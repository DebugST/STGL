<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=0">
<title>STGL</title>
<link rel="stylesheet" type="text/css" href="..//css/stdoc.css"/>
<script type="text/javascript" src="..//js/jquery-1.10.2.min.js"></script>
<script type="text/javascript" src="..//js/stdoc.js"></script>
</head>
<body>
<div id="div_model" style="display:none">BOOK</div>
<div id="div_body">
<div id="div_logo"></div>
<div id="div_left">
<div id="div_left_list">
<ul class='ul_group_root'>
<li>
    <a class='a_node_root anchor_btn' name='a_a' href='#a_a'>欢迎来到 STGL</a>
    <ul>
        <li class='li_node_sub'><a class='anchor_btn' name='a_b' href='#a_b'>编写目的</a></li>
        <li class='li_node_sub'><a class='anchor_btn' name='a_c' href='#a_c'>标注说明</a></li>
    </ul>
</li>
<li>
    <a class='a_node_root anchor_btn' name='a_d' href='#a_d'>项目依赖</a>
    <ul>
        <li class='li_node_sub'><a class='anchor_btn' name='a_e' href='#a_e'>GLFW</a></li>
        <li class='li_node_sub'><a class='anchor_btn' name='a_f' href='#a_f'>GLM</a></li>
        <li class='li_node_sub'><a class='anchor_btn' name='a_g' href='#a_g'>教程所选OpenGL版本</a></li>
    </ul>
</li>
</ul><div class='div_left_space_space'></div>
</div>
<span id="span_time">2022-08-06 -> by:<span>DebugST</span></span>
</div>
<div id="div_right">
<span class='span_location'>STGL<span style='float:right'>2022-08-01</span></span><h1 class='h_title anchor_point' name='a_a'>欢迎来到 STGL</h1>
<p><span class='mark'>STGL</span>是<span class='mark'>.Net</span>对<span class='mark'>OpenGL</span>的一个封装，目前功能尚未完善仅仅是将原生<span class='mark'>OpenGL</span>的<span class='mark'>核心库</span>函数移植完成，如果以面向过程的方式开发，那么现在的<span class='mark'>STGL</span>已经可以胜任，如果是想要面向对象的方式进行开发的话。。。正在持续开发中。。。<span style='color:pink'>当然不排除作者中途摆烂的情况发生😏因为作者就是一条死咸鱼</span>。</p>
<p>等等。。<span class='mark'>.Net</span>版本的<span class='mark'>OpenGL</span>？不是有<span class='mark'>SharpGL</span>和<span class='mark'>OpenTK</span>项目吗？为什么还要在编写一个？。。。你管我？你在教我做事？</p>
<div class='div_hightlight' style='background-color:skyblue;color:black'>
<p>在这之前作者并未进行过任何的<span class='mark'>OpenGL</span>项目开发，即便在开发此项目时也未曾做过任何<span class='mark'>OpenGL</span>的学习，因为仅仅是封装原生<span class='mark'>C</span>语言的函数到<span class='mark'>.Net</span>中是不需要<span class='mark'>OpenGL</span>经验的😏。</p>
<p>此教程是在<span class='mark'>STGL</span>项目在第一版本发布后才开始编写的，也可以看做是作者开始学习<span class='mark'>OpenGL</span>的笔记。并且在学习的过程中作者也会不断的将一些函数封装成类。所以此教程的进度也可以看做是<span class='mark'>STGL-2.0</span>的开发进度。</p>
<p><span style='color:darkred'>如果长期没有更新，极有可能说明作者已经摆烂或者步入仙境了。</span></p>
</div>
<div><h2 class='h_option anchor_point' name='a_b'>编写目的</h2></div>
<p>此教程源于<a class='mark' target='_blank' href='https://learnopengl.com'>learnopengl.com</a>。虽然也有中文翻译版本，如<a class='mark' target='_blank' href='https://learnopengl-cn.github.io'>learnopengl-cn.github.io</a>，那么为什么还要再编写一遍呢？</p>
<p>因为作者也想学习一下<span class='mark'>OpenGL</span>，而刚才已经提到此教程可以看做是作者对于<span class='mark'>OpenGL</span>的学习笔记。并且在<span class='mark'>learopengl</span>中的教程是<span class='mark'>C</span>语言的，既然<span class='mark'>STGL</span>已经将<span class='mark'>OpenGL</span>移植到了<span class='mark'>.Net</span>中，那么为什么不用<span class='mark'>.Net</span>的方式编写一个教程呢？</p>
<p>当然如果<span class='mark'>STGL</span>仅仅是将原生的<span class='mark'>OpenGL</span>函数封装到了<span class='mark'>.Net</span>中那确实没有必要再编写一份教程，但是在随着作者不断学习<span class='mark'>OpenGL</span>的过程中，会不断的把一些原生函数封装成<span class='mark'>class</span>，而此教程的目的是介绍如何使用这些封装好的<span class='mark'>class</span>进行面向对象的开发，而不是面向过程。<span style='color:pink'>（当然。。。作者肯定是这么想的）</span></p>
<p>还有就是。。。<span style='color:pink'>此教程基本抄袭至上面两个网站😎。</span></p>
<div><h2 class='h_option anchor_point' name='a_c'>标注说明</h2></div>
<p>在接下来的教程中，你可能会时常看到如下的方框，它们分别代表着不同类型的提示。</p>
<div class='div_hightlight' style='background-color:yellowgreen;color:black'>
<p>此框的内容表示一些方便的技巧，应当尽量使用。</p>
</div>
<div class='div_hightlight' style='background-color:goldenrod;color:black'>
<p>此框的内容表示一些警告信息，需要注意的地方，应当尽可能的避免。</p>
</div>
<div class='div_hightlight' style='background-color:pink;color:black'>
<p>此框的内容表示一些可能会出现错误的信息，应当尽可能的避免。</p>
</div>
<div class='div_hightlight' style='background-color:skyblue;color:black'>
<p>此框的内容表示一些特别说明。</p>
</div>
<h1 class='h_title anchor_point' name='a_d'>项目依赖</h1>
<div class='div_table'>
<table>
<tr><th>项目</th><th>地址</th><th>备注</th></tr>
<tr><td>GLFW</td><td><a class='mark' target='_blank' href='https://www.glfw.org/'>https://www.glfw.org/</a></td><td>(V3.3.7)内嵌（跨平台原生窗口创建，绘图总需要一个窗口吧？）</td></tr>
<tr class='tr_hight'><td>GLM</td><td><a class='mark' target='_blank' href='https://glm.g-truc.net'>https://glm.g-truc.net</a></td><td>(V0.9.3)移植（数学运算库，用于坐标系之间的转换。）</td></tr>
</table>
</div>
<div><h2 class='h_option anchor_point' name='a_e'>GLFW</h2></div>
<p><span class='mark'>GLFW</span>是一个开源的多平台库，用于桌面上的<span class='mark'>OpenGL</span><span class='mark'>OpenGL ES</span>和<span class='mark'>Vulkan</span>开发。它提供了一个简单的<span class='mark'>API</span>，用于创建窗口、上下文等，管理鼠标键盘的接收输入和事件。</p>
<p>我们渲染总需要一个窗口展示吧？是啊，可能你会觉得<span class='mark'>new Form()</span>不就可以得到一个窗口了吗？但是。。有没有一种可能，你更希望你的程序是可以跨平台的？</p>
<p>当然能做这个事情的不止有<span class='mark'>GLFW</span>同样的项目还有一些其他的，比如：<span class='mark'>GLUT</span>。当然作者这里选择了<span class='mark'>GLFW</span>。</p>
<p><span class='mark'>STGL</span>已经将<span class='mark'>GLFW</span>的库内嵌到了<span class='mark'>STGL</span>的资源中，运行项目的时候将会自动判断当前运行环境并解压其中一个以及相关<span class='mark'>LICENSE</span>至<span class='mark'>runtime</span>目录中。内嵌资源支持的运行环境如下：</p>
<div class='div_table'>
<table>
<tr><th>系统</th><th>架构</th><th>软件</th></tr>
<tr><td>Windows</td><td>NT</td><td>32-bit</td></tr>
<tr class='tr_hight'><td>Windows</td><td>NT</td><td>64-bit</td></tr>
<tr><td>Mac</td><td>X86_64</td><td>64-bit</td></tr>
<tr class='tr_hight'><td>Mac</td><td>Arm64</td><td>64-bit</td></tr>
</table>
</div>
<p>如果需要在<span class='mark'>linux</span>或者其他平台中尝试运行可能需要自己手动编译<span class='mark'>GLFW</span>的源码。作者尝试过编译一些<span class='mark'>linux</span>的库发现程序很难在另一台<span class='mark'>linux</span>中运行即便是同一个系统。</p>
<p>因为<span class='mark'>linux</span>的自由性，导致很多发行版的桌面环境并不统一。如果需要很畅通的进行移植需要编译很多版本的<span class='mark'>SO</span>文件内嵌在<span class='mark'>STGL</span>中，而且还不一定在目标平台上能正常运行，所以有需要的同学请手工编译<span class='mark'>GLFW</span>并且将编译好的<span class='mark'>SO</span>文件拷贝到<span class='mark'>runtime目录中</span>并命名为<span class='mark'>glfw3.so</span></p>
<p>编译方式请参考官网教程：</p>
<p><a class='mark' target='_blank' href='https://www.glfw.org/docs/latest/compile_guide.html#compile_deps_x11'>https://www.glfw.org/docs/latest/compile_guide.html#compile_deps_x11</a></p>
<p>在<span class='mark'>CMake</span>的时候请加上<span class='mark'>-D BUILD_SHARED_LIBS=ON</span>不然不会生成<span class='mark'>SO</span>文件。</p>
<div><h2 class='h_option anchor_point' name='a_f'>GLM</h2></div>
<p><span class='mark'>GLM</span>是一个数学运算库，包涵大量的<span class='mark'>Matrix</span>和<span class='mark'>Vector</span>以及它们的运算方式。从<span class='mark'>learnopengl</span>的<a class='mark' target='_blank' href='https://learnopengl.com/Getting-started/Transformations'>Transformations</a>章节开始提到它，并且在章节内也有讲解一些<span class='mark'>Vector</span>和<span class='mark'>Matrix</span>的运算。并且作者一开始也按照教程讲解的方式编写了<span class='mark'>Vector</span>和<span class='mark'>Matrix</span>类。可是事后作者发现事情并没有这么简单。</p>
<p>在<span class='mark'>learnopengl</span>的教程中仅仅提到了3种类型的矩阵构造<span class='mark'>translate</span><span class='mark'>rotate</span><span class='mark'>scale</span>。通常情况下坐标系的变换也确实是这三种，可是在<span class='mark'>OpenGL</span>中并不是只有坐标系的变换那么简单，还有坐标系的转换，需要构建的矩阵远不止这3中。所以作为学渣的作者学习了两晚上的<span class='mark'>线性代数</span>后，果断决定去抄作业。学习现代？开玩笑。。。这辈子都不可能去学的。</p>
<p>所以作者抄的作业就是<span class='mark'>GLM</span>，之所以选择抄<span class='mark'>GLM</span>还有一个原因。矩阵的内存布局。在<span class='mark'>OpenGL</span>的<span class='mark'>Shader</span>中矩阵是以<span class='mark'>列</span>存储优先的而不是<span class='mark'>行</span>存储优先。<span style='color:pink'>其实就是因为<span class='mark'>learnopengl</span>中使用的也是<span class='mark'>glm</span>🤐🤐🤐</span></p>
<div class='div_hightlight' style='background-color:goldenrod;color:black'>
<p>通常情况下一个<span class='mark'>4X4</span>矩阵<span class='mark'>matrix[1][2]</span>表示的是矩阵中第<span class='mark'>1</span>行第<span class='mark'>2</span>列的数据，可是<span class='mark'>OpenGL</span>是反过来的，所以作者在一开始自己编写的矩阵代码中，无论怎么测试都是没有问题的，可是一旦将矩阵传递给<span class='mark'>shader</span>他就不灵了。。。</p>
<p>后来去查看<span class='mark'>GLM</span>的代码发现<span class='mark'>Matrix * Vector</span>的代码并不是<span class='mark'>行 * 列</span>的方式，而是用的矩阵的<span class='mark'>列</span>去做的运算。至于为什么<span class='mark'>OpenGL</span>采用<span class='mark'>列</span>存储优先读者可以自己去查询相关资料。事实上似乎在微软的<span class='mark'>DX</span>内部，矩阵也是采用的<span class='mark'>列</span>存储优先，虽然传入的矩阵是<span class='mark'>行</span>存储优先的，接口在收到矩阵后会进行自动翻转。</p>
</div>
<div class='div_hightlight' style='background-color:pink;color:black'>
<p>目前作者并没有抄完<span class='mark'>GLM</span>中所有的代码，只是在学习过程中用到了什么函数再去移植什么函数。</p>
</div>
<div><h2 class='h_option anchor_point' name='a_g'>教程所选OpenGL版本</h2></div>
<p>此教程采用<span class='mark'>OpenGL-3.3</span>的版本。因为从<span class='mark'>OpenGL-3.2</span>开始进行了重大更新。至于为什么。。从这句话结束作者就要开始抄袭了。</p>
<div class='div_hightlight' style='background-color:black'>
<p>早期的<span class='mark'>OpenGL</span>使用立即渲染模式（<span class='mark'>Immediate mode</span>，也就是<span class='mark'>固定渲染管线</span>），这个模式下绘制图形很方便。<span class='mark'>OpenGL</span>的大多数功能都被库隐藏起来，开发者很少有控制<span class='mark'>OpenGL</span>如何进行计算的自由。而开发者迫切希望能有更多的灵活性。随着时间推移，规范越来越灵活，开发者对绘图细节有了更多的掌控。立即渲染模式确实容易使用和理解，但是效率太低。因此从<span class='mark'>OpenGL-3.2</span>开始，规范文档开始废弃立即渲染模式，并鼓励开发者在<span class='mark'>OpenGL</span>的核心模式<span class='mark'>Core-profile</span>下进行开发，这个分支的规范完全移除了旧的特性。</p>
<p>当使用<span class='mark'>OpenGL</span>的核心模式时，<span class='mark'>OpenGL</span>迫使我们使用现代的函数。当我们试图使用一个已废弃的函数时，OpenGL会抛出一个错误并终止绘图。现代函数的优势是更高的灵活性和效率，然而也更难于学习。立即渲染模式从<span class='mark'>OpenGL</span>实际运作中抽象掉了很多细节，因此它在易于学习的同时，也很难让人去把握<span class='mark'>OpenGL</span>具体是如何运作的。现代函数要求使用者真正理解<span class='mark'>OpenGL</span>和图形编程，它有一些难度，然而提供了更多的灵活性，更高的效率，更重要的是可以更深入的理解图形编程。</p>
<p>这也是为什么我们的教程面向<span class='mark'>OpenGL-3.3</span>的核心模式。虽然上手更困难，但这份努力是值得的。</p>
<p>现今，更高版本的<span class='mark'>OpenGL</span>已经发布（写作时最新版本为4.6），你可能会问：既然<span class='mark'>OpenGL-4.6</span>都出来了，为什么我们还要学习<span class='mark'>OpenGL-3.3</span>？答案很简单，所有<span class='mark'>OpenGL</span>的更高的版本都是在<span class='mark'>3.3</span>的基础上，引入了额外的功能，并没有改动核心架构。新版本只是引入了一些更有效率或更有用的方式去完成同样的功能。因此，所有的概念和技术在现代<span class='mark'>OpenGL</span>版本里都保持一致。当你的经验足够，你可以轻松使用来自更高版本<span class='mark'>OpenGL</span>的新特性。</p>
</div>
<div class='div_hightlight' style='background-color:pink;color:black'>
<p>当使用新版本的<span class='mark'>OpenGL</span>特性时，只有新一代的显卡能够支持你的应用程序。这也是为什么大多数开发者基于较低版本的<span class='mark'>OpenGL</span>编写程序，并只提供选项启用新版本的特性。</p>
</div>
<p>好了抄袭完了 接下来：阅读愉快:)</p>

</div>
<div id="div_right_list">
<a name='a_a' href='#a_a'>欢迎来到 STGL</a>
<a name='a_b' href='#a_b'>编写目的</a>
<a name='a_c' href='#a_c'>标注说明</a>
<a name='a_d' href='#a_d'>项目依赖</a>
<a name='a_e' href='#a_e'>GLFW</a>
<a name='a_f' href='#a_f'>GLM</a>
<a name='a_g' href='#a_g'>教程所选OpenGL版本</a>
</div>
</div>
</body>
</html>
