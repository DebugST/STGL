#T 欢迎来到 STGL

`STGL`是`.Net`对`OpenGL`的一个封装，目前功能尚未完善仅仅是将原生`OpenGL`的`核心库`函数移植完成，如果以面向过程的方式开发，那么现在的`STGL`已经可以胜任，如果是想要面向对象的方式进行开发的话。。。正在持续开发中。。。[pink|当然不排除作者中途摆烂的情况发生😏因为作者就是一条死咸鱼]。
等等。。`.Net`版本的`OpenGL`？不是有`SharpGL`和`OpenTK`项目吗？为什么还要在编写一个？。。。你管我？你在教我做事？

#HS skyblue|black
在这之前作者并未进行过任何的`OpenGL`项目开发，即便在开发此项目时也未曾做过任何`OpenGL`的学习，因为仅仅是封装原生`C`语言的函数到`.Net`中是不需要`OpenGL`经验的😏。
此教程是在`STGL`项目在第一版本发布后才开始编写的，也可以看做是作者开始学习`OpenGL`的笔记。并且在学习的过程中作者也会不断的将一些函数封装成类。所以此教程的进度也可以看做是`STGL-2.0`的开发进度。
[darkred|如果长期没有更新，极有可能说明作者已经摆烂或者步入仙境了。]
#HE

#O 编写目的

此教程源于[learnopengl.com](https://learnopengl.com)。虽然也有中文翻译版本，如[learnopengl-cn.github.io](https://learnopengl-cn.github.io)，那么为什么还要再编写一遍呢？
因为作者也想学习一下`OpenGL`，而刚才已经提到此教程可以看做是作者对于`OpenGL`的学习笔记。并且在`learopengl`中的教程是`C`语言的，既然`STGL`已经将`OpenGL`移植到了`.Net`中，那么为什么不用`.Net`的方式编写一个教程呢？
当然如果`STGL`仅仅是将原生的`OpenGL`函数封装到了`.Net`中那确实没有必要再编写一份教程，但是在随着作者不断学习`OpenGL`的过程中，会不断的把一些原生函数封装成`class`，而此教程的目的是介绍如何使用这些封装好的`class`进行面向对象的开发，而不是面向过程。[pink|（当然。。。作者肯定是这么想的）]
还有就是。。。[pink|此教程基本抄袭至上面两个网站😎。]

#O 标注说明

在接下来的教程中，你可能会时常看到如下的方框，它们分别代表着不同类型的提示。

#HS yellowgreen|black
此框的内容表示一些方便的技巧，应当尽量使用。
#HE

#HS goldenrod|black
此框的内容表示一些警告信息，需要注意的地方，应当尽可能的避免。
#HE

#HS pink|black
此框的内容表示一些可能会出现错误的信息，应当尽可能的避免。
#HE

#HS skyblue|black
此框的内容表示一些特别说明。
#HE

#T 项目依赖

#TS 项目|地址|备注
GLFW|[https://www.glfw.org/](https://www.glfw.org/)|(V3.3.7)内嵌（跨平台原生窗口创建，绘图总需要一个窗口吧？）
GLM|[https://glm.g-truc.net](https://glm.g-truc.net)|(V0.9.3)移植（数学运算库，用于坐标系之间的转换。）
#TE

#O GLFW

`GLFW`是一个开源的多平台库，用于桌面上的`OpenGL``OpenGL ES`和`Vulkan`开发。它提供了一个简单的`API`，用于创建窗口、上下文等，管理鼠标键盘的接收输入和事件。
我们渲染总需要一个窗口展示吧？是啊，可能你会觉得`new Form()`不就可以得到一个窗口了吗？但是。。有没有一种可能，你更希望你的程序是可以跨平台的？
当然能做这个事情的不止有`GLFW`同样的项目还有一些其他的，比如：`GLUT`。当然作者这里选择了`GLFW`。
`STGL`已经将`GLFW`的库内嵌到了`STGL`的资源中，运行项目的时候将会自动判断当前运行环境并解压其中一个以及相关`LICENSE`至`runtime`目录中。内嵌资源支持的运行环境如下：

#TS 系统|架构|软件
Windows|NT|32-bit
Windows|NT|64-bit
Mac|X86_64|64-bit
Mac|Arm64|64-bit
#TE

如果需要在`linux`或者其他平台中尝试运行可能需要自己手动编译`GLFW`的源码。作者尝试过编译一些`linux`的库发现程序很难在另一台`linux`中运行即便是同一个系统。
因为`linux`的自由性，导致很多发行版的桌面环境并不统一。如果需要很畅通的进行移植需要编译很多版本的`SO`文件内嵌在`STGL`中，而且还不一定在目标平台上能正常运行，所以有需要的同学请手工编译`GLFW`并且将编译好的`SO`文件拷贝到`runtime目录中`并命名为`glfw3.so`

编译方式请参考官网教程：
[https://www.glfw.org/docs/latest/compile_guide.html#compile_deps_x11](https://www.glfw.org/docs/latest/compile_guide.html#compile_deps_x11)
在`CMake`的时候请加上`-D BUILD_SHARED_LIBS=ON`不然不会生成`SO`文件。

#O GLM

`GLM`是一个数学运算库，包涵大量的`Matrix`和`Vector`以及它们的运算方式。从`learnopengl`的[Transformations](https://learnopengl.com/Getting-started/Transformations)章节开始提到它，并且在章节内也有讲解一些`Vector`和`Matrix`的运算。并且作者一开始也按照教程讲解的方式编写了`Vector`和`Matrix`类。可是事后作者发现事情并没有这么简单。
在`learnopengl`的教程中仅仅提到了3种类型的矩阵构造`translate``rotate``scale`。通常情况下坐标系的变换也确实是这三种，可是在`OpenGL`中并不是只有坐标系的变换那么简单，还有坐标系的转换，需要构建的矩阵远不止这3中。所以作为学渣的作者学习了两晚上的`线性代数`后，果断决定去抄作业。学习现代？开玩笑。。。这辈子都不可能去学的。
所以作者抄的作业就是`GLM`，之所以选择抄`GLM`还有一个原因。矩阵的内存布局。在`OpenGL`的`Shader`中矩阵是以`列`存储优先的而不是`行`存储优先。[pink|其实就是因为`learnopengl`中使用的也是`glm`🤐🤐🤐]

#HS goldenrod|black
通常情况下一个`4X4`矩阵`matrix[1][2]`表示的是矩阵中第`1`行第`2`列的数据，可是`OpenGL`是反过来的，所以作者在一开始自己编写的矩阵代码中，无论怎么测试都是没有问题的，可是一旦将矩阵传递给`shader`他就不灵了。。。
后来去查看`GLM`的代码发现`Matrix * Vector`的代码并不是`行 * 列`的方式，而是用的矩阵的`列`去做的运算。至于为什么`OpenGL`采用`列`存储优先读者可以自己去查询相关资料。事实上似乎在微软的`DX`内部，矩阵也是采用的`列`存储优先，虽然传入的矩阵是`行`存储优先的，接口在收到矩阵后会进行自动翻转。
#HE

#HS pink|black
目前作者并没有抄完`GLM`中所有的代码，只是在学习过程中用到了什么函数再去移植什么函数。
#HE

#O 教程所选OpenGL版本

此教程采用`OpenGL-3.3`的版本。因为从`OpenGL-3.2`开始进行了重大更新。至于为什么。。从这句话结束作者就要开始抄袭了。

#HS black

早期的`OpenGL`使用立即渲染模式（`Immediate mode`，也就是`固定渲染管线`），这个模式下绘制图形很方便。`OpenGL`的大多数功能都被库隐藏起来，开发者很少有控制`OpenGL`如何进行计算的自由。而开发者迫切希望能有更多的灵活性。随着时间推移，规范越来越灵活，开发者对绘图细节有了更多的掌控。立即渲染模式确实容易使用和理解，但是效率太低。因此从`OpenGL-3.2`开始，规范文档开始废弃立即渲染模式，并鼓励开发者在`OpenGL`的核心模式`Core-profile`下进行开发，这个分支的规范完全移除了旧的特性。

当使用`OpenGL`的核心模式时，`OpenGL`迫使我们使用现代的函数。当我们试图使用一个已废弃的函数时，OpenGL会抛出一个错误并终止绘图。现代函数的优势是更高的灵活性和效率，然而也更难于学习。立即渲染模式从`OpenGL`实际运作中抽象掉了很多细节，因此它在易于学习的同时，也很难让人去把握`OpenGL`具体是如何运作的。现代函数要求使用者真正理解`OpenGL`和图形编程，它有一些难度，然而提供了更多的灵活性，更高的效率，更重要的是可以更深入的理解图形编程。

这也是为什么我们的教程面向`OpenGL-3.3`的核心模式。虽然上手更困难，但这份努力是值得的。

现今，更高版本的`OpenGL`已经发布（写作时最新版本为4.6），你可能会问：既然`OpenGL-4.6`都出来了，为什么我们还要学习`OpenGL-3.3`？答案很简单，所有`OpenGL`的更高的版本都是在`3.3`的基础上，引入了额外的功能，并没有改动核心架构。新版本只是引入了一些更有效率或更有用的方式去完成同样的功能。因此，所有的概念和技术在现代`OpenGL`版本里都保持一致。当你的经验足够，你可以轻松使用来自更高版本`OpenGL`的新特性。

#HE

#HS pink|black
当使用新版本的`OpenGL`特性时，只有新一代的显卡能够支持你的应用程序。这也是为什么大多数开发者基于较低版本的`OpenGL`编写程序，并只提供选项启用新版本的特性。
#HE

好了抄袭完了 接下来：阅读愉快:)
