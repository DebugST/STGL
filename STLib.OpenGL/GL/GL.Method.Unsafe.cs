using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Runtime.InteropServices;

namespace STLib.OpenGL.GL
{
    partial class GL    // GL.Method.Unsafe
    {
        /**********************************************************************************
         * Originally these functions contained pointers, but the author felt that 
         * it was an unfriendly practice in C# to let developers call functions 
         * containing pointers. Because the Unsafe code feature needs to be enabled. 
         * And I guess C# developers probably don't like pointers.
         * 
         * So the author converts all [XXX*] to [ref XXX] and [XXX**] to [IntPtr].
         * such as: (int* param) to (ref int param), (byte** param) to (IntPtr param)
         * But [void*] is not converted to [ref void] but [IntPtr].
         * 
         * For a single pointer, the developer can still call it very friendly, 
         * but it may be troublesome for the IntPtr type, 
         * and the parameter needs to be converted to the IntPtr type.
         * 
         * For the case of [XXX*]:
         * [XXX*] has been converted to [ref XXX]. Can be called very friendly.
         * the parameter may be a parameter of type XXX or it may be an array of XXX. 
         * But if the parameter is an array how should it be passed?
         *     XXX x = value;
         *     MethodName(ref x);
         *     XXX[] xs = new XXX[count];
         *     MethodName(ref xs[0]);
         *     
         * For the case of [XXX**] or [void*]
         * [XXX**] or [void*] has been converted to [IntPtr].
         * [XXX**] is always [byte**](string[]), [void**](IntPtr[]), [uint**](uint[][]), [bool**](bool[][])
         * ********************************************************************************
         * Note: These codes are automatically created from OpenGL's documentation.
         *       If there is something wrong, it must be because the author is too stupid.
         * Link: https://github.com/KhronosGroup/OpenGL-Registry/xml/gl.xml
         *       https://github.com/KhronosGroup/OpenGL-Refpages/tree/main/gl2.1
         *       https://github.com/KhronosGroup/OpenGL-Refpages/tree/main/gl4
         **********************************************************************************/

        #region GL_VERSION_1_0

        /// <summary>
        /// set texture parameters
        /// <para>Require:</para> <para>GL_VERSION_1_0, GL_VERSION_ES_CM_1_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <code>GL_TEXTURE_3D</code>, <code>GL_TEXTURE_MIN_LOD</code>, <code>GL_TEXTURE_MAX_LOD</code>,
        /// <code>GL_CLAMP_TO_EDGE</code>, <code>GL_TEXTURE_BASE_LEVEL</code>, and <code>GL_TEXTURE_MAX_LEVEL</code> are
        /// available only if the GL version is 1.2 or greater.
        /// <code>GL_CLAMP_TO_BORDER</code> is available only if the GL version is 1.3 or greater.
        /// <code>GL_MIRRORED_REPEAT</code>, <code>GL_TEXTURE_COMPARE_MODE</code>,
        /// <code>GL_TEXTURE_COMPARE_FUNC</code>, <code>GL_DEPTH_TEXTURE_MODE</code>, and
        /// <code>GL_GENERATE_MIPMAP</code> are available only if the GL version is 1.4 or
        /// greater.
        /// <code>GL_TEXTURE_COMPARE_FUNC</code> allows the following additional comparison modes only
        /// if the GL version is 1.5 or greater:
        /// <code>GL_LESS</code>, <code>GL_GREATER</code>,
        /// <code>GL_EQUAL</code>, <code>GL_NOTEQUAL</code>,
        /// <code>GL_ALWAYS</code>, and <code>GL_NEVER</code>.
        /// Suppose that a program has enabled texturing (by calling  <see cref="glEnable"/>  with
        /// argument <code>GL_TEXTURE_1D</code>, <code>GL_TEXTURE_2D</code>, or <code>GL_TEXTURE_3D</code>) and
        /// has set <code>GL_TEXTURE_MIN_FILTER</code> to one of the functions that requires a
        /// mipmap.  If either the dimensions of the texture images currently defined
        /// (with previous calls to  <see cref="glTexImage1D"/> ,  <see cref="glTexImage2D"/> ,
        /// <see cref="glTexImage3D"/> ,  <see cref="glCopyTexImage1D"/> , or  <see cref="glCopyTexImage2D"/> ) do not
        /// follow the proper sequence for mipmaps (described above), or there are
        /// fewer texture images defined than are needed, or the set of texture images
        /// have differing numbers of texture components, then it is as if texture
        /// mapping were disabled.
        /// Linear filtering accesses the four nearest texture elements only in 2D
        /// textures.  In 1D textures, linear filtering accesses the two nearest
        /// texture elements.
        /// For OpenGL versions 1.3 and greater, or when the <code>ARB_multitexture</code> extension is supported, <see cref="glTexParameter"/>
        /// specifies the texture parameters for the active texture unit, specified
        /// by calling  <see cref="glActiveTexture"/> .
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="target"/> or <paramref name="pname"/> is not
        /// one of the accepted defined values.
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="ps"/> should have a defined
        /// constant value (based on the value of <paramref name="pname"/>) and does not.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glTexParameter"/> is executed between the
        /// execution of  <see cref="glBegin"/>  and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glTexParameterfv(GLenum target, GLenum pname, const GLfloat * params);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target texture,
        /// which must be either <code>GL_TEXTURE_1D</code>, <code>GL_TEXTURE_2D</code> or
        /// <code>GL_TEXTURE_3D</code>.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of a texture parameter.
        /// <paramref name="pname"/> can be one of the following:
        /// <code>GL_TEXTURE_MIN_FILTER</code>,
        /// <code>GL_TEXTURE_MAG_FILTER</code>,
        /// <code>GL_TEXTURE_MIN_LOD</code>,
        /// <code>GL_TEXTURE_MAX_LOD</code>,
        /// <code>GL_TEXTURE_BASE_LEVEL</code>,
        /// <code>GL_TEXTURE_MAX_LEVEL</code>,
        /// <code>GL_TEXTURE_WRAP_S</code>,
        /// <code>GL_TEXTURE_WRAP_T</code>,
        /// <code>GL_TEXTURE_WRAP_R</code>,
        /// <code>GL_TEXTURE_BORDER_COLOR</code>,
        /// <code>GL_TEXTURE_PRIORITY</code>,
        /// <code>GL_TEXTURE_COMPARE_MODE</code>,
        /// <code>GL_TEXTURE_COMPARE_FUNC</code>,
        /// <code>GL_DEPTH_TEXTURE_MODE</code>, or
        /// <code>GL_GENERATE_MIPMAP</code>.
        /// </para>
        /// </param>
        /// <param name="ps">
        /// <para>
        /// Specifies a pointer to an array where the value or values of <paramref name="pname"/>
        /// are stored.
        /// </para>
        /// </param>
        /// <seealso cref="ActiveTexture"/>
        /// <seealso cref="BindTexture"/>
        /// <seealso cref="CopyPixels"/>
        /// <seealso cref="CopyTexImage1D"/>
        /// <seealso cref="CopyTexImage2D"/>
        /// <seealso cref="CopyTexSubImage1D"/>
        /// <seealso cref="CopyTexSubImage2D"/>
        /// <seealso cref="CopyTexSubImage3D"/>
        /// <seealso cref="DrawPixels"/>
        /// <seealso cref="PixelStore"/>
        /// <seealso cref="PixelTransfer"/>
        /// <seealso cref="PrioritizeTextures"/>
        /// <seealso cref="TexEnv"/>
        /// <seealso cref="TexGen"/>
        /// <seealso cref="TexImage1D"/>
        /// <seealso cref="TexImage2D"/>
        /// <seealso cref="TexImage3D"/>
        /// <seealso cref="TexSubImage1D"/>
        /// <seealso cref="TexSubImage2D"/>
        /// <seealso cref="TexSubImage3D"/>
        public unsafe static void TexParameterfv(uint target, uint pname, ref float ps) {
            fixed (float* pPs = &ps) {
                GLNative.glTexParameterfv(target, pname, pPs);
            }
        }

        /// <summary>
        /// set texture parameters
        /// <para>Require:</para> <para>GL_VERSION_1_0, GL_VERSION_ES_CM_1_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <code>GL_TEXTURE_3D</code>, <code>GL_TEXTURE_MIN_LOD</code>, <code>GL_TEXTURE_MAX_LOD</code>,
        /// <code>GL_CLAMP_TO_EDGE</code>, <code>GL_TEXTURE_BASE_LEVEL</code>, and <code>GL_TEXTURE_MAX_LEVEL</code> are
        /// available only if the GL version is 1.2 or greater.
        /// <code>GL_CLAMP_TO_BORDER</code> is available only if the GL version is 1.3 or greater.
        /// <code>GL_MIRRORED_REPEAT</code>, <code>GL_TEXTURE_COMPARE_MODE</code>,
        /// <code>GL_TEXTURE_COMPARE_FUNC</code>, <code>GL_DEPTH_TEXTURE_MODE</code>, and
        /// <code>GL_GENERATE_MIPMAP</code> are available only if the GL version is 1.4 or
        /// greater.
        /// <code>GL_TEXTURE_COMPARE_FUNC</code> allows the following additional comparison modes only
        /// if the GL version is 1.5 or greater:
        /// <code>GL_LESS</code>, <code>GL_GREATER</code>,
        /// <code>GL_EQUAL</code>, <code>GL_NOTEQUAL</code>,
        /// <code>GL_ALWAYS</code>, and <code>GL_NEVER</code>.
        /// Suppose that a program has enabled texturing (by calling  <see cref="glEnable"/>  with
        /// argument <code>GL_TEXTURE_1D</code>, <code>GL_TEXTURE_2D</code>, or <code>GL_TEXTURE_3D</code>) and
        /// has set <code>GL_TEXTURE_MIN_FILTER</code> to one of the functions that requires a
        /// mipmap.  If either the dimensions of the texture images currently defined
        /// (with previous calls to  <see cref="glTexImage1D"/> ,  <see cref="glTexImage2D"/> ,
        /// <see cref="glTexImage3D"/> ,  <see cref="glCopyTexImage1D"/> , or  <see cref="glCopyTexImage2D"/> ) do not
        /// follow the proper sequence for mipmaps (described above), or there are
        /// fewer texture images defined than are needed, or the set of texture images
        /// have differing numbers of texture components, then it is as if texture
        /// mapping were disabled.
        /// Linear filtering accesses the four nearest texture elements only in 2D
        /// textures.  In 1D textures, linear filtering accesses the two nearest
        /// texture elements.
        /// For OpenGL versions 1.3 and greater, or when the <code>ARB_multitexture</code> extension is supported, <see cref="glTexParameter"/>
        /// specifies the texture parameters for the active texture unit, specified
        /// by calling  <see cref="glActiveTexture"/> .
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="target"/> or <paramref name="pname"/> is not
        /// one of the accepted defined values.
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="ps"/> should have a defined
        /// constant value (based on the value of <paramref name="pname"/>) and does not.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glTexParameter"/> is executed between the
        /// execution of  <see cref="glBegin"/>  and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glTexParameteriv(GLenum target, GLenum pname, const GLint * params);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target texture,
        /// which must be either <code>GL_TEXTURE_1D</code>, <code>GL_TEXTURE_2D</code> or
        /// <code>GL_TEXTURE_3D</code>.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of a texture parameter.
        /// <paramref name="pname"/> can be one of the following:
        /// <code>GL_TEXTURE_MIN_FILTER</code>,
        /// <code>GL_TEXTURE_MAG_FILTER</code>,
        /// <code>GL_TEXTURE_MIN_LOD</code>,
        /// <code>GL_TEXTURE_MAX_LOD</code>,
        /// <code>GL_TEXTURE_BASE_LEVEL</code>,
        /// <code>GL_TEXTURE_MAX_LEVEL</code>,
        /// <code>GL_TEXTURE_WRAP_S</code>,
        /// <code>GL_TEXTURE_WRAP_T</code>,
        /// <code>GL_TEXTURE_WRAP_R</code>,
        /// <code>GL_TEXTURE_BORDER_COLOR</code>,
        /// <code>GL_TEXTURE_PRIORITY</code>,
        /// <code>GL_TEXTURE_COMPARE_MODE</code>,
        /// <code>GL_TEXTURE_COMPARE_FUNC</code>,
        /// <code>GL_DEPTH_TEXTURE_MODE</code>, or
        /// <code>GL_GENERATE_MIPMAP</code>.
        /// </para>
        /// </param>
        /// <param name="ps">
        /// <para>
        /// Specifies a pointer to an array where the value or values of <paramref name="pname"/>
        /// are stored.
        /// </para>
        /// </param>
        /// <seealso cref="ActiveTexture"/>
        /// <seealso cref="BindTexture"/>
        /// <seealso cref="CopyPixels"/>
        /// <seealso cref="CopyTexImage1D"/>
        /// <seealso cref="CopyTexImage2D"/>
        /// <seealso cref="CopyTexSubImage1D"/>
        /// <seealso cref="CopyTexSubImage2D"/>
        /// <seealso cref="CopyTexSubImage3D"/>
        /// <seealso cref="DrawPixels"/>
        /// <seealso cref="PixelStore"/>
        /// <seealso cref="PixelTransfer"/>
        /// <seealso cref="PrioritizeTextures"/>
        /// <seealso cref="TexEnv"/>
        /// <seealso cref="TexGen"/>
        /// <seealso cref="TexImage1D"/>
        /// <seealso cref="TexImage2D"/>
        /// <seealso cref="TexImage3D"/>
        /// <seealso cref="TexSubImage1D"/>
        /// <seealso cref="TexSubImage2D"/>
        /// <seealso cref="TexSubImage3D"/>
        public unsafe static void TexParameteriv(uint target, uint pname, ref int ps) {
            fixed (int* pPs = &ps) {
                GLNative.glTexParameteriv(target, pname, pPs);
            }
        }

        /// <summary>
        /// specify a one-dimensional texture image
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// Texturing has no effect in color index mode.
        /// If the <code>ARB_imaging</code> extension is supported, RGBA elements may
        /// also be processed by the imaging pipeline.  The following stages may be
        /// applied to an RGBA color before color component clamping to the range
        /// 0 
        /// 1 
        /// :
        /// 1. Color component replacement by the color table specified for 
        /// <code>GL_COLOR_TABLE</code>, if enabled. See  <see cref="glColorTable"/> .
        /// 2. One-dimensional convolution filtering, if enabled. See 
        /// <see cref="glConvolutionFilter1D"/> .
        /// If a convolution filter changes the <paramref name="width"/> of the texture (by
        /// processing with a <code>GL_CONVOLUTION_BORDER_MODE</code> of <code>GL_REDUCE</code>, for
        /// example), the <paramref name="width"/> must 
        /// 2 
        /// n 
        /// + 
        /// 2 
        /// &af; 
        /// border 
        /// ,
        /// for some
        /// integer 
        /// n   ,
        /// after filtering.
        /// 3. RGBA components may be multiplied by <code>GL_POST_CONVOLUTION_c_SCALE</code>, 
        /// and added to <code>GL_POST_CONVOLUTION_c_BIAS</code>, if enabled.  See
        /// <see cref="glPixelTransfer"/> .
        /// 4. Color component replacement by the color table specified for 
        /// <code>GL_POST_CONVOLUTION_COLOR_TABLE</code>, if enabled.  See  <see cref="glColorTable"/> .
        /// 5. Transformation by the color matrix. 
        /// See  <see cref="glMatrixMode"/> .
        /// 6. RGBA components may be multiplied by <code>GL_POST_COLOR_MATRIX_c_SCALE</code>, 
        /// and added to <code>GL_POST_COLOR_MATRIX_c_BIAS</code>, if enabled.  See
        /// <see cref="glPixelTransfer"/> .
        /// 7. Color component replacement by the color table specified for 
        /// <code>GL_POST_COLOR_MATRIX_COLOR_TABLE</code>, if enabled.  See  <see cref="glColorTable"/> .
        /// The texture image can be represented by the same data formats
        /// as the pixels in a  <see cref="glDrawPixels"/>  command,
        /// except that <code>GL_STENCIL_INDEX</code>
        /// cannot be used.
        /// <see cref="glPixelStore"/>  and  <see cref="glPixelTransfer"/>  modes affect texture images
        /// in exactly the way they affect  <see cref="glDrawPixels"/> .
        /// <code>GL_PROXY_TEXTURE_1D</code> may be used only if the GL version is 1.1 or greater.
        /// Internal formats other than 1, 2, 3, or 4 may be
        /// used only if the GL version is 1.1 or greater.
        /// In GL version 1.1 or greater,
        /// <paramref name="data"/> may be a null pointer. In this case texture memory is
        /// allocated to accommodate a texture of width <paramref name="width"/>.
        /// You can then download subtextures to initialize the
        /// texture memory. The image is undefined if the program tries to apply
        /// an uninitialized portion of the texture image to a primitive.
        /// Formats <code>GL_BGR</code>, and <code>GL_BGRA</code> and types
        /// <code>GL_UNSIGNED_BYTE_3_3_2</code>,
        /// <code>GL_UNSIGNED_BYTE_2_3_3_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_5_6_5</code>,
        /// <code>GL_UNSIGNED_SHORT_5_6_5_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_4_4_4_4</code>,
        /// <code>GL_UNSIGNED_SHORT_4_4_4_4_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_5_5_5_1</code>,
        /// <code>GL_UNSIGNED_SHORT_1_5_5_5_REV</code>,
        /// <code>GL_UNSIGNED_INT_8_8_8_8</code>,
        /// <code>GL_UNSIGNED_INT_8_8_8_8_REV</code>,
        /// <code>GL_UNSIGNED_INT_10_10_10_2</code>, and
        /// <code>GL_UNSIGNED_INT_2_10_10_10_REV</code> are available only if the GL version
        /// is 1.2 or greater.
        /// When the <code>ARB_multitexture</code> extension is supported, or the GL version is 1.3 or greater, <see cref="glTexImage1D"/>
        /// specifies the one-dimensional texture for the current texture unit,
        /// specified with  <see cref="glActiveTexture"/> .
        /// <code>GL_DEPTH_COMPONENT</code>, <code>GL_DEPTH_COMPONENT16</code>,
        /// <code>GL_DEPTH_COMPONENT24</code>, and <code>GL_DEPTH_COMPONENT32</code> are available only
        /// if the GL version is 1.4 or greater.
        /// Non-power-of-two textures are supported if the GL version is 2.0 or greater, or if the implementation exports the <code>GL_ARB_texture_non_power_of_two</code> extension.
        /// The 
        /// <code>GL_SRGB</code>,
        /// <code>GL_SRGB8</code>,
        /// <code>GL_SRGB_ALPHA</code>,
        /// <code>GL_SRGB8_ALPHA8</code>,
        /// <code>GL_SLUMINANCE</code>,
        /// <code>GL_SLUMINANCE8</code>,
        /// <code>GL_SLUMINANCE_ALPHA</code>, and
        /// <code>GL_SLUMINANCE8_ALPHA8</code>
        /// internal formats are only available if the GL version is 2.1 or greater.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="target"/> is not <code>GL_TEXTURE_1D</code>
        /// or <code>GL_PROXY_TEXTURE_1D</code>.
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="format"/> is not an accepted
        /// format constant.  Format constants other than <code>GL_STENCIL_INDEX</code>
        /// are accepted.
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="type"/> is not a type constant.
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="type"/> is <code>GL_BITMAP</code> and
        /// <paramref name="format"/> is not <code>GL_COLOR_INDEX</code>.
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="level"/> is less than 0.
        /// <code>GL_INVALID_VALUE</code> may be generated if <paramref name="level"/> is greater than 
        /// log 
        /// 2 
        /// &af; 
        /// max 
        /// ,
        /// where  max  is the returned value of <code>GL_MAX_TEXTURE_SIZE</code>.
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="internalFormat"/> is not 1, 2, 3, 4, or
        /// one of the accepted resolution and format symbolic constants.
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="width"/> is less than 0
        /// or greater than 2 + <code>GL_MAX_TEXTURE_SIZE</code>.
        /// <code>GL_INVALID_VALUE</code> is generated if non-power-of-two textures are not supported and the <paramref name="width"/> cannot be represented as
        /// 2 
        /// n 
        /// + 
        /// 2 
        /// &af; 
        /// border 
        /// for some integer value of  n .
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="border"/> is not 0 or 1.
        /// <code>GL_INVALID_OPERATION</code> is generated if <paramref name="type"/> is one of
        /// <code>GL_UNSIGNED_BYTE_3_3_2</code>,
        /// <code>GL_UNSIGNED_BYTE_2_3_3_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_5_6_5</code>, or
        /// <code>GL_UNSIGNED_SHORT_5_6_5_REV</code>
        /// and <paramref name="format"/> is not <code>GL_RGB</code>.
        /// <code>GL_INVALID_OPERATION</code> is generated if <paramref name="type"/> is one of
        /// <code>GL_UNSIGNED_SHORT_4_4_4_4</code>,
        /// <code>GL_UNSIGNED_SHORT_4_4_4_4_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_5_5_5_1</code>,
        /// <code>GL_UNSIGNED_SHORT_1_5_5_5_REV</code>,
        /// <code>GL_UNSIGNED_INT_8_8_8_8</code>,
        /// <code>GL_UNSIGNED_INT_8_8_8_8_REV</code>,
        /// <code>GL_UNSIGNED_INT_10_10_10_2</code>, or
        /// <code>GL_UNSIGNED_INT_2_10_10_10_REV</code>
        /// and <paramref name="format"/> is neither <code>GL_RGBA</code> nor <code>GL_BGRA</code>.
        /// <code>GL_INVALID_OPERATION</code> is generated if <paramref name="format"/> is
        /// <code>GL_DEPTH_COMPONENT</code> and <paramref name="internalFormat"/> is not
        /// <code>GL_DEPTH_COMPONENT</code>, <code>GL_DEPTH_COMPONENT16</code>,
        /// <code>GL_DEPTH_COMPONENT24</code>, or <code>GL_DEPTH_COMPONENT32</code>.
        /// <code>GL_INVALID_OPERATION</code> is generated if <paramref name="internalFormat"/> is
        /// <code>GL_DEPTH_COMPONENT</code>, <code>GL_DEPTH_COMPONENT16</code>,
        /// <code>GL_DEPTH_COMPONENT24</code>, or <code>GL_DEPTH_COMPONENT32</code>, and <paramref name="format"/> is
        /// not <code>GL_DEPTH_COMPONENT</code>.
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_UNPACK_BUFFER</code> target and the buffer object's data store is currently mapped.
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_UNPACK_BUFFER</code> target and the data would be unpacked from the buffer 
        /// object such that the memory reads required would exceed the data store size.
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_UNPACK_BUFFER</code> target and <paramref name="data"/> is not evenly divisible 
        /// into the number of bytes needed to store in memory a datum indicated by <paramref name="type"/>.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glTexImage1D"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glTexImage1D(GLenum target, GLint level, GLint internalFormat, GLsizei width, GLint border, GLenum format, GLenum type, const void * data);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target texture.
        /// Must be <code>GL_TEXTURE_1D</code> or <code>GL_PROXY_TEXTURE_1D</code>.
        /// </para>
        /// </param>
        /// <param name="level">
        /// <para>
        /// Specifies the level-of-detail number.
        /// Level 0 is the base image level.
        /// Level  n  is the  n th mipmap reduction image.
        /// </para>
        /// </param>
        /// <param name="internalFormat">
        /// <para>
        /// Specifies the number of color components in the texture.
        /// Must be 1, 2, 3, or 4, or one of the following symbolic constants:
        /// <code>GL_ALPHA</code>,
        /// <code>GL_ALPHA4</code>,
        /// <code>GL_ALPHA8</code>,
        /// <code>GL_ALPHA12</code>,
        /// <code>GL_ALPHA16</code>,
        /// <code>GL_COMPRESSED_ALPHA</code>,
        /// <code>GL_COMPRESSED_LUMINANCE</code>,
        /// <code>GL_COMPRESSED_LUMINANCE_ALPHA</code>,
        /// <code>GL_COMPRESSED_INTENSITY</code>,
        /// <code>GL_COMPRESSED_RGB</code>,
        /// <code>GL_COMPRESSED_RGBA</code>,
        /// <code>GL_DEPTH_COMPONENT</code>,
        /// <code>GL_DEPTH_COMPONENT16</code>,
        /// <code>GL_DEPTH_COMPONENT24</code>,
        /// <code>GL_DEPTH_COMPONENT32</code>,
        /// <code>GL_LUMINANCE</code>,
        /// <code>GL_LUMINANCE4</code>,
        /// <code>GL_LUMINANCE8</code>,
        /// <code>GL_LUMINANCE12</code>,
        /// <code>GL_LUMINANCE16</code>,
        /// <code>GL_LUMINANCE_ALPHA</code>,
        /// <code>GL_LUMINANCE4_ALPHA4</code>,
        /// <code>GL_LUMINANCE6_ALPHA2</code>,
        /// <code>GL_LUMINANCE8_ALPHA8</code>,
        /// <code>GL_LUMINANCE12_ALPHA4</code>,
        /// <code>GL_LUMINANCE12_ALPHA12</code>,
        /// <code>GL_LUMINANCE16_ALPHA16</code>,
        /// <code>GL_INTENSITY</code>,
        /// <code>GL_INTENSITY4</code>,
        /// <code>GL_INTENSITY8</code>,
        /// <code>GL_INTENSITY12</code>,
        /// <code>GL_INTENSITY16</code>,
        /// <code>GL_R3_G3_B2</code>,
        /// <code>GL_RGB</code>,
        /// <code>GL_RGB4</code>,
        /// <code>GL_RGB5</code>,
        /// <code>GL_RGB8</code>,
        /// <code>GL_RGB10</code>,
        /// <code>GL_RGB12</code>,
        /// <code>GL_RGB16</code>,
        /// <code>GL_RGBA</code>,
        /// <code>GL_RGBA2</code>,
        /// <code>GL_RGBA4</code>,
        /// <code>GL_RGB5_A1</code>,
        /// <code>GL_RGBA8</code>,
        /// <code>GL_RGB10_A2</code>,
        /// <code>GL_RGBA12</code>,
        /// <code>GL_RGBA16</code>,
        /// <code>GL_SLUMINANCE</code>,
        /// <code>GL_SLUMINANCE8</code>,
        /// <code>GL_SLUMINANCE_ALPHA</code>,
        /// <code>GL_SLUMINANCE8_ALPHA8</code>,
        /// <code>GL_SRGB</code>,
        /// <code>GL_SRGB8</code>,
        /// <code>GL_SRGB_ALPHA</code>, or 
        /// <code>GL_SRGB8_ALPHA8</code>.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// Specifies the width of the texture image including the border if any. If the GL version does not support non-power-of-two sizes, this value must be 
        /// 2 
        /// n 
        /// + 
        /// 2 
        /// &af; 
        /// border 
        /// for some integer 
        /// n   .
        /// All
        /// implementations support texture images that are at least 64 texels
        /// wide. The height of the 1D texture image is 1.
        /// </para>
        /// </param>
        /// <param name="border">
        /// <para>
        /// Specifies the width of the border.
        /// Must be either 0 or 1.
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// Specifies the format of the pixel data.
        /// The following symbolic values are accepted:
        /// <code>GL_COLOR_INDEX</code>,
        /// <code>GL_RED</code>,
        /// <code>GL_GREEN</code>,
        /// <code>GL_BLUE</code>,
        /// <code>GL_ALPHA</code>,
        /// <code>GL_RGB</code>,
        /// <code>GL_BGR</code>,
        /// <code>GL_RGBA</code>,
        /// <code>GL_BGRA</code>,
        /// <code>GL_LUMINANCE</code>, and
        /// <code>GL_LUMINANCE_ALPHA</code>.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the data type of the pixel data.
        /// The following symbolic values are accepted:
        /// <code>GL_UNSIGNED_BYTE</code>,
        /// <code>GL_BYTE</code>,
        /// <code>GL_BITMAP</code>,
        /// <code>GL_UNSIGNED_SHORT</code>,
        /// <code>GL_SHORT</code>,
        /// <code>GL_UNSIGNED_INT</code>,
        /// <code>GL_INT</code>,
        /// <code>GL_FLOAT</code>,
        /// <code>GL_UNSIGNED_BYTE_3_3_2</code>,
        /// <code>GL_UNSIGNED_BYTE_2_3_3_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_5_6_5</code>,
        /// <code>GL_UNSIGNED_SHORT_5_6_5_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_4_4_4_4</code>,
        /// <code>GL_UNSIGNED_SHORT_4_4_4_4_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_5_5_5_1</code>,
        /// <code>GL_UNSIGNED_SHORT_1_5_5_5_REV</code>,
        /// <code>GL_UNSIGNED_INT_8_8_8_8</code>,
        /// <code>GL_UNSIGNED_INT_8_8_8_8_REV</code>,
        /// <code>GL_UNSIGNED_INT_10_10_10_2</code>, and
        /// <code>GL_UNSIGNED_INT_2_10_10_10_REV</code>.
        /// </para>
        /// </param>
        /// <param name="data">
        /// Specifies a pointer to the image data in memory.
        /// </param>
        /// <seealso cref="ActiveTexture"/>
        /// <seealso cref="ColorTable"/>
        /// <seealso cref="CompressedTexImage1D"/>
        /// <seealso cref="CompressedTexSubImage1D"/>
        /// <seealso cref="ConvolutionFilter1D"/>
        /// <seealso cref="CopyPixels"/>
        /// <seealso cref="CopyTexImage1D"/>
        /// <seealso cref="CopyTexSubImage1D"/>
        /// <seealso cref="DrawPixels"/>
        /// <seealso cref="GetCompressedTexImage"/>
        /// <seealso cref="MatrixMode"/>
        /// <seealso cref="PixelStore"/>
        /// <seealso cref="PixelTransfer"/>
        /// <seealso cref="TexEnv"/>
        /// <seealso cref="TexGen"/>
        /// <seealso cref="TexImage2D"/>
        /// <seealso cref="TexImage3D"/>
        /// <seealso cref="TexSubImage1D"/>
        /// <seealso cref="TexSubImage2D"/>
        /// <seealso cref="TexSubImage3D"/>
        /// <seealso cref="TexParameter"/>
        public unsafe static void TexImage1D(uint target, int level, int internalFormat, int width, int border, uint format, uint type, IntPtr data) {
            GLNative.glTexImage1D(target, level, internalFormat, width, border, format, type, (void*)data);
        }

        /// <summary>
        /// specify a two-dimensional texture image
        /// <para>Require:</para> <para>GL_VERSION_1_0, GL_VERSION_ES_CM_1_0, GL_ES_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// Texturing has no effect in color index mode.
        /// If the <code>ARB_imaging</code> extension is supported, RGBA elements may
        /// also be processed by the imaging pipeline.  The following stages may be
        /// applied to an RGBA color before color component clamping to the range
        /// 0 
        /// 1 
        /// :
        /// 1. Color component replacement by the color table specified for 
        /// <code>GL_COLOR_TABLE</code>, if enabled. See  <see cref="glColorTable"/> .
        /// 2. Two-dimensional Convolution filtering, if enabled. 
        /// See  <see cref="glConvolutionFilter1D"/> .
        /// If a convolution filter changes the <paramref name="width"/> of the texture (by
        /// processing with a <code>GL_CONVOLUTION_BORDER_MODE</code> of <code>GL_REDUCE</code>, for
        /// example), and the GL does not support non-power-of-two textures, the <paramref name="width"/> must 
        /// 2 
        /// n 
        /// + 
        /// 2 
        /// &af; 
        /// border 
        /// ,
        /// for some
        /// integer 
        /// n   ,
        /// and <paramref name="height"/> must be 
        /// 2 
        /// m 
        /// + 
        /// 2 
        /// &af; 
        /// border 
        /// ,
        /// for some
        /// integer 
        /// m   ,
        /// after filtering.
        /// 3. RGBA components may be multiplied by <code>GL_POST_CONVOLUTION_c_SCALE</code>, 
        /// and added to <code>GL_POST_CONVOLUTION_c_BIAS</code>, if enabled.  See
        /// <see cref="glPixelTransfer"/> .
        /// 4. Color component replacement by the color table specified for 
        /// <code>GL_POST_CONVOLUTION_COLOR_TABLE</code>, if enabled.  See  <see cref="glColorTable"/> .
        /// 5. Transformation by the color matrix. 
        /// See  <see cref="glMatrixMode"/> .
        /// 6. RGBA components may be multiplied by <code>GL_POST_COLOR_MATRIX_c_SCALE</code>, 
        /// and added to <code>GL_POST_COLOR_MATRIX_c_BIAS</code>, if enabled.  See
        /// <see cref="glPixelTransfer"/> .
        /// 7. Color component replacement by the color table specified for 
        /// <code>GL_POST_COLOR_MATRIX_COLOR_TABLE</code>, if enabled.  See  <see cref="glColorTable"/> .
        /// The texture image can be represented by the same data formats
        /// as the pixels in a  <see cref="glDrawPixels"/>  command,
        /// except that <code>GL_STENCIL_INDEX</code>
        /// cannot be used.
        /// <see cref="glPixelStore"/>  and  <see cref="glPixelTransfer"/>  modes affect texture images
        /// in exactly the way they affect  <see cref="glDrawPixels"/> .
        /// <see cref="glTexImage2D"/> and <code>GL_PROXY_TEXTURE_2D</code> are available only if the GL
        /// version is 1.1 or greater.
        /// Internal formats other than 1, 2, 3, or 4 may be used only if the GL
        /// version is 1.1 or greater.
        /// In GL version 1.1 or greater, <paramref name="data"/> may be a null pointer.
        /// In this case, texture memory is
        /// allocated to accommodate a texture of width <paramref name="width"/> and height <paramref name="height"/>.
        /// You can then download subtextures to initialize this
        /// texture memory.
        /// The image is undefined if the user tries to apply
        /// an uninitialized portion of the texture image to a primitive.
        /// Formats <code>GL_BGR</code>, and <code>GL_BGRA</code> and types
        /// <code>GL_UNSIGNED_BYTE_3_3_2</code>,
        /// <code>GL_UNSIGNED_BYTE_2_3_3_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_5_6_5</code>,
        /// <code>GL_UNSIGNED_SHORT_5_6_5_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_4_4_4_4</code>,
        /// <code>GL_UNSIGNED_SHORT_4_4_4_4_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_5_5_5_1</code>,
        /// <code>GL_UNSIGNED_SHORT_1_5_5_5_REV</code>,
        /// <code>GL_UNSIGNED_INT_8_8_8_8</code>,
        /// <code>GL_UNSIGNED_INT_8_8_8_8_REV</code>,
        /// <code>GL_UNSIGNED_INT_10_10_10_2</code>, and
        /// <code>GL_UNSIGNED_INT_2_10_10_10_REV</code> are available only if the GL version
        /// is 1.2 or greater.
        /// When the <code>ARB_multitexture</code> extension is supported or the GL version is 1.3 or greater, <see cref="glTexImage2D"/>
        /// specifies the two-dimensional texture for the current texture unit,
        /// specified with  <see cref="glActiveTexture"/> .
        /// <code>GL_TEXTURE_CUBE_MAP</code> and <code>GL_PROXY_TEXTURE_CUBE_MAP</code> are available only if the GL
        /// version is 1.3 or greater.
        /// <code>GL_DEPTH_COMPONENT</code>, <code>GL_DEPTH_COMPONENT16</code>,
        /// <code>GL_DEPTH_COMPONENT24</code>, and <code>GL_DEPTH_COMPONENT32</code> are available only
        /// if the GL version is 1.4 or greater.
        /// Non-power-of-two textures are supported if the GL version is 2.0 or greater, or if the implementation exports the <code>GL_ARB_texture_non_power_of_two</code> extension.
        /// The 
        /// <code>GL_SRGB</code>,
        /// <code>GL_SRGB8</code>,
        /// <code>GL_SRGB_ALPHA</code>,
        /// <code>GL_SRGB8_ALPHA8</code>,
        /// <code>GL_SLUMINANCE</code>,
        /// <code>GL_SLUMINANCE8</code>,
        /// <code>GL_SLUMINANCE_ALPHA</code>, and
        /// <code>GL_SLUMINANCE8_ALPHA8</code>
        /// internal formats are only available if the GL version is 2.1 or greater.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="target"/> is not <code>GL_TEXTURE_2D</code>,
        /// <code>GL_PROXY_TEXTURE_2D</code>,
        /// <code>GL_PROXY_TEXTURE_CUBE_MAP</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_POSITIVE_X</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_NEGATIVE_X</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_POSITIVE_Y</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_NEGATIVE_Y</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_POSITIVE_Z</code>, or 
        /// <code>GL_TEXTURE_CUBE_MAP_NEGATIVE_Z</code>.
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="target"/> is one of the six cube map 2D image targets and the width and height parameters are not equal.
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="type"/> is not a type constant.
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="type"/> is <code>GL_BITMAP</code> and
        /// <paramref name="format"/> is not <code>GL_COLOR_INDEX</code>.
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="width"/> or <paramref name="height"/> is less than 0
        /// or greater than 2 + <code>GL_MAX_TEXTURE_SIZE</code>.
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="level"/> is less than 0.
        /// <code>GL_INVALID_VALUE</code> may be generated if <paramref name="level"/> is greater than 
        /// log 
        /// 2 
        /// &af; 
        /// max 
        /// ,
        /// where  max  is the returned value of <code>GL_MAX_TEXTURE_SIZE</code>.
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="internalFormat"/> is not 1, 2, 3, 4, or one of the
        /// accepted resolution and format symbolic constants.
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="width"/> or <paramref name="height"/> is less than 0
        /// or greater than 2 + <code>GL_MAX_TEXTURE_SIZE</code>.
        /// <code>GL_INVALID_VALUE</code> is generated if non-power-of-two textures are not supported and the <paramref name="width"/> or <paramref name="height"/> cannot be represented as 
        /// 2 
        /// k 
        /// + 
        /// 2 
        /// &af; 
        /// border 
        /// for some
        /// integer value of  k .
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="border"/> is not 0 or 1.
        /// <code>GL_INVALID_OPERATION</code> is generated if <paramref name="type"/> is one of
        /// <code>GL_UNSIGNED_BYTE_3_3_2</code>,
        /// <code>GL_UNSIGNED_BYTE_2_3_3_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_5_6_5</code>, or
        /// <code>GL_UNSIGNED_SHORT_5_6_5_REV</code>
        /// and <paramref name="format"/> is not <code>GL_RGB</code>.
        /// <code>GL_INVALID_OPERATION</code> is generated if <paramref name="type"/> is one of
        /// <code>GL_UNSIGNED_SHORT_4_4_4_4</code>,
        /// <code>GL_UNSIGNED_SHORT_4_4_4_4_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_5_5_5_1</code>,
        /// <code>GL_UNSIGNED_SHORT_1_5_5_5_REV</code>,
        /// <code>GL_UNSIGNED_INT_8_8_8_8</code>,
        /// <code>GL_UNSIGNED_INT_8_8_8_8_REV</code>,
        /// <code>GL_UNSIGNED_INT_10_10_10_2</code>, or
        /// <code>GL_UNSIGNED_INT_2_10_10_10_REV</code>
        /// and <paramref name="format"/> is neither <code>GL_RGBA</code> nor <code>GL_BGRA</code>.
        /// <code>GL_INVALID_OPERATION</code> is generated if <paramref name="target"/> is not
        /// <code>GL_TEXTURE_2D</code> or <code>GL_PROXY_TEXTURE_2D</code> and <paramref name="internalFormat"/> is
        /// <code>GL_DEPTH_COMPONENT</code>, <code>GL_DEPTH_COMPONENT16</code>,
        /// <code>GL_DEPTH_COMPONENT24</code>, or <code>GL_DEPTH_COMPONENT32</code>.
        /// <code>GL_INVALID_OPERATION</code> is generated if <paramref name="format"/> is
        /// <code>GL_DEPTH_COMPONENT</code> and <paramref name="internalFormat"/> is not
        /// <code>GL_DEPTH_COMPONENT</code>, <code>GL_DEPTH_COMPONENT16</code>,
        /// <code>GL_DEPTH_COMPONENT24</code>, or <code>GL_DEPTH_COMPONENT32</code>.
        /// <code>GL_INVALID_OPERATION</code> is generated if <paramref name="internalFormat"/> is
        /// <code>GL_DEPTH_COMPONENT</code>, <code>GL_DEPTH_COMPONENT16</code>,
        /// <code>GL_DEPTH_COMPONENT24</code>, or <code>GL_DEPTH_COMPONENT32</code>, and <paramref name="format"/> is
        /// not <code>GL_DEPTH_COMPONENT</code>.
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_UNPACK_BUFFER</code> target and the buffer object's data store is currently mapped.
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_UNPACK_BUFFER</code> target and the data would be unpacked from the buffer 
        /// object such that the memory reads required would exceed the data store size.
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_UNPACK_BUFFER</code> target and <paramref name="data"/> is not evenly divisible 
        /// into the number of bytes needed to store in memory a datum indicated by <paramref name="type"/>.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glTexImage2D"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glTexImage2D(GLenum target, GLint level, GLint internalFormat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const void * data);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target texture.
        /// Must be <code>GL_TEXTURE_2D</code>, <code>GL_PROXY_TEXTURE_2D</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_POSITIVE_X</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_NEGATIVE_X</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_POSITIVE_Y</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_NEGATIVE_Y</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_POSITIVE_Z</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_NEGATIVE_Z</code>, or
        /// <code>GL_PROXY_TEXTURE_CUBE_MAP</code>.
        /// </para>
        /// </param>
        /// <param name="level">
        /// <para>
        /// Specifies the level-of-detail number.
        /// Level 0 is the base image level.
        /// Level  n  is the  n th mipmap reduction image.
        /// </para>
        /// </param>
        /// <param name="internalFormat">
        /// <para>
        /// Specifies the number of color components in the texture.
        /// Must be 1, 2, 3, or 4, or one of the following symbolic constants:
        /// <code>GL_ALPHA</code>,
        /// <code>GL_ALPHA4</code>,
        /// <code>GL_ALPHA8</code>,
        /// <code>GL_ALPHA12</code>,
        /// <code>GL_ALPHA16</code>,
        /// <code>GL_COMPRESSED_ALPHA</code>,
        /// <code>GL_COMPRESSED_LUMINANCE</code>,
        /// <code>GL_COMPRESSED_LUMINANCE_ALPHA</code>,
        /// <code>GL_COMPRESSED_INTENSITY</code>,
        /// <code>GL_COMPRESSED_RGB</code>,
        /// <code>GL_COMPRESSED_RGBA</code>,
        /// <code>GL_DEPTH_COMPONENT</code>,
        /// <code>GL_DEPTH_COMPONENT16</code>,
        /// <code>GL_DEPTH_COMPONENT24</code>,
        /// <code>GL_DEPTH_COMPONENT32</code>,
        /// <code>GL_LUMINANCE</code>,
        /// <code>GL_LUMINANCE4</code>,
        /// <code>GL_LUMINANCE8</code>,
        /// <code>GL_LUMINANCE12</code>,
        /// <code>GL_LUMINANCE16</code>,
        /// <code>GL_LUMINANCE_ALPHA</code>,
        /// <code>GL_LUMINANCE4_ALPHA4</code>,
        /// <code>GL_LUMINANCE6_ALPHA2</code>,
        /// <code>GL_LUMINANCE8_ALPHA8</code>,
        /// <code>GL_LUMINANCE12_ALPHA4</code>,
        /// <code>GL_LUMINANCE12_ALPHA12</code>,
        /// <code>GL_LUMINANCE16_ALPHA16</code>,
        /// <code>GL_INTENSITY</code>,
        /// <code>GL_INTENSITY4</code>,
        /// <code>GL_INTENSITY8</code>,
        /// <code>GL_INTENSITY12</code>,
        /// <code>GL_INTENSITY16</code>,
        /// <code>GL_R3_G3_B2</code>,
        /// <code>GL_RGB</code>,
        /// <code>GL_RGB4</code>,
        /// <code>GL_RGB5</code>,
        /// <code>GL_RGB8</code>,
        /// <code>GL_RGB10</code>,
        /// <code>GL_RGB12</code>,
        /// <code>GL_RGB16</code>,
        /// <code>GL_RGBA</code>,
        /// <code>GL_RGBA2</code>,
        /// <code>GL_RGBA4</code>,
        /// <code>GL_RGB5_A1</code>,
        /// <code>GL_RGBA8</code>,
        /// <code>GL_RGB10_A2</code>,
        /// <code>GL_RGBA12</code>,
        /// <code>GL_RGBA16</code>,
        /// <code>GL_SLUMINANCE</code>,
        /// <code>GL_SLUMINANCE8</code>,
        /// <code>GL_SLUMINANCE_ALPHA</code>,
        /// <code>GL_SLUMINANCE8_ALPHA8</code>,
        /// <code>GL_SRGB</code>,
        /// <code>GL_SRGB8</code>,
        /// <code>GL_SRGB_ALPHA</code>, or 
        /// <code>GL_SRGB8_ALPHA8</code>.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// Specifies the width of the texture image including the border if any. If the GL version does not support non-power-of-two sizes, this value must be 
        /// 2 
        /// n 
        /// + 
        /// 2 
        /// &af; 
        /// border 
        /// for some integer 
        /// n   .
        /// All
        /// implementations support texture images that are at least 64 texels
        /// wide.
        /// </para>
        /// </param>
        /// <param name="height">
        /// <para>
        /// Specifies the height of the texture image including the border if any. If the GL version does not support non-power-of-two sizes, this value must be 
        /// 2 
        /// m 
        /// + 
        /// 2 
        /// &af; 
        /// border 
        /// for some integer 
        /// m   .
        /// All
        /// implementations support texture images that are at least 64 texels
        /// high.
        /// </para>
        /// </param>
        /// <param name="border">
        /// <para>
        /// Specifies the width of the border.
        /// Must be either 0 or 1.
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// Specifies the format of the pixel data.
        /// The following symbolic values are accepted:
        /// <code>GL_COLOR_INDEX</code>,
        /// <code>GL_RED</code>,
        /// <code>GL_GREEN</code>,
        /// <code>GL_BLUE</code>,
        /// <code>GL_ALPHA</code>,
        /// <code>GL_RGB</code>,
        /// <code>GL_BGR</code>,
        /// <code>GL_RGBA</code>,
        /// <code>GL_BGRA</code>,
        /// <code>GL_LUMINANCE</code>, and
        /// <code>GL_LUMINANCE_ALPHA</code>.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the data type of the pixel data.
        /// The following symbolic values are accepted:
        /// <code>GL_UNSIGNED_BYTE</code>,
        /// <code>GL_BYTE</code>,
        /// <code>GL_BITMAP</code>,
        /// <code>GL_UNSIGNED_SHORT</code>,
        /// <code>GL_SHORT</code>,
        /// <code>GL_UNSIGNED_INT</code>,
        /// <code>GL_INT</code>,
        /// <code>GL_FLOAT</code>,
        /// <code>GL_UNSIGNED_BYTE_3_3_2</code>,
        /// <code>GL_UNSIGNED_BYTE_2_3_3_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_5_6_5</code>,
        /// <code>GL_UNSIGNED_SHORT_5_6_5_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_4_4_4_4</code>,
        /// <code>GL_UNSIGNED_SHORT_4_4_4_4_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_5_5_5_1</code>,
        /// <code>GL_UNSIGNED_SHORT_1_5_5_5_REV</code>,
        /// <code>GL_UNSIGNED_INT_8_8_8_8</code>,
        /// <code>GL_UNSIGNED_INT_8_8_8_8_REV</code>,
        /// <code>GL_UNSIGNED_INT_10_10_10_2</code>, and
        /// <code>GL_UNSIGNED_INT_2_10_10_10_REV</code>.
        /// </para>
        /// </param>
        /// <param name="data">
        /// Specifies a pointer to the image data in memory.
        /// </param>
        /// <seealso cref="ActiveTexture"/>
        /// <seealso cref="ColorTable"/>
        /// <seealso cref="ConvolutionFilter2D"/>
        /// <seealso cref="CopyPixels"/>
        /// <seealso cref="CopyTexImage1D"/>
        /// <seealso cref="CopyTexImage2D"/>
        /// <seealso cref="CopyTexSubImage1D"/>
        /// <seealso cref="CopyTexSubImage2D"/>
        /// <seealso cref="CopyTexSubImage3D"/>
        /// <seealso cref="DrawPixels"/>
        /// <seealso cref="MatrixMode"/>
        /// <seealso cref="PixelStore"/>
        /// <seealso cref="PixelTransfer"/>
        /// <seealso cref="SeparableFilter2D"/>
        /// <seealso cref="TexEnv"/>
        /// <seealso cref="TexGen"/>
        /// <seealso cref="TexImage1D"/>
        /// <seealso cref="TexImage3D"/>
        /// <seealso cref="TexSubImage1D"/>
        /// <seealso cref="TexSubImage2D"/>
        /// <seealso cref="TexSubImage3D"/>
        /// <seealso cref="TexParameter"/>
        public unsafe static void TexImage2D(uint target, int level, int internalFormat, int width, int height, int border, uint format, uint type, IntPtr data) {
            GLNative.glTexImage2D(target, level, internalFormat, width, height, border, format, type, (void*)data);
        }

        /// <summary>
        /// read a block of pixels from the frame buffer
        /// <para>Require:</para> <para>GL_VERSION_1_0, GL_VERSION_ES_CM_1_0, GL_ES_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// Values for pixels that lie outside the window
        /// connected to the current GL context are undefined.
        /// If an error is generated,
        /// no change is made to the contents of <paramref name="data"/>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="format"/> or <paramref name="type"/> is not an
        /// accepted value.
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="type"/> is <code>GL_BITMAP</code> and <paramref name="format"/> is
        /// not <code>GL_COLOR_INDEX</code> or <code>GL_STENCIL_INDEX</code>.
        /// <code>GL_INVALID_VALUE</code> is generated if either <paramref name="width"/> or <paramref name="height"/> is negative.
        /// <code>GL_INVALID_OPERATION</code> is generated if <paramref name="format"/> is <code>GL_COLOR_INDEX</code>
        /// and the color buffers store RGBA color components.
        /// <code>GL_INVALID_OPERATION</code> is generated if <paramref name="format"/> is <code>GL_STENCIL_INDEX</code>
        /// and there is no stencil buffer.
        /// <code>GL_INVALID_OPERATION</code> is generated if <paramref name="format"/> is <code>GL_DEPTH_COMPONENT</code>
        /// and there is no depth buffer.
        /// <code>GL_INVALID_OPERATION</code> is generated if <paramref name="type"/> is one of
        /// <code>GL_UNSIGNED_BYTE_3_3_2</code>,
        /// <code>GL_UNSIGNED_BYTE_2_3_3_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_5_6_5</code>, or
        /// <code>GL_UNSIGNED_SHORT_5_6_5_REV</code>
        /// and <paramref name="format"/> is not <code>GL_RGB</code>.
        /// <code>GL_INVALID_OPERATION</code> is generated if <paramref name="type"/> is one of
        /// <code>GL_UNSIGNED_SHORT_4_4_4_4</code>,
        /// <code>GL_UNSIGNED_SHORT_4_4_4_4_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_5_5_5_1</code>,
        /// <code>GL_UNSIGNED_SHORT_1_5_5_5_REV</code>,
        /// <code>GL_UNSIGNED_INT_8_8_8_8</code>,
        /// <code>GL_UNSIGNED_INT_8_8_8_8_REV</code>,
        /// <code>GL_UNSIGNED_INT_10_10_10_2</code>, or
        /// <code>GL_UNSIGNED_INT_2_10_10_10_REV</code>
        /// and <paramref name="format"/> is neither <code>GL_RGBA</code> nor <code>GL_BGRA</code>.
        /// The formats <code>GL_BGR</code>, and <code>GL_BGRA</code> and types
        /// <code>GL_UNSIGNED_BYTE_3_3_2</code>,
        /// <code>GL_UNSIGNED_BYTE_2_3_3_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_5_6_5</code>,
        /// <code>GL_UNSIGNED_SHORT_5_6_5_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_4_4_4_4</code>,
        /// <code>GL_UNSIGNED_SHORT_4_4_4_4_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_5_5_5_1</code>,
        /// <code>GL_UNSIGNED_SHORT_1_5_5_5_REV</code>,
        /// <code>GL_UNSIGNED_INT_8_8_8_8</code>,
        /// <code>GL_UNSIGNED_INT_8_8_8_8_REV</code>,
        /// <code>GL_UNSIGNED_INT_10_10_10_2</code>, and
        /// <code>GL_UNSIGNED_INT_2_10_10_10_REV</code> are available only if the GL version
        /// is 1.2 or greater.
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_PACK_BUFFER</code> target and the buffer object's data store is currently mapped.
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_PACK_BUFFER</code> target and the data would be packed to the buffer 
        /// object such that the memory writes required would exceed the data store size.
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_PACK_BUFFER</code> target and <paramref name="data"/> is not evenly divisible 
        /// into the number of bytes needed to store in memory a datum indicated by <paramref name="type"/>.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glReadPixels"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glReadPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, void * data);</para>
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify the window coordinates of the first pixel
        /// that is read from the frame buffer.
        /// This location is the lower left corner of a rectangular block of pixels.
        /// </para>
        /// </param>
        /// <param name="y">
        /// <para>
        /// Specify the window coordinates of the first pixel
        /// that is read from the frame buffer.
        /// This location is the lower left corner of a rectangular block of pixels.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// Specify the dimensions of the pixel rectangle.
        /// <paramref name="width"/> and <paramref name="height"/> of one correspond to a single pixel.
        /// </para>
        /// </param>
        /// <param name="height">
        /// <para>
        /// Specify the dimensions of the pixel rectangle.
        /// <paramref name="width"/> and <paramref name="height"/> of one correspond to a single pixel.
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// Specifies the format of the pixel data.
        /// The following symbolic values are accepted:
        /// <code>GL_COLOR_INDEX</code>,
        /// <code>GL_STENCIL_INDEX</code>,
        /// <code>GL_DEPTH_COMPONENT</code>,
        /// <code>GL_RED</code>,
        /// <code>GL_GREEN</code>,
        /// <code>GL_BLUE</code>,
        /// <code>GL_ALPHA</code>,
        /// <code>GL_RGB</code>,
        /// <code>GL_BGR</code>,
        /// <code>GL_RGBA</code>,
        /// <code>GL_BGRA</code>,
        /// <code>GL_LUMINANCE</code>, and
        /// <code>GL_LUMINANCE_ALPHA</code>.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the data type of the pixel data.
        /// Must be one of
        /// <code>GL_UNSIGNED_BYTE</code>,
        /// <code>GL_BYTE</code>,
        /// <code>GL_BITMAP</code>,
        /// <code>GL_UNSIGNED_SHORT</code>,
        /// <code>GL_SHORT</code>,
        /// <code>GL_UNSIGNED_INT</code>,
        /// <code>GL_INT</code>,
        /// <code>GL_FLOAT</code>,
        /// <code>GL_UNSIGNED_BYTE_3_3_2</code>,
        /// <code>GL_UNSIGNED_BYTE_2_3_3_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_5_6_5</code>,
        /// <code>GL_UNSIGNED_SHORT_5_6_5_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_4_4_4_4</code>,
        /// <code>GL_UNSIGNED_SHORT_4_4_4_4_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_5_5_5_1</code>,
        /// <code>GL_UNSIGNED_SHORT_1_5_5_5_REV</code>,
        /// <code>GL_UNSIGNED_INT_8_8_8_8</code>,
        /// <code>GL_UNSIGNED_INT_8_8_8_8_REV</code>,
        /// <code>GL_UNSIGNED_INT_10_10_10_2</code>, or
        /// <code>GL_UNSIGNED_INT_2_10_10_10_REV</code>.
        /// </para>
        /// </param>
        /// <param name="data">
        /// Returns the pixel data.
        /// </param>
        /// <seealso cref="CopyPixels"/>
        /// <seealso cref="DrawPixels"/>
        /// <seealso cref="PixelMap"/>
        /// <seealso cref="PixelStore"/>
        /// <seealso cref="PixelTransfer"/>
        /// <seealso cref="ReadBuffer"/>
        public unsafe static void ReadPixels(int x, int y, int width, int height, uint format, uint type, IntPtr data) {
            GLNative.glReadPixels(x, y, width, height, format, type, (void*)data);
        }

        /// <summary>
        /// return the value or values of a selected parameter
        /// <para>Require:</para> <para>GL_VERSION_1_0, GL_VERSION_ES_CM_1_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <code>GL_COLOR_LOGIC_OP</code>,
        /// <code>GL_COLOR_ARRAY</code>,
        /// <code>GL_COLOR_ARRAY_SIZE</code>,
        /// <code>GL_COLOR_ARRAY_STRIDE</code>,
        /// <code>GL_COLOR_ARRAY_TYPE</code>,
        /// <code>GL_EDGE_FLAG_ARRAY</code>,
        /// <code>GL_EDGE_FLAG_ARRAY_STRIDE</code>,
        /// <code>GL_INDEX_ARRAY</code>,
        /// <code>GL_INDEX_ARRAY_STRIDE</code>,
        /// <code>GL_INDEX_ARRAY_TYPE</code>,
        /// <code>GL_INDEX_LOGIC_OP</code>,
        /// <code>GL_NORMAL_ARRAY</code>,
        /// <code>GL_NORMAL_ARRAY_STRIDE</code>,
        /// <code>GL_NORMAL_ARRAY_TYPE</code>,
        /// <code>GL_POLYGON_OFFSET_UNITS</code>,
        /// <code>GL_POLYGON_OFFSET_FACTOR</code>,
        /// <code>GL_POLYGON_OFFSET_FILL</code>,
        /// <code>GL_POLYGON_OFFSET_LINE</code>,
        /// <code>GL_POLYGON_OFFSET_POINT</code>,
        /// <code>GL_TEXTURE_COORD_ARRAY</code>,
        /// <code>GL_TEXTURE_COORD_ARRAY_SIZE</code>,
        /// <code>GL_TEXTURE_COORD_ARRAY_STRIDE</code>,
        /// <code>GL_TEXTURE_COORD_ARRAY_TYPE</code>,
        /// <code>GL_VERTEX_ARRAY</code>,
        /// <code>GL_VERTEX_ARRAY_SIZE</code>,
        /// <code>GL_VERTEX_ARRAY_STRIDE</code>, and
        /// <code>GL_VERTEX_ARRAY_TYPE</code>
        /// are available only if the GL version is 1.1 or greater.
        /// <code>GL_ALIASED_POINT_SIZE_RANGE</code>,
        /// <code>GL_FEEDBACK_BUFFER_SIZE</code>,
        /// <code>GL_FEEDBACK_BUFFER_TYPE</code>,
        /// <code>GL_LIGHT_MODEL_AMBIENT</code>,
        /// <code>GL_LIGHT_MODEL_COLOR_CONTROL</code>,
        /// <code>GL_MAX_3D_TEXTURE_SIZE</code>,
        /// <code>GL_MAX_ELEMENTS_INDICES</code>,
        /// <code>GL_MAX_ELEMENTS_VERTICES</code>,
        /// <code>GL_PACK_IMAGE_HEIGHT</code>,
        /// <code>GL_PACK_SKIP_IMAGES</code>,
        /// <code>GL_RESCALE_NORMAL</code>,
        /// <code>GL_SELECTION_BUFFER_SIZE</code>,
        /// <code>GL_SMOOTH_LINE_WIDTH_GRANULARITY</code>,
        /// <code>GL_SMOOTH_LINE_WIDTH_RANGE</code>,
        /// <code>GL_SMOOTH_POINT_SIZE_GRANULARITY</code>,
        /// <code>GL_SMOOTH_POINT_SIZE_RANGE</code>,
        /// <code>GL_TEXTURE_3D</code>,
        /// <code>GL_TEXTURE_BINDING_3D</code>,
        /// <code>GL_UNPACK_IMAGE_HEIGHT</code>, and
        /// <code>GL_UNPACK_SKIP_IMAGES</code>
        /// are available only if the GL version is 1.2 or greater.
        /// <code>GL_COMPRESSED_TEXTURE_FORMATS</code>,
        /// <code>GL_NUM_COMPRESSED_TEXTURE_FORMATS</code>,
        /// <code>GL_TEXTURE_BINDING_CUBE_MAP</code>, and
        /// <code>GL_TEXTURE_COMPRESSION_HINT</code>
        /// are available only if the GL version is 1.3 or greater.
        /// <code>GL_BLEND_DST_ALPHA</code>,
        /// <code>GL_BLEND_DST_RGB</code>,
        /// <code>GL_BLEND_SRC_ALPHA</code>,
        /// <code>GL_BLEND_SRC_RGB</code>,
        /// <code>GL_CURRENT_FOG_COORD</code>,
        /// <code>GL_CURRENT_SECONDARY_COLOR</code>,
        /// <code>GL_FOG_COORD_ARRAY_STRIDE</code>,
        /// <code>GL_FOG_COORD_ARRAY_TYPE</code>,
        /// <code>GL_FOG_COORD_SRC</code>,
        /// <code>GL_MAX_TEXTURE_LOD_BIAS</code>,
        /// <code>GL_POINT_SIZE_MIN</code>,
        /// <code>GL_POINT_SIZE_MAX</code>,
        /// <code>GL_POINT_FADE_THRESHOLD_SIZE</code>,
        /// <code>GL_POINT_DISTANCE_ATTENUATION</code>,
        /// <code>GL_SECONDARY_COLOR_ARRAY_SIZE</code>,
        /// <code>GL_SECONDARY_COLOR_ARRAY_STRIDE</code>, and
        /// <code>GL_SECONDARY_COLOR_ARRAY_TYPE</code>
        /// are available only if the GL version is 1.4 or greater.
        /// <code>GL_ARRAY_BUFFER_BINDING</code>,
        /// <code>GL_COLOR_ARRAY_BUFFER_BINDING</code>,
        /// <code>GL_EDGE_FLAG_ARRAY_BUFFER_BINDING</code>,
        /// <code>GL_ELEMENT_ARRAY_BUFFER_BINDING</code>,
        /// <code>GL_FOG_COORD_ARRAY_BUFFER_BINDING</code>,
        /// <code>GL_INDEX_ARRAY_BUFFER_BINDING</code>,
        /// <code>GL_NORMAL_ARRAY_BUFFER_BINDING</code>,
        /// <code>GL_SECONDARY_COLOR_ARRAY_BUFFER_BINDING</code>,
        /// <code>GL_TEXTURE_COORD_ARRAY_BUFFER_BINDING</code>, and
        /// <code>GL_VERTEX_ARRAY_BUFFER_BINDING</code>
        /// are available only if the GL version is 1.5 or greater.
        /// <code>GL_BLEND_EQUATION_ALPHA</code>,
        /// <code>GL_BLEND_EQUATION_RGB</code>,
        /// <code>GL_DRAW_BUFFER</code> i ,
        /// <code>GL_FRAGMENT_SHADER_DERIVATIVE_HINT</code>,
        /// <code>GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS</code>,
        /// <code>GL_MAX_DRAW_BUFFERS</code>,
        /// <code>GL_MAX_FRAGMENT_UNIFORM_COMPONENTS</code>,
        /// <code>GL_MAX_TEXTURE_COORDS</code>,
        /// <code>GL_MAX_TEXTURE_IMAGE_UNITS</code>,
        /// <code>GL_MAX_VARYING_FLOATS</code>,
        /// <code>GL_MAX_VERTEX_ATTRIBS</code>,
        /// <code>GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS</code>,
        /// <code>GL_MAX_VERTEX_UNIFORM_COMPONENTS</code>,
        /// <code>GL_POINT_SPRITE</code>,
        /// <code>GL_STENCIL_BACK_FAIL</code>,
        /// <code>GL_STENCIL_BACK_FUNC</code>,
        /// <code>GL_STENCIL_BACK_PASS_DEPTH_FAIL</code>,
        /// <code>GL_STENCIL_BACK_PASS_DEPTH_PASS</code>,
        /// <code>GL_STENCIL_BACK_REF</code>,
        /// <code>GL_STENCIL_BACK_VALUE_MASK</code>,
        /// <code>GL_STENCIL_BACK_WRITEMASK</code>,
        /// <code>GL_VERTEX_PROGRAM_POINT_SIZE</code>, and
        /// <code>GL_VERTEX_PROGRAM_TWO_SIDE</code>
        /// are available only if the GL version is 2.0 or greater.
        /// <code>GL_CURRENT_RASTER_SECONDARY_COLOR</code>,
        /// <code>GL_PIXEL_PACK_BUFFER_BINDING</code> and
        /// <code>GL_PIXEL_UNPACK_BUFFER_BINDING</code>
        /// are available only if the GL version is 2.1 or greater.
        /// <code>GL_LINE_WIDTH_GRANULARITY</code> was deprecated in GL version 1.2.  Its
        /// functionality was replaced by <code>GL_SMOOTH_LINE_WIDTH_GRANULARITY</code>.
        /// <code>GL_LINE_WIDTH_RANGE</code> was deprecated in GL version 1.2.  Its
        /// functionality was replaced by <code>GL_SMOOTH_LINE_WIDTH_RANGE</code>.
        /// <code>GL_POINT_SIZE_GRANULARITY</code> was deprecated in GL version 1.2.  Its
        /// functionality was replaced by <code>GL_SMOOTH_POINT_SIZE_GRANULARITY</code>.
        /// <code>GL_POINT_SIZE_RANGE</code> was deprecated in GL version 1.2.  Its
        /// functionality was replaced by <code>GL_SMOOTH_POINT_SIZE_RANGE</code>.
        /// <code>GL_BLEND_EQUATION</code> was deprecated in GL version 2.0.  Its
        /// functionality was replaced by <code>GL_BLEND_EQUATION_RGB</code> and
        /// <code>GL_BLEND_EQUATION_ALPHA</code>.
        /// <code>GL_COLOR_MATRIX</code>,
        /// <code>GL_COLOR_MATRIX_STACK_DEPTH</code>,
        /// <code>GL_COLOR_TABLE</code>,
        /// <code>GL_CONVOLUTION_1D</code>,
        /// <code>GL_CONVOLUTION_2D</code>,
        /// <code>GL_HISTOGRAM</code>,
        /// <code>GL_MAX_COLOR_MATRIX_STACK_DEPTH</code>,
        /// <code>GL_MINMAX</code>,
        /// <code>GL_POST_COLOR_MATRIX_COLOR_TABLE</code>,
        /// <code>GL_POST_COLOR_MATRIX_RED_BIAS</code>,
        /// <code>GL_POST_COLOR_MATRIX_GREEN_BIAS</code>,
        /// <code>GL_POST_COLOR_MATRIX_BLUE_BIAS</code>,
        /// <code>GL_POST_COLOR_MATRIX_ALPHA_BIAS</code>,
        /// <code>GL_POST_COLOR_MATRIX_RED_SCALE</code>,
        /// <code>GL_POST_COLOR_MATRIX_GREEN_SCALE</code>,
        /// <code>GL_POST_COLOR_MATRIX_BLUE_SCALE</code>,
        /// <code>GL_POST_COLOR_MATRIX_ALPHA_SCALE</code>,
        /// <code>GL_POST_CONVOLUTION_COLOR_TABLE</code>,
        /// <code>GL_POST_CONVOLUTION_RED_BIAS</code>,
        /// <code>GL_POST_CONVOLUTION_GREEN_BIAS</code>,
        /// <code>GL_POST_CONVOLUTION_BLUE_BIAS</code>,
        /// <code>GL_POST_CONVOLUTION_ALPHA_BIAS</code>,
        /// <code>GL_POST_CONVOLUTION_RED_SCALE</code>,
        /// <code>GL_POST_CONVOLUTION_GREEN_SCALE</code>,
        /// <code>GL_POST_CONVOLUTION_BLUE_SCALE</code>,
        /// <code>GL_POST_CONVOLUTION_ALPHA_SCALE</code>, and
        /// <code>GL_SEPARABLE_2D</code>
        /// are available only if <code>ARB_imaging</code> is returned from <see cref="glGet"/>
        /// when called with the argument <code>GL_EXTENSIONS</code>.
        /// When the <code>ARB_multitexture</code> extension is supported, or the GL version
        /// is 1.3 or greater, the following
        /// parameters return the associated value for the active texture unit:
        /// <code>GL_CURRENT_RASTER_TEXTURE_COORDS</code>,
        /// <code>GL_TEXTURE_1D</code>, <code>GL_TEXTURE_BINDING_1D</code>,
        /// <code>GL_TEXTURE_2D</code>, <code>GL_TEXTURE_BINDING_2D</code>,
        /// <code>GL_TEXTURE_3D</code>, <code>GL_TEXTURE_BINDING_3D</code>,
        /// <code>GL_TEXTURE_GEN_S</code>,
        /// <code>GL_TEXTURE_GEN_T</code>,
        /// <code>GL_TEXTURE_GEN_R</code>,
        /// <code>GL_TEXTURE_GEN_Q</code>,
        /// <code>GL_TEXTURE_MATRIX</code>, and
        /// <code>GL_TEXTURE_STACK_DEPTH</code>.
        /// Likewise, the following parameters return the associated value for the
        /// active client texture unit:
        /// <code>GL_TEXTURE_COORD_ARRAY</code>,
        /// <code>GL_TEXTURE_COORD_ARRAY_BUFFER_BINDING</code>,
        /// <code>GL_TEXTURE_COORD_ARRAY_SIZE</code>,
        /// <code>GL_TEXTURE_COORD_ARRAY_STRIDE</code>,
        /// <code>GL_TEXTURE_COORD_ARRAY_TYPE</code>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="pname"/> is not an accepted value.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glGet"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glGetBooleanv(GLenum pname, GLboolean * params);</para>
        /// </summary>
        /// <param name="pname">
        /// <para>
        /// Specifies the parameter value to be returned.
        /// The symbolic constants in the list below are accepted.
        /// </para>
        /// </param>
        /// <param name="ps">
        /// Returns the value or values of the specified parameter.
        /// </param>
        /// <seealso cref="GetActiveAttrib"/>
        /// <seealso cref="GetActiveUniform"/>
        /// <seealso cref="GetAttachedShaders"/>
        /// <seealso cref="GetAttribLocation"/>
        /// <seealso cref="GetBufferParameteriv"/>
        /// <seealso cref="GetBufferPointerv"/>
        /// <seealso cref="GetBufferSubData"/>
        /// <seealso cref="GetClipPlane"/>
        /// <seealso cref="GetColorTable"/>
        /// <seealso cref="GetColorTableParameter"/>
        /// <seealso cref="GetCompressedTexImage"/>
        /// <seealso cref="GetConvolutionFilter"/>
        /// <seealso cref="GetConvolutionParameter"/>
        /// <seealso cref="GetError"/>
        /// <seealso cref="GetHistogram"/>
        /// <seealso cref="GetHistogramParameter"/>
        /// <seealso cref="GetLight"/>
        /// <seealso cref="GetMap"/>
        /// <seealso cref="GetMaterial"/>
        /// <seealso cref="GetMinmax"/>
        /// <seealso cref="GetMinmaxParameter"/>
        /// <seealso cref="GetPixelMap"/>
        /// <seealso cref="GetPointerv"/>
        /// <seealso cref="GetPolygonStipple"/>
        /// <seealso cref="GetProgram"/>
        /// <seealso cref="GetProgramInfoLog"/>
        /// <seealso cref="GetQueryiv"/>
        /// <seealso cref="GetQueryObject"/>
        /// <seealso cref="GetSeparableFilter"/>
        /// <seealso cref="GetShader"/>
        /// <seealso cref="GetShaderInfoLog"/>
        /// <seealso cref="GetShaderSource"/>
        /// <seealso cref="GetString"/>
        /// <seealso cref="GetTexEnv"/>
        /// <seealso cref="GetTexGen"/>
        /// <seealso cref="GetTexImage"/>
        /// <seealso cref="GetTexLevelParameter"/>
        /// <seealso cref="GetTexParameter"/>
        /// <seealso cref="GetUniform"/>
        /// <seealso cref="GetUniformLocation"/>
        /// <seealso cref="GetVertexAttrib"/>
        /// <seealso cref="GetVertexAttribPointerv"/>
        /// <seealso cref="IsEnabled"/>
        public unsafe static void GetBooleanv(uint pname, ref bool ps) {
            fixed (bool* pPs = &ps) {
                GLNative.glGetBooleanv(pname, pPs);
            }
        }

        /// <summary>
        /// return the value or values of a selected parameter
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glGetDoublev(GLenum pname, GLdouble * data);</para>
        /// </summary>
        public unsafe static void GetDoublev(uint pname, ref double data) {
            fixed (double* pData = &data) {
                GLNative.glGetDoublev(pname, pData);
            }
        }

        /// <summary>
        /// return the value or values of a selected parameter
        /// <para>Require:</para> <para>GL_VERSION_1_0, GL_VERSION_ES_CM_1_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glGetFloatv(GLenum pname, GLfloat * data);</para>
        /// </summary>
        public unsafe static void GetFloatv(uint pname, ref float data) {
            fixed (float* pData = &data) {
                GLNative.glGetFloatv(pname, pData);
            }
        }

        /// <summary>
        /// return the value or values of a selected parameter
        /// <para>Require:</para> <para>GL_VERSION_1_0, GL_VERSION_ES_CM_1_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glGetIntegerv(GLenum pname, GLint * data);</para>
        /// </summary>
        public unsafe static void GetIntegerv(uint pname, ref int data) {
            fixed (int* pData = &data) {
                GLNative.glGetIntegerv(pname, pData);
            }
        }

        /// <summary>
        /// return a string describing the current GL connection
        /// <para>Require:</para> <para>GL_VERSION_1_0, GL_VERSION_ES_CM_1_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// If an error is generated, <see cref="glGetString"/> returns 0.
        /// The client and server may support different versions or extensions.
        /// <see cref="glGetString"/> always returns a compatible version number or list of extensions.
        /// The release number always describes the server.
        /// <code>GL_SHADING_LANGUAGE_VERSION</code> is available only if the GL version is 2.0 or greater.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="name"/> is not an accepted value.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glGetString"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>const GLubyte * glGetString(GLenum name);</para>
        /// </summary>
        /// <param name="name">
        /// <para>
        /// Specifies a symbolic constant, one of
        /// <code>GL_VENDOR</code>, <code>GL_RENDERER</code>, <code>GL_VERSION</code>, <code>GL_SHADING_LANGUAGE_VERSION</code>, or <code>GL_EXTENSIONS</code>.
        /// </para>
        /// </param>
        public unsafe static string GetString(uint name) {
            var ptr = GLNative.glGetString(name);
            if (ptr == null) return null;
            return MarshalExtend.PtrToString(ptr);
        }

        /// <summary>
        /// return a texture image
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// If an error is generated,
        /// no change is made to the contents of <paramref name="img"/>.
        /// The types <code>GL_UNSIGNED_BYTE_3_3_2</code>,
        /// <code>GL_UNSIGNED_BYTE_2_3_3_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_5_6_5</code>,
        /// <code>GL_UNSIGNED_SHORT_5_6_5_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_4_4_4_4</code>,
        /// <code>GL_UNSIGNED_SHORT_4_4_4_4_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_5_5_5_1</code>,
        /// <code>GL_UNSIGNED_SHORT_1_5_5_5_REV</code>,
        /// <code>GL_UNSIGNED_INT_8_8_8_8</code>,
        /// <code>GL_UNSIGNED_INT_8_8_8_8_REV</code>,
        /// <code>GL_UNSIGNED_INT_10_10_10_2</code>,
        /// <code>GL_UNSIGNED_INT_2_10_10_10_REV</code>,
        /// and the formats
        /// <code>GL_BGR</code>, and <code>GL_BGRA</code> are available only if the GL version is
        /// 1.2 or greater.
        /// For OpenGL versions 1.3 and greater, or when the <code>ARB_multitexture</code> extension is supported, <see cref="glGetTexImage"/> returns
        /// the texture image for the active texture unit.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="target"/>, <paramref name="format"/>, or <paramref name="type"/> is not
        /// an accepted value.
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="level"/> is less than 0.
        /// <code>GL_INVALID_VALUE</code> may be generated if <paramref name="level"/> is greater
        /// than 
        /// log 
        /// 2 
        /// &af; 
        /// max 
        /// ,
        /// where 
        /// max   
        /// is the returned value of <code>GL_MAX_TEXTURE_SIZE</code>.
        /// <code>GL_INVALID_OPERATION</code> is returned if <paramref name="type"/> is one of
        /// <code>GL_UNSIGNED_BYTE_3_3_2</code>,
        /// <code>GL_UNSIGNED_BYTE_2_3_3_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_5_6_5</code>, or
        /// <code>GL_UNSIGNED_SHORT_5_6_5_REV</code> and <paramref name="format"/> is not <code>GL_RGB</code>.
        /// <code>GL_INVALID_OPERATION</code> is returned if <paramref name="type"/> is one of
        /// <code>GL_UNSIGNED_SHORT_4_4_4_4</code>,
        /// <code>GL_UNSIGNED_SHORT_4_4_4_4_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_5_5_5_1</code>,
        /// <code>GL_UNSIGNED_SHORT_1_5_5_5_REV</code>,
        /// <code>GL_UNSIGNED_INT_8_8_8_8</code>,
        /// <code>GL_UNSIGNED_INT_8_8_8_8_REV</code>,
        /// <code>GL_UNSIGNED_INT_10_10_10_2</code>, or
        /// <code>GL_UNSIGNED_INT_2_10_10_10_REV</code>, and <paramref name="format"/> is neither <code>GL_RGBA</code>
        /// or <code>GL_BGRA</code>.
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_PACK_BUFFER</code> target and the buffer object's data store is currently mapped.
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_PACK_BUFFER</code> target and the data would be packed to the buffer 
        /// object such that the memory writes required would exceed the data store size.
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_PACK_BUFFER</code> target and <paramref name="img"/> is not evenly divisible 
        /// into the number of bytes needed to store in memory a datum indicated by <paramref name="type"/>.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glGetTexImage"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glGetTexImage(GLenum target, GLint level, GLenum format, GLenum type, void * img);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies which texture is to be obtained.
        /// <code>GL_TEXTURE_1D</code>, <code>GL_TEXTURE_2D</code>, <code>GL_TEXTURE_3D</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_POSITIVE_X</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_NEGATIVE_X</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_POSITIVE_Y</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_NEGATIVE_Y</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_POSITIVE_Z</code>, and
        /// <code>GL_TEXTURE_CUBE_MAP_NEGATIVE_Z</code> 
        /// are accepted.
        /// </para>
        /// </param>
        /// <param name="level">
        /// <para>
        /// Specifies the level-of-detail number of the desired image.
        /// Level 0 is the base image level.
        /// Level 
        /// n   
        /// is the 
        /// n   th
        /// mipmap reduction image.
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// Specifies a pixel format for the returned data.
        /// The supported formats are
        /// <code>GL_RED</code>,
        /// <code>GL_GREEN</code>,
        /// <code>GL_BLUE</code>,
        /// <code>GL_ALPHA</code>,
        /// <code>GL_RGB</code>,
        /// <code>GL_BGR</code>,
        /// <code>GL_RGBA</code>,
        /// <code>GL_BGRA</code>,
        /// <code>GL_LUMINANCE</code>, and
        /// <code>GL_LUMINANCE_ALPHA</code>.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies a pixel type for the returned data.
        /// The supported types are
        /// <code>GL_UNSIGNED_BYTE</code>,
        /// <code>GL_BYTE</code>,
        /// <code>GL_UNSIGNED_SHORT</code>,
        /// <code>GL_SHORT</code>,
        /// <code>GL_UNSIGNED_INT</code>,
        /// <code>GL_INT</code>,
        /// <code>GL_FLOAT</code>,
        /// <code>GL_UNSIGNED_BYTE_3_3_2</code>,
        /// <code>GL_UNSIGNED_BYTE_2_3_3_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_5_6_5</code>,
        /// <code>GL_UNSIGNED_SHORT_5_6_5_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_4_4_4_4</code>,
        /// <code>GL_UNSIGNED_SHORT_4_4_4_4_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_5_5_5_1</code>,
        /// <code>GL_UNSIGNED_SHORT_1_5_5_5_REV</code>,
        /// <code>GL_UNSIGNED_INT_8_8_8_8</code>,
        /// <code>GL_UNSIGNED_INT_8_8_8_8_REV</code>,
        /// <code>GL_UNSIGNED_INT_10_10_10_2</code>, and
        /// <code>GL_UNSIGNED_INT_2_10_10_10_REV</code>.
        /// </para>
        /// </param>
        /// <param name="img">
        /// <para>
        /// Returns the texture image.
        /// Should be a pointer to an array of the type specified by <paramref name="type"/>.
        /// </para>
        /// </param>
        /// <seealso cref="ActiveTexture"/>
        /// <seealso cref="DrawPixels"/>
        /// <seealso cref="ReadPixels"/>
        /// <seealso cref="TexEnv"/>
        /// <seealso cref="TexGen"/>
        /// <seealso cref="TexImage1D"/>
        /// <seealso cref="TexImage2D"/>
        /// <seealso cref="TexImage3D"/>
        /// <seealso cref="TexSubImage1D"/>
        /// <seealso cref="TexSubImage2D"/>
        /// <seealso cref="TexSubImage3D"/>
        /// <seealso cref="TexParameter"/>
        public unsafe static void GetTexImage(uint target, int level, uint format, uint type, IntPtr img) {
            GLNative.glGetTexImage(target, level, format, type, (void*)img);
        }

        /// <summary>
        /// return texture parameter values
        /// <para>Require:</para> <para>GL_VERSION_1_0, GL_VERSION_ES_CM_1_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <code>GL_TEXTURE_PRIORITY</code> and <code>GL_TEXTURE_RESIDENT</code> are
        /// available only if the GL version is 1.1 or greater.
        /// <code>GL_TEXTURE_3D</code>,
        /// <code>GL_TEXTURE_MIN_LOD</code>, <code>GL_TEXTURE_MAX_LOD</code>, <code>GL_TEXTURE_BASE_LEVEL</code>,
        /// <code>GL_TEXTURE_MAX_LEVEL</code>, and <code>GL_TEXTURE_WRAP_R</code> are available only
        /// if the GL version is 1.2 or greater.
        /// <code>GL_TEXTURE_COMPARE_MODE</code>, <code>GL_TEXTURE_COMPARE_FUNC</code>, and
        /// <code>GL_GENERATE_MIPMAP</code> is available only if the GL version is 1.4 or
        /// greater.
        /// If an error is generated,
        /// no change is made to the contents of <paramref name="ps"/>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="target"/> or <paramref name="pname"/> is not an
        /// accepted value.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glGetTexParameter"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glGetTexParameterfv(GLenum target, GLenum pname, GLfloat * params);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the symbolic name of the target texture.
        /// <code>GL_TEXTURE_1D</code>,
        /// <code>GL_TEXTURE_2D</code>,
        /// <code>GL_TEXTURE_3D</code>, and
        /// <code>GL_TEXTURE_CUBE_MAP</code>
        /// are accepted.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of a texture parameter.
        /// <code>GL_TEXTURE_MAG_FILTER</code>,
        /// <code>GL_TEXTURE_MIN_FILTER</code>,
        /// <code>GL_TEXTURE_MIN_LOD</code>,
        /// <code>GL_TEXTURE_MAX_LOD</code>,
        /// <code>GL_TEXTURE_BASE_LEVEL</code>,
        /// <code>GL_TEXTURE_MAX_LEVEL</code>,
        /// <code>GL_TEXTURE_WRAP_S</code>,
        /// <code>GL_TEXTURE_WRAP_T</code>,
        /// <code>GL_TEXTURE_WRAP_R</code>,
        /// <code>GL_TEXTURE_BORDER_COLOR</code>,
        /// <code>GL_TEXTURE_PRIORITY</code>,
        /// <code>GL_TEXTURE_RESIDENT</code>,
        /// <code>GL_TEXTURE_COMPARE_MODE</code>,
        /// <code>GL_TEXTURE_COMPARE_FUNC</code>,
        /// <code>GL_DEPTH_TEXTURE_MODE</code>, and
        /// <code>GL_GENERATE_MIPMAP</code>
        /// are accepted.
        /// </para>
        /// </param>
        /// <param name="ps">
        /// Returns the texture parameters.
        /// </param>
        /// <seealso cref="AreTexturesResident"/>
        /// <seealso cref="PrioritizeTextures"/>
        /// <seealso cref="TexParameter"/>
        public unsafe static void GetTexParameterfv(uint target, uint pname, ref float ps) {
            fixed (float* pPs = &ps) {
                GLNative.glGetTexParameterfv(target, pname, pPs);
            }
        }

        /// <summary>
        /// return texture parameter values
        /// <para>Require:</para> <para>GL_VERSION_1_0, GL_VERSION_ES_CM_1_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <code>GL_TEXTURE_PRIORITY</code> and <code>GL_TEXTURE_RESIDENT</code> are
        /// available only if the GL version is 1.1 or greater.
        /// <code>GL_TEXTURE_3D</code>,
        /// <code>GL_TEXTURE_MIN_LOD</code>, <code>GL_TEXTURE_MAX_LOD</code>, <code>GL_TEXTURE_BASE_LEVEL</code>,
        /// <code>GL_TEXTURE_MAX_LEVEL</code>, and <code>GL_TEXTURE_WRAP_R</code> are available only
        /// if the GL version is 1.2 or greater.
        /// <code>GL_TEXTURE_COMPARE_MODE</code>, <code>GL_TEXTURE_COMPARE_FUNC</code>, and
        /// <code>GL_GENERATE_MIPMAP</code> is available only if the GL version is 1.4 or
        /// greater.
        /// If an error is generated,
        /// no change is made to the contents of <paramref name="ps"/>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="target"/> or <paramref name="pname"/> is not an
        /// accepted value.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glGetTexParameter"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glGetTexParameteriv(GLenum target, GLenum pname, GLint * params);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the symbolic name of the target texture.
        /// <code>GL_TEXTURE_1D</code>,
        /// <code>GL_TEXTURE_2D</code>,
        /// <code>GL_TEXTURE_3D</code>, and
        /// <code>GL_TEXTURE_CUBE_MAP</code>
        /// are accepted.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of a texture parameter.
        /// <code>GL_TEXTURE_MAG_FILTER</code>,
        /// <code>GL_TEXTURE_MIN_FILTER</code>,
        /// <code>GL_TEXTURE_MIN_LOD</code>,
        /// <code>GL_TEXTURE_MAX_LOD</code>,
        /// <code>GL_TEXTURE_BASE_LEVEL</code>,
        /// <code>GL_TEXTURE_MAX_LEVEL</code>,
        /// <code>GL_TEXTURE_WRAP_S</code>,
        /// <code>GL_TEXTURE_WRAP_T</code>,
        /// <code>GL_TEXTURE_WRAP_R</code>,
        /// <code>GL_TEXTURE_BORDER_COLOR</code>,
        /// <code>GL_TEXTURE_PRIORITY</code>,
        /// <code>GL_TEXTURE_RESIDENT</code>,
        /// <code>GL_TEXTURE_COMPARE_MODE</code>,
        /// <code>GL_TEXTURE_COMPARE_FUNC</code>,
        /// <code>GL_DEPTH_TEXTURE_MODE</code>, and
        /// <code>GL_GENERATE_MIPMAP</code>
        /// are accepted.
        /// </para>
        /// </param>
        /// <param name="ps">
        /// Returns the texture parameters.
        /// </param>
        /// <seealso cref="AreTexturesResident"/>
        /// <seealso cref="PrioritizeTextures"/>
        /// <seealso cref="TexParameter"/>
        public unsafe static void GetTexParameteriv(uint target, uint pname, ref int ps) {
            fixed (int* pPs = &ps) {
                GLNative.glGetTexParameteriv(target, pname, pPs);
            }
        }

        /// <summary>
        /// return texture parameter values for a specific level of detail
        /// <para>Require:</para> <para>GL_VERSION_1_0, GL_ES_VERSION_3_1</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// If an error is generated,
        /// no change is made to the contents of <paramref name="ps"/>.
        /// <code>GL_TEXTURE_INTERNAL_FORMAT</code> is available only if the GL version is
        /// 1.1 or greater. In version 1.0, use <code>GL_TEXTURE_COMPONENTS</code>
        /// instead.
        /// <code>GL_PROXY_TEXTURE_1D</code> and <code>GL_PROXY_TEXTURE_2D</code> are
        /// available only if the GL version is 1.1 or greater.
        /// <code>GL_TEXTURE_3D</code>, <code>GL_PROXY_TEXTURE_3D</code>, and <code>GL_TEXTURE_DEPTH</code>
        /// are available only if the GL version is 1.2 or greater.
        /// <code>GL_TEXTURE_COMPRESSED</code>,
        /// <code>GL_TEXTURE_COMPRESSED_IMAGE_SIZE</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_POSITIVE_X</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_NEGATIVE_X</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_POSITIVE_Y</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_NEGATIVE_Y</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_POSITIVE_Z</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_NEGATIVE_Z</code>, and
        /// <code>GL_PROXY_TEXTURE_CUBE_MAP</code> are available only if the GL version is 1.3
        /// or greater.
        /// For OpenGL versions 1.3 and greater, or when the <code>ARB_multitexture</code> extension is supported, <see cref="glGetTexLevelParameter"/> returns
        /// the texture level parameters for the active texture unit.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="target"/> or <paramref name="pname"/> is not an
        /// accepted value.
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="level"/> is less than 0.
        /// <code>GL_INVALID_VALUE</code> may be generated if <paramref name="level"/> is greater
        /// than 
        /// log 
        /// 2 
        /// max ,
        /// where  max  is the returned value of <code>GL_MAX_TEXTURE_SIZE</code>.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glGetTexLevelParameter"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <code>GL_TEXTURE_COMPRESSED_IMAGE_SIZE</code> is queried on texture images with an
        /// uncompressed internal format or on proxy targets.
        /// </para>
        /// Original: <para>void glGetTexLevelParameterfv(GLenum target, GLint level, GLenum pname, GLfloat * params);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the symbolic name of the target texture,
        /// either <code>GL_TEXTURE_1D</code>, <code>GL_TEXTURE_2D</code>, <code>GL_TEXTURE_3D</code>,
        /// <code>GL_PROXY_TEXTURE_1D</code>, <code>GL_PROXY_TEXTURE_2D</code>,
        /// <code>GL_PROXY_TEXTURE_3D</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_POSITIVE_X</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_NEGATIVE_X</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_POSITIVE_Y</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_NEGATIVE_Y</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_POSITIVE_Z</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_NEGATIVE_Z</code>, or
        /// <code>GL_PROXY_TEXTURE_CUBE_MAP</code>.
        /// </para>
        /// </param>
        /// <param name="level">
        /// <para>
        /// Specifies the level-of-detail number of the desired image.
        /// Level 0 is the base image level.
        /// Level 
        /// n   
        /// is the 
        /// n   th
        /// mipmap reduction image.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of a texture parameter.
        /// <code>GL_TEXTURE_WIDTH</code>,
        /// <code>GL_TEXTURE_HEIGHT</code>,
        /// <code>GL_TEXTURE_DEPTH</code>,
        /// <code>GL_TEXTURE_INTERNAL_FORMAT</code>,
        /// <code>GL_TEXTURE_BORDER</code>,
        /// <code>GL_TEXTURE_RED_SIZE</code>,
        /// <code>GL_TEXTURE_GREEN_SIZE</code>,
        /// <code>GL_TEXTURE_BLUE_SIZE</code>,
        /// <code>GL_TEXTURE_ALPHA_SIZE</code>,
        /// <code>GL_TEXTURE_LUMINANCE_SIZE</code>,
        /// <code>GL_TEXTURE_INTENSITY_SIZE</code>,
        /// <code>GL_TEXTURE_DEPTH_SIZE</code>,
        /// <code>GL_TEXTURE_COMPRESSED</code>, and
        /// <code>GL_TEXTURE_COMPRESSED_IMAGE_SIZE</code>
        /// are accepted.
        /// </para>
        /// </param>
        /// <param name="ps">
        /// Returns the requested data.
        /// </param>
        /// <seealso cref="ActiveTexture"/>
        /// <seealso cref="GetTexParameter"/>
        /// <seealso cref="CopyTexImage1D"/>
        /// <seealso cref="CopyTexImage2D"/>
        /// <seealso cref="CopyTexSubImage1D"/>
        /// <seealso cref="CopyTexSubImage2D"/>
        /// <seealso cref="CopyTexSubImage3D"/>
        /// <seealso cref="TexEnv"/>
        /// <seealso cref="TexGen"/>
        /// <seealso cref="TexImage1D"/>
        /// <seealso cref="TexImage2D"/>
        /// <seealso cref="TexImage3D"/>
        /// <seealso cref="TexSubImage1D"/>
        /// <seealso cref="TexSubImage2D"/>
        /// <seealso cref="TexSubImage3D"/>
        /// <seealso cref="TexParameter"/>
        public unsafe static void GetTexLevelParameterfv(uint target, int level, uint pname, ref float ps) {
            fixed (float* pPs = &ps) {
                GLNative.glGetTexLevelParameterfv(target, level, pname, pPs);
            }
        }

        /// <summary>
        /// return texture parameter values for a specific level of detail
        /// <para>Require:</para> <para>GL_VERSION_1_0, GL_ES_VERSION_3_1</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// If an error is generated,
        /// no change is made to the contents of <paramref name="ps"/>.
        /// <code>GL_TEXTURE_INTERNAL_FORMAT</code> is available only if the GL version is
        /// 1.1 or greater. In version 1.0, use <code>GL_TEXTURE_COMPONENTS</code>
        /// instead.
        /// <code>GL_PROXY_TEXTURE_1D</code> and <code>GL_PROXY_TEXTURE_2D</code> are
        /// available only if the GL version is 1.1 or greater.
        /// <code>GL_TEXTURE_3D</code>, <code>GL_PROXY_TEXTURE_3D</code>, and <code>GL_TEXTURE_DEPTH</code>
        /// are available only if the GL version is 1.2 or greater.
        /// <code>GL_TEXTURE_COMPRESSED</code>,
        /// <code>GL_TEXTURE_COMPRESSED_IMAGE_SIZE</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_POSITIVE_X</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_NEGATIVE_X</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_POSITIVE_Y</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_NEGATIVE_Y</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_POSITIVE_Z</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_NEGATIVE_Z</code>, and
        /// <code>GL_PROXY_TEXTURE_CUBE_MAP</code> are available only if the GL version is 1.3
        /// or greater.
        /// For OpenGL versions 1.3 and greater, or when the <code>ARB_multitexture</code> extension is supported, <see cref="glGetTexLevelParameter"/> returns
        /// the texture level parameters for the active texture unit.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="target"/> or <paramref name="pname"/> is not an
        /// accepted value.
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="level"/> is less than 0.
        /// <code>GL_INVALID_VALUE</code> may be generated if <paramref name="level"/> is greater
        /// than 
        /// log 
        /// 2 
        /// max ,
        /// where  max  is the returned value of <code>GL_MAX_TEXTURE_SIZE</code>.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glGetTexLevelParameter"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <code>GL_TEXTURE_COMPRESSED_IMAGE_SIZE</code> is queried on texture images with an
        /// uncompressed internal format or on proxy targets.
        /// </para>
        /// Original: <para>void glGetTexLevelParameteriv(GLenum target, GLint level, GLenum pname, GLint * params);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the symbolic name of the target texture,
        /// either <code>GL_TEXTURE_1D</code>, <code>GL_TEXTURE_2D</code>, <code>GL_TEXTURE_3D</code>,
        /// <code>GL_PROXY_TEXTURE_1D</code>, <code>GL_PROXY_TEXTURE_2D</code>,
        /// <code>GL_PROXY_TEXTURE_3D</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_POSITIVE_X</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_NEGATIVE_X</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_POSITIVE_Y</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_NEGATIVE_Y</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_POSITIVE_Z</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_NEGATIVE_Z</code>, or
        /// <code>GL_PROXY_TEXTURE_CUBE_MAP</code>.
        /// </para>
        /// </param>
        /// <param name="level">
        /// <para>
        /// Specifies the level-of-detail number of the desired image.
        /// Level 0 is the base image level.
        /// Level 
        /// n   
        /// is the 
        /// n   th
        /// mipmap reduction image.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of a texture parameter.
        /// <code>GL_TEXTURE_WIDTH</code>,
        /// <code>GL_TEXTURE_HEIGHT</code>,
        /// <code>GL_TEXTURE_DEPTH</code>,
        /// <code>GL_TEXTURE_INTERNAL_FORMAT</code>,
        /// <code>GL_TEXTURE_BORDER</code>,
        /// <code>GL_TEXTURE_RED_SIZE</code>,
        /// <code>GL_TEXTURE_GREEN_SIZE</code>,
        /// <code>GL_TEXTURE_BLUE_SIZE</code>,
        /// <code>GL_TEXTURE_ALPHA_SIZE</code>,
        /// <code>GL_TEXTURE_LUMINANCE_SIZE</code>,
        /// <code>GL_TEXTURE_INTENSITY_SIZE</code>,
        /// <code>GL_TEXTURE_DEPTH_SIZE</code>,
        /// <code>GL_TEXTURE_COMPRESSED</code>, and
        /// <code>GL_TEXTURE_COMPRESSED_IMAGE_SIZE</code>
        /// are accepted.
        /// </para>
        /// </param>
        /// <param name="ps">
        /// Returns the requested data.
        /// </param>
        /// <seealso cref="ActiveTexture"/>
        /// <seealso cref="GetTexParameter"/>
        /// <seealso cref="CopyTexImage1D"/>
        /// <seealso cref="CopyTexImage2D"/>
        /// <seealso cref="CopyTexSubImage1D"/>
        /// <seealso cref="CopyTexSubImage2D"/>
        /// <seealso cref="CopyTexSubImage3D"/>
        /// <seealso cref="TexEnv"/>
        /// <seealso cref="TexGen"/>
        /// <seealso cref="TexImage1D"/>
        /// <seealso cref="TexImage2D"/>
        /// <seealso cref="TexImage3D"/>
        /// <seealso cref="TexSubImage1D"/>
        /// <seealso cref="TexSubImage2D"/>
        /// <seealso cref="TexSubImage3D"/>
        /// <seealso cref="TexParameter"/>
        public unsafe static void GetTexLevelParameteriv(uint target, int level, uint pname, ref int ps) {
            fixed (int* pPs = &ps) {
                GLNative.glGetTexLevelParameteriv(target, level, pname, pPs);
            }
        }

        /// <summary>
        /// execute a list of display lists
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// Display lists can be executed between a call to  <see cref="glBegin"/> 
        /// and the corresponding call to  <see cref="glEnd"/> ,
        /// as long as the display list includes only commands that are allowed
        /// in this interval.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="n"/> is negative.
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="type"/> is not one of
        /// <code>GL_BYTE</code>,
        /// <code>GL_UNSIGNED_BYTE</code>,
        /// <code>GL_SHORT</code>,
        /// <code>GL_UNSIGNED_SHORT</code>,
        /// <code>GL_INT</code>,
        /// <code>GL_UNSIGNED_INT</code>,
        /// <code>GL_FLOAT</code>,
        /// <code>GL_2_BYTES</code>,
        /// <code>GL_3_BYTES</code>,
        /// <code>GL_4_BYTES</code>.
        /// </para>
        /// Original: <para>void glCallLists(GLsizei n, GLenum type, const void * lists);</para>
        /// </summary>
        /// <param name="n">
        /// Specifies the number of display lists to be executed.
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the type of values in <paramref name="lists"/>.
        /// Symbolic constants
        /// <code>GL_BYTE</code>,
        /// <code>GL_UNSIGNED_BYTE</code>,
        /// <code>GL_SHORT</code>,
        /// <code>GL_UNSIGNED_SHORT</code>,
        /// <code>GL_INT</code>,
        /// <code>GL_UNSIGNED_INT</code>,
        /// <code>GL_FLOAT</code>,
        /// <code>GL_2_BYTES</code>,
        /// <code>GL_3_BYTES</code>, and
        /// <code>GL_4_BYTES</code> are accepted.
        /// </para>
        /// </param>
        /// <param name="lists">
        /// <para>
        /// Specifies the address of an array of name offsets in the display list.
        /// The pointer type is void because the offsets can be bytes,
        /// shorts,
        /// ints,
        /// or floats,
        /// depending on the value of <paramref name="type"/>.
        /// </para>
        /// </param>
        /// <seealso cref="CallList"/>
        /// <seealso cref="DeleteLists"/>
        /// <seealso cref="GenLists"/>
        /// <seealso cref="ListBase"/>
        /// <seealso cref="NewList"/>
        /// <seealso cref="PushAttrib"/>
        /// <seealso cref="PushMatrix"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void CallLists(int n, uint type, IntPtr lists) {
            GLNative.glCallLists(n, type, (void*)lists);
        }

        /// <summary>
        /// draw a bitmap
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// To set a valid raster position outside the viewport, first set a valid
        /// raster position inside the viewport, then call <see cref="glBitmap"/> with NULL
        /// as the <paramref name="bitmap"/> parameter and with <paramref name="xmove"/> and <paramref name="ymove"/> set to
        /// the offsets of the new raster position. This technique is useful when
        /// panning an image around the viewport.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="width"/> or <paramref name="height"/> is negative.
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_UNPACK_BUFFER</code> target and the buffer object's data store is currently mapped.
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_UNPACK_BUFFER</code> target and the data would be unpacked from the buffer 
        /// object such that the memory reads required would exceed the data store size.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glBitmap"/>
        /// is executed between the execution of  <see cref="glBegin"/>  and the corresponding execution of
        /// <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glBitmap(GLsizei width, GLsizei height, GLfloat xorig, GLfloat yorig, GLfloat xmove, GLfloat ymove, const GLubyte * bitmap);</para>
        /// </summary>
        /// <param name="width">
        /// Specify the pixel width and height of the bitmap image.
        /// </param>
        /// <param name="height">
        /// Specify the pixel width and height of the bitmap image.
        /// </param>
        /// <param name="xorig">
        /// <para>
        /// Specify the location of the origin in the bitmap image.
        /// The origin is measured from the lower left corner of the bitmap,
        /// with right and up being the positive axes.
        /// </para>
        /// </param>
        /// <param name="yorig">
        /// <para>
        /// Specify the location of the origin in the bitmap image.
        /// The origin is measured from the lower left corner of the bitmap,
        /// with right and up being the positive axes.
        /// </para>
        /// </param>
        /// <param name="xmove">
        /// <para>
        /// Specify the  x  and  y  offsets to be added to the current raster position
        /// after the bitmap is drawn.
        /// </para>
        /// </param>
        /// <param name="ymove">
        /// <para>
        /// Specify the  x  and  y  offsets to be added to the current raster position
        /// after the bitmap is drawn.
        /// </para>
        /// </param>
        /// <param name="bitmap">
        /// Specifies the address of the bitmap image.
        /// </param>
        /// <seealso cref="BindBuffer"/>
        /// <seealso cref="DrawPixels"/>
        /// <seealso cref="PixelStore"/>
        /// <seealso cref="PixelTransfer"/>
        /// <seealso cref="RasterPos"/>
        /// <seealso cref="WindowPos"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void Bitmap(int width, int height, float xorig, float yorig, float xmove, float ymove, ref byte bitmap) {
            fixed (byte* pBitmap = &bitmap) {
                GLNative.glBitmap(width, height, xorig, yorig, xmove, ymove, pBitmap);
            }
        }

        /// <summary>
        /// set the current color
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The initial value for the current color is (1, 1, 1, 1).
        /// The current color can be updated at any time.
        /// In particular,
        /// <see cref="glColor"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glColor3bv(const GLbyte * v);</para>
        /// </summary>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array that contains red, green, blue,
        /// and (sometimes) alpha values.
        /// </para>
        /// </param>
        /// <seealso cref="ColorPointer"/>
        /// <seealso cref="Index"/>
        /// <seealso cref="SecondaryColor"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void Color3bv(ref byte v) {
            fixed (byte* pV = &v) {
                GLNative.glColor3bv(pV);
            }
        }

        /// <summary>
        /// set the current color
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The initial value for the current color is (1, 1, 1, 1).
        /// The current color can be updated at any time.
        /// In particular,
        /// <see cref="glColor"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glColor3dv(const GLdouble * v);</para>
        /// </summary>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array that contains red, green, blue,
        /// and (sometimes) alpha values.
        /// </para>
        /// </param>
        /// <seealso cref="ColorPointer"/>
        /// <seealso cref="Index"/>
        /// <seealso cref="SecondaryColor"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void Color3dv(ref double v) {
            fixed (double* pV = &v) {
                GLNative.glColor3dv(pV);
            }
        }

        /// <summary>
        /// set the current color
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The initial value for the current color is (1, 1, 1, 1).
        /// The current color can be updated at any time.
        /// In particular,
        /// <see cref="glColor"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glColor3fv(const GLfloat * v);</para>
        /// </summary>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array that contains red, green, blue,
        /// and (sometimes) alpha values.
        /// </para>
        /// </param>
        /// <seealso cref="ColorPointer"/>
        /// <seealso cref="Index"/>
        /// <seealso cref="SecondaryColor"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void Color3fv(ref float v) {
            fixed (float* pV = &v) {
                GLNative.glColor3fv(pV);
            }
        }

        /// <summary>
        /// set the current color
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The initial value for the current color is (1, 1, 1, 1).
        /// The current color can be updated at any time.
        /// In particular,
        /// <see cref="glColor"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glColor3iv(const GLint * v);</para>
        /// </summary>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array that contains red, green, blue,
        /// and (sometimes) alpha values.
        /// </para>
        /// </param>
        /// <seealso cref="ColorPointer"/>
        /// <seealso cref="Index"/>
        /// <seealso cref="SecondaryColor"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void Color3iv(ref int v) {
            fixed (int* pV = &v) {
                GLNative.glColor3iv(pV);
            }
        }

        /// <summary>
        /// set the current color
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The initial value for the current color is (1, 1, 1, 1).
        /// The current color can be updated at any time.
        /// In particular,
        /// <see cref="glColor"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glColor3sv(const GLshort * v);</para>
        /// </summary>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array that contains red, green, blue,
        /// and (sometimes) alpha values.
        /// </para>
        /// </param>
        /// <seealso cref="ColorPointer"/>
        /// <seealso cref="Index"/>
        /// <seealso cref="SecondaryColor"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void Color3sv(ref short v) {
            fixed (short* pV = &v) {
                GLNative.glColor3sv(pV);
            }
        }

        /// <summary>
        /// set the current color
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The initial value for the current color is (1, 1, 1, 1).
        /// The current color can be updated at any time.
        /// In particular,
        /// <see cref="glColor"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glColor3ubv(const GLubyte * v);</para>
        /// </summary>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array that contains red, green, blue,
        /// and (sometimes) alpha values.
        /// </para>
        /// </param>
        /// <seealso cref="ColorPointer"/>
        /// <seealso cref="Index"/>
        /// <seealso cref="SecondaryColor"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void Color3ubv(ref byte v) {
            fixed (byte* pV = &v) {
                GLNative.glColor3ubv(pV);
            }
        }

        /// <summary>
        /// set the current color
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The initial value for the current color is (1, 1, 1, 1).
        /// The current color can be updated at any time.
        /// In particular,
        /// <see cref="glColor"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glColor3uiv(const GLuint * v);</para>
        /// </summary>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array that contains red, green, blue,
        /// and (sometimes) alpha values.
        /// </para>
        /// </param>
        /// <seealso cref="ColorPointer"/>
        /// <seealso cref="Index"/>
        /// <seealso cref="SecondaryColor"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void Color3uiv(ref uint v) {
            fixed (uint* pV = &v) {
                GLNative.glColor3uiv(pV);
            }
        }

        /// <summary>
        /// set the current color
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The initial value for the current color is (1, 1, 1, 1).
        /// The current color can be updated at any time.
        /// In particular,
        /// <see cref="glColor"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glColor3usv(const GLushort * v);</para>
        /// </summary>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array that contains red, green, blue,
        /// and (sometimes) alpha values.
        /// </para>
        /// </param>
        /// <seealso cref="ColorPointer"/>
        /// <seealso cref="Index"/>
        /// <seealso cref="SecondaryColor"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void Color3usv(ref ushort v) {
            fixed (ushort* pV = &v) {
                GLNative.glColor3usv(pV);
            }
        }

        /// <summary>
        /// set the current color
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The initial value for the current color is (1, 1, 1, 1).
        /// The current color can be updated at any time.
        /// In particular,
        /// <see cref="glColor"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glColor4bv(const GLbyte * v);</para>
        /// </summary>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array that contains red, green, blue,
        /// and (sometimes) alpha values.
        /// </para>
        /// </param>
        /// <seealso cref="ColorPointer"/>
        /// <seealso cref="Index"/>
        /// <seealso cref="SecondaryColor"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void Color4bv(ref byte v) {
            fixed (byte* pV = &v) {
                GLNative.glColor4bv(pV);
            }
        }

        /// <summary>
        /// set the current color
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The initial value for the current color is (1, 1, 1, 1).
        /// The current color can be updated at any time.
        /// In particular,
        /// <see cref="glColor"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glColor4dv(const GLdouble * v);</para>
        /// </summary>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array that contains red, green, blue,
        /// and (sometimes) alpha values.
        /// </para>
        /// </param>
        /// <seealso cref="ColorPointer"/>
        /// <seealso cref="Index"/>
        /// <seealso cref="SecondaryColor"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void Color4dv(ref double v) {
            fixed (double* pV = &v) {
                GLNative.glColor4dv(pV);
            }
        }

        /// <summary>
        /// set the current color
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The initial value for the current color is (1, 1, 1, 1).
        /// The current color can be updated at any time.
        /// In particular,
        /// <see cref="glColor"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glColor4fv(const GLfloat * v);</para>
        /// </summary>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array that contains red, green, blue,
        /// and (sometimes) alpha values.
        /// </para>
        /// </param>
        /// <seealso cref="ColorPointer"/>
        /// <seealso cref="Index"/>
        /// <seealso cref="SecondaryColor"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void Color4fv(ref float v) {
            fixed (float* pV = &v) {
                GLNative.glColor4fv(pV);
            }
        }

        /// <summary>
        /// set the current color
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The initial value for the current color is (1, 1, 1, 1).
        /// The current color can be updated at any time.
        /// In particular,
        /// <see cref="glColor"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glColor4iv(const GLint * v);</para>
        /// </summary>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array that contains red, green, blue,
        /// and (sometimes) alpha values.
        /// </para>
        /// </param>
        /// <seealso cref="ColorPointer"/>
        /// <seealso cref="Index"/>
        /// <seealso cref="SecondaryColor"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void Color4iv(ref int v) {
            fixed (int* pV = &v) {
                GLNative.glColor4iv(pV);
            }
        }

        /// <summary>
        /// set the current color
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The initial value for the current color is (1, 1, 1, 1).
        /// The current color can be updated at any time.
        /// In particular,
        /// <see cref="glColor"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glColor4sv(const GLshort * v);</para>
        /// </summary>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array that contains red, green, blue,
        /// and (sometimes) alpha values.
        /// </para>
        /// </param>
        /// <seealso cref="ColorPointer"/>
        /// <seealso cref="Index"/>
        /// <seealso cref="SecondaryColor"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void Color4sv(ref short v) {
            fixed (short* pV = &v) {
                GLNative.glColor4sv(pV);
            }
        }

        /// <summary>
        /// set the current color
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The initial value for the current color is (1, 1, 1, 1).
        /// The current color can be updated at any time.
        /// In particular,
        /// <see cref="glColor"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glColor4ubv(const GLubyte * v);</para>
        /// </summary>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array that contains red, green, blue,
        /// and (sometimes) alpha values.
        /// </para>
        /// </param>
        /// <seealso cref="ColorPointer"/>
        /// <seealso cref="Index"/>
        /// <seealso cref="SecondaryColor"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void Color4ubv(ref byte v) {
            fixed (byte* pV = &v) {
                GLNative.glColor4ubv(pV);
            }
        }

        /// <summary>
        /// set the current color
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The initial value for the current color is (1, 1, 1, 1).
        /// The current color can be updated at any time.
        /// In particular,
        /// <see cref="glColor"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glColor4uiv(const GLuint * v);</para>
        /// </summary>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array that contains red, green, blue,
        /// and (sometimes) alpha values.
        /// </para>
        /// </param>
        /// <seealso cref="ColorPointer"/>
        /// <seealso cref="Index"/>
        /// <seealso cref="SecondaryColor"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void Color4uiv(ref uint v) {
            fixed (uint* pV = &v) {
                GLNative.glColor4uiv(pV);
            }
        }

        /// <summary>
        /// set the current color
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The initial value for the current color is (1, 1, 1, 1).
        /// The current color can be updated at any time.
        /// In particular,
        /// <see cref="glColor"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glColor4usv(const GLushort * v);</para>
        /// </summary>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array that contains red, green, blue,
        /// and (sometimes) alpha values.
        /// </para>
        /// </param>
        /// <seealso cref="ColorPointer"/>
        /// <seealso cref="Index"/>
        /// <seealso cref="SecondaryColor"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void Color4usv(ref ushort v) {
            fixed (ushort* pV = &v) {
                GLNative.glColor4usv(pV);
            }
        }

        /// <summary>
        /// flag edges as either boundary or nonboundary
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The current edge flag can be updated at any time.
        /// In particular,
        /// <see cref="glEdgeFlag"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glEdgeFlagv(const GLboolean * flag);</para>
        /// </summary>
        /// <param name="flag">
        /// <para>
        /// Specifies a pointer to an array that contains a single boolean element,
        /// which replaces the current edge flag value.
        /// </para>
        /// </param>
        /// <seealso cref="Begin"/>
        /// <seealso cref="EdgeFlagPointer"/>
        /// <seealso cref="PolygonMode"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void EdgeFlagv(ref bool flag) {
            fixed (bool* pFlag = &flag) {
                GLNative.glEdgeFlagv(pFlag);
            }
        }

        /// <summary>
        /// set the current color index
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glIndexub"/> and <see cref="glIndexubv"/> are available only if the GL version is
        /// 1.1 or greater.
        /// The current index can be updated at any time.
        /// In particular,
        /// <see cref="glIndex"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glIndexdv(const GLdouble * c);</para>
        /// </summary>
        /// <param name="c">
        /// <para>
        /// Specifies a pointer to a one-element array that contains
        /// the new value for the current color index.
        /// </para>
        /// </param>
        /// <seealso cref="Color"/>
        /// <seealso cref="IndexPointer"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void Indexdv(ref double c) {
            fixed (double* pC = &c) {
                GLNative.glIndexdv(pC);
            }
        }

        /// <summary>
        /// set the current color index
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glIndexub"/> and <see cref="glIndexubv"/> are available only if the GL version is
        /// 1.1 or greater.
        /// The current index can be updated at any time.
        /// In particular,
        /// <see cref="glIndex"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glIndexfv(const GLfloat * c);</para>
        /// </summary>
        /// <param name="c">
        /// <para>
        /// Specifies a pointer to a one-element array that contains
        /// the new value for the current color index.
        /// </para>
        /// </param>
        /// <seealso cref="Color"/>
        /// <seealso cref="IndexPointer"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void Indexfv(ref float c) {
            fixed (float* pC = &c) {
                GLNative.glIndexfv(pC);
            }
        }

        /// <summary>
        /// set the current color index
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glIndexub"/> and <see cref="glIndexubv"/> are available only if the GL version is
        /// 1.1 or greater.
        /// The current index can be updated at any time.
        /// In particular,
        /// <see cref="glIndex"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glIndexiv(const GLint * c);</para>
        /// </summary>
        /// <param name="c">
        /// <para>
        /// Specifies a pointer to a one-element array that contains
        /// the new value for the current color index.
        /// </para>
        /// </param>
        /// <seealso cref="Color"/>
        /// <seealso cref="IndexPointer"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void Indexiv(ref int c) {
            fixed (int* pC = &c) {
                GLNative.glIndexiv(pC);
            }
        }

        /// <summary>
        /// set the current color index
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glIndexub"/> and <see cref="glIndexubv"/> are available only if the GL version is
        /// 1.1 or greater.
        /// The current index can be updated at any time.
        /// In particular,
        /// <see cref="glIndex"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glIndexsv(const GLshort * c);</para>
        /// </summary>
        /// <param name="c">
        /// <para>
        /// Specifies a pointer to a one-element array that contains
        /// the new value for the current color index.
        /// </para>
        /// </param>
        /// <seealso cref="Color"/>
        /// <seealso cref="IndexPointer"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void Indexsv(ref short c) {
            fixed (short* pC = &c) {
                GLNative.glIndexsv(pC);
            }
        }

        /// <summary>
        /// set the current normal vector
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The current normal can be updated at any time.
        /// In particular, <see cref="glNormal"/> can be called between a call to  <see cref="glBegin"/>  and
        /// the corresponding call to  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glNormal3bv(const GLbyte * v);</para>
        /// </summary>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array of three elements:
        /// the 
        /// x   ,
        /// y   ,
        /// and 
        /// z   
        /// coordinates of the new current normal.
        /// </para>
        /// </param>
        /// <seealso cref="Begin"/>
        /// <seealso cref="Color"/>
        /// <seealso cref="Index"/>
        /// <seealso cref="MultiTexCoord"/>
        /// <seealso cref="NormalPointer"/>
        /// <seealso cref="TexCoord"/>
        /// <seealso cref="Vertex"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void Normal3bv(ref byte v) {
            fixed (byte* pV = &v) {
                GLNative.glNormal3bv(pV);
            }
        }

        /// <summary>
        /// set the current normal vector
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The current normal can be updated at any time.
        /// In particular, <see cref="glNormal"/> can be called between a call to  <see cref="glBegin"/>  and
        /// the corresponding call to  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glNormal3dv(const GLdouble * v);</para>
        /// </summary>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array of three elements:
        /// the 
        /// x   ,
        /// y   ,
        /// and 
        /// z   
        /// coordinates of the new current normal.
        /// </para>
        /// </param>
        /// <seealso cref="Begin"/>
        /// <seealso cref="Color"/>
        /// <seealso cref="Index"/>
        /// <seealso cref="MultiTexCoord"/>
        /// <seealso cref="NormalPointer"/>
        /// <seealso cref="TexCoord"/>
        /// <seealso cref="Vertex"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void Normal3dv(ref double v) {
            fixed (double* pV = &v) {
                GLNative.glNormal3dv(pV);
            }
        }

        /// <summary>
        /// set the current normal vector
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The current normal can be updated at any time.
        /// In particular, <see cref="glNormal"/> can be called between a call to  <see cref="glBegin"/>  and
        /// the corresponding call to  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glNormal3fv(const GLfloat * v);</para>
        /// </summary>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array of three elements:
        /// the 
        /// x   ,
        /// y   ,
        /// and 
        /// z   
        /// coordinates of the new current normal.
        /// </para>
        /// </param>
        /// <seealso cref="Begin"/>
        /// <seealso cref="Color"/>
        /// <seealso cref="Index"/>
        /// <seealso cref="MultiTexCoord"/>
        /// <seealso cref="NormalPointer"/>
        /// <seealso cref="TexCoord"/>
        /// <seealso cref="Vertex"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void Normal3fv(ref float v) {
            fixed (float* pV = &v) {
                GLNative.glNormal3fv(pV);
            }
        }

        /// <summary>
        /// set the current normal vector
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The current normal can be updated at any time.
        /// In particular, <see cref="glNormal"/> can be called between a call to  <see cref="glBegin"/>  and
        /// the corresponding call to  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glNormal3iv(const GLint * v);</para>
        /// </summary>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array of three elements:
        /// the 
        /// x   ,
        /// y   ,
        /// and 
        /// z   
        /// coordinates of the new current normal.
        /// </para>
        /// </param>
        /// <seealso cref="Begin"/>
        /// <seealso cref="Color"/>
        /// <seealso cref="Index"/>
        /// <seealso cref="MultiTexCoord"/>
        /// <seealso cref="NormalPointer"/>
        /// <seealso cref="TexCoord"/>
        /// <seealso cref="Vertex"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void Normal3iv(ref int v) {
            fixed (int* pV = &v) {
                GLNative.glNormal3iv(pV);
            }
        }

        /// <summary>
        /// set the current normal vector
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The current normal can be updated at any time.
        /// In particular, <see cref="glNormal"/> can be called between a call to  <see cref="glBegin"/>  and
        /// the corresponding call to  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glNormal3sv(const GLshort * v);</para>
        /// </summary>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array of three elements:
        /// the 
        /// x   ,
        /// y   ,
        /// and 
        /// z   
        /// coordinates of the new current normal.
        /// </para>
        /// </param>
        /// <seealso cref="Begin"/>
        /// <seealso cref="Color"/>
        /// <seealso cref="Index"/>
        /// <seealso cref="MultiTexCoord"/>
        /// <seealso cref="NormalPointer"/>
        /// <seealso cref="TexCoord"/>
        /// <seealso cref="Vertex"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void Normal3sv(ref short v) {
            fixed (short* pV = &v) {
                GLNative.glNormal3sv(pV);
            }
        }

        /// <summary>
        /// specify the raster position for pixel operations
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The raster position is modified by <see cref="glRasterPos"/>,  <see cref="glBitmap"/> , and  <see cref="glWindowPos"/> .
        /// When the raster position coordinates are invalid,
        /// drawing commands that are based on the raster position are
        /// ignored (that is, they do not result in changes to GL state).
        /// Calling  <see cref="glDrawElements"/>  or  <see cref="glDrawRangeElements"/>  may leave the
        /// current color or index indeterminate.
        /// If <see cref="glRasterPos"/> is executed while the current color or index is indeterminate, the
        /// current raster color or current raster index remains indeterminate.
        /// To set a valid raster position outside the viewport, first set a valid
        /// raster position, then call  <see cref="glBitmap"/>  with NULL as the  bitmap 
        /// parameter.
        /// When the <code>ARB_imaging</code> extension is supported, there are distinct
        /// raster texture coordinates for each texture unit. Each texture unit's
        /// current raster texture coordinates are updated by <see cref="glRasterPos"/>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glRasterPos"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glRasterPos2dv(const GLdouble * v);</para>
        /// </summary>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array of two,
        /// three,
        /// or four elements,
        /// specifying 
        /// x   ,
        /// y   ,
        /// z   ,
        /// and 
        /// w   
        /// coordinates, respectively.
        /// </para>
        /// </param>
        /// <seealso cref="Bitmap"/>
        /// <seealso cref="CopyPixels"/>
        /// <seealso cref="DrawArrays"/>
        /// <seealso cref="DrawElements"/>
        /// <seealso cref="DrawRangeElements"/>
        /// <seealso cref="DrawPixels"/>
        /// <seealso cref="MultiTexCoord"/>
        /// <seealso cref="TexCoord"/>
        /// <seealso cref="TexGen"/>
        /// <seealso cref="Vertex"/>
        /// <seealso cref="WindowPos"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void RasterPos2dv(ref double v) {
            fixed (double* pV = &v) {
                GLNative.glRasterPos2dv(pV);
            }
        }

        /// <summary>
        /// specify the raster position for pixel operations
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The raster position is modified by <see cref="glRasterPos"/>,  <see cref="glBitmap"/> , and  <see cref="glWindowPos"/> .
        /// When the raster position coordinates are invalid,
        /// drawing commands that are based on the raster position are
        /// ignored (that is, they do not result in changes to GL state).
        /// Calling  <see cref="glDrawElements"/>  or  <see cref="glDrawRangeElements"/>  may leave the
        /// current color or index indeterminate.
        /// If <see cref="glRasterPos"/> is executed while the current color or index is indeterminate, the
        /// current raster color or current raster index remains indeterminate.
        /// To set a valid raster position outside the viewport, first set a valid
        /// raster position, then call  <see cref="glBitmap"/>  with NULL as the  bitmap 
        /// parameter.
        /// When the <code>ARB_imaging</code> extension is supported, there are distinct
        /// raster texture coordinates for each texture unit. Each texture unit's
        /// current raster texture coordinates are updated by <see cref="glRasterPos"/>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glRasterPos"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glRasterPos2fv(const GLfloat * v);</para>
        /// </summary>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array of two,
        /// three,
        /// or four elements,
        /// specifying 
        /// x   ,
        /// y   ,
        /// z   ,
        /// and 
        /// w   
        /// coordinates, respectively.
        /// </para>
        /// </param>
        /// <seealso cref="Bitmap"/>
        /// <seealso cref="CopyPixels"/>
        /// <seealso cref="DrawArrays"/>
        /// <seealso cref="DrawElements"/>
        /// <seealso cref="DrawRangeElements"/>
        /// <seealso cref="DrawPixels"/>
        /// <seealso cref="MultiTexCoord"/>
        /// <seealso cref="TexCoord"/>
        /// <seealso cref="TexGen"/>
        /// <seealso cref="Vertex"/>
        /// <seealso cref="WindowPos"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void RasterPos2fv(ref float v) {
            fixed (float* pV = &v) {
                GLNative.glRasterPos2fv(pV);
            }
        }

        /// <summary>
        /// specify the raster position for pixel operations
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The raster position is modified by <see cref="glRasterPos"/>,  <see cref="glBitmap"/> , and  <see cref="glWindowPos"/> .
        /// When the raster position coordinates are invalid,
        /// drawing commands that are based on the raster position are
        /// ignored (that is, they do not result in changes to GL state).
        /// Calling  <see cref="glDrawElements"/>  or  <see cref="glDrawRangeElements"/>  may leave the
        /// current color or index indeterminate.
        /// If <see cref="glRasterPos"/> is executed while the current color or index is indeterminate, the
        /// current raster color or current raster index remains indeterminate.
        /// To set a valid raster position outside the viewport, first set a valid
        /// raster position, then call  <see cref="glBitmap"/>  with NULL as the  bitmap 
        /// parameter.
        /// When the <code>ARB_imaging</code> extension is supported, there are distinct
        /// raster texture coordinates for each texture unit. Each texture unit's
        /// current raster texture coordinates are updated by <see cref="glRasterPos"/>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glRasterPos"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glRasterPos2iv(const GLint * v);</para>
        /// </summary>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array of two,
        /// three,
        /// or four elements,
        /// specifying 
        /// x   ,
        /// y   ,
        /// z   ,
        /// and 
        /// w   
        /// coordinates, respectively.
        /// </para>
        /// </param>
        /// <seealso cref="Bitmap"/>
        /// <seealso cref="CopyPixels"/>
        /// <seealso cref="DrawArrays"/>
        /// <seealso cref="DrawElements"/>
        /// <seealso cref="DrawRangeElements"/>
        /// <seealso cref="DrawPixels"/>
        /// <seealso cref="MultiTexCoord"/>
        /// <seealso cref="TexCoord"/>
        /// <seealso cref="TexGen"/>
        /// <seealso cref="Vertex"/>
        /// <seealso cref="WindowPos"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void RasterPos2iv(ref int v) {
            fixed (int* pV = &v) {
                GLNative.glRasterPos2iv(pV);
            }
        }

        /// <summary>
        /// specify the raster position for pixel operations
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The raster position is modified by <see cref="glRasterPos"/>,  <see cref="glBitmap"/> , and  <see cref="glWindowPos"/> .
        /// When the raster position coordinates are invalid,
        /// drawing commands that are based on the raster position are
        /// ignored (that is, they do not result in changes to GL state).
        /// Calling  <see cref="glDrawElements"/>  or  <see cref="glDrawRangeElements"/>  may leave the
        /// current color or index indeterminate.
        /// If <see cref="glRasterPos"/> is executed while the current color or index is indeterminate, the
        /// current raster color or current raster index remains indeterminate.
        /// To set a valid raster position outside the viewport, first set a valid
        /// raster position, then call  <see cref="glBitmap"/>  with NULL as the  bitmap 
        /// parameter.
        /// When the <code>ARB_imaging</code> extension is supported, there are distinct
        /// raster texture coordinates for each texture unit. Each texture unit's
        /// current raster texture coordinates are updated by <see cref="glRasterPos"/>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glRasterPos"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glRasterPos2sv(const GLshort * v);</para>
        /// </summary>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array of two,
        /// three,
        /// or four elements,
        /// specifying 
        /// x   ,
        /// y   ,
        /// z   ,
        /// and 
        /// w   
        /// coordinates, respectively.
        /// </para>
        /// </param>
        /// <seealso cref="Bitmap"/>
        /// <seealso cref="CopyPixels"/>
        /// <seealso cref="DrawArrays"/>
        /// <seealso cref="DrawElements"/>
        /// <seealso cref="DrawRangeElements"/>
        /// <seealso cref="DrawPixels"/>
        /// <seealso cref="MultiTexCoord"/>
        /// <seealso cref="TexCoord"/>
        /// <seealso cref="TexGen"/>
        /// <seealso cref="Vertex"/>
        /// <seealso cref="WindowPos"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void RasterPos2sv(ref short v) {
            fixed (short* pV = &v) {
                GLNative.glRasterPos2sv(pV);
            }
        }

        /// <summary>
        /// specify the raster position for pixel operations
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The raster position is modified by <see cref="glRasterPos"/>,  <see cref="glBitmap"/> , and  <see cref="glWindowPos"/> .
        /// When the raster position coordinates are invalid,
        /// drawing commands that are based on the raster position are
        /// ignored (that is, they do not result in changes to GL state).
        /// Calling  <see cref="glDrawElements"/>  or  <see cref="glDrawRangeElements"/>  may leave the
        /// current color or index indeterminate.
        /// If <see cref="glRasterPos"/> is executed while the current color or index is indeterminate, the
        /// current raster color or current raster index remains indeterminate.
        /// To set a valid raster position outside the viewport, first set a valid
        /// raster position, then call  <see cref="glBitmap"/>  with NULL as the  bitmap 
        /// parameter.
        /// When the <code>ARB_imaging</code> extension is supported, there are distinct
        /// raster texture coordinates for each texture unit. Each texture unit's
        /// current raster texture coordinates are updated by <see cref="glRasterPos"/>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glRasterPos"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glRasterPos3dv(const GLdouble * v);</para>
        /// </summary>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array of two,
        /// three,
        /// or four elements,
        /// specifying 
        /// x   ,
        /// y   ,
        /// z   ,
        /// and 
        /// w   
        /// coordinates, respectively.
        /// </para>
        /// </param>
        /// <seealso cref="Bitmap"/>
        /// <seealso cref="CopyPixels"/>
        /// <seealso cref="DrawArrays"/>
        /// <seealso cref="DrawElements"/>
        /// <seealso cref="DrawRangeElements"/>
        /// <seealso cref="DrawPixels"/>
        /// <seealso cref="MultiTexCoord"/>
        /// <seealso cref="TexCoord"/>
        /// <seealso cref="TexGen"/>
        /// <seealso cref="Vertex"/>
        /// <seealso cref="WindowPos"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void RasterPos3dv(ref double v) {
            fixed (double* pV = &v) {
                GLNative.glRasterPos3dv(pV);
            }
        }

        /// <summary>
        /// specify the raster position for pixel operations
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The raster position is modified by <see cref="glRasterPos"/>,  <see cref="glBitmap"/> , and  <see cref="glWindowPos"/> .
        /// When the raster position coordinates are invalid,
        /// drawing commands that are based on the raster position are
        /// ignored (that is, they do not result in changes to GL state).
        /// Calling  <see cref="glDrawElements"/>  or  <see cref="glDrawRangeElements"/>  may leave the
        /// current color or index indeterminate.
        /// If <see cref="glRasterPos"/> is executed while the current color or index is indeterminate, the
        /// current raster color or current raster index remains indeterminate.
        /// To set a valid raster position outside the viewport, first set a valid
        /// raster position, then call  <see cref="glBitmap"/>  with NULL as the  bitmap 
        /// parameter.
        /// When the <code>ARB_imaging</code> extension is supported, there are distinct
        /// raster texture coordinates for each texture unit. Each texture unit's
        /// current raster texture coordinates are updated by <see cref="glRasterPos"/>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glRasterPos"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glRasterPos3fv(const GLfloat * v);</para>
        /// </summary>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array of two,
        /// three,
        /// or four elements,
        /// specifying 
        /// x   ,
        /// y   ,
        /// z   ,
        /// and 
        /// w   
        /// coordinates, respectively.
        /// </para>
        /// </param>
        /// <seealso cref="Bitmap"/>
        /// <seealso cref="CopyPixels"/>
        /// <seealso cref="DrawArrays"/>
        /// <seealso cref="DrawElements"/>
        /// <seealso cref="DrawRangeElements"/>
        /// <seealso cref="DrawPixels"/>
        /// <seealso cref="MultiTexCoord"/>
        /// <seealso cref="TexCoord"/>
        /// <seealso cref="TexGen"/>
        /// <seealso cref="Vertex"/>
        /// <seealso cref="WindowPos"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void RasterPos3fv(ref float v) {
            fixed (float* pV = &v) {
                GLNative.glRasterPos3fv(pV);
            }
        }

        /// <summary>
        /// specify the raster position for pixel operations
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The raster position is modified by <see cref="glRasterPos"/>,  <see cref="glBitmap"/> , and  <see cref="glWindowPos"/> .
        /// When the raster position coordinates are invalid,
        /// drawing commands that are based on the raster position are
        /// ignored (that is, they do not result in changes to GL state).
        /// Calling  <see cref="glDrawElements"/>  or  <see cref="glDrawRangeElements"/>  may leave the
        /// current color or index indeterminate.
        /// If <see cref="glRasterPos"/> is executed while the current color or index is indeterminate, the
        /// current raster color or current raster index remains indeterminate.
        /// To set a valid raster position outside the viewport, first set a valid
        /// raster position, then call  <see cref="glBitmap"/>  with NULL as the  bitmap 
        /// parameter.
        /// When the <code>ARB_imaging</code> extension is supported, there are distinct
        /// raster texture coordinates for each texture unit. Each texture unit's
        /// current raster texture coordinates are updated by <see cref="glRasterPos"/>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glRasterPos"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glRasterPos3iv(const GLint * v);</para>
        /// </summary>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array of two,
        /// three,
        /// or four elements,
        /// specifying 
        /// x   ,
        /// y   ,
        /// z   ,
        /// and 
        /// w   
        /// coordinates, respectively.
        /// </para>
        /// </param>
        /// <seealso cref="Bitmap"/>
        /// <seealso cref="CopyPixels"/>
        /// <seealso cref="DrawArrays"/>
        /// <seealso cref="DrawElements"/>
        /// <seealso cref="DrawRangeElements"/>
        /// <seealso cref="DrawPixels"/>
        /// <seealso cref="MultiTexCoord"/>
        /// <seealso cref="TexCoord"/>
        /// <seealso cref="TexGen"/>
        /// <seealso cref="Vertex"/>
        /// <seealso cref="WindowPos"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void RasterPos3iv(ref int v) {
            fixed (int* pV = &v) {
                GLNative.glRasterPos3iv(pV);
            }
        }

        /// <summary>
        /// specify the raster position for pixel operations
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The raster position is modified by <see cref="glRasterPos"/>,  <see cref="glBitmap"/> , and  <see cref="glWindowPos"/> .
        /// When the raster position coordinates are invalid,
        /// drawing commands that are based on the raster position are
        /// ignored (that is, they do not result in changes to GL state).
        /// Calling  <see cref="glDrawElements"/>  or  <see cref="glDrawRangeElements"/>  may leave the
        /// current color or index indeterminate.
        /// If <see cref="glRasterPos"/> is executed while the current color or index is indeterminate, the
        /// current raster color or current raster index remains indeterminate.
        /// To set a valid raster position outside the viewport, first set a valid
        /// raster position, then call  <see cref="glBitmap"/>  with NULL as the  bitmap 
        /// parameter.
        /// When the <code>ARB_imaging</code> extension is supported, there are distinct
        /// raster texture coordinates for each texture unit. Each texture unit's
        /// current raster texture coordinates are updated by <see cref="glRasterPos"/>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glRasterPos"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glRasterPos3sv(const GLshort * v);</para>
        /// </summary>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array of two,
        /// three,
        /// or four elements,
        /// specifying 
        /// x   ,
        /// y   ,
        /// z   ,
        /// and 
        /// w   
        /// coordinates, respectively.
        /// </para>
        /// </param>
        /// <seealso cref="Bitmap"/>
        /// <seealso cref="CopyPixels"/>
        /// <seealso cref="DrawArrays"/>
        /// <seealso cref="DrawElements"/>
        /// <seealso cref="DrawRangeElements"/>
        /// <seealso cref="DrawPixels"/>
        /// <seealso cref="MultiTexCoord"/>
        /// <seealso cref="TexCoord"/>
        /// <seealso cref="TexGen"/>
        /// <seealso cref="Vertex"/>
        /// <seealso cref="WindowPos"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void RasterPos3sv(ref short v) {
            fixed (short* pV = &v) {
                GLNative.glRasterPos3sv(pV);
            }
        }

        /// <summary>
        /// specify the raster position for pixel operations
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The raster position is modified by <see cref="glRasterPos"/>,  <see cref="glBitmap"/> , and  <see cref="glWindowPos"/> .
        /// When the raster position coordinates are invalid,
        /// drawing commands that are based on the raster position are
        /// ignored (that is, they do not result in changes to GL state).
        /// Calling  <see cref="glDrawElements"/>  or  <see cref="glDrawRangeElements"/>  may leave the
        /// current color or index indeterminate.
        /// If <see cref="glRasterPos"/> is executed while the current color or index is indeterminate, the
        /// current raster color or current raster index remains indeterminate.
        /// To set a valid raster position outside the viewport, first set a valid
        /// raster position, then call  <see cref="glBitmap"/>  with NULL as the  bitmap 
        /// parameter.
        /// When the <code>ARB_imaging</code> extension is supported, there are distinct
        /// raster texture coordinates for each texture unit. Each texture unit's
        /// current raster texture coordinates are updated by <see cref="glRasterPos"/>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glRasterPos"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glRasterPos4dv(const GLdouble * v);</para>
        /// </summary>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array of two,
        /// three,
        /// or four elements,
        /// specifying 
        /// x   ,
        /// y   ,
        /// z   ,
        /// and 
        /// w   
        /// coordinates, respectively.
        /// </para>
        /// </param>
        /// <seealso cref="Bitmap"/>
        /// <seealso cref="CopyPixels"/>
        /// <seealso cref="DrawArrays"/>
        /// <seealso cref="DrawElements"/>
        /// <seealso cref="DrawRangeElements"/>
        /// <seealso cref="DrawPixels"/>
        /// <seealso cref="MultiTexCoord"/>
        /// <seealso cref="TexCoord"/>
        /// <seealso cref="TexGen"/>
        /// <seealso cref="Vertex"/>
        /// <seealso cref="WindowPos"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void RasterPos4dv(ref double v) {
            fixed (double* pV = &v) {
                GLNative.glRasterPos4dv(pV);
            }
        }

        /// <summary>
        /// specify the raster position for pixel operations
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The raster position is modified by <see cref="glRasterPos"/>,  <see cref="glBitmap"/> , and  <see cref="glWindowPos"/> .
        /// When the raster position coordinates are invalid,
        /// drawing commands that are based on the raster position are
        /// ignored (that is, they do not result in changes to GL state).
        /// Calling  <see cref="glDrawElements"/>  or  <see cref="glDrawRangeElements"/>  may leave the
        /// current color or index indeterminate.
        /// If <see cref="glRasterPos"/> is executed while the current color or index is indeterminate, the
        /// current raster color or current raster index remains indeterminate.
        /// To set a valid raster position outside the viewport, first set a valid
        /// raster position, then call  <see cref="glBitmap"/>  with NULL as the  bitmap 
        /// parameter.
        /// When the <code>ARB_imaging</code> extension is supported, there are distinct
        /// raster texture coordinates for each texture unit. Each texture unit's
        /// current raster texture coordinates are updated by <see cref="glRasterPos"/>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glRasterPos"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glRasterPos4fv(const GLfloat * v);</para>
        /// </summary>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array of two,
        /// three,
        /// or four elements,
        /// specifying 
        /// x   ,
        /// y   ,
        /// z   ,
        /// and 
        /// w   
        /// coordinates, respectively.
        /// </para>
        /// </param>
        /// <seealso cref="Bitmap"/>
        /// <seealso cref="CopyPixels"/>
        /// <seealso cref="DrawArrays"/>
        /// <seealso cref="DrawElements"/>
        /// <seealso cref="DrawRangeElements"/>
        /// <seealso cref="DrawPixels"/>
        /// <seealso cref="MultiTexCoord"/>
        /// <seealso cref="TexCoord"/>
        /// <seealso cref="TexGen"/>
        /// <seealso cref="Vertex"/>
        /// <seealso cref="WindowPos"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void RasterPos4fv(ref float v) {
            fixed (float* pV = &v) {
                GLNative.glRasterPos4fv(pV);
            }
        }

        /// <summary>
        /// specify the raster position for pixel operations
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The raster position is modified by <see cref="glRasterPos"/>,  <see cref="glBitmap"/> , and  <see cref="glWindowPos"/> .
        /// When the raster position coordinates are invalid,
        /// drawing commands that are based on the raster position are
        /// ignored (that is, they do not result in changes to GL state).
        /// Calling  <see cref="glDrawElements"/>  or  <see cref="glDrawRangeElements"/>  may leave the
        /// current color or index indeterminate.
        /// If <see cref="glRasterPos"/> is executed while the current color or index is indeterminate, the
        /// current raster color or current raster index remains indeterminate.
        /// To set a valid raster position outside the viewport, first set a valid
        /// raster position, then call  <see cref="glBitmap"/>  with NULL as the  bitmap 
        /// parameter.
        /// When the <code>ARB_imaging</code> extension is supported, there are distinct
        /// raster texture coordinates for each texture unit. Each texture unit's
        /// current raster texture coordinates are updated by <see cref="glRasterPos"/>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glRasterPos"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glRasterPos4iv(const GLint * v);</para>
        /// </summary>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array of two,
        /// three,
        /// or four elements,
        /// specifying 
        /// x   ,
        /// y   ,
        /// z   ,
        /// and 
        /// w   
        /// coordinates, respectively.
        /// </para>
        /// </param>
        /// <seealso cref="Bitmap"/>
        /// <seealso cref="CopyPixels"/>
        /// <seealso cref="DrawArrays"/>
        /// <seealso cref="DrawElements"/>
        /// <seealso cref="DrawRangeElements"/>
        /// <seealso cref="DrawPixels"/>
        /// <seealso cref="MultiTexCoord"/>
        /// <seealso cref="TexCoord"/>
        /// <seealso cref="TexGen"/>
        /// <seealso cref="Vertex"/>
        /// <seealso cref="WindowPos"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void RasterPos4iv(ref int v) {
            fixed (int* pV = &v) {
                GLNative.glRasterPos4iv(pV);
            }
        }

        /// <summary>
        /// specify the raster position for pixel operations
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The raster position is modified by <see cref="glRasterPos"/>,  <see cref="glBitmap"/> , and  <see cref="glWindowPos"/> .
        /// When the raster position coordinates are invalid,
        /// drawing commands that are based on the raster position are
        /// ignored (that is, they do not result in changes to GL state).
        /// Calling  <see cref="glDrawElements"/>  or  <see cref="glDrawRangeElements"/>  may leave the
        /// current color or index indeterminate.
        /// If <see cref="glRasterPos"/> is executed while the current color or index is indeterminate, the
        /// current raster color or current raster index remains indeterminate.
        /// To set a valid raster position outside the viewport, first set a valid
        /// raster position, then call  <see cref="glBitmap"/>  with NULL as the  bitmap 
        /// parameter.
        /// When the <code>ARB_imaging</code> extension is supported, there are distinct
        /// raster texture coordinates for each texture unit. Each texture unit's
        /// current raster texture coordinates are updated by <see cref="glRasterPos"/>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glRasterPos"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glRasterPos4sv(const GLshort * v);</para>
        /// </summary>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array of two,
        /// three,
        /// or four elements,
        /// specifying 
        /// x   ,
        /// y   ,
        /// z   ,
        /// and 
        /// w   
        /// coordinates, respectively.
        /// </para>
        /// </param>
        /// <seealso cref="Bitmap"/>
        /// <seealso cref="CopyPixels"/>
        /// <seealso cref="DrawArrays"/>
        /// <seealso cref="DrawElements"/>
        /// <seealso cref="DrawRangeElements"/>
        /// <seealso cref="DrawPixels"/>
        /// <seealso cref="MultiTexCoord"/>
        /// <seealso cref="TexCoord"/>
        /// <seealso cref="TexGen"/>
        /// <seealso cref="Vertex"/>
        /// <seealso cref="WindowPos"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void RasterPos4sv(ref short v) {
            fixed (short* pV = &v) {
                GLNative.glRasterPos4sv(pV);
            }
        }

        /// <summary>
        /// draw a rectangle
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glRect"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glRectdv(const GLdouble * v1, const GLdouble * v2);</para>
        /// </summary>
        /// <param name="v1">
        /// Specifies a pointer to one vertex of a rectangle.
        /// </param>
        /// <param name="v2">
        /// Specifies a pointer to the opposite vertex of the rectangle.
        /// </param>
        /// <seealso cref="Begin"/>
        /// <seealso cref="Vertex"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void Rectdv(ref double v1, ref double v2) {
            fixed (double* pV1 = &v1)
            fixed (double* pV2 = &v2) {
                GLNative.glRectdv(pV1, pV2);
            }
        }

        /// <summary>
        /// draw a rectangle
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glRect"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glRectfv(const GLfloat * v1, const GLfloat * v2);</para>
        /// </summary>
        /// <param name="v1">
        /// Specifies a pointer to one vertex of a rectangle.
        /// </param>
        /// <param name="v2">
        /// Specifies a pointer to the opposite vertex of the rectangle.
        /// </param>
        /// <seealso cref="Begin"/>
        /// <seealso cref="Vertex"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void Rectfv(ref float v1, ref float v2) {
            fixed (float* pV1 = &v1)
            fixed (float* pV2 = &v2) {
                GLNative.glRectfv(pV1, pV2);
            }
        }

        /// <summary>
        /// draw a rectangle
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glRect"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glRectiv(const GLint * v1, const GLint * v2);</para>
        /// </summary>
        /// <param name="v1">
        /// Specifies a pointer to one vertex of a rectangle.
        /// </param>
        /// <param name="v2">
        /// Specifies a pointer to the opposite vertex of the rectangle.
        /// </param>
        /// <seealso cref="Begin"/>
        /// <seealso cref="Vertex"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void Rectiv(ref int v1, ref int v2) {
            fixed (int* pV1 = &v1)
            fixed (int* pV2 = &v2) {
                GLNative.glRectiv(pV1, pV2);
            }
        }

        /// <summary>
        /// draw a rectangle
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glRect"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glRectsv(const GLshort * v1, const GLshort * v2);</para>
        /// </summary>
        /// <param name="v1">
        /// Specifies a pointer to one vertex of a rectangle.
        /// </param>
        /// <param name="v2">
        /// Specifies a pointer to the opposite vertex of the rectangle.
        /// </param>
        /// <seealso cref="Begin"/>
        /// <seealso cref="Vertex"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void Rectsv(ref short v1, ref short v2) {
            fixed (short* pV1 = &v1)
            fixed (short* pV2 = &v2) {
                GLNative.glRectsv(pV1, pV2);
            }
        }

        /// <summary>
        /// set the current texture coordinates
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The current texture coordinates can be updated at any time.
        /// In particular,
        /// <see cref="glTexCoord"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// When the <code>ARB_imaging</code> extension is supported, <see cref="glTexCoord"/> always
        /// updates texture unit <code>GL_TEXTURE0</code>.
        /// </para>
        /// Original: <para>void glTexCoord1dv(const GLdouble * v);</para>
        /// </summary>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array of one, two, three, or four elements,
        /// which in turn specify the
        /// s ,
        /// t ,
        /// r , and
        /// q  texture coordinates.
        /// </para>
        /// </param>
        /// <seealso cref="MultiTexCoord"/>
        /// <seealso cref="TexCoordPointer"/>
        /// <seealso cref="Vertex"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void TexCoord1dv(ref double v) {
            fixed (double* pV = &v) {
                GLNative.glTexCoord1dv(pV);
            }
        }

        /// <summary>
        /// set the current texture coordinates
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The current texture coordinates can be updated at any time.
        /// In particular,
        /// <see cref="glTexCoord"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// When the <code>ARB_imaging</code> extension is supported, <see cref="glTexCoord"/> always
        /// updates texture unit <code>GL_TEXTURE0</code>.
        /// </para>
        /// Original: <para>void glTexCoord1fv(const GLfloat * v);</para>
        /// </summary>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array of one, two, three, or four elements,
        /// which in turn specify the
        /// s ,
        /// t ,
        /// r , and
        /// q  texture coordinates.
        /// </para>
        /// </param>
        /// <seealso cref="MultiTexCoord"/>
        /// <seealso cref="TexCoordPointer"/>
        /// <seealso cref="Vertex"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void TexCoord1fv(ref float v) {
            fixed (float* pV = &v) {
                GLNative.glTexCoord1fv(pV);
            }
        }

        /// <summary>
        /// set the current texture coordinates
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The current texture coordinates can be updated at any time.
        /// In particular,
        /// <see cref="glTexCoord"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// When the <code>ARB_imaging</code> extension is supported, <see cref="glTexCoord"/> always
        /// updates texture unit <code>GL_TEXTURE0</code>.
        /// </para>
        /// Original: <para>void glTexCoord1iv(const GLint * v);</para>
        /// </summary>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array of one, two, three, or four elements,
        /// which in turn specify the
        /// s ,
        /// t ,
        /// r , and
        /// q  texture coordinates.
        /// </para>
        /// </param>
        /// <seealso cref="MultiTexCoord"/>
        /// <seealso cref="TexCoordPointer"/>
        /// <seealso cref="Vertex"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void TexCoord1iv(ref int v) {
            fixed (int* pV = &v) {
                GLNative.glTexCoord1iv(pV);
            }
        }

        /// <summary>
        /// set the current texture coordinates
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The current texture coordinates can be updated at any time.
        /// In particular,
        /// <see cref="glTexCoord"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// When the <code>ARB_imaging</code> extension is supported, <see cref="glTexCoord"/> always
        /// updates texture unit <code>GL_TEXTURE0</code>.
        /// </para>
        /// Original: <para>void glTexCoord1sv(const GLshort * v);</para>
        /// </summary>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array of one, two, three, or four elements,
        /// which in turn specify the
        /// s ,
        /// t ,
        /// r , and
        /// q  texture coordinates.
        /// </para>
        /// </param>
        /// <seealso cref="MultiTexCoord"/>
        /// <seealso cref="TexCoordPointer"/>
        /// <seealso cref="Vertex"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void TexCoord1sv(ref short v) {
            fixed (short* pV = &v) {
                GLNative.glTexCoord1sv(pV);
            }
        }

        /// <summary>
        /// set the current texture coordinates
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The current texture coordinates can be updated at any time.
        /// In particular,
        /// <see cref="glTexCoord"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// When the <code>ARB_imaging</code> extension is supported, <see cref="glTexCoord"/> always
        /// updates texture unit <code>GL_TEXTURE0</code>.
        /// </para>
        /// Original: <para>void glTexCoord2dv(const GLdouble * v);</para>
        /// </summary>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array of one, two, three, or four elements,
        /// which in turn specify the
        /// s ,
        /// t ,
        /// r , and
        /// q  texture coordinates.
        /// </para>
        /// </param>
        /// <seealso cref="MultiTexCoord"/>
        /// <seealso cref="TexCoordPointer"/>
        /// <seealso cref="Vertex"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void TexCoord2dv(ref double v) {
            fixed (double* pV = &v) {
                GLNative.glTexCoord2dv(pV);
            }
        }

        /// <summary>
        /// set the current texture coordinates
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The current texture coordinates can be updated at any time.
        /// In particular,
        /// <see cref="glTexCoord"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// When the <code>ARB_imaging</code> extension is supported, <see cref="glTexCoord"/> always
        /// updates texture unit <code>GL_TEXTURE0</code>.
        /// </para>
        /// Original: <para>void glTexCoord2fv(const GLfloat * v);</para>
        /// </summary>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array of one, two, three, or four elements,
        /// which in turn specify the
        /// s ,
        /// t ,
        /// r , and
        /// q  texture coordinates.
        /// </para>
        /// </param>
        /// <seealso cref="MultiTexCoord"/>
        /// <seealso cref="TexCoordPointer"/>
        /// <seealso cref="Vertex"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void TexCoord2fv(ref float v) {
            fixed (float* pV = &v) {
                GLNative.glTexCoord2fv(pV);
            }
        }

        /// <summary>
        /// set the current texture coordinates
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The current texture coordinates can be updated at any time.
        /// In particular,
        /// <see cref="glTexCoord"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// When the <code>ARB_imaging</code> extension is supported, <see cref="glTexCoord"/> always
        /// updates texture unit <code>GL_TEXTURE0</code>.
        /// </para>
        /// Original: <para>void glTexCoord2iv(const GLint * v);</para>
        /// </summary>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array of one, two, three, or four elements,
        /// which in turn specify the
        /// s ,
        /// t ,
        /// r , and
        /// q  texture coordinates.
        /// </para>
        /// </param>
        /// <seealso cref="MultiTexCoord"/>
        /// <seealso cref="TexCoordPointer"/>
        /// <seealso cref="Vertex"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void TexCoord2iv(ref int v) {
            fixed (int* pV = &v) {
                GLNative.glTexCoord2iv(pV);
            }
        }

        /// <summary>
        /// set the current texture coordinates
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The current texture coordinates can be updated at any time.
        /// In particular,
        /// <see cref="glTexCoord"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// When the <code>ARB_imaging</code> extension is supported, <see cref="glTexCoord"/> always
        /// updates texture unit <code>GL_TEXTURE0</code>.
        /// </para>
        /// Original: <para>void glTexCoord2sv(const GLshort * v);</para>
        /// </summary>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array of one, two, three, or four elements,
        /// which in turn specify the
        /// s ,
        /// t ,
        /// r , and
        /// q  texture coordinates.
        /// </para>
        /// </param>
        /// <seealso cref="MultiTexCoord"/>
        /// <seealso cref="TexCoordPointer"/>
        /// <seealso cref="Vertex"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void TexCoord2sv(ref short v) {
            fixed (short* pV = &v) {
                GLNative.glTexCoord2sv(pV);
            }
        }

        /// <summary>
        /// set the current texture coordinates
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The current texture coordinates can be updated at any time.
        /// In particular,
        /// <see cref="glTexCoord"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// When the <code>ARB_imaging</code> extension is supported, <see cref="glTexCoord"/> always
        /// updates texture unit <code>GL_TEXTURE0</code>.
        /// </para>
        /// Original: <para>void glTexCoord3dv(const GLdouble * v);</para>
        /// </summary>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array of one, two, three, or four elements,
        /// which in turn specify the
        /// s ,
        /// t ,
        /// r , and
        /// q  texture coordinates.
        /// </para>
        /// </param>
        /// <seealso cref="MultiTexCoord"/>
        /// <seealso cref="TexCoordPointer"/>
        /// <seealso cref="Vertex"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void TexCoord3dv(ref double v) {
            fixed (double* pV = &v) {
                GLNative.glTexCoord3dv(pV);
            }
        }

        /// <summary>
        /// set the current texture coordinates
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The current texture coordinates can be updated at any time.
        /// In particular,
        /// <see cref="glTexCoord"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// When the <code>ARB_imaging</code> extension is supported, <see cref="glTexCoord"/> always
        /// updates texture unit <code>GL_TEXTURE0</code>.
        /// </para>
        /// Original: <para>void glTexCoord3fv(const GLfloat * v);</para>
        /// </summary>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array of one, two, three, or four elements,
        /// which in turn specify the
        /// s ,
        /// t ,
        /// r , and
        /// q  texture coordinates.
        /// </para>
        /// </param>
        /// <seealso cref="MultiTexCoord"/>
        /// <seealso cref="TexCoordPointer"/>
        /// <seealso cref="Vertex"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void TexCoord3fv(ref float v) {
            fixed (float* pV = &v) {
                GLNative.glTexCoord3fv(pV);
            }
        }

        /// <summary>
        /// set the current texture coordinates
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The current texture coordinates can be updated at any time.
        /// In particular,
        /// <see cref="glTexCoord"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// When the <code>ARB_imaging</code> extension is supported, <see cref="glTexCoord"/> always
        /// updates texture unit <code>GL_TEXTURE0</code>.
        /// </para>
        /// Original: <para>void glTexCoord3iv(const GLint * v);</para>
        /// </summary>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array of one, two, three, or four elements,
        /// which in turn specify the
        /// s ,
        /// t ,
        /// r , and
        /// q  texture coordinates.
        /// </para>
        /// </param>
        /// <seealso cref="MultiTexCoord"/>
        /// <seealso cref="TexCoordPointer"/>
        /// <seealso cref="Vertex"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void TexCoord3iv(ref int v) {
            fixed (int* pV = &v) {
                GLNative.glTexCoord3iv(pV);
            }
        }

        /// <summary>
        /// set the current texture coordinates
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The current texture coordinates can be updated at any time.
        /// In particular,
        /// <see cref="glTexCoord"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// When the <code>ARB_imaging</code> extension is supported, <see cref="glTexCoord"/> always
        /// updates texture unit <code>GL_TEXTURE0</code>.
        /// </para>
        /// Original: <para>void glTexCoord3sv(const GLshort * v);</para>
        /// </summary>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array of one, two, three, or four elements,
        /// which in turn specify the
        /// s ,
        /// t ,
        /// r , and
        /// q  texture coordinates.
        /// </para>
        /// </param>
        /// <seealso cref="MultiTexCoord"/>
        /// <seealso cref="TexCoordPointer"/>
        /// <seealso cref="Vertex"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void TexCoord3sv(ref short v) {
            fixed (short* pV = &v) {
                GLNative.glTexCoord3sv(pV);
            }
        }

        /// <summary>
        /// set the current texture coordinates
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The current texture coordinates can be updated at any time.
        /// In particular,
        /// <see cref="glTexCoord"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// When the <code>ARB_imaging</code> extension is supported, <see cref="glTexCoord"/> always
        /// updates texture unit <code>GL_TEXTURE0</code>.
        /// </para>
        /// Original: <para>void glTexCoord4dv(const GLdouble * v);</para>
        /// </summary>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array of one, two, three, or four elements,
        /// which in turn specify the
        /// s ,
        /// t ,
        /// r , and
        /// q  texture coordinates.
        /// </para>
        /// </param>
        /// <seealso cref="MultiTexCoord"/>
        /// <seealso cref="TexCoordPointer"/>
        /// <seealso cref="Vertex"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void TexCoord4dv(ref double v) {
            fixed (double* pV = &v) {
                GLNative.glTexCoord4dv(pV);
            }
        }

        /// <summary>
        /// set the current texture coordinates
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The current texture coordinates can be updated at any time.
        /// In particular,
        /// <see cref="glTexCoord"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// When the <code>ARB_imaging</code> extension is supported, <see cref="glTexCoord"/> always
        /// updates texture unit <code>GL_TEXTURE0</code>.
        /// </para>
        /// Original: <para>void glTexCoord4fv(const GLfloat * v);</para>
        /// </summary>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array of one, two, three, or four elements,
        /// which in turn specify the
        /// s ,
        /// t ,
        /// r , and
        /// q  texture coordinates.
        /// </para>
        /// </param>
        /// <seealso cref="MultiTexCoord"/>
        /// <seealso cref="TexCoordPointer"/>
        /// <seealso cref="Vertex"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void TexCoord4fv(ref float v) {
            fixed (float* pV = &v) {
                GLNative.glTexCoord4fv(pV);
            }
        }

        /// <summary>
        /// set the current texture coordinates
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The current texture coordinates can be updated at any time.
        /// In particular,
        /// <see cref="glTexCoord"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// When the <code>ARB_imaging</code> extension is supported, <see cref="glTexCoord"/> always
        /// updates texture unit <code>GL_TEXTURE0</code>.
        /// </para>
        /// Original: <para>void glTexCoord4iv(const GLint * v);</para>
        /// </summary>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array of one, two, three, or four elements,
        /// which in turn specify the
        /// s ,
        /// t ,
        /// r , and
        /// q  texture coordinates.
        /// </para>
        /// </param>
        /// <seealso cref="MultiTexCoord"/>
        /// <seealso cref="TexCoordPointer"/>
        /// <seealso cref="Vertex"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void TexCoord4iv(ref int v) {
            fixed (int* pV = &v) {
                GLNative.glTexCoord4iv(pV);
            }
        }

        /// <summary>
        /// set the current texture coordinates
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The current texture coordinates can be updated at any time.
        /// In particular,
        /// <see cref="glTexCoord"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// When the <code>ARB_imaging</code> extension is supported, <see cref="glTexCoord"/> always
        /// updates texture unit <code>GL_TEXTURE0</code>.
        /// </para>
        /// Original: <para>void glTexCoord4sv(const GLshort * v);</para>
        /// </summary>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array of one, two, three, or four elements,
        /// which in turn specify the
        /// s ,
        /// t ,
        /// r , and
        /// q  texture coordinates.
        /// </para>
        /// </param>
        /// <seealso cref="MultiTexCoord"/>
        /// <seealso cref="TexCoordPointer"/>
        /// <seealso cref="Vertex"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void TexCoord4sv(ref short v) {
            fixed (short* pV = &v) {
                GLNative.glTexCoord4sv(pV);
            }
        }

        /// <summary>
        /// specify a vertex
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// Invoking <see cref="glVertex"/> outside of a  <see cref="glBegin"/> / <see cref="glEnd"/>  pair
        /// results in undefined behavior.
        /// </para>
        /// Original: <para>void glVertex2dv(const GLdouble * v);</para>
        /// </summary>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array of two, three, or four elements.
        /// The elements of a two-element array are 
        /// x   
        /// and 
        /// y   ;
        /// of a three-element array, 
        /// x   ,
        /// y   ,
        /// and 
        /// z   ;
        /// and of a four-element array, 
        /// x   ,
        /// y   ,
        /// z   ,
        /// and 
        /// w   .
        /// </para>
        /// </param>
        /// <seealso cref="Begin"/>
        /// <seealso cref="CallList"/>
        /// <seealso cref="Color"/>
        /// <seealso cref="EdgeFlag"/>
        /// <seealso cref="EvalCoord"/>
        /// <seealso cref="FogCoord"/>
        /// <seealso cref="Index"/>
        /// <seealso cref="Material"/>
        /// <seealso cref="MultiTexCoord"/>
        /// <seealso cref="Normal"/>
        /// <seealso cref="Rect"/>
        /// <seealso cref="TexCoord"/>
        /// <seealso cref="VertexPointer"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void Vertex2dv(ref double v) {
            fixed (double* pV = &v) {
                GLNative.glVertex2dv(pV);
            }
        }

        /// <summary>
        /// specify a vertex
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// Invoking <see cref="glVertex"/> outside of a  <see cref="glBegin"/> / <see cref="glEnd"/>  pair
        /// results in undefined behavior.
        /// </para>
        /// Original: <para>void glVertex2fv(const GLfloat * v);</para>
        /// </summary>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array of two, three, or four elements.
        /// The elements of a two-element array are 
        /// x   
        /// and 
        /// y   ;
        /// of a three-element array, 
        /// x   ,
        /// y   ,
        /// and 
        /// z   ;
        /// and of a four-element array, 
        /// x   ,
        /// y   ,
        /// z   ,
        /// and 
        /// w   .
        /// </para>
        /// </param>
        /// <seealso cref="Begin"/>
        /// <seealso cref="CallList"/>
        /// <seealso cref="Color"/>
        /// <seealso cref="EdgeFlag"/>
        /// <seealso cref="EvalCoord"/>
        /// <seealso cref="FogCoord"/>
        /// <seealso cref="Index"/>
        /// <seealso cref="Material"/>
        /// <seealso cref="MultiTexCoord"/>
        /// <seealso cref="Normal"/>
        /// <seealso cref="Rect"/>
        /// <seealso cref="TexCoord"/>
        /// <seealso cref="VertexPointer"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void Vertex2fv(ref float v) {
            fixed (float* pV = &v) {
                GLNative.glVertex2fv(pV);
            }
        }

        /// <summary>
        /// specify a vertex
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// Invoking <see cref="glVertex"/> outside of a  <see cref="glBegin"/> / <see cref="glEnd"/>  pair
        /// results in undefined behavior.
        /// </para>
        /// Original: <para>void glVertex2iv(const GLint * v);</para>
        /// </summary>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array of two, three, or four elements.
        /// The elements of a two-element array are 
        /// x   
        /// and 
        /// y   ;
        /// of a three-element array, 
        /// x   ,
        /// y   ,
        /// and 
        /// z   ;
        /// and of a four-element array, 
        /// x   ,
        /// y   ,
        /// z   ,
        /// and 
        /// w   .
        /// </para>
        /// </param>
        /// <seealso cref="Begin"/>
        /// <seealso cref="CallList"/>
        /// <seealso cref="Color"/>
        /// <seealso cref="EdgeFlag"/>
        /// <seealso cref="EvalCoord"/>
        /// <seealso cref="FogCoord"/>
        /// <seealso cref="Index"/>
        /// <seealso cref="Material"/>
        /// <seealso cref="MultiTexCoord"/>
        /// <seealso cref="Normal"/>
        /// <seealso cref="Rect"/>
        /// <seealso cref="TexCoord"/>
        /// <seealso cref="VertexPointer"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void Vertex2iv(ref int v) {
            fixed (int* pV = &v) {
                GLNative.glVertex2iv(pV);
            }
        }

        /// <summary>
        /// specify a vertex
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// Invoking <see cref="glVertex"/> outside of a  <see cref="glBegin"/> / <see cref="glEnd"/>  pair
        /// results in undefined behavior.
        /// </para>
        /// Original: <para>void glVertex2sv(const GLshort * v);</para>
        /// </summary>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array of two, three, or four elements.
        /// The elements of a two-element array are 
        /// x   
        /// and 
        /// y   ;
        /// of a three-element array, 
        /// x   ,
        /// y   ,
        /// and 
        /// z   ;
        /// and of a four-element array, 
        /// x   ,
        /// y   ,
        /// z   ,
        /// and 
        /// w   .
        /// </para>
        /// </param>
        /// <seealso cref="Begin"/>
        /// <seealso cref="CallList"/>
        /// <seealso cref="Color"/>
        /// <seealso cref="EdgeFlag"/>
        /// <seealso cref="EvalCoord"/>
        /// <seealso cref="FogCoord"/>
        /// <seealso cref="Index"/>
        /// <seealso cref="Material"/>
        /// <seealso cref="MultiTexCoord"/>
        /// <seealso cref="Normal"/>
        /// <seealso cref="Rect"/>
        /// <seealso cref="TexCoord"/>
        /// <seealso cref="VertexPointer"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void Vertex2sv(ref short v) {
            fixed (short* pV = &v) {
                GLNative.glVertex2sv(pV);
            }
        }

        /// <summary>
        /// specify a vertex
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// Invoking <see cref="glVertex"/> outside of a  <see cref="glBegin"/> / <see cref="glEnd"/>  pair
        /// results in undefined behavior.
        /// </para>
        /// Original: <para>void glVertex3dv(const GLdouble * v);</para>
        /// </summary>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array of two, three, or four elements.
        /// The elements of a two-element array are 
        /// x   
        /// and 
        /// y   ;
        /// of a three-element array, 
        /// x   ,
        /// y   ,
        /// and 
        /// z   ;
        /// and of a four-element array, 
        /// x   ,
        /// y   ,
        /// z   ,
        /// and 
        /// w   .
        /// </para>
        /// </param>
        /// <seealso cref="Begin"/>
        /// <seealso cref="CallList"/>
        /// <seealso cref="Color"/>
        /// <seealso cref="EdgeFlag"/>
        /// <seealso cref="EvalCoord"/>
        /// <seealso cref="FogCoord"/>
        /// <seealso cref="Index"/>
        /// <seealso cref="Material"/>
        /// <seealso cref="MultiTexCoord"/>
        /// <seealso cref="Normal"/>
        /// <seealso cref="Rect"/>
        /// <seealso cref="TexCoord"/>
        /// <seealso cref="VertexPointer"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void Vertex3dv(ref double v) {
            fixed (double* pV = &v) {
                GLNative.glVertex3dv(pV);
            }
        }

        /// <summary>
        /// specify a vertex
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// Invoking <see cref="glVertex"/> outside of a  <see cref="glBegin"/> / <see cref="glEnd"/>  pair
        /// results in undefined behavior.
        /// </para>
        /// Original: <para>void glVertex3fv(const GLfloat * v);</para>
        /// </summary>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array of two, three, or four elements.
        /// The elements of a two-element array are 
        /// x   
        /// and 
        /// y   ;
        /// of a three-element array, 
        /// x   ,
        /// y   ,
        /// and 
        /// z   ;
        /// and of a four-element array, 
        /// x   ,
        /// y   ,
        /// z   ,
        /// and 
        /// w   .
        /// </para>
        /// </param>
        /// <seealso cref="Begin"/>
        /// <seealso cref="CallList"/>
        /// <seealso cref="Color"/>
        /// <seealso cref="EdgeFlag"/>
        /// <seealso cref="EvalCoord"/>
        /// <seealso cref="FogCoord"/>
        /// <seealso cref="Index"/>
        /// <seealso cref="Material"/>
        /// <seealso cref="MultiTexCoord"/>
        /// <seealso cref="Normal"/>
        /// <seealso cref="Rect"/>
        /// <seealso cref="TexCoord"/>
        /// <seealso cref="VertexPointer"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void Vertex3fv(ref float v) {
            fixed (float* pV = &v) {
                GLNative.glVertex3fv(pV);
            }
        }

        /// <summary>
        /// specify a vertex
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// Invoking <see cref="glVertex"/> outside of a  <see cref="glBegin"/> / <see cref="glEnd"/>  pair
        /// results in undefined behavior.
        /// </para>
        /// Original: <para>void glVertex3iv(const GLint * v);</para>
        /// </summary>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array of two, three, or four elements.
        /// The elements of a two-element array are 
        /// x   
        /// and 
        /// y   ;
        /// of a three-element array, 
        /// x   ,
        /// y   ,
        /// and 
        /// z   ;
        /// and of a four-element array, 
        /// x   ,
        /// y   ,
        /// z   ,
        /// and 
        /// w   .
        /// </para>
        /// </param>
        /// <seealso cref="Begin"/>
        /// <seealso cref="CallList"/>
        /// <seealso cref="Color"/>
        /// <seealso cref="EdgeFlag"/>
        /// <seealso cref="EvalCoord"/>
        /// <seealso cref="FogCoord"/>
        /// <seealso cref="Index"/>
        /// <seealso cref="Material"/>
        /// <seealso cref="MultiTexCoord"/>
        /// <seealso cref="Normal"/>
        /// <seealso cref="Rect"/>
        /// <seealso cref="TexCoord"/>
        /// <seealso cref="VertexPointer"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void Vertex3iv(ref int v) {
            fixed (int* pV = &v) {
                GLNative.glVertex3iv(pV);
            }
        }

        /// <summary>
        /// specify a vertex
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// Invoking <see cref="glVertex"/> outside of a  <see cref="glBegin"/> / <see cref="glEnd"/>  pair
        /// results in undefined behavior.
        /// </para>
        /// Original: <para>void glVertex3sv(const GLshort * v);</para>
        /// </summary>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array of two, three, or four elements.
        /// The elements of a two-element array are 
        /// x   
        /// and 
        /// y   ;
        /// of a three-element array, 
        /// x   ,
        /// y   ,
        /// and 
        /// z   ;
        /// and of a four-element array, 
        /// x   ,
        /// y   ,
        /// z   ,
        /// and 
        /// w   .
        /// </para>
        /// </param>
        /// <seealso cref="Begin"/>
        /// <seealso cref="CallList"/>
        /// <seealso cref="Color"/>
        /// <seealso cref="EdgeFlag"/>
        /// <seealso cref="EvalCoord"/>
        /// <seealso cref="FogCoord"/>
        /// <seealso cref="Index"/>
        /// <seealso cref="Material"/>
        /// <seealso cref="MultiTexCoord"/>
        /// <seealso cref="Normal"/>
        /// <seealso cref="Rect"/>
        /// <seealso cref="TexCoord"/>
        /// <seealso cref="VertexPointer"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void Vertex3sv(ref short v) {
            fixed (short* pV = &v) {
                GLNative.glVertex3sv(pV);
            }
        }

        /// <summary>
        /// specify a vertex
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// Invoking <see cref="glVertex"/> outside of a  <see cref="glBegin"/> / <see cref="glEnd"/>  pair
        /// results in undefined behavior.
        /// </para>
        /// Original: <para>void glVertex4dv(const GLdouble * v);</para>
        /// </summary>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array of two, three, or four elements.
        /// The elements of a two-element array are 
        /// x   
        /// and 
        /// y   ;
        /// of a three-element array, 
        /// x   ,
        /// y   ,
        /// and 
        /// z   ;
        /// and of a four-element array, 
        /// x   ,
        /// y   ,
        /// z   ,
        /// and 
        /// w   .
        /// </para>
        /// </param>
        /// <seealso cref="Begin"/>
        /// <seealso cref="CallList"/>
        /// <seealso cref="Color"/>
        /// <seealso cref="EdgeFlag"/>
        /// <seealso cref="EvalCoord"/>
        /// <seealso cref="FogCoord"/>
        /// <seealso cref="Index"/>
        /// <seealso cref="Material"/>
        /// <seealso cref="MultiTexCoord"/>
        /// <seealso cref="Normal"/>
        /// <seealso cref="Rect"/>
        /// <seealso cref="TexCoord"/>
        /// <seealso cref="VertexPointer"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void Vertex4dv(ref double v) {
            fixed (double* pV = &v) {
                GLNative.glVertex4dv(pV);
            }
        }

        /// <summary>
        /// specify a vertex
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// Invoking <see cref="glVertex"/> outside of a  <see cref="glBegin"/> / <see cref="glEnd"/>  pair
        /// results in undefined behavior.
        /// </para>
        /// Original: <para>void glVertex4fv(const GLfloat * v);</para>
        /// </summary>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array of two, three, or four elements.
        /// The elements of a two-element array are 
        /// x   
        /// and 
        /// y   ;
        /// of a three-element array, 
        /// x   ,
        /// y   ,
        /// and 
        /// z   ;
        /// and of a four-element array, 
        /// x   ,
        /// y   ,
        /// z   ,
        /// and 
        /// w   .
        /// </para>
        /// </param>
        /// <seealso cref="Begin"/>
        /// <seealso cref="CallList"/>
        /// <seealso cref="Color"/>
        /// <seealso cref="EdgeFlag"/>
        /// <seealso cref="EvalCoord"/>
        /// <seealso cref="FogCoord"/>
        /// <seealso cref="Index"/>
        /// <seealso cref="Material"/>
        /// <seealso cref="MultiTexCoord"/>
        /// <seealso cref="Normal"/>
        /// <seealso cref="Rect"/>
        /// <seealso cref="TexCoord"/>
        /// <seealso cref="VertexPointer"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void Vertex4fv(ref float v) {
            fixed (float* pV = &v) {
                GLNative.glVertex4fv(pV);
            }
        }

        /// <summary>
        /// specify a vertex
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// Invoking <see cref="glVertex"/> outside of a  <see cref="glBegin"/> / <see cref="glEnd"/>  pair
        /// results in undefined behavior.
        /// </para>
        /// Original: <para>void glVertex4iv(const GLint * v);</para>
        /// </summary>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array of two, three, or four elements.
        /// The elements of a two-element array are 
        /// x   
        /// and 
        /// y   ;
        /// of a three-element array, 
        /// x   ,
        /// y   ,
        /// and 
        /// z   ;
        /// and of a four-element array, 
        /// x   ,
        /// y   ,
        /// z   ,
        /// and 
        /// w   .
        /// </para>
        /// </param>
        /// <seealso cref="Begin"/>
        /// <seealso cref="CallList"/>
        /// <seealso cref="Color"/>
        /// <seealso cref="EdgeFlag"/>
        /// <seealso cref="EvalCoord"/>
        /// <seealso cref="FogCoord"/>
        /// <seealso cref="Index"/>
        /// <seealso cref="Material"/>
        /// <seealso cref="MultiTexCoord"/>
        /// <seealso cref="Normal"/>
        /// <seealso cref="Rect"/>
        /// <seealso cref="TexCoord"/>
        /// <seealso cref="VertexPointer"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void Vertex4iv(ref int v) {
            fixed (int* pV = &v) {
                GLNative.glVertex4iv(pV);
            }
        }

        /// <summary>
        /// specify a vertex
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// Invoking <see cref="glVertex"/> outside of a  <see cref="glBegin"/> / <see cref="glEnd"/>  pair
        /// results in undefined behavior.
        /// </para>
        /// Original: <para>void glVertex4sv(const GLshort * v);</para>
        /// </summary>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array of two, three, or four elements.
        /// The elements of a two-element array are 
        /// x   
        /// and 
        /// y   ;
        /// of a three-element array, 
        /// x   ,
        /// y   ,
        /// and 
        /// z   ;
        /// and of a four-element array, 
        /// x   ,
        /// y   ,
        /// z   ,
        /// and 
        /// w   .
        /// </para>
        /// </param>
        /// <seealso cref="Begin"/>
        /// <seealso cref="CallList"/>
        /// <seealso cref="Color"/>
        /// <seealso cref="EdgeFlag"/>
        /// <seealso cref="EvalCoord"/>
        /// <seealso cref="FogCoord"/>
        /// <seealso cref="Index"/>
        /// <seealso cref="Material"/>
        /// <seealso cref="MultiTexCoord"/>
        /// <seealso cref="Normal"/>
        /// <seealso cref="Rect"/>
        /// <seealso cref="TexCoord"/>
        /// <seealso cref="VertexPointer"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void Vertex4sv(ref short v) {
            fixed (short* pV = &v) {
                GLNative.glVertex4sv(pV);
            }
        }

        /// <summary>
        /// specify a plane against which all geometry is clipped
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// It is always the case that <code>GL_CLIP_PLANE</code>
        /// i   
        /// = <code>GL_CLIP_PLANE0</code> + 
        /// i   .
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="plane"/> is not an accepted value.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glClipPlane"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glClipPlane(GLenum plane, const GLdouble * equation);</para>
        /// </summary>
        /// <param name="plane">
        /// <para>
        /// Specifies which clipping plane is being positioned.
        /// Symbolic names of the form <code>GL_CLIP_PLANE</code> i ,
        /// where  i  is an integer between 0 and <code>GL_MAX_CLIP_PLANES</code>
        /// -1 
        /// ,
        /// are accepted.
        /// </para>
        /// </param>
        /// <param name="equation">
        /// <para>
        /// Specifies the address of an array of four double-precision floating-point values.
        /// These values are interpreted as a plane equation.
        /// </para>
        /// </param>
        /// <seealso cref="Enable"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void ClipPlane(uint plane, ref double equation) {
            fixed (double* pEquation = &equation) {
                GLNative.glClipPlane(plane, pEquation);
            }
        }

        /// <summary>
        /// specify fog parameters
        /// <para>Require:</para> <para>GL_VERSION_1_0, GL_VERSION_ES_CM_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <code>GL_FOG_COORD_SRC</code> is available only if the GL version is 1.4 or
        /// greater.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="pname"/> is not an accepted value,
        /// or if <paramref name="pname"/> is <code>GL_FOG_MODE</code> and <paramref name="ps"/> is not an accepted value.
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="pname"/> is <code>GL_FOG_DENSITY</code>
        /// and <paramref name="ps"/> is negative.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glFog"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glFogfv(GLenum pname, const GLfloat * params);</para>
        /// </summary>
        /// <param name="pname">
        /// <para>
        /// Specifies a fog parameter.
        /// <code>GL_FOG_MODE</code>,
        /// <code>GL_FOG_DENSITY</code>,
        /// <code>GL_FOG_START</code>,
        /// <code>GL_FOG_END</code>,
        /// <code>GL_FOG_INDEX</code>,
        /// <code>GL_FOG_COLOR</code>, and
        /// <code>GL_FOG_COORD_SRC</code>
        /// are accepted.
        /// </para>
        /// </param>
        /// <param name="ps">
        /// <para>
        /// Specifies the value or values to be assigned to <paramref name="pname"/>.
        /// <code>GL_FOG_COLOR</code> requires an array of four values.
        /// All other parameters accept an array containing only a single value.
        /// </para>
        /// </param>
        /// <seealso cref="Enable"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void Fogfv(uint pname, ref float ps) {
            fixed (float* pPs = &ps) {
                GLNative.glFogfv(pname, pPs);
            }
        }

        /// <summary>
        /// specify fog parameters
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <code>GL_FOG_COORD_SRC</code> is available only if the GL version is 1.4 or
        /// greater.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="pname"/> is not an accepted value,
        /// or if <paramref name="pname"/> is <code>GL_FOG_MODE</code> and <paramref name="ps"/> is not an accepted value.
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="pname"/> is <code>GL_FOG_DENSITY</code>
        /// and <paramref name="ps"/> is negative.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glFog"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glFogiv(GLenum pname, const GLint * params);</para>
        /// </summary>
        /// <param name="pname">
        /// <para>
        /// Specifies a fog parameter.
        /// <code>GL_FOG_MODE</code>,
        /// <code>GL_FOG_DENSITY</code>,
        /// <code>GL_FOG_START</code>,
        /// <code>GL_FOG_END</code>,
        /// <code>GL_FOG_INDEX</code>,
        /// <code>GL_FOG_COLOR</code>, and
        /// <code>GL_FOG_COORD_SRC</code>
        /// are accepted.
        /// </para>
        /// </param>
        /// <param name="ps">
        /// <para>
        /// Specifies the value or values to be assigned to <paramref name="pname"/>.
        /// <code>GL_FOG_COLOR</code> requires an array of four values.
        /// All other parameters accept an array containing only a single value.
        /// </para>
        /// </param>
        /// <seealso cref="Enable"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void Fogiv(uint pname, ref int ps) {
            fixed (int* pPs = &ps) {
                GLNative.glFogiv(pname, pPs);
            }
        }

        /// <summary>
        /// set light source parameters
        /// <para>Require:</para> <para>GL_VERSION_1_0, GL_VERSION_ES_CM_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// It is always the case that <code>GL_LIGHT</code>
        /// i   
        /// = <code>GL_LIGHT0</code> + 
        /// i   .
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if either <paramref name="light"/> or <paramref name="pname"/>
        /// is not an accepted value.
        /// <code>GL_INVALID_VALUE</code> is generated if a spot exponent value is specified
        /// outside the range 
        /// 0 
        /// 128 
        /// ,
        /// or if spot cutoff is specified outside the range 
        /// 0 
        /// 90 
        /// (except for the
        /// special value 180),
        /// or if a negative attenuation factor is specified.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glLight"/> is executed between
        /// the execution of
        /// <see cref="glBegin"/>  and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glLightfv(GLenum light, GLenum pname, const GLfloat * params);</para>
        /// </summary>
        /// <param name="light">
        /// <para>
        /// Specifies a light.
        /// The number of lights depends on the implementation, but
        /// at least eight lights are supported.
        /// They are identified by symbolic names of the form <code>GL_LIGHT</code>
        /// i   ,
        /// where i ranges from 0 to the value of <code>GL_MAX_LIGHTS</code> - 1.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies a light source parameter for <paramref name="light"/>.
        /// <code>GL_AMBIENT</code>,
        /// <code>GL_DIFFUSE</code>,
        /// <code>GL_SPECULAR</code>,
        /// <code>GL_POSITION</code>,
        /// <code>GL_SPOT_CUTOFF</code>,
        /// <code>GL_SPOT_DIRECTION</code>,
        /// <code>GL_SPOT_EXPONENT</code>,
        /// <code>GL_CONSTANT_ATTENUATION</code>,
        /// <code>GL_LINEAR_ATTENUATION</code>, and
        /// <code>GL_QUADRATIC_ATTENUATION</code> are accepted.
        /// </para>
        /// </param>
        /// <param name="ps">
        /// <para>
        /// Specifies a pointer to the value or values that parameter <paramref name="pname"/>
        /// of light source <paramref name="light"/> will be set to.
        /// </para>
        /// </param>
        /// <seealso cref="ColorMaterial"/>
        /// <seealso cref="LightModel"/>
        /// <seealso cref="Material"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void Lightfv(uint light, uint pname, ref float ps) {
            fixed (float* pPs = &ps) {
                GLNative.glLightfv(light, pname, pPs);
            }
        }

        /// <summary>
        /// set light source parameters
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// It is always the case that <code>GL_LIGHT</code>
        /// i   
        /// = <code>GL_LIGHT0</code> + 
        /// i   .
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if either <paramref name="light"/> or <paramref name="pname"/>
        /// is not an accepted value.
        /// <code>GL_INVALID_VALUE</code> is generated if a spot exponent value is specified
        /// outside the range 
        /// 0 
        /// 128 
        /// ,
        /// or if spot cutoff is specified outside the range 
        /// 0 
        /// 90 
        /// (except for the
        /// special value 180),
        /// or if a negative attenuation factor is specified.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glLight"/> is executed between
        /// the execution of
        /// <see cref="glBegin"/>  and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glLightiv(GLenum light, GLenum pname, const GLint * params);</para>
        /// </summary>
        /// <param name="light">
        /// <para>
        /// Specifies a light.
        /// The number of lights depends on the implementation, but
        /// at least eight lights are supported.
        /// They are identified by symbolic names of the form <code>GL_LIGHT</code>
        /// i   ,
        /// where i ranges from 0 to the value of <code>GL_MAX_LIGHTS</code> - 1.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies a light source parameter for <paramref name="light"/>.
        /// <code>GL_AMBIENT</code>,
        /// <code>GL_DIFFUSE</code>,
        /// <code>GL_SPECULAR</code>,
        /// <code>GL_POSITION</code>,
        /// <code>GL_SPOT_CUTOFF</code>,
        /// <code>GL_SPOT_DIRECTION</code>,
        /// <code>GL_SPOT_EXPONENT</code>,
        /// <code>GL_CONSTANT_ATTENUATION</code>,
        /// <code>GL_LINEAR_ATTENUATION</code>, and
        /// <code>GL_QUADRATIC_ATTENUATION</code> are accepted.
        /// </para>
        /// </param>
        /// <param name="ps">
        /// <para>
        /// Specifies a pointer to the value or values that parameter <paramref name="pname"/>
        /// of light source <paramref name="light"/> will be set to.
        /// </para>
        /// </param>
        /// <seealso cref="ColorMaterial"/>
        /// <seealso cref="LightModel"/>
        /// <seealso cref="Material"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void Lightiv(uint light, uint pname, ref int ps) {
            fixed (int* pPs = &ps) {
                GLNative.glLightiv(light, pname, pPs);
            }
        }

        /// <summary>
        /// set the lighting model parameters
        /// <para>Require:</para> <para>GL_VERSION_1_0, GL_VERSION_ES_CM_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <code>GL_LIGHT_MODEL_COLOR_CONTROL</code> is available only if the GL version is
        /// 1.2 or greater.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="pname"/> is not an accepted value.
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="pname"/> is
        /// <code>GL_LIGHT_MODEL_COLOR_CONTROL</code> and <paramref name="ps"/> is not one of
        /// <code>GL_SINGLE_COLOR</code> or <code>GL_SEPARATE_SPECULAR_COLOR</code>.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glLightModel"/> is executed between
        /// the execution of  <see cref="glBegin"/>  and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glLightModelfv(GLenum pname, const GLfloat * params);</para>
        /// </summary>
        /// <param name="pname">
        /// <para>
        /// Specifies a lighting model parameter.
        /// <code>GL_LIGHT_MODEL_AMBIENT</code>,
        /// <code>GL_LIGHT_MODEL_COLOR_CONTROL</code>,
        /// <code>GL_LIGHT_MODEL_LOCAL_VIEWER</code>, and
        /// <code>GL_LIGHT_MODEL_TWO_SIDE</code> are accepted.
        /// </para>
        /// </param>
        /// <param name="ps">
        /// Specifies a pointer to the value or values that <paramref name="ps"/> will be set to.
        /// </param>
        /// <seealso cref="Light"/>
        /// <seealso cref="Material"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void LightModelfv(uint pname, ref float ps) {
            fixed (float* pPs = &ps) {
                GLNative.glLightModelfv(pname, pPs);
            }
        }

        /// <summary>
        /// set the lighting model parameters
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <code>GL_LIGHT_MODEL_COLOR_CONTROL</code> is available only if the GL version is
        /// 1.2 or greater.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="pname"/> is not an accepted value.
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="pname"/> is
        /// <code>GL_LIGHT_MODEL_COLOR_CONTROL</code> and <paramref name="ps"/> is not one of
        /// <code>GL_SINGLE_COLOR</code> or <code>GL_SEPARATE_SPECULAR_COLOR</code>.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glLightModel"/> is executed between
        /// the execution of  <see cref="glBegin"/>  and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glLightModeliv(GLenum pname, const GLint * params);</para>
        /// </summary>
        /// <param name="pname">
        /// <para>
        /// Specifies a lighting model parameter.
        /// <code>GL_LIGHT_MODEL_AMBIENT</code>,
        /// <code>GL_LIGHT_MODEL_COLOR_CONTROL</code>,
        /// <code>GL_LIGHT_MODEL_LOCAL_VIEWER</code>, and
        /// <code>GL_LIGHT_MODEL_TWO_SIDE</code> are accepted.
        /// </para>
        /// </param>
        /// <param name="ps">
        /// Specifies a pointer to the value or values that <paramref name="ps"/> will be set to.
        /// </param>
        /// <seealso cref="Light"/>
        /// <seealso cref="Material"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void LightModeliv(uint pname, ref int ps) {
            fixed (int* pPs = &ps) {
                GLNative.glLightModeliv(pname, pPs);
            }
        }

        /// <summary>
        /// specify material parameters for the lighting model
        /// <para>Require:</para> <para>GL_VERSION_1_0, GL_VERSION_ES_CM_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The material parameters can be updated at any time.
        /// In particular,
        /// <see cref="glMaterial"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// If only a single material parameter is to be changed per vertex,
        /// however,
        /// <see cref="glColorMaterial"/>  is preferred over <see cref="glMaterial"/>
        /// (see  <see cref="glColorMaterial"/> ).
        /// While the ambient, diffuse, specular and emission material parameters
        /// all have alpha components, only the diffuse alpha component is used in
        /// the lighting computation.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if either <paramref name="face"/> or <paramref name="pname"/> is not
        /// an accepted value.
        /// <code>GL_INVALID_VALUE</code> is generated if a specular exponent outside the range
        /// 0 
        /// 128 
        /// is specified.
        /// </para>
        /// Original: <para>void glMaterialfv(GLenum face, GLenum pname, const GLfloat * params);</para>
        /// </summary>
        /// <param name="face">
        /// <para>
        /// Specifies which face or faces are being updated.
        /// Must be one of
        /// <code>GL_FRONT</code>,
        /// <code>GL_BACK</code>, or
        /// <code>GL_FRONT_AND_BACK</code>.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the material parameter of the face or faces that is being updated.
        /// Must be one of
        /// <code>GL_AMBIENT</code>,
        /// <code>GL_DIFFUSE</code>,
        /// <code>GL_SPECULAR</code>,
        /// <code>GL_EMISSION</code>,
        /// <code>GL_SHININESS</code>,
        /// <code>GL_AMBIENT_AND_DIFFUSE</code>, or
        /// <code>GL_COLOR_INDEXES</code>.
        /// </para>
        /// </param>
        /// <param name="ps">
        /// Specifies a pointer to the value or values that <paramref name="pname"/> will be set to.
        /// </param>
        /// <seealso cref="ColorMaterial"/>
        /// <seealso cref="Light"/>
        /// <seealso cref="LightModel"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void Materialfv(uint face, uint pname, ref float ps) {
            fixed (float* pPs = &ps) {
                GLNative.glMaterialfv(face, pname, pPs);
            }
        }

        /// <summary>
        /// specify material parameters for the lighting model
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The material parameters can be updated at any time.
        /// In particular,
        /// <see cref="glMaterial"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// If only a single material parameter is to be changed per vertex,
        /// however,
        /// <see cref="glColorMaterial"/>  is preferred over <see cref="glMaterial"/>
        /// (see  <see cref="glColorMaterial"/> ).
        /// While the ambient, diffuse, specular and emission material parameters
        /// all have alpha components, only the diffuse alpha component is used in
        /// the lighting computation.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if either <paramref name="face"/> or <paramref name="pname"/> is not
        /// an accepted value.
        /// <code>GL_INVALID_VALUE</code> is generated if a specular exponent outside the range
        /// 0 
        /// 128 
        /// is specified.
        /// </para>
        /// Original: <para>void glMaterialiv(GLenum face, GLenum pname, const GLint * params);</para>
        /// </summary>
        /// <param name="face">
        /// <para>
        /// Specifies which face or faces are being updated.
        /// Must be one of
        /// <code>GL_FRONT</code>,
        /// <code>GL_BACK</code>, or
        /// <code>GL_FRONT_AND_BACK</code>.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the material parameter of the face or faces that is being updated.
        /// Must be one of
        /// <code>GL_AMBIENT</code>,
        /// <code>GL_DIFFUSE</code>,
        /// <code>GL_SPECULAR</code>,
        /// <code>GL_EMISSION</code>,
        /// <code>GL_SHININESS</code>,
        /// <code>GL_AMBIENT_AND_DIFFUSE</code>, or
        /// <code>GL_COLOR_INDEXES</code>.
        /// </para>
        /// </param>
        /// <param name="ps">
        /// Specifies a pointer to the value or values that <paramref name="pname"/> will be set to.
        /// </param>
        /// <seealso cref="ColorMaterial"/>
        /// <seealso cref="Light"/>
        /// <seealso cref="LightModel"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void Materialiv(uint face, uint pname, ref int ps) {
            fixed (int* pPs = &ps) {
                GLNative.glMaterialiv(face, pname, pPs);
            }
        }

        /// <summary>
        /// set the polygon stippling pattern
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_UNPACK_BUFFER</code> target and the buffer object's data store is currently mapped.
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_UNPACK_BUFFER</code> target and the data would be unpacked from the buffer 
        /// object such that the memory reads required would exceed the data store size.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glPolygonStipple"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glPolygonStipple(const GLubyte * pattern);</para>
        /// </summary>
        /// <param name="pattern">
        /// <para>
        /// Specifies a pointer to a 
        /// 32 
        /// &times; 
        /// 32 
        /// stipple pattern that will be unpacked
        /// from memory in the same way that  <see cref="glDrawPixels"/>  unpacks pixels.
        /// </para>
        /// </param>
        /// <seealso cref="DrawPixels"/>
        /// <seealso cref="LineStipple"/>
        /// <seealso cref="PixelStore"/>
        /// <seealso cref="PixelTransfer"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void PolygonStipple(ref byte pattern) {
            fixed (byte* pPattern = &pattern) {
                GLNative.glPolygonStipple(pPattern);
            }
        }

        /// <summary>
        /// set texture environment parameters
        /// <para>Require:</para> <para>GL_VERSION_1_0, GL_VERSION_ES_CM_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <code>GL_REPLACE</code> may only be used if the GL version is 1.1 or greater.
        /// <code>GL_TEXTURE_FILTER_CONTROL</code> and <code>GL_TEXTURE_LOD_BIAS</code> may only be
        /// used if the GL version is 1.4 or greater.
        /// <code>GL_COMBINE</code> mode and its associated constants may only be used if the
        /// GL version is 1.3 or greater.
        /// <code>GL_TEXTUREn</code> may only be used if the GL version is 1.4 or greater.
        /// Internal formats other than 1, 2, 3, or 4 may only be used if the GL
        /// version is 1.1 or greater.
        /// For OpenGL versions 1.3 and greater, or when the <code>ARB_multitexture</code> extension is supported, <see cref="glTexEnv"/> controls
        /// the texture environment for the current active texture unit, selected by
        /// <see cref="glActiveTexture"/> .
        /// <code>GL_POINT_SPRITE</code> and <code>GL_COORD_REPLACE</code> are available
        /// only if the GL version is 2.0 or greater.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated when <paramref name="target"/> or <paramref name="pname"/> is not
        /// one of the accepted defined values,
        /// or when <paramref name="ps"/> should have a defined constant value
        /// (based on the value of <paramref name="pname"/>)
        /// and does not.
        /// <code>GL_INVALID_VALUE</code> is generated if the <paramref name="ps"/> value for
        /// <code>GL_RGB_SCALE</code> or <code>GL_ALPHA_SCALE</code> are not one of 1.0, 2.0,
        /// or 4.0.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glTexEnv"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glTexEnvfv(GLenum target, GLenum pname, const GLfloat * params);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies a texture environment.
        /// May be either <code>GL_TEXTURE_ENV</code>, or <code>GL_TEXTURE_FILTER_CONTROL</code>.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of a texture environment parameter.
        /// Accepted values are <code>GL_TEXTURE_ENV_MODE</code>, <code>GL_TEXTURE_ENV_COLOR</code>, or
        /// <code>GL_TEXTURE_LOD_BIAS</code>.
        /// </para>
        /// </param>
        /// <param name="ps">
        /// <para>
        /// Specifies a pointer to a parameter array that contains
        /// either a single symbolic constant, single floating-point number, or an RGBA
        /// color.
        /// </para>
        /// </param>
        /// <seealso cref="ActiveTexture"/>
        /// <seealso cref="CopyPixels"/>
        /// <seealso cref="CopyTexImage1D"/>
        /// <seealso cref="CopyTexImage2D"/>
        /// <seealso cref="CopyTexSubImage1D"/>
        /// <seealso cref="CopyTexSubImage2D"/>
        /// <seealso cref="CopyTexSubImage3D"/>
        /// <seealso cref="TexImage1D"/>
        /// <seealso cref="TexImage2D"/>
        /// <seealso cref="TexImage3D"/>
        /// <seealso cref="TexParameter"/>
        /// <seealso cref="TexSubImage1D"/>
        /// <seealso cref="TexSubImage2D"/>
        /// <seealso cref="TexSubImage3D"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void TexEnvfv(uint target, uint pname, ref float ps) {
            fixed (float* pPs = &ps) {
                GLNative.glTexEnvfv(target, pname, pPs);
            }
        }

        /// <summary>
        /// set texture environment parameters
        /// <para>Require:</para> <para>GL_VERSION_1_0, GL_VERSION_ES_CM_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <code>GL_REPLACE</code> may only be used if the GL version is 1.1 or greater.
        /// <code>GL_TEXTURE_FILTER_CONTROL</code> and <code>GL_TEXTURE_LOD_BIAS</code> may only be
        /// used if the GL version is 1.4 or greater.
        /// <code>GL_COMBINE</code> mode and its associated constants may only be used if the
        /// GL version is 1.3 or greater.
        /// <code>GL_TEXTUREn</code> may only be used if the GL version is 1.4 or greater.
        /// Internal formats other than 1, 2, 3, or 4 may only be used if the GL
        /// version is 1.1 or greater.
        /// For OpenGL versions 1.3 and greater, or when the <code>ARB_multitexture</code> extension is supported, <see cref="glTexEnv"/> controls
        /// the texture environment for the current active texture unit, selected by
        /// <see cref="glActiveTexture"/> .
        /// <code>GL_POINT_SPRITE</code> and <code>GL_COORD_REPLACE</code> are available
        /// only if the GL version is 2.0 or greater.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated when <paramref name="target"/> or <paramref name="pname"/> is not
        /// one of the accepted defined values,
        /// or when <paramref name="ps"/> should have a defined constant value
        /// (based on the value of <paramref name="pname"/>)
        /// and does not.
        /// <code>GL_INVALID_VALUE</code> is generated if the <paramref name="ps"/> value for
        /// <code>GL_RGB_SCALE</code> or <code>GL_ALPHA_SCALE</code> are not one of 1.0, 2.0,
        /// or 4.0.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glTexEnv"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glTexEnviv(GLenum target, GLenum pname, const GLint * params);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies a texture environment.
        /// May be either <code>GL_TEXTURE_ENV</code>, or <code>GL_TEXTURE_FILTER_CONTROL</code>.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of a texture environment parameter.
        /// Accepted values are <code>GL_TEXTURE_ENV_MODE</code>, <code>GL_TEXTURE_ENV_COLOR</code>, or
        /// <code>GL_TEXTURE_LOD_BIAS</code>.
        /// </para>
        /// </param>
        /// <param name="ps">
        /// <para>
        /// Specifies a pointer to a parameter array that contains
        /// either a single symbolic constant, single floating-point number, or an RGBA
        /// color.
        /// </para>
        /// </param>
        /// <seealso cref="ActiveTexture"/>
        /// <seealso cref="CopyPixels"/>
        /// <seealso cref="CopyTexImage1D"/>
        /// <seealso cref="CopyTexImage2D"/>
        /// <seealso cref="CopyTexSubImage1D"/>
        /// <seealso cref="CopyTexSubImage2D"/>
        /// <seealso cref="CopyTexSubImage3D"/>
        /// <seealso cref="TexImage1D"/>
        /// <seealso cref="TexImage2D"/>
        /// <seealso cref="TexImage3D"/>
        /// <seealso cref="TexParameter"/>
        /// <seealso cref="TexSubImage1D"/>
        /// <seealso cref="TexSubImage2D"/>
        /// <seealso cref="TexSubImage3D"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void TexEnviv(uint target, uint pname, ref int ps) {
            fixed (int* pPs = &ps) {
                GLNative.glTexEnviv(target, pname, pPs);
            }
        }

        /// <summary>
        /// control the generation of texture coordinates
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated when <paramref name="coord"/> or <paramref name="pname"/> is not an
        /// accepted defined value,
        /// or when <paramref name="pname"/> is <code>GL_TEXTURE_GEN_MODE</code> and <paramref name="ps"/> is not an
        /// accepted defined value.
        /// <code>GL_INVALID_ENUM</code> is generated when <paramref name="pname"/> is <code>GL_TEXTURE_GEN_MODE</code>,
        /// <paramref name="ps"/> is <code>GL_SPHERE_MAP</code>,
        /// and <paramref name="coord"/> is either <code>GL_R</code> or <code>GL_Q</code>.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glTexGen"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glTexGendv(GLenum coord, GLenum pname, const GLdouble * params);</para>
        /// </summary>
        /// <param name="coord">
        /// <para>
        /// Specifies a texture coordinate.
        /// Must be one of <code>GL_S</code>, <code>GL_T</code>, <code>GL_R</code>, or <code>GL_Q</code>.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of the texture-coordinate generation function
        /// or function parameters.
        /// Must be
        /// <code>GL_TEXTURE_GEN_MODE</code>,
        /// <code>GL_OBJECT_PLANE</code>, or
        /// <code>GL_EYE_PLANE</code>.
        /// </para>
        /// </param>
        /// <param name="ps">
        /// <para>
        /// Specifies a pointer to an array of texture generation parameters.
        /// If <paramref name="pname"/> is <code>GL_TEXTURE_GEN_MODE</code>,
        /// then the array must contain a single symbolic constant,
        /// one of
        /// <code>GL_OBJECT_LINEAR</code>,
        /// <code>GL_EYE_LINEAR</code>,
        /// <code>GL_SPHERE_MAP</code>,
        /// <code>GL_NORMAL_MAP</code>, or
        /// <code>GL_REFLECTION_MAP</code>.
        /// Otherwise,
        /// <paramref name="ps"/> holds the coefficients for the texture-coordinate generation function
        /// specified by <paramref name="pname"/>.
        /// </para>
        /// </param>
        /// <seealso cref="ActiveTexture"/>
        /// <seealso cref="CopyPixels"/>
        /// <seealso cref="CopyTexImage2D"/>
        /// <seealso cref="CopyTexSubImage1D"/>
        /// <seealso cref="CopyTexSubImage2D"/>
        /// <seealso cref="CopyTexSubImage3D"/>
        /// <seealso cref="TexEnv"/>
        /// <seealso cref="TexImage1D"/>
        /// <seealso cref="TexImage2D"/>
        /// <seealso cref="TexImage3D"/>
        /// <seealso cref="TexParameter"/>
        /// <seealso cref="TexSubImage1D"/>
        /// <seealso cref="TexSubImage2D"/>
        /// <seealso cref="TexSubImage3D"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void TexGendv(uint coord, uint pname, ref double ps) {
            fixed (double* pPs = &ps) {
                GLNative.glTexGendv(coord, pname, pPs);
            }
        }

        /// <summary>
        /// control the generation of texture coordinates
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated when <paramref name="coord"/> or <paramref name="pname"/> is not an
        /// accepted defined value,
        /// or when <paramref name="pname"/> is <code>GL_TEXTURE_GEN_MODE</code> and <paramref name="ps"/> is not an
        /// accepted defined value.
        /// <code>GL_INVALID_ENUM</code> is generated when <paramref name="pname"/> is <code>GL_TEXTURE_GEN_MODE</code>,
        /// <paramref name="ps"/> is <code>GL_SPHERE_MAP</code>,
        /// and <paramref name="coord"/> is either <code>GL_R</code> or <code>GL_Q</code>.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glTexGen"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glTexGenfv(GLenum coord, GLenum pname, const GLfloat * params);</para>
        /// </summary>
        /// <param name="coord">
        /// <para>
        /// Specifies a texture coordinate.
        /// Must be one of <code>GL_S</code>, <code>GL_T</code>, <code>GL_R</code>, or <code>GL_Q</code>.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of the texture-coordinate generation function
        /// or function parameters.
        /// Must be
        /// <code>GL_TEXTURE_GEN_MODE</code>,
        /// <code>GL_OBJECT_PLANE</code>, or
        /// <code>GL_EYE_PLANE</code>.
        /// </para>
        /// </param>
        /// <param name="ps">
        /// <para>
        /// Specifies a pointer to an array of texture generation parameters.
        /// If <paramref name="pname"/> is <code>GL_TEXTURE_GEN_MODE</code>,
        /// then the array must contain a single symbolic constant,
        /// one of
        /// <code>GL_OBJECT_LINEAR</code>,
        /// <code>GL_EYE_LINEAR</code>,
        /// <code>GL_SPHERE_MAP</code>,
        /// <code>GL_NORMAL_MAP</code>, or
        /// <code>GL_REFLECTION_MAP</code>.
        /// Otherwise,
        /// <paramref name="ps"/> holds the coefficients for the texture-coordinate generation function
        /// specified by <paramref name="pname"/>.
        /// </para>
        /// </param>
        /// <seealso cref="ActiveTexture"/>
        /// <seealso cref="CopyPixels"/>
        /// <seealso cref="CopyTexImage2D"/>
        /// <seealso cref="CopyTexSubImage1D"/>
        /// <seealso cref="CopyTexSubImage2D"/>
        /// <seealso cref="CopyTexSubImage3D"/>
        /// <seealso cref="TexEnv"/>
        /// <seealso cref="TexImage1D"/>
        /// <seealso cref="TexImage2D"/>
        /// <seealso cref="TexImage3D"/>
        /// <seealso cref="TexParameter"/>
        /// <seealso cref="TexSubImage1D"/>
        /// <seealso cref="TexSubImage2D"/>
        /// <seealso cref="TexSubImage3D"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void TexGenfv(uint coord, uint pname, ref float ps) {
            fixed (float* pPs = &ps) {
                GLNative.glTexGenfv(coord, pname, pPs);
            }
        }

        /// <summary>
        /// control the generation of texture coordinates
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated when <paramref name="coord"/> or <paramref name="pname"/> is not an
        /// accepted defined value,
        /// or when <paramref name="pname"/> is <code>GL_TEXTURE_GEN_MODE</code> and <paramref name="ps"/> is not an
        /// accepted defined value.
        /// <code>GL_INVALID_ENUM</code> is generated when <paramref name="pname"/> is <code>GL_TEXTURE_GEN_MODE</code>,
        /// <paramref name="ps"/> is <code>GL_SPHERE_MAP</code>,
        /// and <paramref name="coord"/> is either <code>GL_R</code> or <code>GL_Q</code>.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glTexGen"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glTexGeniv(GLenum coord, GLenum pname, const GLint * params);</para>
        /// </summary>
        /// <param name="coord">
        /// <para>
        /// Specifies a texture coordinate.
        /// Must be one of <code>GL_S</code>, <code>GL_T</code>, <code>GL_R</code>, or <code>GL_Q</code>.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of the texture-coordinate generation function
        /// or function parameters.
        /// Must be
        /// <code>GL_TEXTURE_GEN_MODE</code>,
        /// <code>GL_OBJECT_PLANE</code>, or
        /// <code>GL_EYE_PLANE</code>.
        /// </para>
        /// </param>
        /// <param name="ps">
        /// <para>
        /// Specifies a pointer to an array of texture generation parameters.
        /// If <paramref name="pname"/> is <code>GL_TEXTURE_GEN_MODE</code>,
        /// then the array must contain a single symbolic constant,
        /// one of
        /// <code>GL_OBJECT_LINEAR</code>,
        /// <code>GL_EYE_LINEAR</code>,
        /// <code>GL_SPHERE_MAP</code>,
        /// <code>GL_NORMAL_MAP</code>, or
        /// <code>GL_REFLECTION_MAP</code>.
        /// Otherwise,
        /// <paramref name="ps"/> holds the coefficients for the texture-coordinate generation function
        /// specified by <paramref name="pname"/>.
        /// </para>
        /// </param>
        /// <seealso cref="ActiveTexture"/>
        /// <seealso cref="CopyPixels"/>
        /// <seealso cref="CopyTexImage2D"/>
        /// <seealso cref="CopyTexSubImage1D"/>
        /// <seealso cref="CopyTexSubImage2D"/>
        /// <seealso cref="CopyTexSubImage3D"/>
        /// <seealso cref="TexEnv"/>
        /// <seealso cref="TexImage1D"/>
        /// <seealso cref="TexImage2D"/>
        /// <seealso cref="TexImage3D"/>
        /// <seealso cref="TexParameter"/>
        /// <seealso cref="TexSubImage1D"/>
        /// <seealso cref="TexSubImage2D"/>
        /// <seealso cref="TexSubImage3D"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void TexGeniv(uint coord, uint pname, ref int ps) {
            fixed (int* pPs = &ps) {
                GLNative.glTexGeniv(coord, pname, pPs);
            }
        }

        /// <summary>
        /// controls feedback mode
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glFeedbackBuffer"/>, when used in a display list, is not compiled into the display list
        /// but is executed immediately.
        /// <see cref="glFeedbackBuffer"/> returns only the texture coordinate of texture unit <code>GL_TEXTURE0</code>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="type"/> is not an accepted value.
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="size"/> is negative.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glFeedbackBuffer"/> is called while the
        /// render mode is <code>GL_FEEDBACK</code>,
        /// or if  <see cref="glRenderMode"/>  is called with argument <code>GL_FEEDBACK</code> before
        /// <see cref="glFeedbackBuffer"/> is called at least once.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glFeedbackBuffer"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glFeedbackBuffer(GLsizei size, GLenum type, GLfloat * buffer);</para>
        /// </summary>
        /// <param name="size">
        /// Specifies the maximum number of values that can be written into <paramref name="buffer"/>.
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies a symbolic constant that describes the information
        /// that will be returned for each vertex.
        /// <code>GL_2D</code>,
        /// <code>GL_3D</code>,
        /// <code>GL_3D_COLOR</code>,
        /// <code>GL_3D_COLOR_TEXTURE</code>, and
        /// <code>GL_4D_COLOR_TEXTURE</code> are accepted.
        /// </para>
        /// </param>
        /// <param name="buffer">
        /// Returns the feedback data.
        /// </param>
        /// <seealso cref="Begin"/>
        /// <seealso cref="LineStipple"/>
        /// <seealso cref="PassThrough"/>
        /// <seealso cref="PolygonMode"/>
        /// <seealso cref="RenderMode"/>
        /// <seealso cref="SelectBuffer"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void FeedbackBuffer(int size, uint type, ref float buffer) {
            fixed (float* pBuffer = &buffer) {
                GLNative.glFeedbackBuffer(size, type, pBuffer);
            }
        }

        /// <summary>
        /// establish a buffer for selection mode values
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The contents of <paramref name="buffer"/> is undefined until  <see cref="glRenderMode"/>  is called
        /// with an argument other than <code>GL_SELECT</code>.
        /// <see cref="glBegin"/> / <see cref="glEnd"/>  primitives and calls to  <see cref="glRasterPos"/> 
        /// can result in hits.   <see cref="glWindowPos"/>  will always generate a selection hit.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="size"/> is negative.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glSelectBuffer"/> is called while the
        /// render mode is <code>GL_SELECT</code>,
        /// or if  <see cref="glRenderMode"/>  is called with argument <code>GL_SELECT</code> before
        /// <see cref="glSelectBuffer"/> is called at least once.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glSelectBuffer"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glSelectBuffer(GLsizei size, GLuint * buffer);</para>
        /// </summary>
        /// <param name="size">
        /// Specifies the size of <paramref name="buffer"/>.
        /// </param>
        /// <param name="buffer">
        /// Returns the selection data.
        /// </param>
        /// <seealso cref="FeedbackBuffer"/>
        /// <seealso cref="InitNames"/>
        /// <seealso cref="LoadName"/>
        /// <seealso cref="PushName"/>
        /// <seealso cref="RenderMode"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void SelectBuffer(int size, ref uint buffer) {
            fixed (uint* pBuffer = &buffer) {
                GLNative.glSelectBuffer(size, pBuffer);
            }
        }

        /// <summary>
        /// define a one-dimensional evaluator
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// As is the case with all GL commands that accept pointers to data,
        /// it is as if the contents of <paramref name="points"/> were copied by <see cref="glMap1"/> before <see cref="glMap1"/>
        /// returns.
        /// Changes to the contents of <paramref name="points"/> have no effect after <see cref="glMap1"/> is called.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="target"/> is not an accepted value.
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="u1"/> is equal to <paramref name="u2"/>.
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="stride"/> is less than the number
        /// of values in a control point.
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="order"/> is less than 1 or
        /// greater than the return value of <code>GL_MAX_EVAL_ORDER</code>.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glMap1"/>
        /// is executed between the execution of
        /// <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glMap1"/> is called and the value
        /// of <code>GL_ACTIVE_TEXTURE</code> is not <code>GL_TEXTURE0</code>.
        /// </para>
        /// Original: <para>void glMap1d(GLenum target, GLdouble u1, GLdouble u2, GLint stride, GLint order, const GLdouble * points);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the kind of values that are generated by the evaluator.
        /// Symbolic constants
        /// <code>GL_MAP1_VERTEX_3</code>,
        /// <code>GL_MAP1_VERTEX_4</code>,
        /// <code>GL_MAP1_INDEX</code>,
        /// <code>GL_MAP1_COLOR_4</code>,
        /// <code>GL_MAP1_NORMAL</code>,
        /// <code>GL_MAP1_TEXTURE_COORD_1</code>,
        /// <code>GL_MAP1_TEXTURE_COORD_2</code>,
        /// <code>GL_MAP1_TEXTURE_COORD_3</code>, and
        /// <code>GL_MAP1_TEXTURE_COORD_4</code> are accepted.
        /// </para>
        /// </param>
        /// <param name="u1">
        /// <para>
        /// Specify a linear mapping of 
        /// u   ,
        /// as presented to  <see cref="glEvalCoord1"/> ,
        /// to 
        /// u  &Hat;  
        /// ,
        /// the variable that is evaluated by the equations specified by this command.
        /// </para>
        /// </param>
        /// <param name="u2">
        /// <para>
        /// Specify a linear mapping of 
        /// u   ,
        /// as presented to  <see cref="glEvalCoord1"/> ,
        /// to 
        /// u  &Hat;  
        /// ,
        /// the variable that is evaluated by the equations specified by this command.
        /// </para>
        /// </param>
        /// <param name="stride">
        /// <para>
        /// Specifies the number of floats or doubles between
        /// the beginning of one control point and the beginning of the next one
        /// in the data structure referenced in <paramref name="points"/>.
        /// This allows control points to be embedded in arbitrary data structures.
        /// The only constraint is that the values for a particular control point
        /// must occupy contiguous memory locations.
        /// </para>
        /// </param>
        /// <param name="order">
        /// <para>
        /// Specifies the number of control points.
        /// Must be positive.
        /// </para>
        /// </param>
        /// <param name="points">
        /// Specifies a pointer to the array of control points.
        /// </param>
        /// <seealso cref="Begin"/>
        /// <seealso cref="Color"/>
        /// <seealso cref="Enable"/>
        /// <seealso cref="EvalCoord"/>
        /// <seealso cref="EvalMesh"/>
        /// <seealso cref="EvalPoint"/>
        /// <seealso cref="Map2"/>
        /// <seealso cref="MapGrid"/>
        /// <seealso cref="Normal"/>
        /// <seealso cref="TexCoord"/>
        /// <seealso cref="Vertex"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void Map1d(uint target, double u1, double u2, int stride, int order, ref double points) {
            fixed (double* pPoints = &points) {
                GLNative.glMap1d(target, u1, u2, stride, order, pPoints);
            }
        }

        /// <summary>
        /// define a one-dimensional evaluator
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// As is the case with all GL commands that accept pointers to data,
        /// it is as if the contents of <paramref name="points"/> were copied by <see cref="glMap1"/> before <see cref="glMap1"/>
        /// returns.
        /// Changes to the contents of <paramref name="points"/> have no effect after <see cref="glMap1"/> is called.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="target"/> is not an accepted value.
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="u1"/> is equal to <paramref name="u2"/>.
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="stride"/> is less than the number
        /// of values in a control point.
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="order"/> is less than 1 or
        /// greater than the return value of <code>GL_MAX_EVAL_ORDER</code>.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glMap1"/>
        /// is executed between the execution of
        /// <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glMap1"/> is called and the value
        /// of <code>GL_ACTIVE_TEXTURE</code> is not <code>GL_TEXTURE0</code>.
        /// </para>
        /// Original: <para>void glMap1f(GLenum target, GLfloat u1, GLfloat u2, GLint stride, GLint order, const GLfloat * points);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the kind of values that are generated by the evaluator.
        /// Symbolic constants
        /// <code>GL_MAP1_VERTEX_3</code>,
        /// <code>GL_MAP1_VERTEX_4</code>,
        /// <code>GL_MAP1_INDEX</code>,
        /// <code>GL_MAP1_COLOR_4</code>,
        /// <code>GL_MAP1_NORMAL</code>,
        /// <code>GL_MAP1_TEXTURE_COORD_1</code>,
        /// <code>GL_MAP1_TEXTURE_COORD_2</code>,
        /// <code>GL_MAP1_TEXTURE_COORD_3</code>, and
        /// <code>GL_MAP1_TEXTURE_COORD_4</code> are accepted.
        /// </para>
        /// </param>
        /// <param name="u1">
        /// <para>
        /// Specify a linear mapping of 
        /// u   ,
        /// as presented to  <see cref="glEvalCoord1"/> ,
        /// to 
        /// u  &Hat;  
        /// ,
        /// the variable that is evaluated by the equations specified by this command.
        /// </para>
        /// </param>
        /// <param name="u2">
        /// <para>
        /// Specify a linear mapping of 
        /// u   ,
        /// as presented to  <see cref="glEvalCoord1"/> ,
        /// to 
        /// u  &Hat;  
        /// ,
        /// the variable that is evaluated by the equations specified by this command.
        /// </para>
        /// </param>
        /// <param name="stride">
        /// <para>
        /// Specifies the number of floats or doubles between
        /// the beginning of one control point and the beginning of the next one
        /// in the data structure referenced in <paramref name="points"/>.
        /// This allows control points to be embedded in arbitrary data structures.
        /// The only constraint is that the values for a particular control point
        /// must occupy contiguous memory locations.
        /// </para>
        /// </param>
        /// <param name="order">
        /// <para>
        /// Specifies the number of control points.
        /// Must be positive.
        /// </para>
        /// </param>
        /// <param name="points">
        /// Specifies a pointer to the array of control points.
        /// </param>
        /// <seealso cref="Begin"/>
        /// <seealso cref="Color"/>
        /// <seealso cref="Enable"/>
        /// <seealso cref="EvalCoord"/>
        /// <seealso cref="EvalMesh"/>
        /// <seealso cref="EvalPoint"/>
        /// <seealso cref="Map2"/>
        /// <seealso cref="MapGrid"/>
        /// <seealso cref="Normal"/>
        /// <seealso cref="TexCoord"/>
        /// <seealso cref="Vertex"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void Map1f(uint target, float u1, float u2, int stride, int order, ref float points) {
            fixed (float* pPoints = &points) {
                GLNative.glMap1f(target, u1, u2, stride, order, pPoints);
            }
        }

        /// <summary>
        /// define a two-dimensional evaluator
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// As is the case with all GL commands that accept pointers to data,
        /// it is as if the contents of <paramref name="points"/> were copied by <see cref="glMap2"/> before <see cref="glMap2"/>
        /// returns.
        /// Changes to the contents of <paramref name="points"/> have no effect after <see cref="glMap2"/> is called.
        /// Initially, <code>GL_AUTO_NORMAL</code> is enabled. If <code>GL_AUTO_NORMAL</code> is enabled,
        /// normal vectors are generated when either
        /// <code>GL_MAP2_VERTEX_3</code> or <code>GL_MAP2_VERTEX_4</code> is used to generate
        /// vertices.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="target"/> is not an accepted value.
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="u1"/> is equal to <paramref name="u2"/>,
        /// or if <paramref name="v1"/> is equal to <paramref name="v2"/>.
        /// <code>GL_INVALID_VALUE</code> is generated if either <paramref name="ustride"/> or <paramref name="vstride"/>
        /// is less than the number of values in a control point.
        /// <code>GL_INVALID_VALUE</code> is generated if either <paramref name="uorder"/> or <paramref name="vorder"/>
        /// is less than 1 or greater than the return value of <code>GL_MAX_EVAL_ORDER</code>.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glMap2"/>
        /// is executed between the execution of
        /// <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glMap2"/> is called and the value
        /// of <code>GL_ACTIVE_TEXTURE</code> is not <code>GL_TEXTURE0</code>.
        /// </para>
        /// Original: <para>void glMap2d(GLenum target, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, const GLdouble * points);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the kind of values that are generated by the evaluator.
        /// Symbolic constants
        /// <code>GL_MAP2_VERTEX_3</code>,
        /// <code>GL_MAP2_VERTEX_4</code>,
        /// <code>GL_MAP2_INDEX</code>,
        /// <code>GL_MAP2_COLOR_4</code>,
        /// <code>GL_MAP2_NORMAL</code>,
        /// <code>GL_MAP2_TEXTURE_COORD_1</code>,
        /// <code>GL_MAP2_TEXTURE_COORD_2</code>,
        /// <code>GL_MAP2_TEXTURE_COORD_3</code>, and
        /// <code>GL_MAP2_TEXTURE_COORD_4</code> are accepted.
        /// </para>
        /// </param>
        /// <param name="u1">
        /// <para>
        /// Specify a linear mapping of 
        /// u   ,
        /// as presented to  <see cref="glEvalCoord2"/> ,
        /// to 
        /// u  &Hat;  
        /// ,
        /// one of the two variables that are evaluated by the equations specified
        /// by this command. Initially, <paramref name="u1"/> is 0 and <paramref name="u2"/> is 1.
        /// </para>
        /// </param>
        /// <param name="u2">
        /// <para>
        /// Specify a linear mapping of 
        /// u   ,
        /// as presented to  <see cref="glEvalCoord2"/> ,
        /// to 
        /// u  &Hat;  
        /// ,
        /// one of the two variables that are evaluated by the equations specified
        /// by this command. Initially, <paramref name="u1"/> is 0 and <paramref name="u2"/> is 1.
        /// </para>
        /// </param>
        /// <param name="ustride">
        /// <para>
        /// Specifies the number of floats or doubles between
        /// the beginning of control point
        /// R 
        /// ij 
        /// and the beginning of control point
        /// R 
        /// i 
        /// + 
        /// 1 
        /// &it; 
        /// j 
        /// ,
        /// where 
        /// i   
        /// and 
        /// j   
        /// are the 
        /// u   
        /// and 
        /// v   
        /// control point indices, respectively.
        /// This allows control points to be embedded in arbitrary data structures.
        /// The only constraint is that the values for a particular control point
        /// must occupy contiguous memory locations. The initial value of <paramref name="ustride"/> is 0.
        /// </para>
        /// </param>
        /// <param name="uorder">
        /// <para>
        /// Specifies the dimension of the control point array in the 
        /// u   
        /// axis.
        /// Must be positive. The initial value is 1.
        /// </para>
        /// </param>
        /// <param name="v1">
        /// <para>
        /// Specify a linear mapping of 
        /// v   ,
        /// as presented to  <see cref="glEvalCoord2"/> ,
        /// to 
        /// v  &Hat;  
        /// ,
        /// one of the two variables that are evaluated by the equations specified
        /// by this command. Initially, <paramref name="v1"/> is 0 and <paramref name="v2"/> is 1.
        /// </para>
        /// </param>
        /// <param name="v2">
        /// <para>
        /// Specify a linear mapping of 
        /// v   ,
        /// as presented to  <see cref="glEvalCoord2"/> ,
        /// to 
        /// v  &Hat;  
        /// ,
        /// one of the two variables that are evaluated by the equations specified
        /// by this command. Initially, <paramref name="v1"/> is 0 and <paramref name="v2"/> is 1.
        /// </para>
        /// </param>
        /// <param name="vstride">
        /// <para>
        /// Specifies the number of floats or doubles between
        /// the beginning of control point
        /// R 
        /// ij 
        /// and the beginning of control point
        /// R 
        /// i 
        /// &af; 
        /// j 
        /// + 
        /// 1 
        /// ,
        /// where 
        /// i   
        /// and 
        /// j   
        /// are the 
        /// u   
        /// and 
        /// v   
        /// control point indices, respectively.
        /// This allows control points to be embedded in arbitrary data structures.
        /// The only constraint is that the values for a particular control point
        /// must occupy contiguous memory locations. The initial value of <paramref name="vstride"/> is 0.
        /// </para>
        /// </param>
        /// <param name="vorder">
        /// <para>
        /// Specifies the dimension of the control point array in the 
        /// v   
        /// axis.
        /// Must be positive. The initial value is 1.
        /// </para>
        /// </param>
        /// <param name="points">
        /// Specifies a pointer to the array of control points.
        /// </param>
        /// <seealso cref="Begin"/>
        /// <seealso cref="Color"/>
        /// <seealso cref="Enable"/>
        /// <seealso cref="EvalCoord"/>
        /// <seealso cref="EvalMesh"/>
        /// <seealso cref="EvalPoint"/>
        /// <seealso cref="Map1"/>
        /// <seealso cref="MapGrid"/>
        /// <seealso cref="Normal"/>
        /// <seealso cref="TexCoord"/>
        /// <seealso cref="Vertex"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void Map2d(uint target, double u1, double u2, int ustride, int uorder, double v1, double v2, int vstride, int vorder, ref double points) {
            fixed (double* pPoints = &points) {
                GLNative.glMap2d(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, pPoints);
            }
        }

        /// <summary>
        /// define a two-dimensional evaluator
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// As is the case with all GL commands that accept pointers to data,
        /// it is as if the contents of <paramref name="points"/> were copied by <see cref="glMap2"/> before <see cref="glMap2"/>
        /// returns.
        /// Changes to the contents of <paramref name="points"/> have no effect after <see cref="glMap2"/> is called.
        /// Initially, <code>GL_AUTO_NORMAL</code> is enabled. If <code>GL_AUTO_NORMAL</code> is enabled,
        /// normal vectors are generated when either
        /// <code>GL_MAP2_VERTEX_3</code> or <code>GL_MAP2_VERTEX_4</code> is used to generate
        /// vertices.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="target"/> is not an accepted value.
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="u1"/> is equal to <paramref name="u2"/>,
        /// or if <paramref name="v1"/> is equal to <paramref name="v2"/>.
        /// <code>GL_INVALID_VALUE</code> is generated if either <paramref name="ustride"/> or <paramref name="vstride"/>
        /// is less than the number of values in a control point.
        /// <code>GL_INVALID_VALUE</code> is generated if either <paramref name="uorder"/> or <paramref name="vorder"/>
        /// is less than 1 or greater than the return value of <code>GL_MAX_EVAL_ORDER</code>.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glMap2"/>
        /// is executed between the execution of
        /// <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glMap2"/> is called and the value
        /// of <code>GL_ACTIVE_TEXTURE</code> is not <code>GL_TEXTURE0</code>.
        /// </para>
        /// Original: <para>void glMap2f(GLenum target, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, const GLfloat * points);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the kind of values that are generated by the evaluator.
        /// Symbolic constants
        /// <code>GL_MAP2_VERTEX_3</code>,
        /// <code>GL_MAP2_VERTEX_4</code>,
        /// <code>GL_MAP2_INDEX</code>,
        /// <code>GL_MAP2_COLOR_4</code>,
        /// <code>GL_MAP2_NORMAL</code>,
        /// <code>GL_MAP2_TEXTURE_COORD_1</code>,
        /// <code>GL_MAP2_TEXTURE_COORD_2</code>,
        /// <code>GL_MAP2_TEXTURE_COORD_3</code>, and
        /// <code>GL_MAP2_TEXTURE_COORD_4</code> are accepted.
        /// </para>
        /// </param>
        /// <param name="u1">
        /// <para>
        /// Specify a linear mapping of 
        /// u   ,
        /// as presented to  <see cref="glEvalCoord2"/> ,
        /// to 
        /// u  &Hat;  
        /// ,
        /// one of the two variables that are evaluated by the equations specified
        /// by this command. Initially, <paramref name="u1"/> is 0 and <paramref name="u2"/> is 1.
        /// </para>
        /// </param>
        /// <param name="u2">
        /// <para>
        /// Specify a linear mapping of 
        /// u   ,
        /// as presented to  <see cref="glEvalCoord2"/> ,
        /// to 
        /// u  &Hat;  
        /// ,
        /// one of the two variables that are evaluated by the equations specified
        /// by this command. Initially, <paramref name="u1"/> is 0 and <paramref name="u2"/> is 1.
        /// </para>
        /// </param>
        /// <param name="ustride">
        /// <para>
        /// Specifies the number of floats or doubles between
        /// the beginning of control point
        /// R 
        /// ij 
        /// and the beginning of control point
        /// R 
        /// i 
        /// + 
        /// 1 
        /// &it; 
        /// j 
        /// ,
        /// where 
        /// i   
        /// and 
        /// j   
        /// are the 
        /// u   
        /// and 
        /// v   
        /// control point indices, respectively.
        /// This allows control points to be embedded in arbitrary data structures.
        /// The only constraint is that the values for a particular control point
        /// must occupy contiguous memory locations. The initial value of <paramref name="ustride"/> is 0.
        /// </para>
        /// </param>
        /// <param name="uorder">
        /// <para>
        /// Specifies the dimension of the control point array in the 
        /// u   
        /// axis.
        /// Must be positive. The initial value is 1.
        /// </para>
        /// </param>
        /// <param name="v1">
        /// <para>
        /// Specify a linear mapping of 
        /// v   ,
        /// as presented to  <see cref="glEvalCoord2"/> ,
        /// to 
        /// v  &Hat;  
        /// ,
        /// one of the two variables that are evaluated by the equations specified
        /// by this command. Initially, <paramref name="v1"/> is 0 and <paramref name="v2"/> is 1.
        /// </para>
        /// </param>
        /// <param name="v2">
        /// <para>
        /// Specify a linear mapping of 
        /// v   ,
        /// as presented to  <see cref="glEvalCoord2"/> ,
        /// to 
        /// v  &Hat;  
        /// ,
        /// one of the two variables that are evaluated by the equations specified
        /// by this command. Initially, <paramref name="v1"/> is 0 and <paramref name="v2"/> is 1.
        /// </para>
        /// </param>
        /// <param name="vstride">
        /// <para>
        /// Specifies the number of floats or doubles between
        /// the beginning of control point
        /// R 
        /// ij 
        /// and the beginning of control point
        /// R 
        /// i 
        /// &af; 
        /// j 
        /// + 
        /// 1 
        /// ,
        /// where 
        /// i   
        /// and 
        /// j   
        /// are the 
        /// u   
        /// and 
        /// v   
        /// control point indices, respectively.
        /// This allows control points to be embedded in arbitrary data structures.
        /// The only constraint is that the values for a particular control point
        /// must occupy contiguous memory locations. The initial value of <paramref name="vstride"/> is 0.
        /// </para>
        /// </param>
        /// <param name="vorder">
        /// <para>
        /// Specifies the dimension of the control point array in the 
        /// v   
        /// axis.
        /// Must be positive. The initial value is 1.
        /// </para>
        /// </param>
        /// <param name="points">
        /// Specifies a pointer to the array of control points.
        /// </param>
        /// <seealso cref="Begin"/>
        /// <seealso cref="Color"/>
        /// <seealso cref="Enable"/>
        /// <seealso cref="EvalCoord"/>
        /// <seealso cref="EvalMesh"/>
        /// <seealso cref="EvalPoint"/>
        /// <seealso cref="Map1"/>
        /// <seealso cref="MapGrid"/>
        /// <seealso cref="Normal"/>
        /// <seealso cref="TexCoord"/>
        /// <seealso cref="Vertex"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void Map2f(uint target, float u1, float u2, int ustride, int uorder, float v1, float v2, int vstride, int vorder, ref float points) {
            fixed (float* pPoints = &points) {
                GLNative.glMap2f(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, pPoints);
            }
        }

        /// <summary>
        /// evaluate enabled one- and two-dimensional maps
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glEvalCoord1dv(const GLdouble * u);</para>
        /// </summary>
        /// <param name="u">
        /// <para>
        /// Specifies a pointer to an array containing
        /// either one or two domain coordinates.
        /// The first coordinate is 
        /// u   .
        /// The second coordinate is 
        /// v   ,
        /// which is present only in <see cref="glEvalCoord2"/> versions.
        /// </para>
        /// </param>
        /// <seealso cref="Begin"/>
        /// <seealso cref="Color"/>
        /// <seealso cref="Enable"/>
        /// <seealso cref="EvalMesh"/>
        /// <seealso cref="EvalPoint"/>
        /// <seealso cref="Index"/>
        /// <seealso cref="Map1"/>
        /// <seealso cref="Map2"/>
        /// <seealso cref="MapGrid"/>
        /// <seealso cref="Normal"/>
        /// <seealso cref="TexCoord"/>
        /// <seealso cref="Vertex"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void EvalCoord1dv(ref double u) {
            fixed (double* pU = &u) {
                GLNative.glEvalCoord1dv(pU);
            }
        }

        /// <summary>
        /// evaluate enabled one- and two-dimensional maps
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glEvalCoord1fv(const GLfloat * u);</para>
        /// </summary>
        /// <param name="u">
        /// <para>
        /// Specifies a pointer to an array containing
        /// either one or two domain coordinates.
        /// The first coordinate is 
        /// u   .
        /// The second coordinate is 
        /// v   ,
        /// which is present only in <see cref="glEvalCoord2"/> versions.
        /// </para>
        /// </param>
        /// <seealso cref="Begin"/>
        /// <seealso cref="Color"/>
        /// <seealso cref="Enable"/>
        /// <seealso cref="EvalMesh"/>
        /// <seealso cref="EvalPoint"/>
        /// <seealso cref="Index"/>
        /// <seealso cref="Map1"/>
        /// <seealso cref="Map2"/>
        /// <seealso cref="MapGrid"/>
        /// <seealso cref="Normal"/>
        /// <seealso cref="TexCoord"/>
        /// <seealso cref="Vertex"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void EvalCoord1fv(ref float u) {
            fixed (float* pU = &u) {
                GLNative.glEvalCoord1fv(pU);
            }
        }

        /// <summary>
        /// evaluate enabled one- and two-dimensional maps
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glEvalCoord2dv(const GLdouble * u);</para>
        /// </summary>
        /// <param name="u">
        /// <para>
        /// Specifies a pointer to an array containing
        /// either one or two domain coordinates.
        /// The first coordinate is 
        /// u   .
        /// The second coordinate is 
        /// v   ,
        /// which is present only in <see cref="glEvalCoord2"/> versions.
        /// </para>
        /// </param>
        /// <seealso cref="Begin"/>
        /// <seealso cref="Color"/>
        /// <seealso cref="Enable"/>
        /// <seealso cref="EvalMesh"/>
        /// <seealso cref="EvalPoint"/>
        /// <seealso cref="Index"/>
        /// <seealso cref="Map1"/>
        /// <seealso cref="Map2"/>
        /// <seealso cref="MapGrid"/>
        /// <seealso cref="Normal"/>
        /// <seealso cref="TexCoord"/>
        /// <seealso cref="Vertex"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void EvalCoord2dv(ref double u) {
            fixed (double* pU = &u) {
                GLNative.glEvalCoord2dv(pU);
            }
        }

        /// <summary>
        /// evaluate enabled one- and two-dimensional maps
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glEvalCoord2fv(const GLfloat * u);</para>
        /// </summary>
        /// <param name="u">
        /// <para>
        /// Specifies a pointer to an array containing
        /// either one or two domain coordinates.
        /// The first coordinate is 
        /// u   .
        /// The second coordinate is 
        /// v   ,
        /// which is present only in <see cref="glEvalCoord2"/> versions.
        /// </para>
        /// </param>
        /// <seealso cref="Begin"/>
        /// <seealso cref="Color"/>
        /// <seealso cref="Enable"/>
        /// <seealso cref="EvalMesh"/>
        /// <seealso cref="EvalPoint"/>
        /// <seealso cref="Index"/>
        /// <seealso cref="Map1"/>
        /// <seealso cref="Map2"/>
        /// <seealso cref="MapGrid"/>
        /// <seealso cref="Normal"/>
        /// <seealso cref="TexCoord"/>
        /// <seealso cref="Vertex"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void EvalCoord2fv(ref float u) {
            fixed (float* pU = &u) {
                GLNative.glEvalCoord2fv(pU);
            }
        }

        /// <summary>
        /// set up pixel transfer maps
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="map"/> is not an accepted value.
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="mapsize"/> is less than one
        /// or larger than <code>GL_MAX_PIXEL_MAP_TABLE</code>.
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="map"/> is
        /// <code>GL_PIXEL_MAP_I_TO_I</code>,
        /// <code>GL_PIXEL_MAP_S_TO_S</code>,
        /// <code>GL_PIXEL_MAP_I_TO_R</code>,
        /// <code>GL_PIXEL_MAP_I_TO_G</code>,
        /// <code>GL_PIXEL_MAP_I_TO_B</code>, or
        /// <code>GL_PIXEL_MAP_I_TO_A</code>,
        /// and <paramref name="mapsize"/> is not a power of two.
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_UNPACK_BUFFER</code> target and the buffer object's data store is currently mapped.
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_UNPACK_BUFFER</code> target and the data would be unpacked from the buffer 
        /// object such that the memory reads required would exceed the data store size.
        /// <code>GL_INVALID_OPERATION</code> is generated by <see cref="glPixelMapfv"/> if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_UNPACK_BUFFER</code> target and <paramref name="values"/> is not evenly divisible 
        /// into the number of bytes needed to store in memory a GLfloat datum.
        /// <code>GL_INVALID_OPERATION</code> is generated by <see cref="glPixelMapuiv"/> if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_UNPACK_BUFFER</code> target and <paramref name="values"/> is not evenly divisible 
        /// into the number of bytes needed to store in memory a GLuint datum.
        /// <code>GL_INVALID_OPERATION</code> is generated by <see cref="glPixelMapusv"/> if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_UNPACK_BUFFER</code> target and <paramref name="values"/> is not evenly divisible 
        /// into the number of bytes needed to store in memory a GLushort datum.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glPixelMap"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glPixelMapfv(GLenum map, GLsizei mapsize, const GLfloat * values);</para>
        /// </summary>
        /// <param name="map">
        /// <para>
        /// Specifies a symbolic map name.
        /// Must be one of the following:
        /// <code>GL_PIXEL_MAP_I_TO_I</code>,
        /// <code>GL_PIXEL_MAP_S_TO_S</code>,
        /// <code>GL_PIXEL_MAP_I_TO_R</code>,
        /// <code>GL_PIXEL_MAP_I_TO_G</code>,
        /// <code>GL_PIXEL_MAP_I_TO_B</code>,
        /// <code>GL_PIXEL_MAP_I_TO_A</code>,
        /// <code>GL_PIXEL_MAP_R_TO_R</code>,
        /// <code>GL_PIXEL_MAP_G_TO_G</code>,
        /// <code>GL_PIXEL_MAP_B_TO_B</code>, or
        /// <code>GL_PIXEL_MAP_A_TO_A</code>.
        /// </para>
        /// </param>
        /// <param name="mapsize">
        /// Specifies the size of the map being defined.
        /// </param>
        /// <param name="values">
        /// Specifies an array of <paramref name="mapsize"/> values.
        /// </param>
        /// <seealso cref="ColorTable"/>
        /// <seealso cref="ColorSubTable"/>
        /// <seealso cref="ConvolutionFilter1D"/>
        /// <seealso cref="ConvolutionFilter2D"/>
        /// <seealso cref="CopyPixels"/>
        /// <seealso cref="CopyTexImage1D"/>
        /// <seealso cref="CopyTexImage2D"/>
        /// <seealso cref="CopyTexSubImage1D"/>
        /// <seealso cref="CopyTexSubImage2D"/>
        /// <seealso cref="DrawPixels"/>
        /// <seealso cref="Histogram"/>
        /// <seealso cref="Minmax"/>
        /// <seealso cref="PixelStore"/>
        /// <seealso cref="PixelTransfer"/>
        /// <seealso cref="ReadPixels"/>
        /// <seealso cref="SeparableFilter2D"/>
        /// <seealso cref="TexImage1D"/>
        /// <seealso cref="TexImage2D"/>
        /// <seealso cref="TexImage3D"/>
        /// <seealso cref="TexSubImage1D"/>
        /// <seealso cref="TexSubImage2D"/>
        /// <seealso cref="TexSubImage3D"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void PixelMapfv(uint map, int mapsize, ref float values) {
            fixed (float* pValues = &values) {
                GLNative.glPixelMapfv(map, mapsize, pValues);
            }
        }

        /// <summary>
        /// set up pixel transfer maps
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="map"/> is not an accepted value.
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="mapsize"/> is less than one
        /// or larger than <code>GL_MAX_PIXEL_MAP_TABLE</code>.
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="map"/> is
        /// <code>GL_PIXEL_MAP_I_TO_I</code>,
        /// <code>GL_PIXEL_MAP_S_TO_S</code>,
        /// <code>GL_PIXEL_MAP_I_TO_R</code>,
        /// <code>GL_PIXEL_MAP_I_TO_G</code>,
        /// <code>GL_PIXEL_MAP_I_TO_B</code>, or
        /// <code>GL_PIXEL_MAP_I_TO_A</code>,
        /// and <paramref name="mapsize"/> is not a power of two.
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_UNPACK_BUFFER</code> target and the buffer object's data store is currently mapped.
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_UNPACK_BUFFER</code> target and the data would be unpacked from the buffer 
        /// object such that the memory reads required would exceed the data store size.
        /// <code>GL_INVALID_OPERATION</code> is generated by <see cref="glPixelMapfv"/> if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_UNPACK_BUFFER</code> target and <paramref name="values"/> is not evenly divisible 
        /// into the number of bytes needed to store in memory a GLfloat datum.
        /// <code>GL_INVALID_OPERATION</code> is generated by <see cref="glPixelMapuiv"/> if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_UNPACK_BUFFER</code> target and <paramref name="values"/> is not evenly divisible 
        /// into the number of bytes needed to store in memory a GLuint datum.
        /// <code>GL_INVALID_OPERATION</code> is generated by <see cref="glPixelMapusv"/> if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_UNPACK_BUFFER</code> target and <paramref name="values"/> is not evenly divisible 
        /// into the number of bytes needed to store in memory a GLushort datum.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glPixelMap"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glPixelMapuiv(GLenum map, GLsizei mapsize, const GLuint * values);</para>
        /// </summary>
        /// <param name="map">
        /// <para>
        /// Specifies a symbolic map name.
        /// Must be one of the following:
        /// <code>GL_PIXEL_MAP_I_TO_I</code>,
        /// <code>GL_PIXEL_MAP_S_TO_S</code>,
        /// <code>GL_PIXEL_MAP_I_TO_R</code>,
        /// <code>GL_PIXEL_MAP_I_TO_G</code>,
        /// <code>GL_PIXEL_MAP_I_TO_B</code>,
        /// <code>GL_PIXEL_MAP_I_TO_A</code>,
        /// <code>GL_PIXEL_MAP_R_TO_R</code>,
        /// <code>GL_PIXEL_MAP_G_TO_G</code>,
        /// <code>GL_PIXEL_MAP_B_TO_B</code>, or
        /// <code>GL_PIXEL_MAP_A_TO_A</code>.
        /// </para>
        /// </param>
        /// <param name="mapsize">
        /// Specifies the size of the map being defined.
        /// </param>
        /// <param name="values">
        /// Specifies an array of <paramref name="mapsize"/> values.
        /// </param>
        /// <seealso cref="ColorTable"/>
        /// <seealso cref="ColorSubTable"/>
        /// <seealso cref="ConvolutionFilter1D"/>
        /// <seealso cref="ConvolutionFilter2D"/>
        /// <seealso cref="CopyPixels"/>
        /// <seealso cref="CopyTexImage1D"/>
        /// <seealso cref="CopyTexImage2D"/>
        /// <seealso cref="CopyTexSubImage1D"/>
        /// <seealso cref="CopyTexSubImage2D"/>
        /// <seealso cref="DrawPixels"/>
        /// <seealso cref="Histogram"/>
        /// <seealso cref="Minmax"/>
        /// <seealso cref="PixelStore"/>
        /// <seealso cref="PixelTransfer"/>
        /// <seealso cref="ReadPixels"/>
        /// <seealso cref="SeparableFilter2D"/>
        /// <seealso cref="TexImage1D"/>
        /// <seealso cref="TexImage2D"/>
        /// <seealso cref="TexImage3D"/>
        /// <seealso cref="TexSubImage1D"/>
        /// <seealso cref="TexSubImage2D"/>
        /// <seealso cref="TexSubImage3D"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void PixelMapuiv(uint map, int mapsize, ref uint values) {
            fixed (uint* pValues = &values) {
                GLNative.glPixelMapuiv(map, mapsize, pValues);
            }
        }

        /// <summary>
        /// set up pixel transfer maps
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="map"/> is not an accepted value.
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="mapsize"/> is less than one
        /// or larger than <code>GL_MAX_PIXEL_MAP_TABLE</code>.
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="map"/> is
        /// <code>GL_PIXEL_MAP_I_TO_I</code>,
        /// <code>GL_PIXEL_MAP_S_TO_S</code>,
        /// <code>GL_PIXEL_MAP_I_TO_R</code>,
        /// <code>GL_PIXEL_MAP_I_TO_G</code>,
        /// <code>GL_PIXEL_MAP_I_TO_B</code>, or
        /// <code>GL_PIXEL_MAP_I_TO_A</code>,
        /// and <paramref name="mapsize"/> is not a power of two.
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_UNPACK_BUFFER</code> target and the buffer object's data store is currently mapped.
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_UNPACK_BUFFER</code> target and the data would be unpacked from the buffer 
        /// object such that the memory reads required would exceed the data store size.
        /// <code>GL_INVALID_OPERATION</code> is generated by <see cref="glPixelMapfv"/> if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_UNPACK_BUFFER</code> target and <paramref name="values"/> is not evenly divisible 
        /// into the number of bytes needed to store in memory a GLfloat datum.
        /// <code>GL_INVALID_OPERATION</code> is generated by <see cref="glPixelMapuiv"/> if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_UNPACK_BUFFER</code> target and <paramref name="values"/> is not evenly divisible 
        /// into the number of bytes needed to store in memory a GLuint datum.
        /// <code>GL_INVALID_OPERATION</code> is generated by <see cref="glPixelMapusv"/> if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_UNPACK_BUFFER</code> target and <paramref name="values"/> is not evenly divisible 
        /// into the number of bytes needed to store in memory a GLushort datum.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glPixelMap"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glPixelMapusv(GLenum map, GLsizei mapsize, const GLushort * values);</para>
        /// </summary>
        /// <param name="map">
        /// <para>
        /// Specifies a symbolic map name.
        /// Must be one of the following:
        /// <code>GL_PIXEL_MAP_I_TO_I</code>,
        /// <code>GL_PIXEL_MAP_S_TO_S</code>,
        /// <code>GL_PIXEL_MAP_I_TO_R</code>,
        /// <code>GL_PIXEL_MAP_I_TO_G</code>,
        /// <code>GL_PIXEL_MAP_I_TO_B</code>,
        /// <code>GL_PIXEL_MAP_I_TO_A</code>,
        /// <code>GL_PIXEL_MAP_R_TO_R</code>,
        /// <code>GL_PIXEL_MAP_G_TO_G</code>,
        /// <code>GL_PIXEL_MAP_B_TO_B</code>, or
        /// <code>GL_PIXEL_MAP_A_TO_A</code>.
        /// </para>
        /// </param>
        /// <param name="mapsize">
        /// Specifies the size of the map being defined.
        /// </param>
        /// <param name="values">
        /// Specifies an array of <paramref name="mapsize"/> values.
        /// </param>
        /// <seealso cref="ColorTable"/>
        /// <seealso cref="ColorSubTable"/>
        /// <seealso cref="ConvolutionFilter1D"/>
        /// <seealso cref="ConvolutionFilter2D"/>
        /// <seealso cref="CopyPixels"/>
        /// <seealso cref="CopyTexImage1D"/>
        /// <seealso cref="CopyTexImage2D"/>
        /// <seealso cref="CopyTexSubImage1D"/>
        /// <seealso cref="CopyTexSubImage2D"/>
        /// <seealso cref="DrawPixels"/>
        /// <seealso cref="Histogram"/>
        /// <seealso cref="Minmax"/>
        /// <seealso cref="PixelStore"/>
        /// <seealso cref="PixelTransfer"/>
        /// <seealso cref="ReadPixels"/>
        /// <seealso cref="SeparableFilter2D"/>
        /// <seealso cref="TexImage1D"/>
        /// <seealso cref="TexImage2D"/>
        /// <seealso cref="TexImage3D"/>
        /// <seealso cref="TexSubImage1D"/>
        /// <seealso cref="TexSubImage2D"/>
        /// <seealso cref="TexSubImage3D"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void PixelMapusv(uint map, int mapsize, ref ushort values) {
            fixed (ushort* pValues = &values) {
                GLNative.glPixelMapusv(map, mapsize, pValues);
            }
        }

        /// <summary>
        /// write a block of pixels to the frame buffer
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <code>GL_BGR</code> and <code>GL_BGRA</code> are only valid for <paramref name="format"/> if the GL
        /// version is 1.2 or greater.
        /// <code>GL_UNSIGNED_BYTE_3_3_2</code>,
        /// <code>GL_UNSIGNED_BYTE_2_3_3_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_5_6_5</code>,
        /// <code>GL_UNSIGNED_SHORT_5_6_5_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_4_4_4_4</code>,
        /// <code>GL_UNSIGNED_SHORT_4_4_4_4_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_5_5_5_1</code>,
        /// <code>GL_UNSIGNED_SHORT_1_5_5_5_REV</code>,
        /// <code>GL_UNSIGNED_INT_8_8_8_8</code>,
        /// <code>GL_UNSIGNED_INT_8_8_8_8_REV</code>,
        /// <code>GL_UNSIGNED_INT_10_10_10_2</code>, and
        /// <code>GL_UNSIGNED_INT_2_10_10_10_REV</code> are only valid for <paramref name="type"/> if the
        /// GL version is 1.2 or greater.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="format"/> or <paramref name="type"/> is not one of
        /// the accepted values.
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="type"/> is <code>GL_BITMAP</code> and
        /// <paramref name="format"/> is not either <code>GL_COLOR_INDEX</code> or <code>GL_STENCIL_INDEX</code>.
        /// <code>GL_INVALID_VALUE</code> is generated if either <paramref name="width"/> or <paramref name="height"/> is negative.
        /// <code>GL_INVALID_OPERATION</code> is generated if <paramref name="format"/> is <code>GL_STENCIL_INDEX</code>
        /// and there is no stencil buffer.
        /// <code>GL_INVALID_OPERATION</code> is generated if <paramref name="format"/> is
        /// <code>GL_RED</code>,
        /// <code>GL_GREEN</code>,
        /// <code>GL_BLUE</code>,
        /// <code>GL_ALPHA</code>,
        /// <code>GL_RGB</code>,
        /// <code>GL_RGBA</code>,
        /// <code>GL_BGR</code>,
        /// <code>GL_BGRA</code>,
        /// <code>GL_LUMINANCE</code>,
        /// or
        /// <code>GL_LUMINANCE_ALPHA</code>,
        /// and the GL is in color index mode.
        /// <code>GL_INVALID_OPERATION</code> is generated if <paramref name="format"/> is one of
        /// <code>GL_UNSIGNED_BYTE_3_3_2</code>,
        /// <code>GL_UNSIGNED_BYTE_2_3_3_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_5_6_5</code>, or
        /// <code>GL_UNSIGNED_SHORT_5_6_5_REV</code>
        /// and <paramref name="format"/> is not <code>GL_RGB</code>.
        /// <code>GL_INVALID_OPERATION</code> is generated if <paramref name="format"/> is one of
        /// <code>GL_UNSIGNED_SHORT_4_4_4_4</code>,
        /// <code>GL_UNSIGNED_SHORT_4_4_4_4_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_5_5_5_1</code>,
        /// <code>GL_UNSIGNED_SHORT_1_5_5_5_REV</code>,
        /// <code>GL_UNSIGNED_INT_8_8_8_8</code>,
        /// <code>GL_UNSIGNED_INT_8_8_8_8_REV</code>,
        /// <code>GL_UNSIGNED_INT_10_10_10_2</code>, or
        /// <code>GL_UNSIGNED_INT_2_10_10_10_REV</code>
        /// and <paramref name="format"/> is neither <code>GL_RGBA</code> nor <code>GL_BGRA</code>.
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_UNPACK_BUFFER</code> target and the buffer object's data store is currently mapped.
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_UNPACK_BUFFER</code> target and the data would be unpacked from the buffer 
        /// object such that the memory reads required would exceed the data store size.
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_UNPACK_BUFFER</code> target and <paramref name="data"/> is not evenly divisible 
        /// into the number of bytes needed to store in memory a datum indicated by <paramref name="type"/>.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glDrawPixels"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glDrawPixels(GLsizei width, GLsizei height, GLenum format, GLenum type, const void * data);</para>
        /// </summary>
        /// <param name="width">
        /// <para>
        /// Specify the dimensions of the pixel rectangle to be written
        /// into the frame buffer.
        /// </para>
        /// </param>
        /// <param name="height">
        /// <para>
        /// Specify the dimensions of the pixel rectangle to be written
        /// into the frame buffer.
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// Specifies the format of the pixel data.
        /// Symbolic constants
        /// <code>GL_COLOR_INDEX</code>,
        /// <code>GL_STENCIL_INDEX</code>,
        /// <code>GL_DEPTH_COMPONENT</code>,
        /// <code>GL_RGB</code>,
        /// <code>GL_BGR</code>,
        /// <code>GL_RGBA</code>,
        /// <code>GL_BGRA</code>,
        /// <code>GL_RED</code>,
        /// <code>GL_GREEN</code>,
        /// <code>GL_BLUE</code>,
        /// <code>GL_ALPHA</code>,
        /// <code>GL_LUMINANCE</code>, and
        /// <code>GL_LUMINANCE_ALPHA</code> are accepted.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the data type for <paramref name="data"/>.
        /// Symbolic constants
        /// <code>GL_UNSIGNED_BYTE</code>,
        /// <code>GL_BYTE</code>,
        /// <code>GL_BITMAP</code>,
        /// <code>GL_UNSIGNED_SHORT</code>,
        /// <code>GL_SHORT</code>,
        /// <code>GL_UNSIGNED_INT</code>,
        /// <code>GL_INT</code>,
        /// <code>GL_FLOAT</code>,
        /// <code>GL_UNSIGNED_BYTE_3_3_2</code>,
        /// <code>GL_UNSIGNED_BYTE_2_3_3_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_5_6_5</code>,
        /// <code>GL_UNSIGNED_SHORT_5_6_5_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_4_4_4_4</code>,
        /// <code>GL_UNSIGNED_SHORT_4_4_4_4_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_5_5_5_1</code>,
        /// <code>GL_UNSIGNED_SHORT_1_5_5_5_REV</code>,
        /// <code>GL_UNSIGNED_INT_8_8_8_8</code>,
        /// <code>GL_UNSIGNED_INT_8_8_8_8_REV</code>,
        /// <code>GL_UNSIGNED_INT_10_10_10_2</code>, and
        /// <code>GL_UNSIGNED_INT_2_10_10_10_REV</code>
        /// are accepted.
        /// </para>
        /// </param>
        /// <param name="data">
        /// Specifies a pointer to the pixel data.
        /// </param>
        /// <seealso cref="AlphaFunc"/>
        /// <seealso cref="BlendFunc"/>
        /// <seealso cref="CopyPixels"/>
        /// <seealso cref="DepthFunc"/>
        /// <seealso cref="LogicOp"/>
        /// <seealso cref="PixelMap"/>
        /// <seealso cref="PixelStore"/>
        /// <seealso cref="PixelTransfer"/>
        /// <seealso cref="PixelZoom"/>
        /// <seealso cref="RasterPos"/>
        /// <seealso cref="ReadPixels"/>
        /// <seealso cref="Scissor"/>
        /// <seealso cref="StencilFunc"/>
        /// <seealso cref="WindowPos"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void DrawPixels(int width, int height, uint format, uint type, IntPtr data) {
            GLNative.glDrawPixels(width, height, format, type, (void*)data);
        }

        /// <summary>
        /// return the coefficients of the specified clipping plane
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// It is always the case that <code>GL_CLIP_PLANE</code>
        /// i   
        /// = <code>GL_CLIP_PLANE0</code> + 
        /// i   .
        /// If an error is generated,
        /// no change is made to the contents of <paramref name="equation"/>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="plane"/> is not an accepted value.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glGetClipPlane"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glGetClipPlane(GLenum plane, GLdouble * equation);</para>
        /// </summary>
        /// <param name="plane">
        /// <para>
        /// Specifies a clipping plane.
        /// The number of clipping planes depends on the implementation,
        /// but at least six clipping planes are supported.
        /// They are identified by symbolic names of the form <code>GL_CLIP_PLANE</code>
        /// i   
        /// where i ranges from 0 to the value of <code>GL_MAX_CLIP_PLANES</code> - 1.
        /// </para>
        /// </param>
        /// <param name="equation">
        /// <para>
        /// Returns four double-precision values that are the coefficients of the plane equation of <paramref name="plane"/> in eye coordinates.
        /// The initial value is (0, 0, 0, 0).
        /// </para>
        /// </param>
        /// <seealso cref="ClipPlane"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void GetClipPlane(uint plane, ref double equation) {
            fixed (double* pEquation = &equation) {
                GLNative.glGetClipPlane(plane, pEquation);
            }
        }

        /// <summary>
        /// return light source parameter values
        /// <para>Require:</para> <para>GL_VERSION_1_0, GL_VERSION_ES_CM_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// It is always the case that <code>GL_LIGHT</code>
        /// i   
        /// = <code>GL_LIGHT0</code> + 
        /// i   .
        /// If an error is generated,
        /// no change is made to the contents of <paramref name="ps"/>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="light"/> or <paramref name="pname"/> is not an
        /// accepted value.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glGetLight"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glGetLightfv(GLenum light, GLenum pname, GLfloat * params);</para>
        /// </summary>
        /// <param name="light">
        /// <para>
        /// Specifies a light source.
        /// The number of possible lights depends on the implementation,
        /// but at least eight lights are supported.
        /// They are identified by symbolic names of the form <code>GL_LIGHT</code>
        /// i   
        /// where 
        /// i   
        /// ranges from 0 to the value of <code>GL_MAX_LIGHTS</code> - 1.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies a light source parameter for <paramref name="light"/>.
        /// Accepted symbolic names are
        /// <code>GL_AMBIENT</code>,
        /// <code>GL_DIFFUSE</code>,
        /// <code>GL_SPECULAR</code>,
        /// <code>GL_POSITION</code>,
        /// <code>GL_SPOT_DIRECTION</code>,
        /// <code>GL_SPOT_EXPONENT</code>,
        /// <code>GL_SPOT_CUTOFF</code>,
        /// <code>GL_CONSTANT_ATTENUATION</code>,
        /// <code>GL_LINEAR_ATTENUATION</code>, and
        /// <code>GL_QUADRATIC_ATTENUATION</code>.
        /// </para>
        /// </param>
        /// <param name="ps">
        /// Returns the requested data.
        /// </param>
        /// <seealso cref="Light"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void GetLightfv(uint light, uint pname, ref float ps) {
            fixed (float* pPs = &ps) {
                GLNative.glGetLightfv(light, pname, pPs);
            }
        }

        /// <summary>
        /// return light source parameter values
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// It is always the case that <code>GL_LIGHT</code>
        /// i   
        /// = <code>GL_LIGHT0</code> + 
        /// i   .
        /// If an error is generated,
        /// no change is made to the contents of <paramref name="ps"/>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="light"/> or <paramref name="pname"/> is not an
        /// accepted value.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glGetLight"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glGetLightiv(GLenum light, GLenum pname, GLint * params);</para>
        /// </summary>
        /// <param name="light">
        /// <para>
        /// Specifies a light source.
        /// The number of possible lights depends on the implementation,
        /// but at least eight lights are supported.
        /// They are identified by symbolic names of the form <code>GL_LIGHT</code>
        /// i   
        /// where 
        /// i   
        /// ranges from 0 to the value of <code>GL_MAX_LIGHTS</code> - 1.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies a light source parameter for <paramref name="light"/>.
        /// Accepted symbolic names are
        /// <code>GL_AMBIENT</code>,
        /// <code>GL_DIFFUSE</code>,
        /// <code>GL_SPECULAR</code>,
        /// <code>GL_POSITION</code>,
        /// <code>GL_SPOT_DIRECTION</code>,
        /// <code>GL_SPOT_EXPONENT</code>,
        /// <code>GL_SPOT_CUTOFF</code>,
        /// <code>GL_CONSTANT_ATTENUATION</code>,
        /// <code>GL_LINEAR_ATTENUATION</code>, and
        /// <code>GL_QUADRATIC_ATTENUATION</code>.
        /// </para>
        /// </param>
        /// <param name="ps">
        /// Returns the requested data.
        /// </param>
        /// <seealso cref="Light"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void GetLightiv(uint light, uint pname, ref int ps) {
            fixed (int* pPs = &ps) {
                GLNative.glGetLightiv(light, pname, pPs);
            }
        }

        /// <summary>
        /// return evaluator parameters
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// If an error is generated,
        /// no change is made to the contents of <paramref name="v"/>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if either <paramref name="target"/> or <paramref name="query"/> is not
        /// an accepted value.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glGetMap"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glGetMapdv(GLenum target, GLenum query, GLdouble * v);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the symbolic name of a map.
        /// Accepted values are
        /// <code>GL_MAP1_COLOR_4</code>,
        /// <code>GL_MAP1_INDEX</code>,
        /// <code>GL_MAP1_NORMAL</code>,
        /// <code>GL_MAP1_TEXTURE_COORD_1</code>,
        /// <code>GL_MAP1_TEXTURE_COORD_2</code>,
        /// <code>GL_MAP1_TEXTURE_COORD_3</code>,
        /// <code>GL_MAP1_TEXTURE_COORD_4</code>,
        /// <code>GL_MAP1_VERTEX_3</code>,
        /// <code>GL_MAP1_VERTEX_4</code>,
        /// <code>GL_MAP2_COLOR_4</code>,
        /// <code>GL_MAP2_INDEX</code>,
        /// <code>GL_MAP2_NORMAL</code>,
        /// <code>GL_MAP2_TEXTURE_COORD_1</code>,
        /// <code>GL_MAP2_TEXTURE_COORD_2</code>,
        /// <code>GL_MAP2_TEXTURE_COORD_3</code>,
        /// <code>GL_MAP2_TEXTURE_COORD_4</code>,
        /// <code>GL_MAP2_VERTEX_3</code>, and
        /// <code>GL_MAP2_VERTEX_4</code>.
        /// </para>
        /// </param>
        /// <param name="query">
        /// <para>
        /// Specifies which parameter to return.
        /// Symbolic names
        /// <code>GL_COEFF</code>,
        /// <code>GL_ORDER</code>, and
        /// <code>GL_DOMAIN</code> are accepted.
        /// </para>
        /// </param>
        /// <param name="v">
        /// Returns the requested data.
        /// </param>
        /// <seealso cref="EvalCoord"/>
        /// <seealso cref="Map1"/>
        /// <seealso cref="Map2"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void GetMapdv(uint target, uint query, ref double v) {
            fixed (double* pV = &v) {
                GLNative.glGetMapdv(target, query, pV);
            }
        }

        /// <summary>
        /// return evaluator parameters
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// If an error is generated,
        /// no change is made to the contents of <paramref name="v"/>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if either <paramref name="target"/> or <paramref name="query"/> is not
        /// an accepted value.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glGetMap"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glGetMapfv(GLenum target, GLenum query, GLfloat * v);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the symbolic name of a map.
        /// Accepted values are
        /// <code>GL_MAP1_COLOR_4</code>,
        /// <code>GL_MAP1_INDEX</code>,
        /// <code>GL_MAP1_NORMAL</code>,
        /// <code>GL_MAP1_TEXTURE_COORD_1</code>,
        /// <code>GL_MAP1_TEXTURE_COORD_2</code>,
        /// <code>GL_MAP1_TEXTURE_COORD_3</code>,
        /// <code>GL_MAP1_TEXTURE_COORD_4</code>,
        /// <code>GL_MAP1_VERTEX_3</code>,
        /// <code>GL_MAP1_VERTEX_4</code>,
        /// <code>GL_MAP2_COLOR_4</code>,
        /// <code>GL_MAP2_INDEX</code>,
        /// <code>GL_MAP2_NORMAL</code>,
        /// <code>GL_MAP2_TEXTURE_COORD_1</code>,
        /// <code>GL_MAP2_TEXTURE_COORD_2</code>,
        /// <code>GL_MAP2_TEXTURE_COORD_3</code>,
        /// <code>GL_MAP2_TEXTURE_COORD_4</code>,
        /// <code>GL_MAP2_VERTEX_3</code>, and
        /// <code>GL_MAP2_VERTEX_4</code>.
        /// </para>
        /// </param>
        /// <param name="query">
        /// <para>
        /// Specifies which parameter to return.
        /// Symbolic names
        /// <code>GL_COEFF</code>,
        /// <code>GL_ORDER</code>, and
        /// <code>GL_DOMAIN</code> are accepted.
        /// </para>
        /// </param>
        /// <param name="v">
        /// Returns the requested data.
        /// </param>
        /// <seealso cref="EvalCoord"/>
        /// <seealso cref="Map1"/>
        /// <seealso cref="Map2"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void GetMapfv(uint target, uint query, ref float v) {
            fixed (float* pV = &v) {
                GLNative.glGetMapfv(target, query, pV);
            }
        }

        /// <summary>
        /// return evaluator parameters
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// If an error is generated,
        /// no change is made to the contents of <paramref name="v"/>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if either <paramref name="target"/> or <paramref name="query"/> is not
        /// an accepted value.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glGetMap"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glGetMapiv(GLenum target, GLenum query, GLint * v);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the symbolic name of a map.
        /// Accepted values are
        /// <code>GL_MAP1_COLOR_4</code>,
        /// <code>GL_MAP1_INDEX</code>,
        /// <code>GL_MAP1_NORMAL</code>,
        /// <code>GL_MAP1_TEXTURE_COORD_1</code>,
        /// <code>GL_MAP1_TEXTURE_COORD_2</code>,
        /// <code>GL_MAP1_TEXTURE_COORD_3</code>,
        /// <code>GL_MAP1_TEXTURE_COORD_4</code>,
        /// <code>GL_MAP1_VERTEX_3</code>,
        /// <code>GL_MAP1_VERTEX_4</code>,
        /// <code>GL_MAP2_COLOR_4</code>,
        /// <code>GL_MAP2_INDEX</code>,
        /// <code>GL_MAP2_NORMAL</code>,
        /// <code>GL_MAP2_TEXTURE_COORD_1</code>,
        /// <code>GL_MAP2_TEXTURE_COORD_2</code>,
        /// <code>GL_MAP2_TEXTURE_COORD_3</code>,
        /// <code>GL_MAP2_TEXTURE_COORD_4</code>,
        /// <code>GL_MAP2_VERTEX_3</code>, and
        /// <code>GL_MAP2_VERTEX_4</code>.
        /// </para>
        /// </param>
        /// <param name="query">
        /// <para>
        /// Specifies which parameter to return.
        /// Symbolic names
        /// <code>GL_COEFF</code>,
        /// <code>GL_ORDER</code>, and
        /// <code>GL_DOMAIN</code> are accepted.
        /// </para>
        /// </param>
        /// <param name="v">
        /// Returns the requested data.
        /// </param>
        /// <seealso cref="EvalCoord"/>
        /// <seealso cref="Map1"/>
        /// <seealso cref="Map2"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void GetMapiv(uint target, uint query, ref int v) {
            fixed (int* pV = &v) {
                GLNative.glGetMapiv(target, query, pV);
            }
        }

        /// <summary>
        /// return material parameters
        /// <para>Require:</para> <para>GL_VERSION_1_0, GL_VERSION_ES_CM_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// If an error is generated,
        /// no change is made to the contents of <paramref name="ps"/>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="face"/> or <paramref name="pname"/> is not an
        /// accepted value.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glGetMaterial"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glGetMaterialfv(GLenum face, GLenum pname, GLfloat * params);</para>
        /// </summary>
        /// <param name="face">
        /// <para>
        /// Specifies which of the two materials is being queried.
        /// <code>GL_FRONT</code> or <code>GL_BACK</code> are accepted,
        /// representing the front and back materials,
        /// respectively.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the material parameter to return.
        /// <code>GL_AMBIENT</code>,
        /// <code>GL_DIFFUSE</code>,
        /// <code>GL_SPECULAR</code>,
        /// <code>GL_EMISSION</code>,
        /// <code>GL_SHININESS</code>, and
        /// <code>GL_COLOR_INDEXES</code>
        /// are accepted.
        /// </para>
        /// </param>
        /// <param name="ps">
        /// Returns the requested data.
        /// </param>
        /// <seealso cref="Material"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void GetMaterialfv(uint face, uint pname, ref float ps) {
            fixed (float* pPs = &ps) {
                GLNative.glGetMaterialfv(face, pname, pPs);
            }
        }

        /// <summary>
        /// return material parameters
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// If an error is generated,
        /// no change is made to the contents of <paramref name="ps"/>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="face"/> or <paramref name="pname"/> is not an
        /// accepted value.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glGetMaterial"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glGetMaterialiv(GLenum face, GLenum pname, GLint * params);</para>
        /// </summary>
        /// <param name="face">
        /// <para>
        /// Specifies which of the two materials is being queried.
        /// <code>GL_FRONT</code> or <code>GL_BACK</code> are accepted,
        /// representing the front and back materials,
        /// respectively.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the material parameter to return.
        /// <code>GL_AMBIENT</code>,
        /// <code>GL_DIFFUSE</code>,
        /// <code>GL_SPECULAR</code>,
        /// <code>GL_EMISSION</code>,
        /// <code>GL_SHININESS</code>, and
        /// <code>GL_COLOR_INDEXES</code>
        /// are accepted.
        /// </para>
        /// </param>
        /// <param name="ps">
        /// Returns the requested data.
        /// </param>
        /// <seealso cref="Material"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void GetMaterialiv(uint face, uint pname, ref int ps) {
            fixed (int* pPs = &ps) {
                GLNative.glGetMaterialiv(face, pname, pPs);
            }
        }

        /// <summary>
        /// return the specified pixel map
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// If an error is generated,
        /// no change is made to the contents of <paramref name="data"/>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="map"/> is not an accepted value.
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_PACK_BUFFER</code> target and the buffer object's data store is currently mapped.
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_PACK_BUFFER</code> target and the data would be packed to the buffer 
        /// object such that the memory writes required would exceed the data store size.
        /// <code>GL_INVALID_OPERATION</code> is generated by <see cref="glGetPixelMapfv"/> if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_PACK_BUFFER</code> target and <paramref name="data"/> is not evenly divisible 
        /// into the number of bytes needed to store in memory a GLfloat datum.
        /// <code>GL_INVALID_OPERATION</code> is generated by <see cref="glGetPixelMapuiv"/> if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_PACK_BUFFER</code> target and <paramref name="data"/> is not evenly divisible 
        /// into the number of bytes needed to store in memory a GLuint datum.
        /// <code>GL_INVALID_OPERATION</code> is generated by <see cref="glGetPixelMapusv"/> if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_PACK_BUFFER</code> target and <paramref name="data"/> is not evenly divisible 
        /// into the number of bytes needed to store in memory a GLushort datum.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glGetPixelMap"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glGetPixelMapfv(GLenum map, GLfloat * data);</para>
        /// </summary>
        /// <param name="map">
        /// <para>
        /// Specifies the name of the pixel map to return.
        /// Accepted values are
        /// <code>GL_PIXEL_MAP_I_TO_I</code>,
        /// <code>GL_PIXEL_MAP_S_TO_S</code>,
        /// <code>GL_PIXEL_MAP_I_TO_R</code>,
        /// <code>GL_PIXEL_MAP_I_TO_G</code>,
        /// <code>GL_PIXEL_MAP_I_TO_B</code>,
        /// <code>GL_PIXEL_MAP_I_TO_A</code>,
        /// <code>GL_PIXEL_MAP_R_TO_R</code>,
        /// <code>GL_PIXEL_MAP_G_TO_G</code>,
        /// <code>GL_PIXEL_MAP_B_TO_B</code>, and
        /// <code>GL_PIXEL_MAP_A_TO_A</code>.
        /// </para>
        /// </param>
        /// <param name="data">
        /// Returns the pixel map contents.
        /// </param>
        /// <seealso cref="ColorSubTable"/>
        /// <seealso cref="ColorTable"/>
        /// <seealso cref="ConvolutionFilter1D"/>
        /// <seealso cref="ConvolutionFilter2D"/>
        /// <seealso cref="CopyColorSubTable"/>
        /// <seealso cref="CopyColorTable"/>
        /// <seealso cref="CopyPixels"/>
        /// <seealso cref="CopyTexImage1D"/>
        /// <seealso cref="CopyTexImage2D"/>
        /// <seealso cref="CopyTexSubImage1D"/>
        /// <seealso cref="CopyTexSubImage2D"/>
        /// <seealso cref="CopyTexSubImage3D"/>
        /// <seealso cref="DrawPixels"/>
        /// <seealso cref="GetHistogram"/>
        /// <seealso cref="GetMinmax"/>
        /// <seealso cref="GetTexImage"/>
        /// <seealso cref="PixelMap"/>
        /// <seealso cref="PixelTransfer"/>
        /// <seealso cref="ReadPixels"/>
        /// <seealso cref="SeparableFilter2D"/>
        /// <seealso cref="TexImage1D"/>
        /// <seealso cref="TexImage1D"/>
        /// <seealso cref="TexImage2D"/>
        /// <seealso cref="TexImage2D"/>
        /// <seealso cref="TexImage3D"/>
        /// <seealso cref="TexSubImage1D"/>
        /// <seealso cref="TexSubImage2D"/>
        /// <seealso cref="TexSubImage3D"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void GetPixelMapfv(uint map, ref float data) {
            fixed (float* pData = &data) {
                GLNative.glGetPixelMapfv(map, pData);
            }
        }

        /// <summary>
        /// return the specified pixel map
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// If an error is generated,
        /// no change is made to the contents of <paramref name="data"/>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="map"/> is not an accepted value.
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_PACK_BUFFER</code> target and the buffer object's data store is currently mapped.
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_PACK_BUFFER</code> target and the data would be packed to the buffer 
        /// object such that the memory writes required would exceed the data store size.
        /// <code>GL_INVALID_OPERATION</code> is generated by <see cref="glGetPixelMapfv"/> if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_PACK_BUFFER</code> target and <paramref name="data"/> is not evenly divisible 
        /// into the number of bytes needed to store in memory a GLfloat datum.
        /// <code>GL_INVALID_OPERATION</code> is generated by <see cref="glGetPixelMapuiv"/> if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_PACK_BUFFER</code> target and <paramref name="data"/> is not evenly divisible 
        /// into the number of bytes needed to store in memory a GLuint datum.
        /// <code>GL_INVALID_OPERATION</code> is generated by <see cref="glGetPixelMapusv"/> if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_PACK_BUFFER</code> target and <paramref name="data"/> is not evenly divisible 
        /// into the number of bytes needed to store in memory a GLushort datum.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glGetPixelMap"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glGetPixelMapuiv(GLenum map, GLuint * data);</para>
        /// </summary>
        /// <param name="map">
        /// <para>
        /// Specifies the name of the pixel map to return.
        /// Accepted values are
        /// <code>GL_PIXEL_MAP_I_TO_I</code>,
        /// <code>GL_PIXEL_MAP_S_TO_S</code>,
        /// <code>GL_PIXEL_MAP_I_TO_R</code>,
        /// <code>GL_PIXEL_MAP_I_TO_G</code>,
        /// <code>GL_PIXEL_MAP_I_TO_B</code>,
        /// <code>GL_PIXEL_MAP_I_TO_A</code>,
        /// <code>GL_PIXEL_MAP_R_TO_R</code>,
        /// <code>GL_PIXEL_MAP_G_TO_G</code>,
        /// <code>GL_PIXEL_MAP_B_TO_B</code>, and
        /// <code>GL_PIXEL_MAP_A_TO_A</code>.
        /// </para>
        /// </param>
        /// <param name="data">
        /// Returns the pixel map contents.
        /// </param>
        /// <seealso cref="ColorSubTable"/>
        /// <seealso cref="ColorTable"/>
        /// <seealso cref="ConvolutionFilter1D"/>
        /// <seealso cref="ConvolutionFilter2D"/>
        /// <seealso cref="CopyColorSubTable"/>
        /// <seealso cref="CopyColorTable"/>
        /// <seealso cref="CopyPixels"/>
        /// <seealso cref="CopyTexImage1D"/>
        /// <seealso cref="CopyTexImage2D"/>
        /// <seealso cref="CopyTexSubImage1D"/>
        /// <seealso cref="CopyTexSubImage2D"/>
        /// <seealso cref="CopyTexSubImage3D"/>
        /// <seealso cref="DrawPixels"/>
        /// <seealso cref="GetHistogram"/>
        /// <seealso cref="GetMinmax"/>
        /// <seealso cref="GetTexImage"/>
        /// <seealso cref="PixelMap"/>
        /// <seealso cref="PixelTransfer"/>
        /// <seealso cref="ReadPixels"/>
        /// <seealso cref="SeparableFilter2D"/>
        /// <seealso cref="TexImage1D"/>
        /// <seealso cref="TexImage1D"/>
        /// <seealso cref="TexImage2D"/>
        /// <seealso cref="TexImage2D"/>
        /// <seealso cref="TexImage3D"/>
        /// <seealso cref="TexSubImage1D"/>
        /// <seealso cref="TexSubImage2D"/>
        /// <seealso cref="TexSubImage3D"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void GetPixelMapuiv(uint map, ref uint data) {
            fixed (uint* pData = &data) {
                GLNative.glGetPixelMapuiv(map, pData);
            }
        }

        /// <summary>
        /// return the specified pixel map
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// If an error is generated,
        /// no change is made to the contents of <paramref name="data"/>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="map"/> is not an accepted value.
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_PACK_BUFFER</code> target and the buffer object's data store is currently mapped.
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_PACK_BUFFER</code> target and the data would be packed to the buffer 
        /// object such that the memory writes required would exceed the data store size.
        /// <code>GL_INVALID_OPERATION</code> is generated by <see cref="glGetPixelMapfv"/> if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_PACK_BUFFER</code> target and <paramref name="data"/> is not evenly divisible 
        /// into the number of bytes needed to store in memory a GLfloat datum.
        /// <code>GL_INVALID_OPERATION</code> is generated by <see cref="glGetPixelMapuiv"/> if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_PACK_BUFFER</code> target and <paramref name="data"/> is not evenly divisible 
        /// into the number of bytes needed to store in memory a GLuint datum.
        /// <code>GL_INVALID_OPERATION</code> is generated by <see cref="glGetPixelMapusv"/> if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_PACK_BUFFER</code> target and <paramref name="data"/> is not evenly divisible 
        /// into the number of bytes needed to store in memory a GLushort datum.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glGetPixelMap"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glGetPixelMapusv(GLenum map, GLushort * data);</para>
        /// </summary>
        /// <param name="map">
        /// <para>
        /// Specifies the name of the pixel map to return.
        /// Accepted values are
        /// <code>GL_PIXEL_MAP_I_TO_I</code>,
        /// <code>GL_PIXEL_MAP_S_TO_S</code>,
        /// <code>GL_PIXEL_MAP_I_TO_R</code>,
        /// <code>GL_PIXEL_MAP_I_TO_G</code>,
        /// <code>GL_PIXEL_MAP_I_TO_B</code>,
        /// <code>GL_PIXEL_MAP_I_TO_A</code>,
        /// <code>GL_PIXEL_MAP_R_TO_R</code>,
        /// <code>GL_PIXEL_MAP_G_TO_G</code>,
        /// <code>GL_PIXEL_MAP_B_TO_B</code>, and
        /// <code>GL_PIXEL_MAP_A_TO_A</code>.
        /// </para>
        /// </param>
        /// <param name="data">
        /// Returns the pixel map contents.
        /// </param>
        /// <seealso cref="ColorSubTable"/>
        /// <seealso cref="ColorTable"/>
        /// <seealso cref="ConvolutionFilter1D"/>
        /// <seealso cref="ConvolutionFilter2D"/>
        /// <seealso cref="CopyColorSubTable"/>
        /// <seealso cref="CopyColorTable"/>
        /// <seealso cref="CopyPixels"/>
        /// <seealso cref="CopyTexImage1D"/>
        /// <seealso cref="CopyTexImage2D"/>
        /// <seealso cref="CopyTexSubImage1D"/>
        /// <seealso cref="CopyTexSubImage2D"/>
        /// <seealso cref="CopyTexSubImage3D"/>
        /// <seealso cref="DrawPixels"/>
        /// <seealso cref="GetHistogram"/>
        /// <seealso cref="GetMinmax"/>
        /// <seealso cref="GetTexImage"/>
        /// <seealso cref="PixelMap"/>
        /// <seealso cref="PixelTransfer"/>
        /// <seealso cref="ReadPixels"/>
        /// <seealso cref="SeparableFilter2D"/>
        /// <seealso cref="TexImage1D"/>
        /// <seealso cref="TexImage1D"/>
        /// <seealso cref="TexImage2D"/>
        /// <seealso cref="TexImage2D"/>
        /// <seealso cref="TexImage3D"/>
        /// <seealso cref="TexSubImage1D"/>
        /// <seealso cref="TexSubImage2D"/>
        /// <seealso cref="TexSubImage3D"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void GetPixelMapusv(uint map, ref ushort data) {
            fixed (ushort* pData = &data) {
                GLNative.glGetPixelMapusv(map, pData);
            }
        }

        /// <summary>
        /// return the polygon stipple pattern
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// If an error is generated,
        /// no change is made to the contents of <paramref name="pattern"/>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_PACK_BUFFER</code> target and the buffer object's data store is currently mapped.
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_PACK_BUFFER</code> target and the data would be packed to the buffer 
        /// object such that the memory writes required would exceed the data store size.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glGetPolygonStipple"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glGetPolygonStipple(GLubyte * pattern);</para>
        /// </summary>
        /// <param name="pattern">
        /// Returns the stipple pattern. The initial value is all 1's.
        /// </param>
        /// <seealso cref="PixelStore"/>
        /// <seealso cref="PixelTransfer"/>
        /// <seealso cref="PolygonStipple"/>
        /// <seealso cref="ReadPixels"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void GetPolygonStipple(ref byte pattern) {
            fixed (byte* pPattern = &pattern) {
                GLNative.glGetPolygonStipple(pPattern);
            }
        }

        /// <summary>
        /// return texture environment parameters
        /// <para>Require:</para> <para>GL_VERSION_1_0, GL_VERSION_ES_CM_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// If an error is generated,
        /// no change is made to the contents of <paramref name="ps"/>.
        /// For OpenGL versions 1.3 and greater, or when the <code>ARB_multitexture</code> extension is supported, <see cref="glGetTexEnv"/> returns
        /// the texture environment parameters for the active texture unit.
        /// <code>GL_COMBINE_RGB</code>,
        /// <code>GL_COMBINE_ALPHA</code>,
        /// <code>GL_SRC0_RGB</code>,
        /// <code>GL_SRC1_RGB</code>,
        /// <code>GL_SRC2_RGB</code>,
        /// <code>GL_SRC0_ALPHA</code>,
        /// <code>GL_SRC1_ALPHA</code>,
        /// <code>GL_SRC2_ALPHA</code>,
        /// <code>GL_OPERAND0_RGB</code>,
        /// <code>GL_OPERAND1_RGB</code>,
        /// <code>GL_OPERAND2_RGB</code>,
        /// <code>GL_OPERAND0_ALPHA</code>,
        /// <code>GL_OPERAND1_ALPHA</code>,
        /// <code>GL_OPERAND2_ALPHA</code>,
        /// <code>GL_RGB_SCALE</code>, and
        /// <code>GL_ALPHA_SCALE</code> are available only if the GL version is 1.3 or greater.
        /// <code>GL_TEXTURE_FILTER_CONTROL</code> and <code>GL_TEXTURE_LOD_BIAS</code> are available
        /// only if the GL version is 1.4 or greater.
        /// <code>GL_POINT_SPRITE</code> and <code>GL_COORD_REPLACE</code> are available
        /// only if the GL version is 2.0 or greater.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="target"/> or <paramref name="pname"/> is not an
        /// accepted value.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glGetTexEnv"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glGetTexEnvfv(GLenum target, GLenum pname, GLfloat * params);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies a texture environment. May be
        /// <code>GL_TEXTURE_ENV</code>,
        /// <code>GL_TEXTURE_FILTER_CONTROL</code>, or
        /// <code>GL_POINT_SPRITE</code>.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of a texture environment parameter.
        /// Accepted values are <code>GL_TEXTURE_ENV_MODE</code>, <code>GL_TEXTURE_ENV_COLOR</code>,
        /// <code>GL_TEXTURE_LOD_BIAS</code>,
        /// <code>GL_COMBINE_RGB</code>,
        /// <code>GL_COMBINE_ALPHA</code>,
        /// <code>GL_SRC0_RGB</code>,
        /// <code>GL_SRC1_RGB</code>,
        /// <code>GL_SRC2_RGB</code>,
        /// <code>GL_SRC0_ALPHA</code>,
        /// <code>GL_SRC1_ALPHA</code>,
        /// <code>GL_SRC2_ALPHA</code>,
        /// <code>GL_OPERAND0_RGB</code>,
        /// <code>GL_OPERAND1_RGB</code>,
        /// <code>GL_OPERAND2_RGB</code>,
        /// <code>GL_OPERAND0_ALPHA</code>,
        /// <code>GL_OPERAND1_ALPHA</code>,
        /// <code>GL_OPERAND2_ALPHA</code>,
        /// <code>GL_RGB_SCALE</code>,
        /// <code>GL_ALPHA_SCALE</code>, or
        /// <code>GL_COORD_REPLACE</code>.
        /// </para>
        /// </param>
        /// <param name="ps">
        /// Returns the requested data.
        /// </param>
        /// <seealso cref="ActiveTexture"/>
        /// <seealso cref="TexEnv"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void GetTexEnvfv(uint target, uint pname, ref float ps) {
            fixed (float* pPs = &ps) {
                GLNative.glGetTexEnvfv(target, pname, pPs);
            }
        }

        /// <summary>
        /// return texture environment parameters
        /// <para>Require:</para> <para>GL_VERSION_1_0, GL_VERSION_ES_CM_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// If an error is generated,
        /// no change is made to the contents of <paramref name="ps"/>.
        /// For OpenGL versions 1.3 and greater, or when the <code>ARB_multitexture</code> extension is supported, <see cref="glGetTexEnv"/> returns
        /// the texture environment parameters for the active texture unit.
        /// <code>GL_COMBINE_RGB</code>,
        /// <code>GL_COMBINE_ALPHA</code>,
        /// <code>GL_SRC0_RGB</code>,
        /// <code>GL_SRC1_RGB</code>,
        /// <code>GL_SRC2_RGB</code>,
        /// <code>GL_SRC0_ALPHA</code>,
        /// <code>GL_SRC1_ALPHA</code>,
        /// <code>GL_SRC2_ALPHA</code>,
        /// <code>GL_OPERAND0_RGB</code>,
        /// <code>GL_OPERAND1_RGB</code>,
        /// <code>GL_OPERAND2_RGB</code>,
        /// <code>GL_OPERAND0_ALPHA</code>,
        /// <code>GL_OPERAND1_ALPHA</code>,
        /// <code>GL_OPERAND2_ALPHA</code>,
        /// <code>GL_RGB_SCALE</code>, and
        /// <code>GL_ALPHA_SCALE</code> are available only if the GL version is 1.3 or greater.
        /// <code>GL_TEXTURE_FILTER_CONTROL</code> and <code>GL_TEXTURE_LOD_BIAS</code> are available
        /// only if the GL version is 1.4 or greater.
        /// <code>GL_POINT_SPRITE</code> and <code>GL_COORD_REPLACE</code> are available
        /// only if the GL version is 2.0 or greater.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="target"/> or <paramref name="pname"/> is not an
        /// accepted value.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glGetTexEnv"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glGetTexEnviv(GLenum target, GLenum pname, GLint * params);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies a texture environment. May be
        /// <code>GL_TEXTURE_ENV</code>,
        /// <code>GL_TEXTURE_FILTER_CONTROL</code>, or
        /// <code>GL_POINT_SPRITE</code>.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of a texture environment parameter.
        /// Accepted values are <code>GL_TEXTURE_ENV_MODE</code>, <code>GL_TEXTURE_ENV_COLOR</code>,
        /// <code>GL_TEXTURE_LOD_BIAS</code>,
        /// <code>GL_COMBINE_RGB</code>,
        /// <code>GL_COMBINE_ALPHA</code>,
        /// <code>GL_SRC0_RGB</code>,
        /// <code>GL_SRC1_RGB</code>,
        /// <code>GL_SRC2_RGB</code>,
        /// <code>GL_SRC0_ALPHA</code>,
        /// <code>GL_SRC1_ALPHA</code>,
        /// <code>GL_SRC2_ALPHA</code>,
        /// <code>GL_OPERAND0_RGB</code>,
        /// <code>GL_OPERAND1_RGB</code>,
        /// <code>GL_OPERAND2_RGB</code>,
        /// <code>GL_OPERAND0_ALPHA</code>,
        /// <code>GL_OPERAND1_ALPHA</code>,
        /// <code>GL_OPERAND2_ALPHA</code>,
        /// <code>GL_RGB_SCALE</code>,
        /// <code>GL_ALPHA_SCALE</code>, or
        /// <code>GL_COORD_REPLACE</code>.
        /// </para>
        /// </param>
        /// <param name="ps">
        /// Returns the requested data.
        /// </param>
        /// <seealso cref="ActiveTexture"/>
        /// <seealso cref="TexEnv"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void GetTexEnviv(uint target, uint pname, ref int ps) {
            fixed (int* pPs = &ps) {
                GLNative.glGetTexEnviv(target, pname, pPs);
            }
        }

        /// <summary>
        /// return texture coordinate generation parameters
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// If an error is generated,
        /// no change is made to the contents of <paramref name="ps"/>.
        /// For OpenGL versions 1.3 and greater, or when the <code>ARB_multitexture</code> extension is supported, <see cref="glGetTexGen"/> returns
        /// the texture coordinate generation parameters for the active texture unit.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="coord"/> or <paramref name="pname"/> is not an
        /// accepted value.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glGetTexGen"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glGetTexGendv(GLenum coord, GLenum pname, GLdouble * params);</para>
        /// </summary>
        /// <param name="coord">
        /// <para>
        /// Specifies a texture coordinate.
        /// Must be
        /// <code>GL_S</code>,
        /// <code>GL_T</code>,
        /// <code>GL_R</code>, or
        /// <code>GL_Q</code>.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of the value(s) to be returned.
        /// Must be either <code>GL_TEXTURE_GEN_MODE</code>
        /// or the name of one of the texture generation plane equations:
        /// <code>GL_OBJECT_PLANE</code> or <code>GL_EYE_PLANE</code>.
        /// </para>
        /// </param>
        /// <param name="ps">
        /// Returns the requested data.
        /// </param>
        /// <seealso cref="ActiveTexture"/>
        /// <seealso cref="TexGen"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void GetTexGendv(uint coord, uint pname, ref double ps) {
            fixed (double* pPs = &ps) {
                GLNative.glGetTexGendv(coord, pname, pPs);
            }
        }

        /// <summary>
        /// return texture coordinate generation parameters
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// If an error is generated,
        /// no change is made to the contents of <paramref name="ps"/>.
        /// For OpenGL versions 1.3 and greater, or when the <code>ARB_multitexture</code> extension is supported, <see cref="glGetTexGen"/> returns
        /// the texture coordinate generation parameters for the active texture unit.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="coord"/> or <paramref name="pname"/> is not an
        /// accepted value.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glGetTexGen"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glGetTexGenfv(GLenum coord, GLenum pname, GLfloat * params);</para>
        /// </summary>
        /// <param name="coord">
        /// <para>
        /// Specifies a texture coordinate.
        /// Must be
        /// <code>GL_S</code>,
        /// <code>GL_T</code>,
        /// <code>GL_R</code>, or
        /// <code>GL_Q</code>.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of the value(s) to be returned.
        /// Must be either <code>GL_TEXTURE_GEN_MODE</code>
        /// or the name of one of the texture generation plane equations:
        /// <code>GL_OBJECT_PLANE</code> or <code>GL_EYE_PLANE</code>.
        /// </para>
        /// </param>
        /// <param name="ps">
        /// Returns the requested data.
        /// </param>
        /// <seealso cref="ActiveTexture"/>
        /// <seealso cref="TexGen"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void GetTexGenfv(uint coord, uint pname, ref float ps) {
            fixed (float* pPs = &ps) {
                GLNative.glGetTexGenfv(coord, pname, pPs);
            }
        }

        /// <summary>
        /// return texture coordinate generation parameters
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// If an error is generated,
        /// no change is made to the contents of <paramref name="ps"/>.
        /// For OpenGL versions 1.3 and greater, or when the <code>ARB_multitexture</code> extension is supported, <see cref="glGetTexGen"/> returns
        /// the texture coordinate generation parameters for the active texture unit.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="coord"/> or <paramref name="pname"/> is not an
        /// accepted value.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glGetTexGen"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glGetTexGeniv(GLenum coord, GLenum pname, GLint * params);</para>
        /// </summary>
        /// <param name="coord">
        /// <para>
        /// Specifies a texture coordinate.
        /// Must be
        /// <code>GL_S</code>,
        /// <code>GL_T</code>,
        /// <code>GL_R</code>, or
        /// <code>GL_Q</code>.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of the value(s) to be returned.
        /// Must be either <code>GL_TEXTURE_GEN_MODE</code>
        /// or the name of one of the texture generation plane equations:
        /// <code>GL_OBJECT_PLANE</code> or <code>GL_EYE_PLANE</code>.
        /// </para>
        /// </param>
        /// <param name="ps">
        /// Returns the requested data.
        /// </param>
        /// <seealso cref="ActiveTexture"/>
        /// <seealso cref="TexGen"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void GetTexGeniv(uint coord, uint pname, ref int ps) {
            fixed (int* pPs = &ps) {
                GLNative.glGetTexGeniv(coord, pname, pPs);
            }
        }

        /// <summary>
        /// replace the current matrix with the specified matrix
        /// <para>Require:</para> <para>GL_VERSION_1_0, GL_VERSION_ES_CM_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// While the elements of the matrix may be specified with
        /// single or double precision, the GL implementation may
        /// store or operate on these values in less than single
        /// precision.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glLoadMatrix"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glLoadMatrixf(const GLfloat * m);</para>
        /// </summary>
        /// <param name="m">
        /// <para>
        /// Specifies a pointer to 16 consecutive values, which are used as the
        /// elements of a 
        /// 4 
        /// &times; 
        /// 4 
        /// column-major matrix.
        /// </para>
        /// </param>
        /// <seealso cref="LoadIdentity"/>
        /// <seealso cref="MatrixMode"/>
        /// <seealso cref="MultMatrix"/>
        /// <seealso cref="MultTransposeMatrix"/>
        /// <seealso cref="PushMatrix"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void LoadMatrixf(ref float m) {
            fixed (float* pM = &m) {
                GLNative.glLoadMatrixf(pM);
            }
        }

        /// <summary>
        /// replace the current matrix with the specified matrix
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// While the elements of the matrix may be specified with
        /// single or double precision, the GL implementation may
        /// store or operate on these values in less than single
        /// precision.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glLoadMatrix"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glLoadMatrixd(const GLdouble * m);</para>
        /// </summary>
        /// <param name="m">
        /// <para>
        /// Specifies a pointer to 16 consecutive values, which are used as the
        /// elements of a 
        /// 4 
        /// &times; 
        /// 4 
        /// column-major matrix.
        /// </para>
        /// </param>
        /// <seealso cref="LoadIdentity"/>
        /// <seealso cref="MatrixMode"/>
        /// <seealso cref="MultMatrix"/>
        /// <seealso cref="MultTransposeMatrix"/>
        /// <seealso cref="PushMatrix"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void LoadMatrixd(ref double m) {
            fixed (double* pM = &m) {
                GLNative.glLoadMatrixd(pM);
            }
        }

        /// <summary>
        /// multiply the current matrix with the specified matrix
        /// <para>Require:</para> <para>GL_VERSION_1_0, GL_VERSION_ES_CM_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// While the elements of the matrix may be specified with
        /// single or double precision, the GL may store or operate on these
        /// values in less-than-single precision.
        /// In many computer languages, 
        /// 4 
        /// &times; 
        /// 4 
        /// arrays are represented
        /// in row-major order. The transformations just described
        /// represent these matrices in column-major order.
        /// The order of the multiplication is important. For example, if the current
        /// transformation is a rotation, and <see cref="glMultMatrix"/> is called with a translation matrix,
        /// the translation is done directly on the coordinates to be transformed,
        /// while the rotation is done on the results of that translation.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glMultMatrix"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glMultMatrixf(const GLfloat * m);</para>
        /// </summary>
        /// <param name="m">
        /// <para>
        /// Points to 16 consecutive values that are used as the elements of
        /// a 
        /// 4 
        /// &times; 
        /// 4 
        /// column-major matrix.
        /// </para>
        /// </param>
        /// <seealso cref="LoadIdentity"/>
        /// <seealso cref="LoadMatrix"/>
        /// <seealso cref="LoadTransposeMatrix"/>
        /// <seealso cref="MatrixMode"/>
        /// <seealso cref="MultTransposeMatrix"/>
        /// <seealso cref="PushMatrix"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void MultMatrixf(ref float m) {
            fixed (float* pM = &m) {
                GLNative.glMultMatrixf(pM);
            }
        }

        /// <summary>
        /// multiply the current matrix with the specified matrix
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// While the elements of the matrix may be specified with
        /// single or double precision, the GL may store or operate on these
        /// values in less-than-single precision.
        /// In many computer languages, 
        /// 4 
        /// &times; 
        /// 4 
        /// arrays are represented
        /// in row-major order. The transformations just described
        /// represent these matrices in column-major order.
        /// The order of the multiplication is important. For example, if the current
        /// transformation is a rotation, and <see cref="glMultMatrix"/> is called with a translation matrix,
        /// the translation is done directly on the coordinates to be transformed,
        /// while the rotation is done on the results of that translation.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glMultMatrix"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glMultMatrixd(const GLdouble * m);</para>
        /// </summary>
        /// <param name="m">
        /// <para>
        /// Points to 16 consecutive values that are used as the elements of
        /// a 
        /// 4 
        /// &times; 
        /// 4 
        /// column-major matrix.
        /// </para>
        /// </param>
        /// <seealso cref="LoadIdentity"/>
        /// <seealso cref="LoadMatrix"/>
        /// <seealso cref="LoadTransposeMatrix"/>
        /// <seealso cref="MatrixMode"/>
        /// <seealso cref="MultTransposeMatrix"/>
        /// <seealso cref="PushMatrix"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void MultMatrixd(ref double m) {
            fixed (double* pM = &m) {
                GLNative.glMultMatrixd(pM);
            }
        }


        #endregion GL_VERSION_1_0

        #region GL_VERSION_1_1

        /// <summary>
        /// render primitives from array data
        /// <para>Require:</para> <para>GL_VERSION_1_1, GL_VERSION_ES_CM_1_0, GL_ES_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glDrawElements"/> is available only if the GL version is 1.1 or greater.
        /// <see cref="glDrawElements"/> is included in display lists. If <see cref="glDrawElements"/> is entered into a
        /// display list,
        /// the necessary array data (determined by the array pointers and
        /// enables) is also
        /// entered into the display list. Because the array pointers and
        /// enables are client-side state, their values affect display lists
        /// when the lists are created, not when the lists are executed.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="mode"/> is not an accepted value.
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="count"/> is negative.
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to an
        /// enabled array or the element array and the buffer object's data store is currently mapped.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glDrawElements"/> is executed between
        /// the execution of  <see cref="glBegin"/>  and the corresponding  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glDrawElements(GLenum mode, GLsizei count, GLenum type, const void * indices);</para>
        /// </summary>
        /// <param name="mode">
        /// <para>
        /// Specifies what kind of primitives to render.
        /// Symbolic constants
        /// <code>GL_POINTS</code>,
        /// <code>GL_LINE_STRIP</code>,
        /// <code>GL_LINE_LOOP</code>,
        /// <code>GL_LINES</code>,
        /// <code>GL_TRIANGLE_STRIP</code>,
        /// <code>GL_TRIANGLE_FAN</code>,
        /// <code>GL_TRIANGLES</code>,
        /// <code>GL_QUAD_STRIP</code>,
        /// <code>GL_QUADS</code>,
        /// and <code>GL_POLYGON</code> are accepted.
        /// </para>
        /// </param>
        /// <param name="count">
        /// Specifies the number of elements to be rendered.
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the type of the values in <paramref name="indices"/>. Must be one of
        /// <code>GL_UNSIGNED_BYTE</code>, <code>GL_UNSIGNED_SHORT</code>, or
        /// <code>GL_UNSIGNED_INT</code>.
        /// </para>
        /// </param>
        /// <param name="indices">
        /// Specifies a pointer to the location where the indices are stored.
        /// </param>
        /// <seealso cref="ArrayElement"/>
        /// <seealso cref="ColorPointer"/>
        /// <seealso cref="DrawArrays"/>
        /// <seealso cref="DrawRangeElements"/>
        /// <seealso cref="EdgeFlagPointer"/>
        /// <seealso cref="FogCoordPointer"/>
        /// <seealso cref="GetPointerv"/>
        /// <seealso cref="IndexPointer"/>
        /// <seealso cref="InterleavedArrays"/>
        /// <seealso cref="NormalPointer"/>
        /// <seealso cref="SecondaryColorPointer"/>
        /// <seealso cref="TexCoordPointer"/>
        /// <seealso cref="VertexPointer"/>
        public unsafe static void DrawElements(uint mode, int count, uint type, IntPtr indices) {
            GLNative.glDrawElements(mode, count, type, (void*)indices);
        }

        /// <summary>
        /// return the address of the specified pointer
        /// <para>Require:</para> <para>GL_VERSION_1_1, GL_VERSION_4_3, GL_VERSION_ES_CM_1_0, GL_ES_VERSION_3_2, GL_KHR_debug</para>
        /// Supported: <para>gl, glcore, gles1, gles2</para>
        /// Notes: 
        /// <para>
        /// <see cref="glGetPointerv"/> is available only if the GL version is 1.1 or greater.
        /// <code>GL_FOG_COORD_ARRAY_POINTER</code> and <code>GL_SECONDARY_COLOR_ARRAY_POINTER</code> 
        /// are available only if the GL version is 1.4 or greater.
        /// The pointers are all client-side state.
        /// The initial value for each pointer is 0.
        /// For OpenGL versions 1.3 and greater, or when the <code>ARB_multitexture</code>
        /// extension is supported, querying the <code>GL_TEXTURE_COORD_ARRAY_POINTER</code>
        /// returns the value for the active client texture unit.
        /// </para>
        /// Errors: 
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="pname"/> is not an accepted value.
        /// Original: <para>void glGetPointerv(GLenum pname, void ** params);</para>
        /// </summary>
        /// <param name="pname">
        /// <para>
        /// Specifies the array or buffer pointer to be returned.
        /// Symbolic constants
        /// <code>GL_COLOR_ARRAY_POINTER</code>,
        /// <code>GL_EDGE_FLAG_ARRAY_POINTER</code>,
        /// <code>GL_FOG_COORD_ARRAY_POINTER</code>,
        /// <code>GL_FEEDBACK_BUFFER_POINTER</code>,
        /// <code>GL_INDEX_ARRAY_POINTER</code>,
        /// <code>GL_NORMAL_ARRAY_POINTER</code>,
        /// <code>GL_SECONDARY_COLOR_ARRAY_POINTER</code>,
        /// <code>GL_SELECTION_BUFFER_POINTER</code>,
        /// <code>GL_TEXTURE_COORD_ARRAY_POINTER</code>,
        /// or
        /// <code>GL_VERTEX_ARRAY_POINTER</code>
        /// are accepted.
        /// </para>
        /// </param>
        /// <param name="ps">
        /// Returns the pointer value specified by <paramref name="pname"/>.
        /// </param>
        /// <seealso cref="BindBuffer"/>
        /// <seealso cref="ClientActiveTexture"/>
        /// <seealso cref="ColorPointer"/>
        /// <seealso cref="EdgeFlagPointer"/>
        /// <seealso cref="FogCoordPointer"/>
        /// <seealso cref="FeedbackBuffer"/>
        /// <seealso cref="GetVertexAttribPointerv"/>
        /// <seealso cref="IndexPointer"/>
        /// <seealso cref="NormalPointer"/>
        /// <seealso cref="SecondaryColorPointer"/>
        /// <seealso cref="SelectBuffer"/>
        /// <seealso cref="TexCoordPointer"/>
        /// <seealso cref="VertexAttribPointer"/>
        /// <seealso cref="VertexPointer"/>
        [Obsolete("Compatibility-only GL 1.1 features removed from GL 3.2")]
        public unsafe static void GetPointerv(uint pname, IntPtr ps) {
            GLNative.glGetPointerv(pname, (void**)ps);
        }

        /// <summary>
        /// specify a one-dimensional texture subimage
        /// <para>Require:</para> <para>GL_VERSION_1_1</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glTexSubImage1D"/> is available only if the GL version is 1.1 or greater.
        /// Texturing has no effect in color index mode.
        /// <see cref="glPixelStore"/>  and  <see cref="glPixelTransfer"/>  modes affect texture images
        /// in exactly the way they affect  <see cref="glDrawPixels"/> .
        /// Formats <code>GL_BGR</code>, and <code>GL_BGRA</code> and types
        /// <code>GL_UNSIGNED_BYTE_3_3_2</code>,
        /// <code>GL_UNSIGNED_BYTE_2_3_3_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_5_6_5</code>,
        /// <code>GL_UNSIGNED_SHORT_5_6_5_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_4_4_4_4</code>,
        /// <code>GL_UNSIGNED_SHORT_4_4_4_4_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_5_5_5_1</code>,
        /// <code>GL_UNSIGNED_SHORT_1_5_5_5_REV</code>,
        /// <code>GL_UNSIGNED_INT_8_8_8_8</code>,
        /// <code>GL_UNSIGNED_INT_8_8_8_8_REV</code>,
        /// <code>GL_UNSIGNED_INT_10_10_10_2</code>, and
        /// <code>GL_UNSIGNED_INT_2_10_10_10_REV</code> are available only if the GL version
        /// is 1.2 or greater.
        /// For OpenGL versions 1.3 and greater, or when the <code>ARB_multitexture</code> extension is supported, <see cref="glTexSubImage1D"/>
        /// specifies a one-dimensional subtexture for the current texture unit,
        /// specified with  <see cref="glActiveTexture"/> .
        /// When the <code>ARB_imaging</code> extension is supported, the RGBA components
        /// specified in <paramref name="data"/> may be processed by the imaging pipeline.  See
        /// <see cref="glTexImage1D"/>  for specific details.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="target"/> is not one of the
        /// allowable values.
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="format"/> is not an accepted
        /// format constant.
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="type"/> is not a type constant.
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="type"/> is <code>GL_BITMAP</code> and
        /// <paramref name="format"/> is not <code>GL_COLOR_INDEX</code>.
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="level"/> is less than 0.
        /// <code>GL_INVALID_VALUE</code> may be generated if <paramref name="level"/> is greater
        /// than 
        /// log 
        /// 2 
        /// max ,
        /// where  max  is the returned value of <code>GL_MAX_TEXTURE_SIZE</code>.
        /// <code>GL_INVALID_VALUE</code> is generated if 
        /// xoffset 
        /// &lt; 
        /// - 
        /// b 
        /// ,
        /// or if 
        /// (w  -  b):-->
        /// xoffset 
        /// + 
        /// width 
        /// &gt; 
        /// w 
        /// - 
        /// b 
        /// ,
        /// where 
        /// w   
        /// is the <code>GL_TEXTURE_WIDTH</code>, and 
        /// b   
        /// is
        /// the width of the <code>GL_TEXTURE_BORDER</code>
        /// of the texture image being modified.
        /// Note that 
        /// w   
        /// includes twice the border width.
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="width"/> is less than 0.
        /// <code>GL_INVALID_OPERATION</code> is generated if the texture array has not
        /// been defined by a previous  <see cref="glTexImage1D"/>  operation.
        /// <code>GL_INVALID_OPERATION</code> is generated if <paramref name="type"/> is one of
        /// <code>GL_UNSIGNED_BYTE_3_3_2</code>,
        /// <code>GL_UNSIGNED_BYTE_2_3_3_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_5_6_5</code>, or
        /// <code>GL_UNSIGNED_SHORT_5_6_5_REV</code>
        /// and <paramref name="format"/> is not <code>GL_RGB</code>.
        /// <code>GL_INVALID_OPERATION</code> is generated if <paramref name="type"/> is one of
        /// <code>GL_UNSIGNED_SHORT_4_4_4_4</code>,
        /// <code>GL_UNSIGNED_SHORT_4_4_4_4_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_5_5_5_1</code>,
        /// <code>GL_UNSIGNED_SHORT_1_5_5_5_REV</code>,
        /// <code>GL_UNSIGNED_INT_8_8_8_8</code>,
        /// <code>GL_UNSIGNED_INT_8_8_8_8_REV</code>,
        /// <code>GL_UNSIGNED_INT_10_10_10_2</code>, or
        /// <code>GL_UNSIGNED_INT_2_10_10_10_REV</code>
        /// and <paramref name="format"/> is neither <code>GL_RGBA</code> nor <code>GL_BGRA</code>.
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_UNPACK_BUFFER</code> target and the buffer object's data store is currently mapped.
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_UNPACK_BUFFER</code> target and the data would be unpacked from the buffer 
        /// object such that the memory reads required would exceed the data store size.
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_UNPACK_BUFFER</code> target and <paramref name="data"/> is not evenly divisible 
        /// into the number of bytes needed to store in memory a datum indicated by <paramref name="type"/>.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glTexSubImage1D"/> is executed
        /// between the execution of  <see cref="glBegin"/>  and the corresponding
        /// execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glTexSubImage1D(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const void * data);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target texture.
        /// Must be <code>GL_TEXTURE_1D</code>.
        /// </para>
        /// </param>
        /// <param name="level">
        /// <para>
        /// Specifies the level-of-detail number.
        /// Level 0 is the base image level.
        /// Level  n  is the  n th mipmap reduction image.
        /// </para>
        /// </param>
        /// <param name="xoffset">
        /// Specifies a texel offset in the x direction within the texture array.
        /// </param>
        /// <param name="width">
        /// Specifies the width of the texture subimage.
        /// </param>
        /// <param name="format">
        /// <para>
        /// Specifies the format of the pixel data.
        /// The following symbolic values are accepted:
        /// <code>GL_COLOR_INDEX</code>,
        /// <code>GL_RED</code>,
        /// <code>GL_GREEN</code>,
        /// <code>GL_BLUE</code>,
        /// <code>GL_ALPHA</code>,
        /// <code>GL_RGB</code>,
        /// <code>GL_BGR</code>,
        /// <code>GL_RGBA</code>,
        /// <code>GL_BGRA</code>,
        /// <code>GL_LUMINANCE</code>, and
        /// <code>GL_LUMINANCE_ALPHA</code>.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the data type of the pixel data.
        /// The following symbolic values are accepted:
        /// <code>GL_UNSIGNED_BYTE</code>,
        /// <code>GL_BYTE</code>,
        /// <code>GL_BITMAP</code>,
        /// <code>GL_UNSIGNED_SHORT</code>,
        /// <code>GL_SHORT</code>,
        /// <code>GL_UNSIGNED_INT</code>,
        /// <code>GL_INT</code>,
        /// <code>GL_FLOAT</code>,
        /// <code>GL_UNSIGNED_BYTE_3_3_2</code>,
        /// <code>GL_UNSIGNED_BYTE_2_3_3_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_5_6_5</code>,
        /// <code>GL_UNSIGNED_SHORT_5_6_5_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_4_4_4_4</code>,
        /// <code>GL_UNSIGNED_SHORT_4_4_4_4_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_5_5_5_1</code>,
        /// <code>GL_UNSIGNED_SHORT_1_5_5_5_REV</code>,
        /// <code>GL_UNSIGNED_INT_8_8_8_8</code>,
        /// <code>GL_UNSIGNED_INT_8_8_8_8_REV</code>,
        /// <code>GL_UNSIGNED_INT_10_10_10_2</code>, and
        /// <code>GL_UNSIGNED_INT_2_10_10_10_REV</code>.
        /// </para>
        /// </param>
        /// <param name="data">
        /// Specifies a pointer to the image data in memory.
        /// </param>
        /// <seealso cref="ActiveTexture"/>
        /// <seealso cref="CopyTexImage1D"/>
        /// <seealso cref="CopyTexImage2D"/>
        /// <seealso cref="CopyTexSubImage1D"/>
        /// <seealso cref="CopyTexSubImage2D"/>
        /// <seealso cref="CopyTexSubImage3D"/>
        /// <seealso cref="DrawPixels"/>
        /// <seealso cref="PixelStore"/>
        /// <seealso cref="PixelTransfer"/>
        /// <seealso cref="TexEnv"/>
        /// <seealso cref="TexGen"/>
        /// <seealso cref="TexImage1D"/>
        /// <seealso cref="TexImage2D"/>
        /// <seealso cref="TexImage3D"/>
        /// <seealso cref="TexParameter"/>
        /// <seealso cref="TexSubImage2D"/>
        /// <seealso cref="TexSubImage3D"/>
        public unsafe static void TexSubImage1D(uint target, int level, int xoffset, int width, uint format, uint type, IntPtr data) {
            GLNative.glTexSubImage1D(target, level, xoffset, width, format, type, (void*)data);
        }

        /// <summary>
        /// specify a two-dimensional texture subimage
        /// <para>Require:</para> <para>GL_VERSION_1_1, GL_VERSION_ES_CM_1_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glTexSubImage2D"/> is available only if the GL version is 1.1 or greater.
        /// Texturing has no effect in color index mode.
        /// <see cref="glPixelStore"/>  and  <see cref="glPixelTransfer"/>  modes affect texture images
        /// in exactly the way they affect  <see cref="glDrawPixels"/> .
        /// Formats <code>GL_BGR</code>, and <code>GL_BGRA</code> and types
        /// <code>GL_UNSIGNED_BYTE_3_3_2</code>,
        /// <code>GL_UNSIGNED_BYTE_2_3_3_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_5_6_5</code>,
        /// <code>GL_UNSIGNED_SHORT_5_6_5_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_4_4_4_4</code>,
        /// <code>GL_UNSIGNED_SHORT_4_4_4_4_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_5_5_5_1</code>,
        /// <code>GL_UNSIGNED_SHORT_1_5_5_5_REV</code>,
        /// <code>GL_UNSIGNED_INT_8_8_8_8</code>,
        /// <code>GL_UNSIGNED_INT_8_8_8_8_REV</code>,
        /// <code>GL_UNSIGNED_INT_10_10_10_2</code>, and
        /// <code>GL_UNSIGNED_INT_2_10_10_10_REV</code> are available only if the GL version
        /// is 1.2 or greater.
        /// For OpenGL versions 1.3 and greater, or when the <code>ARB_multitexture</code> extension is supported, <see cref="glTexSubImage2D"/>
        /// specifies a two-dimensional subtexture for the current texture unit,
        /// specified with  <see cref="glActiveTexture"/> .
        /// When the <code>ARB_imaging</code> extension is supported, the RGBA components
        /// specified in <paramref name="data"/> may be processed by the imaging pipeline.  See
        /// <see cref="glTexImage1D"/>  for specific details.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="target"/> is not <code>GL_TEXTURE_2D</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_POSITIVE_X</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_NEGATIVE_X</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_POSITIVE_Y</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_NEGATIVE_Y</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_POSITIVE_Z</code>, or
        /// <code>GL_TEXTURE_CUBE_MAP_NEGATIVE_Z</code>.
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="format"/> is not an accepted
        /// format constant.
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="type"/> is not a type constant.
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="type"/> is <code>GL_BITMAP</code> and
        /// <paramref name="format"/> is not <code>GL_COLOR_INDEX</code>.
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="level"/> is less than 0.
        /// <code>GL_INVALID_VALUE</code> may be generated if <paramref name="level"/> is greater
        /// than 
        /// log 
        /// 2 
        /// max ,
        /// where  max  is the returned value of <code>GL_MAX_TEXTURE_SIZE</code>.
        /// <code>GL_INVALID_VALUE</code> is generated if 
        /// xoffset 
        /// &lt; 
        /// - 
        /// b 
        /// ,
        /// (w - b):-->
        /// xoffset 
        /// + 
        /// width 
        /// &gt; 
        /// w 
        /// - 
        /// b 
        /// ,
        /// yoffset 
        /// &lt; 
        /// - 
        /// b 
        /// ,
        /// or 
        /// (h - b):-->
        /// yoffset 
        /// + 
        /// height 
        /// &gt; 
        /// h 
        /// - 
        /// b 
        /// ,
        /// where 
        /// w   
        /// is the <code>GL_TEXTURE_WIDTH</code>,
        /// h   
        /// is the <code>GL_TEXTURE_HEIGHT</code>, and 
        /// b   
        /// is the border width
        /// of the texture image being modified.
        /// Note that 
        /// w   
        /// and 
        /// h   
        /// include twice the border width.
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="width"/> or <paramref name="height"/> is less than 0.
        /// <code>GL_INVALID_OPERATION</code> is generated if the texture array has not
        /// been defined by a previous  <see cref="glTexImage2D"/>  operation.
        /// <code>GL_INVALID_OPERATION</code> is generated if <paramref name="type"/> is one of
        /// <code>GL_UNSIGNED_BYTE_3_3_2</code>,
        /// <code>GL_UNSIGNED_BYTE_2_3_3_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_5_6_5</code>, or
        /// <code>GL_UNSIGNED_SHORT_5_6_5_REV</code>
        /// and <paramref name="format"/> is not <code>GL_RGB</code>.
        /// <code>GL_INVALID_OPERATION</code> is generated if <paramref name="type"/> is one of
        /// <code>GL_UNSIGNED_SHORT_4_4_4_4</code>,
        /// <code>GL_UNSIGNED_SHORT_4_4_4_4_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_5_5_5_1</code>,
        /// <code>GL_UNSIGNED_SHORT_1_5_5_5_REV</code>,
        /// <code>GL_UNSIGNED_INT_8_8_8_8</code>,
        /// <code>GL_UNSIGNED_INT_8_8_8_8_REV</code>,
        /// <code>GL_UNSIGNED_INT_10_10_10_2</code>, or
        /// <code>GL_UNSIGNED_INT_2_10_10_10_REV</code>
        /// and <paramref name="format"/> is neither <code>GL_RGBA</code> nor <code>GL_BGRA</code>.
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_UNPACK_BUFFER</code> target and the buffer object's data store is currently mapped.
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_UNPACK_BUFFER</code> target and the data would be unpacked from the buffer 
        /// object such that the memory reads required would exceed the data store size.
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_UNPACK_BUFFER</code> target and <paramref name="data"/> is not evenly divisible 
        /// into the number of bytes needed to store in memory a datum indicated by <paramref name="type"/>.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glTexSubImage2D"/> is executed
        /// between the execution of  <see cref="glBegin"/>  and the corresponding
        /// execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const void * data);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target texture.
        /// Must be <code>GL_TEXTURE_2D</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_POSITIVE_X</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_NEGATIVE_X</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_POSITIVE_Y</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_NEGATIVE_Y</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_POSITIVE_Z</code>, or
        /// <code>GL_TEXTURE_CUBE_MAP_NEGATIVE_Z</code>.
        /// </para>
        /// </param>
        /// <param name="level">
        /// <para>
        /// Specifies the level-of-detail number.
        /// Level 0 is the base image level.
        /// Level  n  is the  n th mipmap reduction image.
        /// </para>
        /// </param>
        /// <param name="xoffset">
        /// Specifies a texel offset in the x direction within the texture array.
        /// </param>
        /// <param name="yoffset">
        /// Specifies a texel offset in the y direction within the texture array.
        /// </param>
        /// <param name="width">
        /// Specifies the width of the texture subimage.
        /// </param>
        /// <param name="height">
        /// Specifies the height of the texture subimage.
        /// </param>
        /// <param name="format">
        /// <para>
        /// Specifies the format of the pixel data.
        /// The following symbolic values are accepted:
        /// <code>GL_COLOR_INDEX</code>,
        /// <code>GL_RED</code>,
        /// <code>GL_GREEN</code>,
        /// <code>GL_BLUE</code>,
        /// <code>GL_ALPHA</code>,
        /// <code>GL_RGB</code>,
        /// <code>GL_BGR</code>,
        /// <code>GL_RGBA</code>,
        /// <code>GL_BGRA</code>,
        /// <code>GL_LUMINANCE</code>, and
        /// <code>GL_LUMINANCE_ALPHA</code>.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the data type of the pixel data.
        /// The following symbolic values are accepted:
        /// <code>GL_UNSIGNED_BYTE</code>,
        /// <code>GL_BYTE</code>,
        /// <code>GL_BITMAP</code>,
        /// <code>GL_UNSIGNED_SHORT</code>,
        /// <code>GL_SHORT</code>,
        /// <code>GL_UNSIGNED_INT</code>,
        /// <code>GL_INT</code>,
        /// <code>GL_FLOAT</code>,
        /// <code>GL_UNSIGNED_BYTE_3_3_2</code>,
        /// <code>GL_UNSIGNED_BYTE_2_3_3_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_5_6_5</code>,
        /// <code>GL_UNSIGNED_SHORT_5_6_5_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_4_4_4_4</code>,
        /// <code>GL_UNSIGNED_SHORT_4_4_4_4_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_5_5_5_1</code>,
        /// <code>GL_UNSIGNED_SHORT_1_5_5_5_REV</code>,
        /// <code>GL_UNSIGNED_INT_8_8_8_8</code>,
        /// <code>GL_UNSIGNED_INT_8_8_8_8_REV</code>,
        /// <code>GL_UNSIGNED_INT_10_10_10_2</code>, and
        /// <code>GL_UNSIGNED_INT_2_10_10_10_REV</code>.
        /// </para>
        /// </param>
        /// <param name="data">
        /// Specifies a pointer to the image data in memory.
        /// </param>
        /// <seealso cref="ActiveTexture"/>
        /// <seealso cref="CopyTexImage1D"/>
        /// <seealso cref="CopyTexImage2D"/>
        /// <seealso cref="CopyTexSubImage1D"/>
        /// <seealso cref="CopyTexSubImage2D"/>
        /// <seealso cref="CopyTexSubImage3D"/>
        /// <seealso cref="DrawPixels"/>
        /// <seealso cref="PixelStore"/>
        /// <seealso cref="PixelTransfer"/>
        /// <seealso cref="TexEnv"/>
        /// <seealso cref="TexGen"/>
        /// <seealso cref="TexImage1D"/>
        /// <seealso cref="TexImage2D"/>
        /// <seealso cref="TexImage3D"/>
        /// <seealso cref="TexSubImage1D"/>
        /// <seealso cref="TexSubImage3D"/>
        /// <seealso cref="TexParameter"/>
        public unsafe static void TexSubImage2D(uint target, int level, int xoffset, int yoffset, int width, int height, uint format, uint type, IntPtr data) {
            GLNative.glTexSubImage2D(target, level, xoffset, yoffset, width, height, format, type, (void*)data);
        }

        /// <summary>
        /// delete named textures
        /// <para>Require:</para> <para>GL_VERSION_1_1, GL_VERSION_ES_CM_1_0, GL_ES_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <see cref="glDeleteTextures"/> is available only if the GL version is 1.1 or greater.
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="n"/> is negative.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glDeleteTextures"/> is executed
        /// between the execution of  <see cref="glBegin"/>  and the corresponding
        /// execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glDeleteTextures(GLsizei n, const GLuint * textures);</para>
        /// </summary>
        /// <param name="n">
        /// Specifies the number of textures to be deleted.
        /// </param>
        /// <param name="textures">
        /// Specifies an array of textures to be deleted.
        /// </param>
        /// <seealso cref="AreTexturesResident"/>
        /// <seealso cref="BindTexture"/>
        /// <seealso cref="CopyTexImage1D"/>
        /// <seealso cref="CopyTexImage2D"/>
        /// <seealso cref="GenTextures"/>
        /// <seealso cref="Get"/>
        /// <seealso cref="GetTexParameter"/>
        /// <seealso cref="PrioritizeTextures"/>
        /// <seealso cref="TexImage1D"/>
        /// <seealso cref="TexImage2D"/>
        /// <seealso cref="TexParameter"/>
        public unsafe static void DeleteTextures(int n, ref uint textures) {
            fixed (uint* pTextures = &textures) {
                GLNative.glDeleteTextures(n, pTextures);
            }
        }

        /// <summary>
        /// generate texture names
        /// <para>Require:</para> <para>GL_VERSION_1_1, GL_VERSION_ES_CM_1_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <see cref="glGenTextures"/> is available only if the GL version is 1.1 or greater.
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="n"/> is negative.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glGenTextures"/> is executed
        /// between the execution of  <see cref="glBegin"/>  and the corresponding
        /// execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glGenTextures(GLsizei n, GLuint * textures);</para>
        /// </summary>
        /// <param name="n">
        /// Specifies the number of texture names to be generated.
        /// </param>
        /// <param name="textures">
        /// Specifies an array in which the generated texture names are stored.
        /// </param>
        /// <seealso cref="BindTexture"/>
        /// <seealso cref="CopyTexImage1D"/>
        /// <seealso cref="CopyTexImage2D"/>
        /// <seealso cref="DeleteTextures"/>
        /// <seealso cref="Get"/>
        /// <seealso cref="GetTexParameter"/>
        /// <seealso cref="TexImage1D"/>
        /// <seealso cref="TexImage2D"/>
        /// <seealso cref="TexImage3D"/>
        /// <seealso cref="TexParameter"/>
        public unsafe static void GenTextures(int n, ref uint textures) {
            fixed (uint* pTextures = &textures) {
                GLNative.glGenTextures(n, pTextures);
            }
        }

        /// <summary>
        /// define an array of colors
        /// <para>Require:</para> <para>GL_VERSION_1_1, GL_VERSION_ES_CM_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glColorPointer"/> is available only if the GL version is 1.1 or greater.
        /// The color array is initially disabled and isn't accessed when
        /// <see cref="glArrayElement"/> ,  <see cref="glDrawElements"/> ,  <see cref="glDrawRangeElements"/> ,
        /// <see cref="glDrawArrays"/> ,  <see cref="glMultiDrawArrays"/> , or  <see cref="glMultiDrawElements"/> 
        /// is called.
        /// Execution of <see cref="glColorPointer"/> is not allowed between the execution of
        /// <see cref="glBegin"/>  and the corresponding execution of  <see cref="glEnd"/> ,
        /// but an error may or may not be generated. If no error is generated,
        /// the operation is undefined.
        /// <see cref="glColorPointer"/> is typically implemented on the client side.
        /// Color array parameters are client-side state and are therefore not saved
        /// or restored by  <see cref="glPushAttrib"/>  and  <see cref="glPopAttrib"/> .
        /// Use  <see cref="glPushClientAttrib"/>  and  <see cref="glPopClientAttrib"/>  instead.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="size"/> is not 3 or 4.
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="type"/> is not an accepted value.
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="stride"/> is negative.
        /// </para>
        /// Original: <para>void glColorPointer(GLint size, GLenum type, GLsizei stride, const void * pointer);</para>
        /// </summary>
        /// <param name="size">
        /// <para>
        /// Specifies the number of components per color. Must be 3 or 4.
        /// The initial value is 4.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the data type of each color component in the array.
        /// Symbolic constants
        /// <code>GL_BYTE</code>,
        /// <code>GL_UNSIGNED_BYTE</code>,
        /// <code>GL_SHORT</code>,
        /// <code>GL_UNSIGNED_SHORT</code>,
        /// <code>GL_INT</code>,
        /// <code>GL_UNSIGNED_INT</code>,
        /// <code>GL_FLOAT</code>,
        /// and
        /// <code>GL_DOUBLE</code>
        /// are accepted.
        /// The initial value is <code>GL_FLOAT</code>.
        /// </para>
        /// </param>
        /// <param name="stride">
        /// <para>
        /// Specifies the byte offset between consecutive colors.
        /// If <paramref name="stride"/> is 0, the colors are understood to be
        /// tightly packed in the array. The initial value is 0.
        /// </para>
        /// </param>
        /// <param name="pointer">
        /// <para>
        /// Specifies a pointer to the first component of the first color element
        /// in the array. The initial value is 0.
        /// </para>
        /// </param>
        /// <seealso cref="ArrayElement"/>
        /// <seealso cref="BindBuffer"/>
        /// <seealso cref="Color"/>
        /// <seealso cref="DisableClientState"/>
        /// <seealso cref="DrawArrays"/>
        /// <seealso cref="DrawElements"/>
        /// <seealso cref="DrawRangeElements"/>
        /// <seealso cref="EdgeFlagPointer"/>
        /// <seealso cref="EnableClientState"/>
        /// <seealso cref="FogCoordPointer"/>
        /// <seealso cref="IndexPointer"/>
        /// <seealso cref="InterleavedArrays"/>
        /// <seealso cref="MultiDrawArrays"/>
        /// <seealso cref="MultiDrawElements"/>
        /// <seealso cref="NormalPointer"/>
        /// <seealso cref="PopClientAttrib"/>
        /// <seealso cref="PushClientAttrib"/>
        /// <seealso cref="SecondaryColorPointer"/>
        /// <seealso cref="TexCoordPointer"/>
        /// <seealso cref="VertexAttribPointer"/>
        /// <seealso cref="VertexPointer"/>
        [Obsolete("Compatibility-only GL 1.1 features removed from GL 3.2")]
        public unsafe static void ColorPointer(int size, uint type, int stride, IntPtr pointer) {
            GLNative.glColorPointer(size, type, stride, (void*)pointer);
        }

        /// <summary>
        /// define an array of edge flags
        /// <para>Require:</para> <para>GL_VERSION_1_1</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glEdgeFlagPointer"/> is available only if the GL version is 1.1 or greater.
        /// Edge flags are not supported for interleaved vertex array formats
        /// (see  <see cref="glInterleavedArrays"/> ).
        /// The edge flag array is initially disabled and isn't accessed when
        /// <see cref="glArrayElement"/> ,  <see cref="glDrawElements"/> ,  <see cref="glDrawRangeElements"/> ,
        /// <see cref="glDrawArrays"/> ,  <see cref="glMultiDrawArrays"/> , or  <see cref="glMultiDrawElements"/> 
        /// is called.
        /// Execution of <see cref="glEdgeFlagPointer"/> is not allowed between the execution of
        /// <see cref="glBegin"/>  and the corresponding execution of  <see cref="glEnd"/> ,
        /// but an error may or may not be generated. If no error is generated,
        /// the operation is undefined.
        /// <see cref="glEdgeFlagPointer"/> is typically implemented on the client side.
        /// Edge flag array parameters are client-side state and are therefore
        /// not saved or restored by  <see cref="glPushAttrib"/>  and  <see cref="glPopAttrib"/> .
        /// Use  <see cref="glPushClientAttrib"/>  and
        /// <see cref="glPopClientAttrib"/>  instead.
        /// </para>
        /// Errors: 
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="stride"/> is negative.
        /// Original: <para>void glEdgeFlagPointer(GLsizei stride, const void * pointer);</para>
        /// </summary>
        /// <param name="stride">
        /// <para>
        /// Specifies the byte offset between consecutive edge flags.
        /// If <paramref name="stride"/> is 0, the edge flags are understood
        /// to be tightly packed in the array. The initial value is 0.
        /// </para>
        /// </param>
        /// <param name="pointer">
        /// <para>
        /// Specifies a pointer to the first edge flag in the array. The initial
        /// value is 0.
        /// </para>
        /// </param>
        /// <seealso cref="ArrayElement"/>
        /// <seealso cref="BindBuffer"/>
        /// <seealso cref="ColorPointer"/>
        /// <seealso cref="DisableClientState"/>
        /// <seealso cref="DrawArrays"/>
        /// <seealso cref="DrawElements"/>
        /// <seealso cref="DrawRangeElements"/>
        /// <seealso cref="EdgeFlag"/>
        /// <seealso cref="EnableClientState"/>
        /// <seealso cref="FogCoordPointer"/>
        /// <seealso cref="IndexPointer"/>
        /// <seealso cref="InterleavedArrays"/>
        /// <seealso cref="MultiDrawArrays"/>
        /// <seealso cref="MultiDrawElements"/>
        /// <seealso cref="NormalPointer"/>
        /// <seealso cref="PopClientAttrib"/>
        /// <seealso cref="PushClientAttrib"/>
        /// <seealso cref="SecondaryColorPointer"/>
        /// <seealso cref="TexCoordPointer"/>
        /// <seealso cref="VertexAttribPointer"/>
        /// <seealso cref="VertexPointer"/>
        [Obsolete("Compatibility-only GL 1.1 features removed from GL 3.2")]
        public unsafe static void EdgeFlagPointer(int stride, IntPtr pointer) {
            GLNative.glEdgeFlagPointer(stride, (void*)pointer);
        }

        /// <summary>
        /// define an array of color indexes
        /// <para>Require:</para> <para>GL_VERSION_1_1</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glIndexPointer"/> is available only if the GL version is 1.1 or greater.
        /// Color indexes are not supported for interleaved vertex array formats
        /// (see  <see cref="glInterleavedArrays"/> ).
        /// The color index array is initially disabled and isn't accessed when
        /// <see cref="glArrayElement"/> ,  <see cref="glDrawElements"/> ,  <see cref="glDrawRangeElements"/> ,
        /// <see cref="glDrawArrays"/> ,  <see cref="glMultiDrawArrays"/> , or  <see cref="glMultiDrawElements"/> 
        /// is called.
        /// Execution of <see cref="glIndexPointer"/> is not allowed between
        /// <see cref="glBegin"/>  and the corresponding  <see cref="glEnd"/> ,
        /// but an error may or may not be generated. If an error is not generated,
        /// the operation is undefined.
        /// <see cref="glIndexPointer"/> is typically implemented on the client side.
        /// Color index array parameters are client-side state and are
        /// therefore not saved or restored by  <see cref="glPushAttrib"/>  and  <see cref="glPopAttrib"/> .
        /// Use  <see cref="glPushClientAttrib"/>  and
        /// <see cref="glPopClientAttrib"/>  instead.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="type"/> is not an accepted value.
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="stride"/> is negative.
        /// </para>
        /// Original: <para>void glIndexPointer(GLenum type, GLsizei stride, const void * pointer);</para>
        /// </summary>
        /// <param name="type">
        /// <para>
        /// Specifies the data type of each color index in the array.
        /// Symbolic constants
        /// <code>GL_UNSIGNED_BYTE</code>,
        /// <code>GL_SHORT</code>,
        /// <code>GL_INT</code>,
        /// <code>GL_FLOAT</code>,
        /// and <code>GL_DOUBLE</code>
        /// are accepted. The initial value is <code>GL_FLOAT</code>.
        /// </para>
        /// </param>
        /// <param name="stride">
        /// <para>
        /// Specifies the byte offset between consecutive color indexes.
        /// If <paramref name="stride"/> is 0, the color indexes are understood to
        /// be tightly packed in the array. The initial value is 0.
        /// </para>
        /// </param>
        /// <param name="pointer">
        /// <para>
        /// Specifies a pointer to the first index in the array.
        /// The initial value is 0.
        /// </para>
        /// </param>
        /// <seealso cref="ArrayElement"/>
        /// <seealso cref="BindBuffer"/>
        /// <seealso cref="ColorPointer"/>
        /// <seealso cref="DisableClientState"/>
        /// <seealso cref="DrawArrays"/>
        /// <seealso cref="DrawElements"/>
        /// <seealso cref="DrawRangeElements"/>
        /// <seealso cref="EdgeFlagPointer"/>
        /// <seealso cref="EnableClientState"/>
        /// <seealso cref="FogCoordPointer"/>
        /// <seealso cref="Index"/>
        /// <seealso cref="InterleavedArrays"/>
        /// <seealso cref="MultiDrawArrays"/>
        /// <seealso cref="MultiDrawElements"/>
        /// <seealso cref="NormalPointer"/>
        /// <seealso cref="PopClientAttrib"/>
        /// <seealso cref="PushClientAttrib"/>
        /// <seealso cref="SecondaryColorPointer"/>
        /// <seealso cref="TexCoordPointer"/>
        /// <seealso cref="VertexAttribPointer"/>
        /// <seealso cref="VertexPointer"/>
        [Obsolete("Compatibility-only GL 1.1 features removed from GL 3.2")]
        public unsafe static void IndexPointer(uint type, int stride, IntPtr pointer) {
            GLNative.glIndexPointer(type, stride, (void*)pointer);
        }

        /// <summary>
        /// simultaneously specify and enable several interleaved arrays
        /// <para>Require:</para> <para>GL_VERSION_1_1</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glInterleavedArrays"/> is available only if the GL version is 1.1 or greater.
        /// If <see cref="glInterleavedArrays"/> is called while compiling a display list, it is not
        /// compiled into the list, and it is executed immediately.
        /// Execution of <see cref="glInterleavedArrays"/> is not allowed between the execution of
        /// <see cref="glBegin"/>  and the corresponding execution of  <see cref="glEnd"/> ,
        /// but an error may or may not be generated. If no error is generated,
        /// the operation is undefined.
        /// <see cref="glInterleavedArrays"/> is typically implemented on the client side.
        /// Vertex array parameters are client-side state and are therefore not
        /// saved or restored by  <see cref="glPushAttrib"/>  and  <see cref="glPopAttrib"/> .
        /// Use  <see cref="glPushClientAttrib"/>  and  <see cref="glPopClientAttrib"/>  instead.
        /// For OpenGL versions 1.3 and greater, or when the <code>ARB_multitexture</code> extension is supported, <see cref="glInterleavedArrays"/>
        /// only updates the texture coordinate array for the client active texture
        /// unit. The texture coordinate state for other client texture units is not
        /// updated, regardless of whether the client texture unit is enabled or not.
        /// Secondary color values are not supported in interleaved vertex array formats.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="format"/> is not an accepted value.
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="stride"/> is negative.
        /// </para>
        /// Original: <para>void glInterleavedArrays(GLenum format, GLsizei stride, const void * pointer);</para>
        /// </summary>
        /// <param name="format">
        /// <para>
        /// Specifies the type of array to enable. Symbolic constants
        /// <code>GL_V2F</code>,
        /// <code>GL_V3F</code>,
        /// <code>GL_C4UB_V2F</code>,
        /// <code>GL_C4UB_V3F</code>,
        /// <code>GL_C3F_V3F</code>,
        /// <code>GL_N3F_V3F</code>,
        /// <code>GL_C4F_N3F_V3F</code>,
        /// <code>GL_T2F_V3F</code>,
        /// <code>GL_T4F_V4F</code>,
        /// <code>GL_T2F_C4UB_V3F</code>,
        /// <code>GL_T2F_C3F_V3F</code>,
        /// <code>GL_T2F_N3F_V3F</code>,
        /// <code>GL_T2F_C4F_N3F_V3F</code>,
        /// and
        /// <code>GL_T4F_C4F_N3F_V4F</code>
        /// are accepted.
        /// </para>
        /// </param>
        /// <param name="stride">
        /// Specifies the offset in bytes between each aggregate array element.
        /// </param>
        /// <seealso cref="ArrayElement"/>
        /// <seealso cref="ClientActiveTexture"/>
        /// <seealso cref="ColorPointer"/>
        /// <seealso cref="DrawArrays"/>
        /// <seealso cref="DrawElements"/>
        /// <seealso cref="EdgeFlagPointer"/>
        /// <seealso cref="EnableClientState"/>
        /// <seealso cref="GetPointerv"/>
        /// <seealso cref="IndexPointer"/>
        /// <seealso cref="NormalPointer"/>
        /// <seealso cref="SecondaryColorPointer"/>
        /// <seealso cref="TexCoordPointer"/>
        /// <seealso cref="VertexPointer"/>
        [Obsolete("Compatibility-only GL 1.1 features removed from GL 3.2")]
        public unsafe static void InterleavedArrays(uint format, int stride, IntPtr pointer) {
            GLNative.glInterleavedArrays(format, stride, (void*)pointer);
        }

        /// <summary>
        /// define an array of normals
        /// <para>Require:</para> <para>GL_VERSION_1_1, GL_VERSION_ES_CM_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glNormalPointer"/> is available only if the GL version is 1.1 or greater.
        /// The normal array is initially disabled and isn't accessed when
        /// <see cref="glArrayElement"/> ,  <see cref="glDrawElements"/> ,  <see cref="glDrawRangeElements"/> ,
        /// <see cref="glDrawArrays"/> ,  <see cref="glMultiDrawArrays"/> , or  <see cref="glMultiDrawElements"/> 
        /// is called.
        /// Execution of <see cref="glNormalPointer"/> is not allowed between
        /// <see cref="glBegin"/>  and the corresponding  <see cref="glEnd"/> ,
        /// but an error may or may not be generated. If an error is not generated,
        /// the operation is undefined.
        /// <see cref="glNormalPointer"/> is typically implemented on the client side.
        /// Normal array parameters are client-side state and are therefore not
        /// saved or restored by  <see cref="glPushAttrib"/>  and  <see cref="glPopAttrib"/> .
        /// Use  <see cref="glPushClientAttrib"/>  and
        /// <see cref="glPopClientAttrib"/>  instead.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="type"/> is not an accepted value.
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="stride"/> is negative.
        /// </para>
        /// Original: <para>void glNormalPointer(GLenum type, GLsizei stride, const void * pointer);</para>
        /// </summary>
        /// <param name="type">
        /// <para>
        /// Specifies the data type of each coordinate in the array.
        /// Symbolic constants
        /// <code>GL_BYTE</code>,
        /// <code>GL_SHORT</code>,
        /// <code>GL_INT</code>,
        /// <code>GL_FLOAT</code>, and
        /// <code>GL_DOUBLE</code>
        /// are accepted. The initial value is <code>GL_FLOAT</code>.
        /// </para>
        /// </param>
        /// <param name="stride">
        /// <para>
        /// Specifies the byte offset between consecutive normals. If <paramref name="stride"/> is
        /// 0, the normals are understood to be tightly packed in
        /// the array. The initial value is 0.
        /// </para>
        /// </param>
        /// <param name="pointer">
        /// <para>
        /// Specifies a pointer to the first coordinate of the first normal in the
        /// array. The initial value is 0.
        /// </para>
        /// </param>
        /// <seealso cref="ArrayElement"/>
        /// <seealso cref="BindBuffer"/>
        /// <seealso cref="ColorPointer"/>
        /// <seealso cref="DisableClientState"/>
        /// <seealso cref="DrawArrays"/>
        /// <seealso cref="DrawElements"/>
        /// <seealso cref="DrawRangeElements"/>
        /// <seealso cref="EdgeFlagPointer"/>
        /// <seealso cref="EnableClientState"/>
        /// <seealso cref="FogCoordPointer"/>
        /// <seealso cref="IndexPointer"/>
        /// <seealso cref="InterleavedArrays"/>
        /// <seealso cref="MultiDrawArrays"/>
        /// <seealso cref="MultiDrawElements"/>
        /// <seealso cref="Normal"/>
        /// <seealso cref="PopClientAttrib"/>
        /// <seealso cref="PushClientAttrib"/>
        /// <seealso cref="SecondaryColorPointer"/>
        /// <seealso cref="TexCoordPointer"/>
        /// <seealso cref="VertexAttribPointer"/>
        /// <seealso cref="VertexPointer"/>
        [Obsolete("Compatibility-only GL 1.1 features removed from GL 3.2")]
        public unsafe static void NormalPointer(uint type, int stride, IntPtr pointer) {
            GLNative.glNormalPointer(type, stride, (void*)pointer);
        }

        /// <summary>
        /// define an array of texture coordinates
        /// <para>Require:</para> <para>GL_VERSION_1_1, GL_VERSION_ES_CM_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glTexCoordPointer"/> is available only if the GL version is 1.1 or greater.
        /// For OpenGL versions 1.3 and greater, or when the <code>ARB_multitexture</code>
        /// extension is supported, <see cref="glTexCoordPointer"/> updates the
        /// texture coordinate array state of the active client texture unit,
        /// specified with  <see cref="glClientActiveTexture"/> .
        /// Each texture coordinate array is initially disabled and isn't accessed when
        /// <see cref="glArrayElement"/> ,  <see cref="glDrawElements"/> ,  <see cref="glDrawRangeElements"/> ,
        /// <see cref="glDrawArrays"/> ,  <see cref="glMultiDrawArrays"/> , or  <see cref="glMultiDrawElements"/> 
        /// is called.
        /// Execution of <see cref="glTexCoordPointer"/> is not allowed between the execution of
        /// <see cref="glBegin"/>  and the corresponding execution of  <see cref="glEnd"/> ,
        /// but an error may or may not be generated. If no error is generated,
        /// the operation is undefined.
        /// <see cref="glTexCoordPointer"/> is typically implemented on the client side.
        /// Texture coordinate array parameters are client-side state and are therefore
        /// not saved or restored by  <see cref="glPushAttrib"/>  and  <see cref="glPopAttrib"/> .
        /// Use  <see cref="glPushClientAttrib"/>  and
        /// <see cref="glPopClientAttrib"/>  instead.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="size"/> is not 1, 2, 3, or 4.
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="type"/> is not an accepted value.
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="stride"/> is negative.
        /// </para>
        /// Original: <para>void glTexCoordPointer(GLint size, GLenum type, GLsizei stride, const void * pointer);</para>
        /// </summary>
        /// <param name="size">
        /// <para>
        /// Specifies the number of coordinates per array element. Must be 1, 2, 3,
        /// or 4. The initial value is 4.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the data type of each texture coordinate.
        /// Symbolic constants
        /// <code>GL_SHORT</code>,
        /// <code>GL_INT</code>,
        /// <code>GL_FLOAT</code>,
        /// or <code>GL_DOUBLE</code>
        /// are accepted. The initial value is <code>GL_FLOAT</code>.
        /// </para>
        /// </param>
        /// <param name="stride">
        /// <para>
        /// Specifies the byte offset between consecutive texture coordinate sets.
        /// If <paramref name="stride"/> is 0, the array elements are understood
        /// to be tightly packed. The initial value is 0.
        /// </para>
        /// </param>
        /// <param name="pointer">
        /// <para>
        /// Specifies a pointer to the first coordinate of the first texture coordinate set in the
        /// array. The initial value is 0.
        /// </para>
        /// </param>
        /// <seealso cref="ArrayElement"/>
        /// <seealso cref="BindBuffer"/>
        /// <seealso cref="ClientActiveTexture"/>
        /// <seealso cref="ColorPointer"/>
        /// <seealso cref="DisableClientState"/>
        /// <seealso cref="DrawArrays"/>
        /// <seealso cref="DrawElements"/>
        /// <seealso cref="DrawRangeElements"/>
        /// <seealso cref="EdgeFlagPointer"/>
        /// <seealso cref="EnableClientState"/>
        /// <seealso cref="FogCoordPointer"/>
        /// <seealso cref="IndexPointer"/>
        /// <seealso cref="InterleavedArrays"/>
        /// <seealso cref="MultiDrawArrays"/>
        /// <seealso cref="MultiDrawElements"/>
        /// <seealso cref="MultiTexCoord"/>
        /// <seealso cref="NormalPointer"/>
        /// <seealso cref="PopClientAttrib"/>
        /// <seealso cref="PushClientAttrib"/>
        /// <seealso cref="SecondaryColorPointer"/>
        /// <seealso cref="TexCoord"/>
        /// <seealso cref="VertexAttribPointer"/>
        /// <seealso cref="VertexPointer"/>
        [Obsolete("Compatibility-only GL 1.1 features removed from GL 3.2")]
        public unsafe static void TexCoordPointer(int size, uint type, int stride, IntPtr pointer) {
            GLNative.glTexCoordPointer(size, type, stride, (void*)pointer);
        }

        /// <summary>
        /// define an array of vertex data
        /// <para>Require:</para> <para>GL_VERSION_1_1, GL_VERSION_ES_CM_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glVertexPointer"/> is available only if the GL version is 1.1 or greater.
        /// The vertex array is initially disabled and isn't accessed when
        /// <see cref="glArrayElement"/> ,  <see cref="glDrawElements"/> ,  <see cref="glDrawRangeElements"/> ,
        /// <see cref="glDrawArrays"/> ,  <see cref="glMultiDrawArrays"/> , or  <see cref="glMultiDrawElements"/> 
        /// is called.
        /// Execution of <see cref="glVertexPointer"/> is not allowed between the execution of
        /// <see cref="glBegin"/>  and the corresponding execution of  <see cref="glEnd"/> ,
        /// but an error may or may not be generated. If no error is generated,
        /// the operation is undefined.
        /// <see cref="glVertexPointer"/> is typically implemented on the client side.
        /// Vertex array parameters are client-side state and are therefore not
        /// saved or restored by  <see cref="glPushAttrib"/>  and  <see cref="glPopAttrib"/> .
        /// Use  <see cref="glPushClientAttrib"/>  and  <see cref="glPopClientAttrib"/>  instead.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="size"/> is not 2, 3, or 4.
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="type"/> is not an accepted value.
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="stride"/> is negative.
        /// </para>
        /// Original: <para>void glVertexPointer(GLint size, GLenum type, GLsizei stride, const void * pointer);</para>
        /// </summary>
        /// <param name="size">
        /// <para>
        /// Specifies the number of coordinates per vertex. Must be 2, 3, or
        /// 4. The initial value is 4.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the data type of each coordinate in the array.
        /// Symbolic constants
        /// <code>GL_SHORT</code>,
        /// <code>GL_INT</code>,
        /// <code>GL_FLOAT</code>,
        /// or <code>GL_DOUBLE</code>
        /// are accepted. The initial value is <code>GL_FLOAT</code>.
        /// </para>
        /// </param>
        /// <param name="stride">
        /// <para>
        /// Specifies the byte offset between consecutive
        /// vertices. If <paramref name="stride"/> is 0, the vertices are understood to be tightly packed in
        /// the array. The initial value
        /// is 0.
        /// </para>
        /// </param>
        /// <param name="pointer">
        /// <para>
        /// Specifies a pointer to the first coordinate of the first vertex in the
        /// array. The initial value is 0.
        /// </para>
        /// </param>
        /// <seealso cref="ArrayElement"/>
        /// <seealso cref="BindBuffer"/>
        /// <seealso cref="ColorPointer"/>
        /// <seealso cref="DisableClientState"/>
        /// <seealso cref="DrawArrays"/>
        /// <seealso cref="DrawElements"/>
        /// <seealso cref="DrawRangeElements"/>
        /// <seealso cref="EdgeFlagPointer"/>
        /// <seealso cref="EnableClientState"/>
        /// <seealso cref="FogCoordPointer"/>
        /// <seealso cref="IndexPointer"/>
        /// <seealso cref="InterleavedArrays"/>
        /// <seealso cref="MultiDrawArrays"/>
        /// <seealso cref="MultiDrawElements"/>
        /// <seealso cref="NormalPointer"/>
        /// <seealso cref="PopClientAttrib"/>
        /// <seealso cref="PushClientAttrib"/>
        /// <seealso cref="SecondaryColorPointer"/>
        /// <seealso cref="TexCoordPointer"/>
        /// <seealso cref="Vertex"/>
        /// <seealso cref="VertexAttribPointer"/>
        [Obsolete("Compatibility-only GL 1.1 features removed from GL 3.2")]
        public unsafe static void VertexPointer(int size, uint type, int stride, IntPtr pointer) {
            GLNative.glVertexPointer(size, type, stride, (void*)pointer);
        }

        /// <summary>
        /// determine if textures are loaded in texture memory
        /// <para>Require:</para> <para>GL_VERSION_1_1</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glAreTexturesResident"/> is available only if the GL version is 1.1 or greater.
        /// <see cref="glAreTexturesResident"/> returns the residency status of the textures at the time of
        /// invocation. It does not guarantee that the textures will remain
        /// resident at any other time.
        /// If textures reside in virtual memory (there is no texture memory), they
        /// are considered always resident.
        /// Some implementations may not load a texture until the first use of
        /// that texture.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="n"/> is negative.
        /// <code>GL_INVALID_VALUE</code> is generated if any element in <paramref name="textures"/>
        /// is 0 or does not name a texture. In that case, the function returns
        /// <code>GL_FALSE</code> and the contents of <paramref name="residences"/> is indeterminate.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glAreTexturesResident"/> is executed
        /// between the execution of  <see cref="glBegin"/>  and the corresponding
        /// execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>GLboolean glAreTexturesResident(GLsizei n, const GLuint * textures, GLboolean * residences);</para>
        /// </summary>
        /// <param name="n">
        /// Specifies the number of textures to be queried.
        /// </param>
        /// <param name="textures">
        /// Specifies an array containing the names of the textures to be queried.
        /// </param>
        /// <param name="residences">
        /// <para>
        /// Specifies an array in which the texture residence status is returned.
        /// The residence status of a texture named by an element of <paramref name="textures"/> is
        /// returned in the corresponding element of <paramref name="residences"/>.
        /// </para>
        /// </param>
        /// <seealso cref="BindTexture"/>
        /// <seealso cref="GetTexParameter"/>
        /// <seealso cref="PrioritizeTextures"/>
        /// <seealso cref="TexImage1D"/>
        /// <seealso cref="TexImage2D"/>
        /// <seealso cref="TexImage3D"/>
        /// <seealso cref="TexParameter"/>
        [Obsolete("Compatibility-only GL 1.1 features removed from GL 3.2")]
        public unsafe static bool AreTexturesResident(int n, ref uint textures, ref bool residences) {
            fixed (uint* pTextures = &textures)
            fixed (bool* pResidences = &residences) {
                return GLNative.glAreTexturesResident(n, pTextures, pResidences);
            }
        }

        /// <summary>
        /// set texture residence priority
        /// <para>Require:</para> <para>GL_VERSION_1_1</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <see cref="glPrioritizeTextures"/> is available only if the GL version is 1.1 or greater.
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="n"/> is negative.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glPrioritizeTextures"/> is executed
        /// between the execution of  <see cref="glBegin"/>  and the corresponding
        /// execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glPrioritizeTextures(GLsizei n, const GLuint * textures, const GLclampf * priorities);</para>
        /// </summary>
        /// <param name="n">
        /// Specifies the number of textures to be prioritized.
        /// </param>
        /// <param name="textures">
        /// Specifies an array containing the names of the textures to be prioritized.
        /// </param>
        /// <param name="priorities">
        /// <para>
        /// Specifies an array containing the texture priorities.
        /// A priority given in an element of <paramref name="priorities"/> applies to the texture
        /// named by the corresponding element of <paramref name="textures"/>.
        /// </para>
        /// </param>
        /// <seealso cref="AreTexturesResident"/>
        /// <seealso cref="BindTexture"/>
        /// <seealso cref="CopyTexImage1D"/>
        /// <seealso cref="CopyTexImage2D"/>
        /// <seealso cref="TexImage1D"/>
        /// <seealso cref="TexImage2D"/>
        /// <seealso cref="TexImage3D"/>
        /// <seealso cref="TexParameter"/>
        [Obsolete("Compatibility-only GL 1.1 features removed from GL 3.2")]
        public unsafe static void PrioritizeTextures(int n, ref uint textures, ref float priorities) {
            fixed (uint* pTextures = &textures)
            fixed (float* pPriorities = &priorities) {
                GLNative.glPrioritizeTextures(n, pTextures, pPriorities);
            }
        }

        /// <summary>
        /// set the current color index
        /// <para>Require:</para> <para>GL_VERSION_1_1</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glIndexub"/> and <see cref="glIndexubv"/> are available only if the GL version is
        /// 1.1 or greater.
        /// The current index can be updated at any time.
        /// In particular,
        /// <see cref="glIndex"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glIndexubv(const GLubyte * c);</para>
        /// </summary>
        /// <param name="c">
        /// <para>
        /// Specifies a pointer to a one-element array that contains
        /// the new value for the current color index.
        /// </para>
        /// </param>
        /// <seealso cref="Color"/>
        /// <seealso cref="IndexPointer"/>
        [Obsolete("Compatibility-only GL 1.1 features removed from GL 3.2")]
        public unsafe static void Indexubv(ref byte c) {
            fixed (byte* pC = &c) {
                GLNative.glIndexubv(pC);
            }
        }


        #endregion GL_VERSION_1_1

        #region GL_VERSION_1_2

        /// <summary>
        /// render primitives from array data
        /// <para>Require:</para> <para>GL_VERSION_1_2, GL_ES_VERSION_3_0, GL_SC_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glDrawRangeElements"/> is available only if the GL version is 1.2 or greater.
        /// <see cref="glDrawRangeElements"/> is included in display lists. If <see cref="glDrawRangeElements"/> is entered into a
        /// display list,
        /// the necessary array data (determined by the array pointers and
        /// enables) is also
        /// entered into the display list. Because the array pointers and
        /// enables are client-side state, their values affect display lists
        /// when the lists are created, not when the lists are executed.
        /// </para>
        /// Errors: 
        /// <para>
        /// It is an error for indices to lie outside the range 
        /// start 
        /// end 
        /// ,
        /// but implementations may not check for this situation. Such indices
        /// cause implementation-dependent behavior.
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="mode"/> is not an accepted value.
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="count"/> is negative.
        /// <code>GL_INVALID_VALUE</code> is generated if 
        /// end 
        /// &lt; 
        /// start 
        /// .
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to an
        /// enabled array or the element array and the buffer object's data store is currently mapped.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glDrawRangeElements"/> is executed between
        /// the execution of  <see cref="glBegin"/>  and the corresponding  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glDrawRangeElements(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const void * indices);</para>
        /// </summary>
        /// <param name="mode">
        /// <para>
        /// Specifies what kind of primitives to render.
        /// Symbolic constants
        /// <code>GL_POINTS</code>,
        /// <code>GL_LINE_STRIP</code>,
        /// <code>GL_LINE_LOOP</code>,
        /// <code>GL_LINES</code>,
        /// <code>GL_TRIANGLE_STRIP</code>,
        /// <code>GL_TRIANGLE_FAN</code>,
        /// <code>GL_TRIANGLES</code>,
        /// <code>GL_QUAD_STRIP</code>,
        /// <code>GL_QUADS</code>,
        /// and <code>GL_POLYGON</code> are accepted.
        /// </para>
        /// </param>
        /// <param name="start">
        /// Specifies the minimum array index contained in <paramref name="indices"/>.
        /// </param>
        /// <param name="end">
        /// Specifies the maximum array index contained in <paramref name="indices"/>.
        /// </param>
        /// <param name="count">
        /// Specifies the number of elements to be rendered.
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the type of the values in <paramref name="indices"/>. Must be one of
        /// <code>GL_UNSIGNED_BYTE</code>, <code>GL_UNSIGNED_SHORT</code>, or
        /// <code>GL_UNSIGNED_INT</code>.
        /// </para>
        /// </param>
        /// <param name="indices">
        /// Specifies a pointer to the location where the indices are stored.
        /// </param>
        /// <seealso cref="ArrayElement"/>
        /// <seealso cref="ColorPointer"/>
        /// <seealso cref="DrawArrays"/>
        /// <seealso cref="DrawElements"/>
        /// <seealso cref="EdgeFlagPointer"/>
        /// <seealso cref="GetPointerv"/>
        /// <seealso cref="IndexPointer"/>
        /// <seealso cref="InterleavedArrays"/>
        /// <seealso cref="NormalPointer"/>
        /// <seealso cref="SecondaryColorPointer"/>
        /// <seealso cref="TexCoordPointer"/>
        /// <seealso cref="VertexPointer"/>
        public unsafe static void DrawRangeElements(uint mode, uint start, uint end, int count, uint type, IntPtr indices) {
            GLNative.glDrawRangeElements(mode, start, end, count, type, (void*)indices);
        }

        /// <summary>
        /// specify a three-dimensional texture image
        /// <para>Require:</para> <para>GL_VERSION_1_2, GL_ES_VERSION_3_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// Texturing has no effect in color index mode.
        /// The texture image can be represented by the same data formats
        /// as the pixels in a  <see cref="glDrawPixels"/>  command,
        /// except that <code>GL_STENCIL_INDEX</code> and <code>GL_DEPTH_COMPONENT</code>
        /// cannot be used.
        /// <see cref="glPixelStore"/>  and  <see cref="glPixelTransfer"/>  modes affect texture images
        /// in exactly the way they affect  <see cref="glDrawPixels"/> .
        /// <see cref="glTexImage3D"/> is available only if the GL version is 1.2 or greater.
        /// Internal formats other than 1, 2, 3, or 4 may be used only if the GL
        /// version is 1.1 or greater.
        /// <paramref name="data"/> may be a null pointer.
        /// In this case texture memory is
        /// allocated to accommodate a texture of width <paramref name="width"/>, height <paramref name="height"/>,
        /// and depth <paramref name="depth"/>.
        /// You can then download subtextures to initialize this
        /// texture memory.
        /// The image is undefined if the user tries to apply
        /// an uninitialized portion of the texture image to a primitive.
        /// Formats <code>GL_BGR</code>, and <code>GL_BGRA</code> and types
        /// <code>GL_UNSIGNED_BYTE_3_3_2</code>,
        /// <code>GL_UNSIGNED_BYTE_2_3_3_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_5_6_5</code>,
        /// <code>GL_UNSIGNED_SHORT_5_6_5_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_4_4_4_4</code>,
        /// <code>GL_UNSIGNED_SHORT_4_4_4_4_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_5_5_5_1</code>,
        /// <code>GL_UNSIGNED_SHORT_1_5_5_5_REV</code>,
        /// <code>GL_UNSIGNED_INT_8_8_8_8</code>,
        /// <code>GL_UNSIGNED_INT_8_8_8_8_REV</code>,
        /// <code>GL_UNSIGNED_INT_10_10_10_2</code>, and
        /// <code>GL_UNSIGNED_INT_2_10_10_10_REV</code> are available only if the GL version
        /// is 1.2 or greater.
        /// For OpenGL versions 1.3 and greater, or when the <code>ARB_multitexture</code> extension is supported, <see cref="glTexImage3D"/>
        /// specifies the three-dimensional texture for the current texture unit,
        /// specified with  <see cref="glActiveTexture"/> .
        /// If the <code>ARB_imaging</code> extension is supported, RGBA elements may
        /// also be processed by the imaging pipeline.  The following stages may be
        /// applied to an RGBA color before color component clamping to the range
        /// 0 
        /// 1 
        /// :
        /// 1. Color component replacement by the color table specified for 
        /// <code>GL_COLOR_TABLE</code>, if enabled. See  <see cref="glColorTable"/> .
        /// 2. Color component replacement by the color table specified for 
        /// <code>GL_POST_CONVOLUTION_COLOR_TABLE</code>, if enabled.  See  <see cref="glColorTable"/> .
        /// 3. Transformation by the color matrix.  See  <see cref="glMatrixMode"/> . 
        /// 4. RGBA components may be multiplied by <code>GL_POST_COLOR_MATRIX_c_SCALE</code>, 
        /// and added to <code>GL_POST_COLOR_MATRIX_c_BIAS</code>, if enabled.  See
        /// <see cref="glPixelTransfer"/> .
        /// 5. Color component replacement by the color table specified for 
        /// <code>GL_POST_COLOR_MATRIX_COLOR_TABLE</code>, if enabled.  See
        /// <see cref="glColorTable"/> .
        /// Non-power-of-two textures are supported if the GL version is 2.0 or greater, or if the implementation exports the <code>GL_ARB_texture_non_power_of_two</code> extension.
        /// The 
        /// <code>GL_SRGB</code>,
        /// <code>GL_SRGB8</code>,
        /// <code>GL_SRGB_ALPHA</code>,
        /// <code>GL_SRGB8_ALPHA8</code>,
        /// <code>GL_SLUMINANCE</code>,
        /// <code>GL_SLUMINANCE8</code>,
        /// <code>GL_SLUMINANCE_ALPHA</code>, and
        /// <code>GL_SLUMINANCE8_ALPHA8</code>
        /// internal formats are only available if the GL version is 2.1 or greater.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="target"/> is not <code>GL_TEXTURE_3D</code>
        /// or <code>GL_PROXY_TEXTURE_3D</code>.
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="format"/> is not an accepted
        /// format constant.  Format constants other than <code>GL_STENCIL_INDEX</code> and <code>GL_DEPTH_COMPONENT</code>
        /// are accepted.
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="type"/> is not a type constant.
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="type"/> is <code>GL_BITMAP</code> and
        /// <paramref name="format"/> is not <code>GL_COLOR_INDEX</code>.
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="level"/> is less than 0.
        /// <code>GL_INVALID_VALUE</code> may be generated if <paramref name="level"/> is greater than 
        /// log 
        /// 2 
        /// &af; 
        /// max 
        /// ,
        /// where  max  is the returned value of <code>GL_MAX_TEXTURE_SIZE</code>.
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="internalFormat"/> is not 1, 2, 3, 4, or one of the
        /// accepted resolution and format symbolic constants.
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="width"/>, <paramref name="height"/>, or <paramref name="depth"/> is less than 0 or greater than 2 + <code>GL_MAX_TEXTURE_SIZE</code>.
        /// <code>GL_INVALID_VALUE</code> is generated if non-power-of-two textures are not supported and the <paramref name="width"/>, <paramref name="height"/>, or <paramref name="depth"/> cannot be represented as 
        /// 2 
        /// k 
        /// + 
        /// 2 
        /// &af; 
        /// border 
        /// for some
        /// integer value of  k .
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="border"/> is not 0 or 1.
        /// <code>GL_INVALID_OPERATION</code> is generated if <paramref name="type"/> is one of
        /// <code>GL_UNSIGNED_BYTE_3_3_2</code>,
        /// <code>GL_UNSIGNED_BYTE_2_3_3_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_5_6_5</code>, or
        /// <code>GL_UNSIGNED_SHORT_5_6_5_REV</code>
        /// and <paramref name="format"/> is not <code>GL_RGB</code>.
        /// <code>GL_INVALID_OPERATION</code> is generated if <paramref name="type"/> is one of
        /// <code>GL_UNSIGNED_SHORT_4_4_4_4</code>,
        /// <code>GL_UNSIGNED_SHORT_4_4_4_4_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_5_5_5_1</code>,
        /// <code>GL_UNSIGNED_SHORT_1_5_5_5_REV</code>,
        /// <code>GL_UNSIGNED_INT_8_8_8_8</code>,
        /// <code>GL_UNSIGNED_INT_8_8_8_8_REV</code>,
        /// <code>GL_UNSIGNED_INT_10_10_10_2</code>, or
        /// <code>GL_UNSIGNED_INT_2_10_10_10_REV</code>
        /// and <paramref name="format"/> is neither <code>GL_RGBA</code> nor <code>GL_BGRA</code>.
        /// <code>GL_INVALID_OPERATION</code> is generated if <paramref name="format"/> or <paramref name="internalFormat"/> is
        /// <code>GL_DEPTH_COMPONENT</code>, <code>GL_DEPTH_COMPONENT16</code>,
        /// <code>GL_DEPTH_COMPONENT24</code>, or <code>GL_DEPTH_COMPONENT32</code>.
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_UNPACK_BUFFER</code> target and the buffer object's data store is currently mapped.
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_UNPACK_BUFFER</code> target and the data would be unpacked from the buffer 
        /// object such that the memory reads required would exceed the data store size.
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_UNPACK_BUFFER</code> target and <paramref name="data"/> is not evenly divisible 
        /// into the number of bytes needed to store in memory a datum indicated by <paramref name="type"/>.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glTexImage3D"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glTexImage3D(GLenum target, GLint level, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const void * data);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target texture.
        /// Must be <code>GL_TEXTURE_3D</code> or <code>GL_PROXY_TEXTURE_3D</code>.
        /// </para>
        /// </param>
        /// <param name="level">
        /// <para>
        /// Specifies the level-of-detail number.
        /// Level 0 is the base image level.
        /// Level 
        /// n   
        /// is the 
        /// n 
        /// th 
        /// mipmap reduction image.
        /// </para>
        /// </param>
        /// <param name="internalFormat">
        /// <para>
        /// Specifies the number of color components in the texture.
        /// Must be 1, 2, 3, or 4, or one of the following symbolic constants:
        /// <code>GL_ALPHA</code>,
        /// <code>GL_ALPHA4</code>,
        /// <code>GL_ALPHA8</code>,
        /// <code>GL_ALPHA12</code>,
        /// <code>GL_ALPHA16</code>,
        /// <code>GL_COMPRESSED_ALPHA</code>,
        /// <code>GL_COMPRESSED_LUMINANCE</code>,
        /// <code>GL_COMPRESSED_LUMINANCE_ALPHA</code>,
        /// <code>GL_COMPRESSED_INTENSITY</code>,
        /// <code>GL_COMPRESSED_RGB</code>,
        /// <code>GL_COMPRESSED_RGBA</code>,
        /// <code>GL_LUMINANCE</code>,
        /// <code>GL_LUMINANCE4</code>,
        /// <code>GL_LUMINANCE8</code>,
        /// <code>GL_LUMINANCE12</code>,
        /// <code>GL_LUMINANCE16</code>,
        /// <code>GL_LUMINANCE_ALPHA</code>,
        /// <code>GL_LUMINANCE4_ALPHA4</code>,
        /// <code>GL_LUMINANCE6_ALPHA2</code>,
        /// <code>GL_LUMINANCE8_ALPHA8</code>,
        /// <code>GL_LUMINANCE12_ALPHA4</code>,
        /// <code>GL_LUMINANCE12_ALPHA12</code>,
        /// <code>GL_LUMINANCE16_ALPHA16</code>,
        /// <code>GL_INTENSITY</code>,
        /// <code>GL_INTENSITY4</code>,
        /// <code>GL_INTENSITY8</code>,
        /// <code>GL_INTENSITY12</code>,
        /// <code>GL_INTENSITY16</code>,
        /// <code>GL_R3_G3_B2</code>,
        /// <code>GL_RGB</code>,
        /// <code>GL_RGB4</code>,
        /// <code>GL_RGB5</code>,
        /// <code>GL_RGB8</code>,
        /// <code>GL_RGB10</code>,
        /// <code>GL_RGB12</code>,
        /// <code>GL_RGB16</code>,
        /// <code>GL_RGBA</code>,
        /// <code>GL_RGBA2</code>,
        /// <code>GL_RGBA4</code>,
        /// <code>GL_RGB5_A1</code>,
        /// <code>GL_RGBA8</code>,
        /// <code>GL_RGB10_A2</code>,
        /// <code>GL_RGBA12</code>,
        /// <code>GL_RGBA16</code>,
        /// <code>GL_SLUMINANCE</code>,
        /// <code>GL_SLUMINANCE8</code>,
        /// <code>GL_SLUMINANCE_ALPHA</code>,
        /// <code>GL_SLUMINANCE8_ALPHA8</code>,
        /// <code>GL_SRGB</code>,
        /// <code>GL_SRGB8</code>,
        /// <code>GL_SRGB_ALPHA</code>, or 
        /// <code>GL_SRGB8_ALPHA8</code>.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// Specifies the width of the texture image including the border if any. If the GL version does not support non-power-of-two sizes, this value must be 
        /// 2 
        /// n 
        /// + 
        /// 2 
        /// &af; 
        /// border 
        /// for some integer 
        /// n   .
        /// All
        /// implementations support 3D texture images that are at least 16 texels
        /// wide.
        /// </para>
        /// </param>
        /// <param name="height">
        /// <para>
        /// Specifies the height of the texture image including the border if any. If the GL version does not support non-power-of-two sizes, this value must be 
        /// 2 
        /// m 
        /// + 
        /// 2 
        /// &af; 
        /// border 
        /// for some integer 
        /// m   .
        /// All
        /// implementations support 3D texture images that are at least 16 texels
        /// high.
        /// </para>
        /// </param>
        /// <param name="depth">
        /// <para>
        /// Specifies the depth of the texture image including the border if any. If the GL version does not support non-power-of-two sizes, this value must be 
        /// 2 
        /// k 
        /// + 
        /// 2 
        /// &af; 
        /// border 
        /// for some integer 
        /// k   .
        /// All
        /// implementations support 3D texture images that are at least 16 texels
        /// deep.
        /// </para>
        /// </param>
        /// <param name="border">
        /// <para>
        /// Specifies the width of the border.
        /// Must be either 0 or 1.
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// Specifies the format of the pixel data.
        /// The following symbolic values are accepted:
        /// <code>GL_COLOR_INDEX</code>,
        /// <code>GL_RED</code>,
        /// <code>GL_GREEN</code>,
        /// <code>GL_BLUE</code>,
        /// <code>GL_ALPHA</code>,
        /// <code>GL_RGB</code>,
        /// <code>GL_BGR</code>,
        /// <code>GL_RGBA</code>,
        /// <code>GL_BGRA</code>,
        /// <code>GL_LUMINANCE</code>, and
        /// <code>GL_LUMINANCE_ALPHA</code>.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the data type of the pixel data.
        /// The following symbolic values are accepted:
        /// <code>GL_UNSIGNED_BYTE</code>,
        /// <code>GL_BYTE</code>,
        /// <code>GL_BITMAP</code>,
        /// <code>GL_UNSIGNED_SHORT</code>,
        /// <code>GL_SHORT</code>,
        /// <code>GL_UNSIGNED_INT</code>,
        /// <code>GL_INT</code>,
        /// <code>GL_FLOAT</code>,
        /// <code>GL_UNSIGNED_BYTE_3_3_2</code>,
        /// <code>GL_UNSIGNED_BYTE_2_3_3_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_5_6_5</code>,
        /// <code>GL_UNSIGNED_SHORT_5_6_5_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_4_4_4_4</code>,
        /// <code>GL_UNSIGNED_SHORT_4_4_4_4_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_5_5_5_1</code>,
        /// <code>GL_UNSIGNED_SHORT_1_5_5_5_REV</code>,
        /// <code>GL_UNSIGNED_INT_8_8_8_8</code>,
        /// <code>GL_UNSIGNED_INT_8_8_8_8_REV</code>,
        /// <code>GL_UNSIGNED_INT_10_10_10_2</code>, and
        /// <code>GL_UNSIGNED_INT_2_10_10_10_REV</code>.
        /// </para>
        /// </param>
        /// <param name="data">
        /// Specifies a pointer to the image data in memory.
        /// </param>
        /// <seealso cref="ActiveTexture"/>
        /// <seealso cref="ColorTable"/>
        /// <seealso cref="CompressedTexImage1D"/>
        /// <seealso cref="CompressedTexImage2D"/>
        /// <seealso cref="CompressedTexImage3D"/>
        /// <seealso cref="CompressedTexSubImage1D"/>
        /// <seealso cref="CompressedTexSubImage2D"/>
        /// <seealso cref="CompressedTexSubImage3D"/>
        /// <seealso cref="CopyPixels"/>
        /// <seealso cref="CopyTexImage1D"/>
        /// <seealso cref="CopyTexImage2D"/>
        /// <seealso cref="CopyTexSubImage1D"/>
        /// <seealso cref="CopyTexSubImage2D"/>
        /// <seealso cref="CopyTexSubImage3D"/>
        /// <seealso cref="DrawPixels"/>
        /// <seealso cref="GetCompressedTexImage"/>
        /// <seealso cref="MatrixMode"/>
        /// <seealso cref="PixelStore"/>
        /// <seealso cref="PixelTransfer"/>
        /// <seealso cref="TexEnv"/>
        /// <seealso cref="TexGen"/>
        /// <seealso cref="TexImage1D"/>
        /// <seealso cref="TexImage2D"/>
        /// <seealso cref="TexSubImage1D"/>
        /// <seealso cref="TexSubImage2D"/>
        /// <seealso cref="TexSubImage3D"/>
        /// <seealso cref="TexParameter"/>
        public unsafe static void TexImage3D(uint target, int level, int internalFormat, int width, int height, int depth, int border, uint format, uint type, IntPtr data) {
            GLNative.glTexImage3D(target, level, internalFormat, width, height, depth, border, format, type, (void*)data);
        }

        /// <summary>
        /// specify a three-dimensional texture subimage
        /// <para>Require:</para> <para>GL_VERSION_1_2, GL_ES_VERSION_3_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glTexSubImage3D"/> is available only if the GL version is 1.2 or greater.
        /// Texturing has no effect in color index mode.
        /// <see cref="glPixelStore"/>  and  <see cref="glPixelTransfer"/>  modes affect texture images
        /// in exactly the way they affect  <see cref="glDrawPixels"/> .
        /// Formats <code>GL_BGR</code>, and <code>GL_BGRA</code> and types
        /// <code>GL_UNSIGNED_BYTE_3_3_2</code>,
        /// <code>GL_UNSIGNED_BYTE_2_3_3_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_5_6_5</code>,
        /// <code>GL_UNSIGNED_SHORT_5_6_5_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_4_4_4_4</code>,
        /// <code>GL_UNSIGNED_SHORT_4_4_4_4_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_5_5_5_1</code>,
        /// <code>GL_UNSIGNED_SHORT_1_5_5_5_REV</code>,
        /// <code>GL_UNSIGNED_INT_8_8_8_8</code>,
        /// <code>GL_UNSIGNED_INT_8_8_8_8_REV</code>,
        /// <code>GL_UNSIGNED_INT_10_10_10_2</code>, and
        /// <code>GL_UNSIGNED_INT_2_10_10_10_REV</code> are available only if the GL version
        /// is 1.2 or greater.
        /// For OpenGL versions 1.3 and greater, or when the <code>ARB_multitexture</code> extension is supported, <see cref="glTexSubImage3D"/>
        /// specifies a three-dimensional subtexture for the current texture unit,
        /// specified with  <see cref="glActiveTexture"/> .
        /// When the <code>ARB_imaging</code> extension is supported, the RGBA components
        /// specified in <paramref name="data"/> may be processed by the imaging pipeline.  See
        /// <see cref="glTexImage3D"/>  for specific details.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if /<paramref name="target"/> is not <code>GL_TEXTURE_3D</code>.
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="format"/> is not an accepted
        /// format constant.
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="type"/> is not a type constant.
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="type"/> is <code>GL_BITMAP</code> and
        /// <paramref name="format"/> is not <code>GL_COLOR_INDEX</code>.
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="level"/> is less than 0.
        /// <code>GL_INVALID_VALUE</code> may be generated if <paramref name="level"/> is greater
        /// than 
        /// log 
        /// 2 
        /// max ,
        /// where  max  is the returned value of <code>GL_MAX_TEXTURE_SIZE</code>.
        /// <code>GL_INVALID_VALUE</code> is generated if 
        /// xoffset 
        /// &lt; 
        /// - 
        /// b 
        /// ,
        /// (w - b):-->
        /// xoffset 
        /// + 
        /// width 
        /// &gt; 
        /// w 
        /// - 
        /// b 
        /// ,
        /// yoffset 
        /// &lt; 
        /// - 
        /// b 
        /// ,
        /// or 
        /// (h - b):-->
        /// yoffset 
        /// + 
        /// height 
        /// &gt; 
        /// h 
        /// - 
        /// b 
        /// ,
        /// or 
        /// zoffset 
        /// &lt; 
        /// - 
        /// b 
        /// ,
        /// or 
        /// (d - b):-->
        /// zoffset 
        /// + 
        /// depth 
        /// &gt; 
        /// d 
        /// - 
        /// b 
        /// ,
        /// where 
        /// w   
        /// is the <code>GL_TEXTURE_WIDTH</code>,
        /// h   
        /// is the <code>GL_TEXTURE_HEIGHT</code>, 
        /// d   
        /// is the <code>GL_TEXTURE_DEPTH</code>
        /// and 
        /// b   
        /// is the border width of the texture image being modified.
        /// Note that 
        /// w   ,
        /// h   ,
        /// and 
        /// d   
        /// include twice the border width.
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="width"/>, <paramref name="height"/>, or <paramref name="depth"/>
        /// is less than 0.
        /// <code>GL_INVALID_OPERATION</code> is generated if the texture array has not
        /// been defined by a previous  <see cref="glTexImage3D"/>  operation.
        /// <code>GL_INVALID_OPERATION</code> is generated if <paramref name="type"/> is one of
        /// <code>GL_UNSIGNED_BYTE_3_3_2</code>,
        /// <code>GL_UNSIGNED_BYTE_2_3_3_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_5_6_5</code>, or
        /// <code>GL_UNSIGNED_SHORT_5_6_5_REV</code>
        /// and <paramref name="format"/> is not <code>GL_RGB</code>.
        /// <code>GL_INVALID_OPERATION</code> is generated if <paramref name="type"/> is one of
        /// <code>GL_UNSIGNED_SHORT_4_4_4_4</code>,
        /// <code>GL_UNSIGNED_SHORT_4_4_4_4_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_5_5_5_1</code>,
        /// <code>GL_UNSIGNED_SHORT_1_5_5_5_REV</code>,
        /// <code>GL_UNSIGNED_INT_8_8_8_8</code>,
        /// <code>GL_UNSIGNED_INT_8_8_8_8_REV</code>,
        /// <code>GL_UNSIGNED_INT_10_10_10_2</code>, or
        /// <code>GL_UNSIGNED_INT_2_10_10_10_REV</code>
        /// and <paramref name="format"/> is neither <code>GL_RGBA</code> nor <code>GL_BGRA</code>.
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_UNPACK_BUFFER</code> target and the buffer object's data store is currently mapped.
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_UNPACK_BUFFER</code> target and the data would be unpacked from the buffer 
        /// object such that the memory reads required would exceed the data store size.
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_UNPACK_BUFFER</code> target and <paramref name="data"/> is not evenly divisible 
        /// into the number of bytes needed to store in memory a datum indicated by <paramref name="type"/>.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glTexSubImage3D"/> is executed
        /// between the execution of  <see cref="glBegin"/>  and the corresponding
        /// execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void * data);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target texture.
        /// Must be <code>GL_TEXTURE_3D</code>.
        /// </para>
        /// </param>
        /// <param name="level">
        /// <para>
        /// Specifies the level-of-detail number.
        /// Level 0 is the base image level.
        /// Level  n  is the  n th mipmap reduction image.
        /// </para>
        /// </param>
        /// <param name="xoffset">
        /// Specifies a texel offset in the x direction within the texture array.
        /// </param>
        /// <param name="yoffset">
        /// Specifies a texel offset in the y direction within the texture array.
        /// </param>
        /// <param name="zoffset">
        /// Specifies a texel offset in the z direction within the texture array.
        /// </param>
        /// <param name="width">
        /// Specifies the width of the texture subimage.
        /// </param>
        /// <param name="height">
        /// Specifies the height of the texture subimage.
        /// </param>
        /// <param name="depth">
        /// Specifies the depth of the texture subimage.
        /// </param>
        /// <param name="format">
        /// <para>
        /// Specifies the format of the pixel data.
        /// The following symbolic values are accepted:
        /// <code>GL_COLOR_INDEX</code>,
        /// <code>GL_RED</code>,
        /// <code>GL_GREEN</code>,
        /// <code>GL_BLUE</code>,
        /// <code>GL_ALPHA</code>,
        /// <code>GL_RGB</code>,
        /// <code>GL_BGR</code>,
        /// <code>GL_RGBA</code>,
        /// <code>GL_BGRA</code>,
        /// <code>GL_LUMINANCE</code>, and
        /// <code>GL_LUMINANCE_ALPHA</code>.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the data type of the pixel data.
        /// The following symbolic values are accepted:
        /// <code>GL_UNSIGNED_BYTE</code>,
        /// <code>GL_BYTE</code>,
        /// <code>GL_BITMAP</code>,
        /// <code>GL_UNSIGNED_SHORT</code>,
        /// <code>GL_SHORT</code>,
        /// <code>GL_UNSIGNED_INT</code>,
        /// <code>GL_INT</code>,
        /// <code>GL_FLOAT</code>,
        /// <code>GL_UNSIGNED_BYTE_3_3_2</code>,
        /// <code>GL_UNSIGNED_BYTE_2_3_3_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_5_6_5</code>,
        /// <code>GL_UNSIGNED_SHORT_5_6_5_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_4_4_4_4</code>,
        /// <code>GL_UNSIGNED_SHORT_4_4_4_4_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_5_5_5_1</code>,
        /// <code>GL_UNSIGNED_SHORT_1_5_5_5_REV</code>,
        /// <code>GL_UNSIGNED_INT_8_8_8_8</code>,
        /// <code>GL_UNSIGNED_INT_8_8_8_8_REV</code>,
        /// <code>GL_UNSIGNED_INT_10_10_10_2</code>, and
        /// <code>GL_UNSIGNED_INT_2_10_10_10_REV</code>.
        /// </para>
        /// </param>
        /// <param name="data">
        /// Specifies a pointer to the image data in memory.
        /// </param>
        /// <seealso cref="ActiveTexture"/>
        /// <seealso cref="CopyTexImage1D"/>
        /// <seealso cref="CopyTexImage2D"/>
        /// <seealso cref="CopyTexSubImage1D"/>
        /// <seealso cref="CopyTexSubImage2D"/>
        /// <seealso cref="CopyTexSubImage3D"/>
        /// <seealso cref="DrawPixels"/>
        /// <seealso cref="PixelStore"/>
        /// <seealso cref="PixelTransfer"/>
        /// <seealso cref="TexEnv"/>
        /// <seealso cref="TexGen"/>
        /// <seealso cref="TexImage1D"/>
        /// <seealso cref="TexImage2D"/>
        /// <seealso cref="TexImage3D"/>
        /// <seealso cref="TexSubImage1D"/>
        /// <seealso cref="TexSubImage2D"/>
        /// <seealso cref="TexParameter"/>
        public unsafe static void TexSubImage3D(uint target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, uint format, uint type, IntPtr data) {
            GLNative.glTexSubImage3D(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, (void*)data);
        }


        #endregion GL_VERSION_1_2

        #region GL_VERSION_1_3

        /// <summary>
        /// specify a three-dimensional texture image in a compressed format
        /// <para>Require:</para> <para>GL_VERSION_1_3, GL_ES_VERSION_3_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glCompressedTexImage3D"/> is available only if the GL version is 1.3 or greater.
        /// Non-power-of-two textures are supported if the GL version is 2.0 or greater, or if the implementation exports the <code>GL_ARB_texture_non_power_of_two</code> extension.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="internalformat"/> is one of the generic compressed internal formats: <code>GL_COMPRESSED_ALPHA</code>,
        /// <code>GL_COMPRESSED_LUMINANCE</code>, <code>GL_COMPRESSED_LUMINANCE_ALPHA</code>,
        /// <code>GL_COMPRESSED_INTENSITY</code>, <code>GL_COMPRESSED_RGB</code>, or
        /// <code>GL_COMPRESSED_RGBA</code>.
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="imageSize"/> is not consistent with
        /// the format, dimensions, and contents of the specified compressed image data.
        /// <code>GL_INVALID_OPERATION</code> is generated if parameter combinations are not
        /// supported by the specific compressed internal format as specified in the
        /// specific texture compression extension.
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_UNPACK_BUFFER</code> target and the buffer object's data store is currently mapped.
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_UNPACK_BUFFER</code> target and the data would be unpacked from the buffer 
        /// object such that the memory reads required would exceed the data store size.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glCompressedTexImage3D"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// Undefined results, including abnormal program termination, are generated if <paramref name="data"/> is not encoded in a manner consistent with the extension specification defining the internal compression format.
        /// </para>
        /// Original: <para>void glCompressedTexImage3D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const void * data);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target texture.
        /// Must be <code>GL_TEXTURE_3D</code> or <code>GL_PROXY_TEXTURE_3D</code>.
        /// </para>
        /// </param>
        /// <param name="level">
        /// <para>
        /// Specifies the level-of-detail number.
        /// Level 0 is the base image level.
        /// Level  n  is the  n th mipmap reduction image.
        /// </para>
        /// </param>
        /// <param name="internalformat">
        /// Specifies the format of the compressed image data stored at address <paramref name="data"/>.
        /// </param>
        /// <param name="width">
        /// <para>
        /// Specifies the width of the texture image including the border if any. If the GL version does not support non-power-of-two sizes, this value must be 
        /// 2 
        /// n 
        /// + 
        /// 2 
        /// &af; 
        /// border 
        /// for some integer 
        /// n   .
        /// All
        /// implementations support 3D texture images that are at least 16 texels
        /// wide.
        /// </para>
        /// </param>
        /// <param name="height">
        /// <para>
        /// Specifies the height of the texture image including the border if any. If the GL version does not support non-power-of-two sizes, this value must be 
        /// 2 
        /// n 
        /// + 
        /// 2 
        /// &af; 
        /// border 
        /// for some integer 
        /// n   .
        /// All
        /// implementations support 3D texture images that are at least 16 texels
        /// high.
        /// </para>
        /// </param>
        /// <param name="depth">
        /// <para>
        /// Specifies the depth of the texture image including the border if any. If the GL version does not support non-power-of-two sizes, this value must be 
        /// 2 
        /// n 
        /// + 
        /// 2 
        /// &af; 
        /// border 
        /// for some integer 
        /// n   .
        /// All
        /// implementations support 3D texture images that are at least 16 texels
        /// deep.
        /// </para>
        /// </param>
        /// <param name="border">
        /// <para>
        /// Specifies the width of the border.
        /// Must be either 0 or 1.
        /// </para>
        /// </param>
        /// <param name="imageSize">
        /// <para>
        /// Specifies the number of unsigned bytes of image data starting at the
        /// address specified by <paramref name="data"/>.
        /// </para>
        /// </param>
        /// <param name="data">
        /// Specifies a pointer to the compressed image data in memory.
        /// </param>
        /// <seealso cref="ActiveTexture"/>
        /// <seealso cref="ColorTable"/>
        /// <seealso cref="CompressedTexImage1D"/>
        /// <seealso cref="CompressedTexImage2D"/>
        /// <seealso cref="CompressedTexSubImage1D"/>
        /// <seealso cref="CompressedTexSubImage2D"/>
        /// <seealso cref="CompressedTexSubImage3D"/>
        /// <seealso cref="ConvolutionFilter1D"/>
        /// <seealso cref="CopyPixels"/>
        /// <seealso cref="CopyTexImage1D"/>
        /// <seealso cref="CopyTexSubImage1D"/>
        /// <seealso cref="CopyTexSubImage2D"/>
        /// <seealso cref="CopyTexSubImage3D"/>
        /// <seealso cref="DrawPixels"/>
        /// <seealso cref="MatrixMode"/>
        /// <seealso cref="PixelStore"/>
        /// <seealso cref="PixelTransfer"/>
        /// <seealso cref="TexEnv"/>
        /// <seealso cref="TexGen"/>
        /// <seealso cref="TexImage1D"/>
        /// <seealso cref="TexImage2D"/>
        /// <seealso cref="TexSubImage1D"/>
        /// <seealso cref="TexSubImage2D"/>
        /// <seealso cref="TexSubImage3D"/>
        /// <seealso cref="TexParameter"/>
        public unsafe static void CompressedTexImage3D(uint target, int level, uint internalformat, int width, int height, int depth, int border, int imageSize, IntPtr data) {
            GLNative.glCompressedTexImage3D(target, level, internalformat, width, height, depth, border, imageSize, (void*)data);
        }

        /// <summary>
        /// specify a two-dimensional texture image in a compressed format
        /// <para>Require:</para> <para>GL_VERSION_1_3, GL_VERSION_ES_CM_1_0, GL_ES_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glCompressedTexImage2D"/> is available only if the GL version is 1.3 or greater.
        /// Non-power-of-two textures are supported if the GL version is 2.0 or greater, or if the implementation exports the <code>GL_ARB_texture_non_power_of_two</code> extension.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="internalformat"/> is one of the generic compressed internal formats: <code>GL_COMPRESSED_ALPHA</code>,
        /// <code>GL_COMPRESSED_LUMINANCE</code>, <code>GL_COMPRESSED_LUMINANCE_ALPHA</code>,
        /// <code>GL_COMPRESSED_INTENSITY</code>, <code>GL_COMPRESSED_RGB</code>, or
        /// <code>GL_COMPRESSED_RGBA</code>.
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="imageSize"/> is not consistent with
        /// the format, dimensions, and contents of the specified compressed image
        /// data.
        /// <code>GL_INVALID_OPERATION</code> is generated if parameter combinations are not
        /// supported by the specific compressed internal format as specified in the
        /// specific texture compression extension.
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_UNPACK_BUFFER</code> target and the buffer object's data store is currently mapped.
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_UNPACK_BUFFER</code> target and the data would be unpacked from the buffer 
        /// object such that the memory reads required would exceed the data store size.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glCompressedTexImage2D"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// Undefined results, including abnormal program termination, are generated if
        /// <paramref name="data"/> is not encoded in a manner consistent with the extension
        /// specification defining the internal compression format.
        /// </para>
        /// Original: <para>void glCompressedTexImage2D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const void * data);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target texture.
        /// Must be <code>GL_TEXTURE_2D</code>, <code>GL_PROXY_TEXTURE_2D</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_POSITIVE_X</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_NEGATIVE_X</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_POSITIVE_Y</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_NEGATIVE_Y</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_POSITIVE_Z</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_NEGATIVE_Z</code>, or
        /// <code>GL_PROXY_TEXTURE_CUBE_MAP</code>.
        /// </para>
        /// </param>
        /// <param name="level">
        /// <para>
        /// Specifies the level-of-detail number.
        /// Level 0 is the base image level.
        /// Level  n  is the  n th mipmap reduction image.
        /// </para>
        /// </param>
        /// <param name="internalformat">
        /// Specifies the format of the compressed image data stored at address <paramref name="data"/>.
        /// </param>
        /// <param name="width">
        /// <para>
        /// Specifies the width of the texture image including the border if any. If the GL version does not support non-power-of-two sizes, this value must be 
        /// 2 
        /// n 
        /// + 
        /// 2 
        /// &af; 
        /// border 
        /// for some integer 
        /// n   .
        /// All
        /// implementations support 2D texture images that are at least 64 texels
        /// wide and cube-mapped texture images that are at least 16 texels wide.
        /// </para>
        /// </param>
        /// <param name="height">
        /// <para>
        /// Specifies the height of the texture image including the border if any. If the GL version does not support non-power-of-two sizes, this value must be 
        /// Must be 
        /// 2 
        /// n 
        /// + 
        /// 2 
        /// &af; 
        /// border 
        /// for some integer 
        /// n   .
        /// All
        /// implementations support 2D texture images that are at least 64 texels
        /// high and cube-mapped texture images that are at least 16 texels high.
        /// </para>
        /// </param>
        /// <param name="border">
        /// <para>
        /// Specifies the width of the border.
        /// Must be either 0 or 1.
        /// </para>
        /// </param>
        /// <param name="imageSize">
        /// <para>
        /// Specifies the number of unsigned bytes of image data starting at the
        /// address specified by <paramref name="data"/>.
        /// </para>
        /// </param>
        /// <param name="data">
        /// Specifies a pointer to the compressed image data in memory.
        /// </param>
        /// <seealso cref="ActiveTexture"/>
        /// <seealso cref="ColorTable"/>
        /// <seealso cref="CompressedTexImage1D"/>
        /// <seealso cref="CompressedTexImage3D"/>
        /// <seealso cref="CompressedTexSubImage1D"/>
        /// <seealso cref="CompressedTexSubImage2D"/>
        /// <seealso cref="CompressedTexSubImage3D"/>
        /// <seealso cref="ConvolutionFilter1D"/>
        /// <seealso cref="CopyPixels"/>
        /// <seealso cref="CopyTexImage1D"/>
        /// <seealso cref="CopyTexSubImage1D"/>
        /// <seealso cref="CopyTexSubImage2D"/>
        /// <seealso cref="CopyTexSubImage3D"/>
        /// <seealso cref="DrawPixels"/>
        /// <seealso cref="MatrixMode"/>
        /// <seealso cref="PixelStore"/>
        /// <seealso cref="PixelTransfer"/>
        /// <seealso cref="TexEnv"/>
        /// <seealso cref="TexGen"/>
        /// <seealso cref="TexImage2D"/>
        /// <seealso cref="TexImage3D"/>
        /// <seealso cref="TexSubImage1D"/>
        /// <seealso cref="TexSubImage2D"/>
        /// <seealso cref="TexSubImage3D"/>
        /// <seealso cref="TexParameter"/>
        public unsafe static void CompressedTexImage2D(uint target, int level, uint internalformat, int width, int height, int border, int imageSize, IntPtr data) {
            GLNative.glCompressedTexImage2D(target, level, internalformat, width, height, border, imageSize, (void*)data);
        }

        /// <summary>
        /// specify a one-dimensional texture image in a compressed format
        /// <para>Require:</para> <para>GL_VERSION_1_3</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glCompressedTexImage1D"/> is available only if the GL version is 1.3 or greater.
        /// Non-power-of-two textures are supported if the GL version is 2.0 or greater, or if the implementation exports the <code>GL_ARB_texture_non_power_of_two</code> extension.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="internalformat"/> is one of the generic compressed internal formats: <code>GL_COMPRESSED_ALPHA</code>,
        /// <code>GL_COMPRESSED_LUMINANCE</code>, <code>GL_COMPRESSED_LUMINANCE_ALPHA</code>,
        /// <code>GL_COMPRESSED_INTENSITY</code>, <code>GL_COMPRESSED_RGB</code>, or
        /// <code>GL_COMPRESSED_RGBA</code>.
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="imageSize"/> is not consistent with
        /// the format, dimensions, and contents of the specified compressed image
        /// data.
        /// <code>GL_INVALID_OPERATION</code> is generated if parameter combinations are not
        /// supported by the specific compressed internal format as specified in the
        /// specific texture compression extension.
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_UNPACK_BUFFER</code> target and the buffer object's data store is currently mapped.
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_UNPACK_BUFFER</code> target and the data would be unpacked from the buffer 
        /// object such that the memory reads required would exceed the data store size.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glCompressedTexImage1D"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// Undefined results, including abnormal program termination, are generated if
        /// <paramref name="data"/> is not encoded in a manner consistent with the extension
        /// specification defining the internal compression format.
        /// </para>
        /// Original: <para>void glCompressedTexImage1D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const void * data);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target texture.
        /// Must be <code>GL_TEXTURE_1D</code> or <code>GL_PROXY_TEXTURE_1D</code>.
        /// </para>
        /// </param>
        /// <param name="level">
        /// <para>
        /// Specifies the level-of-detail number.
        /// Level 0 is the base image level.
        /// Level  n  is the  n th mipmap reduction image.
        /// </para>
        /// </param>
        /// <param name="internalformat">
        /// Specifies the format of the compressed image data stored at address <paramref name="data"/>.
        /// </param>
        /// <param name="width">
        /// <para>
        /// Specifies the width of the texture image including the border if any. If the GL version does not support non-power-of-two sizes, this value must be 
        /// 2 
        /// n 
        /// + 
        /// 2 
        /// &af; 
        /// border 
        /// for some integer 
        /// n   .
        /// All implementations support texture images that are at least 64 texels wide. The height of the 1D texture image is 1.
        /// </para>
        /// </param>
        /// <param name="border">
        /// Specifies the width of the border. Must be either 0 or 1.
        /// </param>
        /// <param name="imageSize">
        /// Specifies the number of unsigned bytes of image data starting at the address specified by <paramref name="data"/>.
        /// </param>
        /// <param name="data">
        /// Specifies a pointer to the compressed image data in memory.
        /// </param>
        /// <seealso cref="ActiveTexture"/>
        /// <seealso cref="ColorTable"/>
        /// <seealso cref="CompressedTexImage2D"/>
        /// <seealso cref="CompressedTexImage3D"/>
        /// <seealso cref="CompressedTexSubImage1D"/>
        /// <seealso cref="CompressedTexSubImage2D"/>
        /// <seealso cref="CompressedTexSubImage3D"/>
        /// <seealso cref="ConvolutionFilter1D"/>
        /// <seealso cref="CopyPixels"/>
        /// <seealso cref="CopyTexImage1D"/>
        /// <seealso cref="CopyTexImage2D"/>
        /// <seealso cref="CopyTexSubImage1D"/>
        /// <seealso cref="CopyTexSubImage2D"/>
        /// <seealso cref="CopyTexSubImage3D"/>
        /// <seealso cref="DrawPixels"/>
        /// <seealso cref="MatrixMode"/>
        /// <seealso cref="PixelStore"/>
        /// <seealso cref="PixelTransfer"/>
        /// <seealso cref="TexEnv"/>
        /// <seealso cref="TexGen"/>
        /// <seealso cref="TexImage2D"/>
        /// <seealso cref="TexImage3D"/>
        /// <seealso cref="TexSubImage1D"/>
        /// <seealso cref="TexSubImage2D"/>
        /// <seealso cref="TexSubImage3D"/>
        /// <seealso cref="TexParameter"/>
        public unsafe static void CompressedTexImage1D(uint target, int level, uint internalformat, int width, int border, int imageSize, IntPtr data) {
            GLNative.glCompressedTexImage1D(target, level, internalformat, width, border, imageSize, (void*)data);
        }

        /// <summary>
        /// specify a three-dimensional texture subimage in a compressed format
        /// <para>Require:</para> <para>GL_VERSION_1_3, GL_ES_VERSION_3_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <see cref="glCompressedTexSubImage3D"/> is available only if the GL version is 1.3 or greater.
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="format"/> is one of these generic compressed internal formats: 
        /// <code>GL_COMPRESSED_ALPHA</code>,
        /// <code>GL_COMPRESSED_LUMINANCE</code>, 
        /// <code>GL_COMPRESSED_LUMINANCE_ALPHA</code>,
        /// <code>GL_COMPRESSED_INTENSITY</code>,             
        /// <code>GL_COMPRESSED_RGB</code>,
        /// <code>GL_COMPRESSED_RGBA</code>,
        /// <code>GL_COMPRESSED_SLUMINANCE</code>,
        /// <code>GL_COMPRESSED_SLUMINANCE_ALPHA</code>,
        /// <code>GL_COMPRESSED_SRGB</code>,
        /// <code>GL_COMPRESSED_SRGBA</code>, or
        /// <code>GL_COMPRESSED_SRGB_ALPHA</code>.
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="imageSize"/> is not consistent with
        /// the format, dimensions, and contents of the specified compressed image
        /// data.
        /// <code>GL_INVALID_OPERATION</code> is generated if parameter combinations are not
        /// supported by the specific compressed internal format as specified in the
        /// specific texture compression extension.
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_UNPACK_BUFFER</code> target and the buffer object's data store is currently mapped.
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_UNPACK_BUFFER</code> target and the data would be unpacked from the buffer 
        /// object such that the memory reads required would exceed the data store size.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glCompressedTexSubImage3D"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// Undefined results, including abnormal program termination, are generated if
        /// <paramref name="data"/> is not encoded in a manner consistent with the extension
        /// specification defining the internal compression format.
        /// </para>
        /// Original: <para>void glCompressedTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void * data);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target texture.
        /// Must be <code>GL_TEXTURE_3D</code>.
        /// </para>
        /// </param>
        /// <param name="level">
        /// <para>
        /// Specifies the level-of-detail number.
        /// Level 0 is the base image level.
        /// Level  n  is the  n th mipmap reduction image.
        /// </para>
        /// </param>
        /// <param name="xoffset">
        /// Specifies a texel offset in the x direction within the texture array.
        /// </param>
        /// <param name="yoffset">
        /// Specifies a texel offset in the y direction within the texture array.
        /// </param>
        /// <param name="width">
        /// Specifies the width of the texture subimage.
        /// </param>
        /// <param name="height">
        /// Specifies the height of the texture subimage.
        /// </param>
        /// <param name="depth">
        /// Specifies the depth of the texture subimage.
        /// </param>
        /// <param name="format">
        /// Specifies the format of the compressed image data stored at address <paramref name="data"/>.
        /// </param>
        /// <param name="imageSize">
        /// <para>
        /// Specifies the number of unsigned bytes of image data starting at the
        /// address specified by <paramref name="data"/>.
        /// </para>
        /// </param>
        /// <param name="data">
        /// Specifies a pointer to the compressed image data in memory.
        /// </param>
        /// <seealso cref="ActiveTexture"/>
        /// <seealso cref="ColorTable"/>
        /// <seealso cref="CompressedTexImage1D"/>
        /// <seealso cref="CompressedTexImage2D"/>
        /// <seealso cref="CompressedTexImage3D"/>
        /// <seealso cref="CompressedTexSubImage1D"/>
        /// <seealso cref="CompressedTexSubImage2D"/>
        /// <seealso cref="ConvolutionFilter1D"/>
        /// <seealso cref="CopyPixels"/>
        /// <seealso cref="CopyTexImage1D"/>
        /// <seealso cref="CopyTexImage2D"/>
        /// <seealso cref="CopyTexSubImage1D"/>
        /// <seealso cref="CopyTexSubImage2D"/>
        /// <seealso cref="CopyTexSubImage3D"/>
        /// <seealso cref="DrawPixels"/>
        /// <seealso cref="MatrixMode"/>
        /// <seealso cref="PixelStore"/>
        /// <seealso cref="PixelTransfer"/>
        /// <seealso cref="TexEnv"/>
        /// <seealso cref="TexGen"/>
        /// <seealso cref="TexImage2D"/>
        /// <seealso cref="TexImage3D"/>
        /// <seealso cref="TexSubImage1D"/>
        /// <seealso cref="TexSubImage2D"/>
        /// <seealso cref="TexSubImage3D"/>
        /// <seealso cref="TexParameter"/>
        public unsafe static void CompressedTexSubImage3D(uint target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, uint format, int imageSize, IntPtr data) {
            GLNative.glCompressedTexSubImage3D(target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, (void*)data);
        }

        /// <summary>
        /// specify a two-dimensional texture subimage in a compressed format
        /// <para>Require:</para> <para>GL_VERSION_1_3, GL_VERSION_ES_CM_1_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glCompressedTexSubImage2D"/> is available only if the GL version is 1.3 or greater.
        /// <code>GL_TEXTURE_CUBE_MAP_POSITIVE_X</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_NEGATIVE_X</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_POSITIVE_Y</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_NEGATIVE_Y</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_POSITIVE_Z</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_NEGATIVE_Z</code>, or
        /// <code>GL_PROXY_TEXTURE_CUBE_MAP</code> are available only if the GL version is 1.3
        /// or greater.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="format"/> is one of these generic compressed internal formats: 
        /// <code>GL_COMPRESSED_ALPHA</code>,
        /// <code>GL_COMPRESSED_LUMINANCE</code>, 
        /// <code>GL_COMPRESSED_LUMINANCE_ALPHA</code>,
        /// <code>GL_COMPRESSED_INTENSITY</code>,             
        /// <code>GL_COMPRESSED_RGB</code>,
        /// <code>GL_COMPRESSED_RGBA</code>,
        /// <code>GL_COMPRESSED_SLUMINANCE</code>,
        /// <code>GL_COMPRESSED_SLUMINANCE_ALPHA</code>,
        /// <code>GL_COMPRESSED_SRGB</code>,
        /// <code>GL_COMPRESSED_SRGBA</code>, or
        /// <code>GL_COMPRESSED_SRGB_ALPHA</code>.
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="imageSize"/> is not consistent with
        /// the format, dimensions, and contents of the specified compressed image
        /// data.
        /// <code>GL_INVALID_OPERATION</code> is generated if parameter combinations are not
        /// supported by the specific compressed internal format as specified in the
        /// specific texture compression extension.
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_UNPACK_BUFFER</code> target and the buffer object's data store is currently mapped.
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_UNPACK_BUFFER</code> target and the data would be unpacked from the buffer 
        /// object such that the memory reads required would exceed the data store size.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glCompressedTexSubImage2D"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// Undefined results, including abnormal program termination, are generated if
        /// <paramref name="data"/> is not encoded in a manner consistent with the extension
        /// specification defining the internal compression format.
        /// </para>
        /// Original: <para>void glCompressedTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void * data);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target texture.
        /// Must be <code>GL_TEXTURE_2D</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_POSITIVE_X</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_NEGATIVE_X</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_POSITIVE_Y</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_NEGATIVE_Y</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_POSITIVE_Z</code>, or
        /// <code>GL_TEXTURE_CUBE_MAP_NEGATIVE_Z</code>.
        /// </para>
        /// </param>
        /// <param name="level">
        /// <para>
        /// Specifies the level-of-detail number.
        /// Level 0 is the base image level.
        /// Level  n  is the  n th mipmap reduction image.
        /// </para>
        /// </param>
        /// <param name="xoffset">
        /// Specifies a texel offset in the x direction within the texture array.
        /// </param>
        /// <param name="yoffset">
        /// Specifies a texel offset in the y direction within the texture array.
        /// </param>
        /// <param name="width">
        /// Specifies the width of the texture subimage.
        /// </param>
        /// <param name="height">
        /// Specifies the height of the texture subimage.
        /// </param>
        /// <param name="format">
        /// Specifies the format of the compressed image data stored at address <paramref name="data"/>.
        /// </param>
        /// <param name="imageSize">
        /// <para>
        /// Specifies the number of unsigned bytes of image data starting at the
        /// address specified by <paramref name="data"/>.
        /// </para>
        /// </param>
        /// <param name="data">
        /// Specifies a pointer to the compressed image data in memory.
        /// </param>
        /// <seealso cref="ActiveTexture"/>
        /// <seealso cref="ColorTable"/>
        /// <seealso cref="CompressedTexImage1D"/>
        /// <seealso cref="CompressedTexImage2D"/>
        /// <seealso cref="CompressedTexImage3D"/>
        /// <seealso cref="CompressedTexSubImage1D"/>
        /// <seealso cref="CompressedTexSubImage3D"/>
        /// <seealso cref="ConvolutionFilter1D"/>
        /// <seealso cref="CopyPixels"/>
        /// <seealso cref="CopyTexImage1D"/>
        /// <seealso cref="CopyTexImage2D"/>
        /// <seealso cref="CopyTexSubImage1D"/>
        /// <seealso cref="CopyTexSubImage2D"/>
        /// <seealso cref="CopyTexSubImage3D"/>
        /// <seealso cref="DrawPixels"/>
        /// <seealso cref="MatrixMode"/>
        /// <seealso cref="PixelStore"/>
        /// <seealso cref="PixelTransfer"/>
        /// <seealso cref="TexEnv"/>
        /// <seealso cref="TexGen"/>
        /// <seealso cref="TexImage2D"/>
        /// <seealso cref="TexImage3D"/>
        /// <seealso cref="TexSubImage1D"/>
        /// <seealso cref="TexSubImage2D"/>
        /// <seealso cref="TexSubImage3D"/>
        /// <seealso cref="TexParameter"/>
        public unsafe static void CompressedTexSubImage2D(uint target, int level, int xoffset, int yoffset, int width, int height, uint format, int imageSize, IntPtr data) {
            GLNative.glCompressedTexSubImage2D(target, level, xoffset, yoffset, width, height, format, imageSize, (void*)data);
        }

        /// <summary>
        /// specify a one-dimensional texture subimage in a compressed format
        /// <para>Require:</para> <para>GL_VERSION_1_3</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <see cref="glCompressedTexSubImage1D"/> is available only if the GL version is 1.3 or greater.
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="format"/> is one of these generic compressed internal formats: 
        /// <code>GL_COMPRESSED_ALPHA</code>,
        /// <code>GL_COMPRESSED_LUMINANCE</code>, 
        /// <code>GL_COMPRESSED_LUMINANCE_ALPHA</code>,
        /// <code>GL_COMPRESSED_INTENSITY</code>,             
        /// <code>GL_COMPRESSED_RGB</code>,
        /// <code>GL_COMPRESSED_RGBA</code>,
        /// <code>GL_COMPRESSED_SLUMINANCE</code>,
        /// <code>GL_COMPRESSED_SLUMINANCE_ALPHA</code>,
        /// <code>GL_COMPRESSED_SRGB</code>,
        /// <code>GL_COMPRESSED_SRGBA</code>, or
        /// <code>GL_COMPRESSED_SRGB_ALPHA</code>.
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="imageSize"/> is not consistent with
        /// the format, dimensions, and contents of the specified compressed image
        /// data.
        /// <code>GL_INVALID_OPERATION</code> is generated if parameter combinations are not
        /// supported by the specific compressed internal format as specified in the
        /// specific texture compression extension.
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_UNPACK_BUFFER</code> target and the buffer object's data store is currently mapped.
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_UNPACK_BUFFER</code> target and the data would be unpacked from the buffer 
        /// object such that the memory reads required would exceed the data store size.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glCompressedTexSubImage1D"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// Undefined results, including abnormal program termination, are generated if
        /// <paramref name="data"/> is not encoded in a manner consistent with the extension
        /// specification defining the internal compression format.
        /// </para>
        /// Original: <para>void glCompressedTexSubImage1D(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const void * data);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target texture.
        /// Must be <code>GL_TEXTURE_1D</code>.
        /// </para>
        /// </param>
        /// <param name="level">
        /// <para>
        /// Specifies the level-of-detail number.
        /// Level 0 is the base image level.
        /// Level  n  is the  n th mipmap reduction image.
        /// </para>
        /// </param>
        /// <param name="xoffset">
        /// Specifies a texel offset in the x direction within the texture array.
        /// </param>
        /// <param name="width">
        /// Specifies the width of the texture subimage.
        /// </param>
        /// <param name="format">
        /// Specifies the format of the compressed image data stored at address <paramref name="data"/>.
        /// </param>
        /// <param name="imageSize">
        /// <para>
        /// Specifies the number of unsigned bytes of image data starting at the
        /// address specified by <paramref name="data"/>.
        /// </para>
        /// </param>
        /// <param name="data">
        /// Specifies a pointer to the compressed image data in memory.
        /// </param>
        /// <seealso cref="ActiveTexture"/>
        /// <seealso cref="ColorTable"/>
        /// <seealso cref="CompressedTexImage1D"/>
        /// <seealso cref="CompressedTexImage2D"/>
        /// <seealso cref="CompressedTexImage3D"/>
        /// <seealso cref="CompressedTexSubImage2D"/>
        /// <seealso cref="CompressedTexSubImage3D"/>
        /// <seealso cref="ConvolutionFilter1D"/>
        /// <seealso cref="CopyPixels"/>
        /// <seealso cref="CopyTexImage1D"/>
        /// <seealso cref="CopyTexImage2D"/>
        /// <seealso cref="CopyTexSubImage1D"/>
        /// <seealso cref="CopyTexSubImage2D"/>
        /// <seealso cref="CopyTexSubImage3D"/>
        /// <seealso cref="DrawPixels"/>
        /// <seealso cref="MatrixMode"/>
        /// <seealso cref="PixelStore"/>
        /// <seealso cref="PixelTransfer"/>
        /// <seealso cref="TexEnv"/>
        /// <seealso cref="TexGen"/>
        /// <seealso cref="TexImage2D"/>
        /// <seealso cref="TexImage3D"/>
        /// <seealso cref="TexSubImage1D"/>
        /// <seealso cref="TexSubImage2D"/>
        /// <seealso cref="TexSubImage3D"/>
        /// <seealso cref="TexParameter"/>
        public unsafe static void CompressedTexSubImage1D(uint target, int level, int xoffset, int width, uint format, int imageSize, IntPtr data) {
            GLNative.glCompressedTexSubImage1D(target, level, xoffset, width, format, imageSize, (void*)data);
        }

        /// <summary>
        /// return a compressed texture image
        /// <para>Require:</para> <para>GL_VERSION_1_3</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <see cref="glGetCompressedTexImage"/> is available only if the GL version is 1.3 or greater.
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="lod"/> is less than zero or greater
        /// than the maximum number of LODs permitted by the implementation.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glGetCompressedTexImage"/> is used to retrieve a
        /// texture that is in an uncompressed internal format.
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_PACK_BUFFER</code> target and the buffer object's data store is currently mapped.
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_PACK_BUFFER</code> target and the data would be packed to the buffer 
        /// object such that the memory writes required would exceed the data store size.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glGetCompressedTexImage"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glGetCompressedTexImage(GLenum target, GLint lod, void * img);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies which texture is to be obtained.
        /// <code>GL_TEXTURE_1D</code>, <code>GL_TEXTURE_2D</code>, and <code>GL_TEXTURE_3D</code>
        /// <code>GL_TEXTURE_CUBE_MAP_POSITIVE_X</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_NEGATIVE_X</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_POSITIVE_Y</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_NEGATIVE_Y</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_POSITIVE_Z</code>, and
        /// <code>GL_TEXTURE_CUBE_MAP_NEGATIVE_Z</code>
        /// are accepted.
        /// </para>
        /// </param>
        /// <param name="lod">
        /// <para>
        /// Specifies the level-of-detail number of the desired image.
        /// Level 0 is the base image level.
        /// Level 
        /// n   
        /// is the 
        /// n   th
        /// mipmap reduction image.
        /// </para>
        /// </param>
        /// <param name="img">
        /// Returns the compressed texture image.
        /// </param>
        /// <seealso cref="ActiveTexture"/>
        /// <seealso cref="CompressedTexImage1D"/>
        /// <seealso cref="CompressedTexImage2D"/>
        /// <seealso cref="CompressedTexImage3D"/>
        /// <seealso cref="CompressedTexSubImage1D"/>
        /// <seealso cref="CompressedTexSubImage2D"/>
        /// <seealso cref="CompressedTexSubImage3D"/>
        /// <seealso cref="DrawPixels"/>
        /// <seealso cref="ReadPixels"/>
        /// <seealso cref="TexEnv"/>
        /// <seealso cref="TexGen"/>
        /// <seealso cref="TexImage1D"/>
        /// <seealso cref="TexImage2D"/>
        /// <seealso cref="TexImage3D"/>
        /// <seealso cref="TexParameter"/>
        /// <seealso cref="TexSubImage1D"/>
        /// <seealso cref="TexSubImage2D"/>
        /// <seealso cref="TexSubImage3D"/>
        public unsafe static void GetCompressedTexImage(uint target, int lod, IntPtr img) {
            GLNative.glGetCompressedTexImage(target, lod, (void*)img);
        }

        /// <summary>
        /// set the current texture coordinates
        /// <para>Require:</para> <para>GL_VERSION_1_3</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glMultiTexCoord"/> is only supported if the GL version is 1.3 or greater, or if
        /// <code>ARB_multitexture</code> is included in the string returned by
        /// <see cref="glGetString"/>  when called with the argument <code>GL_EXTENSIONS</code>.
        /// The current texture coordinates can be updated at any time.
        /// In particular,
        /// <see cref="glMultiTexCoord"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// It is always the case that <code>GL_TEXTURE</code>
        /// i   
        /// = <code>GL_TEXTURE0</code> + 
        /// i   .
        /// </para>
        /// Original: <para>void glMultiTexCoord1dv(GLenum target, const GLdouble * v);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the texture unit whose coordinates should be modified. The number
        /// of texture units is implementation dependent, but must be at least
        /// two. Symbolic constant must be one of 
        /// <code>GL_TEXTURE</code>   i   ,
        /// where i ranges from 0 to <code>GL_MAX_TEXTURE_COORDS</code> - 1,
        /// which is an implementation-dependent value.
        /// </para>
        /// </param>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array of one, two, three, or four elements,
        /// which in turn specify the 
        /// s   ,
        /// t   ,
        /// r   ,
        /// and 
        /// q   
        /// texture coordinates.
        /// </para>
        /// </param>
        /// <seealso cref="ActiveTexture"/>
        /// <seealso cref="ClientActiveTexture"/>
        /// <seealso cref="TexCoord"/>
        /// <seealso cref="TexCoordPointer"/>
        /// <seealso cref="Vertex"/>
        [Obsolete("Compatibility-only GL 1.3 features removed from GL 3.2")]
        public unsafe static void MultiTexCoord1dv(uint target, ref double v) {
            fixed (double* pV = &v) {
                GLNative.glMultiTexCoord1dv(target, pV);
            }
        }

        /// <summary>
        /// set the current texture coordinates
        /// <para>Require:</para> <para>GL_VERSION_1_3</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glMultiTexCoord"/> is only supported if the GL version is 1.3 or greater, or if
        /// <code>ARB_multitexture</code> is included in the string returned by
        /// <see cref="glGetString"/>  when called with the argument <code>GL_EXTENSIONS</code>.
        /// The current texture coordinates can be updated at any time.
        /// In particular,
        /// <see cref="glMultiTexCoord"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// It is always the case that <code>GL_TEXTURE</code>
        /// i   
        /// = <code>GL_TEXTURE0</code> + 
        /// i   .
        /// </para>
        /// Original: <para>void glMultiTexCoord1fv(GLenum target, const GLfloat * v);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the texture unit whose coordinates should be modified. The number
        /// of texture units is implementation dependent, but must be at least
        /// two. Symbolic constant must be one of 
        /// <code>GL_TEXTURE</code>   i   ,
        /// where i ranges from 0 to <code>GL_MAX_TEXTURE_COORDS</code> - 1,
        /// which is an implementation-dependent value.
        /// </para>
        /// </param>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array of one, two, three, or four elements,
        /// which in turn specify the 
        /// s   ,
        /// t   ,
        /// r   ,
        /// and 
        /// q   
        /// texture coordinates.
        /// </para>
        /// </param>
        /// <seealso cref="ActiveTexture"/>
        /// <seealso cref="ClientActiveTexture"/>
        /// <seealso cref="TexCoord"/>
        /// <seealso cref="TexCoordPointer"/>
        /// <seealso cref="Vertex"/>
        [Obsolete("Compatibility-only GL 1.3 features removed from GL 3.2")]
        public unsafe static void MultiTexCoord1fv(uint target, ref float v) {
            fixed (float* pV = &v) {
                GLNative.glMultiTexCoord1fv(target, pV);
            }
        }

        /// <summary>
        /// set the current texture coordinates
        /// <para>Require:</para> <para>GL_VERSION_1_3</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glMultiTexCoord"/> is only supported if the GL version is 1.3 or greater, or if
        /// <code>ARB_multitexture</code> is included in the string returned by
        /// <see cref="glGetString"/>  when called with the argument <code>GL_EXTENSIONS</code>.
        /// The current texture coordinates can be updated at any time.
        /// In particular,
        /// <see cref="glMultiTexCoord"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// It is always the case that <code>GL_TEXTURE</code>
        /// i   
        /// = <code>GL_TEXTURE0</code> + 
        /// i   .
        /// </para>
        /// Original: <para>void glMultiTexCoord1iv(GLenum target, const GLint * v);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the texture unit whose coordinates should be modified. The number
        /// of texture units is implementation dependent, but must be at least
        /// two. Symbolic constant must be one of 
        /// <code>GL_TEXTURE</code>   i   ,
        /// where i ranges from 0 to <code>GL_MAX_TEXTURE_COORDS</code> - 1,
        /// which is an implementation-dependent value.
        /// </para>
        /// </param>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array of one, two, three, or four elements,
        /// which in turn specify the 
        /// s   ,
        /// t   ,
        /// r   ,
        /// and 
        /// q   
        /// texture coordinates.
        /// </para>
        /// </param>
        /// <seealso cref="ActiveTexture"/>
        /// <seealso cref="ClientActiveTexture"/>
        /// <seealso cref="TexCoord"/>
        /// <seealso cref="TexCoordPointer"/>
        /// <seealso cref="Vertex"/>
        [Obsolete("Compatibility-only GL 1.3 features removed from GL 3.2")]
        public unsafe static void MultiTexCoord1iv(uint target, ref int v) {
            fixed (int* pV = &v) {
                GLNative.glMultiTexCoord1iv(target, pV);
            }
        }

        /// <summary>
        /// set the current texture coordinates
        /// <para>Require:</para> <para>GL_VERSION_1_3</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glMultiTexCoord"/> is only supported if the GL version is 1.3 or greater, or if
        /// <code>ARB_multitexture</code> is included in the string returned by
        /// <see cref="glGetString"/>  when called with the argument <code>GL_EXTENSIONS</code>.
        /// The current texture coordinates can be updated at any time.
        /// In particular,
        /// <see cref="glMultiTexCoord"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// It is always the case that <code>GL_TEXTURE</code>
        /// i   
        /// = <code>GL_TEXTURE0</code> + 
        /// i   .
        /// </para>
        /// Original: <para>void glMultiTexCoord1sv(GLenum target, const GLshort * v);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the texture unit whose coordinates should be modified. The number
        /// of texture units is implementation dependent, but must be at least
        /// two. Symbolic constant must be one of 
        /// <code>GL_TEXTURE</code>   i   ,
        /// where i ranges from 0 to <code>GL_MAX_TEXTURE_COORDS</code> - 1,
        /// which is an implementation-dependent value.
        /// </para>
        /// </param>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array of one, two, three, or four elements,
        /// which in turn specify the 
        /// s   ,
        /// t   ,
        /// r   ,
        /// and 
        /// q   
        /// texture coordinates.
        /// </para>
        /// </param>
        /// <seealso cref="ActiveTexture"/>
        /// <seealso cref="ClientActiveTexture"/>
        /// <seealso cref="TexCoord"/>
        /// <seealso cref="TexCoordPointer"/>
        /// <seealso cref="Vertex"/>
        [Obsolete("Compatibility-only GL 1.3 features removed from GL 3.2")]
        public unsafe static void MultiTexCoord1sv(uint target, ref short v) {
            fixed (short* pV = &v) {
                GLNative.glMultiTexCoord1sv(target, pV);
            }
        }

        /// <summary>
        /// set the current texture coordinates
        /// <para>Require:</para> <para>GL_VERSION_1_3</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glMultiTexCoord"/> is only supported if the GL version is 1.3 or greater, or if
        /// <code>ARB_multitexture</code> is included in the string returned by
        /// <see cref="glGetString"/>  when called with the argument <code>GL_EXTENSIONS</code>.
        /// The current texture coordinates can be updated at any time.
        /// In particular,
        /// <see cref="glMultiTexCoord"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// It is always the case that <code>GL_TEXTURE</code>
        /// i   
        /// = <code>GL_TEXTURE0</code> + 
        /// i   .
        /// </para>
        /// Original: <para>void glMultiTexCoord2dv(GLenum target, const GLdouble * v);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the texture unit whose coordinates should be modified. The number
        /// of texture units is implementation dependent, but must be at least
        /// two. Symbolic constant must be one of 
        /// <code>GL_TEXTURE</code>   i   ,
        /// where i ranges from 0 to <code>GL_MAX_TEXTURE_COORDS</code> - 1,
        /// which is an implementation-dependent value.
        /// </para>
        /// </param>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array of one, two, three, or four elements,
        /// which in turn specify the 
        /// s   ,
        /// t   ,
        /// r   ,
        /// and 
        /// q   
        /// texture coordinates.
        /// </para>
        /// </param>
        /// <seealso cref="ActiveTexture"/>
        /// <seealso cref="ClientActiveTexture"/>
        /// <seealso cref="TexCoord"/>
        /// <seealso cref="TexCoordPointer"/>
        /// <seealso cref="Vertex"/>
        [Obsolete("Compatibility-only GL 1.3 features removed from GL 3.2")]
        public unsafe static void MultiTexCoord2dv(uint target, ref double v) {
            fixed (double* pV = &v) {
                GLNative.glMultiTexCoord2dv(target, pV);
            }
        }

        /// <summary>
        /// set the current texture coordinates
        /// <para>Require:</para> <para>GL_VERSION_1_3</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glMultiTexCoord"/> is only supported if the GL version is 1.3 or greater, or if
        /// <code>ARB_multitexture</code> is included in the string returned by
        /// <see cref="glGetString"/>  when called with the argument <code>GL_EXTENSIONS</code>.
        /// The current texture coordinates can be updated at any time.
        /// In particular,
        /// <see cref="glMultiTexCoord"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// It is always the case that <code>GL_TEXTURE</code>
        /// i   
        /// = <code>GL_TEXTURE0</code> + 
        /// i   .
        /// </para>
        /// Original: <para>void glMultiTexCoord2fv(GLenum target, const GLfloat * v);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the texture unit whose coordinates should be modified. The number
        /// of texture units is implementation dependent, but must be at least
        /// two. Symbolic constant must be one of 
        /// <code>GL_TEXTURE</code>   i   ,
        /// where i ranges from 0 to <code>GL_MAX_TEXTURE_COORDS</code> - 1,
        /// which is an implementation-dependent value.
        /// </para>
        /// </param>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array of one, two, three, or four elements,
        /// which in turn specify the 
        /// s   ,
        /// t   ,
        /// r   ,
        /// and 
        /// q   
        /// texture coordinates.
        /// </para>
        /// </param>
        /// <seealso cref="ActiveTexture"/>
        /// <seealso cref="ClientActiveTexture"/>
        /// <seealso cref="TexCoord"/>
        /// <seealso cref="TexCoordPointer"/>
        /// <seealso cref="Vertex"/>
        [Obsolete("Compatibility-only GL 1.3 features removed from GL 3.2")]
        public unsafe static void MultiTexCoord2fv(uint target, ref float v) {
            fixed (float* pV = &v) {
                GLNative.glMultiTexCoord2fv(target, pV);
            }
        }

        /// <summary>
        /// set the current texture coordinates
        /// <para>Require:</para> <para>GL_VERSION_1_3</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glMultiTexCoord"/> is only supported if the GL version is 1.3 or greater, or if
        /// <code>ARB_multitexture</code> is included in the string returned by
        /// <see cref="glGetString"/>  when called with the argument <code>GL_EXTENSIONS</code>.
        /// The current texture coordinates can be updated at any time.
        /// In particular,
        /// <see cref="glMultiTexCoord"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// It is always the case that <code>GL_TEXTURE</code>
        /// i   
        /// = <code>GL_TEXTURE0</code> + 
        /// i   .
        /// </para>
        /// Original: <para>void glMultiTexCoord2iv(GLenum target, const GLint * v);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the texture unit whose coordinates should be modified. The number
        /// of texture units is implementation dependent, but must be at least
        /// two. Symbolic constant must be one of 
        /// <code>GL_TEXTURE</code>   i   ,
        /// where i ranges from 0 to <code>GL_MAX_TEXTURE_COORDS</code> - 1,
        /// which is an implementation-dependent value.
        /// </para>
        /// </param>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array of one, two, three, or four elements,
        /// which in turn specify the 
        /// s   ,
        /// t   ,
        /// r   ,
        /// and 
        /// q   
        /// texture coordinates.
        /// </para>
        /// </param>
        /// <seealso cref="ActiveTexture"/>
        /// <seealso cref="ClientActiveTexture"/>
        /// <seealso cref="TexCoord"/>
        /// <seealso cref="TexCoordPointer"/>
        /// <seealso cref="Vertex"/>
        [Obsolete("Compatibility-only GL 1.3 features removed from GL 3.2")]
        public unsafe static void MultiTexCoord2iv(uint target, ref int v) {
            fixed (int* pV = &v) {
                GLNative.glMultiTexCoord2iv(target, pV);
            }
        }

        /// <summary>
        /// set the current texture coordinates
        /// <para>Require:</para> <para>GL_VERSION_1_3</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glMultiTexCoord"/> is only supported if the GL version is 1.3 or greater, or if
        /// <code>ARB_multitexture</code> is included in the string returned by
        /// <see cref="glGetString"/>  when called with the argument <code>GL_EXTENSIONS</code>.
        /// The current texture coordinates can be updated at any time.
        /// In particular,
        /// <see cref="glMultiTexCoord"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// It is always the case that <code>GL_TEXTURE</code>
        /// i   
        /// = <code>GL_TEXTURE0</code> + 
        /// i   .
        /// </para>
        /// Original: <para>void glMultiTexCoord2sv(GLenum target, const GLshort * v);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the texture unit whose coordinates should be modified. The number
        /// of texture units is implementation dependent, but must be at least
        /// two. Symbolic constant must be one of 
        /// <code>GL_TEXTURE</code>   i   ,
        /// where i ranges from 0 to <code>GL_MAX_TEXTURE_COORDS</code> - 1,
        /// which is an implementation-dependent value.
        /// </para>
        /// </param>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array of one, two, three, or four elements,
        /// which in turn specify the 
        /// s   ,
        /// t   ,
        /// r   ,
        /// and 
        /// q   
        /// texture coordinates.
        /// </para>
        /// </param>
        /// <seealso cref="ActiveTexture"/>
        /// <seealso cref="ClientActiveTexture"/>
        /// <seealso cref="TexCoord"/>
        /// <seealso cref="TexCoordPointer"/>
        /// <seealso cref="Vertex"/>
        [Obsolete("Compatibility-only GL 1.3 features removed from GL 3.2")]
        public unsafe static void MultiTexCoord2sv(uint target, ref short v) {
            fixed (short* pV = &v) {
                GLNative.glMultiTexCoord2sv(target, pV);
            }
        }

        /// <summary>
        /// set the current texture coordinates
        /// <para>Require:</para> <para>GL_VERSION_1_3</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glMultiTexCoord"/> is only supported if the GL version is 1.3 or greater, or if
        /// <code>ARB_multitexture</code> is included in the string returned by
        /// <see cref="glGetString"/>  when called with the argument <code>GL_EXTENSIONS</code>.
        /// The current texture coordinates can be updated at any time.
        /// In particular,
        /// <see cref="glMultiTexCoord"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// It is always the case that <code>GL_TEXTURE</code>
        /// i   
        /// = <code>GL_TEXTURE0</code> + 
        /// i   .
        /// </para>
        /// Original: <para>void glMultiTexCoord3dv(GLenum target, const GLdouble * v);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the texture unit whose coordinates should be modified. The number
        /// of texture units is implementation dependent, but must be at least
        /// two. Symbolic constant must be one of 
        /// <code>GL_TEXTURE</code>   i   ,
        /// where i ranges from 0 to <code>GL_MAX_TEXTURE_COORDS</code> - 1,
        /// which is an implementation-dependent value.
        /// </para>
        /// </param>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array of one, two, three, or four elements,
        /// which in turn specify the 
        /// s   ,
        /// t   ,
        /// r   ,
        /// and 
        /// q   
        /// texture coordinates.
        /// </para>
        /// </param>
        /// <seealso cref="ActiveTexture"/>
        /// <seealso cref="ClientActiveTexture"/>
        /// <seealso cref="TexCoord"/>
        /// <seealso cref="TexCoordPointer"/>
        /// <seealso cref="Vertex"/>
        [Obsolete("Compatibility-only GL 1.3 features removed from GL 3.2")]
        public unsafe static void MultiTexCoord3dv(uint target, ref double v) {
            fixed (double* pV = &v) {
                GLNative.glMultiTexCoord3dv(target, pV);
            }
        }

        /// <summary>
        /// set the current texture coordinates
        /// <para>Require:</para> <para>GL_VERSION_1_3</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glMultiTexCoord"/> is only supported if the GL version is 1.3 or greater, or if
        /// <code>ARB_multitexture</code> is included in the string returned by
        /// <see cref="glGetString"/>  when called with the argument <code>GL_EXTENSIONS</code>.
        /// The current texture coordinates can be updated at any time.
        /// In particular,
        /// <see cref="glMultiTexCoord"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// It is always the case that <code>GL_TEXTURE</code>
        /// i   
        /// = <code>GL_TEXTURE0</code> + 
        /// i   .
        /// </para>
        /// Original: <para>void glMultiTexCoord3fv(GLenum target, const GLfloat * v);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the texture unit whose coordinates should be modified. The number
        /// of texture units is implementation dependent, but must be at least
        /// two. Symbolic constant must be one of 
        /// <code>GL_TEXTURE</code>   i   ,
        /// where i ranges from 0 to <code>GL_MAX_TEXTURE_COORDS</code> - 1,
        /// which is an implementation-dependent value.
        /// </para>
        /// </param>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array of one, two, three, or four elements,
        /// which in turn specify the 
        /// s   ,
        /// t   ,
        /// r   ,
        /// and 
        /// q   
        /// texture coordinates.
        /// </para>
        /// </param>
        /// <seealso cref="ActiveTexture"/>
        /// <seealso cref="ClientActiveTexture"/>
        /// <seealso cref="TexCoord"/>
        /// <seealso cref="TexCoordPointer"/>
        /// <seealso cref="Vertex"/>
        [Obsolete("Compatibility-only GL 1.3 features removed from GL 3.2")]
        public unsafe static void MultiTexCoord3fv(uint target, ref float v) {
            fixed (float* pV = &v) {
                GLNative.glMultiTexCoord3fv(target, pV);
            }
        }

        /// <summary>
        /// set the current texture coordinates
        /// <para>Require:</para> <para>GL_VERSION_1_3</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glMultiTexCoord"/> is only supported if the GL version is 1.3 or greater, or if
        /// <code>ARB_multitexture</code> is included in the string returned by
        /// <see cref="glGetString"/>  when called with the argument <code>GL_EXTENSIONS</code>.
        /// The current texture coordinates can be updated at any time.
        /// In particular,
        /// <see cref="glMultiTexCoord"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// It is always the case that <code>GL_TEXTURE</code>
        /// i   
        /// = <code>GL_TEXTURE0</code> + 
        /// i   .
        /// </para>
        /// Original: <para>void glMultiTexCoord3iv(GLenum target, const GLint * v);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the texture unit whose coordinates should be modified. The number
        /// of texture units is implementation dependent, but must be at least
        /// two. Symbolic constant must be one of 
        /// <code>GL_TEXTURE</code>   i   ,
        /// where i ranges from 0 to <code>GL_MAX_TEXTURE_COORDS</code> - 1,
        /// which is an implementation-dependent value.
        /// </para>
        /// </param>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array of one, two, three, or four elements,
        /// which in turn specify the 
        /// s   ,
        /// t   ,
        /// r   ,
        /// and 
        /// q   
        /// texture coordinates.
        /// </para>
        /// </param>
        /// <seealso cref="ActiveTexture"/>
        /// <seealso cref="ClientActiveTexture"/>
        /// <seealso cref="TexCoord"/>
        /// <seealso cref="TexCoordPointer"/>
        /// <seealso cref="Vertex"/>
        [Obsolete("Compatibility-only GL 1.3 features removed from GL 3.2")]
        public unsafe static void MultiTexCoord3iv(uint target, ref int v) {
            fixed (int* pV = &v) {
                GLNative.glMultiTexCoord3iv(target, pV);
            }
        }

        /// <summary>
        /// set the current texture coordinates
        /// <para>Require:</para> <para>GL_VERSION_1_3</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glMultiTexCoord"/> is only supported if the GL version is 1.3 or greater, or if
        /// <code>ARB_multitexture</code> is included in the string returned by
        /// <see cref="glGetString"/>  when called with the argument <code>GL_EXTENSIONS</code>.
        /// The current texture coordinates can be updated at any time.
        /// In particular,
        /// <see cref="glMultiTexCoord"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// It is always the case that <code>GL_TEXTURE</code>
        /// i   
        /// = <code>GL_TEXTURE0</code> + 
        /// i   .
        /// </para>
        /// Original: <para>void glMultiTexCoord3sv(GLenum target, const GLshort * v);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the texture unit whose coordinates should be modified. The number
        /// of texture units is implementation dependent, but must be at least
        /// two. Symbolic constant must be one of 
        /// <code>GL_TEXTURE</code>   i   ,
        /// where i ranges from 0 to <code>GL_MAX_TEXTURE_COORDS</code> - 1,
        /// which is an implementation-dependent value.
        /// </para>
        /// </param>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array of one, two, three, or four elements,
        /// which in turn specify the 
        /// s   ,
        /// t   ,
        /// r   ,
        /// and 
        /// q   
        /// texture coordinates.
        /// </para>
        /// </param>
        /// <seealso cref="ActiveTexture"/>
        /// <seealso cref="ClientActiveTexture"/>
        /// <seealso cref="TexCoord"/>
        /// <seealso cref="TexCoordPointer"/>
        /// <seealso cref="Vertex"/>
        [Obsolete("Compatibility-only GL 1.3 features removed from GL 3.2")]
        public unsafe static void MultiTexCoord3sv(uint target, ref short v) {
            fixed (short* pV = &v) {
                GLNative.glMultiTexCoord3sv(target, pV);
            }
        }

        /// <summary>
        /// set the current texture coordinates
        /// <para>Require:</para> <para>GL_VERSION_1_3</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glMultiTexCoord"/> is only supported if the GL version is 1.3 or greater, or if
        /// <code>ARB_multitexture</code> is included in the string returned by
        /// <see cref="glGetString"/>  when called with the argument <code>GL_EXTENSIONS</code>.
        /// The current texture coordinates can be updated at any time.
        /// In particular,
        /// <see cref="glMultiTexCoord"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// It is always the case that <code>GL_TEXTURE</code>
        /// i   
        /// = <code>GL_TEXTURE0</code> + 
        /// i   .
        /// </para>
        /// Original: <para>void glMultiTexCoord4dv(GLenum target, const GLdouble * v);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the texture unit whose coordinates should be modified. The number
        /// of texture units is implementation dependent, but must be at least
        /// two. Symbolic constant must be one of 
        /// <code>GL_TEXTURE</code>   i   ,
        /// where i ranges from 0 to <code>GL_MAX_TEXTURE_COORDS</code> - 1,
        /// which is an implementation-dependent value.
        /// </para>
        /// </param>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array of one, two, three, or four elements,
        /// which in turn specify the 
        /// s   ,
        /// t   ,
        /// r   ,
        /// and 
        /// q   
        /// texture coordinates.
        /// </para>
        /// </param>
        /// <seealso cref="ActiveTexture"/>
        /// <seealso cref="ClientActiveTexture"/>
        /// <seealso cref="TexCoord"/>
        /// <seealso cref="TexCoordPointer"/>
        /// <seealso cref="Vertex"/>
        [Obsolete("Compatibility-only GL 1.3 features removed from GL 3.2")]
        public unsafe static void MultiTexCoord4dv(uint target, ref double v) {
            fixed (double* pV = &v) {
                GLNative.glMultiTexCoord4dv(target, pV);
            }
        }

        /// <summary>
        /// set the current texture coordinates
        /// <para>Require:</para> <para>GL_VERSION_1_3</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glMultiTexCoord"/> is only supported if the GL version is 1.3 or greater, or if
        /// <code>ARB_multitexture</code> is included in the string returned by
        /// <see cref="glGetString"/>  when called with the argument <code>GL_EXTENSIONS</code>.
        /// The current texture coordinates can be updated at any time.
        /// In particular,
        /// <see cref="glMultiTexCoord"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// It is always the case that <code>GL_TEXTURE</code>
        /// i   
        /// = <code>GL_TEXTURE0</code> + 
        /// i   .
        /// </para>
        /// Original: <para>void glMultiTexCoord4fv(GLenum target, const GLfloat * v);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the texture unit whose coordinates should be modified. The number
        /// of texture units is implementation dependent, but must be at least
        /// two. Symbolic constant must be one of 
        /// <code>GL_TEXTURE</code>   i   ,
        /// where i ranges from 0 to <code>GL_MAX_TEXTURE_COORDS</code> - 1,
        /// which is an implementation-dependent value.
        /// </para>
        /// </param>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array of one, two, three, or four elements,
        /// which in turn specify the 
        /// s   ,
        /// t   ,
        /// r   ,
        /// and 
        /// q   
        /// texture coordinates.
        /// </para>
        /// </param>
        /// <seealso cref="ActiveTexture"/>
        /// <seealso cref="ClientActiveTexture"/>
        /// <seealso cref="TexCoord"/>
        /// <seealso cref="TexCoordPointer"/>
        /// <seealso cref="Vertex"/>
        [Obsolete("Compatibility-only GL 1.3 features removed from GL 3.2")]
        public unsafe static void MultiTexCoord4fv(uint target, ref float v) {
            fixed (float* pV = &v) {
                GLNative.glMultiTexCoord4fv(target, pV);
            }
        }

        /// <summary>
        /// set the current texture coordinates
        /// <para>Require:</para> <para>GL_VERSION_1_3</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glMultiTexCoord"/> is only supported if the GL version is 1.3 or greater, or if
        /// <code>ARB_multitexture</code> is included in the string returned by
        /// <see cref="glGetString"/>  when called with the argument <code>GL_EXTENSIONS</code>.
        /// The current texture coordinates can be updated at any time.
        /// In particular,
        /// <see cref="glMultiTexCoord"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// It is always the case that <code>GL_TEXTURE</code>
        /// i   
        /// = <code>GL_TEXTURE0</code> + 
        /// i   .
        /// </para>
        /// Original: <para>void glMultiTexCoord4iv(GLenum target, const GLint * v);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the texture unit whose coordinates should be modified. The number
        /// of texture units is implementation dependent, but must be at least
        /// two. Symbolic constant must be one of 
        /// <code>GL_TEXTURE</code>   i   ,
        /// where i ranges from 0 to <code>GL_MAX_TEXTURE_COORDS</code> - 1,
        /// which is an implementation-dependent value.
        /// </para>
        /// </param>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array of one, two, three, or four elements,
        /// which in turn specify the 
        /// s   ,
        /// t   ,
        /// r   ,
        /// and 
        /// q   
        /// texture coordinates.
        /// </para>
        /// </param>
        /// <seealso cref="ActiveTexture"/>
        /// <seealso cref="ClientActiveTexture"/>
        /// <seealso cref="TexCoord"/>
        /// <seealso cref="TexCoordPointer"/>
        /// <seealso cref="Vertex"/>
        [Obsolete("Compatibility-only GL 1.3 features removed from GL 3.2")]
        public unsafe static void MultiTexCoord4iv(uint target, ref int v) {
            fixed (int* pV = &v) {
                GLNative.glMultiTexCoord4iv(target, pV);
            }
        }

        /// <summary>
        /// set the current texture coordinates
        /// <para>Require:</para> <para>GL_VERSION_1_3</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glMultiTexCoord"/> is only supported if the GL version is 1.3 or greater, or if
        /// <code>ARB_multitexture</code> is included in the string returned by
        /// <see cref="glGetString"/>  when called with the argument <code>GL_EXTENSIONS</code>.
        /// The current texture coordinates can be updated at any time.
        /// In particular,
        /// <see cref="glMultiTexCoord"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// It is always the case that <code>GL_TEXTURE</code>
        /// i   
        /// = <code>GL_TEXTURE0</code> + 
        /// i   .
        /// </para>
        /// Original: <para>void glMultiTexCoord4sv(GLenum target, const GLshort * v);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the texture unit whose coordinates should be modified. The number
        /// of texture units is implementation dependent, but must be at least
        /// two. Symbolic constant must be one of 
        /// <code>GL_TEXTURE</code>   i   ,
        /// where i ranges from 0 to <code>GL_MAX_TEXTURE_COORDS</code> - 1,
        /// which is an implementation-dependent value.
        /// </para>
        /// </param>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array of one, two, three, or four elements,
        /// which in turn specify the 
        /// s   ,
        /// t   ,
        /// r   ,
        /// and 
        /// q   
        /// texture coordinates.
        /// </para>
        /// </param>
        /// <seealso cref="ActiveTexture"/>
        /// <seealso cref="ClientActiveTexture"/>
        /// <seealso cref="TexCoord"/>
        /// <seealso cref="TexCoordPointer"/>
        /// <seealso cref="Vertex"/>
        [Obsolete("Compatibility-only GL 1.3 features removed from GL 3.2")]
        public unsafe static void MultiTexCoord4sv(uint target, ref short v) {
            fixed (short* pV = &v) {
                GLNative.glMultiTexCoord4sv(target, pV);
            }
        }

        /// <summary>
        /// replace the current matrix with the specified row-major ordered matrix
        /// <para>Require:</para> <para>GL_VERSION_1_3</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glLoadTransposeMatrix"/> is available only if the GL version is 1.3 or greater.
        /// While the elements of the matrix may be specified with
        /// single or double precision, the GL implementation may
        /// store or operate on these values in less than single
        /// precision.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glLoadTransposeMatrix"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glLoadTransposeMatrixf(const GLfloat * m);</para>
        /// </summary>
        /// <param name="m">
        /// <para>
        /// Specifies a pointer to 16 consecutive values, which are used as the
        /// elements of a 
        /// 4 
        /// &times; 
        /// 4 
        /// row-major matrix.
        /// </para>
        /// </param>
        /// <seealso cref="LoadIdentity"/>
        /// <seealso cref="LoadMatrix"/>
        /// <seealso cref="MatrixMode"/>
        /// <seealso cref="MultMatrix"/>
        /// <seealso cref="MultTransposeMatrix"/>
        /// <seealso cref="PushMatrix"/>
        [Obsolete("Compatibility-only GL 1.3 features removed from GL 3.2")]
        public unsafe static void LoadTransposeMatrixf(ref float m) {
            fixed (float* pM = &m) {
                GLNative.glLoadTransposeMatrixf(pM);
            }
        }

        /// <summary>
        /// replace the current matrix with the specified row-major ordered matrix
        /// <para>Require:</para> <para>GL_VERSION_1_3</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glLoadTransposeMatrix"/> is available only if the GL version is 1.3 or greater.
        /// While the elements of the matrix may be specified with
        /// single or double precision, the GL implementation may
        /// store or operate on these values in less than single
        /// precision.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glLoadTransposeMatrix"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glLoadTransposeMatrixd(const GLdouble * m);</para>
        /// </summary>
        /// <param name="m">
        /// <para>
        /// Specifies a pointer to 16 consecutive values, which are used as the
        /// elements of a 
        /// 4 
        /// &times; 
        /// 4 
        /// row-major matrix.
        /// </para>
        /// </param>
        /// <seealso cref="LoadIdentity"/>
        /// <seealso cref="LoadMatrix"/>
        /// <seealso cref="MatrixMode"/>
        /// <seealso cref="MultMatrix"/>
        /// <seealso cref="MultTransposeMatrix"/>
        /// <seealso cref="PushMatrix"/>
        [Obsolete("Compatibility-only GL 1.3 features removed from GL 3.2")]
        public unsafe static void LoadTransposeMatrixd(ref double m) {
            fixed (double* pM = &m) {
                GLNative.glLoadTransposeMatrixd(pM);
            }
        }

        /// <summary>
        /// multiply the current matrix with the specified row-major ordered matrix
        /// <para>Require:</para> <para>GL_VERSION_1_3</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glMultTransposeMatrix"/> is available only if the GL version is 1.3 or greater.
        /// While the elements of the matrix may be specified with
        /// single or double precision, the GL may store or operate on these
        /// values in less-than-single precision.
        /// The order of the multiplication is important. For example, if the current
        /// transformation is a rotation, and <see cref="glMultTransposeMatrix"/> is called with a translation matrix,
        /// the translation is done directly on the coordinates to be transformed,
        /// while the rotation is done on the results of that translation.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glMultTransposeMatrix"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glMultTransposeMatrixf(const GLfloat * m);</para>
        /// </summary>
        /// <param name="m">
        /// <para>
        /// Points to 16 consecutive values that are used as the elements of
        /// a 
        /// 4 
        /// &times; 
        /// 4 
        /// row-major matrix.
        /// </para>
        /// </param>
        /// <seealso cref="LoadIdentity"/>
        /// <seealso cref="LoadMatrix"/>
        /// <seealso cref="LoadTransposeMatrix"/>
        /// <seealso cref="MatrixMode"/>
        /// <seealso cref="PushMatrix"/>
        [Obsolete("Compatibility-only GL 1.3 features removed from GL 3.2")]
        public unsafe static void MultTransposeMatrixf(ref float m) {
            fixed (float* pM = &m) {
                GLNative.glMultTransposeMatrixf(pM);
            }
        }

        /// <summary>
        /// multiply the current matrix with the specified row-major ordered matrix
        /// <para>Require:</para> <para>GL_VERSION_1_3</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glMultTransposeMatrix"/> is available only if the GL version is 1.3 or greater.
        /// While the elements of the matrix may be specified with
        /// single or double precision, the GL may store or operate on these
        /// values in less-than-single precision.
        /// The order of the multiplication is important. For example, if the current
        /// transformation is a rotation, and <see cref="glMultTransposeMatrix"/> is called with a translation matrix,
        /// the translation is done directly on the coordinates to be transformed,
        /// while the rotation is done on the results of that translation.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glMultTransposeMatrix"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glMultTransposeMatrixd(const GLdouble * m);</para>
        /// </summary>
        /// <param name="m">
        /// <para>
        /// Points to 16 consecutive values that are used as the elements of
        /// a 
        /// 4 
        /// &times; 
        /// 4 
        /// row-major matrix.
        /// </para>
        /// </param>
        /// <seealso cref="LoadIdentity"/>
        /// <seealso cref="LoadMatrix"/>
        /// <seealso cref="LoadTransposeMatrix"/>
        /// <seealso cref="MatrixMode"/>
        /// <seealso cref="PushMatrix"/>
        [Obsolete("Compatibility-only GL 1.3 features removed from GL 3.2")]
        public unsafe static void MultTransposeMatrixd(ref double m) {
            fixed (double* pM = &m) {
                GLNative.glMultTransposeMatrixd(pM);
            }
        }


        #endregion GL_VERSION_1_3

        #region GL_VERSION_1_4

        /// <summary>
        /// render multiple sets of primitives from array data
        /// <para>Require:</para> <para>GL_VERSION_1_4</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glMultiDrawArrays"/> is available only if the GL version is 1.4 or greater.
        /// <see cref="glMultiDrawArrays"/> is included in display lists. If <see cref="glMultiDrawArrays"/> is entered into a
        /// display list,
        /// the necessary array data (determined by the array pointers and
        /// enables) is also
        /// entered into the display list. Because the array pointers and
        /// enables are client-side state, their values affect display lists
        /// when the lists are created, not when the lists are executed.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="mode"/> is not an accepted value.
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="primcount"/> is negative.
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to an
        /// enabled array and the buffer object's data store is currently mapped.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glMultiDrawArrays"/> is executed between
        /// the execution of  <see cref="glBegin"/>  and the corresponding  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glMultiDrawArrays(GLenum mode, GLint * first, GLsizei * count, GLsizei primcount);</para>
        /// </summary>
        /// <param name="mode">
        /// <para>
        /// Specifies what kind of primitives to render.
        /// Symbolic constants
        /// <code>GL_POINTS</code>,
        /// <code>GL_LINE_STRIP</code>,
        /// <code>GL_LINE_LOOP</code>,
        /// <code>GL_LINES</code>,
        /// <code>GL_TRIANGLE_STRIP</code>,
        /// <code>GL_TRIANGLE_FAN</code>,
        /// <code>GL_TRIANGLES</code>,
        /// <code>GL_QUAD_STRIP</code>,
        /// <code>GL_QUADS</code>,
        /// and <code>GL_POLYGON</code> are accepted.
        /// </para>
        /// </param>
        /// <param name="first">
        /// Points to an array of starting indices in the enabled arrays.
        /// </param>
        /// <param name="count">
        /// Points to an array of the number of indices to be rendered.
        /// </param>
        /// <param name="primcount">
        /// Specifies the size of the first and count
        /// </param>
        /// <seealso cref="ArrayElement"/>
        /// <seealso cref="ColorPointer"/>
        /// <seealso cref="DrawElements"/>
        /// <seealso cref="DrawRangeElements"/>
        /// <seealso cref="EdgeFlagPointer"/>
        /// <seealso cref="FogCoordPointer"/>
        /// <seealso cref="GetPointerv"/>
        /// <seealso cref="IndexPointer"/>
        /// <seealso cref="InterleavedArrays"/>
        /// <seealso cref="NormalPointer"/>
        /// <seealso cref="SecondaryColorPointer"/>
        /// <seealso cref="TexCoordPointer"/>
        /// <seealso cref="VertexPointer"/>
        public unsafe static void MultiDrawArrays(uint mode, ref int first, ref int count, int primcount) {
            fixed (int* pFirst = &first)
            fixed (int* pCount = &count) {
                GLNative.glMultiDrawArrays(mode, pFirst, pCount, primcount);
            }
        }

        /// <summary>
        /// render multiple sets of primitives by specifying indices of array data elements
        /// <para>Require:</para> <para>GL_VERSION_1_4</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glMultiDrawElements"/> is available only if the GL version is 1.4 or greater.
        /// <see cref="glMultiDrawElements"/> is included in display lists. If <see cref="glMultiDrawElements"/> is entered into a
        /// display list,
        /// the necessary array data (determined by the array pointers and
        /// enables) is also
        /// entered into the display list. Because the array pointers and
        /// enables are client-side state, their values affect display lists
        /// when the lists are created, not when the lists are executed.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="mode"/> is not an accepted value.
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="primcount"/> is negative.
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to an
        /// enabled array or the element array and the buffer object's data store is currently mapped.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glMultiDrawElements"/> is executed between
        /// the execution of  <see cref="glBegin"/>  and the corresponding  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glMultiDrawElements(GLenum mode, const GLsizei * count, GLenum type, const void ** indices, GLsizei primcount);</para>
        /// </summary>
        /// <param name="mode">
        /// <para>
        /// Specifies what kind of primitives to render.
        /// Symbolic constants
        /// <code>GL_POINTS</code>,
        /// <code>GL_LINE_STRIP</code>,
        /// <code>GL_LINE_LOOP</code>,
        /// <code>GL_LINES</code>,
        /// <code>GL_TRIANGLE_STRIP</code>,
        /// <code>GL_TRIANGLE_FAN</code>,
        /// <code>GL_TRIANGLES</code>,
        /// <code>GL_QUAD_STRIP</code>,
        /// <code>GL_QUADS</code>,
        /// and <code>GL_POLYGON</code> are accepted.
        /// </para>
        /// </param>
        /// <param name="count">
        /// Points to an array of the elements counts.
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the type of the values in <paramref name="indices"/>. Must be one of
        /// <code>GL_UNSIGNED_BYTE</code>, <code>GL_UNSIGNED_SHORT</code>, or
        /// <code>GL_UNSIGNED_INT</code>.
        /// </para>
        /// </param>
        /// <param name="indices">
        /// Specifies a pointer to the location where the indices are stored.
        /// </param>
        /// <param name="primcount">
        /// Specifies the size of the <paramref name="count"/> array.
        /// </param>
        /// <seealso cref="ArrayElement"/>
        /// <seealso cref="ColorPointer"/>
        /// <seealso cref="DrawArrays"/>
        /// <seealso cref="DrawRangeElements"/>
        /// <seealso cref="EdgeFlagPointer"/>
        /// <seealso cref="FogCoordPointer"/>
        /// <seealso cref="GetPointerv"/>
        /// <seealso cref="IndexPointer"/>
        /// <seealso cref="InterleavedArrays"/>
        /// <seealso cref="NormalPointer"/>
        /// <seealso cref="SecondaryColorPointer"/>
        /// <seealso cref="TexCoordPointer"/>
        /// <seealso cref="VertexPointer"/>
        public unsafe static void MultiDrawElements(uint mode, ref int count, uint type, IntPtr indices, int primcount) {
            fixed (int* pCount = &count) {
                GLNative.glMultiDrawElements(mode, pCount, type, (void**)indices, primcount);
            }
        }

        /// <summary>
        /// specify point parameters
        /// <para>Require:</para> <para>GL_VERSION_1_4, GL_VERSION_ES_CM_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glPointParameter"/> is available only if the GL version is 1.4 or greater.
        /// <code>GL_POINT_SPRITE_COORD_ORIGIN</code> is available only if the GL version is 2.0 or greater.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated If the value specified for
        /// <code>GL_POINT_SIZE_MIN</code>, <code>GL_POINT_SIZE_MAX</code>, or
        /// <code>GL_POINT_FADE_THRESHOLD_SIZE</code> is less than zero.
        /// <code>GL_INVALID_ENUM</code> is generated If the value specified for
        /// <code>GL_POINT_SPRITE_COORD_ORIGIN</code> is not <code>GL_LOWER_LEFT</code> or <code>GL_UPPER_LEFT</code>.
        /// If the value for <code>GL_POINT_SIZE_MIN</code> is greater than
        /// <code>GL_POINT_SIZE_MAX</code>, the point size after clamping is undefined, but no
        /// error is generated.
        /// </para>
        /// Original: <para>void glPointParameterfv(GLenum pname, const GLfloat * params);</para>
        /// </summary>
        /// <param name="pname">
        /// <para>
        /// Specifies a point parameter.
        /// <code>GL_POINT_SIZE_MIN</code>,
        /// <code>GL_POINT_SIZE_MAX</code>,
        /// <code>GL_POINT_DISTANCE_ATTENUATION</code>,
        /// <code>GL_POINT_FADE_THRESHOLD_SIZE</code>, and
        /// <code>GL_POINT_SPRITE_COORD_ORIGIN</code>
        /// are accepted.
        /// </para>
        /// </param>
        /// <param name="ps">
        /// <para>
        /// Specifies the value or values to be assigned to <paramref name="pname"/>.
        /// <code>GL_POINT_DISTANCE_ATTENUATION</code> requires an array of three values.
        /// All other parameters accept an array containing only a single value.
        /// </para>
        /// </param>
        /// <seealso cref="PointSize"/>
        public unsafe static void PointParameterfv(uint pname, ref float ps) {
            fixed (float* pPs = &ps) {
                GLNative.glPointParameterfv(pname, pPs);
            }
        }

        /// <summary>
        /// specify point parameters
        /// <para>Require:</para> <para>GL_VERSION_1_4</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glPointParameter"/> is available only if the GL version is 1.4 or greater.
        /// <code>GL_POINT_SPRITE_COORD_ORIGIN</code> is available only if the GL version is 2.0 or greater.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated If the value specified for
        /// <code>GL_POINT_SIZE_MIN</code>, <code>GL_POINT_SIZE_MAX</code>, or
        /// <code>GL_POINT_FADE_THRESHOLD_SIZE</code> is less than zero.
        /// <code>GL_INVALID_ENUM</code> is generated If the value specified for
        /// <code>GL_POINT_SPRITE_COORD_ORIGIN</code> is not <code>GL_LOWER_LEFT</code> or <code>GL_UPPER_LEFT</code>.
        /// If the value for <code>GL_POINT_SIZE_MIN</code> is greater than
        /// <code>GL_POINT_SIZE_MAX</code>, the point size after clamping is undefined, but no
        /// error is generated.
        /// </para>
        /// Original: <para>void glPointParameteriv(GLenum pname, const GLint * params);</para>
        /// </summary>
        /// <param name="pname">
        /// <para>
        /// Specifies a point parameter.
        /// <code>GL_POINT_SIZE_MIN</code>,
        /// <code>GL_POINT_SIZE_MAX</code>,
        /// <code>GL_POINT_DISTANCE_ATTENUATION</code>,
        /// <code>GL_POINT_FADE_THRESHOLD_SIZE</code>, and
        /// <code>GL_POINT_SPRITE_COORD_ORIGIN</code>
        /// are accepted.
        /// </para>
        /// </param>
        /// <param name="ps">
        /// <para>
        /// Specifies the value or values to be assigned to <paramref name="pname"/>.
        /// <code>GL_POINT_DISTANCE_ATTENUATION</code> requires an array of three values.
        /// All other parameters accept an array containing only a single value.
        /// </para>
        /// </param>
        /// <seealso cref="PointSize"/>
        public unsafe static void PointParameteriv(uint pname, ref int ps) {
            fixed (int* pPs = &ps) {
                GLNative.glPointParameteriv(pname, pPs);
            }
        }

        /// <summary>
        /// set the current fog coordinates
        /// <para>Require:</para> <para>GL_VERSION_1_4</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glFogCoord"/> is available only if the GL version is 1.4 or greater.
        /// The current fog coordinate can be updated at any time.  In particular,
        /// <see cref="glFogCoord"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glFogCoordfv(GLfloat * coord);</para>
        /// </summary>
        /// <param name="coord">
        /// <para>
        /// Specifies a pointer to an array containing a single value representing the
        /// fog distance.
        /// </para>
        /// </param>
        /// <seealso cref="Fog"/>
        /// <seealso cref="FogCoordPointer"/>
        /// <seealso cref="Vertex"/>
        [Obsolete("Compatibility-only GL 1.4 features removed from GL 3.2")]
        public unsafe static void FogCoordfv(ref float coord) {
            fixed (float* pCoord = &coord) {
                GLNative.glFogCoordfv(pCoord);
            }
        }

        /// <summary>
        /// set the current fog coordinates
        /// <para>Require:</para> <para>GL_VERSION_1_4</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glFogCoord"/> is available only if the GL version is 1.4 or greater.
        /// The current fog coordinate can be updated at any time.  In particular,
        /// <see cref="glFogCoord"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glFogCoorddv(GLdouble * coord);</para>
        /// </summary>
        /// <param name="coord">
        /// <para>
        /// Specifies a pointer to an array containing a single value representing the
        /// fog distance.
        /// </para>
        /// </param>
        /// <seealso cref="Fog"/>
        /// <seealso cref="FogCoordPointer"/>
        /// <seealso cref="Vertex"/>
        [Obsolete("Compatibility-only GL 1.4 features removed from GL 3.2")]
        public unsafe static void FogCoorddv(ref double coord) {
            fixed (double* pCoord = &coord) {
                GLNative.glFogCoorddv(pCoord);
            }
        }

        /// <summary>
        /// define an array of fog coordinates
        /// <para>Require:</para> <para>GL_VERSION_1_4</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glFogCoordPointer"/> is available only if the GL version is 1.4 or greater.
        /// Fog coordinates are not supported for interleaved vertex array formats
        /// (see  <see cref="glInterleavedArrays"/> ).
        /// The fog coordinate array is initially disabled and isn't accessed when
        /// <see cref="glArrayElement"/> ,  <see cref="glDrawElements"/> ,  <see cref="glDrawRangeElements"/> ,
        /// <see cref="glDrawArrays"/> ,  <see cref="glMultiDrawArrays"/> , or  <see cref="glMultiDrawElements"/> 
        /// is called.
        /// Execution of <see cref="glFogCoordPointer"/> is not allowed between the execution of
        /// <see cref="glBegin"/>  and the corresponding execution of  <see cref="glEnd"/> ,
        /// but an error may or may not be generated. If no error is generated,
        /// the operation is undefined.
        /// <see cref="glFogCoordPointer"/> is typically implemented on the client side with no protocol.
        /// Fog coordinate array parameters are client-side state and are
        /// therefore not saved or restored by  <see cref="glPushAttrib"/>  and  <see cref="glPopAttrib"/> .
        /// Use  <see cref="glPushClientAttrib"/>  and
        /// <see cref="glPopClientAttrib"/>  instead.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="type"/> is not either <code>GL_FLOAT</code>
        /// or <code>GL_DOUBLE</code>.
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="stride"/> is negative.
        /// </para>
        /// Original: <para>void glFogCoordPointer(GLenum type, GLsizei stride, void * pointer);</para>
        /// </summary>
        /// <param name="type">
        /// <para>
        /// Specifies the data type of each fog coordinate.
        /// Symbolic constants
        /// <code>GL_FLOAT</code>,
        /// or <code>GL_DOUBLE</code>
        /// are accepted. The initial value is <code>GL_FLOAT</code>.
        /// </para>
        /// </param>
        /// <param name="stride">
        /// <para>
        /// Specifies the byte offset between consecutive fog coordinates.
        /// If <paramref name="stride"/> is 0, the array elements are understood
        /// to be tightly packed. The initial value is 0.
        /// </para>
        /// </param>
        /// <param name="pointer">
        /// <para>
        /// Specifies a pointer to the first coordinate of the first fog coordinate in the
        /// array. The initial value is 0.
        /// </para>
        /// </param>
        /// <seealso cref="ArrayElement"/>
        /// <seealso cref="BindBuffer"/>
        /// <seealso cref="ColorPointer"/>
        /// <seealso cref="DisableClientState"/>
        /// <seealso cref="DrawArrays"/>
        /// <seealso cref="DrawElements"/>
        /// <seealso cref="DrawRangeElements"/>
        /// <seealso cref="EdgeFlagPointer"/>
        /// <seealso cref="EnableClientState"/>
        /// <seealso cref="FogCoord"/>
        /// <seealso cref="IndexPointer"/>
        /// <seealso cref="InterleavedArrays"/>
        /// <seealso cref="MultiDrawArrays"/>
        /// <seealso cref="MultiDrawElements"/>
        /// <seealso cref="NormalPointer"/>
        /// <seealso cref="PopClientAttrib"/>
        /// <seealso cref="PushClientAttrib"/>
        /// <seealso cref="SecondaryColorPointer"/>
        /// <seealso cref="TexCoordPointer"/>
        /// <seealso cref="VertexAttribPointer"/>
        /// <seealso cref="VertexPointer"/>
        [Obsolete("Compatibility-only GL 1.4 features removed from GL 3.2")]
        public unsafe static void FogCoordPointer(uint type, int stride, IntPtr pointer) {
            GLNative.glFogCoordPointer(type, stride, (void*)pointer);
        }

        /// <summary>
        /// set the current secondary color
        /// <para>Require:</para> <para>GL_VERSION_1_4</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glSecondaryColor"/> is available only if the GL version is 1.4 or greater.
        /// The initial value for the secondary color is (0, 0, 0, 0).
        /// The secondary color can be updated at any time.  In particular, <see cref="glSecondaryColor"/> can
        /// be called between a call to  <see cref="glBegin"/>  and the corresponding call to
        /// <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glSecondaryColor3bv(const GLbyte * v);</para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array that contains red, green, blue.
        /// </param>
        /// <seealso cref="Color"/>
        /// <seealso cref="Index"/>
        /// <seealso cref="IsEnabled"/>
        /// <seealso cref="LightModel"/>
        /// <seealso cref="SecondaryColorPointer"/>
        [Obsolete("Compatibility-only GL 1.4 features removed from GL 3.2")]
        public unsafe static void SecondaryColor3bv(ref byte v) {
            fixed (byte* pV = &v) {
                GLNative.glSecondaryColor3bv(pV);
            }
        }

        /// <summary>
        /// set the current secondary color
        /// <para>Require:</para> <para>GL_VERSION_1_4</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glSecondaryColor"/> is available only if the GL version is 1.4 or greater.
        /// The initial value for the secondary color is (0, 0, 0, 0).
        /// The secondary color can be updated at any time.  In particular, <see cref="glSecondaryColor"/> can
        /// be called between a call to  <see cref="glBegin"/>  and the corresponding call to
        /// <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glSecondaryColor3dv(const GLdouble * v);</para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array that contains red, green, blue.
        /// </param>
        /// <seealso cref="Color"/>
        /// <seealso cref="Index"/>
        /// <seealso cref="IsEnabled"/>
        /// <seealso cref="LightModel"/>
        /// <seealso cref="SecondaryColorPointer"/>
        [Obsolete("Compatibility-only GL 1.4 features removed from GL 3.2")]
        public unsafe static void SecondaryColor3dv(ref double v) {
            fixed (double* pV = &v) {
                GLNative.glSecondaryColor3dv(pV);
            }
        }

        /// <summary>
        /// set the current secondary color
        /// <para>Require:</para> <para>GL_VERSION_1_4</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glSecondaryColor"/> is available only if the GL version is 1.4 or greater.
        /// The initial value for the secondary color is (0, 0, 0, 0).
        /// The secondary color can be updated at any time.  In particular, <see cref="glSecondaryColor"/> can
        /// be called between a call to  <see cref="glBegin"/>  and the corresponding call to
        /// <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glSecondaryColor3fv(const GLfloat * v);</para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array that contains red, green, blue.
        /// </param>
        /// <seealso cref="Color"/>
        /// <seealso cref="Index"/>
        /// <seealso cref="IsEnabled"/>
        /// <seealso cref="LightModel"/>
        /// <seealso cref="SecondaryColorPointer"/>
        [Obsolete("Compatibility-only GL 1.4 features removed from GL 3.2")]
        public unsafe static void SecondaryColor3fv(ref float v) {
            fixed (float* pV = &v) {
                GLNative.glSecondaryColor3fv(pV);
            }
        }

        /// <summary>
        /// set the current secondary color
        /// <para>Require:</para> <para>GL_VERSION_1_4</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glSecondaryColor"/> is available only if the GL version is 1.4 or greater.
        /// The initial value for the secondary color is (0, 0, 0, 0).
        /// The secondary color can be updated at any time.  In particular, <see cref="glSecondaryColor"/> can
        /// be called between a call to  <see cref="glBegin"/>  and the corresponding call to
        /// <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glSecondaryColor3iv(const GLint * v);</para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array that contains red, green, blue.
        /// </param>
        /// <seealso cref="Color"/>
        /// <seealso cref="Index"/>
        /// <seealso cref="IsEnabled"/>
        /// <seealso cref="LightModel"/>
        /// <seealso cref="SecondaryColorPointer"/>
        [Obsolete("Compatibility-only GL 1.4 features removed from GL 3.2")]
        public unsafe static void SecondaryColor3iv(ref int v) {
            fixed (int* pV = &v) {
                GLNative.glSecondaryColor3iv(pV);
            }
        }

        /// <summary>
        /// set the current secondary color
        /// <para>Require:</para> <para>GL_VERSION_1_4</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glSecondaryColor"/> is available only if the GL version is 1.4 or greater.
        /// The initial value for the secondary color is (0, 0, 0, 0).
        /// The secondary color can be updated at any time.  In particular, <see cref="glSecondaryColor"/> can
        /// be called between a call to  <see cref="glBegin"/>  and the corresponding call to
        /// <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glSecondaryColor3sv(const GLshort * v);</para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array that contains red, green, blue.
        /// </param>
        /// <seealso cref="Color"/>
        /// <seealso cref="Index"/>
        /// <seealso cref="IsEnabled"/>
        /// <seealso cref="LightModel"/>
        /// <seealso cref="SecondaryColorPointer"/>
        [Obsolete("Compatibility-only GL 1.4 features removed from GL 3.2")]
        public unsafe static void SecondaryColor3sv(ref short v) {
            fixed (short* pV = &v) {
                GLNative.glSecondaryColor3sv(pV);
            }
        }

        /// <summary>
        /// set the current secondary color
        /// <para>Require:</para> <para>GL_VERSION_1_4</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glSecondaryColor"/> is available only if the GL version is 1.4 or greater.
        /// The initial value for the secondary color is (0, 0, 0, 0).
        /// The secondary color can be updated at any time.  In particular, <see cref="glSecondaryColor"/> can
        /// be called between a call to  <see cref="glBegin"/>  and the corresponding call to
        /// <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glSecondaryColor3ubv(const GLubyte * v);</para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array that contains red, green, blue.
        /// </param>
        /// <seealso cref="Color"/>
        /// <seealso cref="Index"/>
        /// <seealso cref="IsEnabled"/>
        /// <seealso cref="LightModel"/>
        /// <seealso cref="SecondaryColorPointer"/>
        [Obsolete("Compatibility-only GL 1.4 features removed from GL 3.2")]
        public unsafe static void SecondaryColor3ubv(ref byte v) {
            fixed (byte* pV = &v) {
                GLNative.glSecondaryColor3ubv(pV);
            }
        }

        /// <summary>
        /// set the current secondary color
        /// <para>Require:</para> <para>GL_VERSION_1_4</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glSecondaryColor"/> is available only if the GL version is 1.4 or greater.
        /// The initial value for the secondary color is (0, 0, 0, 0).
        /// The secondary color can be updated at any time.  In particular, <see cref="glSecondaryColor"/> can
        /// be called between a call to  <see cref="glBegin"/>  and the corresponding call to
        /// <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glSecondaryColor3uiv(const GLuint * v);</para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array that contains red, green, blue.
        /// </param>
        /// <seealso cref="Color"/>
        /// <seealso cref="Index"/>
        /// <seealso cref="IsEnabled"/>
        /// <seealso cref="LightModel"/>
        /// <seealso cref="SecondaryColorPointer"/>
        [Obsolete("Compatibility-only GL 1.4 features removed from GL 3.2")]
        public unsafe static void SecondaryColor3uiv(ref uint v) {
            fixed (uint* pV = &v) {
                GLNative.glSecondaryColor3uiv(pV);
            }
        }

        /// <summary>
        /// set the current secondary color
        /// <para>Require:</para> <para>GL_VERSION_1_4</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glSecondaryColor"/> is available only if the GL version is 1.4 or greater.
        /// The initial value for the secondary color is (0, 0, 0, 0).
        /// The secondary color can be updated at any time.  In particular, <see cref="glSecondaryColor"/> can
        /// be called between a call to  <see cref="glBegin"/>  and the corresponding call to
        /// <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glSecondaryColor3usv(const GLushort * v);</para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array that contains red, green, blue.
        /// </param>
        /// <seealso cref="Color"/>
        /// <seealso cref="Index"/>
        /// <seealso cref="IsEnabled"/>
        /// <seealso cref="LightModel"/>
        /// <seealso cref="SecondaryColorPointer"/>
        [Obsolete("Compatibility-only GL 1.4 features removed from GL 3.2")]
        public unsafe static void SecondaryColor3usv(ref ushort v) {
            fixed (ushort* pV = &v) {
                GLNative.glSecondaryColor3usv(pV);
            }
        }

        /// <summary>
        /// define an array of secondary colors
        /// <para>Require:</para> <para>GL_VERSION_1_4</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glSecondaryColorPointer"/> is available only if the GL version is 1.4 or greater.
        /// Secondary colors are not supported for interleaved vertex array formats
        /// (see  <see cref="glInterleavedArrays"/> ).
        /// The secondary color array is initially disabled and isn't accessed when
        /// <see cref="glArrayElement"/> ,  <see cref="glDrawElements"/> ,  <see cref="glDrawRangeElements"/> ,
        /// <see cref="glDrawArrays"/> ,  <see cref="glMultiDrawArrays"/> , or  <see cref="glMultiDrawElements"/> 
        /// is called.
        /// Execution of <see cref="glSecondaryColorPointer"/> is not allowed between the execution of
        /// <see cref="glBegin"/>  and the corresponding execution of  <see cref="glEnd"/> ,
        /// but an error may or may not be generated. If no error is generated,
        /// the operation is undefined.
        /// <see cref="glSecondaryColorPointer"/> is typically implemented on the client side.
        /// Secondary color array parameters are client-side state and are therefore
        /// not saved or restored by  <see cref="glPushAttrib"/>  and  <see cref="glPopAttrib"/> .  Use
        /// <see cref="glPushClientAttrib"/>  and  <see cref="glPopClientAttrib"/>  instead.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="size"/> is not 3.
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="type"/> is not an accepted value.
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="stride"/> is negative.
        /// </para>
        /// Original: <para>void glSecondaryColorPointer(GLint size, GLenum type, GLsizei stride, const void * pointer);</para>
        /// </summary>
        /// <param name="size">
        /// Specifies the number of components per color. Must be 3.
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the data type of each color component in the array.
        /// Symbolic constants
        /// <code>GL_BYTE</code>,
        /// <code>GL_UNSIGNED_BYTE</code>,
        /// <code>GL_SHORT</code>,
        /// <code>GL_UNSIGNED_SHORT</code>,
        /// <code>GL_INT</code>,
        /// <code>GL_UNSIGNED_INT</code>,
        /// <code>GL_FLOAT</code>,
        /// or
        /// <code>GL_DOUBLE</code>
        /// are accepted.
        /// The initial value is <code>GL_FLOAT</code>.
        /// </para>
        /// </param>
        /// <param name="stride">
        /// <para>
        /// Specifies the byte offset between consecutive colors.
        /// If <paramref name="stride"/> is 0, the colors are understood to be
        /// tightly packed in the array. The initial value is 0.
        /// </para>
        /// </param>
        /// <param name="pointer">
        /// <para>
        /// Specifies a pointer to the first component of the first color element
        /// in the array. The initial value is 0.
        /// </para>
        /// </param>
        /// <seealso cref="ArrayElement"/>
        /// <seealso cref="BindBuffer"/>
        /// <seealso cref="ColorPointer"/>
        /// <seealso cref="DisableClientState"/>
        /// <seealso cref="DrawArrays"/>
        /// <seealso cref="DrawElements"/>
        /// <seealso cref="DrawRangeElements"/>
        /// <seealso cref="EdgeFlagPointer"/>
        /// <seealso cref="EnableClientState"/>
        /// <seealso cref="FogCoordPointer"/>
        /// <seealso cref="IndexPointer"/>
        /// <seealso cref="InterleavedArrays"/>
        /// <seealso cref="MultiDrawArrays"/>
        /// <seealso cref="MultiDrawElements"/>
        /// <seealso cref="NormalPointer"/>
        /// <seealso cref="PopClientAttrib"/>
        /// <seealso cref="PushClientAttrib"/>
        /// <seealso cref="SecondaryColor"/>
        /// <seealso cref="TexCoordPointer"/>
        /// <seealso cref="VertexAttribPointer"/>
        /// <seealso cref="VertexPointer"/>
        [Obsolete("Compatibility-only GL 1.4 features removed from GL 3.2")]
        public unsafe static void SecondaryColorPointer(int size, uint type, int stride, IntPtr pointer) {
            GLNative.glSecondaryColorPointer(size, type, stride, (void*)pointer);
        }

        /// <summary>
        /// specify the raster position in window coordinates for pixel operations
        /// <para>Require:</para> <para>GL_VERSION_1_4</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glWindowPos"/> is available only if the GL version is 1.4 or greater.
        /// The raster position is modified by  <see cref="glRasterPos"/> ,  <see cref="glBitmap"/> , and
        /// <see cref="glWindowPos"/>.
        /// Calling  <see cref="glDrawElements"/> , or  <see cref="glDrawRangeElements"/>  may leave the
        /// current color or index indeterminate.
        /// If <see cref="glWindowPos"/> is executed while the current color or index is indeterminate, the
        /// current raster color or current raster index remains indeterminate.
        /// There are distinct raster texture coordinates for each texture unit. Each
        /// texture unit's current raster texture coordinates are updated by <see cref="glWindowPos"/>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glWindowPos"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glWindowPos2dv(const GLdouble * v);</para>
        /// </summary>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array of two or three elements,
        /// specifying 
        /// x   ,
        /// y   ,
        /// z   
        /// coordinates, respectively.
        /// </para>
        /// </param>
        /// <seealso cref="Bitmap"/>
        /// <seealso cref="CopyPixels"/>
        /// <seealso cref="DrawArrays"/>
        /// <seealso cref="DrawElements"/>
        /// <seealso cref="DrawRangeElements"/>
        /// <seealso cref="DrawPixels"/>
        /// <seealso cref="MultiTexCoord"/>
        /// <seealso cref="RasterPos"/>
        /// <seealso cref="TexCoord"/>
        /// <seealso cref="TexGen"/>
        /// <seealso cref="Vertex"/>
        [Obsolete("Compatibility-only GL 1.4 features removed from GL 3.2")]
        public unsafe static void WindowPos2dv(ref double v) {
            fixed (double* pV = &v) {
                GLNative.glWindowPos2dv(pV);
            }
        }

        /// <summary>
        /// specify the raster position in window coordinates for pixel operations
        /// <para>Require:</para> <para>GL_VERSION_1_4</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glWindowPos"/> is available only if the GL version is 1.4 or greater.
        /// The raster position is modified by  <see cref="glRasterPos"/> ,  <see cref="glBitmap"/> , and
        /// <see cref="glWindowPos"/>.
        /// Calling  <see cref="glDrawElements"/> , or  <see cref="glDrawRangeElements"/>  may leave the
        /// current color or index indeterminate.
        /// If <see cref="glWindowPos"/> is executed while the current color or index is indeterminate, the
        /// current raster color or current raster index remains indeterminate.
        /// There are distinct raster texture coordinates for each texture unit. Each
        /// texture unit's current raster texture coordinates are updated by <see cref="glWindowPos"/>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glWindowPos"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glWindowPos2fv(const GLfloat * v);</para>
        /// </summary>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array of two or three elements,
        /// specifying 
        /// x   ,
        /// y   ,
        /// z   
        /// coordinates, respectively.
        /// </para>
        /// </param>
        /// <seealso cref="Bitmap"/>
        /// <seealso cref="CopyPixels"/>
        /// <seealso cref="DrawArrays"/>
        /// <seealso cref="DrawElements"/>
        /// <seealso cref="DrawRangeElements"/>
        /// <seealso cref="DrawPixels"/>
        /// <seealso cref="MultiTexCoord"/>
        /// <seealso cref="RasterPos"/>
        /// <seealso cref="TexCoord"/>
        /// <seealso cref="TexGen"/>
        /// <seealso cref="Vertex"/>
        [Obsolete("Compatibility-only GL 1.4 features removed from GL 3.2")]
        public unsafe static void WindowPos2fv(ref float v) {
            fixed (float* pV = &v) {
                GLNative.glWindowPos2fv(pV);
            }
        }

        /// <summary>
        /// specify the raster position in window coordinates for pixel operations
        /// <para>Require:</para> <para>GL_VERSION_1_4</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glWindowPos"/> is available only if the GL version is 1.4 or greater.
        /// The raster position is modified by  <see cref="glRasterPos"/> ,  <see cref="glBitmap"/> , and
        /// <see cref="glWindowPos"/>.
        /// Calling  <see cref="glDrawElements"/> , or  <see cref="glDrawRangeElements"/>  may leave the
        /// current color or index indeterminate.
        /// If <see cref="glWindowPos"/> is executed while the current color or index is indeterminate, the
        /// current raster color or current raster index remains indeterminate.
        /// There are distinct raster texture coordinates for each texture unit. Each
        /// texture unit's current raster texture coordinates are updated by <see cref="glWindowPos"/>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glWindowPos"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glWindowPos2iv(const GLint * v);</para>
        /// </summary>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array of two or three elements,
        /// specifying 
        /// x   ,
        /// y   ,
        /// z   
        /// coordinates, respectively.
        /// </para>
        /// </param>
        /// <seealso cref="Bitmap"/>
        /// <seealso cref="CopyPixels"/>
        /// <seealso cref="DrawArrays"/>
        /// <seealso cref="DrawElements"/>
        /// <seealso cref="DrawRangeElements"/>
        /// <seealso cref="DrawPixels"/>
        /// <seealso cref="MultiTexCoord"/>
        /// <seealso cref="RasterPos"/>
        /// <seealso cref="TexCoord"/>
        /// <seealso cref="TexGen"/>
        /// <seealso cref="Vertex"/>
        [Obsolete("Compatibility-only GL 1.4 features removed from GL 3.2")]
        public unsafe static void WindowPos2iv(ref int v) {
            fixed (int* pV = &v) {
                GLNative.glWindowPos2iv(pV);
            }
        }

        /// <summary>
        /// specify the raster position in window coordinates for pixel operations
        /// <para>Require:</para> <para>GL_VERSION_1_4</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glWindowPos"/> is available only if the GL version is 1.4 or greater.
        /// The raster position is modified by  <see cref="glRasterPos"/> ,  <see cref="glBitmap"/> , and
        /// <see cref="glWindowPos"/>.
        /// Calling  <see cref="glDrawElements"/> , or  <see cref="glDrawRangeElements"/>  may leave the
        /// current color or index indeterminate.
        /// If <see cref="glWindowPos"/> is executed while the current color or index is indeterminate, the
        /// current raster color or current raster index remains indeterminate.
        /// There are distinct raster texture coordinates for each texture unit. Each
        /// texture unit's current raster texture coordinates are updated by <see cref="glWindowPos"/>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glWindowPos"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glWindowPos2sv(const GLshort * v);</para>
        /// </summary>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array of two or three elements,
        /// specifying 
        /// x   ,
        /// y   ,
        /// z   
        /// coordinates, respectively.
        /// </para>
        /// </param>
        /// <seealso cref="Bitmap"/>
        /// <seealso cref="CopyPixels"/>
        /// <seealso cref="DrawArrays"/>
        /// <seealso cref="DrawElements"/>
        /// <seealso cref="DrawRangeElements"/>
        /// <seealso cref="DrawPixels"/>
        /// <seealso cref="MultiTexCoord"/>
        /// <seealso cref="RasterPos"/>
        /// <seealso cref="TexCoord"/>
        /// <seealso cref="TexGen"/>
        /// <seealso cref="Vertex"/>
        [Obsolete("Compatibility-only GL 1.4 features removed from GL 3.2")]
        public unsafe static void WindowPos2sv(ref short v) {
            fixed (short* pV = &v) {
                GLNative.glWindowPos2sv(pV);
            }
        }

        /// <summary>
        /// specify the raster position in window coordinates for pixel operations
        /// <para>Require:</para> <para>GL_VERSION_1_4</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glWindowPos"/> is available only if the GL version is 1.4 or greater.
        /// The raster position is modified by  <see cref="glRasterPos"/> ,  <see cref="glBitmap"/> , and
        /// <see cref="glWindowPos"/>.
        /// Calling  <see cref="glDrawElements"/> , or  <see cref="glDrawRangeElements"/>  may leave the
        /// current color or index indeterminate.
        /// If <see cref="glWindowPos"/> is executed while the current color or index is indeterminate, the
        /// current raster color or current raster index remains indeterminate.
        /// There are distinct raster texture coordinates for each texture unit. Each
        /// texture unit's current raster texture coordinates are updated by <see cref="glWindowPos"/>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glWindowPos"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glWindowPos3dv(const GLdouble * v);</para>
        /// </summary>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array of two or three elements,
        /// specifying 
        /// x   ,
        /// y   ,
        /// z   
        /// coordinates, respectively.
        /// </para>
        /// </param>
        /// <seealso cref="Bitmap"/>
        /// <seealso cref="CopyPixels"/>
        /// <seealso cref="DrawArrays"/>
        /// <seealso cref="DrawElements"/>
        /// <seealso cref="DrawRangeElements"/>
        /// <seealso cref="DrawPixels"/>
        /// <seealso cref="MultiTexCoord"/>
        /// <seealso cref="RasterPos"/>
        /// <seealso cref="TexCoord"/>
        /// <seealso cref="TexGen"/>
        /// <seealso cref="Vertex"/>
        [Obsolete("Compatibility-only GL 1.4 features removed from GL 3.2")]
        public unsafe static void WindowPos3dv(ref double v) {
            fixed (double* pV = &v) {
                GLNative.glWindowPos3dv(pV);
            }
        }

        /// <summary>
        /// specify the raster position in window coordinates for pixel operations
        /// <para>Require:</para> <para>GL_VERSION_1_4</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glWindowPos"/> is available only if the GL version is 1.4 or greater.
        /// The raster position is modified by  <see cref="glRasterPos"/> ,  <see cref="glBitmap"/> , and
        /// <see cref="glWindowPos"/>.
        /// Calling  <see cref="glDrawElements"/> , or  <see cref="glDrawRangeElements"/>  may leave the
        /// current color or index indeterminate.
        /// If <see cref="glWindowPos"/> is executed while the current color or index is indeterminate, the
        /// current raster color or current raster index remains indeterminate.
        /// There are distinct raster texture coordinates for each texture unit. Each
        /// texture unit's current raster texture coordinates are updated by <see cref="glWindowPos"/>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glWindowPos"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glWindowPos3fv(const GLfloat * v);</para>
        /// </summary>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array of two or three elements,
        /// specifying 
        /// x   ,
        /// y   ,
        /// z   
        /// coordinates, respectively.
        /// </para>
        /// </param>
        /// <seealso cref="Bitmap"/>
        /// <seealso cref="CopyPixels"/>
        /// <seealso cref="DrawArrays"/>
        /// <seealso cref="DrawElements"/>
        /// <seealso cref="DrawRangeElements"/>
        /// <seealso cref="DrawPixels"/>
        /// <seealso cref="MultiTexCoord"/>
        /// <seealso cref="RasterPos"/>
        /// <seealso cref="TexCoord"/>
        /// <seealso cref="TexGen"/>
        /// <seealso cref="Vertex"/>
        [Obsolete("Compatibility-only GL 1.4 features removed from GL 3.2")]
        public unsafe static void WindowPos3fv(ref float v) {
            fixed (float* pV = &v) {
                GLNative.glWindowPos3fv(pV);
            }
        }

        /// <summary>
        /// specify the raster position in window coordinates for pixel operations
        /// <para>Require:</para> <para>GL_VERSION_1_4</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glWindowPos"/> is available only if the GL version is 1.4 or greater.
        /// The raster position is modified by  <see cref="glRasterPos"/> ,  <see cref="glBitmap"/> , and
        /// <see cref="glWindowPos"/>.
        /// Calling  <see cref="glDrawElements"/> , or  <see cref="glDrawRangeElements"/>  may leave the
        /// current color or index indeterminate.
        /// If <see cref="glWindowPos"/> is executed while the current color or index is indeterminate, the
        /// current raster color or current raster index remains indeterminate.
        /// There are distinct raster texture coordinates for each texture unit. Each
        /// texture unit's current raster texture coordinates are updated by <see cref="glWindowPos"/>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glWindowPos"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glWindowPos3iv(const GLint * v);</para>
        /// </summary>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array of two or three elements,
        /// specifying 
        /// x   ,
        /// y   ,
        /// z   
        /// coordinates, respectively.
        /// </para>
        /// </param>
        /// <seealso cref="Bitmap"/>
        /// <seealso cref="CopyPixels"/>
        /// <seealso cref="DrawArrays"/>
        /// <seealso cref="DrawElements"/>
        /// <seealso cref="DrawRangeElements"/>
        /// <seealso cref="DrawPixels"/>
        /// <seealso cref="MultiTexCoord"/>
        /// <seealso cref="RasterPos"/>
        /// <seealso cref="TexCoord"/>
        /// <seealso cref="TexGen"/>
        /// <seealso cref="Vertex"/>
        [Obsolete("Compatibility-only GL 1.4 features removed from GL 3.2")]
        public unsafe static void WindowPos3iv(ref int v) {
            fixed (int* pV = &v) {
                GLNative.glWindowPos3iv(pV);
            }
        }

        /// <summary>
        /// specify the raster position in window coordinates for pixel operations
        /// <para>Require:</para> <para>GL_VERSION_1_4</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glWindowPos"/> is available only if the GL version is 1.4 or greater.
        /// The raster position is modified by  <see cref="glRasterPos"/> ,  <see cref="glBitmap"/> , and
        /// <see cref="glWindowPos"/>.
        /// Calling  <see cref="glDrawElements"/> , or  <see cref="glDrawRangeElements"/>  may leave the
        /// current color or index indeterminate.
        /// If <see cref="glWindowPos"/> is executed while the current color or index is indeterminate, the
        /// current raster color or current raster index remains indeterminate.
        /// There are distinct raster texture coordinates for each texture unit. Each
        /// texture unit's current raster texture coordinates are updated by <see cref="glWindowPos"/>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glWindowPos"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glWindowPos3sv(const GLshort * v);</para>
        /// </summary>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array of two or three elements,
        /// specifying 
        /// x   ,
        /// y   ,
        /// z   
        /// coordinates, respectively.
        /// </para>
        /// </param>
        /// <seealso cref="Bitmap"/>
        /// <seealso cref="CopyPixels"/>
        /// <seealso cref="DrawArrays"/>
        /// <seealso cref="DrawElements"/>
        /// <seealso cref="DrawRangeElements"/>
        /// <seealso cref="DrawPixels"/>
        /// <seealso cref="MultiTexCoord"/>
        /// <seealso cref="RasterPos"/>
        /// <seealso cref="TexCoord"/>
        /// <seealso cref="TexGen"/>
        /// <seealso cref="Vertex"/>
        [Obsolete("Compatibility-only GL 1.4 features removed from GL 3.2")]
        public unsafe static void WindowPos3sv(ref short v) {
            fixed (short* pV = &v) {
                GLNative.glWindowPos3sv(pV);
            }
        }


        #region Promoted from ARB_imaging subset to core


        #endregion Promoted from ARB_imaging subset to core

        #endregion GL_VERSION_1_4

        #region GL_VERSION_1_5

        /// <summary>
        /// generate query object names
        /// <para>Require:</para> <para>GL_VERSION_1_5, GL_ES_VERSION_3_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <see cref="glGenQueries"/> is available only if the GL version is 1.5 or greater.
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="n"/> is negative.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glGenQueries"/> is executed
        /// between the execution of  <see cref="glBegin"/>  and the corresponding
        /// execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glGenQueries(GLsizei n, GLuint * ids);</para>
        /// </summary>
        /// <param name="n">
        /// Specifies the number of query object names to be generated.
        /// </param>
        /// <param name="ids">
        /// Specifies an array in which the generated query object names are stored.
        /// </param>
        /// <seealso cref="BeginQuery"/>
        /// <seealso cref="DeleteQueries"/>
        /// <seealso cref="EndQuery"/>
        public unsafe static void GenQueries(int n, ref uint ids) {
            fixed (uint* pIds = &ids) {
                GLNative.glGenQueries(n, pIds);
            }
        }

        /// <summary>
        /// delete named query objects
        /// <para>Require:</para> <para>GL_VERSION_1_5, GL_ES_VERSION_3_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <see cref="glDeleteQueries"/> is available only if the GL version is 1.5 or greater.
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="n"/> is negative.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glDeleteQueries"/> is executed
        /// between the execution of  <see cref="glBegin"/>  and the corresponding
        /// execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glDeleteQueries(GLsizei n, const GLuint * ids);</para>
        /// </summary>
        /// <param name="n">
        /// Specifies the number of query objects to be deleted.
        /// </param>
        /// <param name="ids">
        /// Specifies an array of query objects to be deleted.
        /// </param>
        /// <seealso cref="BeginQuery"/>
        /// <seealso cref="EndQuery"/>
        /// <seealso cref="GenQueries"/>
        /// <seealso cref="GetQueryiv"/>
        /// <seealso cref="GetQueryObject"/>
        public unsafe static void DeleteQueries(int n, ref uint ids) {
            fixed (uint* pIds = &ids) {
                GLNative.glDeleteQueries(n, pIds);
            }
        }

        /// <summary>
        /// return parameters of a query object target
        /// <para>Require:</para> <para>GL_VERSION_1_5, GL_ES_VERSION_3_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// If an error is generated,
        /// no change is made to the contents of <paramref name="ps"/>.
        /// <see cref="glGetQueryiv"/> is available only if the GL version is 1.5 or greater.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="target"/> or <paramref name="pname"/> is not an
        /// accepted value.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glGetQueryiv"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glGetQueryiv(GLenum target, GLenum pname, GLint * params);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies a query object target.
        /// Must be <code>GL_SAMPLES_PASSED</code>.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of a query object target parameter.
        /// Accepted values are <code>GL_CURRENT_QUERY</code> or <code>GL_QUERY_COUNTER_BITS</code>.
        /// </para>
        /// </param>
        /// <param name="ps">
        /// Returns the requested data.
        /// </param>
        /// <seealso cref="GetQueryObject"/>
        /// <seealso cref="IsQuery"/>
        public unsafe static void GetQueryiv(uint target, uint pname, ref int ps) {
            fixed (int* pPs = &ps) {
                GLNative.glGetQueryiv(target, pname, pPs);
            }
        }

        /// <summary>
        /// return parameters of a query object
        /// <para>Require:</para> <para>GL_VERSION_1_5</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// If an error is generated,
        /// no change is made to the contents of <paramref name="ps"/>.
        /// <see cref="glGetQueryObject"/> implicitly flushes the GL pipeline so that any incomplete rendering
        /// delimited by the occlusion query completes in finite time.
        /// If multiple queries are issued using the same query object <paramref name="id"/> before calling 
        /// <see cref="glGetQueryObject"/>, the results of the most recent query will be returned.  In this case,
        /// when issuing a new query, the results of the previous query are discarded.
        /// <see cref="glGetQueryObject"/> is available only if the GL version is 1.5 or greater.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="pname"/> is not an accepted value.
        /// <code>GL_INVALID_OPERATION</code> is generated if <paramref name="id"/> is not the name of a query object.
        /// <code>GL_INVALID_OPERATION</code> is generated if <paramref name="id"/> is the name of a currently active 
        /// query object.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glGetQueryObject"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glGetQueryObjectiv(GLuint id, GLenum pname, GLint * params);</para>
        /// </summary>
        /// <param name="id">
        /// Specifies the name of a query object.
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of a query object parameter.
        /// Accepted values are <code>GL_QUERY_RESULT</code> or <code>GL_QUERY_RESULT_AVAILABLE</code>.
        /// </para>
        /// </param>
        /// <param name="ps">
        /// Returns the requested data.
        /// </param>
        /// <seealso cref="BeginQuery"/>
        /// <seealso cref="EndQuery"/>
        /// <seealso cref="GetQueryiv"/>
        /// <seealso cref="IsQuery"/>
        public unsafe static void GetQueryObjectiv(uint id, uint pname, ref int ps) {
            fixed (int* pPs = &ps) {
                GLNative.glGetQueryObjectiv(id, pname, pPs);
            }
        }

        /// <summary>
        /// return parameters of a query object
        /// <para>Require:</para> <para>GL_VERSION_1_5, GL_ES_VERSION_3_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// If an error is generated,
        /// no change is made to the contents of <paramref name="ps"/>.
        /// <see cref="glGetQueryObject"/> implicitly flushes the GL pipeline so that any incomplete rendering
        /// delimited by the occlusion query completes in finite time.
        /// If multiple queries are issued using the same query object <paramref name="id"/> before calling 
        /// <see cref="glGetQueryObject"/>, the results of the most recent query will be returned.  In this case,
        /// when issuing a new query, the results of the previous query are discarded.
        /// <see cref="glGetQueryObject"/> is available only if the GL version is 1.5 or greater.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="pname"/> is not an accepted value.
        /// <code>GL_INVALID_OPERATION</code> is generated if <paramref name="id"/> is not the name of a query object.
        /// <code>GL_INVALID_OPERATION</code> is generated if <paramref name="id"/> is the name of a currently active 
        /// query object.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glGetQueryObject"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glGetQueryObjectuiv(GLuint id, GLenum pname, GLuint * params);</para>
        /// </summary>
        /// <param name="id">
        /// Specifies the name of a query object.
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of a query object parameter.
        /// Accepted values are <code>GL_QUERY_RESULT</code> or <code>GL_QUERY_RESULT_AVAILABLE</code>.
        /// </para>
        /// </param>
        /// <param name="ps">
        /// Returns the requested data.
        /// </param>
        /// <seealso cref="BeginQuery"/>
        /// <seealso cref="EndQuery"/>
        /// <seealso cref="GetQueryiv"/>
        /// <seealso cref="IsQuery"/>
        public unsafe static void GetQueryObjectuiv(uint id, uint pname, ref uint ps) {
            fixed (uint* pPs = &ps) {
                GLNative.glGetQueryObjectuiv(id, pname, pPs);
            }
        }

        /// <summary>
        /// delete named buffer objects
        /// <para>Require:</para> <para>GL_VERSION_1_5, GL_VERSION_ES_CM_1_0, GL_ES_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <see cref="glDeleteBuffers"/> is available only if the GL version is 1.5 or greater.
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="n"/> is negative.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glDeleteBuffers"/> is executed
        /// between the execution of  <see cref="glBegin"/>  and the corresponding
        /// execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glDeleteBuffers(GLsizei n, const GLuint * buffers);</para>
        /// </summary>
        /// <param name="n">
        /// Specifies the number of buffer objects to be deleted.
        /// </param>
        /// <param name="buffers">
        /// Specifies an array of buffer objects to be deleted.
        /// </param>
        /// <seealso cref="BindBuffer"/>
        /// <seealso cref="GenBuffers"/>
        /// <seealso cref="Get"/>
        public unsafe static void DeleteBuffers(int n, ref uint buffers) {
            fixed (uint* pBuffers = &buffers) {
                GLNative.glDeleteBuffers(n, pBuffers);
            }
        }

        /// <summary>
        /// generate buffer object names
        /// <para>Require:</para> <para>GL_VERSION_1_5, GL_VERSION_ES_CM_1_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <see cref="glGenBuffers"/> is available only if the GL version is 1.5 or greater.
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="n"/> is negative.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glGenBuffers"/> is executed
        /// between the execution of  <see cref="glBegin"/>  and the corresponding
        /// execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glGenBuffers(GLsizei n, GLuint * buffers);</para>
        /// </summary>
        /// <param name="n">
        /// Specifies the number of buffer object names to be generated.
        /// </param>
        /// <param name="buffers">
        /// Specifies an array in which the generated buffer object names are stored.
        /// </param>
        /// <seealso cref="BindBuffer"/>
        /// <seealso cref="DeleteBuffers"/>
        /// <seealso cref="Get"/>
        public unsafe static void GenBuffers(int n, ref uint buffers) {
            fixed (uint* pBuffers = &buffers) {
                GLNative.glGenBuffers(n, pBuffers);
            }
        }

        /// <summary>
        /// creates and initializes a buffer object's data store
        /// <para>Require:</para> <para>GL_VERSION_1_5, GL_VERSION_ES_CM_1_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glBufferData"/> is available only if the GL version is 1.5 or greater.
        /// Targets <code>GL_PIXEL_PACK_BUFFER</code> and <code>GL_PIXEL_UNPACK_BUFFER</code> are available 
        /// only if the GL version is 2.1 or greater.
        /// If <paramref name="data"/> is <code>NULL</code>, a data store of the specified size is still created,
        /// but its contents remain uninitialized and thus undefined.
        /// Clients must align data elements consistent with the requirements of the client
        /// platform, with an additional base-level requirement that an offset within a buffer to
        /// a datum comprising    N  bytes be a 
        /// multiple of  N   .
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="target"/> is not 
        /// <code>GL_ARRAY_BUFFER</code>, <code>GL_ELEMENT_ARRAY_BUFFER</code>, 
        /// <code>GL_PIXEL_PACK_BUFFER</code>, or <code>GL_PIXEL_UNPACK_BUFFER</code>.
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="usage"/> is not 
        /// <code>GL_STREAM_DRAW</code>, <code>GL_STREAM_READ</code>, <code>GL_STREAM_COPY</code>, 
        /// <code>GL_STATIC_DRAW</code>, <code>GL_STATIC_READ</code>, <code>GL_STATIC_COPY</code>, 
        /// <code>GL_DYNAMIC_DRAW</code>, <code>GL_DYNAMIC_READ</code>, or <code>GL_DYNAMIC_COPY</code>.
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="size"/> is negative.
        /// <code>GL_INVALID_OPERATION</code> is generated if the reserved buffer object name 0 is bound to <paramref name="target"/>.
        /// <code>GL_OUT_OF_MEMORY</code> is generated if the GL is unable to create a data store with the specified <paramref name="size"/>.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glBufferData"/>
        /// is executed between the execution of
        /// <see cref="glBegin"/>  and the corresponding execution of
        /// <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glBufferData(GLenum target, GLsizeiptr size, const void * data, GLenum usage);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target buffer object.
        /// The symbolic constant must be <code>GL_ARRAY_BUFFER</code>, 
        /// <code>GL_ELEMENT_ARRAY_BUFFER</code>,
        /// <code>GL_PIXEL_PACK_BUFFER</code>, or
        /// <code>GL_PIXEL_UNPACK_BUFFER</code>.
        /// </para>
        /// </param>
        /// <param name="size">
        /// Specifies the size in bytes of the buffer object's new data store.
        /// </param>
        /// <param name="data">
        /// <para>
        /// Specifies a pointer to data that will be copied into the data store for initialization,
        /// or <code>NULL</code> if no data is to be copied.
        /// </para>
        /// </param>
        /// <param name="usage">
        /// <para>
        /// Specifies the expected usage pattern of the data store. The symbolic constant must be
        /// <code>GL_STREAM_DRAW</code>, <code>GL_STREAM_READ</code>, <code>GL_STREAM_COPY</code>, 
        /// <code>GL_STATIC_DRAW</code>, <code>GL_STATIC_READ</code>, <code>GL_STATIC_COPY</code>, 
        /// <code>GL_DYNAMIC_DRAW</code>, <code>GL_DYNAMIC_READ</code>, or <code>GL_DYNAMIC_COPY</code>.
        /// </para>
        /// </param>
        /// <seealso cref="BindBuffer"/>
        /// <seealso cref="BufferSubData"/>
        /// <seealso cref="MapBuffer"/>
        /// <seealso cref="UnmapBuffer"/>
        public unsafe static void BufferData(uint target, IntPtr size, IntPtr data, uint usage) {
            GLNative.glBufferData(target, size, (void*)data, usage);
        }

        /// <summary>
        /// updates a subset of a buffer object's data store
        /// <para>Require:</para> <para>GL_VERSION_1_5, GL_VERSION_ES_CM_1_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glBufferSubData"/> is available only if the GL version is 1.5 or greater.
        /// Targets <code>GL_PIXEL_PACK_BUFFER</code> and <code>GL_PIXEL_UNPACK_BUFFER</code> are available 
        /// only if the GL version is 2.1 or greater.
        /// When replacing the entire data store, consider using <see cref="glBufferSubData"/> rather
        /// than completely recreating the data store with <see cref="glBufferData"/>.  This avoids the cost of
        /// reallocating the data store.
        /// Consider using multiple buffer objects to avoid stalling the rendering pipeline during data store updates.
        /// If any rendering in the pipeline makes reference to data in the buffer object being updated by 
        /// <see cref="glBufferSubData"/>, especially from the specific region being updated, that rendering must 
        /// drain from the pipeline before the data store can be updated.
        /// Clients must align data elements consistent with the requirements of the client
        /// platform, with an additional base-level requirement that an offset within a buffer to
        /// a datum comprising    N  bytes be a 
        /// multiple of  N   .
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="target"/> is not 
        /// <code>GL_ARRAY_BUFFER</code>, <code>GL_ELEMENT_ARRAY_BUFFER</code>, 
        /// <code>GL_PIXEL_PACK_BUFFER</code>, or <code>GL_PIXEL_UNPACK_BUFFER</code>.
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="offset"/> or 
        /// <paramref name="size"/> is negative, or if together they define a region of memory
        /// that extends beyond the buffer object's allocated data store.
        /// <code>GL_INVALID_OPERATION</code> is generated if the reserved buffer object name 0 is bound to <paramref name="target"/>.
        /// <code>GL_INVALID_OPERATION</code> is generated if the buffer object being updated is mapped.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glBufferSubData"/>
        /// is executed between the execution of
        /// <see cref="glBegin"/>  and the corresponding execution of
        /// <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glBufferSubData(GLenum target, GLintptr offset, GLsizeiptr size, const void * data);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target buffer object.
        /// The symbolic constant must be <code>GL_ARRAY_BUFFER</code>, 
        /// <code>GL_ELEMENT_ARRAY_BUFFER</code>,
        /// <code>GL_PIXEL_PACK_BUFFER</code>, or
        /// <code>GL_PIXEL_UNPACK_BUFFER</code>.
        /// </para>
        /// </param>
        /// <param name="offset">
        /// <para>
        /// Specifies the offset into the buffer object's data store where data replacement will begin,
        /// measured in bytes.
        /// </para>
        /// </param>
        /// <param name="size">
        /// Specifies the size in bytes of the data store region being replaced.
        /// </param>
        /// <param name="data">
        /// Specifies a pointer to the new data that will be copied into the data store.
        /// </param>
        /// <seealso cref="BindBuffer"/>
        /// <seealso cref="BufferData"/>
        /// <seealso cref="MapBuffer"/>
        /// <seealso cref="UnmapBuffer"/>
        public unsafe static void BufferSubData(uint target, IntPtr offset, IntPtr size, IntPtr data) {
            GLNative.glBufferSubData(target, offset, size, (void*)data);
        }

        /// <summary>
        /// returns a subset of a buffer object's data store
        /// <para>Require:</para> <para>GL_VERSION_1_5</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// If an error is generated,
        /// no change is made to the contents of <paramref name="data"/>.
        /// <see cref="glGetBufferSubData"/> is available only if the GL version is 1.5 or greater.
        /// Targets <code>GL_PIXEL_PACK_BUFFER</code> and <code>GL_PIXEL_UNPACK_BUFFER</code> are available 
        /// only if the GL version is 2.1 or greater.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="target"/> is not 
        /// <code>GL_ARRAY_BUFFER</code>, <code>GL_ELEMENT_ARRAY_BUFFER</code>, 
        /// <code>GL_PIXEL_PACK_BUFFER</code>, or <code>GL_PIXEL_UNPACK_BUFFER</code>.
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="offset"/> or 
        /// <paramref name="size"/> is negative, or if together they define a region of memory
        /// that extends beyond the buffer object's allocated data store.
        /// <code>GL_INVALID_OPERATION</code> is generated if the reserved buffer object name 0 is bound to <paramref name="target"/>.
        /// <code>GL_INVALID_OPERATION</code> is generated if the buffer object being queried is mapped.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glGetBufferSubData"/>
        /// is executed between the execution of
        /// <see cref="glBegin"/>  and the corresponding execution of
        /// <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glGetBufferSubData(GLenum target, GLintptr offset, GLsizeiptr size, void * data);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target buffer object.
        /// The symbolic constant must be <code>GL_ARRAY_BUFFER</code>, 
        /// <code>GL_ELEMENT_ARRAY_BUFFER</code>,
        /// <code>GL_PIXEL_PACK_BUFFER</code>, or
        /// <code>GL_PIXEL_UNPACK_BUFFER</code>.
        /// </para>
        /// </param>
        /// <param name="offset">
        /// <para>
        /// Specifies the offset into the buffer object's data store from which data will be returned,
        /// measured in bytes.
        /// </para>
        /// </param>
        /// <param name="size">
        /// Specifies the size in bytes of the data store region being returned.
        /// </param>
        /// <param name="data">
        /// Specifies a pointer to the location where buffer object data is returned.
        /// </param>
        /// <seealso cref="BindBuffer"/>
        /// <seealso cref="BufferData"/>
        /// <seealso cref="BufferSubData"/>
        /// <seealso cref="MapBuffer"/>
        /// <seealso cref="UnmapBuffer"/>
        public unsafe static void GetBufferSubData(uint target, IntPtr offset, IntPtr size, IntPtr data) {
            GLNative.glGetBufferSubData(target, offset, size, (void*)data);
        }

        /// <summary>
        /// map a buffer object's data store
        /// <para>Require:</para> <para>GL_VERSION_1_5</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// If an error is generated, <see cref="glMapBuffer"/> returns <code>NULL</code>, and
        /// <see cref="glUnmapBuffer"/> returns <code>GL_FALSE</code>.
        /// <see cref="glMapBuffer"/> and <see cref="glUnmapBuffer"/> are available only if the GL version is 1.5 or greater.
        /// <code>GL_PIXEL_PACK_BUFFER</code> and <code>GL_PIXEL_UNPACK_BUFFER</code> are 
        /// available only if the GL version is 2.1 or greater.
        /// Parameter values passed to GL commands may not be sourced from the returned pointer. No error will be generated,
        /// but results will be undefined and will likely vary across GL implementations.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="target"/> is not 
        /// <code>GL_ARRAY_BUFFER</code>, <code>GL_ELEMENT_ARRAY_BUFFER</code>, 
        /// <code>GL_PIXEL_PACK_BUFFER</code>, or <code>GL_PIXEL_UNPACK_BUFFER</code>.
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="access"/> is not 
        /// <code>GL_READ_ONLY</code>, <code>GL_WRITE_ONLY</code>, or <code>GL_READ_WRITE</code>.
        /// <code>GL_OUT_OF_MEMORY</code> is generated when <see cref="glMapBuffer"/> is executed
        /// if the GL is unable to map the buffer object's data store. This may occur for a variety of system-specific 
        /// reasons, such as the absence of sufficient remaining virtual memory.
        /// <code>GL_INVALID_OPERATION</code> is generated if the reserved buffer object name 0 is bound to <paramref name="target"/>.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glMapBuffer"/> is executed for
        /// a buffer object whose data store is already mapped.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glUnmapBuffer"/> is executed for
        /// a buffer object whose data store is not currently mapped.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glMapBuffer"/> or <see cref="glUnmapBuffer"/> is executed
        /// between the execution of  <see cref="glBegin"/>  and the corresponding
        /// execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void * glMapBuffer(GLenum target, GLenum access);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target buffer object being mapped.
        /// The symbolic constant must be
        /// <code>GL_ARRAY_BUFFER</code>,
        /// <code>GL_ELEMENT_ARRAY_BUFFER</code>,
        /// <code>GL_PIXEL_PACK_BUFFER</code>, or
        /// <code>GL_PIXEL_UNPACK_BUFFER</code>.
        /// </para>
        /// </param>
        /// <param name="access">
        /// <para>
        /// Specifies the access policy, indicating whether it will be possible to read from, write to,
        /// or both read from and write to the buffer object's mapped data store. The symbolic constant must be
        /// <code>GL_READ_ONLY</code>, <code>GL_WRITE_ONLY</code>, or <code>GL_READ_WRITE</code>.
        /// </para>
        /// </param>
        /// <seealso cref="BindBuffer"/>
        /// <seealso cref="BufferData"/>
        /// <seealso cref="BufferSubData"/>
        /// <seealso cref="DeleteBuffers"/>
        public unsafe static IntPtr MapBuffer(uint target, uint access) {
            return (IntPtr)GLNative.glMapBuffer(target, access);
        }

        /// <summary>
        /// return parameters of a buffer object
        /// <para>Require:</para> <para>GL_VERSION_1_5, GL_VERSION_ES_CM_1_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// If an error is generated,
        /// no change is made to the contents of <paramref name="data"/>.
        /// <see cref="glGetBufferParameteriv"/> is available only if the GL version is 1.5 or greater.
        /// Targets <code>GL_PIXEL_PACK_BUFFER</code> and <code>GL_PIXEL_UNPACK_BUFFER</code> are available 
        /// only if the GL version is 2.1 or greater.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="target"/> or <paramref name="value"/> is not an
        /// accepted value.
        /// <code>GL_INVALID_OPERATION</code> is generated if the reserved buffer object name 0 is bound to <paramref name="target"/>.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glGetBufferParameteriv"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glGetBufferParameteriv(GLenum target, GLenum value, GLint * data);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target buffer object.
        /// The symbolic constant must be <code>GL_ARRAY_BUFFER</code>, 
        /// <code>GL_ELEMENT_ARRAY_BUFFER</code>,
        /// <code>GL_PIXEL_PACK_BUFFER</code>, or
        /// <code>GL_PIXEL_UNPACK_BUFFER</code>.
        /// </para>
        /// </param>
        /// <param name="value">
        /// <para>
        /// Specifies the symbolic name of a buffer object parameter.
        /// Accepted values are <code>GL_BUFFER_ACCESS</code>, <code>GL_BUFFER_MAPPED</code>, 
        /// <code>GL_BUFFER_SIZE</code>, or <code>GL_BUFFER_USAGE</code>.
        /// </para>
        /// </param>
        /// <param name="data">
        /// Returns the requested parameter.
        /// </param>
        /// <seealso cref="BindBuffer"/>
        /// <seealso cref="BufferData"/>
        /// <seealso cref="MapBuffer"/>
        /// <seealso cref="UnmapBuffer"/>
        public unsafe static void GetBufferParameteriv(uint target, uint value, ref int data) {
            fixed (int* pData = &data) {
                GLNative.glGetBufferParameteriv(target, value, pData);
            }
        }

        /// <summary>
        /// return the pointer to a mapped buffer object's data store
        /// <para>Require:</para> <para>GL_VERSION_1_5, GL_ES_VERSION_3_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// If an error is generated,
        /// no change is made to the contents of <paramref name="ps"/>.
        /// <see cref="glGetBufferPointerv"/> is available only if the GL version is 1.5 or greater.
        /// Targets <code>GL_PIXEL_PACK_BUFFER</code> and <code>GL_PIXEL_UNPACK_BUFFER</code> are available 
        /// only if the GL version is 2.1 or greater.
        /// The initial value for the pointer is <code>NULL</code>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="target"/> or <paramref name="pname"/> is not an
        /// accepted value.
        /// <code>GL_INVALID_OPERATION</code> is generated if the reserved buffer object name 0 is bound to <paramref name="target"/>.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glGetBufferPointerv"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glGetBufferPointerv(GLenum target, GLenum pname, void ** params);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target buffer object.
        /// The symbolic constant must be <code>GL_ARRAY_BUFFER</code>, 
        /// <code>GL_ELEMENT_ARRAY_BUFFER</code>,
        /// <code>GL_PIXEL_PACK_BUFFER</code>, or
        /// <code>GL_PIXEL_UNPACK_BUFFER</code>.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// Specifies the pointer to be returned.  The symbolic constant must be <code>GL_BUFFER_MAP_POINTER</code>.
        /// </param>
        /// <param name="ps">
        /// Returns the pointer value specified by <paramref name="pname"/>.
        /// </param>
        /// <seealso cref="BindBuffer"/>
        /// <seealso cref="MapBuffer"/>
        public unsafe static void GetBufferPointerv(uint target, uint pname, IntPtr ps) {
            GLNative.glGetBufferPointerv(target, pname, (void**)ps);
        }


        #endregion GL_VERSION_1_5

        #region GL_VERSION_2_0

        /// <summary>
        /// Specifies a list of color buffers to be drawn into
        /// <para>Require:</para> <para>GL_VERSION_2_0, GL_ES_VERSION_3_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glDrawBuffers"/> is available only if
        /// the GL version is 2.0 or greater. 
        /// It is always the case that <code>GL_AUXi</code> =
        /// <code>GL_AUX0</code> + <code>i</code>. 
        /// The symbolic constants <code>GL_FRONT</code>,
        /// <code>GL_BACK</code>, <code>GL_LEFT</code>,
        /// <code>GL_RIGHT</code>, and
        /// <code>GL_FRONT_AND_BACK</code> are not allowed in the
        /// <paramref name="bufs"/> array since they may refer to
        /// multiple buffers. 
        /// If a fragment shader writes to neither
        /// <code>gl_FragColor</code> nor
        /// <code>gl_FragData</code>, the values of the fragment
        /// colors following shader execution are undefined. For each
        /// fragment generated in this situation, a different value may be
        /// written into each of the buffers specified by
        /// <paramref name="bufs"/>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if one of the
        /// values in <paramref name="bufs"/> is not an accepted
        /// value. 
        /// <code>GL_INVALID_ENUM</code> is generated if
        /// <paramref name="n"/> is less than 0. 
        /// <code>GL_INVALID_OPERATION</code> is generated if a
        /// symbolic constant other than <code>GL_NONE</code>
        /// appears more than once in <paramref name="bufs"/>. 
        /// <code>GL_INVALID_OPERATION</code> is generated if any of
        /// the entries in <paramref name="bufs"/> (other than
        /// <code>GL_NONE</code> ) indicates a color buffer that
        /// does not exist in the current GL context. 
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="n"/> is greater than
        /// <code>GL_MAX_DRAW_BUFFERS</code>. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <see cref="glDrawBuffers"/> is executed between the
        /// execution of
        /// <see cref="glBegin"/> 
        /// and the corresponding execution of
        /// <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glDrawBuffers(GLsizei n, const GLenum * bufs);</para>
        /// </summary>
        /// <param name="n">
        /// <para>
        /// Specifies the number of buffers in
        /// <paramref name="bufs"/>.
        /// </para>
        /// </param>
        /// <param name="bufs">
        /// <para>
        /// Points to an array of symbolic constants
        /// specifying the buffers into which fragment colors or
        /// data values will be written.
        /// </para>
        /// </param>
        /// <seealso cref="BlendFunc"/>
        /// <seealso cref="ColorMask"/>
        /// <seealso cref="DrawBuffers"/>
        /// <seealso cref="IndexMask"/>
        /// <seealso cref="LogicOp"/>
        /// <seealso cref="ReadBuffer"/>
        public unsafe static void DrawBuffers(int n, ref uint bufs) {
            fixed (uint* pBufs = &bufs) {
                GLNative.glDrawBuffers(n, pBufs);
            }
        }

        /// <summary>
        /// Associates a generic vertex attribute index with a named attribute variable
        /// <para>Require:</para> <para>GL_VERSION_2_0, GL_ES_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glBindAttribLocation"/> is available
        /// only if the GL version is 2.0 or greater. 
        /// <see cref="glBindAttribLocation"/> can be called
        /// before any vertex shader objects are bound to the specified
        /// program object. It is also permissible to bind a generic
        /// attribute index to an attribute variable name that is never used
        /// in a vertex shader. 
        /// If <paramref name="name"/> was bound previously, that
        /// information is lost. Thus you cannot bind one user-defined
        /// attribute variable to multiple indices, but you can bind
        /// multiple user-defined attribute variables to the same
        /// index. 
        /// Applications are allowed to bind more than one
        /// user-defined attribute variable to the same generic vertex
        /// attribute index. This is called  aliasing ,
        /// and it is allowed only if just one of the aliased attributes is
        /// active in the executable program, or if no path through the
        /// shader consumes more than one attribute of a set of attributes
        /// aliased to the same location. The compiler and linker are
        /// allowed to assume that no aliasing is done and are free to
        /// employ optimizations that work only in the absence of aliasing.
        /// OpenGL implementations are not required to do error checking to
        /// detect aliasing. Because there is no way to bind standard
        /// attributes, it is not possible to alias generic attributes with
        /// conventional ones (except for generic attribute 0). 
        /// Active attributes that are not explicitly bound will be
        /// bound by the linker when
        /// <see cref="glLinkProgram"/> 
        /// is called. The locations assigned can be queried by calling
        /// <see cref="glGetAttribLocation"/> . 
        /// OpenGL copies the <paramref name="name"/> string when
        /// <see cref="glBindAttribLocation"/> is called, so an
        /// application may free its copy of the <paramref name="name"/>
        /// string immediately after the function returns.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="index"/> is greater than or equal to
        /// <code>GL_MAX_VERTEX_ATTRIBS</code>. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <paramref name="name"/> starts with the reserved prefix
        /// &quot;gl_&quot;. 
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="program"/> is not a value generated by
        /// OpenGL. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <paramref name="program"/> is not a program object. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <see cref="glBindAttribLocation"/> is executed between
        /// the execution of
        /// <see cref="glBegin"/> 
        /// and the corresponding execution of
        /// <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glBindAttribLocation(GLuint program, GLuint index, const GLchar * name);</para>
        /// </summary>
        /// <param name="program">
        /// <para>
        /// Specifies the handle of the program object in
        /// which the association is to be made.
        /// </para>
        /// </param>
        /// <param name="index">
        /// <para>
        /// Specifies the index of the generic vertex
        /// attribute to be bound.
        /// </para>
        /// </param>
        /// <param name="name">
        /// <para>
        /// Specifies a null terminated string containing
        /// the name of the vertex shader attribute variable to
        /// which <paramref name="index"/> is to be
        /// bound.
        /// </para>
        /// </param>
        /// <seealso cref="DisableVertexAttribArray"/>
        /// <seealso cref="EnableVertexAttribArray"/>
        /// <seealso cref="UseProgram"/>
        /// <seealso cref="VertexAttrib"/>
        /// <seealso cref="VertexAttribPointer"/>
        public unsafe static void BindAttribLocation(uint program, uint index, ref byte name) {
            fixed (byte* pName = &name) {
                GLNative.glBindAttribLocation(program, index, pName);
            }
        }

        /// <summary>
        /// Returns information about an active attribute variable for the specified program object
        /// <para>Require:</para> <para>GL_VERSION_2_0, GL_ES_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glGetActiveAttrib"/>
        /// is available only if the GL version is 2.0 or greater. 
        /// <code>GL_FLOAT_MAT2x3</code>,
        /// <code>GL_FLOAT_MAT2x4</code>,
        /// <code>GL_FLOAT_MAT3x2</code>,
        /// <code>GL_FLOAT_MAT3x4</code>,
        /// <code>GL_FLOAT_MAT4x2</code>, and
        /// <code>GL_FLOAT_MAT4x3</code>
        /// will only be returned as a <paramref name="type"/>
        /// if the GL version is 2.1 or greater.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="program"/> is not a value generated by
        /// OpenGL. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <paramref name="program"/> is not a program object. 
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="index"/> is greater than or equal to the
        /// number of active attribute variables in
        /// <paramref name="program"/>. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <see cref="glGetActiveAttrib"/> is executed between the
        /// execution of
        /// <see cref="glBegin"/> 
        /// and the corresponding execution of
        /// <see cref="glEnd"/> . 
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="bufSize"/> is less than 0.
        /// </para>
        /// Original: <para>void glGetActiveAttrib(GLuint program, GLuint index, GLsizei bufSize, GLsizei * length, GLint * size, GLenum * type, GLchar * name);</para>
        /// </summary>
        /// <param name="program">
        /// <para>
        /// Specifies the program object to be
        /// queried.
        /// </para>
        /// </param>
        /// <param name="index">
        /// <para>
        /// Specifies the index of the attribute variable
        /// to be queried.
        /// </para>
        /// </param>
        /// <param name="bufSize">
        /// <para>
        /// Specifies the maximum number of characters
        /// OpenGL is allowed to write in the character buffer
        /// indicated by <paramref name="name"/>.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// Returns the number of characters actually
        /// written by OpenGL in the string indicated by
        /// <paramref name="name"/> (excluding the null
        /// terminator) if a value other than
        /// <code>NULL</code> is passed.
        /// </para>
        /// </param>
        /// <param name="size">
        /// <para>
        /// Returns the size of the attribute
        /// variable.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Returns the data type of the attribute
        /// variable.
        /// </para>
        /// </param>
        /// <param name="name">
        /// <para>
        /// Returns a null terminated string containing
        /// the name of the attribute variable.
        /// </para>
        /// </param>
        /// <seealso cref="BindAttribLocation"/>
        /// <seealso cref="LinkProgram"/>
        /// <seealso cref="VertexAttrib"/>
        /// <seealso cref="VertexAttribPointer"/>
        public unsafe static void GetActiveAttrib(uint program, uint index, int bufSize, ref int length, ref int size, ref uint type, ref byte name) {
            fixed (int* pLength = &length)
            fixed (int* pSize = &size)
            fixed (uint* pType = &type)
            fixed (byte* pName = &name) {
                GLNative.glGetActiveAttrib(program, index, bufSize, pLength, pSize, pType, pName);
            }
        }

        /// <summary>
        /// Returns information about an active uniform variable for the specified program object
        /// <para>Require:</para> <para>GL_VERSION_2_0, GL_ES_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glGetActiveUniform"/> is available only
        /// if the GL version is 2.0 or greater. 
        /// <code>GL_FLOAT_MAT2x3</code>,
        /// <code>GL_FLOAT_MAT2x4</code>,
        /// <code>GL_FLOAT_MAT3x2</code>,
        /// <code>GL_FLOAT_MAT3x4</code>,
        /// <code>GL_FLOAT_MAT4x2</code>, and
        /// <code>GL_FLOAT_MAT4x3</code>
        /// will only be returned as a <paramref name="type"/>
        /// if the GL version is 2.1 or greater.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="program"/> is not a value generated by
        /// OpenGL. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <paramref name="program"/> is not a program object. 
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="index"/> is greater than or equal to the
        /// number of active uniform variables in
        /// <paramref name="program"/>. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <see cref="glGetActiveUniform"/> is executed between the
        /// execution of
        /// <see cref="glBegin"/> 
        /// and the corresponding execution of
        /// <see cref="glEnd"/> . 
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="bufSize"/> is less than 0.
        /// </para>
        /// Original: <para>void glGetActiveUniform(GLuint program, GLuint index, GLsizei bufSize, GLsizei * length, GLint * size, GLenum * type, GLchar * name);</para>
        /// </summary>
        /// <param name="program">
        /// <para>
        /// Specifies the program object to be
        /// queried.
        /// </para>
        /// </param>
        /// <param name="index">
        /// <para>
        /// Specifies the index of the uniform variable to
        /// be queried.
        /// </para>
        /// </param>
        /// <param name="bufSize">
        /// <para>
        /// Specifies the maximum number of characters
        /// OpenGL is allowed to write in the character buffer
        /// indicated by <paramref name="name"/>.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// Returns the number of characters actually
        /// written by OpenGL in the string indicated by
        /// <paramref name="name"/> (excluding the null
        /// terminator) if a value other than
        /// <code>NULL</code> is passed.
        /// </para>
        /// </param>
        /// <param name="size">
        /// <para>
        /// Returns the size of the uniform
        /// variable.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Returns the data type of the uniform
        /// variable.
        /// </para>
        /// </param>
        /// <param name="name">
        /// <para>
        /// Returns a null terminated string containing
        /// the name of the uniform variable.
        /// </para>
        /// </param>
        /// <seealso cref="GetUniform"/>
        /// <seealso cref="GetUniformLocation"/>
        /// <seealso cref="LinkProgram"/>
        /// <seealso cref="Uniform"/>
        /// <seealso cref="UseProgram"/>
        public unsafe static void GetActiveUniform(uint program, uint index, int bufSize, ref int length, ref int size, ref uint type, ref byte name) {
            fixed (int* pLength = &length)
            fixed (int* pSize = &size)
            fixed (uint* pType = &type)
            fixed (byte* pName = &name) {
                GLNative.glGetActiveUniform(program, index, bufSize, pLength, pSize, pType, pName);
            }
        }

        /// <summary>
        /// Returns the handles of the shader objects attached to a program object
        /// <para>Require:</para> <para>GL_VERSION_2_0, GL_ES_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glGetAttachedShaders"/>
        /// is available only if the GL version is 2.0 or greater.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="program"/> is not a value generated by
        /// OpenGL. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <paramref name="program"/> is not a program object. 
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="maxCount"/> is less than 0. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <see cref="glGetAttachedShaders"/> 
        /// is executed between the execution of
        /// <see cref="glBegin"/> 
        /// and the corresponding execution of
        /// <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glGetAttachedShaders(GLuint program, GLsizei maxCount, GLsizei * count, GLuint * shaders);</para>
        /// </summary>
        /// <param name="program">
        /// <para>
        /// Specifies the program object to be
        /// queried.
        /// </para>
        /// </param>
        /// <param name="maxCount">
        /// <para>
        /// Specifies the size of the array for storing
        /// the returned object names.
        /// </para>
        /// </param>
        /// <param name="count">
        /// <para>
        /// Returns the number of names actually returned
        /// in <paramref name="shaders"/>.
        /// </para>
        /// </param>
        /// <param name="shaders">
        /// <para>
        /// Specifies an array that is used to return the
        /// names of attached shader objects.
        /// </para>
        /// </param>
        /// <seealso cref="AttachShader"/>
        /// <seealso cref="DetachShader"/>
        public unsafe static void GetAttachedShaders(uint program, int maxCount, ref int count, ref uint shaders) {
            fixed (int* pCount = &count)
            fixed (uint* pShaders = &shaders) {
                GLNative.glGetAttachedShaders(program, maxCount, pCount, pShaders);
            }
        }

        /// <summary>
        /// Returns the location of an attribute variable
        /// <para>Require:</para> <para>GL_VERSION_2_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glGetAttribLocation"/> is available only
        /// if the GL version is 2.0 or greater.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <paramref name="program"/> is not a value generated by
        /// OpenGL. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <paramref name="program"/> is not a program object. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <paramref name="program"/> has not been successfully
        /// linked. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <see cref="glGetAttribLocation"/> is executed between the
        /// execution of
        /// <see cref="glBegin"/> 
        /// and the corresponding execution of
        /// <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>GLint glGetAttribLocation(GLuint program, const GLchar * name);</para>
        /// </summary>
        /// <param name="program">
        /// <para>
        /// Specifies the program object to be
        /// queried.
        /// </para>
        /// </param>
        /// <param name="name">
        /// <para>
        /// Points to a null terminated string containing
        /// the name of the attribute variable whose location is
        /// to be queried.
        /// </para>
        /// </param>
        /// <seealso cref="BindAttribLocation"/>
        /// <seealso cref="LinkProgram"/>
        /// <seealso cref="VertexAttrib"/>
        /// <seealso cref="VertexAttribPointer"/>
        public unsafe static int GetAttribLocation(uint program, ref byte name) {
            fixed (byte* pName = &name) {
                return GLNative.glGetAttribLocation(program, pName);
            }
        }

        /// <summary>
        /// Returns a parameter from a program object
        /// <para>Require:</para> <para>GL_VERSION_2_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glGetProgram"/> is available only if the
        /// GL version is 2.0 or greater. 
        /// If an error is generated, no change is made to the
        /// contents of <paramref name="ps"/>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code>
        /// is generated if <paramref name="program"/>
        /// is not a value generated by OpenGL. 
        /// <code>GL_INVALID_OPERATION</code>
        /// is generated if <paramref name="program"/>
        /// does not refer to a program object. 
        /// <code>GL_INVALID_ENUM</code>
        /// is generated if <paramref name="pname"/>
        /// is not an accepted value. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <see cref="glGetProgram"/> is executed between the
        /// execution of
        /// <see cref="glBegin"/> 
        /// and the corresponding execution of
        /// <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glGetProgramiv(GLuint program, GLenum pname, GLint * params);</para>
        /// </summary>
        /// <param name="program">
        /// <para>
        /// Specifies the program object to be
        /// queried.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the object parameter. Accepted
        /// symbolic names are
        /// <code>GL_DELETE_STATUS</code>,
        /// <code>GL_LINK_STATUS</code>,
        /// <code>GL_VALIDATE_STATUS</code>,
        /// <code>GL_INFO_LOG_LENGTH</code>,
        /// <code>GL_ATTACHED_SHADERS</code>,
        /// <code>GL_ACTIVE_ATTRIBUTES</code>,
        /// <code>GL_ACTIVE_ATTRIBUTE_MAX_LENGTH</code>,
        /// <code>GL_ACTIVE_UNIFORMS</code>,
        /// <code>GL_ACTIVE_UNIFORM_MAX_LENGTH</code>.
        /// </para>
        /// </param>
        /// <param name="ps">
        /// Returns the requested object parameter.
        /// </param>
        /// <seealso cref="AttachShader"/>
        /// <seealso cref="CreateProgram"/>
        /// <seealso cref="DeleteProgram"/>
        /// <seealso cref="GetShader"/>
        /// <seealso cref="LinkProgram"/>
        /// <seealso cref="ValidateProgram"/>
        public unsafe static void GetProgramiv(uint program, uint pname, ref int ps) {
            fixed (int* pPs = &ps) {
                GLNative.glGetProgramiv(program, pname, pPs);
            }
        }

        /// <summary>
        /// Returns the information log for a program object
        /// <para>Require:</para> <para>GL_VERSION_2_0, GL_ES_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glGetProgramInfoLog"/> is available only
        /// if the GL version is 2.0 or greater. 
        /// The information log for a program object is the OpenGL
        /// implementer's primary mechanism for conveying information about
        /// linking and validating. Therefore, the information log can be
        /// helpful to application developers during the development
        /// process, even when these operations are successful. Application
        /// developers should not expect different OpenGL implementations to
        /// produce identical information logs.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="program"/> is not a value generated by
        /// OpenGL. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <paramref name="program"/> is not a program object. 
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="maxLength"/> is less than 0. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <see cref="glGetProgramInfoLog"/> is executed between the
        /// execution of
        /// <see cref="glBegin"/> 
        /// and the corresponding execution of
        /// <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glGetProgramInfoLog(GLuint program, GLsizei maxLength, GLsizei * length, GLchar * infoLog);</para>
        /// </summary>
        /// <param name="program">
        /// <para>
        /// Specifies the program object whose information
        /// log is to be queried.
        /// </para>
        /// </param>
        /// <param name="maxLength">
        /// <para>
        /// Specifies the size of the character buffer for
        /// storing the returned information log.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// Returns the length of the string returned in
        /// <paramref name="infoLog"/> (excluding the null
        /// terminator).
        /// </para>
        /// </param>
        /// <param name="infoLog">
        /// <para>
        /// Specifies an array of characters that is used
        /// to return the information log.
        /// </para>
        /// </param>
        /// <seealso cref="CompileShader"/>
        /// <seealso cref="GetShaderInfoLog"/>
        /// <seealso cref="LinkProgram"/>
        /// <seealso cref="ValidateProgram"/>
        public unsafe static void GetProgramInfoLog(uint program, int maxLength, ref int length, ref byte infoLog) {
            fixed (int* pLength = &length)
            fixed (byte* pInfoLog = &infoLog) {
                GLNative.glGetProgramInfoLog(program, maxLength, pLength, pInfoLog);
            }
        }

        /// <summary>
        /// Returns a parameter from a shader object
        /// <para>Require:</para> <para>GL_VERSION_2_0, GL_ES_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glGetShader"/> is available only if the
        /// GL version is 2.0 or greater. 
        /// If an error is generated, no change is made to the
        /// contents of <paramref name="ps"/>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="shader"/> is not a value generated by
        /// OpenGL. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <paramref name="shader"/> does not refer to a shader
        /// object. 
        /// <code>GL_INVALID_ENUM</code> is generated if
        /// <paramref name="pname"/> is not an accepted value. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <see cref="glGetShader"/> is executed between the
        /// execution of
        /// <see cref="glBegin"/> 
        /// and the corresponding execution of
        /// <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glGetShaderiv(GLuint shader, GLenum pname, GLint * params);</para>
        /// </summary>
        /// <param name="shader">
        /// <para>
        /// Specifies the shader object to be
        /// queried.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the object parameter. Accepted
        /// symbolic names are
        /// <code>GL_SHADER_TYPE</code>,
        /// <code>GL_DELETE_STATUS</code>,
        /// <code>GL_COMPILE_STATUS</code>,
        /// <code>GL_INFO_LOG_LENGTH</code>,
        /// <code>GL_SHADER_SOURCE_LENGTH</code>.
        /// </para>
        /// </param>
        /// <param name="ps">
        /// Returns the requested object parameter.
        /// </param>
        /// <seealso cref="CompileShader"/>
        /// <seealso cref="CreateShader"/>
        /// <seealso cref="DeleteShader"/>
        /// <seealso cref="GetProgram"/>
        /// <seealso cref="ShaderSource"/>
        public unsafe static void GetShaderiv(uint shader, uint pname, ref int ps) {
            fixed (int* pPs = &ps) {
                GLNative.glGetShaderiv(shader, pname, pPs);
            }
        }

        /// <summary>
        /// Returns the information log for a shader object
        /// <para>Require:</para> <para>GL_VERSION_2_0, GL_ES_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glGetShaderInfoLog"/> is available only
        /// if the GL version is 2.0 or greater. 
        /// The information log for a shader object is the OpenGL
        /// implementer's primary mechanism for conveying information about
        /// the compilation process. Therefore, the information log can be
        /// helpful to application developers during the development
        /// process, even when compilation is successful. Application
        /// developers should not expect different OpenGL implementations to
        /// produce identical information logs.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="shader"/> is not a value generated by
        /// OpenGL. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <paramref name="shader"/> is not a shader object. 
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="maxLength"/> is less than 0. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <see cref="glGetShaderInfoLog"/> is executed between the
        /// execution of
        /// <see cref="glBegin"/> 
        /// and the corresponding execution of
        /// <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glGetShaderInfoLog(GLuint shader, GLsizei maxLength, GLsizei * length, GLchar * infoLog);</para>
        /// </summary>
        /// <param name="shader">
        /// <para>
        /// Specifies the shader object whose information
        /// log is to be queried.
        /// </para>
        /// </param>
        /// <param name="maxLength">
        /// <para>
        /// Specifies the size of the character buffer for
        /// storing the returned information log.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// Returns the length of the string returned in
        /// <paramref name="infoLog"/> (excluding the null
        /// terminator).
        /// </para>
        /// </param>
        /// <param name="infoLog">
        /// <para>
        /// Specifies an array of characters that is used
        /// to return the information log.
        /// </para>
        /// </param>
        /// <seealso cref="CompileShader"/>
        /// <seealso cref="GetProgramInfoLog"/>
        /// <seealso cref="LinkProgram"/>
        /// <seealso cref="ValidateProgram"/>
        public unsafe static void GetShaderInfoLog(uint shader, int maxLength, ref int length, ref byte infoLog) {
            fixed (int* pLength = &length)
            fixed (byte* pInfoLog = &infoLog) {
                GLNative.glGetShaderInfoLog(shader, maxLength, pLength, pInfoLog);
            }
        }

        /// <summary>
        /// Returns the source code string from a shader object
        /// <para>Require:</para> <para>GL_VERSION_2_0, GL_ES_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glGetShaderSource"/> is available only
        /// if the GL version is 2.0 or greater.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="shader"/> is not a value generated by
        /// OpenGL. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <paramref name="shader"/> is not a shader object. 
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="bufSize"/> is less than 0. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <see cref="glGetShaderSource"/> is executed between the
        /// execution of
        /// <see cref="glBegin"/> 
        /// and the corresponding execution of
        /// <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glGetShaderSource(GLuint shader, GLsizei bufSize, GLsizei * length, GLchar * source);</para>
        /// </summary>
        /// <param name="shader">
        /// <para>
        /// Specifies the shader object to be
        /// queried.
        /// </para>
        /// </param>
        /// <param name="bufSize">
        /// <para>
        /// Specifies the size of the character buffer for
        /// storing the returned source code string.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// Returns the length of the string returned in
        /// <paramref name="source"/> (excluding the null
        /// terminator).
        /// </para>
        /// </param>
        /// <param name="source">
        /// <para>
        /// Specifies an array of characters that is used
        /// to return the source code string.
        /// </para>
        /// </param>
        /// <seealso cref="CreateShader"/>
        /// <seealso cref="ShaderSource"/>
        public unsafe static void GetShaderSource(uint shader, int bufSize, ref int length, ref byte source) {
            fixed (int* pLength = &length)
            fixed (byte* pSource = &source) {
                GLNative.glGetShaderSource(shader, bufSize, pLength, pSource);
            }
        }

        /// <summary>
        /// Returns the location of a uniform variable
        /// <para>Require:</para> <para>GL_VERSION_2_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glGetUniformLocation"/> is available
        /// only if the GL version is 2.0 or greater.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="program"/> is not a value generated by
        /// OpenGL. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <paramref name="program"/> is not a program object. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <paramref name="program"/> has not been successfully
        /// linked. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <see cref="glGetUniformLocation"/> is executed between
        /// the execution of
        /// <see cref="glBegin"/> 
        /// and the corresponding execution of
        /// <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>GLint glGetUniformLocation(GLuint program, const GLchar * name);</para>
        /// </summary>
        /// <param name="program">
        /// <para>
        /// Specifies the program object to be
        /// queried.
        /// </para>
        /// </param>
        /// <param name="name">
        /// <para>
        /// Points to a null terminated string containing
        /// the name of the uniform variable whose location is
        /// to be queried.
        /// </para>
        /// </param>
        /// <seealso cref="LinkProgram"/>
        /// <seealso cref="Uniform"/>
        public unsafe static int GetUniformLocation(uint program, ref byte name) {
            fixed (byte* pName = &name) {
                return GLNative.glGetUniformLocation(program, pName);
            }
        }

        /// <summary>
        /// Returns the value of a uniform variable
        /// <para>Require:</para> <para>GL_VERSION_2_0, GL_ES_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glGetUniform"/> is available only if the
        /// GL version is 2.0 or greater. 
        /// If an error is generated, no change is made to the
        /// contents of <paramref name="ps"/>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="program"/> is not a value generated by
        /// OpenGL. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <paramref name="program"/> is not a program object. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <paramref name="program"/> has not been successfully
        /// linked. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <paramref name="location"/> does not correspond to a valid
        /// uniform variable location for the specified program object. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <see cref="glGetUniform"/> is executed between the
        /// execution of
        /// <see cref="glBegin"/> 
        /// and the corresponding execution of
        /// <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glGetUniformfv(GLuint program, GLint location, GLfloat * params);</para>
        /// </summary>
        /// <param name="program">
        /// <para>
        /// Specifies the program object to be
        /// queried.
        /// </para>
        /// </param>
        /// <param name="location">
        /// <para>
        /// Specifies the location of the uniform variable
        /// to be queried.
        /// </para>
        /// </param>
        /// <param name="ps">
        /// <para>
        /// Returns the value of the specified uniform
        /// variable.
        /// </para>
        /// </param>
        /// <seealso cref="CreateProgram"/>
        /// <seealso cref="LinkProgram"/>
        /// <seealso cref="Uniform"/>
        public unsafe static void GetUniformfv(uint program, int location, ref float ps) {
            fixed (float* pPs = &ps) {
                GLNative.glGetUniformfv(program, location, pPs);
            }
        }

        /// <summary>
        /// Returns the value of a uniform variable
        /// <para>Require:</para> <para>GL_VERSION_2_0, GL_ES_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glGetUniform"/> is available only if the
        /// GL version is 2.0 or greater. 
        /// If an error is generated, no change is made to the
        /// contents of <paramref name="ps"/>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="program"/> is not a value generated by
        /// OpenGL. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <paramref name="program"/> is not a program object. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <paramref name="program"/> has not been successfully
        /// linked. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <paramref name="location"/> does not correspond to a valid
        /// uniform variable location for the specified program object. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <see cref="glGetUniform"/> is executed between the
        /// execution of
        /// <see cref="glBegin"/> 
        /// and the corresponding execution of
        /// <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glGetUniformiv(GLuint program, GLint location, GLint * params);</para>
        /// </summary>
        /// <param name="program">
        /// <para>
        /// Specifies the program object to be
        /// queried.
        /// </para>
        /// </param>
        /// <param name="location">
        /// <para>
        /// Specifies the location of the uniform variable
        /// to be queried.
        /// </para>
        /// </param>
        /// <param name="ps">
        /// <para>
        /// Returns the value of the specified uniform
        /// variable.
        /// </para>
        /// </param>
        /// <seealso cref="CreateProgram"/>
        /// <seealso cref="LinkProgram"/>
        /// <seealso cref="Uniform"/>
        public unsafe static void GetUniformiv(uint program, int location, ref int ps) {
            fixed (int* pPs = &ps) {
                GLNative.glGetUniformiv(program, location, pPs);
            }
        }

        /// <summary>
        /// Return a generic vertex attribute parameter
        /// <para>Require:</para> <para>GL_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glGetVertexAttrib"/> is available only
        /// if the GL version is 2.0 or greater. 
        /// If an error is generated, no change is made to the
        /// contents of <paramref name="ps"/>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="index"/> is greater than or equal to
        /// <code>GL_MAX_VERTEX_ATTRIBS</code>. 
        /// <code>GL_INVALID_ENUM</code> is generated if
        /// <paramref name="pname"/> is not an accepted value. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <paramref name="index"/> is 0 and
        /// <paramref name="pname"/> is
        /// <code>GL_CURRENT_VERTEX_ATTRIB</code>.
        /// </para>
        /// Original: <para>void glGetVertexAttribdv(GLuint index, GLenum pname, GLdouble * params);</para>
        /// </summary>
        /// <param name="index">
        /// <para>
        /// Specifies the generic vertex attribute
        /// parameter to be queried.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of the vertex
        /// attribute parameter to be queried. Accepted values are
        /// <code>GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING</code>,
        /// <code>GL_VERTEX_ATTRIB_ARRAY_ENABLED</code>,
        /// <code>GL_VERTEX_ATTRIB_ARRAY_SIZE</code>,
        /// <code>GL_VERTEX_ATTRIB_ARRAY_STRIDE</code>,
        /// <code>GL_VERTEX_ATTRIB_ARRAY_TYPE</code>,
        /// <code>GL_VERTEX_ATTRIB_ARRAY_NORMALIZED</code>, or
        /// <code>GL_CURRENT_VERTEX_ATTRIB</code>.
        /// </para>
        /// </param>
        /// <param name="ps">
        /// Returns the requested data.
        /// </param>
        /// <seealso cref="BindAttribLocation"/>
        /// <seealso cref="BindBuffer"/>
        /// <seealso cref="DisableVertexAttribArray"/>
        /// <seealso cref="EnableVertexAttribArray"/>
        /// <seealso cref="VertexAttrib"/>
        /// <seealso cref="VertexAttribPointer"/>
        public unsafe static void GetVertexAttribdv(uint index, uint pname, ref double ps) {
            fixed (double* pPs = &ps) {
                GLNative.glGetVertexAttribdv(index, pname, pPs);
            }
        }

        /// <summary>
        /// Return a generic vertex attribute parameter
        /// <para>Require:</para> <para>GL_VERSION_2_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glGetVertexAttrib"/> is available only
        /// if the GL version is 2.0 or greater. 
        /// If an error is generated, no change is made to the
        /// contents of <paramref name="ps"/>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="index"/> is greater than or equal to
        /// <code>GL_MAX_VERTEX_ATTRIBS</code>. 
        /// <code>GL_INVALID_ENUM</code> is generated if
        /// <paramref name="pname"/> is not an accepted value. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <paramref name="index"/> is 0 and
        /// <paramref name="pname"/> is
        /// <code>GL_CURRENT_VERTEX_ATTRIB</code>.
        /// </para>
        /// Original: <para>void glGetVertexAttribfv(GLuint index, GLenum pname, GLfloat * params);</para>
        /// </summary>
        /// <param name="index">
        /// <para>
        /// Specifies the generic vertex attribute
        /// parameter to be queried.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of the vertex
        /// attribute parameter to be queried. Accepted values are
        /// <code>GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING</code>,
        /// <code>GL_VERTEX_ATTRIB_ARRAY_ENABLED</code>,
        /// <code>GL_VERTEX_ATTRIB_ARRAY_SIZE</code>,
        /// <code>GL_VERTEX_ATTRIB_ARRAY_STRIDE</code>,
        /// <code>GL_VERTEX_ATTRIB_ARRAY_TYPE</code>,
        /// <code>GL_VERTEX_ATTRIB_ARRAY_NORMALIZED</code>, or
        /// <code>GL_CURRENT_VERTEX_ATTRIB</code>.
        /// </para>
        /// </param>
        /// <param name="ps">
        /// Returns the requested data.
        /// </param>
        /// <seealso cref="BindAttribLocation"/>
        /// <seealso cref="BindBuffer"/>
        /// <seealso cref="DisableVertexAttribArray"/>
        /// <seealso cref="EnableVertexAttribArray"/>
        /// <seealso cref="VertexAttrib"/>
        /// <seealso cref="VertexAttribPointer"/>
        public unsafe static void GetVertexAttribfv(uint index, uint pname, ref float ps) {
            fixed (float* pPs = &ps) {
                GLNative.glGetVertexAttribfv(index, pname, pPs);
            }
        }

        /// <summary>
        /// Return a generic vertex attribute parameter
        /// <para>Require:</para> <para>GL_VERSION_2_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glGetVertexAttrib"/> is available only
        /// if the GL version is 2.0 or greater. 
        /// If an error is generated, no change is made to the
        /// contents of <paramref name="ps"/>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="index"/> is greater than or equal to
        /// <code>GL_MAX_VERTEX_ATTRIBS</code>. 
        /// <code>GL_INVALID_ENUM</code> is generated if
        /// <paramref name="pname"/> is not an accepted value. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <paramref name="index"/> is 0 and
        /// <paramref name="pname"/> is
        /// <code>GL_CURRENT_VERTEX_ATTRIB</code>.
        /// </para>
        /// Original: <para>void glGetVertexAttribiv(GLuint index, GLenum pname, GLint * params);</para>
        /// </summary>
        /// <param name="index">
        /// <para>
        /// Specifies the generic vertex attribute
        /// parameter to be queried.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of the vertex
        /// attribute parameter to be queried. Accepted values are
        /// <code>GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING</code>,
        /// <code>GL_VERTEX_ATTRIB_ARRAY_ENABLED</code>,
        /// <code>GL_VERTEX_ATTRIB_ARRAY_SIZE</code>,
        /// <code>GL_VERTEX_ATTRIB_ARRAY_STRIDE</code>,
        /// <code>GL_VERTEX_ATTRIB_ARRAY_TYPE</code>,
        /// <code>GL_VERTEX_ATTRIB_ARRAY_NORMALIZED</code>, or
        /// <code>GL_CURRENT_VERTEX_ATTRIB</code>.
        /// </para>
        /// </param>
        /// <param name="ps">
        /// Returns the requested data.
        /// </param>
        /// <seealso cref="BindAttribLocation"/>
        /// <seealso cref="BindBuffer"/>
        /// <seealso cref="DisableVertexAttribArray"/>
        /// <seealso cref="EnableVertexAttribArray"/>
        /// <seealso cref="VertexAttrib"/>
        /// <seealso cref="VertexAttribPointer"/>
        public unsafe static void GetVertexAttribiv(uint index, uint pname, ref int ps) {
            fixed (int* pPs = &ps) {
                GLNative.glGetVertexAttribiv(index, pname, pPs);
            }
        }

        /// <summary>
        /// return the address of the specified generic vertex attribute pointer
        /// <para>Require:</para> <para>GL_VERSION_2_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glGetVertexAttribPointerv"/>
        /// is available only if the GL version is 2.0 or greater. 
        /// The pointer returned is client-side state. 
        /// The initial value for each pointer is 0.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code>
        /// is generated if <paramref name="index"/>
        /// is greater than or equal to <code>GL_MAX_VERTEX_ATTRIBS</code>. 
        /// <code>GL_INVALID_ENUM</code>
        /// is generated if <paramref name="pname"/>
        /// is not an accepted value.
        /// </para>
        /// Original: <para>void glGetVertexAttribPointerv(GLuint index, GLenum pname, void ** pointer);</para>
        /// </summary>
        /// <param name="index">
        /// <para>
        /// Specifies the generic vertex attribute
        /// parameter to be returned.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of the generic
        /// vertex attribute parameter to be returned. Must be
        /// <code>GL_VERTEX_ATTRIB_ARRAY_POINTER</code>.
        /// </para>
        /// </param>
        /// <param name="pointer">
        /// Returns the pointer value.
        /// </param>
        /// <seealso cref="GetVertexAttrib"/>
        /// <seealso cref="VertexAttribPointer"/>
        public unsafe static void GetVertexAttribPointerv(uint index, uint pname, IntPtr pointer) {
            GLNative.glGetVertexAttribPointerv(index, pname, (void**)pointer);
        }

        /// <summary>
        /// Replaces the source code in a shader object
        /// <para>Require:</para> <para>GL_VERSION_2_0, GL_ES_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glShaderSource"/> is available only if
        /// the GL version is 2.0 or greater. 
        /// OpenGL copies the shader source code strings when
        /// <see cref="glShaderSource"/> is called, so an application
        /// may free its copy of the source code strings immediately after
        /// the function returns.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="shader"/> is not a value generated by
        /// OpenGL. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <paramref name="shader"/> is not a shader object. 
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="count"/> is less than 0. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <see cref="glShaderSource"/> is executed between the
        /// execution of
        /// <see cref="glBegin"/> 
        /// and the corresponding execution of
        /// <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glShaderSource(GLuint shader, GLsizei count, const GLchar ** string, const GLint * length);</para>
        /// </summary>
        /// <param name="shader">
        /// <para>
        /// Specifies the handle of the shader object
        /// whose source code is to be replaced.
        /// </para>
        /// </param>
        /// <param name="count">
        /// <para>
        /// Specifies the number of elements in the
        /// <paramref name="str"/> and
        /// <paramref name="length"/>
        /// arrays.
        /// </para>
        /// </param>
        /// <param name="str">
        /// <para>
        /// Specifies an array of pointers to strings
        /// containing the source code to be loaded into the
        /// shader.
        /// </para>
        /// </param>
        /// <param name="length">
        /// Specifies an array of string lengths.
        /// </param>
        /// <seealso cref="CompileShader"/>
        /// <seealso cref="CreateShader"/>
        /// <seealso cref="DeleteShader"/>
        public unsafe static void ShaderSource(uint shader, int count, IntPtr str, ref int length) {
            fixed (int* pLength = &length) {
                GLNative.glShaderSource(shader, count, (byte**)str, pLength);
            }
        }

        /// <summary>
        /// Specify the value of a uniform variable for the current program object
        /// <para>Require:</para> <para>GL_VERSION_2_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glUniform"/> is available only if the GL
        /// version is 2.0 or greater. 
        /// <see cref="glUniformMatrix{2x3|3x2|2x4|4x2|3x4|4x3}fv"/> 
        /// is available only if the GL version is 2.1 or greater. 
        /// <see cref="glUniform1i"/> and
        /// <see cref="glUniform1iv"/> are the only two functions
        /// that may be used to load uniform variables defined as sampler
        /// types. Loading samplers with any other function will result in a
        /// <code>GL_INVALID_OPERATION</code> error. 
        /// If <paramref name="count"/> is greater than 1 and the
        /// indicated uniform variable is not an array, a
        /// <code>GL_INVALID_OPERATION</code> error is generated and the
        /// specified uniform variable will remain unchanged. 
        /// Other than the preceding exceptions, if the type and size
        /// of the uniform variable as defined in the shader do not match
        /// the type and size specified in the name of the command used to
        /// load its value, a <code>GL_INVALID_OPERATION</code> error will
        /// be generated and the specified uniform variable will remain
        /// unchanged. 
        /// If <paramref name="location"/> is a value other than
        /// -1 and it does not represent a valid uniform variable location
        /// in the current program object, an error will be generated, and
        /// no changes will be made to the uniform variable storage of the
        /// current program object. If <paramref name="location"/> is
        /// equal to -1, the data passed in will be silently ignored and the
        /// specified uniform variable will not be changed.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if there
        /// is no current program object. 
        /// <code>GL_INVALID_OPERATION</code> is generated if the
        /// size of the uniform variable declared in the shader does not
        /// match the size indicated by the <see cref="glUniform"/>
        /// command. 
        /// <code>GL_INVALID_OPERATION</code> is generated if one of
        /// the integer variants of this function is used to load a uniform
        /// variable of type float, vec2, vec3, vec4, or an array of these,
        /// or if one of the floating-point variants of this function is
        /// used to load a uniform variable of type int, ivec2, ivec3, or
        /// ivec4, or an array of these. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <paramref name="location"/> is an invalid uniform location
        /// for the current program object and
        /// <paramref name="location"/> is not equal to -1. 
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="count"/> is less than 0. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <paramref name="count"/> is greater than 1 and the indicated
        /// uniform variable is not an array variable. 
        /// <code>GL_INVALID_OPERATION</code> is generated if a
        /// sampler is loaded using a command other than
        /// <see cref="glUniform1i"/> and
        /// <see cref="glUniform1iv"/>. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <see cref="glUniform"/> is executed between the execution
        /// of
        /// <see cref="glBegin"/> 
        /// and the corresponding execution of
        /// <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glUniform1fv(GLint location, GLsizei count, const GLfloat * value);</para>
        /// </summary>
        /// <param name="location">
        /// <para>
        /// Specifies the location of the uniform value to
        /// be modified.
        /// </para>
        /// </param>
        /// <param name="count">
        /// <para>
        /// Specifies the number of elements that are to
        /// be modified. This should be 1 if the targeted
        /// uniform variable is not an array, and 1 or more if it is
        /// an array.
        /// </para>
        /// </param>
        /// <param name="value">
        /// <para>
        /// Specifies a pointer to an array of
        /// <paramref name="count"/> values that will be
        /// used to update the specified uniform
        /// variable.
        /// </para>
        /// </param>
        /// <seealso cref="LinkProgram"/>
        /// <seealso cref="UseProgram"/>
        public unsafe static void Uniform1fv(int location, int count, ref float value) {
            fixed (float* pValue = &value) {
                GLNative.glUniform1fv(location, count, pValue);
            }
        }

        /// <summary>
        /// Specify the value of a uniform variable for the current program object
        /// <para>Require:</para> <para>GL_VERSION_2_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glUniform"/> is available only if the GL
        /// version is 2.0 or greater. 
        /// <see cref="glUniformMatrix{2x3|3x2|2x4|4x2|3x4|4x3}fv"/> 
        /// is available only if the GL version is 2.1 or greater. 
        /// <see cref="glUniform1i"/> and
        /// <see cref="glUniform1iv"/> are the only two functions
        /// that may be used to load uniform variables defined as sampler
        /// types. Loading samplers with any other function will result in a
        /// <code>GL_INVALID_OPERATION</code> error. 
        /// If <paramref name="count"/> is greater than 1 and the
        /// indicated uniform variable is not an array, a
        /// <code>GL_INVALID_OPERATION</code> error is generated and the
        /// specified uniform variable will remain unchanged. 
        /// Other than the preceding exceptions, if the type and size
        /// of the uniform variable as defined in the shader do not match
        /// the type and size specified in the name of the command used to
        /// load its value, a <code>GL_INVALID_OPERATION</code> error will
        /// be generated and the specified uniform variable will remain
        /// unchanged. 
        /// If <paramref name="location"/> is a value other than
        /// -1 and it does not represent a valid uniform variable location
        /// in the current program object, an error will be generated, and
        /// no changes will be made to the uniform variable storage of the
        /// current program object. If <paramref name="location"/> is
        /// equal to -1, the data passed in will be silently ignored and the
        /// specified uniform variable will not be changed.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if there
        /// is no current program object. 
        /// <code>GL_INVALID_OPERATION</code> is generated if the
        /// size of the uniform variable declared in the shader does not
        /// match the size indicated by the <see cref="glUniform"/>
        /// command. 
        /// <code>GL_INVALID_OPERATION</code> is generated if one of
        /// the integer variants of this function is used to load a uniform
        /// variable of type float, vec2, vec3, vec4, or an array of these,
        /// or if one of the floating-point variants of this function is
        /// used to load a uniform variable of type int, ivec2, ivec3, or
        /// ivec4, or an array of these. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <paramref name="location"/> is an invalid uniform location
        /// for the current program object and
        /// <paramref name="location"/> is not equal to -1. 
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="count"/> is less than 0. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <paramref name="count"/> is greater than 1 and the indicated
        /// uniform variable is not an array variable. 
        /// <code>GL_INVALID_OPERATION</code> is generated if a
        /// sampler is loaded using a command other than
        /// <see cref="glUniform1i"/> and
        /// <see cref="glUniform1iv"/>. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <see cref="glUniform"/> is executed between the execution
        /// of
        /// <see cref="glBegin"/> 
        /// and the corresponding execution of
        /// <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glUniform2fv(GLint location, GLsizei count, const GLfloat * value);</para>
        /// </summary>
        /// <param name="location">
        /// <para>
        /// Specifies the location of the uniform value to
        /// be modified.
        /// </para>
        /// </param>
        /// <param name="count">
        /// <para>
        /// Specifies the number of elements that are to
        /// be modified. This should be 1 if the targeted
        /// uniform variable is not an array, and 1 or more if it is
        /// an array.
        /// </para>
        /// </param>
        /// <param name="value">
        /// <para>
        /// Specifies a pointer to an array of
        /// <paramref name="count"/> values that will be
        /// used to update the specified uniform
        /// variable.
        /// </para>
        /// </param>
        /// <seealso cref="LinkProgram"/>
        /// <seealso cref="UseProgram"/>
        public unsafe static void Uniform2fv(int location, int count, ref float value) {
            fixed (float* pValue = &value) {
                GLNative.glUniform2fv(location, count, pValue);
            }
        }

        /// <summary>
        /// Specify the value of a uniform variable for the current program object
        /// <para>Require:</para> <para>GL_VERSION_2_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glUniform"/> is available only if the GL
        /// version is 2.0 or greater. 
        /// <see cref="glUniformMatrix{2x3|3x2|2x4|4x2|3x4|4x3}fv"/> 
        /// is available only if the GL version is 2.1 or greater. 
        /// <see cref="glUniform1i"/> and
        /// <see cref="glUniform1iv"/> are the only two functions
        /// that may be used to load uniform variables defined as sampler
        /// types. Loading samplers with any other function will result in a
        /// <code>GL_INVALID_OPERATION</code> error. 
        /// If <paramref name="count"/> is greater than 1 and the
        /// indicated uniform variable is not an array, a
        /// <code>GL_INVALID_OPERATION</code> error is generated and the
        /// specified uniform variable will remain unchanged. 
        /// Other than the preceding exceptions, if the type and size
        /// of the uniform variable as defined in the shader do not match
        /// the type and size specified in the name of the command used to
        /// load its value, a <code>GL_INVALID_OPERATION</code> error will
        /// be generated and the specified uniform variable will remain
        /// unchanged. 
        /// If <paramref name="location"/> is a value other than
        /// -1 and it does not represent a valid uniform variable location
        /// in the current program object, an error will be generated, and
        /// no changes will be made to the uniform variable storage of the
        /// current program object. If <paramref name="location"/> is
        /// equal to -1, the data passed in will be silently ignored and the
        /// specified uniform variable will not be changed.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if there
        /// is no current program object. 
        /// <code>GL_INVALID_OPERATION</code> is generated if the
        /// size of the uniform variable declared in the shader does not
        /// match the size indicated by the <see cref="glUniform"/>
        /// command. 
        /// <code>GL_INVALID_OPERATION</code> is generated if one of
        /// the integer variants of this function is used to load a uniform
        /// variable of type float, vec2, vec3, vec4, or an array of these,
        /// or if one of the floating-point variants of this function is
        /// used to load a uniform variable of type int, ivec2, ivec3, or
        /// ivec4, or an array of these. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <paramref name="location"/> is an invalid uniform location
        /// for the current program object and
        /// <paramref name="location"/> is not equal to -1. 
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="count"/> is less than 0. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <paramref name="count"/> is greater than 1 and the indicated
        /// uniform variable is not an array variable. 
        /// <code>GL_INVALID_OPERATION</code> is generated if a
        /// sampler is loaded using a command other than
        /// <see cref="glUniform1i"/> and
        /// <see cref="glUniform1iv"/>. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <see cref="glUniform"/> is executed between the execution
        /// of
        /// <see cref="glBegin"/> 
        /// and the corresponding execution of
        /// <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glUniform3fv(GLint location, GLsizei count, const GLfloat * value);</para>
        /// </summary>
        /// <param name="location">
        /// <para>
        /// Specifies the location of the uniform value to
        /// be modified.
        /// </para>
        /// </param>
        /// <param name="count">
        /// <para>
        /// Specifies the number of elements that are to
        /// be modified. This should be 1 if the targeted
        /// uniform variable is not an array, and 1 or more if it is
        /// an array.
        /// </para>
        /// </param>
        /// <param name="value">
        /// <para>
        /// Specifies a pointer to an array of
        /// <paramref name="count"/> values that will be
        /// used to update the specified uniform
        /// variable.
        /// </para>
        /// </param>
        /// <seealso cref="LinkProgram"/>
        /// <seealso cref="UseProgram"/>
        public unsafe static void Uniform3fv(int location, int count, ref float value) {
            fixed (float* pValue = &value) {
                GLNative.glUniform3fv(location, count, pValue);
            }
        }

        /// <summary>
        /// Specify the value of a uniform variable for the current program object
        /// <para>Require:</para> <para>GL_VERSION_2_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glUniform"/> is available only if the GL
        /// version is 2.0 or greater. 
        /// <see cref="glUniformMatrix{2x3|3x2|2x4|4x2|3x4|4x3}fv"/> 
        /// is available only if the GL version is 2.1 or greater. 
        /// <see cref="glUniform1i"/> and
        /// <see cref="glUniform1iv"/> are the only two functions
        /// that may be used to load uniform variables defined as sampler
        /// types. Loading samplers with any other function will result in a
        /// <code>GL_INVALID_OPERATION</code> error. 
        /// If <paramref name="count"/> is greater than 1 and the
        /// indicated uniform variable is not an array, a
        /// <code>GL_INVALID_OPERATION</code> error is generated and the
        /// specified uniform variable will remain unchanged. 
        /// Other than the preceding exceptions, if the type and size
        /// of the uniform variable as defined in the shader do not match
        /// the type and size specified in the name of the command used to
        /// load its value, a <code>GL_INVALID_OPERATION</code> error will
        /// be generated and the specified uniform variable will remain
        /// unchanged. 
        /// If <paramref name="location"/> is a value other than
        /// -1 and it does not represent a valid uniform variable location
        /// in the current program object, an error will be generated, and
        /// no changes will be made to the uniform variable storage of the
        /// current program object. If <paramref name="location"/> is
        /// equal to -1, the data passed in will be silently ignored and the
        /// specified uniform variable will not be changed.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if there
        /// is no current program object. 
        /// <code>GL_INVALID_OPERATION</code> is generated if the
        /// size of the uniform variable declared in the shader does not
        /// match the size indicated by the <see cref="glUniform"/>
        /// command. 
        /// <code>GL_INVALID_OPERATION</code> is generated if one of
        /// the integer variants of this function is used to load a uniform
        /// variable of type float, vec2, vec3, vec4, or an array of these,
        /// or if one of the floating-point variants of this function is
        /// used to load a uniform variable of type int, ivec2, ivec3, or
        /// ivec4, or an array of these. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <paramref name="location"/> is an invalid uniform location
        /// for the current program object and
        /// <paramref name="location"/> is not equal to -1. 
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="count"/> is less than 0. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <paramref name="count"/> is greater than 1 and the indicated
        /// uniform variable is not an array variable. 
        /// <code>GL_INVALID_OPERATION</code> is generated if a
        /// sampler is loaded using a command other than
        /// <see cref="glUniform1i"/> and
        /// <see cref="glUniform1iv"/>. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <see cref="glUniform"/> is executed between the execution
        /// of
        /// <see cref="glBegin"/> 
        /// and the corresponding execution of
        /// <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glUniform4fv(GLint location, GLsizei count, const GLfloat * value);</para>
        /// </summary>
        /// <param name="location">
        /// <para>
        /// Specifies the location of the uniform value to
        /// be modified.
        /// </para>
        /// </param>
        /// <param name="count">
        /// <para>
        /// Specifies the number of elements that are to
        /// be modified. This should be 1 if the targeted
        /// uniform variable is not an array, and 1 or more if it is
        /// an array.
        /// </para>
        /// </param>
        /// <param name="value">
        /// <para>
        /// Specifies a pointer to an array of
        /// <paramref name="count"/> values that will be
        /// used to update the specified uniform
        /// variable.
        /// </para>
        /// </param>
        /// <seealso cref="LinkProgram"/>
        /// <seealso cref="UseProgram"/>
        public unsafe static void Uniform4fv(int location, int count, ref float value) {
            fixed (float* pValue = &value) {
                GLNative.glUniform4fv(location, count, pValue);
            }
        }

        /// <summary>
        /// Specify the value of a uniform variable for the current program object
        /// <para>Require:</para> <para>GL_VERSION_2_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glUniform"/> is available only if the GL
        /// version is 2.0 or greater. 
        /// <see cref="glUniformMatrix{2x3|3x2|2x4|4x2|3x4|4x3}fv"/> 
        /// is available only if the GL version is 2.1 or greater. 
        /// <see cref="glUniform1i"/> and
        /// <see cref="glUniform1iv"/> are the only two functions
        /// that may be used to load uniform variables defined as sampler
        /// types. Loading samplers with any other function will result in a
        /// <code>GL_INVALID_OPERATION</code> error. 
        /// If <paramref name="count"/> is greater than 1 and the
        /// indicated uniform variable is not an array, a
        /// <code>GL_INVALID_OPERATION</code> error is generated and the
        /// specified uniform variable will remain unchanged. 
        /// Other than the preceding exceptions, if the type and size
        /// of the uniform variable as defined in the shader do not match
        /// the type and size specified in the name of the command used to
        /// load its value, a <code>GL_INVALID_OPERATION</code> error will
        /// be generated and the specified uniform variable will remain
        /// unchanged. 
        /// If <paramref name="location"/> is a value other than
        /// -1 and it does not represent a valid uniform variable location
        /// in the current program object, an error will be generated, and
        /// no changes will be made to the uniform variable storage of the
        /// current program object. If <paramref name="location"/> is
        /// equal to -1, the data passed in will be silently ignored and the
        /// specified uniform variable will not be changed.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if there
        /// is no current program object. 
        /// <code>GL_INVALID_OPERATION</code> is generated if the
        /// size of the uniform variable declared in the shader does not
        /// match the size indicated by the <see cref="glUniform"/>
        /// command. 
        /// <code>GL_INVALID_OPERATION</code> is generated if one of
        /// the integer variants of this function is used to load a uniform
        /// variable of type float, vec2, vec3, vec4, or an array of these,
        /// or if one of the floating-point variants of this function is
        /// used to load a uniform variable of type int, ivec2, ivec3, or
        /// ivec4, or an array of these. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <paramref name="location"/> is an invalid uniform location
        /// for the current program object and
        /// <paramref name="location"/> is not equal to -1. 
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="count"/> is less than 0. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <paramref name="count"/> is greater than 1 and the indicated
        /// uniform variable is not an array variable. 
        /// <code>GL_INVALID_OPERATION</code> is generated if a
        /// sampler is loaded using a command other than
        /// <see cref="glUniform1i"/> and
        /// <see cref="glUniform1iv"/>. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <see cref="glUniform"/> is executed between the execution
        /// of
        /// <see cref="glBegin"/> 
        /// and the corresponding execution of
        /// <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glUniform1iv(GLint location, GLsizei count, const GLint * value);</para>
        /// </summary>
        /// <param name="location">
        /// <para>
        /// Specifies the location of the uniform value to
        /// be modified.
        /// </para>
        /// </param>
        /// <param name="count">
        /// <para>
        /// Specifies the number of elements that are to
        /// be modified. This should be 1 if the targeted
        /// uniform variable is not an array, and 1 or more if it is
        /// an array.
        /// </para>
        /// </param>
        /// <param name="value">
        /// <para>
        /// Specifies a pointer to an array of
        /// <paramref name="count"/> values that will be
        /// used to update the specified uniform
        /// variable.
        /// </para>
        /// </param>
        /// <seealso cref="LinkProgram"/>
        /// <seealso cref="UseProgram"/>
        public unsafe static void Uniform1iv(int location, int count, ref int value) {
            fixed (int* pValue = &value) {
                GLNative.glUniform1iv(location, count, pValue);
            }
        }

        /// <summary>
        /// Specify the value of a uniform variable for the current program object
        /// <para>Require:</para> <para>GL_VERSION_2_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glUniform"/> is available only if the GL
        /// version is 2.0 or greater. 
        /// <see cref="glUniformMatrix{2x3|3x2|2x4|4x2|3x4|4x3}fv"/> 
        /// is available only if the GL version is 2.1 or greater. 
        /// <see cref="glUniform1i"/> and
        /// <see cref="glUniform1iv"/> are the only two functions
        /// that may be used to load uniform variables defined as sampler
        /// types. Loading samplers with any other function will result in a
        /// <code>GL_INVALID_OPERATION</code> error. 
        /// If <paramref name="count"/> is greater than 1 and the
        /// indicated uniform variable is not an array, a
        /// <code>GL_INVALID_OPERATION</code> error is generated and the
        /// specified uniform variable will remain unchanged. 
        /// Other than the preceding exceptions, if the type and size
        /// of the uniform variable as defined in the shader do not match
        /// the type and size specified in the name of the command used to
        /// load its value, a <code>GL_INVALID_OPERATION</code> error will
        /// be generated and the specified uniform variable will remain
        /// unchanged. 
        /// If <paramref name="location"/> is a value other than
        /// -1 and it does not represent a valid uniform variable location
        /// in the current program object, an error will be generated, and
        /// no changes will be made to the uniform variable storage of the
        /// current program object. If <paramref name="location"/> is
        /// equal to -1, the data passed in will be silently ignored and the
        /// specified uniform variable will not be changed.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if there
        /// is no current program object. 
        /// <code>GL_INVALID_OPERATION</code> is generated if the
        /// size of the uniform variable declared in the shader does not
        /// match the size indicated by the <see cref="glUniform"/>
        /// command. 
        /// <code>GL_INVALID_OPERATION</code> is generated if one of
        /// the integer variants of this function is used to load a uniform
        /// variable of type float, vec2, vec3, vec4, or an array of these,
        /// or if one of the floating-point variants of this function is
        /// used to load a uniform variable of type int, ivec2, ivec3, or
        /// ivec4, or an array of these. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <paramref name="location"/> is an invalid uniform location
        /// for the current program object and
        /// <paramref name="location"/> is not equal to -1. 
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="count"/> is less than 0. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <paramref name="count"/> is greater than 1 and the indicated
        /// uniform variable is not an array variable. 
        /// <code>GL_INVALID_OPERATION</code> is generated if a
        /// sampler is loaded using a command other than
        /// <see cref="glUniform1i"/> and
        /// <see cref="glUniform1iv"/>. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <see cref="glUniform"/> is executed between the execution
        /// of
        /// <see cref="glBegin"/> 
        /// and the corresponding execution of
        /// <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glUniform2iv(GLint location, GLsizei count, const GLint * value);</para>
        /// </summary>
        /// <param name="location">
        /// <para>
        /// Specifies the location of the uniform value to
        /// be modified.
        /// </para>
        /// </param>
        /// <param name="count">
        /// <para>
        /// Specifies the number of elements that are to
        /// be modified. This should be 1 if the targeted
        /// uniform variable is not an array, and 1 or more if it is
        /// an array.
        /// </para>
        /// </param>
        /// <param name="value">
        /// <para>
        /// Specifies a pointer to an array of
        /// <paramref name="count"/> values that will be
        /// used to update the specified uniform
        /// variable.
        /// </para>
        /// </param>
        /// <seealso cref="LinkProgram"/>
        /// <seealso cref="UseProgram"/>
        public unsafe static void Uniform2iv(int location, int count, ref int value) {
            fixed (int* pValue = &value) {
                GLNative.glUniform2iv(location, count, pValue);
            }
        }

        /// <summary>
        /// Specify the value of a uniform variable for the current program object
        /// <para>Require:</para> <para>GL_VERSION_2_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glUniform"/> is available only if the GL
        /// version is 2.0 or greater. 
        /// <see cref="glUniformMatrix{2x3|3x2|2x4|4x2|3x4|4x3}fv"/> 
        /// is available only if the GL version is 2.1 or greater. 
        /// <see cref="glUniform1i"/> and
        /// <see cref="glUniform1iv"/> are the only two functions
        /// that may be used to load uniform variables defined as sampler
        /// types. Loading samplers with any other function will result in a
        /// <code>GL_INVALID_OPERATION</code> error. 
        /// If <paramref name="count"/> is greater than 1 and the
        /// indicated uniform variable is not an array, a
        /// <code>GL_INVALID_OPERATION</code> error is generated and the
        /// specified uniform variable will remain unchanged. 
        /// Other than the preceding exceptions, if the type and size
        /// of the uniform variable as defined in the shader do not match
        /// the type and size specified in the name of the command used to
        /// load its value, a <code>GL_INVALID_OPERATION</code> error will
        /// be generated and the specified uniform variable will remain
        /// unchanged. 
        /// If <paramref name="location"/> is a value other than
        /// -1 and it does not represent a valid uniform variable location
        /// in the current program object, an error will be generated, and
        /// no changes will be made to the uniform variable storage of the
        /// current program object. If <paramref name="location"/> is
        /// equal to -1, the data passed in will be silently ignored and the
        /// specified uniform variable will not be changed.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if there
        /// is no current program object. 
        /// <code>GL_INVALID_OPERATION</code> is generated if the
        /// size of the uniform variable declared in the shader does not
        /// match the size indicated by the <see cref="glUniform"/>
        /// command. 
        /// <code>GL_INVALID_OPERATION</code> is generated if one of
        /// the integer variants of this function is used to load a uniform
        /// variable of type float, vec2, vec3, vec4, or an array of these,
        /// or if one of the floating-point variants of this function is
        /// used to load a uniform variable of type int, ivec2, ivec3, or
        /// ivec4, or an array of these. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <paramref name="location"/> is an invalid uniform location
        /// for the current program object and
        /// <paramref name="location"/> is not equal to -1. 
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="count"/> is less than 0. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <paramref name="count"/> is greater than 1 and the indicated
        /// uniform variable is not an array variable. 
        /// <code>GL_INVALID_OPERATION</code> is generated if a
        /// sampler is loaded using a command other than
        /// <see cref="glUniform1i"/> and
        /// <see cref="glUniform1iv"/>. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <see cref="glUniform"/> is executed between the execution
        /// of
        /// <see cref="glBegin"/> 
        /// and the corresponding execution of
        /// <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glUniform3iv(GLint location, GLsizei count, const GLint * value);</para>
        /// </summary>
        /// <param name="location">
        /// <para>
        /// Specifies the location of the uniform value to
        /// be modified.
        /// </para>
        /// </param>
        /// <param name="count">
        /// <para>
        /// Specifies the number of elements that are to
        /// be modified. This should be 1 if the targeted
        /// uniform variable is not an array, and 1 or more if it is
        /// an array.
        /// </para>
        /// </param>
        /// <param name="value">
        /// <para>
        /// Specifies a pointer to an array of
        /// <paramref name="count"/> values that will be
        /// used to update the specified uniform
        /// variable.
        /// </para>
        /// </param>
        /// <seealso cref="LinkProgram"/>
        /// <seealso cref="UseProgram"/>
        public unsafe static void Uniform3iv(int location, int count, ref int value) {
            fixed (int* pValue = &value) {
                GLNative.glUniform3iv(location, count, pValue);
            }
        }

        /// <summary>
        /// Specify the value of a uniform variable for the current program object
        /// <para>Require:</para> <para>GL_VERSION_2_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glUniform"/> is available only if the GL
        /// version is 2.0 or greater. 
        /// <see cref="glUniformMatrix{2x3|3x2|2x4|4x2|3x4|4x3}fv"/> 
        /// is available only if the GL version is 2.1 or greater. 
        /// <see cref="glUniform1i"/> and
        /// <see cref="glUniform1iv"/> are the only two functions
        /// that may be used to load uniform variables defined as sampler
        /// types. Loading samplers with any other function will result in a
        /// <code>GL_INVALID_OPERATION</code> error. 
        /// If <paramref name="count"/> is greater than 1 and the
        /// indicated uniform variable is not an array, a
        /// <code>GL_INVALID_OPERATION</code> error is generated and the
        /// specified uniform variable will remain unchanged. 
        /// Other than the preceding exceptions, if the type and size
        /// of the uniform variable as defined in the shader do not match
        /// the type and size specified in the name of the command used to
        /// load its value, a <code>GL_INVALID_OPERATION</code> error will
        /// be generated and the specified uniform variable will remain
        /// unchanged. 
        /// If <paramref name="location"/> is a value other than
        /// -1 and it does not represent a valid uniform variable location
        /// in the current program object, an error will be generated, and
        /// no changes will be made to the uniform variable storage of the
        /// current program object. If <paramref name="location"/> is
        /// equal to -1, the data passed in will be silently ignored and the
        /// specified uniform variable will not be changed.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if there
        /// is no current program object. 
        /// <code>GL_INVALID_OPERATION</code> is generated if the
        /// size of the uniform variable declared in the shader does not
        /// match the size indicated by the <see cref="glUniform"/>
        /// command. 
        /// <code>GL_INVALID_OPERATION</code> is generated if one of
        /// the integer variants of this function is used to load a uniform
        /// variable of type float, vec2, vec3, vec4, or an array of these,
        /// or if one of the floating-point variants of this function is
        /// used to load a uniform variable of type int, ivec2, ivec3, or
        /// ivec4, or an array of these. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <paramref name="location"/> is an invalid uniform location
        /// for the current program object and
        /// <paramref name="location"/> is not equal to -1. 
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="count"/> is less than 0. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <paramref name="count"/> is greater than 1 and the indicated
        /// uniform variable is not an array variable. 
        /// <code>GL_INVALID_OPERATION</code> is generated if a
        /// sampler is loaded using a command other than
        /// <see cref="glUniform1i"/> and
        /// <see cref="glUniform1iv"/>. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <see cref="glUniform"/> is executed between the execution
        /// of
        /// <see cref="glBegin"/> 
        /// and the corresponding execution of
        /// <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glUniform4iv(GLint location, GLsizei count, const GLint * value);</para>
        /// </summary>
        /// <param name="location">
        /// <para>
        /// Specifies the location of the uniform value to
        /// be modified.
        /// </para>
        /// </param>
        /// <param name="count">
        /// <para>
        /// Specifies the number of elements that are to
        /// be modified. This should be 1 if the targeted
        /// uniform variable is not an array, and 1 or more if it is
        /// an array.
        /// </para>
        /// </param>
        /// <param name="value">
        /// <para>
        /// Specifies a pointer to an array of
        /// <paramref name="count"/> values that will be
        /// used to update the specified uniform
        /// variable.
        /// </para>
        /// </param>
        /// <seealso cref="LinkProgram"/>
        /// <seealso cref="UseProgram"/>
        public unsafe static void Uniform4iv(int location, int count, ref int value) {
            fixed (int* pValue = &value) {
                GLNative.glUniform4iv(location, count, pValue);
            }
        }

        /// <summary>
        /// Specify the value of a uniform variable for the current program object
        /// <para>Require:</para> <para>GL_VERSION_2_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glUniform"/> is available only if the GL
        /// version is 2.0 or greater. 
        /// <see cref="glUniformMatrix{2x3|3x2|2x4|4x2|3x4|4x3}fv"/> 
        /// is available only if the GL version is 2.1 or greater. 
        /// <see cref="glUniform1i"/> and
        /// <see cref="glUniform1iv"/> are the only two functions
        /// that may be used to load uniform variables defined as sampler
        /// types. Loading samplers with any other function will result in a
        /// <code>GL_INVALID_OPERATION</code> error. 
        /// If <paramref name="count"/> is greater than 1 and the
        /// indicated uniform variable is not an array, a
        /// <code>GL_INVALID_OPERATION</code> error is generated and the
        /// specified uniform variable will remain unchanged. 
        /// Other than the preceding exceptions, if the type and size
        /// of the uniform variable as defined in the shader do not match
        /// the type and size specified in the name of the command used to
        /// load its value, a <code>GL_INVALID_OPERATION</code> error will
        /// be generated and the specified uniform variable will remain
        /// unchanged. 
        /// If <paramref name="location"/> is a value other than
        /// -1 and it does not represent a valid uniform variable location
        /// in the current program object, an error will be generated, and
        /// no changes will be made to the uniform variable storage of the
        /// current program object. If <paramref name="location"/> is
        /// equal to -1, the data passed in will be silently ignored and the
        /// specified uniform variable will not be changed.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if there
        /// is no current program object. 
        /// <code>GL_INVALID_OPERATION</code> is generated if the
        /// size of the uniform variable declared in the shader does not
        /// match the size indicated by the <see cref="glUniform"/>
        /// command. 
        /// <code>GL_INVALID_OPERATION</code> is generated if one of
        /// the integer variants of this function is used to load a uniform
        /// variable of type float, vec2, vec3, vec4, or an array of these,
        /// or if one of the floating-point variants of this function is
        /// used to load a uniform variable of type int, ivec2, ivec3, or
        /// ivec4, or an array of these. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <paramref name="location"/> is an invalid uniform location
        /// for the current program object and
        /// <paramref name="location"/> is not equal to -1. 
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="count"/> is less than 0. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <paramref name="count"/> is greater than 1 and the indicated
        /// uniform variable is not an array variable. 
        /// <code>GL_INVALID_OPERATION</code> is generated if a
        /// sampler is loaded using a command other than
        /// <see cref="glUniform1i"/> and
        /// <see cref="glUniform1iv"/>. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <see cref="glUniform"/> is executed between the execution
        /// of
        /// <see cref="glBegin"/> 
        /// and the corresponding execution of
        /// <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glUniformMatrix2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);</para>
        /// </summary>
        /// <param name="location">
        /// <para>
        /// Specifies the location of the uniform value to
        /// be modified.
        /// </para>
        /// </param>
        /// <param name="count">
        /// <para>
        /// Specifies the number of matrices that are to
        /// be modified. This should be 1 if the targeted
        /// uniform variable is not an array of matrices, and 1 or more if it is
        /// an array of matrices.
        /// </para>
        /// </param>
        /// <param name="transpose">
        /// <para>
        /// Specifies whether to transpose the matrix as
        /// the values are loaded into the uniform
        /// variable.
        /// </para>
        /// </param>
        /// <param name="value">
        /// <para>
        /// Specifies a pointer to an array of
        /// <paramref name="count"/> values that will be
        /// used to update the specified uniform
        /// variable.
        /// </para>
        /// </param>
        /// <seealso cref="LinkProgram"/>
        /// <seealso cref="UseProgram"/>
        public unsafe static void UniformMatrix2fv(int location, int count, bool transpose, ref float value) {
            fixed (float* pValue = &value) {
                GLNative.glUniformMatrix2fv(location, count, transpose, pValue);
            }
        }

        /// <summary>
        /// Specify the value of a uniform variable for the current program object
        /// <para>Require:</para> <para>GL_VERSION_2_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glUniform"/> is available only if the GL
        /// version is 2.0 or greater. 
        /// <see cref="glUniformMatrix{2x3|3x2|2x4|4x2|3x4|4x3}fv"/> 
        /// is available only if the GL version is 2.1 or greater. 
        /// <see cref="glUniform1i"/> and
        /// <see cref="glUniform1iv"/> are the only two functions
        /// that may be used to load uniform variables defined as sampler
        /// types. Loading samplers with any other function will result in a
        /// <code>GL_INVALID_OPERATION</code> error. 
        /// If <paramref name="count"/> is greater than 1 and the
        /// indicated uniform variable is not an array, a
        /// <code>GL_INVALID_OPERATION</code> error is generated and the
        /// specified uniform variable will remain unchanged. 
        /// Other than the preceding exceptions, if the type and size
        /// of the uniform variable as defined in the shader do not match
        /// the type and size specified in the name of the command used to
        /// load its value, a <code>GL_INVALID_OPERATION</code> error will
        /// be generated and the specified uniform variable will remain
        /// unchanged. 
        /// If <paramref name="location"/> is a value other than
        /// -1 and it does not represent a valid uniform variable location
        /// in the current program object, an error will be generated, and
        /// no changes will be made to the uniform variable storage of the
        /// current program object. If <paramref name="location"/> is
        /// equal to -1, the data passed in will be silently ignored and the
        /// specified uniform variable will not be changed.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if there
        /// is no current program object. 
        /// <code>GL_INVALID_OPERATION</code> is generated if the
        /// size of the uniform variable declared in the shader does not
        /// match the size indicated by the <see cref="glUniform"/>
        /// command. 
        /// <code>GL_INVALID_OPERATION</code> is generated if one of
        /// the integer variants of this function is used to load a uniform
        /// variable of type float, vec2, vec3, vec4, or an array of these,
        /// or if one of the floating-point variants of this function is
        /// used to load a uniform variable of type int, ivec2, ivec3, or
        /// ivec4, or an array of these. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <paramref name="location"/> is an invalid uniform location
        /// for the current program object and
        /// <paramref name="location"/> is not equal to -1. 
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="count"/> is less than 0. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <paramref name="count"/> is greater than 1 and the indicated
        /// uniform variable is not an array variable. 
        /// <code>GL_INVALID_OPERATION</code> is generated if a
        /// sampler is loaded using a command other than
        /// <see cref="glUniform1i"/> and
        /// <see cref="glUniform1iv"/>. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <see cref="glUniform"/> is executed between the execution
        /// of
        /// <see cref="glBegin"/> 
        /// and the corresponding execution of
        /// <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glUniformMatrix3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);</para>
        /// </summary>
        /// <param name="location">
        /// <para>
        /// Specifies the location of the uniform value to
        /// be modified.
        /// </para>
        /// </param>
        /// <param name="count">
        /// <para>
        /// Specifies the number of matrices that are to
        /// be modified. This should be 1 if the targeted
        /// uniform variable is not an array of matrices, and 1 or more if it is
        /// an array of matrices.
        /// </para>
        /// </param>
        /// <param name="transpose">
        /// <para>
        /// Specifies whether to transpose the matrix as
        /// the values are loaded into the uniform
        /// variable.
        /// </para>
        /// </param>
        /// <param name="value">
        /// <para>
        /// Specifies a pointer to an array of
        /// <paramref name="count"/> values that will be
        /// used to update the specified uniform
        /// variable.
        /// </para>
        /// </param>
        /// <seealso cref="LinkProgram"/>
        /// <seealso cref="UseProgram"/>
        public unsafe static void UniformMatrix3fv(int location, int count, bool transpose, ref float value) {
            fixed (float* pValue = &value) {
                GLNative.glUniformMatrix3fv(location, count, transpose, pValue);
            }
        }

        /// <summary>
        /// Specify the value of a uniform variable for the current program object
        /// <para>Require:</para> <para>GL_VERSION_2_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glUniform"/> is available only if the GL
        /// version is 2.0 or greater. 
        /// <see cref="glUniformMatrix{2x3|3x2|2x4|4x2|3x4|4x3}fv"/> 
        /// is available only if the GL version is 2.1 or greater. 
        /// <see cref="glUniform1i"/> and
        /// <see cref="glUniform1iv"/> are the only two functions
        /// that may be used to load uniform variables defined as sampler
        /// types. Loading samplers with any other function will result in a
        /// <code>GL_INVALID_OPERATION</code> error. 
        /// If <paramref name="count"/> is greater than 1 and the
        /// indicated uniform variable is not an array, a
        /// <code>GL_INVALID_OPERATION</code> error is generated and the
        /// specified uniform variable will remain unchanged. 
        /// Other than the preceding exceptions, if the type and size
        /// of the uniform variable as defined in the shader do not match
        /// the type and size specified in the name of the command used to
        /// load its value, a <code>GL_INVALID_OPERATION</code> error will
        /// be generated and the specified uniform variable will remain
        /// unchanged. 
        /// If <paramref name="location"/> is a value other than
        /// -1 and it does not represent a valid uniform variable location
        /// in the current program object, an error will be generated, and
        /// no changes will be made to the uniform variable storage of the
        /// current program object. If <paramref name="location"/> is
        /// equal to -1, the data passed in will be silently ignored and the
        /// specified uniform variable will not be changed.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if there
        /// is no current program object. 
        /// <code>GL_INVALID_OPERATION</code> is generated if the
        /// size of the uniform variable declared in the shader does not
        /// match the size indicated by the <see cref="glUniform"/>
        /// command. 
        /// <code>GL_INVALID_OPERATION</code> is generated if one of
        /// the integer variants of this function is used to load a uniform
        /// variable of type float, vec2, vec3, vec4, or an array of these,
        /// or if one of the floating-point variants of this function is
        /// used to load a uniform variable of type int, ivec2, ivec3, or
        /// ivec4, or an array of these. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <paramref name="location"/> is an invalid uniform location
        /// for the current program object and
        /// <paramref name="location"/> is not equal to -1. 
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="count"/> is less than 0. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <paramref name="count"/> is greater than 1 and the indicated
        /// uniform variable is not an array variable. 
        /// <code>GL_INVALID_OPERATION</code> is generated if a
        /// sampler is loaded using a command other than
        /// <see cref="glUniform1i"/> and
        /// <see cref="glUniform1iv"/>. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <see cref="glUniform"/> is executed between the execution
        /// of
        /// <see cref="glBegin"/> 
        /// and the corresponding execution of
        /// <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glUniformMatrix4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);</para>
        /// </summary>
        /// <param name="location">
        /// <para>
        /// Specifies the location of the uniform value to
        /// be modified.
        /// </para>
        /// </param>
        /// <param name="count">
        /// <para>
        /// Specifies the number of matrices that are to
        /// be modified. This should be 1 if the targeted
        /// uniform variable is not an array of matrices, and 1 or more if it is
        /// an array of matrices.
        /// </para>
        /// </param>
        /// <param name="transpose">
        /// <para>
        /// Specifies whether to transpose the matrix as
        /// the values are loaded into the uniform
        /// variable.
        /// </para>
        /// </param>
        /// <param name="value">
        /// <para>
        /// Specifies a pointer to an array of
        /// <paramref name="count"/> values that will be
        /// used to update the specified uniform
        /// variable.
        /// </para>
        /// </param>
        /// <seealso cref="LinkProgram"/>
        /// <seealso cref="UseProgram"/>
        public unsafe static void UniformMatrix4fv(int location, int count, bool transpose, ref float value) {
            fixed (float* pValue = &value) {
                GLNative.glUniformMatrix4fv(location, count, transpose, pValue);
            }
        }

        /// <summary>
        /// Specifies the value of a generic vertex attribute
        /// <para>Require:</para> <para>GL_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glVertexAttrib"/> is available only if
        /// the GL version is 2.0 or greater. 
        /// Generic vertex attributes can be updated at any time. In
        /// particular, <see cref="glVertexAttrib"/> can be called
        /// between a call to
        /// <see cref="glBegin"/> 
        /// and the corresponding call to
        /// <see cref="glEnd"/> . 
        /// It is possible for an application to bind more than one
        /// attribute name to the same generic vertex attribute index. This
        /// is referred to as aliasing, and it is allowed only if just one
        /// of the aliased attribute variables is active in the vertex
        /// shader, or if no path through the vertex shader consumes more
        /// than one of the attributes aliased to the same location. OpenGL
        /// implementations are not required to do error checking to detect
        /// aliasing, they are allowed to assume that aliasing will not
        /// occur, and they are allowed to employ optimizations that work
        /// only in the absence of aliasing. 
        /// There is no provision for binding standard vertex
        /// attributes; therefore, it is not possible to alias generic
        /// attributes with standard attributes.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="index"/> is greater than or equal to
        /// <code>GL_MAX_VERTEX_ATTRIBS</code>.
        /// </para>
        /// Original: <para>void glVertexAttrib1dv(GLuint index, const GLdouble * v);</para>
        /// </summary>
        /// <param name="index">
        /// <para>
        /// Specifies the index of the generic vertex
        /// attribute to be modified.
        /// </para>
        /// </param>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array of values to
        /// be used for the generic vertex attribute.
        /// </para>
        /// </param>
        /// <seealso cref="BindAttribLocation"/>
        /// <seealso cref="Vertex"/>
        /// <seealso cref="VertexAttribPointer"/>
        public unsafe static void VertexAttrib1dv(uint index, ref double v) {
            fixed (double* pV = &v) {
                GLNative.glVertexAttrib1dv(index, pV);
            }
        }

        /// <summary>
        /// Specifies the value of a generic vertex attribute
        /// <para>Require:</para> <para>GL_VERSION_2_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glVertexAttrib"/> is available only if
        /// the GL version is 2.0 or greater. 
        /// Generic vertex attributes can be updated at any time. In
        /// particular, <see cref="glVertexAttrib"/> can be called
        /// between a call to
        /// <see cref="glBegin"/> 
        /// and the corresponding call to
        /// <see cref="glEnd"/> . 
        /// It is possible for an application to bind more than one
        /// attribute name to the same generic vertex attribute index. This
        /// is referred to as aliasing, and it is allowed only if just one
        /// of the aliased attribute variables is active in the vertex
        /// shader, or if no path through the vertex shader consumes more
        /// than one of the attributes aliased to the same location. OpenGL
        /// implementations are not required to do error checking to detect
        /// aliasing, they are allowed to assume that aliasing will not
        /// occur, and they are allowed to employ optimizations that work
        /// only in the absence of aliasing. 
        /// There is no provision for binding standard vertex
        /// attributes; therefore, it is not possible to alias generic
        /// attributes with standard attributes.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="index"/> is greater than or equal to
        /// <code>GL_MAX_VERTEX_ATTRIBS</code>.
        /// </para>
        /// Original: <para>void glVertexAttrib1fv(GLuint index, const GLfloat * v);</para>
        /// </summary>
        /// <param name="index">
        /// <para>
        /// Specifies the index of the generic vertex
        /// attribute to be modified.
        /// </para>
        /// </param>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array of values to
        /// be used for the generic vertex attribute.
        /// </para>
        /// </param>
        /// <seealso cref="BindAttribLocation"/>
        /// <seealso cref="Vertex"/>
        /// <seealso cref="VertexAttribPointer"/>
        public unsafe static void VertexAttrib1fv(uint index, ref float v) {
            fixed (float* pV = &v) {
                GLNative.glVertexAttrib1fv(index, pV);
            }
        }

        /// <summary>
        /// Specifies the value of a generic vertex attribute
        /// <para>Require:</para> <para>GL_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glVertexAttrib"/> is available only if
        /// the GL version is 2.0 or greater. 
        /// Generic vertex attributes can be updated at any time. In
        /// particular, <see cref="glVertexAttrib"/> can be called
        /// between a call to
        /// <see cref="glBegin"/> 
        /// and the corresponding call to
        /// <see cref="glEnd"/> . 
        /// It is possible for an application to bind more than one
        /// attribute name to the same generic vertex attribute index. This
        /// is referred to as aliasing, and it is allowed only if just one
        /// of the aliased attribute variables is active in the vertex
        /// shader, or if no path through the vertex shader consumes more
        /// than one of the attributes aliased to the same location. OpenGL
        /// implementations are not required to do error checking to detect
        /// aliasing, they are allowed to assume that aliasing will not
        /// occur, and they are allowed to employ optimizations that work
        /// only in the absence of aliasing. 
        /// There is no provision for binding standard vertex
        /// attributes; therefore, it is not possible to alias generic
        /// attributes with standard attributes.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="index"/> is greater than or equal to
        /// <code>GL_MAX_VERTEX_ATTRIBS</code>.
        /// </para>
        /// Original: <para>void glVertexAttrib1sv(GLuint index, const GLshort * v);</para>
        /// </summary>
        /// <param name="index">
        /// <para>
        /// Specifies the index of the generic vertex
        /// attribute to be modified.
        /// </para>
        /// </param>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array of values to
        /// be used for the generic vertex attribute.
        /// </para>
        /// </param>
        /// <seealso cref="BindAttribLocation"/>
        /// <seealso cref="Vertex"/>
        /// <seealso cref="VertexAttribPointer"/>
        public unsafe static void VertexAttrib1sv(uint index, ref short v) {
            fixed (short* pV = &v) {
                GLNative.glVertexAttrib1sv(index, pV);
            }
        }

        /// <summary>
        /// Specifies the value of a generic vertex attribute
        /// <para>Require:</para> <para>GL_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glVertexAttrib"/> is available only if
        /// the GL version is 2.0 or greater. 
        /// Generic vertex attributes can be updated at any time. In
        /// particular, <see cref="glVertexAttrib"/> can be called
        /// between a call to
        /// <see cref="glBegin"/> 
        /// and the corresponding call to
        /// <see cref="glEnd"/> . 
        /// It is possible for an application to bind more than one
        /// attribute name to the same generic vertex attribute index. This
        /// is referred to as aliasing, and it is allowed only if just one
        /// of the aliased attribute variables is active in the vertex
        /// shader, or if no path through the vertex shader consumes more
        /// than one of the attributes aliased to the same location. OpenGL
        /// implementations are not required to do error checking to detect
        /// aliasing, they are allowed to assume that aliasing will not
        /// occur, and they are allowed to employ optimizations that work
        /// only in the absence of aliasing. 
        /// There is no provision for binding standard vertex
        /// attributes; therefore, it is not possible to alias generic
        /// attributes with standard attributes.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="index"/> is greater than or equal to
        /// <code>GL_MAX_VERTEX_ATTRIBS</code>.
        /// </para>
        /// Original: <para>void glVertexAttrib2dv(GLuint index, const GLdouble * v);</para>
        /// </summary>
        /// <param name="index">
        /// <para>
        /// Specifies the index of the generic vertex
        /// attribute to be modified.
        /// </para>
        /// </param>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array of values to
        /// be used for the generic vertex attribute.
        /// </para>
        /// </param>
        /// <seealso cref="BindAttribLocation"/>
        /// <seealso cref="Vertex"/>
        /// <seealso cref="VertexAttribPointer"/>
        public unsafe static void VertexAttrib2dv(uint index, ref double v) {
            fixed (double* pV = &v) {
                GLNative.glVertexAttrib2dv(index, pV);
            }
        }

        /// <summary>
        /// Specifies the value of a generic vertex attribute
        /// <para>Require:</para> <para>GL_VERSION_2_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glVertexAttrib"/> is available only if
        /// the GL version is 2.0 or greater. 
        /// Generic vertex attributes can be updated at any time. In
        /// particular, <see cref="glVertexAttrib"/> can be called
        /// between a call to
        /// <see cref="glBegin"/> 
        /// and the corresponding call to
        /// <see cref="glEnd"/> . 
        /// It is possible for an application to bind more than one
        /// attribute name to the same generic vertex attribute index. This
        /// is referred to as aliasing, and it is allowed only if just one
        /// of the aliased attribute variables is active in the vertex
        /// shader, or if no path through the vertex shader consumes more
        /// than one of the attributes aliased to the same location. OpenGL
        /// implementations are not required to do error checking to detect
        /// aliasing, they are allowed to assume that aliasing will not
        /// occur, and they are allowed to employ optimizations that work
        /// only in the absence of aliasing. 
        /// There is no provision for binding standard vertex
        /// attributes; therefore, it is not possible to alias generic
        /// attributes with standard attributes.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="index"/> is greater than or equal to
        /// <code>GL_MAX_VERTEX_ATTRIBS</code>.
        /// </para>
        /// Original: <para>void glVertexAttrib2fv(GLuint index, const GLfloat * v);</para>
        /// </summary>
        /// <param name="index">
        /// <para>
        /// Specifies the index of the generic vertex
        /// attribute to be modified.
        /// </para>
        /// </param>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array of values to
        /// be used for the generic vertex attribute.
        /// </para>
        /// </param>
        /// <seealso cref="BindAttribLocation"/>
        /// <seealso cref="Vertex"/>
        /// <seealso cref="VertexAttribPointer"/>
        public unsafe static void VertexAttrib2fv(uint index, ref float v) {
            fixed (float* pV = &v) {
                GLNative.glVertexAttrib2fv(index, pV);
            }
        }

        /// <summary>
        /// Specifies the value of a generic vertex attribute
        /// <para>Require:</para> <para>GL_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glVertexAttrib"/> is available only if
        /// the GL version is 2.0 or greater. 
        /// Generic vertex attributes can be updated at any time. In
        /// particular, <see cref="glVertexAttrib"/> can be called
        /// between a call to
        /// <see cref="glBegin"/> 
        /// and the corresponding call to
        /// <see cref="glEnd"/> . 
        /// It is possible for an application to bind more than one
        /// attribute name to the same generic vertex attribute index. This
        /// is referred to as aliasing, and it is allowed only if just one
        /// of the aliased attribute variables is active in the vertex
        /// shader, or if no path through the vertex shader consumes more
        /// than one of the attributes aliased to the same location. OpenGL
        /// implementations are not required to do error checking to detect
        /// aliasing, they are allowed to assume that aliasing will not
        /// occur, and they are allowed to employ optimizations that work
        /// only in the absence of aliasing. 
        /// There is no provision for binding standard vertex
        /// attributes; therefore, it is not possible to alias generic
        /// attributes with standard attributes.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="index"/> is greater than or equal to
        /// <code>GL_MAX_VERTEX_ATTRIBS</code>.
        /// </para>
        /// Original: <para>void glVertexAttrib2sv(GLuint index, const GLshort * v);</para>
        /// </summary>
        /// <param name="index">
        /// <para>
        /// Specifies the index of the generic vertex
        /// attribute to be modified.
        /// </para>
        /// </param>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array of values to
        /// be used for the generic vertex attribute.
        /// </para>
        /// </param>
        /// <seealso cref="BindAttribLocation"/>
        /// <seealso cref="Vertex"/>
        /// <seealso cref="VertexAttribPointer"/>
        public unsafe static void VertexAttrib2sv(uint index, ref short v) {
            fixed (short* pV = &v) {
                GLNative.glVertexAttrib2sv(index, pV);
            }
        }

        /// <summary>
        /// Specifies the value of a generic vertex attribute
        /// <para>Require:</para> <para>GL_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glVertexAttrib"/> is available only if
        /// the GL version is 2.0 or greater. 
        /// Generic vertex attributes can be updated at any time. In
        /// particular, <see cref="glVertexAttrib"/> can be called
        /// between a call to
        /// <see cref="glBegin"/> 
        /// and the corresponding call to
        /// <see cref="glEnd"/> . 
        /// It is possible for an application to bind more than one
        /// attribute name to the same generic vertex attribute index. This
        /// is referred to as aliasing, and it is allowed only if just one
        /// of the aliased attribute variables is active in the vertex
        /// shader, or if no path through the vertex shader consumes more
        /// than one of the attributes aliased to the same location. OpenGL
        /// implementations are not required to do error checking to detect
        /// aliasing, they are allowed to assume that aliasing will not
        /// occur, and they are allowed to employ optimizations that work
        /// only in the absence of aliasing. 
        /// There is no provision for binding standard vertex
        /// attributes; therefore, it is not possible to alias generic
        /// attributes with standard attributes.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="index"/> is greater than or equal to
        /// <code>GL_MAX_VERTEX_ATTRIBS</code>.
        /// </para>
        /// Original: <para>void glVertexAttrib3dv(GLuint index, const GLdouble * v);</para>
        /// </summary>
        /// <param name="index">
        /// <para>
        /// Specifies the index of the generic vertex
        /// attribute to be modified.
        /// </para>
        /// </param>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array of values to
        /// be used for the generic vertex attribute.
        /// </para>
        /// </param>
        /// <seealso cref="BindAttribLocation"/>
        /// <seealso cref="Vertex"/>
        /// <seealso cref="VertexAttribPointer"/>
        public unsafe static void VertexAttrib3dv(uint index, ref double v) {
            fixed (double* pV = &v) {
                GLNative.glVertexAttrib3dv(index, pV);
            }
        }

        /// <summary>
        /// Specifies the value of a generic vertex attribute
        /// <para>Require:</para> <para>GL_VERSION_2_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glVertexAttrib"/> is available only if
        /// the GL version is 2.0 or greater. 
        /// Generic vertex attributes can be updated at any time. In
        /// particular, <see cref="glVertexAttrib"/> can be called
        /// between a call to
        /// <see cref="glBegin"/> 
        /// and the corresponding call to
        /// <see cref="glEnd"/> . 
        /// It is possible for an application to bind more than one
        /// attribute name to the same generic vertex attribute index. This
        /// is referred to as aliasing, and it is allowed only if just one
        /// of the aliased attribute variables is active in the vertex
        /// shader, or if no path through the vertex shader consumes more
        /// than one of the attributes aliased to the same location. OpenGL
        /// implementations are not required to do error checking to detect
        /// aliasing, they are allowed to assume that aliasing will not
        /// occur, and they are allowed to employ optimizations that work
        /// only in the absence of aliasing. 
        /// There is no provision for binding standard vertex
        /// attributes; therefore, it is not possible to alias generic
        /// attributes with standard attributes.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="index"/> is greater than or equal to
        /// <code>GL_MAX_VERTEX_ATTRIBS</code>.
        /// </para>
        /// Original: <para>void glVertexAttrib3fv(GLuint index, const GLfloat * v);</para>
        /// </summary>
        /// <param name="index">
        /// <para>
        /// Specifies the index of the generic vertex
        /// attribute to be modified.
        /// </para>
        /// </param>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array of values to
        /// be used for the generic vertex attribute.
        /// </para>
        /// </param>
        /// <seealso cref="BindAttribLocation"/>
        /// <seealso cref="Vertex"/>
        /// <seealso cref="VertexAttribPointer"/>
        public unsafe static void VertexAttrib3fv(uint index, ref float v) {
            fixed (float* pV = &v) {
                GLNative.glVertexAttrib3fv(index, pV);
            }
        }

        /// <summary>
        /// Specifies the value of a generic vertex attribute
        /// <para>Require:</para> <para>GL_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glVertexAttrib"/> is available only if
        /// the GL version is 2.0 or greater. 
        /// Generic vertex attributes can be updated at any time. In
        /// particular, <see cref="glVertexAttrib"/> can be called
        /// between a call to
        /// <see cref="glBegin"/> 
        /// and the corresponding call to
        /// <see cref="glEnd"/> . 
        /// It is possible for an application to bind more than one
        /// attribute name to the same generic vertex attribute index. This
        /// is referred to as aliasing, and it is allowed only if just one
        /// of the aliased attribute variables is active in the vertex
        /// shader, or if no path through the vertex shader consumes more
        /// than one of the attributes aliased to the same location. OpenGL
        /// implementations are not required to do error checking to detect
        /// aliasing, they are allowed to assume that aliasing will not
        /// occur, and they are allowed to employ optimizations that work
        /// only in the absence of aliasing. 
        /// There is no provision for binding standard vertex
        /// attributes; therefore, it is not possible to alias generic
        /// attributes with standard attributes.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="index"/> is greater than or equal to
        /// <code>GL_MAX_VERTEX_ATTRIBS</code>.
        /// </para>
        /// Original: <para>void glVertexAttrib3sv(GLuint index, const GLshort * v);</para>
        /// </summary>
        /// <param name="index">
        /// <para>
        /// Specifies the index of the generic vertex
        /// attribute to be modified.
        /// </para>
        /// </param>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array of values to
        /// be used for the generic vertex attribute.
        /// </para>
        /// </param>
        /// <seealso cref="BindAttribLocation"/>
        /// <seealso cref="Vertex"/>
        /// <seealso cref="VertexAttribPointer"/>
        public unsafe static void VertexAttrib3sv(uint index, ref short v) {
            fixed (short* pV = &v) {
                GLNative.glVertexAttrib3sv(index, pV);
            }
        }

        /// <summary>
        /// Specifies the value of a generic vertex attribute
        /// <para>Require:</para> <para>GL_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glVertexAttrib"/> is available only if
        /// the GL version is 2.0 or greater. 
        /// Generic vertex attributes can be updated at any time. In
        /// particular, <see cref="glVertexAttrib"/> can be called
        /// between a call to
        /// <see cref="glBegin"/> 
        /// and the corresponding call to
        /// <see cref="glEnd"/> . 
        /// It is possible for an application to bind more than one
        /// attribute name to the same generic vertex attribute index. This
        /// is referred to as aliasing, and it is allowed only if just one
        /// of the aliased attribute variables is active in the vertex
        /// shader, or if no path through the vertex shader consumes more
        /// than one of the attributes aliased to the same location. OpenGL
        /// implementations are not required to do error checking to detect
        /// aliasing, they are allowed to assume that aliasing will not
        /// occur, and they are allowed to employ optimizations that work
        /// only in the absence of aliasing. 
        /// There is no provision for binding standard vertex
        /// attributes; therefore, it is not possible to alias generic
        /// attributes with standard attributes.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="index"/> is greater than or equal to
        /// <code>GL_MAX_VERTEX_ATTRIBS</code>.
        /// </para>
        /// Original: <para>void glVertexAttrib4Nbv(GLuint index, const GLbyte * v);</para>
        /// </summary>
        /// <param name="index">
        /// <para>
        /// Specifies the index of the generic vertex
        /// attribute to be modified.
        /// </para>
        /// </param>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array of values to
        /// be used for the generic vertex attribute.
        /// </para>
        /// </param>
        /// <seealso cref="BindAttribLocation"/>
        /// <seealso cref="Vertex"/>
        /// <seealso cref="VertexAttribPointer"/>
        public unsafe static void VertexAttrib4Nbv(uint index, ref byte v) {
            fixed (byte* pV = &v) {
                GLNative.glVertexAttrib4Nbv(index, pV);
            }
        }

        /// <summary>
        /// Specifies the value of a generic vertex attribute
        /// <para>Require:</para> <para>GL_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glVertexAttrib"/> is available only if
        /// the GL version is 2.0 or greater. 
        /// Generic vertex attributes can be updated at any time. In
        /// particular, <see cref="glVertexAttrib"/> can be called
        /// between a call to
        /// <see cref="glBegin"/> 
        /// and the corresponding call to
        /// <see cref="glEnd"/> . 
        /// It is possible for an application to bind more than one
        /// attribute name to the same generic vertex attribute index. This
        /// is referred to as aliasing, and it is allowed only if just one
        /// of the aliased attribute variables is active in the vertex
        /// shader, or if no path through the vertex shader consumes more
        /// than one of the attributes aliased to the same location. OpenGL
        /// implementations are not required to do error checking to detect
        /// aliasing, they are allowed to assume that aliasing will not
        /// occur, and they are allowed to employ optimizations that work
        /// only in the absence of aliasing. 
        /// There is no provision for binding standard vertex
        /// attributes; therefore, it is not possible to alias generic
        /// attributes with standard attributes.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="index"/> is greater than or equal to
        /// <code>GL_MAX_VERTEX_ATTRIBS</code>.
        /// </para>
        /// Original: <para>void glVertexAttrib4Niv(GLuint index, const GLint * v);</para>
        /// </summary>
        /// <param name="index">
        /// <para>
        /// Specifies the index of the generic vertex
        /// attribute to be modified.
        /// </para>
        /// </param>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array of values to
        /// be used for the generic vertex attribute.
        /// </para>
        /// </param>
        /// <seealso cref="BindAttribLocation"/>
        /// <seealso cref="Vertex"/>
        /// <seealso cref="VertexAttribPointer"/>
        public unsafe static void VertexAttrib4Niv(uint index, ref int v) {
            fixed (int* pV = &v) {
                GLNative.glVertexAttrib4Niv(index, pV);
            }
        }

        /// <summary>
        /// Specifies the value of a generic vertex attribute
        /// <para>Require:</para> <para>GL_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glVertexAttrib"/> is available only if
        /// the GL version is 2.0 or greater. 
        /// Generic vertex attributes can be updated at any time. In
        /// particular, <see cref="glVertexAttrib"/> can be called
        /// between a call to
        /// <see cref="glBegin"/> 
        /// and the corresponding call to
        /// <see cref="glEnd"/> . 
        /// It is possible for an application to bind more than one
        /// attribute name to the same generic vertex attribute index. This
        /// is referred to as aliasing, and it is allowed only if just one
        /// of the aliased attribute variables is active in the vertex
        /// shader, or if no path through the vertex shader consumes more
        /// than one of the attributes aliased to the same location. OpenGL
        /// implementations are not required to do error checking to detect
        /// aliasing, they are allowed to assume that aliasing will not
        /// occur, and they are allowed to employ optimizations that work
        /// only in the absence of aliasing. 
        /// There is no provision for binding standard vertex
        /// attributes; therefore, it is not possible to alias generic
        /// attributes with standard attributes.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="index"/> is greater than or equal to
        /// <code>GL_MAX_VERTEX_ATTRIBS</code>.
        /// </para>
        /// Original: <para>void glVertexAttrib4Nsv(GLuint index, const GLshort * v);</para>
        /// </summary>
        /// <param name="index">
        /// <para>
        /// Specifies the index of the generic vertex
        /// attribute to be modified.
        /// </para>
        /// </param>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array of values to
        /// be used for the generic vertex attribute.
        /// </para>
        /// </param>
        /// <seealso cref="BindAttribLocation"/>
        /// <seealso cref="Vertex"/>
        /// <seealso cref="VertexAttribPointer"/>
        public unsafe static void VertexAttrib4Nsv(uint index, ref short v) {
            fixed (short* pV = &v) {
                GLNative.glVertexAttrib4Nsv(index, pV);
            }
        }

        /// <summary>
        /// Specifies the value of a generic vertex attribute
        /// <para>Require:</para> <para>GL_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glVertexAttrib"/> is available only if
        /// the GL version is 2.0 or greater. 
        /// Generic vertex attributes can be updated at any time. In
        /// particular, <see cref="glVertexAttrib"/> can be called
        /// between a call to
        /// <see cref="glBegin"/> 
        /// and the corresponding call to
        /// <see cref="glEnd"/> . 
        /// It is possible for an application to bind more than one
        /// attribute name to the same generic vertex attribute index. This
        /// is referred to as aliasing, and it is allowed only if just one
        /// of the aliased attribute variables is active in the vertex
        /// shader, or if no path through the vertex shader consumes more
        /// than one of the attributes aliased to the same location. OpenGL
        /// implementations are not required to do error checking to detect
        /// aliasing, they are allowed to assume that aliasing will not
        /// occur, and they are allowed to employ optimizations that work
        /// only in the absence of aliasing. 
        /// There is no provision for binding standard vertex
        /// attributes; therefore, it is not possible to alias generic
        /// attributes with standard attributes.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="index"/> is greater than or equal to
        /// <code>GL_MAX_VERTEX_ATTRIBS</code>.
        /// </para>
        /// Original: <para>void glVertexAttrib4Nubv(GLuint index, const GLubyte * v);</para>
        /// </summary>
        /// <param name="index">
        /// <para>
        /// Specifies the index of the generic vertex
        /// attribute to be modified.
        /// </para>
        /// </param>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array of values to
        /// be used for the generic vertex attribute.
        /// </para>
        /// </param>
        /// <seealso cref="BindAttribLocation"/>
        /// <seealso cref="Vertex"/>
        /// <seealso cref="VertexAttribPointer"/>
        public unsafe static void VertexAttrib4Nubv(uint index, ref byte v) {
            fixed (byte* pV = &v) {
                GLNative.glVertexAttrib4Nubv(index, pV);
            }
        }

        /// <summary>
        /// Specifies the value of a generic vertex attribute
        /// <para>Require:</para> <para>GL_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glVertexAttrib"/> is available only if
        /// the GL version is 2.0 or greater. 
        /// Generic vertex attributes can be updated at any time. In
        /// particular, <see cref="glVertexAttrib"/> can be called
        /// between a call to
        /// <see cref="glBegin"/> 
        /// and the corresponding call to
        /// <see cref="glEnd"/> . 
        /// It is possible for an application to bind more than one
        /// attribute name to the same generic vertex attribute index. This
        /// is referred to as aliasing, and it is allowed only if just one
        /// of the aliased attribute variables is active in the vertex
        /// shader, or if no path through the vertex shader consumes more
        /// than one of the attributes aliased to the same location. OpenGL
        /// implementations are not required to do error checking to detect
        /// aliasing, they are allowed to assume that aliasing will not
        /// occur, and they are allowed to employ optimizations that work
        /// only in the absence of aliasing. 
        /// There is no provision for binding standard vertex
        /// attributes; therefore, it is not possible to alias generic
        /// attributes with standard attributes.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="index"/> is greater than or equal to
        /// <code>GL_MAX_VERTEX_ATTRIBS</code>.
        /// </para>
        /// Original: <para>void glVertexAttrib4Nuiv(GLuint index, const GLuint * v);</para>
        /// </summary>
        /// <param name="index">
        /// <para>
        /// Specifies the index of the generic vertex
        /// attribute to be modified.
        /// </para>
        /// </param>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array of values to
        /// be used for the generic vertex attribute.
        /// </para>
        /// </param>
        /// <seealso cref="BindAttribLocation"/>
        /// <seealso cref="Vertex"/>
        /// <seealso cref="VertexAttribPointer"/>
        public unsafe static void VertexAttrib4Nuiv(uint index, ref uint v) {
            fixed (uint* pV = &v) {
                GLNative.glVertexAttrib4Nuiv(index, pV);
            }
        }

        /// <summary>
        /// Specifies the value of a generic vertex attribute
        /// <para>Require:</para> <para>GL_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glVertexAttrib"/> is available only if
        /// the GL version is 2.0 or greater. 
        /// Generic vertex attributes can be updated at any time. In
        /// particular, <see cref="glVertexAttrib"/> can be called
        /// between a call to
        /// <see cref="glBegin"/> 
        /// and the corresponding call to
        /// <see cref="glEnd"/> . 
        /// It is possible for an application to bind more than one
        /// attribute name to the same generic vertex attribute index. This
        /// is referred to as aliasing, and it is allowed only if just one
        /// of the aliased attribute variables is active in the vertex
        /// shader, or if no path through the vertex shader consumes more
        /// than one of the attributes aliased to the same location. OpenGL
        /// implementations are not required to do error checking to detect
        /// aliasing, they are allowed to assume that aliasing will not
        /// occur, and they are allowed to employ optimizations that work
        /// only in the absence of aliasing. 
        /// There is no provision for binding standard vertex
        /// attributes; therefore, it is not possible to alias generic
        /// attributes with standard attributes.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="index"/> is greater than or equal to
        /// <code>GL_MAX_VERTEX_ATTRIBS</code>.
        /// </para>
        /// Original: <para>void glVertexAttrib4Nusv(GLuint index, const GLushort * v);</para>
        /// </summary>
        /// <param name="index">
        /// <para>
        /// Specifies the index of the generic vertex
        /// attribute to be modified.
        /// </para>
        /// </param>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array of values to
        /// be used for the generic vertex attribute.
        /// </para>
        /// </param>
        /// <seealso cref="BindAttribLocation"/>
        /// <seealso cref="Vertex"/>
        /// <seealso cref="VertexAttribPointer"/>
        public unsafe static void VertexAttrib4Nusv(uint index, ref ushort v) {
            fixed (ushort* pV = &v) {
                GLNative.glVertexAttrib4Nusv(index, pV);
            }
        }

        /// <summary>
        /// Specifies the value of a generic vertex attribute
        /// <para>Require:</para> <para>GL_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glVertexAttrib"/> is available only if
        /// the GL version is 2.0 or greater. 
        /// Generic vertex attributes can be updated at any time. In
        /// particular, <see cref="glVertexAttrib"/> can be called
        /// between a call to
        /// <see cref="glBegin"/> 
        /// and the corresponding call to
        /// <see cref="glEnd"/> . 
        /// It is possible for an application to bind more than one
        /// attribute name to the same generic vertex attribute index. This
        /// is referred to as aliasing, and it is allowed only if just one
        /// of the aliased attribute variables is active in the vertex
        /// shader, or if no path through the vertex shader consumes more
        /// than one of the attributes aliased to the same location. OpenGL
        /// implementations are not required to do error checking to detect
        /// aliasing, they are allowed to assume that aliasing will not
        /// occur, and they are allowed to employ optimizations that work
        /// only in the absence of aliasing. 
        /// There is no provision for binding standard vertex
        /// attributes; therefore, it is not possible to alias generic
        /// attributes with standard attributes.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="index"/> is greater than or equal to
        /// <code>GL_MAX_VERTEX_ATTRIBS</code>.
        /// </para>
        /// Original: <para>void glVertexAttrib4bv(GLuint index, const GLbyte * v);</para>
        /// </summary>
        /// <param name="index">
        /// <para>
        /// Specifies the index of the generic vertex
        /// attribute to be modified.
        /// </para>
        /// </param>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array of values to
        /// be used for the generic vertex attribute.
        /// </para>
        /// </param>
        /// <seealso cref="BindAttribLocation"/>
        /// <seealso cref="Vertex"/>
        /// <seealso cref="VertexAttribPointer"/>
        public unsafe static void VertexAttrib4bv(uint index, ref byte v) {
            fixed (byte* pV = &v) {
                GLNative.glVertexAttrib4bv(index, pV);
            }
        }

        /// <summary>
        /// Specifies the value of a generic vertex attribute
        /// <para>Require:</para> <para>GL_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glVertexAttrib"/> is available only if
        /// the GL version is 2.0 or greater. 
        /// Generic vertex attributes can be updated at any time. In
        /// particular, <see cref="glVertexAttrib"/> can be called
        /// between a call to
        /// <see cref="glBegin"/> 
        /// and the corresponding call to
        /// <see cref="glEnd"/> . 
        /// It is possible for an application to bind more than one
        /// attribute name to the same generic vertex attribute index. This
        /// is referred to as aliasing, and it is allowed only if just one
        /// of the aliased attribute variables is active in the vertex
        /// shader, or if no path through the vertex shader consumes more
        /// than one of the attributes aliased to the same location. OpenGL
        /// implementations are not required to do error checking to detect
        /// aliasing, they are allowed to assume that aliasing will not
        /// occur, and they are allowed to employ optimizations that work
        /// only in the absence of aliasing. 
        /// There is no provision for binding standard vertex
        /// attributes; therefore, it is not possible to alias generic
        /// attributes with standard attributes.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="index"/> is greater than or equal to
        /// <code>GL_MAX_VERTEX_ATTRIBS</code>.
        /// </para>
        /// Original: <para>void glVertexAttrib4dv(GLuint index, const GLdouble * v);</para>
        /// </summary>
        /// <param name="index">
        /// <para>
        /// Specifies the index of the generic vertex
        /// attribute to be modified.
        /// </para>
        /// </param>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array of values to
        /// be used for the generic vertex attribute.
        /// </para>
        /// </param>
        /// <seealso cref="BindAttribLocation"/>
        /// <seealso cref="Vertex"/>
        /// <seealso cref="VertexAttribPointer"/>
        public unsafe static void VertexAttrib4dv(uint index, ref double v) {
            fixed (double* pV = &v) {
                GLNative.glVertexAttrib4dv(index, pV);
            }
        }

        /// <summary>
        /// Specifies the value of a generic vertex attribute
        /// <para>Require:</para> <para>GL_VERSION_2_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glVertexAttrib"/> is available only if
        /// the GL version is 2.0 or greater. 
        /// Generic vertex attributes can be updated at any time. In
        /// particular, <see cref="glVertexAttrib"/> can be called
        /// between a call to
        /// <see cref="glBegin"/> 
        /// and the corresponding call to
        /// <see cref="glEnd"/> . 
        /// It is possible for an application to bind more than one
        /// attribute name to the same generic vertex attribute index. This
        /// is referred to as aliasing, and it is allowed only if just one
        /// of the aliased attribute variables is active in the vertex
        /// shader, or if no path through the vertex shader consumes more
        /// than one of the attributes aliased to the same location. OpenGL
        /// implementations are not required to do error checking to detect
        /// aliasing, they are allowed to assume that aliasing will not
        /// occur, and they are allowed to employ optimizations that work
        /// only in the absence of aliasing. 
        /// There is no provision for binding standard vertex
        /// attributes; therefore, it is not possible to alias generic
        /// attributes with standard attributes.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="index"/> is greater than or equal to
        /// <code>GL_MAX_VERTEX_ATTRIBS</code>.
        /// </para>
        /// Original: <para>void glVertexAttrib4fv(GLuint index, const GLfloat * v);</para>
        /// </summary>
        /// <param name="index">
        /// <para>
        /// Specifies the index of the generic vertex
        /// attribute to be modified.
        /// </para>
        /// </param>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array of values to
        /// be used for the generic vertex attribute.
        /// </para>
        /// </param>
        /// <seealso cref="BindAttribLocation"/>
        /// <seealso cref="Vertex"/>
        /// <seealso cref="VertexAttribPointer"/>
        public unsafe static void VertexAttrib4fv(uint index, ref float v) {
            fixed (float* pV = &v) {
                GLNative.glVertexAttrib4fv(index, pV);
            }
        }

        /// <summary>
        /// Specifies the value of a generic vertex attribute
        /// <para>Require:</para> <para>GL_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glVertexAttrib"/> is available only if
        /// the GL version is 2.0 or greater. 
        /// Generic vertex attributes can be updated at any time. In
        /// particular, <see cref="glVertexAttrib"/> can be called
        /// between a call to
        /// <see cref="glBegin"/> 
        /// and the corresponding call to
        /// <see cref="glEnd"/> . 
        /// It is possible for an application to bind more than one
        /// attribute name to the same generic vertex attribute index. This
        /// is referred to as aliasing, and it is allowed only if just one
        /// of the aliased attribute variables is active in the vertex
        /// shader, or if no path through the vertex shader consumes more
        /// than one of the attributes aliased to the same location. OpenGL
        /// implementations are not required to do error checking to detect
        /// aliasing, they are allowed to assume that aliasing will not
        /// occur, and they are allowed to employ optimizations that work
        /// only in the absence of aliasing. 
        /// There is no provision for binding standard vertex
        /// attributes; therefore, it is not possible to alias generic
        /// attributes with standard attributes.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="index"/> is greater than or equal to
        /// <code>GL_MAX_VERTEX_ATTRIBS</code>.
        /// </para>
        /// Original: <para>void glVertexAttrib4iv(GLuint index, const GLint * v);</para>
        /// </summary>
        /// <param name="index">
        /// <para>
        /// Specifies the index of the generic vertex
        /// attribute to be modified.
        /// </para>
        /// </param>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array of values to
        /// be used for the generic vertex attribute.
        /// </para>
        /// </param>
        /// <seealso cref="BindAttribLocation"/>
        /// <seealso cref="Vertex"/>
        /// <seealso cref="VertexAttribPointer"/>
        public unsafe static void VertexAttrib4iv(uint index, ref int v) {
            fixed (int* pV = &v) {
                GLNative.glVertexAttrib4iv(index, pV);
            }
        }

        /// <summary>
        /// Specifies the value of a generic vertex attribute
        /// <para>Require:</para> <para>GL_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glVertexAttrib"/> is available only if
        /// the GL version is 2.0 or greater. 
        /// Generic vertex attributes can be updated at any time. In
        /// particular, <see cref="glVertexAttrib"/> can be called
        /// between a call to
        /// <see cref="glBegin"/> 
        /// and the corresponding call to
        /// <see cref="glEnd"/> . 
        /// It is possible for an application to bind more than one
        /// attribute name to the same generic vertex attribute index. This
        /// is referred to as aliasing, and it is allowed only if just one
        /// of the aliased attribute variables is active in the vertex
        /// shader, or if no path through the vertex shader consumes more
        /// than one of the attributes aliased to the same location. OpenGL
        /// implementations are not required to do error checking to detect
        /// aliasing, they are allowed to assume that aliasing will not
        /// occur, and they are allowed to employ optimizations that work
        /// only in the absence of aliasing. 
        /// There is no provision for binding standard vertex
        /// attributes; therefore, it is not possible to alias generic
        /// attributes with standard attributes.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="index"/> is greater than or equal to
        /// <code>GL_MAX_VERTEX_ATTRIBS</code>.
        /// </para>
        /// Original: <para>void glVertexAttrib4sv(GLuint index, const GLshort * v);</para>
        /// </summary>
        /// <param name="index">
        /// <para>
        /// Specifies the index of the generic vertex
        /// attribute to be modified.
        /// </para>
        /// </param>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array of values to
        /// be used for the generic vertex attribute.
        /// </para>
        /// </param>
        /// <seealso cref="BindAttribLocation"/>
        /// <seealso cref="Vertex"/>
        /// <seealso cref="VertexAttribPointer"/>
        public unsafe static void VertexAttrib4sv(uint index, ref short v) {
            fixed (short* pV = &v) {
                GLNative.glVertexAttrib4sv(index, pV);
            }
        }

        /// <summary>
        /// Specifies the value of a generic vertex attribute
        /// <para>Require:</para> <para>GL_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glVertexAttrib"/> is available only if
        /// the GL version is 2.0 or greater. 
        /// Generic vertex attributes can be updated at any time. In
        /// particular, <see cref="glVertexAttrib"/> can be called
        /// between a call to
        /// <see cref="glBegin"/> 
        /// and the corresponding call to
        /// <see cref="glEnd"/> . 
        /// It is possible for an application to bind more than one
        /// attribute name to the same generic vertex attribute index. This
        /// is referred to as aliasing, and it is allowed only if just one
        /// of the aliased attribute variables is active in the vertex
        /// shader, or if no path through the vertex shader consumes more
        /// than one of the attributes aliased to the same location. OpenGL
        /// implementations are not required to do error checking to detect
        /// aliasing, they are allowed to assume that aliasing will not
        /// occur, and they are allowed to employ optimizations that work
        /// only in the absence of aliasing. 
        /// There is no provision for binding standard vertex
        /// attributes; therefore, it is not possible to alias generic
        /// attributes with standard attributes.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="index"/> is greater than or equal to
        /// <code>GL_MAX_VERTEX_ATTRIBS</code>.
        /// </para>
        /// Original: <para>void glVertexAttrib4ubv(GLuint index, const GLubyte * v);</para>
        /// </summary>
        /// <param name="index">
        /// <para>
        /// Specifies the index of the generic vertex
        /// attribute to be modified.
        /// </para>
        /// </param>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array of values to
        /// be used for the generic vertex attribute.
        /// </para>
        /// </param>
        /// <seealso cref="BindAttribLocation"/>
        /// <seealso cref="Vertex"/>
        /// <seealso cref="VertexAttribPointer"/>
        public unsafe static void VertexAttrib4ubv(uint index, ref byte v) {
            fixed (byte* pV = &v) {
                GLNative.glVertexAttrib4ubv(index, pV);
            }
        }

        /// <summary>
        /// Specifies the value of a generic vertex attribute
        /// <para>Require:</para> <para>GL_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glVertexAttrib"/> is available only if
        /// the GL version is 2.0 or greater. 
        /// Generic vertex attributes can be updated at any time. In
        /// particular, <see cref="glVertexAttrib"/> can be called
        /// between a call to
        /// <see cref="glBegin"/> 
        /// and the corresponding call to
        /// <see cref="glEnd"/> . 
        /// It is possible for an application to bind more than one
        /// attribute name to the same generic vertex attribute index. This
        /// is referred to as aliasing, and it is allowed only if just one
        /// of the aliased attribute variables is active in the vertex
        /// shader, or if no path through the vertex shader consumes more
        /// than one of the attributes aliased to the same location. OpenGL
        /// implementations are not required to do error checking to detect
        /// aliasing, they are allowed to assume that aliasing will not
        /// occur, and they are allowed to employ optimizations that work
        /// only in the absence of aliasing. 
        /// There is no provision for binding standard vertex
        /// attributes; therefore, it is not possible to alias generic
        /// attributes with standard attributes.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="index"/> is greater than or equal to
        /// <code>GL_MAX_VERTEX_ATTRIBS</code>.
        /// </para>
        /// Original: <para>void glVertexAttrib4uiv(GLuint index, const GLuint * v);</para>
        /// </summary>
        /// <param name="index">
        /// <para>
        /// Specifies the index of the generic vertex
        /// attribute to be modified.
        /// </para>
        /// </param>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array of values to
        /// be used for the generic vertex attribute.
        /// </para>
        /// </param>
        /// <seealso cref="BindAttribLocation"/>
        /// <seealso cref="Vertex"/>
        /// <seealso cref="VertexAttribPointer"/>
        public unsafe static void VertexAttrib4uiv(uint index, ref uint v) {
            fixed (uint* pV = &v) {
                GLNative.glVertexAttrib4uiv(index, pV);
            }
        }

        /// <summary>
        /// Specifies the value of a generic vertex attribute
        /// <para>Require:</para> <para>GL_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glVertexAttrib"/> is available only if
        /// the GL version is 2.0 or greater. 
        /// Generic vertex attributes can be updated at any time. In
        /// particular, <see cref="glVertexAttrib"/> can be called
        /// between a call to
        /// <see cref="glBegin"/> 
        /// and the corresponding call to
        /// <see cref="glEnd"/> . 
        /// It is possible for an application to bind more than one
        /// attribute name to the same generic vertex attribute index. This
        /// is referred to as aliasing, and it is allowed only if just one
        /// of the aliased attribute variables is active in the vertex
        /// shader, or if no path through the vertex shader consumes more
        /// than one of the attributes aliased to the same location. OpenGL
        /// implementations are not required to do error checking to detect
        /// aliasing, they are allowed to assume that aliasing will not
        /// occur, and they are allowed to employ optimizations that work
        /// only in the absence of aliasing. 
        /// There is no provision for binding standard vertex
        /// attributes; therefore, it is not possible to alias generic
        /// attributes with standard attributes.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="index"/> is greater than or equal to
        /// <code>GL_MAX_VERTEX_ATTRIBS</code>.
        /// </para>
        /// Original: <para>void glVertexAttrib4usv(GLuint index, const GLushort * v);</para>
        /// </summary>
        /// <param name="index">
        /// <para>
        /// Specifies the index of the generic vertex
        /// attribute to be modified.
        /// </para>
        /// </param>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array of values to
        /// be used for the generic vertex attribute.
        /// </para>
        /// </param>
        /// <seealso cref="BindAttribLocation"/>
        /// <seealso cref="Vertex"/>
        /// <seealso cref="VertexAttribPointer"/>
        public unsafe static void VertexAttrib4usv(uint index, ref ushort v) {
            fixed (ushort* pV = &v) {
                GLNative.glVertexAttrib4usv(index, pV);
            }
        }

        /// <summary>
        /// define an array of generic vertex attribute data
        /// <para>Require:</para> <para>GL_VERSION_2_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glVertexAttribPointer"/> is available
        /// only if the GL version is 2.0 or greater. 
        /// Each generic vertex attribute array is initially disabled
        /// and isn't accessed when
        /// <see cref="glArrayElement"/> ,  <see cref="glDrawElements"/> ,  <see cref="glDrawRangeElements"/> ,
        /// <see cref="glDrawArrays"/> ,  <see cref="glMultiDrawArrays"/> , or  <see cref="glMultiDrawElements"/> 
        /// is called. 
        /// Execution of <see cref="glVertexAttribPointer"/> is
        /// not allowed between the execution of
        /// <see cref="glBegin"/> 
        /// and the corresponding execution of
        /// <see cref="glEnd"/> ,
        /// but an error may or may not be generated. If no error is
        /// generated, the operation is undefined. 
        /// <see cref="glVertexAttribPointer"/> is typically
        /// implemented on the client side. 
        /// Generic vertex attribute array parameters are client-side
        /// state and are therefore not saved or restored by
        /// <see cref="glPushAttrib"/> 
        /// and
        /// <see cref="glPopAttrib"/> .
        /// Use
        /// <see cref="glPushClientAttrib"/> 
        /// and
        /// <see cref="glPopClientAttrib"/> 
        /// instead.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="index"/> is greater than or equal to
        /// <code>GL_MAX_VERTEX_ATTRIBS</code>. 
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="size"/> is not 1, 2, 3, or 4. 
        /// <code>GL_INVALID_ENUM</code> is generated if
        /// <paramref name="type"/> is not an accepted value. 
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="stride"/> is negative.
        /// </para>
        /// Original: <para>void glVertexAttribPointer(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const void * pointer);</para>
        /// </summary>
        /// <param name="index">
        /// <para>
        /// Specifies the index of the generic vertex
        /// attribute to be modified.
        /// </para>
        /// </param>
        /// <param name="size">
        /// <para>
        /// Specifies the number of components per
        /// generic vertex attribute. Must
        /// be 1, 2, 3, or 4. The initial value is 4.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the data type of each component in
        /// the array. Symbolic constants
        /// <code>GL_BYTE</code>,
        /// <code>GL_UNSIGNED_BYTE</code>,
        /// <code>GL_SHORT</code>,
        /// <code>GL_UNSIGNED_SHORT</code>,
        /// <code>GL_INT</code>,
        /// <code>GL_UNSIGNED_INT</code>,
        /// <code>GL_FLOAT</code>, or
        /// <code>GL_DOUBLE</code> are
        /// accepted. The initial value is <code>GL_FLOAT</code>.
        /// </para>
        /// </param>
        /// <param name="normalized">
        /// <para>
        /// Specifies whether fixed-point data values
        /// should be normalized (<code>GL_TRUE</code>)
        /// or converted directly as fixed-point values
        /// (<code>GL_FALSE</code>) when they are
        /// accessed.
        /// </para>
        /// </param>
        /// <param name="stride">
        /// <para>
        /// Specifies the byte offset between consecutive
        /// generic vertex attributes. If <paramref name="stride"/>
        /// is 0, the generic vertex attributes are
        /// understood to be tightly packed in the
        /// array. The initial value is 0.
        /// </para>
        /// </param>
        /// <param name="pointer">
        /// <para>
        /// Specifies a pointer to the first component of
        /// the first generic vertex attribute in the array. The initial value is 0.
        /// </para>
        /// </param>
        /// <seealso cref="ArrayElement"/>
        /// <seealso cref="BindAttribLocation"/>
        /// <seealso cref="BindBuffer"/>
        /// <seealso cref="ColorPointer"/>
        /// <seealso cref="DisableVertexAttribArray"/>
        /// <seealso cref="DrawArrays"/>
        /// <seealso cref="DrawElements"/>
        /// <seealso cref="DrawRangeElements"/>
        /// <seealso cref="EnableVertexAttribArray"/>
        /// <seealso cref="EdgeFlagPointer"/>
        /// <seealso cref="FogCoordPointer"/>
        /// <seealso cref="IndexPointer"/>
        /// <seealso cref="InterleavedArrays"/>
        /// <seealso cref="MultiDrawArrays"/>
        /// <seealso cref="MultiDrawElements"/>
        /// <seealso cref="NormalPointer"/>
        /// <seealso cref="PopClientAttrib"/>
        /// <seealso cref="PushClientAttrib"/>
        /// <seealso cref="SecondaryColorPointer"/>
        /// <seealso cref="TexCoordPointer"/>
        /// <seealso cref="VertexAttrib"/>
        /// <seealso cref="VertexPointer"/>
        public unsafe static void VertexAttribPointer(uint index, int size, uint type, bool normalized, int stride, IntPtr pointer) {
            GLNative.glVertexAttribPointer(index, size, type, normalized, stride, (void*)pointer);
        }


        #endregion GL_VERSION_2_0

        #region GL_VERSION_2_1

        /// <summary>
        /// Specify the value of a uniform variable for the current program object
        /// <para>Require:</para> <para>GL_VERSION_2_1, GL_ES_VERSION_3_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glUniform"/> is available only if the GL
        /// version is 2.0 or greater. 
        /// <see cref="glUniformMatrix{2x3|3x2|2x4|4x2|3x4|4x3}fv"/> 
        /// is available only if the GL version is 2.1 or greater. 
        /// <see cref="glUniform1i"/> and
        /// <see cref="glUniform1iv"/> are the only two functions
        /// that may be used to load uniform variables defined as sampler
        /// types. Loading samplers with any other function will result in a
        /// <code>GL_INVALID_OPERATION</code> error. 
        /// If <paramref name="count"/> is greater than 1 and the
        /// indicated uniform variable is not an array, a
        /// <code>GL_INVALID_OPERATION</code> error is generated and the
        /// specified uniform variable will remain unchanged. 
        /// Other than the preceding exceptions, if the type and size
        /// of the uniform variable as defined in the shader do not match
        /// the type and size specified in the name of the command used to
        /// load its value, a <code>GL_INVALID_OPERATION</code> error will
        /// be generated and the specified uniform variable will remain
        /// unchanged. 
        /// If <paramref name="location"/> is a value other than
        /// -1 and it does not represent a valid uniform variable location
        /// in the current program object, an error will be generated, and
        /// no changes will be made to the uniform variable storage of the
        /// current program object. If <paramref name="location"/> is
        /// equal to -1, the data passed in will be silently ignored and the
        /// specified uniform variable will not be changed.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if there
        /// is no current program object. 
        /// <code>GL_INVALID_OPERATION</code> is generated if the
        /// size of the uniform variable declared in the shader does not
        /// match the size indicated by the <see cref="glUniform"/>
        /// command. 
        /// <code>GL_INVALID_OPERATION</code> is generated if one of
        /// the integer variants of this function is used to load a uniform
        /// variable of type float, vec2, vec3, vec4, or an array of these,
        /// or if one of the floating-point variants of this function is
        /// used to load a uniform variable of type int, ivec2, ivec3, or
        /// ivec4, or an array of these. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <paramref name="location"/> is an invalid uniform location
        /// for the current program object and
        /// <paramref name="location"/> is not equal to -1. 
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="count"/> is less than 0. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <paramref name="count"/> is greater than 1 and the indicated
        /// uniform variable is not an array variable. 
        /// <code>GL_INVALID_OPERATION</code> is generated if a
        /// sampler is loaded using a command other than
        /// <see cref="glUniform1i"/> and
        /// <see cref="glUniform1iv"/>. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <see cref="glUniform"/> is executed between the execution
        /// of
        /// <see cref="glBegin"/> 
        /// and the corresponding execution of
        /// <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glUniformMatrix2x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);</para>
        /// </summary>
        /// <param name="location">
        /// <para>
        /// Specifies the location of the uniform value to
        /// be modified.
        /// </para>
        /// </param>
        /// <param name="count">
        /// <para>
        /// Specifies the number of matrices that are to
        /// be modified. This should be 1 if the targeted
        /// uniform variable is not an array of matrices, and 1 or more if it is
        /// an array of matrices.
        /// </para>
        /// </param>
        /// <param name="transpose">
        /// <para>
        /// Specifies whether to transpose the matrix as
        /// the values are loaded into the uniform
        /// variable.
        /// </para>
        /// </param>
        /// <param name="value">
        /// <para>
        /// Specifies a pointer to an array of
        /// <paramref name="count"/> values that will be
        /// used to update the specified uniform
        /// variable.
        /// </para>
        /// </param>
        /// <seealso cref="LinkProgram"/>
        /// <seealso cref="UseProgram"/>
        public unsafe static void UniformMatrix2x3fv(int location, int count, bool transpose, ref float value) {
            fixed (float* pValue = &value) {
                GLNative.glUniformMatrix2x3fv(location, count, transpose, pValue);
            }
        }

        /// <summary>
        /// Specify the value of a uniform variable for the current program object
        /// <para>Require:</para> <para>GL_VERSION_2_1, GL_ES_VERSION_3_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glUniform"/> is available only if the GL
        /// version is 2.0 or greater. 
        /// <see cref="glUniformMatrix{2x3|3x2|2x4|4x2|3x4|4x3}fv"/> 
        /// is available only if the GL version is 2.1 or greater. 
        /// <see cref="glUniform1i"/> and
        /// <see cref="glUniform1iv"/> are the only two functions
        /// that may be used to load uniform variables defined as sampler
        /// types. Loading samplers with any other function will result in a
        /// <code>GL_INVALID_OPERATION</code> error. 
        /// If <paramref name="count"/> is greater than 1 and the
        /// indicated uniform variable is not an array, a
        /// <code>GL_INVALID_OPERATION</code> error is generated and the
        /// specified uniform variable will remain unchanged. 
        /// Other than the preceding exceptions, if the type and size
        /// of the uniform variable as defined in the shader do not match
        /// the type and size specified in the name of the command used to
        /// load its value, a <code>GL_INVALID_OPERATION</code> error will
        /// be generated and the specified uniform variable will remain
        /// unchanged. 
        /// If <paramref name="location"/> is a value other than
        /// -1 and it does not represent a valid uniform variable location
        /// in the current program object, an error will be generated, and
        /// no changes will be made to the uniform variable storage of the
        /// current program object. If <paramref name="location"/> is
        /// equal to -1, the data passed in will be silently ignored and the
        /// specified uniform variable will not be changed.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if there
        /// is no current program object. 
        /// <code>GL_INVALID_OPERATION</code> is generated if the
        /// size of the uniform variable declared in the shader does not
        /// match the size indicated by the <see cref="glUniform"/>
        /// command. 
        /// <code>GL_INVALID_OPERATION</code> is generated if one of
        /// the integer variants of this function is used to load a uniform
        /// variable of type float, vec2, vec3, vec4, or an array of these,
        /// or if one of the floating-point variants of this function is
        /// used to load a uniform variable of type int, ivec2, ivec3, or
        /// ivec4, or an array of these. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <paramref name="location"/> is an invalid uniform location
        /// for the current program object and
        /// <paramref name="location"/> is not equal to -1. 
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="count"/> is less than 0. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <paramref name="count"/> is greater than 1 and the indicated
        /// uniform variable is not an array variable. 
        /// <code>GL_INVALID_OPERATION</code> is generated if a
        /// sampler is loaded using a command other than
        /// <see cref="glUniform1i"/> and
        /// <see cref="glUniform1iv"/>. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <see cref="glUniform"/> is executed between the execution
        /// of
        /// <see cref="glBegin"/> 
        /// and the corresponding execution of
        /// <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glUniformMatrix3x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);</para>
        /// </summary>
        /// <param name="location">
        /// <para>
        /// Specifies the location of the uniform value to
        /// be modified.
        /// </para>
        /// </param>
        /// <param name="count">
        /// <para>
        /// Specifies the number of matrices that are to
        /// be modified. This should be 1 if the targeted
        /// uniform variable is not an array of matrices, and 1 or more if it is
        /// an array of matrices.
        /// </para>
        /// </param>
        /// <param name="transpose">
        /// <para>
        /// Specifies whether to transpose the matrix as
        /// the values are loaded into the uniform
        /// variable.
        /// </para>
        /// </param>
        /// <param name="value">
        /// <para>
        /// Specifies a pointer to an array of
        /// <paramref name="count"/> values that will be
        /// used to update the specified uniform
        /// variable.
        /// </para>
        /// </param>
        /// <seealso cref="LinkProgram"/>
        /// <seealso cref="UseProgram"/>
        public unsafe static void UniformMatrix3x2fv(int location, int count, bool transpose, ref float value) {
            fixed (float* pValue = &value) {
                GLNative.glUniformMatrix3x2fv(location, count, transpose, pValue);
            }
        }

        /// <summary>
        /// Specify the value of a uniform variable for the current program object
        /// <para>Require:</para> <para>GL_VERSION_2_1, GL_ES_VERSION_3_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glUniform"/> is available only if the GL
        /// version is 2.0 or greater. 
        /// <see cref="glUniformMatrix{2x3|3x2|2x4|4x2|3x4|4x3}fv"/> 
        /// is available only if the GL version is 2.1 or greater. 
        /// <see cref="glUniform1i"/> and
        /// <see cref="glUniform1iv"/> are the only two functions
        /// that may be used to load uniform variables defined as sampler
        /// types. Loading samplers with any other function will result in a
        /// <code>GL_INVALID_OPERATION</code> error. 
        /// If <paramref name="count"/> is greater than 1 and the
        /// indicated uniform variable is not an array, a
        /// <code>GL_INVALID_OPERATION</code> error is generated and the
        /// specified uniform variable will remain unchanged. 
        /// Other than the preceding exceptions, if the type and size
        /// of the uniform variable as defined in the shader do not match
        /// the type and size specified in the name of the command used to
        /// load its value, a <code>GL_INVALID_OPERATION</code> error will
        /// be generated and the specified uniform variable will remain
        /// unchanged. 
        /// If <paramref name="location"/> is a value other than
        /// -1 and it does not represent a valid uniform variable location
        /// in the current program object, an error will be generated, and
        /// no changes will be made to the uniform variable storage of the
        /// current program object. If <paramref name="location"/> is
        /// equal to -1, the data passed in will be silently ignored and the
        /// specified uniform variable will not be changed.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if there
        /// is no current program object. 
        /// <code>GL_INVALID_OPERATION</code> is generated if the
        /// size of the uniform variable declared in the shader does not
        /// match the size indicated by the <see cref="glUniform"/>
        /// command. 
        /// <code>GL_INVALID_OPERATION</code> is generated if one of
        /// the integer variants of this function is used to load a uniform
        /// variable of type float, vec2, vec3, vec4, or an array of these,
        /// or if one of the floating-point variants of this function is
        /// used to load a uniform variable of type int, ivec2, ivec3, or
        /// ivec4, or an array of these. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <paramref name="location"/> is an invalid uniform location
        /// for the current program object and
        /// <paramref name="location"/> is not equal to -1. 
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="count"/> is less than 0. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <paramref name="count"/> is greater than 1 and the indicated
        /// uniform variable is not an array variable. 
        /// <code>GL_INVALID_OPERATION</code> is generated if a
        /// sampler is loaded using a command other than
        /// <see cref="glUniform1i"/> and
        /// <see cref="glUniform1iv"/>. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <see cref="glUniform"/> is executed between the execution
        /// of
        /// <see cref="glBegin"/> 
        /// and the corresponding execution of
        /// <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glUniformMatrix2x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);</para>
        /// </summary>
        /// <param name="location">
        /// <para>
        /// Specifies the location of the uniform value to
        /// be modified.
        /// </para>
        /// </param>
        /// <param name="count">
        /// <para>
        /// Specifies the number of matrices that are to
        /// be modified. This should be 1 if the targeted
        /// uniform variable is not an array of matrices, and 1 or more if it is
        /// an array of matrices.
        /// </para>
        /// </param>
        /// <param name="transpose">
        /// <para>
        /// Specifies whether to transpose the matrix as
        /// the values are loaded into the uniform
        /// variable.
        /// </para>
        /// </param>
        /// <param name="value">
        /// <para>
        /// Specifies a pointer to an array of
        /// <paramref name="count"/> values that will be
        /// used to update the specified uniform
        /// variable.
        /// </para>
        /// </param>
        /// <seealso cref="LinkProgram"/>
        /// <seealso cref="UseProgram"/>
        public unsafe static void UniformMatrix2x4fv(int location, int count, bool transpose, ref float value) {
            fixed (float* pValue = &value) {
                GLNative.glUniformMatrix2x4fv(location, count, transpose, pValue);
            }
        }

        /// <summary>
        /// Specify the value of a uniform variable for the current program object
        /// <para>Require:</para> <para>GL_VERSION_2_1, GL_ES_VERSION_3_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glUniform"/> is available only if the GL
        /// version is 2.0 or greater. 
        /// <see cref="glUniformMatrix{2x3|3x2|2x4|4x2|3x4|4x3}fv"/> 
        /// is available only if the GL version is 2.1 or greater. 
        /// <see cref="glUniform1i"/> and
        /// <see cref="glUniform1iv"/> are the only two functions
        /// that may be used to load uniform variables defined as sampler
        /// types. Loading samplers with any other function will result in a
        /// <code>GL_INVALID_OPERATION</code> error. 
        /// If <paramref name="count"/> is greater than 1 and the
        /// indicated uniform variable is not an array, a
        /// <code>GL_INVALID_OPERATION</code> error is generated and the
        /// specified uniform variable will remain unchanged. 
        /// Other than the preceding exceptions, if the type and size
        /// of the uniform variable as defined in the shader do not match
        /// the type and size specified in the name of the command used to
        /// load its value, a <code>GL_INVALID_OPERATION</code> error will
        /// be generated and the specified uniform variable will remain
        /// unchanged. 
        /// If <paramref name="location"/> is a value other than
        /// -1 and it does not represent a valid uniform variable location
        /// in the current program object, an error will be generated, and
        /// no changes will be made to the uniform variable storage of the
        /// current program object. If <paramref name="location"/> is
        /// equal to -1, the data passed in will be silently ignored and the
        /// specified uniform variable will not be changed.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if there
        /// is no current program object. 
        /// <code>GL_INVALID_OPERATION</code> is generated if the
        /// size of the uniform variable declared in the shader does not
        /// match the size indicated by the <see cref="glUniform"/>
        /// command. 
        /// <code>GL_INVALID_OPERATION</code> is generated if one of
        /// the integer variants of this function is used to load a uniform
        /// variable of type float, vec2, vec3, vec4, or an array of these,
        /// or if one of the floating-point variants of this function is
        /// used to load a uniform variable of type int, ivec2, ivec3, or
        /// ivec4, or an array of these. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <paramref name="location"/> is an invalid uniform location
        /// for the current program object and
        /// <paramref name="location"/> is not equal to -1. 
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="count"/> is less than 0. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <paramref name="count"/> is greater than 1 and the indicated
        /// uniform variable is not an array variable. 
        /// <code>GL_INVALID_OPERATION</code> is generated if a
        /// sampler is loaded using a command other than
        /// <see cref="glUniform1i"/> and
        /// <see cref="glUniform1iv"/>. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <see cref="glUniform"/> is executed between the execution
        /// of
        /// <see cref="glBegin"/> 
        /// and the corresponding execution of
        /// <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glUniformMatrix4x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);</para>
        /// </summary>
        /// <param name="location">
        /// <para>
        /// Specifies the location of the uniform value to
        /// be modified.
        /// </para>
        /// </param>
        /// <param name="count">
        /// <para>
        /// Specifies the number of matrices that are to
        /// be modified. This should be 1 if the targeted
        /// uniform variable is not an array of matrices, and 1 or more if it is
        /// an array of matrices.
        /// </para>
        /// </param>
        /// <param name="transpose">
        /// <para>
        /// Specifies whether to transpose the matrix as
        /// the values are loaded into the uniform
        /// variable.
        /// </para>
        /// </param>
        /// <param name="value">
        /// <para>
        /// Specifies a pointer to an array of
        /// <paramref name="count"/> values that will be
        /// used to update the specified uniform
        /// variable.
        /// </para>
        /// </param>
        /// <seealso cref="LinkProgram"/>
        /// <seealso cref="UseProgram"/>
        public unsafe static void UniformMatrix4x2fv(int location, int count, bool transpose, ref float value) {
            fixed (float* pValue = &value) {
                GLNative.glUniformMatrix4x2fv(location, count, transpose, pValue);
            }
        }

        /// <summary>
        /// Specify the value of a uniform variable for the current program object
        /// <para>Require:</para> <para>GL_VERSION_2_1, GL_ES_VERSION_3_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glUniform"/> is available only if the GL
        /// version is 2.0 or greater. 
        /// <see cref="glUniformMatrix{2x3|3x2|2x4|4x2|3x4|4x3}fv"/> 
        /// is available only if the GL version is 2.1 or greater. 
        /// <see cref="glUniform1i"/> and
        /// <see cref="glUniform1iv"/> are the only two functions
        /// that may be used to load uniform variables defined as sampler
        /// types. Loading samplers with any other function will result in a
        /// <code>GL_INVALID_OPERATION</code> error. 
        /// If <paramref name="count"/> is greater than 1 and the
        /// indicated uniform variable is not an array, a
        /// <code>GL_INVALID_OPERATION</code> error is generated and the
        /// specified uniform variable will remain unchanged. 
        /// Other than the preceding exceptions, if the type and size
        /// of the uniform variable as defined in the shader do not match
        /// the type and size specified in the name of the command used to
        /// load its value, a <code>GL_INVALID_OPERATION</code> error will
        /// be generated and the specified uniform variable will remain
        /// unchanged. 
        /// If <paramref name="location"/> is a value other than
        /// -1 and it does not represent a valid uniform variable location
        /// in the current program object, an error will be generated, and
        /// no changes will be made to the uniform variable storage of the
        /// current program object. If <paramref name="location"/> is
        /// equal to -1, the data passed in will be silently ignored and the
        /// specified uniform variable will not be changed.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if there
        /// is no current program object. 
        /// <code>GL_INVALID_OPERATION</code> is generated if the
        /// size of the uniform variable declared in the shader does not
        /// match the size indicated by the <see cref="glUniform"/>
        /// command. 
        /// <code>GL_INVALID_OPERATION</code> is generated if one of
        /// the integer variants of this function is used to load a uniform
        /// variable of type float, vec2, vec3, vec4, or an array of these,
        /// or if one of the floating-point variants of this function is
        /// used to load a uniform variable of type int, ivec2, ivec3, or
        /// ivec4, or an array of these. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <paramref name="location"/> is an invalid uniform location
        /// for the current program object and
        /// <paramref name="location"/> is not equal to -1. 
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="count"/> is less than 0. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <paramref name="count"/> is greater than 1 and the indicated
        /// uniform variable is not an array variable. 
        /// <code>GL_INVALID_OPERATION</code> is generated if a
        /// sampler is loaded using a command other than
        /// <see cref="glUniform1i"/> and
        /// <see cref="glUniform1iv"/>. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <see cref="glUniform"/> is executed between the execution
        /// of
        /// <see cref="glBegin"/> 
        /// and the corresponding execution of
        /// <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glUniformMatrix3x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);</para>
        /// </summary>
        /// <param name="location">
        /// <para>
        /// Specifies the location of the uniform value to
        /// be modified.
        /// </para>
        /// </param>
        /// <param name="count">
        /// <para>
        /// Specifies the number of matrices that are to
        /// be modified. This should be 1 if the targeted
        /// uniform variable is not an array of matrices, and 1 or more if it is
        /// an array of matrices.
        /// </para>
        /// </param>
        /// <param name="transpose">
        /// <para>
        /// Specifies whether to transpose the matrix as
        /// the values are loaded into the uniform
        /// variable.
        /// </para>
        /// </param>
        /// <param name="value">
        /// <para>
        /// Specifies a pointer to an array of
        /// <paramref name="count"/> values that will be
        /// used to update the specified uniform
        /// variable.
        /// </para>
        /// </param>
        /// <seealso cref="LinkProgram"/>
        /// <seealso cref="UseProgram"/>
        public unsafe static void UniformMatrix3x4fv(int location, int count, bool transpose, ref float value) {
            fixed (float* pValue = &value) {
                GLNative.glUniformMatrix3x4fv(location, count, transpose, pValue);
            }
        }

        /// <summary>
        /// Specify the value of a uniform variable for the current program object
        /// <para>Require:</para> <para>GL_VERSION_2_1, GL_ES_VERSION_3_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glUniform"/> is available only if the GL
        /// version is 2.0 or greater. 
        /// <see cref="glUniformMatrix{2x3|3x2|2x4|4x2|3x4|4x3}fv"/> 
        /// is available only if the GL version is 2.1 or greater. 
        /// <see cref="glUniform1i"/> and
        /// <see cref="glUniform1iv"/> are the only two functions
        /// that may be used to load uniform variables defined as sampler
        /// types. Loading samplers with any other function will result in a
        /// <code>GL_INVALID_OPERATION</code> error. 
        /// If <paramref name="count"/> is greater than 1 and the
        /// indicated uniform variable is not an array, a
        /// <code>GL_INVALID_OPERATION</code> error is generated and the
        /// specified uniform variable will remain unchanged. 
        /// Other than the preceding exceptions, if the type and size
        /// of the uniform variable as defined in the shader do not match
        /// the type and size specified in the name of the command used to
        /// load its value, a <code>GL_INVALID_OPERATION</code> error will
        /// be generated and the specified uniform variable will remain
        /// unchanged. 
        /// If <paramref name="location"/> is a value other than
        /// -1 and it does not represent a valid uniform variable location
        /// in the current program object, an error will be generated, and
        /// no changes will be made to the uniform variable storage of the
        /// current program object. If <paramref name="location"/> is
        /// equal to -1, the data passed in will be silently ignored and the
        /// specified uniform variable will not be changed.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if there
        /// is no current program object. 
        /// <code>GL_INVALID_OPERATION</code> is generated if the
        /// size of the uniform variable declared in the shader does not
        /// match the size indicated by the <see cref="glUniform"/>
        /// command. 
        /// <code>GL_INVALID_OPERATION</code> is generated if one of
        /// the integer variants of this function is used to load a uniform
        /// variable of type float, vec2, vec3, vec4, or an array of these,
        /// or if one of the floating-point variants of this function is
        /// used to load a uniform variable of type int, ivec2, ivec3, or
        /// ivec4, or an array of these. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <paramref name="location"/> is an invalid uniform location
        /// for the current program object and
        /// <paramref name="location"/> is not equal to -1. 
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="count"/> is less than 0. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <paramref name="count"/> is greater than 1 and the indicated
        /// uniform variable is not an array variable. 
        /// <code>GL_INVALID_OPERATION</code> is generated if a
        /// sampler is loaded using a command other than
        /// <see cref="glUniform1i"/> and
        /// <see cref="glUniform1iv"/>. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <see cref="glUniform"/> is executed between the execution
        /// of
        /// <see cref="glBegin"/> 
        /// and the corresponding execution of
        /// <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glUniformMatrix4x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);</para>
        /// </summary>
        /// <param name="location">
        /// <para>
        /// Specifies the location of the uniform value to
        /// be modified.
        /// </para>
        /// </param>
        /// <param name="count">
        /// <para>
        /// Specifies the number of matrices that are to
        /// be modified. This should be 1 if the targeted
        /// uniform variable is not an array of matrices, and 1 or more if it is
        /// an array of matrices.
        /// </para>
        /// </param>
        /// <param name="transpose">
        /// <para>
        /// Specifies whether to transpose the matrix as
        /// the values are loaded into the uniform
        /// variable.
        /// </para>
        /// </param>
        /// <param name="value">
        /// <para>
        /// Specifies a pointer to an array of
        /// <paramref name="count"/> values that will be
        /// used to update the specified uniform
        /// variable.
        /// </para>
        /// </param>
        /// <seealso cref="LinkProgram"/>
        /// <seealso cref="UseProgram"/>
        public unsafe static void UniformMatrix4x3fv(int location, int count, bool transpose, ref float value) {
            fixed (float* pValue = &value) {
                GLNative.glUniformMatrix4x3fv(location, count, transpose, pValue);
            }
        }


        #endregion GL_VERSION_2_1

        #region GL_VERSION_3_0

        /// <summary>
        /// return the value or values of a selected parameter
        /// <para>Require:</para> <para>GL_VERSION_3_0, GL_ES_VERSION_3_1</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glGetBooleani_v(GLenum target, GLuint index, GLboolean * data);</para>
        /// </summary>
        public unsafe static void GetBooleani_v(uint target, uint index, ref bool data) {
            fixed (bool* pData = &data) {
                GLNative.glGetBooleani_v(target, index, pData);
            }
        }

        /// <summary>
        /// return the value or values of a selected parameter
        /// <para>Require:</para> <para>GL_VERSION_3_0, GL_VERSION_3_1, GL_ES_VERSION_3_0, GL_ARB_uniform_buffer_object</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetIntegeri_v(GLenum target, GLuint index, GLint * data);</para>
        /// </summary>
        public unsafe static void GetIntegeri_v(uint target, uint index, ref int data) {
            fixed (int* pData = &data) {
                GLNative.glGetIntegeri_v(target, index, pData);
            }
        }

        /// <summary>
        /// specify values to record in transform feedback buffers
        /// <para>Require:</para> <para>GL_VERSION_3_0, GL_ES_VERSION_3_0</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glTransformFeedbackVaryings(GLuint program, GLsizei count, const char ** varyings, GLenum bufferMode);</para>
        /// </summary>
        public unsafe static void TransformFeedbackVaryings(uint program, int count, IntPtr varyings, uint bufferMode) {
            GLNative.glTransformFeedbackVaryings(program, count, (byte**)varyings, bufferMode);
        }

        /// <summary>
        /// retrieve information about varying variables selected for transform feedback
        /// <para>Require:</para> <para>GL_VERSION_3_0, GL_ES_VERSION_3_0</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glGetTransformFeedbackVarying(GLuint program, GLuint index, GLsizei bufSize, GLsizei * length, GLsizei * size, GLenum * type, char * name);</para>
        /// </summary>
        public unsafe static void GetTransformFeedbackVarying(uint program, uint index, int bufSize, ref int length, ref int size, ref uint type, ref byte name) {
            fixed (int* pLength = &length)
            fixed (int* pSize = &size)
            fixed (uint* pType = &type)
            fixed (byte* pName = &name) {
                GLNative.glGetTransformFeedbackVarying(program, index, bufSize, pLength, pSize, pType, pName);
            }
        }

        /// <summary>
        /// define an array of generic vertex attribute data
        /// <para>Require:</para> <para>GL_VERSION_3_0, GL_ES_VERSION_3_0</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glVertexAttribIPointer(GLuint index, GLint size, GLenum type, GLsizei stride, const void * pointer);</para>
        /// </summary>
        public unsafe static void VertexAttribIPointer(uint index, int size, uint type, int stride, IntPtr pointer) {
            GLNative.glVertexAttribIPointer(index, size, type, stride, (void*)pointer);
        }

        /// <summary>
        /// Return a generic vertex attribute parameter
        /// <para>Require:</para> <para>GL_VERSION_3_0, GL_ES_VERSION_3_0</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glGetVertexAttribIiv(GLuint index, GLenum pname, GLint * params);</para>
        /// </summary>
        public unsafe static void GetVertexAttribIiv(uint index, uint pname, ref int ps) {
            fixed (int* pPs = &ps) {
                GLNative.glGetVertexAttribIiv(index, pname, pPs);
            }
        }

        /// <summary>
        /// Return a generic vertex attribute parameter
        /// <para>Require:</para> <para>GL_VERSION_3_0, GL_ES_VERSION_3_0</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glGetVertexAttribIuiv(GLuint index, GLenum pname, GLuint * params);</para>
        /// </summary>
        public unsafe static void GetVertexAttribIuiv(uint index, uint pname, ref uint ps) {
            fixed (uint* pPs = &ps) {
                GLNative.glGetVertexAttribIuiv(index, pname, pPs);
            }
        }

        /// <summary>
        /// Specifies the value of a generic vertex attribute
        /// <para>Require:</para> <para>GL_VERSION_3_0</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glVertexAttribI1iv(GLuint index, const GLint * v);</para>
        /// </summary>
        public unsafe static void VertexAttribI1iv(uint index, ref int v) {
            fixed (int* pV = &v) {
                GLNative.glVertexAttribI1iv(index, pV);
            }
        }

        /// <summary>
        /// Specifies the value of a generic vertex attribute
        /// <para>Require:</para> <para>GL_VERSION_3_0</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glVertexAttribI2iv(GLuint index, const GLint * v);</para>
        /// </summary>
        public unsafe static void VertexAttribI2iv(uint index, ref int v) {
            fixed (int* pV = &v) {
                GLNative.glVertexAttribI2iv(index, pV);
            }
        }

        /// <summary>
        /// Specifies the value of a generic vertex attribute
        /// <para>Require:</para> <para>GL_VERSION_3_0</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glVertexAttribI3iv(GLuint index, const GLint * v);</para>
        /// </summary>
        public unsafe static void VertexAttribI3iv(uint index, ref int v) {
            fixed (int* pV = &v) {
                GLNative.glVertexAttribI3iv(index, pV);
            }
        }

        /// <summary>
        /// Specifies the value of a generic vertex attribute
        /// <para>Require:</para> <para>GL_VERSION_3_0, GL_ES_VERSION_3_0</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glVertexAttribI4iv(GLuint index, const GLint * v);</para>
        /// </summary>
        public unsafe static void VertexAttribI4iv(uint index, ref int v) {
            fixed (int* pV = &v) {
                GLNative.glVertexAttribI4iv(index, pV);
            }
        }

        /// <summary>
        /// Specifies the value of a generic vertex attribute
        /// <para>Require:</para> <para>GL_VERSION_3_0</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glVertexAttribI1uiv(GLuint index, const GLuint * v);</para>
        /// </summary>
        public unsafe static void VertexAttribI1uiv(uint index, ref uint v) {
            fixed (uint* pV = &v) {
                GLNative.glVertexAttribI1uiv(index, pV);
            }
        }

        /// <summary>
        /// Specifies the value of a generic vertex attribute
        /// <para>Require:</para> <para>GL_VERSION_3_0</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glVertexAttribI2uiv(GLuint index, const GLuint * v);</para>
        /// </summary>
        public unsafe static void VertexAttribI2uiv(uint index, ref uint v) {
            fixed (uint* pV = &v) {
                GLNative.glVertexAttribI2uiv(index, pV);
            }
        }

        /// <summary>
        /// Specifies the value of a generic vertex attribute
        /// <para>Require:</para> <para>GL_VERSION_3_0</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glVertexAttribI3uiv(GLuint index, const GLuint * v);</para>
        /// </summary>
        public unsafe static void VertexAttribI3uiv(uint index, ref uint v) {
            fixed (uint* pV = &v) {
                GLNative.glVertexAttribI3uiv(index, pV);
            }
        }

        /// <summary>
        /// Specifies the value of a generic vertex attribute
        /// <para>Require:</para> <para>GL_VERSION_3_0, GL_ES_VERSION_3_0</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glVertexAttribI4uiv(GLuint index, const GLuint * v);</para>
        /// </summary>
        public unsafe static void VertexAttribI4uiv(uint index, ref uint v) {
            fixed (uint* pV = &v) {
                GLNative.glVertexAttribI4uiv(index, pV);
            }
        }

        /// <summary>
        /// Specifies the value of a generic vertex attribute
        /// <para>Require:</para> <para>GL_VERSION_3_0</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glVertexAttribI4bv(GLuint index, const GLbyte * v);</para>
        /// </summary>
        public unsafe static void VertexAttribI4bv(uint index, ref byte v) {
            fixed (byte* pV = &v) {
                GLNative.glVertexAttribI4bv(index, pV);
            }
        }

        /// <summary>
        /// Specifies the value of a generic vertex attribute
        /// <para>Require:</para> <para>GL_VERSION_3_0</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glVertexAttribI4sv(GLuint index, const GLshort * v);</para>
        /// </summary>
        public unsafe static void VertexAttribI4sv(uint index, ref short v) {
            fixed (short* pV = &v) {
                GLNative.glVertexAttribI4sv(index, pV);
            }
        }

        /// <summary>
        /// Specifies the value of a generic vertex attribute
        /// <para>Require:</para> <para>GL_VERSION_3_0</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glVertexAttribI4ubv(GLuint index, const GLubyte * v);</para>
        /// </summary>
        public unsafe static void VertexAttribI4ubv(uint index, ref byte v) {
            fixed (byte* pV = &v) {
                GLNative.glVertexAttribI4ubv(index, pV);
            }
        }

        /// <summary>
        /// Specifies the value of a generic vertex attribute
        /// <para>Require:</para> <para>GL_VERSION_3_0</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glVertexAttribI4usv(GLuint index, const GLushort * v);</para>
        /// </summary>
        public unsafe static void VertexAttribI4usv(uint index, ref ushort v) {
            fixed (ushort* pV = &v) {
                GLNative.glVertexAttribI4usv(index, pV);
            }
        }

        /// <summary>
        /// Returns the value of a uniform variable
        /// <para>Require:</para> <para>GL_VERSION_3_0, GL_ES_VERSION_3_0</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glGetUniformuiv(GLuint program, GLint location, GLuint * params);</para>
        /// </summary>
        public unsafe static void GetUniformuiv(uint program, int location, ref uint ps) {
            fixed (uint* pPs = &ps) {
                GLNative.glGetUniformuiv(program, location, pPs);
            }
        }

        /// <summary>
        /// bind a user-defined varying out variable to a fragment shader color number
        /// <para>Require:</para> <para>GL_VERSION_3_0</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glBindFragDataLocation(GLuint program, GLuint colorNumber, const char * name);</para>
        /// </summary>
        public unsafe static void BindFragDataLocation(uint program, uint colorNumber, ref byte name) {
            fixed (byte* pName = &name) {
                GLNative.glBindFragDataLocation(program, colorNumber, pName);
            }
        }

        /// <summary>
        /// query the bindings of color numbers to user-defined varying out variables
        /// <para>Require:</para> <para>GL_VERSION_3_0, GL_ES_VERSION_3_0</para>
        /// Supported: <para>GL</para>
        /// Original: <para>GLint glGetFragDataLocation(GLuint program, const char * name);</para>
        /// </summary>
        public unsafe static int GetFragDataLocation(uint program, ref byte name) {
            fixed (byte* pName = &name) {
                return GLNative.glGetFragDataLocation(program, pName);
            }
        }

        /// <summary>
        /// Specify the value of a uniform variable for the current program object
        /// <para>Require:</para> <para>GL_VERSION_3_0, GL_ES_VERSION_3_0</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glUniform1uiv(GLint location, GLsizei count, const GLuint * value);</para>
        /// </summary>
        public unsafe static void Uniform1uiv(int location, int count, ref uint value) {
            fixed (uint* pValue = &value) {
                GLNative.glUniform1uiv(location, count, pValue);
            }
        }

        /// <summary>
        /// Specify the value of a uniform variable for the current program object
        /// <para>Require:</para> <para>GL_VERSION_3_0, GL_ES_VERSION_3_0</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glUniform2uiv(GLint location, GLsizei count, const GLuint * value);</para>
        /// </summary>
        public unsafe static void Uniform2uiv(int location, int count, ref uint value) {
            fixed (uint* pValue = &value) {
                GLNative.glUniform2uiv(location, count, pValue);
            }
        }

        /// <summary>
        /// Specify the value of a uniform variable for the current program object
        /// <para>Require:</para> <para>GL_VERSION_3_0, GL_ES_VERSION_3_0</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glUniform3uiv(GLint location, GLsizei count, const GLuint * value);</para>
        /// </summary>
        public unsafe static void Uniform3uiv(int location, int count, ref uint value) {
            fixed (uint* pValue = &value) {
                GLNative.glUniform3uiv(location, count, pValue);
            }
        }

        /// <summary>
        /// Specify the value of a uniform variable for the current program object
        /// <para>Require:</para> <para>GL_VERSION_3_0, GL_ES_VERSION_3_0</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glUniform4uiv(GLint location, GLsizei count, const GLuint * value);</para>
        /// </summary>
        public unsafe static void Uniform4uiv(int location, int count, ref uint value) {
            fixed (uint* pValue = &value) {
                GLNative.glUniform4uiv(location, count, pValue);
            }
        }

        /// <summary>
        /// set texture parameters
        /// <para>Require:</para> <para>GL_VERSION_3_0, GL_ES_VERSION_3_2</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glTexParameterIiv(GLenum target, GLenum pname, const GLint * params);</para>
        /// </summary>
        public unsafe static void TexParameterIiv(uint target, uint pname, ref int ps) {
            fixed (int* pPs = &ps) {
                GLNative.glTexParameterIiv(target, pname, pPs);
            }
        }

        /// <summary>
        /// set texture parameters
        /// <para>Require:</para> <para>GL_VERSION_3_0, GL_ES_VERSION_3_2</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glTexParameterIuiv(GLenum target, GLenum pname, const GLuint * params);</para>
        /// </summary>
        public unsafe static void TexParameterIuiv(uint target, uint pname, ref uint ps) {
            fixed (uint* pPs = &ps) {
                GLNative.glTexParameterIuiv(target, pname, pPs);
            }
        }

        /// <summary>
        /// return texture parameter values
        /// <para>Require:</para> <para>GL_VERSION_3_0, GL_ES_VERSION_3_2</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glGetTexParameterIiv(GLenum target, GLenum pname, GLint * params);</para>
        /// </summary>
        public unsafe static void GetTexParameterIiv(uint target, uint pname, ref int ps) {
            fixed (int* pPs = &ps) {
                GLNative.glGetTexParameterIiv(target, pname, pPs);
            }
        }

        /// <summary>
        /// return texture parameter values
        /// <para>Require:</para> <para>GL_VERSION_3_0, GL_ES_VERSION_3_2</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glGetTexParameterIuiv(GLenum target, GLenum pname, GLuint * params);</para>
        /// </summary>
        public unsafe static void GetTexParameterIuiv(uint target, uint pname, ref uint ps) {
            fixed (uint* pPs = &ps) {
                GLNative.glGetTexParameterIuiv(target, pname, pPs);
            }
        }

        /// <summary>
        /// clear individual buffers of a framebuffer
        /// <para>Require:</para> <para>GL_VERSION_3_0, GL_ES_VERSION_3_0</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glClearBufferiv(GLenum buffer, GLint drawbuffer, const GLint * value);</para>
        /// </summary>
        public unsafe static void ClearBufferiv(uint buffer, int drawbuffer, ref int value) {
            fixed (int* pValue = &value) {
                GLNative.glClearBufferiv(buffer, drawbuffer, pValue);
            }
        }

        /// <summary>
        /// clear individual buffers of a framebuffer
        /// <para>Require:</para> <para>GL_VERSION_3_0, GL_ES_VERSION_3_0</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glClearBufferuiv(GLenum buffer, GLint drawbuffer, const GLuint * value);</para>
        /// </summary>
        public unsafe static void ClearBufferuiv(uint buffer, int drawbuffer, ref uint value) {
            fixed (uint* pValue = &value) {
                GLNative.glClearBufferuiv(buffer, drawbuffer, pValue);
            }
        }

        /// <summary>
        /// clear individual buffers of a framebuffer
        /// <para>Require:</para> <para>GL_VERSION_3_0, GL_ES_VERSION_3_0</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glClearBufferfv(GLenum buffer, GLint drawbuffer, const GLfloat * value);</para>
        /// </summary>
        public unsafe static void ClearBufferfv(uint buffer, int drawbuffer, ref float value) {
            fixed (float* pValue = &value) {
                GLNative.glClearBufferfv(buffer, drawbuffer, pValue);
            }
        }

        /// <summary>
        /// return a string describing the current GL connection
        /// <para>Require:</para> <para>GL_VERSION_3_0, GL_ES_VERSION_3_0</para>
        /// Supported: <para>GL</para>
        /// Original: <para>const GLubyte * glGetStringi(GLenum name, GLuint index);</para>
        /// </summary>
        public unsafe static string GetStringi(uint name, uint index) {
            var ptr = GLNative.glGetStringi(name, index);
            if (ptr == null) return null;
            return MarshalExtend.PtrToString(ptr);
        }


        #region Reuse ARB_framebuffer_object

        /// <summary>
        /// delete renderbuffer objects
        /// <para>Require:</para> <para>GL_VERSION_3_0, GL_ES_VERSION_2_0, GL_ARB_framebuffer_object</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glDeleteRenderbuffers(GLsizei n, GLuint * renderbuffers);</para>
        /// </summary>
        public unsafe static void DeleteRenderbuffers(int n, ref uint renderbuffers) {
            fixed (uint* pRenderbuffers = &renderbuffers) {
                GLNative.glDeleteRenderbuffers(n, pRenderbuffers);
            }
        }

        /// <summary>
        /// generate renderbuffer object names
        /// <para>Require:</para> <para>GL_VERSION_3_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0, GL_ARB_framebuffer_object</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGenRenderbuffers(GLsizei n, GLuint * renderbuffers);</para>
        /// </summary>
        public unsafe static void GenRenderbuffers(int n, ref uint renderbuffers) {
            fixed (uint* pRenderbuffers = &renderbuffers) {
                GLNative.glGenRenderbuffers(n, pRenderbuffers);
            }
        }

        /// <summary>
        /// query a named parameter of a renderbuffer object
        /// <para>Require:</para> <para>GL_VERSION_3_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0, GL_ARB_framebuffer_object</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetRenderbufferParameteriv(GLenum target, GLenum pname, GLint * params);</para>
        /// </summary>
        public unsafe static void GetRenderbufferParameteriv(uint target, uint pname, ref int ps) {
            fixed (int* pPs = &ps) {
                GLNative.glGetRenderbufferParameteriv(target, pname, pPs);
            }
        }

        /// <summary>
        /// delete framebuffer objects
        /// <para>Require:</para> <para>GL_VERSION_3_0, GL_ES_VERSION_2_0, GL_ARB_framebuffer_object</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glDeleteFramebuffers(GLsizei n, GLuint * framebuffers);</para>
        /// </summary>
        public unsafe static void DeleteFramebuffers(int n, ref uint framebuffers) {
            fixed (uint* pFramebuffers = &framebuffers) {
                GLNative.glDeleteFramebuffers(n, pFramebuffers);
            }
        }

        /// <summary>
        /// generate framebuffer object names
        /// <para>Require:</para> <para>GL_VERSION_3_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0, GL_ARB_framebuffer_object</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGenFramebuffers(GLsizei n, GLuint * ids);</para>
        /// </summary>
        public unsafe static void GenFramebuffers(int n, ref uint ids) {
            fixed (uint* pIds = &ids) {
                GLNative.glGenFramebuffers(n, pIds);
            }
        }

        /// <summary>
        /// retrieve information about attachments of a framebuffer object
        /// <para>Require:</para> <para>GL_VERSION_3_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0, GL_ARB_framebuffer_object</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetFramebufferAttachmentParameteriv(GLenum target, GLenum attachment, GLenum pname, GLint * params);</para>
        /// </summary>
        public unsafe static void GetFramebufferAttachmentParameteriv(uint target, uint attachment, uint pname, ref int ps) {
            fixed (int* pPs = &ps) {
                GLNative.glGetFramebufferAttachmentParameteriv(target, attachment, pname, pPs);
            }
        }


        #endregion Reuse ARB_framebuffer_object

        #region Reuse ARB_map_buffer_range

        /// <summary>
        /// map all or part of a buffer object's data store into the client's address space
        /// <para>Require:</para> <para>GL_VERSION_3_0, GL_ES_VERSION_3_0, GL_ARB_map_buffer_range</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void * glMapBufferRange(GLenum target, GLintptr offset, GLsizeiptr length, GLbitfield access);</para>
        /// </summary>
        public unsafe static IntPtr MapBufferRange(uint target, IntPtr offset, IntPtr length, uint access) {
            return (IntPtr)GLNative.glMapBufferRange(target, offset, length, access);
        }


        #endregion Reuse ARB_map_buffer_range

        #region Reuse ARB_vertex_array_object

        /// <summary>
        /// delete vertex array objects
        /// <para>Require:</para> <para>GL_VERSION_3_0, GL_ES_VERSION_3_0, GL_ARB_vertex_array_object</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glDeleteVertexArrays(GLsizei n, const GLuint * arrays);</para>
        /// </summary>
        public unsafe static void DeleteVertexArrays(int n, ref uint arrays) {
            fixed (uint* pArrays = &arrays) {
                GLNative.glDeleteVertexArrays(n, pArrays);
            }
        }

        /// <summary>
        /// generate vertex array object names
        /// <para>Require:</para> <para>GL_VERSION_3_0, GL_ES_VERSION_3_0, GL_ARB_vertex_array_object</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGenVertexArrays(GLsizei n, GLuint * arrays);</para>
        /// </summary>
        public unsafe static void GenVertexArrays(int n, ref uint arrays) {
            fixed (uint* pArrays = &arrays) {
                GLNative.glGenVertexArrays(n, pArrays);
            }
        }


        #endregion Reuse ARB_vertex_array_object

        #endregion GL_VERSION_3_0

        #region GL_VERSION_3_1

        /// <summary>
        /// draw multiple instances of a set of elements
        /// <para>Require:</para> <para>GL_VERSION_3_1, GL_ES_VERSION_3_0</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glDrawElementsInstanced(GLenum mode, GLsizei count, GLenum type, const void * indices, GLsizei instancecount);</para>
        /// </summary>
        public unsafe static void DrawElementsInstanced(uint mode, int count, uint type, IntPtr indices, int instancecount) {
            GLNative.glDrawElementsInstanced(mode, count, type, (void*)indices, instancecount);
        }


        #region Reuse ARB_copy_buffer


        #endregion Reuse ARB_copy_buffer

        #region Reuse ARB_uniform_buffer_object

        /// <summary>
        /// retrieve the index of a named uniform block
        /// <para>Require:</para> <para>GL_VERSION_3_1, GL_ES_VERSION_3_0, GL_ARB_uniform_buffer_object</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetUniformIndices(GLuint program, GLsizei uniformCount, const GLchar ** uniformNames, GLuint * uniformIndices);</para>
        /// </summary>
        public unsafe static void GetUniformIndices(uint program, int uniformCount, IntPtr uniformNames, ref uint uniformIndices) {
            fixed (uint* pUniformIndices = &uniformIndices) {
                GLNative.glGetUniformIndices(program, uniformCount, (byte**)uniformNames, pUniformIndices);
            }
        }

        /// <summary>
        /// Returns information about several active uniform variables for the specified program object
        /// <para>Require:</para> <para>GL_VERSION_3_1, GL_ES_VERSION_3_0, GL_ARB_uniform_buffer_object</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetActiveUniformsiv(GLuint program, GLsizei uniformCount, const GLuint * uniformIndices, GLenum pname, GLint * params);</para>
        /// </summary>
        public unsafe static void GetActiveUniformsiv(uint program, int uniformCount, ref uint uniformIndices, uint pname, ref int ps) {
            fixed (uint* pUniformIndices = &uniformIndices)
            fixed (int* pPs = &ps) {
                GLNative.glGetActiveUniformsiv(program, uniformCount, pUniformIndices, pname, pPs);
            }
        }

        /// <summary>
        /// query the name of an active uniform
        /// <para>Require:</para> <para>GL_VERSION_3_1, GL_ARB_uniform_buffer_object</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetActiveUniformName(GLuint program, GLuint uniformIndex, GLsizei bufSize, GLsizei * length, GLchar * uniformName);</para>
        /// </summary>
        public unsafe static void GetActiveUniformName(uint program, uint uniformIndex, int bufSize, ref int length, ref byte uniformName) {
            fixed (int* pLength = &length)
            fixed (byte* pUniformName = &uniformName) {
                GLNative.glGetActiveUniformName(program, uniformIndex, bufSize, pLength, pUniformName);
            }
        }

        /// <summary>
        /// retrieve the index of a named uniform block
        /// <para>Require:</para> <para>GL_VERSION_3_1, GL_ES_VERSION_3_0, GL_ARB_uniform_buffer_object</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>GLuint glGetUniformBlockIndex(GLuint program, const GLchar * uniformBlockName);</para>
        /// </summary>
        public unsafe static uint GetUniformBlockIndex(uint program, ref byte uniformBlockName) {
            fixed (byte* pUniformBlockName = &uniformBlockName) {
                return GLNative.glGetUniformBlockIndex(program, pUniformBlockName);
            }
        }

        /// <summary>
        /// query information about an active uniform block
        /// <para>Require:</para> <para>GL_VERSION_3_1, GL_ES_VERSION_3_0, GL_ARB_uniform_buffer_object</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetActiveUniformBlockiv(GLuint program, GLuint uniformBlockIndex, GLenum pname, GLint * params);</para>
        /// </summary>
        public unsafe static void GetActiveUniformBlockiv(uint program, uint uniformBlockIndex, uint pname, ref int ps) {
            fixed (int* pPs = &ps) {
                GLNative.glGetActiveUniformBlockiv(program, uniformBlockIndex, pname, pPs);
            }
        }

        /// <summary>
        /// retrieve the name of an active uniform block
        /// <para>Require:</para> <para>GL_VERSION_3_1, GL_ES_VERSION_3_0, GL_ARB_uniform_buffer_object</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetActiveUniformBlockName(GLuint program, GLuint uniformBlockIndex, GLsizei bufSize, GLsizei * length, GLchar * uniformBlockName);</para>
        /// </summary>
        public unsafe static void GetActiveUniformBlockName(uint program, uint uniformBlockIndex, int bufSize, ref int length, ref byte uniformBlockName) {
            fixed (int* pLength = &length)
            fixed (byte* pUniformBlockName = &uniformBlockName) {
                GLNative.glGetActiveUniformBlockName(program, uniformBlockIndex, bufSize, pLength, pUniformBlockName);
            }
        }

        // void glGetIntegeri_v(GLenum target, GLuint index, GLint * data);

        #endregion Reuse ARB_uniform_buffer_object

        #endregion GL_VERSION_3_1

        #region GL_VERSION_3_2


        #region Reuse ARB_draw_elements_base_vertex

        /// <summary>
        /// render primitives from array data with a per-element offset
        /// <para>Require:</para> <para>GL_VERSION_3_2, GL_ES_VERSION_3_2, GL_ARB_draw_elements_base_vertex</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glDrawElementsBaseVertex(GLenum mode, GLsizei count, GLenum type, void * indices, GLint basevertex);</para>
        /// </summary>
        public unsafe static void DrawElementsBaseVertex(uint mode, int count, uint type, IntPtr indices, int basevertex) {
            GLNative.glDrawElementsBaseVertex(mode, count, type, (void*)indices, basevertex);
        }

        /// <summary>
        /// render primitives from array data with a per-element offset
        /// <para>Require:</para> <para>GL_VERSION_3_2, GL_ES_VERSION_3_2, GL_ARB_draw_elements_base_vertex</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glDrawRangeElementsBaseVertex(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, void * indices, GLint basevertex);</para>
        /// </summary>
        public unsafe static void DrawRangeElementsBaseVertex(uint mode, uint start, uint end, int count, uint type, IntPtr indices, int basevertex) {
            GLNative.glDrawRangeElementsBaseVertex(mode, start, end, count, type, (void*)indices, basevertex);
        }

        /// <summary>
        /// render multiple instances of a set of primitives from array data with a per-element offset
        /// <para>Require:</para> <para>GL_VERSION_3_2, GL_ES_VERSION_3_2, GL_ARB_draw_elements_base_vertex</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glDrawElementsInstancedBaseVertex(GLenum mode, GLsizei count, GLenum type, void * indices, GLsizei instancecount, GLint basevertex);</para>
        /// </summary>
        public unsafe static void DrawElementsInstancedBaseVertex(uint mode, int count, uint type, IntPtr indices, int instancecount, int basevertex) {
            GLNative.glDrawElementsInstancedBaseVertex(mode, count, type, (void*)indices, instancecount, basevertex);
        }

        /// <summary>
        /// render multiple sets of primitives by specifying indices of array data elements and an index to apply to each index
        /// <para>Require:</para> <para>GL_VERSION_3_2, GL_ARB_draw_elements_base_vertex</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glMultiDrawElementsBaseVertex(GLenum mode, const GLsizei * count, GLenum type, const void * const * indices, GLsizei drawcount, const GLint * basevertex);</para>
        /// </summary>
        public unsafe static void MultiDrawElementsBaseVertex(uint mode, ref int count, uint type, IntPtr indices, int drawcount, ref int basevertex) {
            fixed (int* pCount = &count)
            fixed (int* pBasevertex = &basevertex) {
                GLNative.glMultiDrawElementsBaseVertex(mode, pCount, type, indices, drawcount, pBasevertex);
            }
        }


        #endregion Reuse ARB_draw_elements_base_vertex

        #region Reuse ARB_provoking_vertex


        #endregion Reuse ARB_provoking_vertex

        #region Reuse ARB_sync

        /// <summary>
        /// return the value or values of a selected parameter
        /// <para>Require:</para> <para>GL_VERSION_3_2, GL_ES_VERSION_3_0, GL_ARB_sync</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetInteger64v(GLenum pname, GLint64 * data);</para>
        /// </summary>
        public unsafe static void GetInteger64v(uint pname, ref UInt64 data) {
            fixed (UInt64* pData = &data) {
                GLNative.glGetInteger64v(pname, pData);
            }
        }

        /// <summary>
        /// query the properties of a sync object
        /// <para>Require:</para> <para>GL_VERSION_3_2, GL_ES_VERSION_3_0, GL_ARB_sync</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetSynciv(GLsync sync, GLenum pname, GLsizei bufSize, GLsizei * length, GLint * values);</para>
        /// </summary>
        public unsafe static void GetSynciv(IntPtr sync, uint pname, int bufSize, ref int length, ref int values) {
            fixed (int* pLength = &length)
            fixed (int* pValues = &values) {
                GLNative.glGetSynciv(sync, pname, bufSize, pLength, pValues);
            }
        }


        #endregion Reuse ARB_sync

        #region Reuse ARB_texture_multisample

        /// <summary>
        /// return the value or values of a selected parameter
        /// <para>Require:</para> <para>GL_VERSION_3_2, GL_ES_VERSION_3_0</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glGetInteger64i_v(GLenum target, GLuint index, GLint64 * data);</para>
        /// </summary>
        public unsafe static void GetInteger64i_v(uint target, uint index, ref UInt64 data) {
            fixed (UInt64* pData = &data) {
                GLNative.glGetInteger64i_v(target, index, pData);
            }
        }

        /// <summary>
        /// return parameters of a buffer object
        /// <para>Require:</para> <para>GL_VERSION_3_2, GL_ES_VERSION_3_0</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glGetBufferParameteri64v(GLenum target, GLenum value, GLint64 * data);</para>
        /// </summary>
        public unsafe static void GetBufferParameteri64v(uint target, uint value, ref UInt64 data) {
            fixed (UInt64* pData = &data) {
                GLNative.glGetBufferParameteri64v(target, value, pData);
            }
        }

        /// <summary>
        /// retrieve the location of a sample
        /// <para>Require:</para> <para>GL_VERSION_3_2, GL_ES_VERSION_3_1, GL_ARB_texture_multisample</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetMultisamplefv(GLenum pname, GLuint index, GLfloat * val);</para>
        /// </summary>
        public unsafe static void GetMultisamplefv(uint pname, uint index, ref float val) {
            fixed (float* pVal = &val) {
                GLNative.glGetMultisamplefv(pname, index, pVal);
            }
        }


        #endregion Reuse ARB_texture_multisample

        #region Compatibility-only GL 1.0 features removed from GL 3.2

        // void glCallLists(GLsizei n, GLenum type, const void * lists);
        // void glBitmap(GLsizei width, GLsizei height, GLfloat xorig, GLfloat yorig, GLfloat xmove, GLfloat ymove, const GLubyte * bitmap);
        // void glColor3bv(const GLbyte * v);
        // void glColor3dv(const GLdouble * v);
        // void glColor3fv(const GLfloat * v);
        // void glColor3iv(const GLint * v);
        // void glColor3sv(const GLshort * v);
        // void glColor3ubv(const GLubyte * v);
        // void glColor3uiv(const GLuint * v);
        // void glColor3usv(const GLushort * v);
        // void glColor4bv(const GLbyte * v);
        // void glColor4dv(const GLdouble * v);
        // void glColor4fv(const GLfloat * v);
        // void glColor4iv(const GLint * v);
        // void glColor4sv(const GLshort * v);
        // void glColor4ubv(const GLubyte * v);
        // void glColor4uiv(const GLuint * v);
        // void glColor4usv(const GLushort * v);
        // void glEdgeFlagv(const GLboolean * flag);
        // void glIndexdv(const GLdouble * c);
        // void glIndexfv(const GLfloat * c);
        // void glIndexiv(const GLint * c);
        // void glIndexsv(const GLshort * c);
        // void glNormal3bv(const GLbyte * v);
        // void glNormal3dv(const GLdouble * v);
        // void glNormal3fv(const GLfloat * v);
        // void glNormal3iv(const GLint * v);
        // void glNormal3sv(const GLshort * v);
        // void glRasterPos2dv(const GLdouble * v);
        // void glRasterPos2fv(const GLfloat * v);
        // void glRasterPos2iv(const GLint * v);
        // void glRasterPos2sv(const GLshort * v);
        // void glRasterPos3dv(const GLdouble * v);
        // void glRasterPos3fv(const GLfloat * v);
        // void glRasterPos3iv(const GLint * v);
        // void glRasterPos3sv(const GLshort * v);
        // void glRasterPos4dv(const GLdouble * v);
        // void glRasterPos4fv(const GLfloat * v);
        // void glRasterPos4iv(const GLint * v);
        // void glRasterPos4sv(const GLshort * v);
        // void glRectdv(const GLdouble * v1, const GLdouble * v2);
        // void glRectfv(const GLfloat * v1, const GLfloat * v2);
        // void glRectiv(const GLint * v1, const GLint * v2);
        // void glRectsv(const GLshort * v1, const GLshort * v2);
        // void glTexCoord1dv(const GLdouble * v);
        // void glTexCoord1fv(const GLfloat * v);
        // void glTexCoord1iv(const GLint * v);
        // void glTexCoord1sv(const GLshort * v);
        // void glTexCoord2dv(const GLdouble * v);
        // void glTexCoord2fv(const GLfloat * v);
        // void glTexCoord2iv(const GLint * v);
        // void glTexCoord2sv(const GLshort * v);
        // void glTexCoord3dv(const GLdouble * v);
        // void glTexCoord3fv(const GLfloat * v);
        // void glTexCoord3iv(const GLint * v);
        // void glTexCoord3sv(const GLshort * v);
        // void glTexCoord4dv(const GLdouble * v);
        // void glTexCoord4fv(const GLfloat * v);
        // void glTexCoord4iv(const GLint * v);
        // void glTexCoord4sv(const GLshort * v);
        // void glVertex2dv(const GLdouble * v);
        // void glVertex2fv(const GLfloat * v);
        // void glVertex2iv(const GLint * v);
        // void glVertex2sv(const GLshort * v);
        // void glVertex3dv(const GLdouble * v);
        // void glVertex3fv(const GLfloat * v);
        // void glVertex3iv(const GLint * v);
        // void glVertex3sv(const GLshort * v);
        // void glVertex4dv(const GLdouble * v);
        // void glVertex4fv(const GLfloat * v);
        // void glVertex4iv(const GLint * v);
        // void glVertex4sv(const GLshort * v);
        // void glClipPlane(GLenum plane, const GLdouble * equation);
        // void glFogfv(GLenum pname, const GLfloat * ps);
        // void glFogiv(GLenum pname, const GLint * ps);
        // void glLightfv(GLenum light, GLenum pname, const GLfloat * ps);
        // void glLightiv(GLenum light, GLenum pname, const GLint * ps);
        // void glLightModelfv(GLenum pname, const GLfloat * ps);
        // void glLightModeliv(GLenum pname, const GLint * ps);
        // void glMaterialfv(GLenum face, GLenum pname, const GLfloat * ps);
        // void glMaterialiv(GLenum face, GLenum pname, const GLint * ps);
        // void glPolygonStipple(const GLubyte * pattern);
        // void glTexEnvfv(GLenum target, GLenum pname, const GLfloat * ps);
        // void glTexEnviv(GLenum target, GLenum pname, const GLint * ps);
        // void glTexGendv(GLenum coord, GLenum pname, const GLdouble * ps);
        // void glTexGenfv(GLenum coord, GLenum pname, const GLfloat * ps);
        // void glTexGeniv(GLenum coord, GLenum pname, const GLint * ps);
        // void glFeedbackBuffer(GLsizei size, GLenum type, GLfloat * buffer);
        // void glSelectBuffer(GLsizei size, GLuint * buffer);
        // void glMap1d(GLenum target, GLdouble u1, GLdouble u2, GLint stride, GLint order, const GLdouble * points);
        // void glMap1f(GLenum target, GLfloat u1, GLfloat u2, GLint stride, GLint order, const GLfloat * points);
        // void glMap2d(GLenum target, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, const GLdouble * points);
        // void glMap2f(GLenum target, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, const GLfloat * points);
        // void glEvalCoord1dv(const GLdouble * u);
        // void glEvalCoord1fv(const GLfloat * u);
        // void glEvalCoord2dv(const GLdouble * u);
        // void glEvalCoord2fv(const GLfloat * u);
        // void glPixelMapfv(GLenum map, GLsizei mapsize, const GLfloat * values);
        // void glPixelMapuiv(GLenum map, GLsizei mapsize, const GLuint * values);
        // void glPixelMapusv(GLenum map, GLsizei mapsize, const GLushort * values);
        // void glDrawPixels(GLsizei width, GLsizei height, GLenum format, GLenum type, const void * data);
        // void glGetClipPlane(GLenum plane, GLdouble * equation);
        // void glGetLightfv(GLenum light, GLenum pname, GLfloat * ps);
        // void glGetLightiv(GLenum light, GLenum pname, GLint * ps);
        // void glGetMapdv(GLenum target, GLenum query, GLdouble * v);
        // void glGetMapfv(GLenum target, GLenum query, GLfloat * v);
        // void glGetMapiv(GLenum target, GLenum query, GLint * v);
        // void glGetMaterialfv(GLenum face, GLenum pname, GLfloat * ps);
        // void glGetMaterialiv(GLenum face, GLenum pname, GLint * ps);
        // void glGetPixelMapfv(GLenum map, GLfloat * data);
        // void glGetPixelMapuiv(GLenum map, GLuint * data);
        // void glGetPixelMapusv(GLenum map, GLushort * data);
        // void glGetPolygonStipple(GLubyte * pattern);
        // void glGetTexEnvfv(GLenum target, GLenum pname, GLfloat * ps);
        // void glGetTexEnviv(GLenum target, GLenum pname, GLint * ps);
        // void glGetTexGendv(GLenum coord, GLenum pname, GLdouble * ps);
        // void glGetTexGenfv(GLenum coord, GLenum pname, GLfloat * ps);
        // void glGetTexGeniv(GLenum coord, GLenum pname, GLint * ps);
        // void glLoadMatrixf(const GLfloat * m);
        // void glLoadMatrixd(const GLdouble * m);
        // void glMultMatrixf(const GLfloat * m);
        // void glMultMatrixd(const GLdouble * m);

        #endregion Compatibility-only GL 1.0 features removed from GL 3.2

        #region Compatibility-only GL 1.1 features removed from GL 3.2

        // void glColorPointer(GLint size, GLenum type, GLsizei stride, const void * pointer);
        // void glEdgeFlagPointer(GLsizei stride, const void * pointer);
        // void glIndexPointer(GLenum type, GLsizei stride, const void * pointer);
        // void glGetPointerv(GLenum pname, void ** ps);
        // void glInterleavedArrays(GLenum format, GLsizei stride, const void * pointer);
        // void glNormalPointer(GLenum type, GLsizei stride, const void * pointer);
        // void glTexCoordPointer(GLint size, GLenum type, GLsizei stride, const void * pointer);
        // void glVertexPointer(GLint size, GLenum type, GLsizei stride, const void * pointer);
        // GLboolean glAreTexturesResident(GLsizei n, const GLuint * textures, GLboolean * residences);
        // void glPrioritizeTextures(GLsizei n, const GLuint * textures, const GLclampf * priorities);
        // void glIndexubv(const GLubyte * c);

        #endregion Compatibility-only GL 1.1 features removed from GL 3.2

        #region Compatibility-only GL 1.2 features removed from GL 3.2


        #endregion Compatibility-only GL 1.2 features removed from GL 3.2

        #region Compatibility-only GL 1.3 features removed from GL 3.2

        // void glMultiTexCoord1dv(GLenum target, const GLdouble * v);
        // void glMultiTexCoord1fv(GLenum target, const GLfloat * v);
        // void glMultiTexCoord1iv(GLenum target, const GLint * v);
        // void glMultiTexCoord1sv(GLenum target, const GLshort * v);
        // void glMultiTexCoord2dv(GLenum target, const GLdouble * v);
        // void glMultiTexCoord2fv(GLenum target, const GLfloat * v);
        // void glMultiTexCoord2iv(GLenum target, const GLint * v);
        // void glMultiTexCoord2sv(GLenum target, const GLshort * v);
        // void glMultiTexCoord3dv(GLenum target, const GLdouble * v);
        // void glMultiTexCoord3fv(GLenum target, const GLfloat * v);
        // void glMultiTexCoord3iv(GLenum target, const GLint * v);
        // void glMultiTexCoord3sv(GLenum target, const GLshort * v);
        // void glMultiTexCoord4dv(GLenum target, const GLdouble * v);
        // void glMultiTexCoord4fv(GLenum target, const GLfloat * v);
        // void glMultiTexCoord4iv(GLenum target, const GLint * v);
        // void glMultiTexCoord4sv(GLenum target, const GLshort * v);
        // void glLoadTransposeMatrixf(const GLfloat * m);
        // void glLoadTransposeMatrixd(const GLdouble * m);
        // void glMultTransposeMatrixf(const GLfloat * m);
        // void glMultTransposeMatrixd(const GLdouble * m);

        #endregion Compatibility-only GL 1.3 features removed from GL 3.2

        #region Compatibility-only GL 1.4 features removed from GL 3.2

        // void glFogCoordfv(GLfloat * coord);
        // void glFogCoorddv(GLdouble * coord);
        // void glFogCoordPointer(GLenum type, GLsizei stride, void * pointer);
        // void glSecondaryColor3bv(const GLbyte * v);
        // void glSecondaryColor3dv(const GLdouble * v);
        // void glSecondaryColor3fv(const GLfloat * v);
        // void glSecondaryColor3iv(const GLint * v);
        // void glSecondaryColor3sv(const GLshort * v);
        // void glSecondaryColor3ubv(const GLubyte * v);
        // void glSecondaryColor3uiv(const GLuint * v);
        // void glSecondaryColor3usv(const GLushort * v);
        // void glSecondaryColorPointer(GLint size, GLenum type, GLsizei stride, const void * pointer);
        // void glWindowPos2dv(const GLdouble * v);
        // void glWindowPos2fv(const GLfloat * v);
        // void glWindowPos2iv(const GLint * v);
        // void glWindowPos2sv(const GLshort * v);
        // void glWindowPos3dv(const GLdouble * v);
        // void glWindowPos3fv(const GLfloat * v);
        // void glWindowPos3iv(const GLint * v);
        // void glWindowPos3sv(const GLshort * v);

        #endregion Compatibility-only GL 1.4 features removed from GL 3.2

        #region Compatibility-only GL 1.5 features removed from GL 3.2


        #endregion Compatibility-only GL 1.5 features removed from GL 3.2

        #region Compatibility-only GL 2.0 features removed from GL 3.2


        #endregion Compatibility-only GL 2.0 features removed from GL 3.2

        #region Compatibility-only GL 2.1 features removed from GL 3.2


        #endregion Compatibility-only GL 2.1 features removed from GL 3.2

        #region Compatibility-only GL 3.0 features removed from GL 3.2


        #endregion Compatibility-only GL 3.0 features removed from GL 3.2

        #endregion GL_VERSION_3_2

        #region GL_VERSION_3_3


        #region Reuse ARB_blend_func_extended

        /// <summary>
        /// bind a user-defined varying out variable to a fragment shader color number and index
        /// <para>Require:</para> <para>GL_VERSION_3_3, GL_ARB_blend_func_extended</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glBindFragDataLocationIndexed(GLuint program, GLuint colorNumber, GLuint index, const char * name);</para>
        /// </summary>
        public unsafe static void BindFragDataLocationIndexed(uint program, uint colorNumber, uint index, ref byte name) {
            fixed (byte* pName = &name) {
                GLNative.glBindFragDataLocationIndexed(program, colorNumber, index, pName);
            }
        }

        /// <summary>
        /// query the bindings of color indices to user-defined varying out variables
        /// <para>Require:</para> <para>GL_VERSION_3_3, GL_ARB_blend_func_extended</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>GLint glGetFragDataIndex(GLuint program, const char * name);</para>
        /// </summary>
        public unsafe static int GetFragDataIndex(uint program, ref byte name) {
            fixed (byte* pName = &name) {
                return GLNative.glGetFragDataIndex(program, pName);
            }
        }


        #endregion Reuse ARB_blend_func_extended

        #region Reuse ARB_sampler_objects

        /// <summary>
        /// generate sampler object names
        /// <para>Require:</para> <para>GL_VERSION_3_3, GL_ES_VERSION_3_0, GL_ARB_sampler_objects</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGenSamplers(GLsizei n, GLuint * samplers);</para>
        /// </summary>
        public unsafe static void GenSamplers(int n, ref uint samplers) {
            fixed (uint* pSamplers = &samplers) {
                GLNative.glGenSamplers(n, pSamplers);
            }
        }

        /// <summary>
        /// delete named sampler objects
        /// <para>Require:</para> <para>GL_VERSION_3_3, GL_ES_VERSION_3_0, GL_ARB_sampler_objects</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glDeleteSamplers(GLsizei n, const GLuint * samplers);</para>
        /// </summary>
        public unsafe static void DeleteSamplers(int n, ref uint samplers) {
            fixed (uint* pSamplers = &samplers) {
                GLNative.glDeleteSamplers(n, pSamplers);
            }
        }

        /// <summary>
        /// set sampler parameters
        /// <para>Require:</para> <para>GL_VERSION_3_3, GL_ES_VERSION_3_0, GL_ARB_sampler_objects</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glSamplerParameteriv(GLuint sampler, GLenum pname, const GLint * params);</para>
        /// </summary>
        public unsafe static void SamplerParameteriv(uint sampler, uint pname, ref int ps) {
            fixed (int* pPs = &ps) {
                GLNative.glSamplerParameteriv(sampler, pname, pPs);
            }
        }

        /// <summary>
        /// set sampler parameters
        /// <para>Require:</para> <para>GL_VERSION_3_3, GL_ES_VERSION_3_0, GL_ARB_sampler_objects</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glSamplerParameterfv(GLuint sampler, GLenum pname, const GLfloat * params);</para>
        /// </summary>
        public unsafe static void SamplerParameterfv(uint sampler, uint pname, ref float ps) {
            fixed (float* pPs = &ps) {
                GLNative.glSamplerParameterfv(sampler, pname, pPs);
            }
        }

        /// <summary>
        /// set sampler parameters
        /// <para>Require:</para> <para>GL_VERSION_3_3, GL_ES_VERSION_3_2, GL_ARB_sampler_objects</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glSamplerParameterIiv(GLuint sampler, GLenum pname, const GLint * params);</para>
        /// </summary>
        public unsafe static void SamplerParameterIiv(uint sampler, uint pname, ref int ps) {
            fixed (int* pPs = &ps) {
                GLNative.glSamplerParameterIiv(sampler, pname, pPs);
            }
        }

        /// <summary>
        /// set sampler parameters
        /// <para>Require:</para> <para>GL_VERSION_3_3, GL_ES_VERSION_3_2, GL_ARB_sampler_objects</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glSamplerParameterIuiv(GLuint sampler, GLenum pname, const GLuint * params);</para>
        /// </summary>
        public unsafe static void SamplerParameterIuiv(uint sampler, uint pname, ref uint ps) {
            fixed (uint* pPs = &ps) {
                GLNative.glSamplerParameterIuiv(sampler, pname, pPs);
            }
        }

        /// <summary>
        /// return sampler parameter values
        /// <para>Require:</para> <para>GL_VERSION_3_3, GL_ES_VERSION_3_0, GL_ARB_sampler_objects</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetSamplerParameteriv(GLuint sampler, GLenum pname, GLint * params);</para>
        /// </summary>
        public unsafe static void GetSamplerParameteriv(uint sampler, uint pname, ref int ps) {
            fixed (int* pPs = &ps) {
                GLNative.glGetSamplerParameteriv(sampler, pname, pPs);
            }
        }

        /// <summary>
        /// return sampler parameter values
        /// <para>Require:</para> <para>GL_VERSION_3_3, GL_ES_VERSION_3_2, GL_ARB_sampler_objects</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetSamplerParameterIiv(GLuint sampler, GLenum pname, GLint * params);</para>
        /// </summary>
        public unsafe static void GetSamplerParameterIiv(uint sampler, uint pname, ref int ps) {
            fixed (int* pPs = &ps) {
                GLNative.glGetSamplerParameterIiv(sampler, pname, pPs);
            }
        }

        /// <summary>
        /// return sampler parameter values
        /// <para>Require:</para> <para>GL_VERSION_3_3, GL_ES_VERSION_3_0, GL_ARB_sampler_objects</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetSamplerParameterfv(GLuint sampler, GLenum pname, GLfloat * params);</para>
        /// </summary>
        public unsafe static void GetSamplerParameterfv(uint sampler, uint pname, ref float ps) {
            fixed (float* pPs = &ps) {
                GLNative.glGetSamplerParameterfv(sampler, pname, pPs);
            }
        }

        /// <summary>
        /// return sampler parameter values
        /// <para>Require:</para> <para>GL_VERSION_3_3, GL_ES_VERSION_3_2, GL_ARB_sampler_objects</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetSamplerParameterIuiv(GLuint sampler, GLenum pname, GLuint * params);</para>
        /// </summary>
        public unsafe static void GetSamplerParameterIuiv(uint sampler, uint pname, ref uint ps) {
            fixed (uint* pPs = &ps) {
                GLNative.glGetSamplerParameterIuiv(sampler, pname, pPs);
            }
        }


        #endregion Reuse ARB_sampler_objects

        #region Reuse ARB_timer_query

        /// <summary>
        /// return parameters of a query object
        /// <para>Require:</para> <para>GL_VERSION_3_3, GL_ARB_timer_query</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetQueryObjecti64v(GLuint id, GLenum pname, GLint64 * params);</para>
        /// </summary>
        public unsafe static void GetQueryObjecti64v(uint id, uint pname, ref UInt64 ps) {
            fixed (UInt64* pPs = &ps) {
                GLNative.glGetQueryObjecti64v(id, pname, pPs);
            }
        }

        /// <summary>
        /// return parameters of a query object
        /// <para>Require:</para> <para>GL_VERSION_3_3, GL_ARB_timer_query</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetQueryObjectui64v(GLuint id, GLenum pname, GLuint64 * params);</para>
        /// </summary>
        public unsafe static void GetQueryObjectui64v(uint id, uint pname, ref UInt64 ps) {
            fixed (UInt64* pPs = &ps) {
                GLNative.glGetQueryObjectui64v(id, pname, pPs);
            }
        }


        #endregion Reuse ARB_timer_query

        #region Reuse ARB_vertex_type_2_10_10_10_rev

        /// <summary>
        /// <para>Require:</para> <para>GL_VERSION_3_3, GL_ARB_vertex_type_2_10_10_10_rev</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glVertexAttribP1uiv(GLuint index, GLenum type, GLboolean normalized, const GLuint * value);</para>
        /// </summary>
        public unsafe static void VertexAttribP1uiv(uint index, uint type, bool normalized, ref uint value) {
            fixed (uint* pValue = &value) {
                GLNative.glVertexAttribP1uiv(index, type, normalized, pValue);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_VERSION_3_3, GL_ARB_vertex_type_2_10_10_10_rev</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glVertexAttribP2uiv(GLuint index, GLenum type, GLboolean normalized, const GLuint * value);</para>
        /// </summary>
        public unsafe static void VertexAttribP2uiv(uint index, uint type, bool normalized, ref uint value) {
            fixed (uint* pValue = &value) {
                GLNative.glVertexAttribP2uiv(index, type, normalized, pValue);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_VERSION_3_3, GL_ARB_vertex_type_2_10_10_10_rev</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glVertexAttribP3uiv(GLuint index, GLenum type, GLboolean normalized, const GLuint * value);</para>
        /// </summary>
        public unsafe static void VertexAttribP3uiv(uint index, uint type, bool normalized, ref uint value) {
            fixed (uint* pValue = &value) {
                GLNative.glVertexAttribP3uiv(index, type, normalized, pValue);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_VERSION_3_3, GL_ARB_vertex_type_2_10_10_10_rev</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glVertexAttribP4uiv(GLuint index, GLenum type, GLboolean normalized, const GLuint * value);</para>
        /// </summary>
        public unsafe static void VertexAttribP4uiv(uint index, uint type, bool normalized, ref uint value) {
            fixed (uint* pValue = &value) {
                GLNative.glVertexAttribP4uiv(index, type, normalized, pValue);
            }
        }


        #endregion Reuse ARB_vertex_type_2_10_10_10_rev

        #region Reuse ARB_vertex_type_2_10_10_10_rev compatibility profile

        /// <summary>
        /// <para>Require:</para> <para>GL_VERSION_3_3, GL_ARB_vertex_type_2_10_10_10_rev</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glVertexP2uiv(GLenum type, const GLuint * value);</para>
        /// </summary>
        public unsafe static void VertexP2uiv(uint type, ref uint value) {
            fixed (uint* pValue = &value) {
                GLNative.glVertexP2uiv(type, pValue);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_VERSION_3_3, GL_ARB_vertex_type_2_10_10_10_rev</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glVertexP3uiv(GLenum type, const GLuint * value);</para>
        /// </summary>
        public unsafe static void VertexP3uiv(uint type, ref uint value) {
            fixed (uint* pValue = &value) {
                GLNative.glVertexP3uiv(type, pValue);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_VERSION_3_3, GL_ARB_vertex_type_2_10_10_10_rev</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glVertexP4uiv(GLenum type, const GLuint * value);</para>
        /// </summary>
        public unsafe static void VertexP4uiv(uint type, ref uint value) {
            fixed (uint* pValue = &value) {
                GLNative.glVertexP4uiv(type, pValue);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_VERSION_3_3, GL_ARB_vertex_type_2_10_10_10_rev</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glTexCoordP1uiv(GLenum type, const GLuint * coords);</para>
        /// </summary>
        public unsafe static void TexCoordP1uiv(uint type, ref uint coords) {
            fixed (uint* pCoords = &coords) {
                GLNative.glTexCoordP1uiv(type, pCoords);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_VERSION_3_3, GL_ARB_vertex_type_2_10_10_10_rev</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glTexCoordP2uiv(GLenum type, const GLuint * coords);</para>
        /// </summary>
        public unsafe static void TexCoordP2uiv(uint type, ref uint coords) {
            fixed (uint* pCoords = &coords) {
                GLNative.glTexCoordP2uiv(type, pCoords);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_VERSION_3_3, GL_ARB_vertex_type_2_10_10_10_rev</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glTexCoordP3uiv(GLenum type, const GLuint * coords);</para>
        /// </summary>
        public unsafe static void TexCoordP3uiv(uint type, ref uint coords) {
            fixed (uint* pCoords = &coords) {
                GLNative.glTexCoordP3uiv(type, pCoords);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_VERSION_3_3, GL_ARB_vertex_type_2_10_10_10_rev</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glTexCoordP4uiv(GLenum type, const GLuint * coords);</para>
        /// </summary>
        public unsafe static void TexCoordP4uiv(uint type, ref uint coords) {
            fixed (uint* pCoords = &coords) {
                GLNative.glTexCoordP4uiv(type, pCoords);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_VERSION_3_3, GL_ARB_vertex_type_2_10_10_10_rev</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glMultiTexCoordP1uiv(GLenum texture, GLenum type, const GLuint * coords);</para>
        /// </summary>
        public unsafe static void MultiTexCoordP1uiv(uint texture, uint type, ref uint coords) {
            fixed (uint* pCoords = &coords) {
                GLNative.glMultiTexCoordP1uiv(texture, type, pCoords);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_VERSION_3_3, GL_ARB_vertex_type_2_10_10_10_rev</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glMultiTexCoordP2uiv(GLenum texture, GLenum type, const GLuint * coords);</para>
        /// </summary>
        public unsafe static void MultiTexCoordP2uiv(uint texture, uint type, ref uint coords) {
            fixed (uint* pCoords = &coords) {
                GLNative.glMultiTexCoordP2uiv(texture, type, pCoords);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_VERSION_3_3, GL_ARB_vertex_type_2_10_10_10_rev</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glMultiTexCoordP3uiv(GLenum texture, GLenum type, const GLuint * coords);</para>
        /// </summary>
        public unsafe static void MultiTexCoordP3uiv(uint texture, uint type, ref uint coords) {
            fixed (uint* pCoords = &coords) {
                GLNative.glMultiTexCoordP3uiv(texture, type, pCoords);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_VERSION_3_3, GL_ARB_vertex_type_2_10_10_10_rev</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glMultiTexCoordP4uiv(GLenum texture, GLenum type, const GLuint * coords);</para>
        /// </summary>
        public unsafe static void MultiTexCoordP4uiv(uint texture, uint type, ref uint coords) {
            fixed (uint* pCoords = &coords) {
                GLNative.glMultiTexCoordP4uiv(texture, type, pCoords);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_VERSION_3_3, GL_ARB_vertex_type_2_10_10_10_rev</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glNormalP3uiv(GLenum type, const GLuint * coords);</para>
        /// </summary>
        public unsafe static void NormalP3uiv(uint type, ref uint coords) {
            fixed (uint* pCoords = &coords) {
                GLNative.glNormalP3uiv(type, pCoords);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_VERSION_3_3, GL_ARB_vertex_type_2_10_10_10_rev</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glColorP3uiv(GLenum type, const GLuint * color);</para>
        /// </summary>
        public unsafe static void ColorP3uiv(uint type, ref uint color) {
            fixed (uint* pColor = &color) {
                GLNative.glColorP3uiv(type, pColor);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_VERSION_3_3, GL_ARB_vertex_type_2_10_10_10_rev</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glColorP4uiv(GLenum type, const GLuint * color);</para>
        /// </summary>
        public unsafe static void ColorP4uiv(uint type, ref uint color) {
            fixed (uint* pColor = &color) {
                GLNative.glColorP4uiv(type, pColor);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_VERSION_3_3, GL_ARB_vertex_type_2_10_10_10_rev</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glSecondaryColorP3uiv(GLenum type, const GLuint * color);</para>
        /// </summary>
        public unsafe static void SecondaryColorP3uiv(uint type, ref uint color) {
            fixed (uint* pColor = &color) {
                GLNative.glSecondaryColorP3uiv(type, pColor);
            }
        }


        #endregion Reuse ARB_vertex_type_2_10_10_10_rev compatibility profile

        #endregion GL_VERSION_3_3

        #region GL_VERSION_4_0


        #region Reuse ARB_draw_indirect

        /// <summary>
        /// render primitives from array data, taking parameters from memory
        /// <para>Require:</para> <para>GL_VERSION_4_0, GL_ES_VERSION_3_1, GL_ARB_draw_indirect</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glDrawArraysIndirect(GLenum mode, const void * indirect);</para>
        /// </summary>
        public unsafe static void DrawArraysIndirect(uint mode, IntPtr indirect) {
            GLNative.glDrawArraysIndirect(mode, (void*)indirect);
        }

        /// <summary>
        /// render indexed primitives from array data, taking parameters from memory
        /// <para>Require:</para> <para>GL_VERSION_4_0, GL_ES_VERSION_3_1, GL_ARB_draw_indirect</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glDrawElementsIndirect(GLenum mode, GLenum type, const void * indirect);</para>
        /// </summary>
        public unsafe static void DrawElementsIndirect(uint mode, uint type, IntPtr indirect) {
            GLNative.glDrawElementsIndirect(mode, type, (void*)indirect);
        }


        #endregion Reuse ARB_draw_indirect

        #region Reuse ARB_gpu_shader_fp64

        /// <summary>
        /// <para>Require:</para> <para>GL_VERSION_4_0, GL_ARB_gpu_shader_fp64</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glUniform1dv(GLint location, GLsizei count, const GLdouble * value);</para>
        /// </summary>
        public unsafe static void Uniform1dv(int location, int count, ref double value) {
            fixed (double* pValue = &value) {
                GLNative.glUniform1dv(location, count, pValue);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_VERSION_4_0, GL_ARB_gpu_shader_fp64</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glUniform2dv(GLint location, GLsizei count, const GLdouble * value);</para>
        /// </summary>
        public unsafe static void Uniform2dv(int location, int count, ref double value) {
            fixed (double* pValue = &value) {
                GLNative.glUniform2dv(location, count, pValue);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_VERSION_4_0, GL_ARB_gpu_shader_fp64</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glUniform3dv(GLint location, GLsizei count, const GLdouble * value);</para>
        /// </summary>
        public unsafe static void Uniform3dv(int location, int count, ref double value) {
            fixed (double* pValue = &value) {
                GLNative.glUniform3dv(location, count, pValue);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_VERSION_4_0, GL_ARB_gpu_shader_fp64</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glUniform4dv(GLint location, GLsizei count, const GLdouble * value);</para>
        /// </summary>
        public unsafe static void Uniform4dv(int location, int count, ref double value) {
            fixed (double* pValue = &value) {
                GLNative.glUniform4dv(location, count, pValue);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_VERSION_4_0, GL_ARB_gpu_shader_fp64</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glUniformMatrix2dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);</para>
        /// </summary>
        public unsafe static void UniformMatrix2dv(int location, int count, bool transpose, ref double value) {
            fixed (double* pValue = &value) {
                GLNative.glUniformMatrix2dv(location, count, transpose, pValue);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_VERSION_4_0, GL_ARB_gpu_shader_fp64</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glUniformMatrix3dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);</para>
        /// </summary>
        public unsafe static void UniformMatrix3dv(int location, int count, bool transpose, ref double value) {
            fixed (double* pValue = &value) {
                GLNative.glUniformMatrix3dv(location, count, transpose, pValue);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_VERSION_4_0, GL_ARB_gpu_shader_fp64</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glUniformMatrix4dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);</para>
        /// </summary>
        public unsafe static void UniformMatrix4dv(int location, int count, bool transpose, ref double value) {
            fixed (double* pValue = &value) {
                GLNative.glUniformMatrix4dv(location, count, transpose, pValue);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_VERSION_4_0, GL_ARB_gpu_shader_fp64</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glUniformMatrix2x3dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);</para>
        /// </summary>
        public unsafe static void UniformMatrix2x3dv(int location, int count, bool transpose, ref double value) {
            fixed (double* pValue = &value) {
                GLNative.glUniformMatrix2x3dv(location, count, transpose, pValue);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_VERSION_4_0, GL_ARB_gpu_shader_fp64</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glUniformMatrix2x4dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);</para>
        /// </summary>
        public unsafe static void UniformMatrix2x4dv(int location, int count, bool transpose, ref double value) {
            fixed (double* pValue = &value) {
                GLNative.glUniformMatrix2x4dv(location, count, transpose, pValue);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_VERSION_4_0, GL_ARB_gpu_shader_fp64</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glUniformMatrix3x2dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);</para>
        /// </summary>
        public unsafe static void UniformMatrix3x2dv(int location, int count, bool transpose, ref double value) {
            fixed (double* pValue = &value) {
                GLNative.glUniformMatrix3x2dv(location, count, transpose, pValue);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_VERSION_4_0, GL_ARB_gpu_shader_fp64</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glUniformMatrix3x4dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);</para>
        /// </summary>
        public unsafe static void UniformMatrix3x4dv(int location, int count, bool transpose, ref double value) {
            fixed (double* pValue = &value) {
                GLNative.glUniformMatrix3x4dv(location, count, transpose, pValue);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_VERSION_4_0, GL_ARB_gpu_shader_fp64</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glUniformMatrix4x2dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);</para>
        /// </summary>
        public unsafe static void UniformMatrix4x2dv(int location, int count, bool transpose, ref double value) {
            fixed (double* pValue = &value) {
                GLNative.glUniformMatrix4x2dv(location, count, transpose, pValue);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_VERSION_4_0, GL_ARB_gpu_shader_fp64</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glUniformMatrix4x3dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);</para>
        /// </summary>
        public unsafe static void UniformMatrix4x3dv(int location, int count, bool transpose, ref double value) {
            fixed (double* pValue = &value) {
                GLNative.glUniformMatrix4x3dv(location, count, transpose, pValue);
            }
        }

        /// <summary>
        /// Returns the value of a uniform variable
        /// <para>Require:</para> <para>GL_VERSION_4_0, GL_ARB_gpu_shader_fp64</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetUniformdv(GLuint program, GLint location, GLdouble * params);</para>
        /// </summary>
        public unsafe static void GetUniformdv(uint program, int location, ref double ps) {
            fixed (double* pPs = &ps) {
                GLNative.glGetUniformdv(program, location, pPs);
            }
        }


        #endregion Reuse ARB_gpu_shader_fp64

        #region Reuse ARB_shader_subroutine

        /// <summary>
        /// retrieve the location of a subroutine uniform of a given shader stage within a program
        /// <para>Require:</para> <para>GL_VERSION_4_0, GL_ARB_shader_subroutine</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>GLint glGetSubroutineUniformLocation(GLuint program, GLenum shadertype, const GLchar * name);</para>
        /// </summary>
        public unsafe static int GetSubroutineUniformLocation(uint program, uint shadertype, ref byte name) {
            fixed (byte* pName = &name) {
                return GLNative.glGetSubroutineUniformLocation(program, shadertype, pName);
            }
        }

        /// <summary>
        /// retrieve the index of a subroutine uniform of a given shader stage within a program
        /// <para>Require:</para> <para>GL_VERSION_4_0, GL_ARB_shader_subroutine</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>GLuint glGetSubroutineIndex(GLuint program, GLenum shadertype, const GLchar * name);</para>
        /// </summary>
        public unsafe static uint GetSubroutineIndex(uint program, uint shadertype, ref byte name) {
            fixed (byte* pName = &name) {
                return GLNative.glGetSubroutineIndex(program, shadertype, pName);
            }
        }

        /// <summary>
        /// query a property of an active shader subroutine uniform
        /// <para>Require:</para> <para>GL_VERSION_4_0, GL_ARB_shader_subroutine</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetActiveSubroutineUniformiv(GLuint program, GLenum shadertype, GLuint index, GLenum pname, GLint * values);</para>
        /// </summary>
        public unsafe static void GetActiveSubroutineUniformiv(uint program, uint shadertype, uint index, uint pname, ref int values) {
            fixed (int* pValues = &values) {
                GLNative.glGetActiveSubroutineUniformiv(program, shadertype, index, pname, pValues);
            }
        }

        /// <summary>
        /// query the name of an active shader subroutine uniform
        /// <para>Require:</para> <para>GL_VERSION_4_0, GL_ARB_shader_subroutine</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetActiveSubroutineUniformName(GLuint program, GLenum shadertype, GLuint index, GLsizei bufSize, GLsizei * length, GLchar * name);</para>
        /// </summary>
        public unsafe static void GetActiveSubroutineUniformName(uint program, uint shadertype, uint index, int bufSize, ref int length, ref byte name) {
            fixed (int* pLength = &length)
            fixed (byte* pName = &name) {
                GLNative.glGetActiveSubroutineUniformName(program, shadertype, index, bufSize, pLength, pName);
            }
        }

        /// <summary>
        /// query the name of an active shader subroutine
        /// <para>Require:</para> <para>GL_VERSION_4_0, GL_ARB_shader_subroutine</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetActiveSubroutineName(GLuint program, GLenum shadertype, GLuint index, GLsizei bufSize, GLsizei * length, GLchar * name);</para>
        /// </summary>
        public unsafe static void GetActiveSubroutineName(uint program, uint shadertype, uint index, int bufSize, ref int length, ref byte name) {
            fixed (int* pLength = &length)
            fixed (byte* pName = &name) {
                GLNative.glGetActiveSubroutineName(program, shadertype, index, bufSize, pLength, pName);
            }
        }

        /// <summary>
        /// load active subroutine uniforms
        /// <para>Require:</para> <para>GL_VERSION_4_0, GL_ARB_shader_subroutine</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glUniformSubroutinesuiv(GLenum shadertype, GLsizei count, const GLuint * indices);</para>
        /// </summary>
        public unsafe static void UniformSubroutinesuiv(uint shadertype, int count, ref uint indices) {
            fixed (uint* pIndices = &indices) {
                GLNative.glUniformSubroutinesuiv(shadertype, count, pIndices);
            }
        }

        /// <summary>
        /// retrieve the value of a subroutine uniform of a given shader stage of the current program
        /// <para>Require:</para> <para>GL_VERSION_4_0, GL_ARB_shader_subroutine</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetUniformSubroutineuiv(GLenum shadertype, GLint location, GLuint * values);</para>
        /// </summary>
        public unsafe static void GetUniformSubroutineuiv(uint shadertype, int location, ref uint values) {
            fixed (uint* pValues = &values) {
                GLNative.glGetUniformSubroutineuiv(shadertype, location, pValues);
            }
        }

        /// <summary>
        /// retrieve properties of a program object corresponding to a specified shader stage
        /// <para>Require:</para> <para>GL_VERSION_4_0, GL_ARB_shader_subroutine</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetProgramStageiv(GLuint program, GLenum shadertype, GLenum pname, GLint * values);</para>
        /// </summary>
        public unsafe static void GetProgramStageiv(uint program, uint shadertype, uint pname, ref int values) {
            fixed (int* pValues = &values) {
                GLNative.glGetProgramStageiv(program, shadertype, pname, pValues);
            }
        }


        #endregion Reuse ARB_shader_subroutine

        #region Reuse ARB_tessellation_shader

        /// <summary>
        /// specifies the parameters for patch primitives
        /// <para>Require:</para> <para>GL_VERSION_4_0, GL_ARB_tessellation_shader</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glPatchParameterfv(GLenum pname, const GLfloat * values);</para>
        /// </summary>
        public unsafe static void PatchParameterfv(uint pname, ref float values) {
            fixed (float* pValues = &values) {
                GLNative.glPatchParameterfv(pname, pValues);
            }
        }


        #endregion Reuse ARB_tessellation_shader

        #region Reuse ARB_transform_feedback2

        /// <summary>
        /// delete transform feedback objects
        /// <para>Require:</para> <para>GL_VERSION_4_0, GL_ES_VERSION_3_0, GL_ARB_transform_feedback2</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glDeleteTransformFeedbacks(GLsizei n, const GLuint * ids);</para>
        /// </summary>
        public unsafe static void DeleteTransformFeedbacks(int n, ref uint ids) {
            fixed (uint* pIds = &ids) {
                GLNative.glDeleteTransformFeedbacks(n, pIds);
            }
        }

        /// <summary>
        /// reserve transform feedback object names
        /// <para>Require:</para> <para>GL_VERSION_4_0, GL_ES_VERSION_3_0, GL_ARB_transform_feedback2</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGenTransformFeedbacks(GLsizei n, GLuint * ids);</para>
        /// </summary>
        public unsafe static void GenTransformFeedbacks(int n, ref uint ids) {
            fixed (uint* pIds = &ids) {
                GLNative.glGenTransformFeedbacks(n, pIds);
            }
        }


        #endregion Reuse ARB_transform_feedback2

        #region Reuse ARB_transform_feedback3

        /// <summary>
        /// return parameters of an indexed query object target
        /// <para>Require:</para> <para>GL_VERSION_4_0, GL_ARB_transform_feedback3</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetQueryIndexediv(GLenum target, GLuint index, GLenum pname, GLint * params);</para>
        /// </summary>
        public unsafe static void GetQueryIndexediv(uint target, uint index, uint pname, ref int ps) {
            fixed (int* pPs = &ps) {
                GLNative.glGetQueryIndexediv(target, index, pname, pPs);
            }
        }


        #endregion Reuse ARB_transform_feedback3

        #endregion GL_VERSION_4_0

        #region GL_VERSION_4_1


        #region Reuse commands from ARB_ES2_compatibility

        /// <summary>
        /// load pre-compiled shader binaries
        /// <para>Require:</para> <para>GL_VERSION_4_1, GL_ES_VERSION_2_0, GL_ARB_ES2_compatibility</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glShaderBinary(GLsizei count, const GLuint * shaders, GLenum binaryFormat, const void * binary, GLsizei length);</para>
        /// </summary>
        public unsafe static void ShaderBinary(int count, ref uint shaders, uint binaryFormat, IntPtr binary, int length) {
            fixed (uint* pShaders = &shaders) {
                GLNative.glShaderBinary(count, pShaders, binaryFormat, (void*)binary, length);
            }
        }

        /// <summary>
        /// retrieve the range and precision for numeric formats supported by the shader compiler
        /// <para>Require:</para> <para>GL_VERSION_4_1, GL_ES_VERSION_2_0, GL_ARB_ES2_compatibility</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetShaderPrecisionFormat(GLenum shaderType, GLenum precisionType, GLint * range, GLint * precision);</para>
        /// </summary>
        public unsafe static void GetShaderPrecisionFormat(uint shaderType, uint precisionType, ref int range, ref int precision) {
            fixed (int* pRange = &range)
            fixed (int* pPrecision = &precision) {
                GLNative.glGetShaderPrecisionFormat(shaderType, precisionType, pRange, pPrecision);
            }
        }


        #endregion Reuse commands from ARB_ES2_compatibility

        #region Reuse commands from ARB_get_program_binary

        /// <summary>
        /// return a binary representation of a program object's compiled and linked executable source
        /// <para>Require:</para> <para>GL_VERSION_4_1, GL_ES_VERSION_3_0, GL_ARB_get_program_binary</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetProgramBinary(GLuint program, GLsizei bufSize, GLsizei * length, GLenum * binaryFormat, void * binary);</para>
        /// </summary>
        public unsafe static void GetProgramBinary(uint program, int bufSize, ref int length, ref uint binaryFormat, IntPtr binary) {
            fixed (int* pLength = &length)
            fixed (uint* pBinaryFormat = &binaryFormat) {
                GLNative.glGetProgramBinary(program, bufSize, pLength, pBinaryFormat, (void*)binary);
            }
        }

        /// <summary>
        /// load a program object with a program binary
        /// <para>Require:</para> <para>GL_VERSION_4_1, GL_ES_VERSION_3_0, GL_SC_VERSION_2_0, GL_ARB_get_program_binary</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glProgramBinary(GLuint program, GLenum binaryFormat, const void * binary, GLsizei length);</para>
        /// </summary>
        public unsafe static void ProgramBinary(uint program, uint binaryFormat, IntPtr binary, int length) {
            GLNative.glProgramBinary(program, binaryFormat, (void*)binary, length);
        }


        #endregion Reuse commands from ARB_get_program_binary

        #region Reuse commands from ARB_separate_shader_objects

        /// <summary>
        /// create a stand-alone program from an array of null-terminated source code strings
        /// <para>Require:</para> <para>GL_VERSION_4_1, GL_ES_VERSION_3_1, GL_ARB_separate_shader_objects</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>GLuint glCreateShaderProgramv(GLenum type, GLsizei count, const char ** strings);</para>
        /// </summary>
        public unsafe static uint CreateShaderProgramv(uint type, int count, IntPtr strings) {
            return GLNative.glCreateShaderProgramv(type, count, (byte**)strings);
        }

        /// <summary>
        /// delete program pipeline objects
        /// <para>Require:</para> <para>GL_VERSION_4_1, GL_ES_VERSION_3_1, GL_ARB_separate_shader_objects</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glDeleteProgramPipelines(GLsizei n, const GLuint * pipelines);</para>
        /// </summary>
        public unsafe static void DeleteProgramPipelines(int n, ref uint pipelines) {
            fixed (uint* pPipelines = &pipelines) {
                GLNative.glDeleteProgramPipelines(n, pPipelines);
            }
        }

        /// <summary>
        /// reserve program pipeline object names
        /// <para>Require:</para> <para>GL_VERSION_4_1, GL_ES_VERSION_3_1, GL_ARB_separate_shader_objects</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGenProgramPipelines(GLsizei n, GLuint * pipelines);</para>
        /// </summary>
        public unsafe static void GenProgramPipelines(int n, ref uint pipelines) {
            fixed (uint* pPipelines = &pipelines) {
                GLNative.glGenProgramPipelines(n, pPipelines);
            }
        }

        /// <summary>
        /// retrieve properties of a program pipeline object
        /// <para>Require:</para> <para>GL_VERSION_4_1, GL_ES_VERSION_3_1, GL_ARB_separate_shader_objects</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetProgramPipelineiv(GLuint pipeline, GLenum pname, GLint * params);</para>
        /// </summary>
        public unsafe static void GetProgramPipelineiv(uint pipeline, uint pname, ref int ps) {
            fixed (int* pPs = &ps) {
                GLNative.glGetProgramPipelineiv(pipeline, pname, pPs);
            }
        }

        /// <summary>
        /// Specify the value of a uniform variable for a specified program object
        /// <para>Require:</para> <para>GL_VERSION_4_1, GL_ES_VERSION_3_1, GL_ARB_separate_shader_objects</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glProgramUniform1iv(GLuint program, GLint location, GLsizei count, const GLint * value);</para>
        /// </summary>
        public unsafe static void ProgramUniform1iv(uint program, int location, int count, ref int value) {
            fixed (int* pValue = &value) {
                GLNative.glProgramUniform1iv(program, location, count, pValue);
            }
        }

        /// <summary>
        /// Specify the value of a uniform variable for a specified program object
        /// <para>Require:</para> <para>GL_VERSION_4_1, GL_ES_VERSION_3_1, GL_ARB_separate_shader_objects</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glProgramUniform1fv(GLuint program, GLint location, GLsizei count, const GLfloat * value);</para>
        /// </summary>
        public unsafe static void ProgramUniform1fv(uint program, int location, int count, ref float value) {
            fixed (float* pValue = &value) {
                GLNative.glProgramUniform1fv(program, location, count, pValue);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_VERSION_4_1, GL_ARB_separate_shader_objects</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glProgramUniform1dv(GLuint program, GLint location, GLsizei count, const GLdouble * value);</para>
        /// </summary>
        public unsafe static void ProgramUniform1dv(uint program, int location, int count, ref double value) {
            fixed (double* pValue = &value) {
                GLNative.glProgramUniform1dv(program, location, count, pValue);
            }
        }

        /// <summary>
        /// Specify the value of a uniform variable for a specified program object
        /// <para>Require:</para> <para>GL_VERSION_4_1, GL_ES_VERSION_3_1, GL_ARB_separate_shader_objects</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glProgramUniform1uiv(GLuint program, GLint location, GLsizei count, const GLuint * value);</para>
        /// </summary>
        public unsafe static void ProgramUniform1uiv(uint program, int location, int count, ref uint value) {
            fixed (uint* pValue = &value) {
                GLNative.glProgramUniform1uiv(program, location, count, pValue);
            }
        }

        /// <summary>
        /// Specify the value of a uniform variable for a specified program object
        /// <para>Require:</para> <para>GL_VERSION_4_1, GL_ES_VERSION_3_1, GL_ARB_separate_shader_objects</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glProgramUniform2iv(GLuint program, GLint location, GLsizei count, const GLint * value);</para>
        /// </summary>
        public unsafe static void ProgramUniform2iv(uint program, int location, int count, ref int value) {
            fixed (int* pValue = &value) {
                GLNative.glProgramUniform2iv(program, location, count, pValue);
            }
        }

        /// <summary>
        /// Specify the value of a uniform variable for a specified program object
        /// <para>Require:</para> <para>GL_VERSION_4_1, GL_ES_VERSION_3_1, GL_ARB_separate_shader_objects</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glProgramUniform2fv(GLuint program, GLint location, GLsizei count, const GLfloat * value);</para>
        /// </summary>
        public unsafe static void ProgramUniform2fv(uint program, int location, int count, ref float value) {
            fixed (float* pValue = &value) {
                GLNative.glProgramUniform2fv(program, location, count, pValue);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_VERSION_4_1, GL_ARB_separate_shader_objects</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glProgramUniform2dv(GLuint program, GLint location, GLsizei count, const GLdouble * value);</para>
        /// </summary>
        public unsafe static void ProgramUniform2dv(uint program, int location, int count, ref double value) {
            fixed (double* pValue = &value) {
                GLNative.glProgramUniform2dv(program, location, count, pValue);
            }
        }

        /// <summary>
        /// Specify the value of a uniform variable for a specified program object
        /// <para>Require:</para> <para>GL_VERSION_4_1, GL_ES_VERSION_3_1, GL_ARB_separate_shader_objects</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glProgramUniform2uiv(GLuint program, GLint location, GLsizei count, const GLuint * value);</para>
        /// </summary>
        public unsafe static void ProgramUniform2uiv(uint program, int location, int count, ref uint value) {
            fixed (uint* pValue = &value) {
                GLNative.glProgramUniform2uiv(program, location, count, pValue);
            }
        }

        /// <summary>
        /// Specify the value of a uniform variable for a specified program object
        /// <para>Require:</para> <para>GL_VERSION_4_1, GL_ES_VERSION_3_1, GL_ARB_separate_shader_objects</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glProgramUniform3iv(GLuint program, GLint location, GLsizei count, const GLint * value);</para>
        /// </summary>
        public unsafe static void ProgramUniform3iv(uint program, int location, int count, ref int value) {
            fixed (int* pValue = &value) {
                GLNative.glProgramUniform3iv(program, location, count, pValue);
            }
        }

        /// <summary>
        /// Specify the value of a uniform variable for a specified program object
        /// <para>Require:</para> <para>GL_VERSION_4_1, GL_ES_VERSION_3_1, GL_ARB_separate_shader_objects</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glProgramUniform3fv(GLuint program, GLint location, GLsizei count, const GLfloat * value);</para>
        /// </summary>
        public unsafe static void ProgramUniform3fv(uint program, int location, int count, ref float value) {
            fixed (float* pValue = &value) {
                GLNative.glProgramUniform3fv(program, location, count, pValue);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_VERSION_4_1, GL_ARB_separate_shader_objects</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glProgramUniform3dv(GLuint program, GLint location, GLsizei count, const GLdouble * value);</para>
        /// </summary>
        public unsafe static void ProgramUniform3dv(uint program, int location, int count, ref double value) {
            fixed (double* pValue = &value) {
                GLNative.glProgramUniform3dv(program, location, count, pValue);
            }
        }

        /// <summary>
        /// Specify the value of a uniform variable for a specified program object
        /// <para>Require:</para> <para>GL_VERSION_4_1, GL_ES_VERSION_3_1, GL_ARB_separate_shader_objects</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glProgramUniform3uiv(GLuint program, GLint location, GLsizei count, const GLuint * value);</para>
        /// </summary>
        public unsafe static void ProgramUniform3uiv(uint program, int location, int count, ref uint value) {
            fixed (uint* pValue = &value) {
                GLNative.glProgramUniform3uiv(program, location, count, pValue);
            }
        }

        /// <summary>
        /// Specify the value of a uniform variable for a specified program object
        /// <para>Require:</para> <para>GL_VERSION_4_1, GL_ES_VERSION_3_1, GL_ARB_separate_shader_objects</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glProgramUniform4iv(GLuint program, GLint location, GLsizei count, const GLint * value);</para>
        /// </summary>
        public unsafe static void ProgramUniform4iv(uint program, int location, int count, ref int value) {
            fixed (int* pValue = &value) {
                GLNative.glProgramUniform4iv(program, location, count, pValue);
            }
        }

        /// <summary>
        /// Specify the value of a uniform variable for a specified program object
        /// <para>Require:</para> <para>GL_VERSION_4_1, GL_ES_VERSION_3_1, GL_ARB_separate_shader_objects</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glProgramUniform4fv(GLuint program, GLint location, GLsizei count, const GLfloat * value);</para>
        /// </summary>
        public unsafe static void ProgramUniform4fv(uint program, int location, int count, ref float value) {
            fixed (float* pValue = &value) {
                GLNative.glProgramUniform4fv(program, location, count, pValue);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_VERSION_4_1, GL_ARB_separate_shader_objects</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glProgramUniform4dv(GLuint program, GLint location, GLsizei count, const GLdouble * value);</para>
        /// </summary>
        public unsafe static void ProgramUniform4dv(uint program, int location, int count, ref double value) {
            fixed (double* pValue = &value) {
                GLNative.glProgramUniform4dv(program, location, count, pValue);
            }
        }

        /// <summary>
        /// Specify the value of a uniform variable for a specified program object
        /// <para>Require:</para> <para>GL_VERSION_4_1, GL_ES_VERSION_3_1, GL_ARB_separate_shader_objects</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glProgramUniform4uiv(GLuint program, GLint location, GLsizei count, const GLuint * value);</para>
        /// </summary>
        public unsafe static void ProgramUniform4uiv(uint program, int location, int count, ref uint value) {
            fixed (uint* pValue = &value) {
                GLNative.glProgramUniform4uiv(program, location, count, pValue);
            }
        }

        /// <summary>
        /// Specify the value of a uniform variable for a specified program object
        /// <para>Require:</para> <para>GL_VERSION_4_1, GL_ES_VERSION_3_1, GL_ARB_separate_shader_objects</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glProgramUniformMatrix2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);</para>
        /// </summary>
        public unsafe static void ProgramUniformMatrix2fv(uint program, int location, int count, bool transpose, ref float value) {
            fixed (float* pValue = &value) {
                GLNative.glProgramUniformMatrix2fv(program, location, count, transpose, pValue);
            }
        }

        /// <summary>
        /// Specify the value of a uniform variable for a specified program object
        /// <para>Require:</para> <para>GL_VERSION_4_1, GL_ES_VERSION_3_1, GL_ARB_separate_shader_objects</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glProgramUniformMatrix3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);</para>
        /// </summary>
        public unsafe static void ProgramUniformMatrix3fv(uint program, int location, int count, bool transpose, ref float value) {
            fixed (float* pValue = &value) {
                GLNative.glProgramUniformMatrix3fv(program, location, count, transpose, pValue);
            }
        }

        /// <summary>
        /// Specify the value of a uniform variable for a specified program object
        /// <para>Require:</para> <para>GL_VERSION_4_1, GL_ES_VERSION_3_1, GL_ARB_separate_shader_objects</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glProgramUniformMatrix4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);</para>
        /// </summary>
        public unsafe static void ProgramUniformMatrix4fv(uint program, int location, int count, bool transpose, ref float value) {
            fixed (float* pValue = &value) {
                GLNative.glProgramUniformMatrix4fv(program, location, count, transpose, pValue);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_VERSION_4_1, GL_ARB_separate_shader_objects</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glProgramUniformMatrix2dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);</para>
        /// </summary>
        public unsafe static void ProgramUniformMatrix2dv(uint program, int location, int count, bool transpose, ref double value) {
            fixed (double* pValue = &value) {
                GLNative.glProgramUniformMatrix2dv(program, location, count, transpose, pValue);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_VERSION_4_1, GL_ARB_separate_shader_objects</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glProgramUniformMatrix3dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);</para>
        /// </summary>
        public unsafe static void ProgramUniformMatrix3dv(uint program, int location, int count, bool transpose, ref double value) {
            fixed (double* pValue = &value) {
                GLNative.glProgramUniformMatrix3dv(program, location, count, transpose, pValue);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_VERSION_4_1, GL_ARB_separate_shader_objects</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glProgramUniformMatrix4dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);</para>
        /// </summary>
        public unsafe static void ProgramUniformMatrix4dv(uint program, int location, int count, bool transpose, ref double value) {
            fixed (double* pValue = &value) {
                GLNative.glProgramUniformMatrix4dv(program, location, count, transpose, pValue);
            }
        }

        /// <summary>
        /// Specify the value of a uniform variable for a specified program object
        /// <para>Require:</para> <para>GL_VERSION_4_1, GL_ES_VERSION_3_1, GL_ARB_separate_shader_objects</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glProgramUniformMatrix2x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);</para>
        /// </summary>
        public unsafe static void ProgramUniformMatrix2x3fv(uint program, int location, int count, bool transpose, ref float value) {
            fixed (float* pValue = &value) {
                GLNative.glProgramUniformMatrix2x3fv(program, location, count, transpose, pValue);
            }
        }

        /// <summary>
        /// Specify the value of a uniform variable for a specified program object
        /// <para>Require:</para> <para>GL_VERSION_4_1, GL_ES_VERSION_3_1, GL_ARB_separate_shader_objects</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glProgramUniformMatrix3x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);</para>
        /// </summary>
        public unsafe static void ProgramUniformMatrix3x2fv(uint program, int location, int count, bool transpose, ref float value) {
            fixed (float* pValue = &value) {
                GLNative.glProgramUniformMatrix3x2fv(program, location, count, transpose, pValue);
            }
        }

        /// <summary>
        /// Specify the value of a uniform variable for a specified program object
        /// <para>Require:</para> <para>GL_VERSION_4_1, GL_ES_VERSION_3_1, GL_ARB_separate_shader_objects</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glProgramUniformMatrix2x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);</para>
        /// </summary>
        public unsafe static void ProgramUniformMatrix2x4fv(uint program, int location, int count, bool transpose, ref float value) {
            fixed (float* pValue = &value) {
                GLNative.glProgramUniformMatrix2x4fv(program, location, count, transpose, pValue);
            }
        }

        /// <summary>
        /// Specify the value of a uniform variable for a specified program object
        /// <para>Require:</para> <para>GL_VERSION_4_1, GL_ES_VERSION_3_1, GL_ARB_separate_shader_objects</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glProgramUniformMatrix4x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);</para>
        /// </summary>
        public unsafe static void ProgramUniformMatrix4x2fv(uint program, int location, int count, bool transpose, ref float value) {
            fixed (float* pValue = &value) {
                GLNative.glProgramUniformMatrix4x2fv(program, location, count, transpose, pValue);
            }
        }

        /// <summary>
        /// Specify the value of a uniform variable for a specified program object
        /// <para>Require:</para> <para>GL_VERSION_4_1, GL_ES_VERSION_3_1, GL_ARB_separate_shader_objects</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glProgramUniformMatrix3x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);</para>
        /// </summary>
        public unsafe static void ProgramUniformMatrix3x4fv(uint program, int location, int count, bool transpose, ref float value) {
            fixed (float* pValue = &value) {
                GLNative.glProgramUniformMatrix3x4fv(program, location, count, transpose, pValue);
            }
        }

        /// <summary>
        /// Specify the value of a uniform variable for a specified program object
        /// <para>Require:</para> <para>GL_VERSION_4_1, GL_ES_VERSION_3_1, GL_ARB_separate_shader_objects</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glProgramUniformMatrix4x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);</para>
        /// </summary>
        public unsafe static void ProgramUniformMatrix4x3fv(uint program, int location, int count, bool transpose, ref float value) {
            fixed (float* pValue = &value) {
                GLNative.glProgramUniformMatrix4x3fv(program, location, count, transpose, pValue);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_VERSION_4_1, GL_ARB_separate_shader_objects</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glProgramUniformMatrix2x3dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);</para>
        /// </summary>
        public unsafe static void ProgramUniformMatrix2x3dv(uint program, int location, int count, bool transpose, ref double value) {
            fixed (double* pValue = &value) {
                GLNative.glProgramUniformMatrix2x3dv(program, location, count, transpose, pValue);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_VERSION_4_1, GL_ARB_separate_shader_objects</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glProgramUniformMatrix3x2dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);</para>
        /// </summary>
        public unsafe static void ProgramUniformMatrix3x2dv(uint program, int location, int count, bool transpose, ref double value) {
            fixed (double* pValue = &value) {
                GLNative.glProgramUniformMatrix3x2dv(program, location, count, transpose, pValue);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_VERSION_4_1, GL_ARB_separate_shader_objects</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glProgramUniformMatrix2x4dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);</para>
        /// </summary>
        public unsafe static void ProgramUniformMatrix2x4dv(uint program, int location, int count, bool transpose, ref double value) {
            fixed (double* pValue = &value) {
                GLNative.glProgramUniformMatrix2x4dv(program, location, count, transpose, pValue);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_VERSION_4_1, GL_ARB_separate_shader_objects</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glProgramUniformMatrix4x2dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);</para>
        /// </summary>
        public unsafe static void ProgramUniformMatrix4x2dv(uint program, int location, int count, bool transpose, ref double value) {
            fixed (double* pValue = &value) {
                GLNative.glProgramUniformMatrix4x2dv(program, location, count, transpose, pValue);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_VERSION_4_1, GL_ARB_separate_shader_objects</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glProgramUniformMatrix3x4dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);</para>
        /// </summary>
        public unsafe static void ProgramUniformMatrix3x4dv(uint program, int location, int count, bool transpose, ref double value) {
            fixed (double* pValue = &value) {
                GLNative.glProgramUniformMatrix3x4dv(program, location, count, transpose, pValue);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_VERSION_4_1, GL_ARB_separate_shader_objects</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glProgramUniformMatrix4x3dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);</para>
        /// </summary>
        public unsafe static void ProgramUniformMatrix4x3dv(uint program, int location, int count, bool transpose, ref double value) {
            fixed (double* pValue = &value) {
                GLNative.glProgramUniformMatrix4x3dv(program, location, count, transpose, pValue);
            }
        }

        /// <summary>
        /// retrieve the info log string from a program pipeline object
        /// <para>Require:</para> <para>GL_VERSION_4_1, GL_ES_VERSION_3_1, GL_ARB_separate_shader_objects</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetProgramPipelineInfoLog(GLuint pipeline, GLsizei bufSize, GLsizei * length, GLchar * infoLog);</para>
        /// </summary>
        public unsafe static void GetProgramPipelineInfoLog(uint pipeline, int bufSize, ref int length, ref byte infoLog) {
            fixed (int* pLength = &length)
            fixed (byte* pInfoLog = &infoLog) {
                GLNative.glGetProgramPipelineInfoLog(pipeline, bufSize, pLength, pInfoLog);
            }
        }


        #endregion Reuse commands from ARB_separate_shader_objects

        #region Reuse commands from ARB_vertex_attrib_64bit

        /// <summary>
        /// Specifies the value of a generic vertex attribute
        /// <para>Require:</para> <para>GL_VERSION_4_1, GL_ARB_vertex_attrib_64bit</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glVertexAttribL1dv(GLuint index, const GLdouble * v);</para>
        /// </summary>
        public unsafe static void VertexAttribL1dv(uint index, ref double v) {
            fixed (double* pV = &v) {
                GLNative.glVertexAttribL1dv(index, pV);
            }
        }

        /// <summary>
        /// Specifies the value of a generic vertex attribute
        /// <para>Require:</para> <para>GL_VERSION_4_1, GL_ARB_vertex_attrib_64bit</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glVertexAttribL2dv(GLuint index, const GLdouble * v);</para>
        /// </summary>
        public unsafe static void VertexAttribL2dv(uint index, ref double v) {
            fixed (double* pV = &v) {
                GLNative.glVertexAttribL2dv(index, pV);
            }
        }

        /// <summary>
        /// Specifies the value of a generic vertex attribute
        /// <para>Require:</para> <para>GL_VERSION_4_1, GL_ARB_vertex_attrib_64bit</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glVertexAttribL3dv(GLuint index, const GLdouble * v);</para>
        /// </summary>
        public unsafe static void VertexAttribL3dv(uint index, ref double v) {
            fixed (double* pV = &v) {
                GLNative.glVertexAttribL3dv(index, pV);
            }
        }

        /// <summary>
        /// Specifies the value of a generic vertex attribute
        /// <para>Require:</para> <para>GL_VERSION_4_1, GL_ARB_vertex_attrib_64bit</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glVertexAttribL4dv(GLuint index, const GLdouble * v);</para>
        /// </summary>
        public unsafe static void VertexAttribL4dv(uint index, ref double v) {
            fixed (double* pV = &v) {
                GLNative.glVertexAttribL4dv(index, pV);
            }
        }

        /// <summary>
        /// define an array of generic vertex attribute data
        /// <para>Require:</para> <para>GL_VERSION_4_1, GL_ARB_vertex_attrib_64bit</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glVertexAttribLPointer(GLuint index, GLint size, GLenum type, GLsizei stride, const void * pointer);</para>
        /// </summary>
        public unsafe static void VertexAttribLPointer(uint index, int size, uint type, int stride, IntPtr pointer) {
            GLNative.glVertexAttribLPointer(index, size, type, stride, (void*)pointer);
        }

        /// <summary>
        /// Return a generic vertex attribute parameter
        /// <para>Require:</para> <para>GL_VERSION_4_1, GL_ARB_vertex_attrib_64bit</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetVertexAttribLdv(GLuint index, GLenum pname, GLdouble * params);</para>
        /// </summary>
        public unsafe static void GetVertexAttribLdv(uint index, uint pname, ref double ps) {
            fixed (double* pPs = &ps) {
                GLNative.glGetVertexAttribLdv(index, pname, pPs);
            }
        }


        #endregion Reuse commands from ARB_vertex_attrib_64bit

        #region Reuse commands from ARB_viewport_array

        /// <summary>
        /// set multiple viewports
        /// <para>Require:</para> <para>GL_VERSION_4_1, GL_ARB_viewport_array</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glViewportArrayv(GLuint first, GLsizei count, const GLfloat * v);</para>
        /// </summary>
        public unsafe static void ViewportArrayv(uint first, int count, ref float v) {
            fixed (float* pV = &v) {
                GLNative.glViewportArrayv(first, count, pV);
            }
        }

        /// <summary>
        /// set a specified viewport
        /// <para>Require:</para> <para>GL_VERSION_4_1, GL_ARB_viewport_array</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glViewportIndexedfv(GLuint index, const GLfloat * v);</para>
        /// </summary>
        public unsafe static void ViewportIndexedfv(uint index, ref float v) {
            fixed (float* pV = &v) {
                GLNative.glViewportIndexedfv(index, pV);
            }
        }

        /// <summary>
        /// define the scissor box for multiple viewports
        /// <para>Require:</para> <para>GL_VERSION_4_1, GL_ARB_viewport_array</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glScissorArrayv(GLuint first, GLsizei count, const GLint * v);</para>
        /// </summary>
        public unsafe static void ScissorArrayv(uint first, int count, ref int v) {
            fixed (int* pV = &v) {
                GLNative.glScissorArrayv(first, count, pV);
            }
        }

        /// <summary>
        /// define the scissor box for a specific viewport
        /// <para>Require:</para> <para>GL_VERSION_4_1, GL_ARB_viewport_array</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glScissorIndexedv(GLuint index, const GLint * v);</para>
        /// </summary>
        public unsafe static void ScissorIndexedv(uint index, ref int v) {
            fixed (int* pV = &v) {
                GLNative.glScissorIndexedv(index, pV);
            }
        }

        /// <summary>
        /// specify mapping of depth values from normalized device coordinates to window coordinates for a specified set of viewports
        /// <para>Require:</para> <para>GL_VERSION_4_1, GL_ARB_viewport_array</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glDepthRangeArrayv(GLuint first, GLsizei count, const GLdouble * v);</para>
        /// </summary>
        public unsafe static void DepthRangeArrayv(uint first, int count, ref double v) {
            fixed (double* pV = &v) {
                GLNative.glDepthRangeArrayv(first, count, pV);
            }
        }

        /// <summary>
        /// return the value or values of a selected parameter
        /// <para>Require:</para> <para>GL_VERSION_4_1, GL_ARB_viewport_array</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetFloati_v(GLenum target, GLuint index, GLfloat * data);</para>
        /// </summary>
        public unsafe static void GetFloati_v(uint target, uint index, ref float data) {
            fixed (float* pData = &data) {
                GLNative.glGetFloati_v(target, index, pData);
            }
        }

        /// <summary>
        /// return the value or values of a selected parameter
        /// <para>Require:</para> <para>GL_VERSION_4_1, GL_ARB_viewport_array</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetDoublei_v(GLenum target, GLuint index, GLdouble * data);</para>
        /// </summary>
        public unsafe static void GetDoublei_v(uint target, uint index, ref double data) {
            fixed (double* pData = &data) {
                GLNative.glGetDoublei_v(target, index, pData);
            }
        }


        #endregion Reuse commands from ARB_viewport_array

        #endregion GL_VERSION_4_1

        #region GL_VERSION_4_2


        #region Reuse commands from ARB_base_instance

        /// <summary>
        /// draw multiple instances of a set of elements with offset applied to instanced attributes
        /// <para>Require:</para> <para>GL_VERSION_4_2, GL_ARB_base_instance</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glDrawElementsInstancedBaseInstance(GLenum mode, GLsizei count, GLenum type, const void * indices, GLsizei instancecount, GLuint baseinstance);</para>
        /// </summary>
        public unsafe static void DrawElementsInstancedBaseInstance(uint mode, int count, uint type, IntPtr indices, int instancecount, uint baseinstance) {
            GLNative.glDrawElementsInstancedBaseInstance(mode, count, type, (void*)indices, instancecount, baseinstance);
        }

        /// <summary>
        /// render multiple instances of a set of primitives from array data with a per-element offset
        /// <para>Require:</para> <para>GL_VERSION_4_2, GL_ARB_base_instance</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glDrawElementsInstancedBaseVertexBaseInstance(GLenum mode, GLsizei count, GLenum type, void * indices, GLsizei instancecount, GLint basevertex, GLuint baseinstance);</para>
        /// </summary>
        public unsafe static void DrawElementsInstancedBaseVertexBaseInstance(uint mode, int count, uint type, IntPtr indices, int instancecount, int basevertex, uint baseinstance) {
            GLNative.glDrawElementsInstancedBaseVertexBaseInstance(mode, count, type, (void*)indices, instancecount, basevertex, baseinstance);
        }


        #endregion Reuse commands from ARB_base_instance

        #region Reuse commands from ARB_internalformat_query

        /// <summary>
        /// retrieve information about implementation-dependent support for internal formats
        /// <para>Require:</para> <para>GL_VERSION_4_2, GL_ES_VERSION_3_0, GL_ARB_internalformat_query</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetInternalformativ(GLenum target, GLenum internalformat, GLenum pname, GLsizei bufSize, GLint * params);</para>
        /// </summary>
        public unsafe static void GetInternalformativ(uint target, uint internalformat, uint pname, int bufSize, ref int ps) {
            fixed (int* pPs = &ps) {
                GLNative.glGetInternalformativ(target, internalformat, pname, bufSize, pPs);
            }
        }


        #endregion Reuse commands from ARB_internalformat_query

        #region Reuse commands from ARB_shader_atomic_counters

        /// <summary>
        /// retrieve information about the set of active atomic counter buffers for a program
        /// <para>Require:</para> <para>GL_VERSION_4_2, GL_ARB_shader_atomic_counters</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetActiveAtomicCounterBufferiv(GLuint program, GLuint bufferIndex, GLenum pname, GLint * params);</para>
        /// </summary>
        public unsafe static void GetActiveAtomicCounterBufferiv(uint program, uint bufferIndex, uint pname, ref int ps) {
            fixed (int* pPs = &ps) {
                GLNative.glGetActiveAtomicCounterBufferiv(program, bufferIndex, pname, pPs);
            }
        }


        #endregion Reuse commands from ARB_shader_atomic_counters

        #region Reuse commands from ARB_shader_image_load_store


        #endregion Reuse commands from ARB_shader_image_load_store

        #region Reuse commands from ARB_texture_storage


        #endregion Reuse commands from ARB_texture_storage

        #region Reuse commands from ARB_transform_feedback_instanced


        #endregion Reuse commands from ARB_transform_feedback_instanced

        #endregion GL_VERSION_4_2

        #region GL_VERSION_4_3


        #region Reuse commands from ARB_clear_buffer_object

        /// <summary>
        /// fill a buffer object's data store with a fixed value
        /// <para>Require:</para> <para>GL_VERSION_4_3, GL_ARB_clear_buffer_object</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glClearBufferData(GLenum target, GLenum internalformat, GLenum format, GLenum type, const void * data);</para>
        /// </summary>
        public unsafe static void ClearBufferData(uint target, uint internalformat, uint format, uint type, IntPtr data) {
            GLNative.glClearBufferData(target, internalformat, format, type, (void*)data);
        }

        /// <summary>
        /// fill all or part of buffer object's data store with a fixed value
        /// <para>Require:</para> <para>GL_VERSION_4_3, GL_ARB_clear_buffer_object</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glClearBufferSubData(GLenum target, GLenum internalformat, GLintptr offset, GLsizeiptr size, GLenum format, GLenum type, const void * data);</para>
        /// </summary>
        public unsafe static void ClearBufferSubData(uint target, uint internalformat, IntPtr offset, IntPtr size, uint format, uint type, IntPtr data) {
            GLNative.glClearBufferSubData(target, internalformat, offset, size, format, type, (void*)data);
        }


        #endregion Reuse commands from ARB_clear_buffer_object

        #region Reuse commands from ARB_compute_shader


        #endregion Reuse commands from ARB_compute_shader

        #region Reuse commands from ARB_copy_image


        #endregion Reuse commands from ARB_copy_image

        #region Reuse commands from ARB_framebuffer_no_attachments

        /// <summary>
        /// query a named parameter of a framebuffer object
        /// <para>Require:</para> <para>GL_VERSION_4_3, GL_ES_VERSION_3_1, GL_ARB_framebuffer_no_attachments</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetFramebufferParameteriv(GLenum target, GLenum pname, GLint * params);</para>
        /// </summary>
        public unsafe static void GetFramebufferParameteriv(uint target, uint pname, ref int ps) {
            fixed (int* pPs = &ps) {
                GLNative.glGetFramebufferParameteriv(target, pname, pPs);
            }
        }


        #endregion Reuse commands from ARB_framebuffer_no_attachments

        #region Reuse commands from ARB_internalformat_query2

        /// <summary>
        /// retrieve information about implementation-dependent support for internal formats
        /// <para>Require:</para> <para>GL_VERSION_4_3, GL_ARB_internalformat_query2</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetInternalformati64v(GLenum target, GLenum internalformat, GLenum pname, GLsizei bufSize, GLint64 * params);</para>
        /// </summary>
        public unsafe static void GetInternalformati64v(uint target, uint internalformat, uint pname, int bufSize, ref UInt64 ps) {
            fixed (UInt64* pPs = &ps) {
                GLNative.glGetInternalformati64v(target, internalformat, pname, bufSize, pPs);
            }
        }


        #endregion Reuse commands from ARB_internalformat_query2

        #region Reuse commands from ARB_invalidate_subdata

        /// <summary>
        /// invalidate the content of some or all of a framebuffer's attachments
        /// <para>Require:</para> <para>GL_VERSION_4_3, GL_ES_VERSION_3_0, GL_ARB_invalidate_subdata</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glInvalidateFramebuffer(GLenum target, GLsizei numAttachments, const GLenum * attachments);</para>
        /// </summary>
        public unsafe static void InvalidateFramebuffer(uint target, int numAttachments, ref uint attachments) {
            fixed (uint* pAttachments = &attachments) {
                GLNative.glInvalidateFramebuffer(target, numAttachments, pAttachments);
            }
        }

        /// <summary>
        /// invalidate the content of a region of some or all of a framebuffer's attachments
        /// <para>Require:</para> <para>GL_VERSION_4_3, GL_ES_VERSION_3_0, GL_ARB_invalidate_subdata</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glInvalidateSubFramebuffer(GLenum target, GLsizei numAttachments, const GLenum * attachments, GLint x, GLint y, GLint width, GLint height);</para>
        /// </summary>
        public unsafe static void InvalidateSubFramebuffer(uint target, int numAttachments, ref uint attachments, int x, int y, int width, int height) {
            fixed (uint* pAttachments = &attachments) {
                GLNative.glInvalidateSubFramebuffer(target, numAttachments, pAttachments, x, y, width, height);
            }
        }


        #endregion Reuse commands from ARB_invalidate_subdata

        #region Reuse commands from ARB_multi_draw_indirect

        /// <summary>
        /// render multiple sets of primitives from array data, taking parameters from memory
        /// <para>Require:</para> <para>GL_VERSION_4_3, GL_ARB_multi_draw_indirect</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glMultiDrawArraysIndirect(GLenum mode, const void * indirect, GLsizei drawcount, GLsizei stride);</para>
        /// </summary>
        public unsafe static void MultiDrawArraysIndirect(uint mode, IntPtr indirect, int drawcount, int stride) {
            GLNative.glMultiDrawArraysIndirect(mode, (void*)indirect, drawcount, stride);
        }

        /// <summary>
        /// render indexed primitives from array data, taking parameters from memory
        /// <para>Require:</para> <para>GL_VERSION_4_3, GL_ARB_multi_draw_indirect</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glMultiDrawElementsIndirect(GLenum mode, GLenum type, const void * indirect, GLsizei drawcount, GLsizei stride);</para>
        /// </summary>
        public unsafe static void MultiDrawElementsIndirect(uint mode, uint type, IntPtr indirect, int drawcount, int stride) {
            GLNative.glMultiDrawElementsIndirect(mode, type, (void*)indirect, drawcount, stride);
        }


        #endregion Reuse commands from ARB_multi_draw_indirect

        #region Reuse commands from ARB_program_interface_query

        /// <summary>
        /// query a property of an interface in a program
        /// <para>Require:</para> <para>GL_VERSION_4_3, GL_ES_VERSION_3_1, GL_ARB_program_interface_query</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetProgramInterfaceiv(GLuint program, GLenum programInterface, GLenum pname, GLint * params);</para>
        /// </summary>
        public unsafe static void GetProgramInterfaceiv(uint program, uint programInterface, uint pname, ref int ps) {
            fixed (int* pPs = &ps) {
                GLNative.glGetProgramInterfaceiv(program, programInterface, pname, pPs);
            }
        }

        /// <summary>
        /// query the index of a named resource within a program
        /// <para>Require:</para> <para>GL_VERSION_4_3, GL_ES_VERSION_3_1, GL_ARB_program_interface_query</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>GLuint glGetProgramResourceIndex(GLuint program, GLenum programInterface, const char * name);</para>
        /// </summary>
        public unsafe static uint GetProgramResourceIndex(uint program, uint programInterface, ref byte name) {
            fixed (byte* pName = &name) {
                return GLNative.glGetProgramResourceIndex(program, programInterface, pName);
            }
        }

        /// <summary>
        /// query the name of an indexed resource within a program
        /// <para>Require:</para> <para>GL_VERSION_4_3, GL_ES_VERSION_3_1, GL_ARB_program_interface_query</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetProgramResourceName(GLuint program, GLenum programInterface, GLuint index, GLsizei bufSize, GLsizei * length, char * name);</para>
        /// </summary>
        public unsafe static void GetProgramResourceName(uint program, uint programInterface, uint index, int bufSize, ref int length, ref byte name) {
            fixed (int* pLength = &length)
            fixed (byte* pName = &name) {
                GLNative.glGetProgramResourceName(program, programInterface, index, bufSize, pLength, pName);
            }
        }

        /// <summary>
        /// retrieve values for multiple properties of a single active resource within a program object
        /// <para>Require:</para> <para>GL_VERSION_4_3, GL_ES_VERSION_3_1, GL_ARB_program_interface_query</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetProgramResourceiv(GLuint program, GLenum programInterface, GLuint index, GLsizei propCount, const GLenum * props, GLsizei bufSize, GLsizei * length, GLint * params);</para>
        /// </summary>
        public unsafe static void GetProgramResourceiv(uint program, uint programInterface, uint index, int propCount, ref uint props, int bufSize, ref int length, ref int ps) {
            fixed (uint* pProps = &props)
            fixed (int* pLength = &length)
            fixed (int* pPs = &ps) {
                GLNative.glGetProgramResourceiv(program, programInterface, index, propCount, pProps, bufSize, pLength, pPs);
            }
        }

        /// <summary>
        /// query the location of a named resource within a program
        /// <para>Require:</para> <para>GL_VERSION_4_3, GL_ES_VERSION_3_1, GL_ARB_program_interface_query</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>GLint glGetProgramResourceLocation(GLuint program, GLenum programInterface, const char * name);</para>
        /// </summary>
        public unsafe static int GetProgramResourceLocation(uint program, uint programInterface, ref byte name) {
            fixed (byte* pName = &name) {
                return GLNative.glGetProgramResourceLocation(program, programInterface, pName);
            }
        }

        /// <summary>
        /// query the fragment color index of a named variable within a program
        /// <para>Require:</para> <para>GL_VERSION_4_3, GL_ARB_program_interface_query</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>GLint glGetProgramResourceLocationIndex(GLuint program, GLenum programInterface, const char * name);</para>
        /// </summary>
        public unsafe static int GetProgramResourceLocationIndex(uint program, uint programInterface, ref byte name) {
            fixed (byte* pName = &name) {
                return GLNative.glGetProgramResourceLocationIndex(program, programInterface, pName);
            }
        }


        #endregion Reuse commands from ARB_program_interface_query

        #region Reuse commands from ARB_shader_storage_buffer_object


        #endregion Reuse commands from ARB_shader_storage_buffer_object

        #region Reuse commands from ARB_texture_buffer_range


        #endregion Reuse commands from ARB_texture_buffer_range

        #region Reuse commands from ARB_texture_storage_multisample


        #endregion Reuse commands from ARB_texture_storage_multisample

        #region Reuse commands from ARB_texture_view


        #endregion Reuse commands from ARB_texture_view

        #region Reuse commands from ARB_vertex_attrib_binding


        #endregion Reuse commands from ARB_vertex_attrib_binding

        #region Reuse commands from KHR_debug (includes ARB_debug_output commands promoted to KHR without suffixes)

        /// <summary>
        /// control the reporting of debug messages in a debug context
        /// <para>Require:</para> <para>GL_VERSION_4_3, GL_ES_VERSION_3_2, GL_KHR_debug</para>
        /// Supported: <para>gl, glcore, gles1, gles2</para>
        /// Original: <para>void glDebugMessageControl(GLenum source, GLenum type, GLenum severity, GLsizei count, const GLuint * ids, GLboolean enabled);</para>
        /// </summary>
        public unsafe static void DebugMessageControl(uint source, uint type, uint severity, int count, ref uint ids, bool enabled) {
            fixed (uint* pIds = &ids) {
                GLNative.glDebugMessageControl(source, type, severity, count, pIds, enabled);
            }
        }

        /// <summary>
        /// inject an application-supplied message into the debug message queue
        /// <para>Require:</para> <para>GL_VERSION_4_3, GL_ES_VERSION_3_2, GL_KHR_debug</para>
        /// Supported: <para>gl, glcore, gles1, gles2</para>
        /// Original: <para>void glDebugMessageInsert(GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const char * message);</para>
        /// </summary>
        public unsafe static void DebugMessageInsert(uint source, uint type, uint id, uint severity, int length, ref byte message) {
            fixed (byte* pMessage = &message) {
                GLNative.glDebugMessageInsert(source, type, id, severity, length, pMessage);
            }
        }

        /// <summary>
        /// specify a callback to receive debugging messages from the GL
        /// <para>Require:</para> <para>GL_VERSION_4_3, GL_ES_VERSION_3_2, GL_KHR_debug</para>
        /// Supported: <para>gl, glcore, gles1, gles2</para>
        /// Original: <para>void glDebugMessageCallback(GLDEBUGPROC callback, const void * userParam);</para>
        /// </summary>
        public unsafe static void DebugMessageCallback(GLNativeDelegate.GLDEBUGPROC callback, IntPtr userParam) {
            GLNative.glDebugMessageCallback(callback, (void*)userParam);
        }

        /// <summary>
        /// retrieve messages from the debug message log
        /// <para>Require:</para> <para>GL_VERSION_4_3, GL_ES_VERSION_3_2, GL_KHR_debug</para>
        /// Supported: <para>gl, glcore, gles1, gles2</para>
        /// Original: <para>GLuint glGetDebugMessageLog(GLuint count, GLsizei bufSize, GLenum * sources, GLenum * types, GLuint * ids, GLenum * severities, GLsizei * lengths, GLchar * messageLog);</para>
        /// </summary>
        public unsafe static uint GetDebugMessageLog(uint count, int bufSize, ref uint sources, ref uint types, ref uint ids, ref uint severities, ref int lengths, ref byte messageLog) {
            fixed (uint* pSources = &sources)
            fixed (uint* pTypes = &types)
            fixed (uint* pIds = &ids)
            fixed (uint* pSeverities = &severities)
            fixed (int* pLengths = &lengths)
            fixed (byte* pMessageLog = &messageLog) {
                return GLNative.glGetDebugMessageLog(count, bufSize, pSources, pTypes, pIds, pSeverities, pLengths, pMessageLog);
            }
        }

        /// <summary>
        /// push a named debug group into the command stream
        /// <para>Require:</para> <para>GL_VERSION_4_3, GL_ES_VERSION_3_2, GL_KHR_debug</para>
        /// Supported: <para>gl, glcore, gles1, gles2</para>
        /// Original: <para>void glPushDebugGroup(GLenum source, GLuint id, GLsizei length, const char * message);</para>
        /// </summary>
        public unsafe static void PushDebugGroup(uint source, uint id, int length, ref byte message) {
            fixed (byte* pMessage = &message) {
                GLNative.glPushDebugGroup(source, id, length, pMessage);
            }
        }

        /// <summary>
        /// label a named object identified within a namespace
        /// <para>Require:</para> <para>GL_VERSION_4_3, GL_ES_VERSION_3_2, GL_KHR_debug</para>
        /// Supported: <para>gl, glcore, gles1, gles2</para>
        /// Original: <para>void glObjectLabel(GLenum identifier, GLuint name, GLsizei length, const char * label);</para>
        /// </summary>
        public unsafe static void ObjectLabel(uint identifier, uint name, int length, ref byte label) {
            fixed (byte* pLabel = &label) {
                GLNative.glObjectLabel(identifier, name, length, pLabel);
            }
        }

        /// <summary>
        /// retrieve the label of a named object identified within a namespace
        /// <para>Require:</para> <para>GL_VERSION_4_3, GL_ES_VERSION_3_2, GL_KHR_debug</para>
        /// Supported: <para>gl, glcore, gles1, gles2</para>
        /// Original: <para>void glGetObjectLabel(GLenum identifier, GLuint name, GLsizei bufSize, GLsizei * length, char * label);</para>
        /// </summary>
        public unsafe static void GetObjectLabel(uint identifier, uint name, int bufSize, ref int length, ref byte label) {
            fixed (int* pLength = &length)
            fixed (byte* pLabel = &label) {
                GLNative.glGetObjectLabel(identifier, name, bufSize, pLength, pLabel);
            }
        }

        /// <summary>
        /// label a sync object identified by a pointer
        /// <para>Require:</para> <para>GL_VERSION_4_3, GL_ES_VERSION_3_2, GL_KHR_debug</para>
        /// Supported: <para>gl, glcore, gles1, gles2</para>
        /// Original: <para>void glObjectPtrLabel(void * ptr, GLsizei length, const char * label);</para>
        /// </summary>
        public unsafe static void ObjectPtrLabel(IntPtr ptr, int length, ref byte label) {
            fixed (byte* pLabel = &label) {
                GLNative.glObjectPtrLabel((void*)ptr, length, pLabel);
            }
        }

        /// <summary>
        /// retrieve the label of a sync object identified by a pointer
        /// <para>Require:</para> <para>GL_VERSION_4_3, GL_ES_VERSION_3_2, GL_KHR_debug</para>
        /// Supported: <para>gl, glcore, gles1, gles2</para>
        /// Original: <para>void glGetObjectPtrLabel(void * ptr, GLsizei bufSize, GLsizei * length, char * label);</para>
        /// </summary>
        public unsafe static void GetObjectPtrLabel(IntPtr ptr, int bufSize, ref int length, ref byte label) {
            fixed (int* pLength = &length)
            fixed (byte* pLabel = &label) {
                GLNative.glGetObjectPtrLabel((void*)ptr, bufSize, pLength, pLabel);
            }
        }

        // void glGetPointerv(GLenum pname, void ** ps);

        #endregion Reuse commands from KHR_debug (includes ARB_debug_output commands promoted to KHR without suffixes)

        #endregion GL_VERSION_4_3

        #region GL_VERSION_4_4


        #region Reuse GL_ARB_buffer_storage

        /// <summary>
        /// <para>
        /// creates and initializes a buffer object's immutable data
        /// store
        /// </para>
        /// <para>Require:</para> <para>GL_VERSION_4_4, GL_ARB_buffer_storage</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glBufferStorage(GLenum target, GLsizeiptr size, const void * data, GLbitfield flags);</para>
        /// </summary>
        public unsafe static void BufferStorage(uint target, IntPtr size, IntPtr data, uint flags) {
            GLNative.glBufferStorage(target, size, (void*)data, flags);
        }


        #endregion Reuse GL_ARB_buffer_storage

        #region Reuse GL_ARB_clear_texture

        /// <summary>
        /// fills all a texture image with a constant value
        /// <para>Require:</para> <para>GL_VERSION_4_4, GL_ARB_clear_texture</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glClearTexImage(GLuint texture, GLint level, GLenum format, GLenum type, const void * data);</para>
        /// </summary>
        public unsafe static void ClearTexImage(uint texture, int level, uint format, uint type, IntPtr data) {
            GLNative.glClearTexImage(texture, level, format, type, (void*)data);
        }

        /// <summary>
        /// fills all or part of a texture image with a constant value
        /// <para>Require:</para> <para>GL_VERSION_4_4, GL_ARB_clear_texture</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glClearTexSubImage(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void * data);</para>
        /// </summary>
        public unsafe static void ClearTexSubImage(uint texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, uint format, uint type, IntPtr data) {
            GLNative.glClearTexSubImage(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, type, (void*)data);
        }


        #endregion Reuse GL_ARB_clear_texture

        #region Reuse GL_ARB_multi_bind (none)

        /// <summary>
        /// bind one or more buffer objects to a sequence of indexed buffer targets
        /// <para>Require:</para> <para>GL_VERSION_4_4, GL_ARB_multi_bind</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glBindBuffersBase(GLenum target, GLuint first, GLsizei count, const GLuint * buffers);</para>
        /// </summary>
        public unsafe static void BindBuffersBase(uint target, uint first, int count, ref uint buffers) {
            fixed (uint* pBuffers = &buffers) {
                GLNative.glBindBuffersBase(target, first, count, pBuffers);
            }
        }

        /// <summary>
        /// bind ranges of one or more buffer objects to a sequence of indexed buffer targets
        /// <para>Require:</para> <para>GL_VERSION_4_4, GL_ARB_multi_bind</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glBindBuffersRange(GLenum target, GLuint first, GLsizei count, const GLuint * buffers, const GLintptr * offsets, const GLintptr * sizes);</para>
        /// </summary>
        public unsafe static void BindBuffersRange(uint target, uint first, int count, ref uint buffers, IntPtr offsets, IntPtr sizes) {
            fixed (uint* pBuffers = &buffers) {
                GLNative.glBindBuffersRange(target, first, count, pBuffers, offsets, sizes);
            }
        }

        /// <summary>
        /// bind one or more named textures to a sequence of consecutive texture units
        /// <para>Require:</para> <para>GL_VERSION_4_4, GL_ARB_multi_bind</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glBindTextures(GLuint first, GLsizei count, const GLuint * textures);</para>
        /// </summary>
        public unsafe static void BindTextures(uint first, int count, ref uint textures) {
            fixed (uint* pTextures = &textures) {
                GLNative.glBindTextures(first, count, pTextures);
            }
        }

        /// <summary>
        /// bind one or more named sampler objects to a sequence of consecutive sampler units
        /// <para>Require:</para> <para>GL_VERSION_4_4, GL_ARB_multi_bind</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glBindSamplers(GLuint first, GLsizei count, const GLuint * samplers);</para>
        /// </summary>
        public unsafe static void BindSamplers(uint first, int count, ref uint samplers) {
            fixed (uint* pSamplers = &samplers) {
                GLNative.glBindSamplers(first, count, pSamplers);
            }
        }

        /// <summary>
        /// bind one or more named texture images to a sequence of consecutive image units
        /// <para>Require:</para> <para>GL_VERSION_4_4, GL_ARB_multi_bind</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glBindImageTextures(GLuint first, GLsizei count, const GLuint * textures);</para>
        /// </summary>
        public unsafe static void BindImageTextures(uint first, int count, ref uint textures) {
            fixed (uint* pTextures = &textures) {
                GLNative.glBindImageTextures(first, count, pTextures);
            }
        }

        /// <summary>
        /// attach multiple buffer objects to a vertex array object
        /// <para>Require:</para> <para>GL_VERSION_4_4, GL_ARB_multi_bind</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glBindVertexBuffers(GLuint first, GLsizei count, const GLuint * buffers, const GLintptr * offsets, const GLsizei * strides);</para>
        /// </summary>
        public unsafe static void BindVertexBuffers(uint first, int count, ref uint buffers, IntPtr offsets, ref int strides) {
            fixed (uint* pBuffers = &buffers)
            fixed (int* pStrides = &strides) {
                GLNative.glBindVertexBuffers(first, count, pBuffers, offsets, pStrides);
            }
        }


        #endregion Reuse GL_ARB_multi_bind (none)

        #endregion GL_VERSION_4_4

        #region GL_VERSION_4_5


        #region Reuse GL_ARB_clip_control


        #endregion Reuse GL_ARB_clip_control

        #region Reuse GL_ARB_direct_state_access

        /// <summary>
        /// create transform feedback objects
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glCreateTransformFeedbacks(GLsizei n, GLuint * ids);</para>
        /// </summary>
        public unsafe static void CreateTransformFeedbacks(int n, ref uint ids) {
            fixed (uint* pIds = &ids) {
                GLNative.glCreateTransformFeedbacks(n, pIds);
            }
        }

        /// <summary>
        /// query the state of a transform feedback object.
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetTransformFeedbackiv(GLuint xfb, GLenum pname, GLint * param);</para>
        /// </summary>
        public unsafe static void GetTransformFeedbackiv(uint xfb, uint pname, ref int param) {
            fixed (int* pParam = &param) {
                GLNative.glGetTransformFeedbackiv(xfb, pname, pParam);
            }
        }

        /// <summary>
        /// query the state of a transform feedback object.
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetTransformFeedbacki_v(GLuint xfb, GLenum pname, GLuint index, GLint * param);</para>
        /// </summary>
        public unsafe static void GetTransformFeedbacki_v(uint xfb, uint pname, uint index, ref int param) {
            fixed (int* pParam = &param) {
                GLNative.glGetTransformFeedbacki_v(xfb, pname, index, pParam);
            }
        }

        /// <summary>
        /// query the state of a transform feedback object.
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetTransformFeedbacki64_v(GLuint xfb, GLenum pname, GLuint index, GLint64 * param);</para>
        /// </summary>
        public unsafe static void GetTransformFeedbacki64_v(uint xfb, uint pname, uint index, ref UInt64 param) {
            fixed (UInt64* pParam = &param) {
                GLNative.glGetTransformFeedbacki64_v(xfb, pname, index, pParam);
            }
        }

        /// <summary>
        /// create buffer objects
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glCreateBuffers(GLsizei n, GLuint * buffers);</para>
        /// </summary>
        public unsafe static void CreateBuffers(int n, ref uint buffers) {
            fixed (uint* pBuffers = &buffers) {
                GLNative.glCreateBuffers(n, pBuffers);
            }
        }

        /// <summary>
        /// <para>
        /// creates and initializes a buffer object's immutable data
        /// store
        /// </para>
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glNamedBufferStorage(GLuint buffer, GLsizeiptr size, const void * data, GLbitfield flags);</para>
        /// </summary>
        public unsafe static void NamedBufferStorage(uint buffer, IntPtr size, IntPtr data, uint flags) {
            GLNative.glNamedBufferStorage(buffer, size, (void*)data, flags);
        }

        /// <summary>
        /// <para>
        /// creates and initializes a buffer object's data
        /// store
        /// </para>
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glNamedBufferData(GLuint buffer, GLsizeiptr size, const void * data, GLenum usage);</para>
        /// </summary>
        public unsafe static void NamedBufferData(uint buffer, IntPtr size, IntPtr data, uint usage) {
            GLNative.glNamedBufferData(buffer, size, (void*)data, usage);
        }

        /// <summary>
        /// updates a subset of a buffer object's data store
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glNamedBufferSubData(GLuint buffer, GLintptr offset, GLsizeiptr size, const void * data);</para>
        /// </summary>
        public unsafe static void NamedBufferSubData(uint buffer, IntPtr offset, IntPtr size, IntPtr data) {
            GLNative.glNamedBufferSubData(buffer, offset, size, (void*)data);
        }

        /// <summary>
        /// fill a buffer object's data store with a fixed value
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glClearNamedBufferData(GLuint buffer, GLenum internalformat, GLenum format, GLenum type, const void * data);</para>
        /// </summary>
        public unsafe static void ClearNamedBufferData(uint buffer, uint internalformat, uint format, uint type, IntPtr data) {
            GLNative.glClearNamedBufferData(buffer, internalformat, format, type, (void*)data);
        }

        /// <summary>
        /// fill all or part of buffer object's data store with a fixed value
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glClearNamedBufferSubData(GLuint buffer, GLenum internalformat, GLintptr offset, GLsizeiptr size, GLenum format, GLenum type, const void * data);</para>
        /// </summary>
        public unsafe static void ClearNamedBufferSubData(uint buffer, uint internalformat, IntPtr offset, IntPtr size, uint format, uint type, IntPtr data) {
            GLNative.glClearNamedBufferSubData(buffer, internalformat, offset, size, format, type, (void*)data);
        }

        /// <summary>
        /// map all of a buffer object's data store into the client's address space
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void * glMapNamedBuffer(GLuint buffer, GLenum access);</para>
        /// </summary>
        public unsafe static IntPtr MapNamedBuffer(uint buffer, uint access) {
            return (IntPtr)GLNative.glMapNamedBuffer(buffer, access);
        }

        /// <summary>
        /// map all or part of a buffer object's data store into the client's address space
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void * glMapNamedBufferRange(GLuint buffer, GLintptr offset, GLsizeiptr length, GLbitfield access);</para>
        /// </summary>
        public unsafe static IntPtr MapNamedBufferRange(uint buffer, IntPtr offset, IntPtr length, uint access) {
            return (IntPtr)GLNative.glMapNamedBufferRange(buffer, offset, length, access);
        }

        /// <summary>
        /// return parameters of a buffer object
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetNamedBufferParameteriv(GLuint buffer, GLenum pname, GLint * params);</para>
        /// </summary>
        public unsafe static void GetNamedBufferParameteriv(uint buffer, uint pname, ref int ps) {
            fixed (int* pPs = &ps) {
                GLNative.glGetNamedBufferParameteriv(buffer, pname, pPs);
            }
        }

        /// <summary>
        /// return parameters of a buffer object
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetNamedBufferParameteri64v(GLuint buffer, GLenum pname, GLint64 * params);</para>
        /// </summary>
        public unsafe static void GetNamedBufferParameteri64v(uint buffer, uint pname, ref UInt64 ps) {
            fixed (UInt64* pPs = &ps) {
                GLNative.glGetNamedBufferParameteri64v(buffer, pname, pPs);
            }
        }

        /// <summary>
        /// return the pointer to a mapped buffer object's data store
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetNamedBufferPointerv(GLuint buffer, GLenum pname, void ** params);</para>
        /// </summary>
        public unsafe static void GetNamedBufferPointerv(uint buffer, uint pname, IntPtr ps) {
            GLNative.glGetNamedBufferPointerv(buffer, pname, (void**)ps);
        }

        /// <summary>
        /// returns a subset of a buffer object's data store
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetNamedBufferSubData(GLuint buffer, GLintptr offset, GLsizeiptr size, void * data);</para>
        /// </summary>
        public unsafe static void GetNamedBufferSubData(uint buffer, IntPtr offset, IntPtr size, IntPtr data) {
            GLNative.glGetNamedBufferSubData(buffer, offset, size, (void*)data);
        }

        /// <summary>
        /// create framebuffer objects
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glCreateFramebuffers(GLsizei n, GLuint * framebuffers);</para>
        /// </summary>
        public unsafe static void CreateFramebuffers(int n, ref uint framebuffers) {
            fixed (uint* pFramebuffers = &framebuffers) {
                GLNative.glCreateFramebuffers(n, pFramebuffers);
            }
        }

        /// <summary>
        /// <para>
        /// Specifies a list of color buffers to be drawn
        /// into
        /// </para>
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glNamedFramebufferDrawBuffers(GLuint framebuffer, GLsizei n, const GLenum * bufs);</para>
        /// </summary>
        public unsafe static void NamedFramebufferDrawBuffers(uint framebuffer, int n, ref uint bufs) {
            fixed (uint* pBufs = &bufs) {
                GLNative.glNamedFramebufferDrawBuffers(framebuffer, n, pBufs);
            }
        }

        /// <summary>
        /// invalidate the content of some or all of a framebuffer's attachments
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glInvalidateNamedFramebufferData(GLuint framebuffer, GLsizei numAttachments, const GLenum * attachments);</para>
        /// </summary>
        public unsafe static void InvalidateNamedFramebufferData(uint framebuffer, int numAttachments, ref uint attachments) {
            fixed (uint* pAttachments = &attachments) {
                GLNative.glInvalidateNamedFramebufferData(framebuffer, numAttachments, pAttachments);
            }
        }

        /// <summary>
        /// invalidate the content of a region of some or all of a framebuffer's attachments
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glInvalidateNamedFramebufferSubData(GLuint framebuffer, GLsizei numAttachments, const GLenum * attachments, GLint x, GLint y, GLsizei width, GLsizei height);</para>
        /// </summary>
        public unsafe static void InvalidateNamedFramebufferSubData(uint framebuffer, int numAttachments, ref uint attachments, int x, int y, int width, int height) {
            fixed (uint* pAttachments = &attachments) {
                GLNative.glInvalidateNamedFramebufferSubData(framebuffer, numAttachments, pAttachments, x, y, width, height);
            }
        }

        /// <summary>
        /// clear individual buffers of a framebuffer
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glClearNamedFramebufferiv(GLuint framebuffer, GLenum buffer, GLint drawbuffer, const GLint * value);</para>
        /// </summary>
        public unsafe static void ClearNamedFramebufferiv(uint framebuffer, uint buffer, int drawbuffer, ref int value) {
            fixed (int* pValue = &value) {
                GLNative.glClearNamedFramebufferiv(framebuffer, buffer, drawbuffer, pValue);
            }
        }

        /// <summary>
        /// clear individual buffers of a framebuffer
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glClearNamedFramebufferuiv(GLuint framebuffer, GLenum buffer, GLint drawbuffer, const GLuint * value);</para>
        /// </summary>
        public unsafe static void ClearNamedFramebufferuiv(uint framebuffer, uint buffer, int drawbuffer, ref uint value) {
            fixed (uint* pValue = &value) {
                GLNative.glClearNamedFramebufferuiv(framebuffer, buffer, drawbuffer, pValue);
            }
        }

        /// <summary>
        /// clear individual buffers of a framebuffer
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glClearNamedFramebufferfv(GLuint framebuffer, GLenum buffer, GLint drawbuffer, const GLfloat * value);</para>
        /// </summary>
        public unsafe static void ClearNamedFramebufferfv(uint framebuffer, uint buffer, int drawbuffer, ref float value) {
            fixed (float* pValue = &value) {
                GLNative.glClearNamedFramebufferfv(framebuffer, buffer, drawbuffer, pValue);
            }
        }

        /// <summary>
        /// query a named parameter of a framebuffer object
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetNamedFramebufferParameteriv(GLuint framebuffer, GLenum pname, GLint * param);</para>
        /// </summary>
        public unsafe static void GetNamedFramebufferParameteriv(uint framebuffer, uint pname, ref int param) {
            fixed (int* pParam = &param) {
                GLNative.glGetNamedFramebufferParameteriv(framebuffer, pname, pParam);
            }
        }

        /// <summary>
        /// retrieve information about attachments of a framebuffer object
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetNamedFramebufferAttachmentParameteriv(GLuint framebuffer, GLenum attachment, GLenum pname, GLint * params);</para>
        /// </summary>
        public unsafe static void GetNamedFramebufferAttachmentParameteriv(uint framebuffer, uint attachment, uint pname, ref int ps) {
            fixed (int* pPs = &ps) {
                GLNative.glGetNamedFramebufferAttachmentParameteriv(framebuffer, attachment, pname, pPs);
            }
        }

        /// <summary>
        /// create renderbuffer objects
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glCreateRenderbuffers(GLsizei n, GLuint * renderbuffers);</para>
        /// </summary>
        public unsafe static void CreateRenderbuffers(int n, ref uint renderbuffers) {
            fixed (uint* pRenderbuffers = &renderbuffers) {
                GLNative.glCreateRenderbuffers(n, pRenderbuffers);
            }
        }

        /// <summary>
        /// query a named parameter of a renderbuffer object
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetNamedRenderbufferParameteriv(GLuint renderbuffer, GLenum pname, GLint * params);</para>
        /// </summary>
        public unsafe static void GetNamedRenderbufferParameteriv(uint renderbuffer, uint pname, ref int ps) {
            fixed (int* pPs = &ps) {
                GLNative.glGetNamedRenderbufferParameteriv(renderbuffer, pname, pPs);
            }
        }

        /// <summary>
        /// create texture objects
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glCreateTextures(GLenum target, GLsizei n, GLuint * textures);</para>
        /// </summary>
        public unsafe static void CreateTextures(uint target, int n, ref uint textures) {
            fixed (uint* pTextures = &textures) {
                GLNative.glCreateTextures(target, n, pTextures);
            }
        }

        /// <summary>
        /// specify a one-dimensional texture subimage
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glTextureSubImage1D(GLuint texture, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const void * pixels);</para>
        /// </summary>
        public unsafe static void TextureSubImage1D(uint texture, int level, int xoffset, int width, uint format, uint type, IntPtr pixels) {
            GLNative.glTextureSubImage1D(texture, level, xoffset, width, format, type, (void*)pixels);
        }

        /// <summary>
        /// specify a two-dimensional texture subimage
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glTextureSubImage2D(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const void * pixels);</para>
        /// </summary>
        public unsafe static void TextureSubImage2D(uint texture, int level, int xoffset, int yoffset, int width, int height, uint format, uint type, IntPtr pixels) {
            GLNative.glTextureSubImage2D(texture, level, xoffset, yoffset, width, height, format, type, (void*)pixels);
        }

        /// <summary>
        /// specify a three-dimensional texture subimage
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glTextureSubImage3D(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void * pixels);</para>
        /// </summary>
        public unsafe static void TextureSubImage3D(uint texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, uint format, uint type, IntPtr pixels) {
            GLNative.glTextureSubImage3D(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, type, (void*)pixels);
        }

        /// <summary>
        /// <para>
        /// specify a one-dimensional texture subimage in a compressed
        /// format
        /// </para>
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glCompressedTextureSubImage1D(GLuint texture, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const void * data);</para>
        /// </summary>
        public unsafe static void CompressedTextureSubImage1D(uint texture, int level, int xoffset, int width, uint format, int imageSize, IntPtr data) {
            GLNative.glCompressedTextureSubImage1D(texture, level, xoffset, width, format, imageSize, (void*)data);
        }

        /// <summary>
        /// specify a two-dimensional texture subimage in a compressed format
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glCompressedTextureSubImage2D(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void * data);</para>
        /// </summary>
        public unsafe static void CompressedTextureSubImage2D(uint texture, int level, int xoffset, int yoffset, int width, int height, uint format, int imageSize, IntPtr data) {
            GLNative.glCompressedTextureSubImage2D(texture, level, xoffset, yoffset, width, height, format, imageSize, (void*)data);
        }

        /// <summary>
        /// specify a three-dimensional texture subimage in a compressed format
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glCompressedTextureSubImage3D(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void * data);</para>
        /// </summary>
        public unsafe static void CompressedTextureSubImage3D(uint texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, uint format, int imageSize, IntPtr data) {
            GLNative.glCompressedTextureSubImage3D(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, (void*)data);
        }

        /// <summary>
        /// set texture parameters
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glTextureParameterfv(GLuint texture, GLenum pname, const GLfloat * params);</para>
        /// </summary>
        public unsafe static void TextureParameterfv(uint texture, uint pname, ref float ps) {
            fixed (float* pPs = &ps) {
                GLNative.glTextureParameterfv(texture, pname, pPs);
            }
        }

        /// <summary>
        /// set texture parameters
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glTextureParameterIiv(GLuint texture, GLenum pname, const GLint * params);</para>
        /// </summary>
        public unsafe static void TextureParameterIiv(uint texture, uint pname, ref int ps) {
            fixed (int* pPs = &ps) {
                GLNative.glTextureParameterIiv(texture, pname, pPs);
            }
        }

        /// <summary>
        /// set texture parameters
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glTextureParameterIuiv(GLuint texture, GLenum pname, const GLuint * params);</para>
        /// </summary>
        public unsafe static void TextureParameterIuiv(uint texture, uint pname, ref uint ps) {
            fixed (uint* pPs = &ps) {
                GLNative.glTextureParameterIuiv(texture, pname, pPs);
            }
        }

        /// <summary>
        /// set texture parameters
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glTextureParameteriv(GLuint texture, GLenum pname, const GLint * params);</para>
        /// </summary>
        public unsafe static void TextureParameteriv(uint texture, uint pname, ref int ps) {
            fixed (int* pPs = &ps) {
                GLNative.glTextureParameteriv(texture, pname, pPs);
            }
        }

        /// <summary>
        /// return a texture image
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetTextureImage(GLuint texture, GLint level, GLenum format, GLenum type, GLsizei bufSize, void * pixels);</para>
        /// </summary>
        public unsafe static void GetTextureImage(uint texture, int level, uint format, uint type, int bufSize, IntPtr pixels) {
            GLNative.glGetTextureImage(texture, level, format, type, bufSize, (void*)pixels);
        }

        /// <summary>
        /// return a compressed texture image
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetCompressedTextureImage(GLuint texture, GLint level, GLsizei bufSize, void * pixels);</para>
        /// </summary>
        public unsafe static void GetCompressedTextureImage(uint texture, int level, int bufSize, IntPtr pixels) {
            GLNative.glGetCompressedTextureImage(texture, level, bufSize, (void*)pixels);
        }

        /// <summary>
        /// <para>
        /// return texture parameter values for a specific level of
        /// detail
        /// </para>
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetTextureLevelParameterfv(GLuint texture, GLint level, GLenum pname, GLfloat * params);</para>
        /// </summary>
        public unsafe static void GetTextureLevelParameterfv(uint texture, int level, uint pname, ref float ps) {
            fixed (float* pPs = &ps) {
                GLNative.glGetTextureLevelParameterfv(texture, level, pname, pPs);
            }
        }

        /// <summary>
        /// <para>
        /// return texture parameter values for a specific level of
        /// detail
        /// </para>
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetTextureLevelParameteriv(GLuint texture, GLint level, GLenum pname, GLint * params);</para>
        /// </summary>
        public unsafe static void GetTextureLevelParameteriv(uint texture, int level, uint pname, ref int ps) {
            fixed (int* pPs = &ps) {
                GLNative.glGetTextureLevelParameteriv(texture, level, pname, pPs);
            }
        }

        /// <summary>
        /// return texture parameter values
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetTextureParameterfv(GLuint texture, GLenum pname, GLfloat * params);</para>
        /// </summary>
        public unsafe static void GetTextureParameterfv(uint texture, uint pname, ref float ps) {
            fixed (float* pPs = &ps) {
                GLNative.glGetTextureParameterfv(texture, pname, pPs);
            }
        }

        /// <summary>
        /// return texture parameter values
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetTextureParameterIiv(GLuint texture, GLenum pname, GLint * params);</para>
        /// </summary>
        public unsafe static void GetTextureParameterIiv(uint texture, uint pname, ref int ps) {
            fixed (int* pPs = &ps) {
                GLNative.glGetTextureParameterIiv(texture, pname, pPs);
            }
        }

        /// <summary>
        /// return texture parameter values
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetTextureParameterIuiv(GLuint texture, GLenum pname, GLuint * params);</para>
        /// </summary>
        public unsafe static void GetTextureParameterIuiv(uint texture, uint pname, ref uint ps) {
            fixed (uint* pPs = &ps) {
                GLNative.glGetTextureParameterIuiv(texture, pname, pPs);
            }
        }

        /// <summary>
        /// return texture parameter values
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetTextureParameteriv(GLuint texture, GLenum pname, GLint * params);</para>
        /// </summary>
        public unsafe static void GetTextureParameteriv(uint texture, uint pname, ref int ps) {
            fixed (int* pPs = &ps) {
                GLNative.glGetTextureParameteriv(texture, pname, pPs);
            }
        }

        /// <summary>
        /// create vertex array objects
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glCreateVertexArrays(GLsizei n, GLuint * arrays);</para>
        /// </summary>
        public unsafe static void CreateVertexArrays(int n, ref uint arrays) {
            fixed (uint* pArrays = &arrays) {
                GLNative.glCreateVertexArrays(n, pArrays);
            }
        }

        /// <summary>
        /// attach multiple buffer objects to a vertex array object
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glVertexArrayVertexBuffers(GLuint vaobj, GLuint first, GLsizei count, const GLuint * buffers, const GLintptr * offsets, const GLsizei * strides);</para>
        /// </summary>
        public unsafe static void VertexArrayVertexBuffers(uint vaobj, uint first, int count, ref uint buffers, IntPtr offsets, ref int strides) {
            fixed (uint* pBuffers = &buffers)
            fixed (int* pStrides = &strides) {
                GLNative.glVertexArrayVertexBuffers(vaobj, first, count, pBuffers, offsets, pStrides);
            }
        }

        /// <summary>
        /// retrieve parameters of a vertex array object
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetVertexArrayiv(GLuint vaobj, GLenum pname, GLint * param);</para>
        /// </summary>
        public unsafe static void GetVertexArrayiv(uint vaobj, uint pname, ref int param) {
            fixed (int* pParam = &param) {
                GLNative.glGetVertexArrayiv(vaobj, pname, pParam);
            }
        }

        /// <summary>
        /// <para>
        /// retrieve parameters of an attribute of a vertex array
        /// object
        /// </para>
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetVertexArrayIndexediv(GLuint vaobj, GLuint index, GLenum pname, GLint * param);</para>
        /// </summary>
        public unsafe static void GetVertexArrayIndexediv(uint vaobj, uint index, uint pname, ref int param) {
            fixed (int* pParam = &param) {
                GLNative.glGetVertexArrayIndexediv(vaobj, index, pname, pParam);
            }
        }

        /// <summary>
        /// <para>
        /// retrieve parameters of an attribute of a vertex array
        /// object
        /// </para>
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetVertexArrayIndexed64iv(GLuint vaobj, GLuint index, GLenum pname, GLint64 * param);</para>
        /// </summary>
        public unsafe static void GetVertexArrayIndexed64iv(uint vaobj, uint index, uint pname, ref UInt64 param) {
            fixed (UInt64* pParam = &param) {
                GLNative.glGetVertexArrayIndexed64iv(vaobj, index, pname, pParam);
            }
        }

        /// <summary>
        /// create sampler objects
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glCreateSamplers(GLsizei n, GLuint * samplers);</para>
        /// </summary>
        public unsafe static void CreateSamplers(int n, ref uint samplers) {
            fixed (uint* pSamplers = &samplers) {
                GLNative.glCreateSamplers(n, pSamplers);
            }
        }

        /// <summary>
        /// create program pipeline objects
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glCreateProgramPipelines(GLsizei n, GLuint * pipelines);</para>
        /// </summary>
        public unsafe static void CreateProgramPipelines(int n, ref uint pipelines) {
            fixed (uint* pPipelines = &pipelines) {
                GLNative.glCreateProgramPipelines(n, pPipelines);
            }
        }

        /// <summary>
        /// create query objects
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glCreateQueries(GLenum target, GLsizei n, GLuint * ids);</para>
        /// </summary>
        public unsafe static void CreateQueries(uint target, int n, ref uint ids) {
            fixed (uint* pIds = &ids) {
                GLNative.glCreateQueries(target, n, pIds);
            }
        }


        #endregion Reuse GL_ARB_direct_state_access

        #region Reuse GL_ARB_ES3_1_compatibility


        #endregion Reuse GL_ARB_ES3_1_compatibility

        #region Reuse GL_ARB_get_texture_sub_image

        /// <summary>
        /// <para>
        /// retrieve a sub-region of a texture image from a texture
        /// object
        /// </para>
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_get_texture_sub_image</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetTextureSubImage(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, GLsizei bufSize, void * pixels);</para>
        /// </summary>
        public unsafe static void GetTextureSubImage(uint texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, uint format, uint type, int bufSize, IntPtr pixels) {
            GLNative.glGetTextureSubImage(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, type, bufSize, (void*)pixels);
        }

        /// <summary>
        /// <para>
        /// retrieve a sub-region of a compressed texture image from a
        /// compressed texture object
        /// </para>
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_get_texture_sub_image</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetCompressedTextureSubImage(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLsizei bufSize, void * pixels);</para>
        /// </summary>
        public unsafe static void GetCompressedTextureSubImage(uint texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, int bufSize, IntPtr pixels) {
            GLNative.glGetCompressedTextureSubImage(texture, level, xoffset, yoffset, zoffset, width, height, depth, bufSize, (void*)pixels);
        }


        #endregion Reuse GL_ARB_get_texture_sub_image

        #region Reuse GL_ARB_robustness

        /// <summary>
        /// return a compressed texture image
        /// <para>Require:</para> <para>GL_VERSION_4_5</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glGetnCompressedTexImage(GLenum target, GLint level, GLsizei bufSize, void * pixels);</para>
        /// </summary>
        public unsafe static void GetnCompressedTexImage(uint target, int level, int bufSize, IntPtr pixels) {
            GLNative.glGetnCompressedTexImage(target, level, bufSize, (void*)pixels);
        }

        /// <summary>
        /// return a texture image
        /// <para>Require:</para> <para>GL_VERSION_4_5</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glGetnTexImage(GLenum target, GLint level, GLenum format, GLenum type, GLsizei bufSize, void * pixels);</para>
        /// </summary>
        public unsafe static void GetnTexImage(uint target, int level, uint format, uint type, int bufSize, IntPtr pixels) {
            GLNative.glGetnTexImage(target, level, format, type, bufSize, (void*)pixels);
        }

        /// <summary>
        /// Returns the value of a uniform variable
        /// <para>Require:</para> <para>GL_VERSION_4_5</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glGetnUniformdv(GLuint program, GLint location, GLsizei bufSize, GLdouble * params);</para>
        /// </summary>
        public unsafe static void GetnUniformdv(uint program, int location, int bufSize, ref double ps) {
            fixed (double* pPs = &ps) {
                GLNative.glGetnUniformdv(program, location, bufSize, pPs);
            }
        }

        /// <summary>
        /// Returns the value of a uniform variable
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ES_VERSION_3_2, GL_SC_VERSION_2_0, GL_KHR_robustness</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glGetnUniformfv(GLuint program, GLint location, GLsizei bufSize, GLfloat * params);</para>
        /// </summary>
        public unsafe static void GetnUniformfv(uint program, int location, int bufSize, ref float ps) {
            fixed (float* pPs = &ps) {
                GLNative.glGetnUniformfv(program, location, bufSize, pPs);
            }
        }

        /// <summary>
        /// Returns the value of a uniform variable
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ES_VERSION_3_2, GL_SC_VERSION_2_0, GL_KHR_robustness</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glGetnUniformiv(GLuint program, GLint location, GLsizei bufSize, GLint * params);</para>
        /// </summary>
        public unsafe static void GetnUniformiv(uint program, int location, int bufSize, ref int ps) {
            fixed (int* pPs = &ps) {
                GLNative.glGetnUniformiv(program, location, bufSize, pPs);
            }
        }

        /// <summary>
        /// Returns the value of a uniform variable
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ES_VERSION_3_2, GL_KHR_robustness</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glGetnUniformuiv(GLuint program, GLint location, GLsizei bufSize, GLuint * params);</para>
        /// </summary>
        public unsafe static void GetnUniformuiv(uint program, int location, int bufSize, ref uint ps) {
            fixed (uint* pPs = &ps) {
                GLNative.glGetnUniformuiv(program, location, bufSize, pPs);
            }
        }

        /// <summary>
        /// read a block of pixels from the frame buffer
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ES_VERSION_3_2, GL_SC_VERSION_2_0, GL_KHR_robustness</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glReadnPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLsizei bufSize, void * data);</para>
        /// </summary>
        public unsafe static void ReadnPixels(int x, int y, int width, int height, uint format, uint type, int bufSize, IntPtr data) {
            GLNative.glReadnPixels(x, y, width, height, format, type, bufSize, (void*)data);
        }


        #endregion Reuse GL_ARB_robustness

        #region Reuse GL_ARB_robustness

        /// <summary>
        /// <para>Require:</para> <para>GL_VERSION_4_5</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glGetnMapdv(GLenum target, GLenum query, GLsizei bufSize, GLdouble * v);</para>
        /// </summary>
        public unsafe static void GetnMapdv(uint target, uint query, int bufSize, ref double v) {
            fixed (double* pV = &v) {
                GLNative.glGetnMapdv(target, query, bufSize, pV);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_VERSION_4_5</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glGetnMapfv(GLenum target, GLenum query, GLsizei bufSize, GLfloat * v);</para>
        /// </summary>
        public unsafe static void GetnMapfv(uint target, uint query, int bufSize, ref float v) {
            fixed (float* pV = &v) {
                GLNative.glGetnMapfv(target, query, bufSize, pV);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_VERSION_4_5</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glGetnMapiv(GLenum target, GLenum query, GLsizei bufSize, GLint * v);</para>
        /// </summary>
        public unsafe static void GetnMapiv(uint target, uint query, int bufSize, ref int v) {
            fixed (int* pV = &v) {
                GLNative.glGetnMapiv(target, query, bufSize, pV);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_VERSION_4_5</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glGetnPixelMapfv(GLenum map, GLsizei bufSize, GLfloat * values);</para>
        /// </summary>
        public unsafe static void GetnPixelMapfv(uint map, int bufSize, ref float values) {
            fixed (float* pValues = &values) {
                GLNative.glGetnPixelMapfv(map, bufSize, pValues);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_VERSION_4_5</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glGetnPixelMapuiv(GLenum map, GLsizei bufSize, GLuint * values);</para>
        /// </summary>
        public unsafe static void GetnPixelMapuiv(uint map, int bufSize, ref uint values) {
            fixed (uint* pValues = &values) {
                GLNative.glGetnPixelMapuiv(map, bufSize, pValues);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_VERSION_4_5</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glGetnPixelMapusv(GLenum map, GLsizei bufSize, GLushort * values);</para>
        /// </summary>
        public unsafe static void GetnPixelMapusv(uint map, int bufSize, ref ushort values) {
            fixed (ushort* pValues = &values) {
                GLNative.glGetnPixelMapusv(map, bufSize, pValues);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_VERSION_4_5</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glGetnPolygonStipple(GLsizei bufSize, GLubyte * pattern);</para>
        /// </summary>
        public unsafe static void GetnPolygonStipple(int bufSize, ref byte pattern) {
            fixed (byte* pPattern = &pattern) {
                GLNative.glGetnPolygonStipple(bufSize, pPattern);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_VERSION_4_5</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glGetnColorTable(GLenum target, GLenum format, GLenum type, GLsizei bufSize, void * table);</para>
        /// </summary>
        public unsafe static void GetnColorTable(uint target, uint format, uint type, int bufSize, IntPtr table) {
            GLNative.glGetnColorTable(target, format, type, bufSize, (void*)table);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_VERSION_4_5</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glGetnConvolutionFilter(GLenum target, GLenum format, GLenum type, GLsizei bufSize, void * image);</para>
        /// </summary>
        public unsafe static void GetnConvolutionFilter(uint target, uint format, uint type, int bufSize, IntPtr image) {
            GLNative.glGetnConvolutionFilter(target, format, type, bufSize, (void*)image);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_VERSION_4_5</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glGetnSeparableFilter(GLenum target, GLenum format, GLenum type, GLsizei rowBufSize, void * row, GLsizei columnBufSize, void * column, void * span);</para>
        /// </summary>
        public unsafe static void GetnSeparableFilter(uint target, uint format, uint type, int rowBufSize, IntPtr row, int columnBufSize, IntPtr column, IntPtr span) {
            GLNative.glGetnSeparableFilter(target, format, type, rowBufSize, (void*)row, columnBufSize, (void*)column, (void*)span);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_VERSION_4_5</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glGetnHistogram(GLenum target, GLboolean reset, GLenum format, GLenum type, GLsizei bufSize, void * values);</para>
        /// </summary>
        public unsafe static void GetnHistogram(uint target, bool reset, uint format, uint type, int bufSize, IntPtr values) {
            GLNative.glGetnHistogram(target, reset, format, type, bufSize, (void*)values);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_VERSION_4_5</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glGetnMinmax(GLenum target, GLboolean reset, GLenum format, GLenum type, GLsizei bufSize, void * values);</para>
        /// </summary>
        public unsafe static void GetnMinmax(uint target, bool reset, uint format, uint type, int bufSize, IntPtr values) {
            GLNative.glGetnMinmax(target, reset, format, type, bufSize, (void*)values);
        }


        #endregion Reuse GL_ARB_robustness

        #region Reuse GL_ARB_texture_barrier


        #endregion Reuse GL_ARB_texture_barrier

        #endregion GL_VERSION_4_5

        #region GL_VERSION_4_6


        #region Reuse GL_ARB_gl_spirv

        /// <summary>
        /// <para>Require:</para> <para>GL_VERSION_4_6</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glSpecializeShader(GLuint shader, const GLchar * pEntryPoint, GLuint numSpecializationConstants, const GLuint * pConstantIndex, const GLuint * pConstantValue);</para>
        /// </summary>
        public unsafe static void SpecializeShader(uint shader, ref byte pEntryPoint, uint numSpecializationConstants, ref uint pConstantIndex, ref uint pConstantValue) {
            fixed (byte* pPEntryPoint = &pEntryPoint)
            fixed (uint* pPConstantIndex = &pConstantIndex)
            fixed (uint* pPConstantValue = &pConstantValue) {
                GLNative.glSpecializeShader(shader, pPEntryPoint, numSpecializationConstants, pPConstantIndex, pPConstantValue);
            }
        }


        #endregion Reuse GL_ARB_gl_spirv

        #region Reuse GL_ARB_indirect_parameters

        /// <summary>
        /// <para>Require:</para> <para>GL_VERSION_4_6</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glMultiDrawArraysIndirectCount(GLenum mode, const void * indirect, GLintptr drawcount, GLsizei maxdrawcount, GLsizei stride);</para>
        /// </summary>
        public unsafe static void MultiDrawArraysIndirectCount(uint mode, IntPtr indirect, IntPtr drawcount, int maxdrawcount, int stride) {
            GLNative.glMultiDrawArraysIndirectCount(mode, (void*)indirect, drawcount, maxdrawcount, stride);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_VERSION_4_6</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glMultiDrawElementsIndirectCount(GLenum mode, GLenum type, const void * indirect, GLintptr drawcount, GLsizei maxdrawcount, GLsizei stride);</para>
        /// </summary>
        public unsafe static void MultiDrawElementsIndirectCount(uint mode, uint type, IntPtr indirect, IntPtr drawcount, int maxdrawcount, int stride) {
            GLNative.glMultiDrawElementsIndirectCount(mode, type, (void*)indirect, drawcount, maxdrawcount, stride);
        }


        #endregion Reuse GL_ARB_indirect_parameters

        #region Reuse GL_ARB_polygon_offset_clamp


        #endregion Reuse GL_ARB_polygon_offset_clamp

        #endregion GL_VERSION_4_6

        #region GL_3DFX_tbuffer


        #endregion GL_3DFX_tbuffer

        #region GL_AMD_debug_output

        /// <summary>
        /// <para>Require:</para> <para>GL_AMD_debug_output</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glDebugMessageEnableAMD(GLenum category, GLenum severity, GLsizei count, const GLuint * ids, GLboolean enabled);</para>
        /// </summary>
        public unsafe static void DebugMessageEnableAMD(uint category, uint severity, int count, ref uint ids, bool enabled) {
            fixed (uint* pIds = &ids) {
                GLNative.glDebugMessageEnableAMD(category, severity, count, pIds, enabled);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_AMD_debug_output</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glDebugMessageInsertAMD(GLenum category, GLenum severity, GLuint id, GLsizei length, const GLchar * buf);</para>
        /// </summary>
        public unsafe static void DebugMessageInsertAMD(uint category, uint severity, uint id, int length, ref byte buf) {
            fixed (byte* pBuf = &buf) {
                GLNative.glDebugMessageInsertAMD(category, severity, id, length, pBuf);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_AMD_debug_output</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glDebugMessageCallbackAMD(GLDEBUGPROCAMD callback, void * userParam);</para>
        /// </summary>
        public unsafe static void DebugMessageCallbackAMD(GLNativeDelegate.GLDEBUGPROCAMD callback, IntPtr userParam) {
            GLNative.glDebugMessageCallbackAMD(callback, (void*)userParam);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_AMD_debug_output</para>
        /// Supported: <para>gl</para>
        /// Original: <para>GLuint glGetDebugMessageLogAMD(GLuint count, GLsizei bufSize, GLenum * categories, GLuint * severities, GLuint * ids, GLsizei * lengths, GLchar * message);</para>
        /// </summary>
        public unsafe static uint GetDebugMessageLogAMD(uint count, int bufSize, ref uint categories, ref uint severities, ref uint ids, ref int lengths, ref byte message) {
            fixed (uint* pCategories = &categories)
            fixed (uint* pSeverities = &severities)
            fixed (uint* pIds = &ids)
            fixed (int* pLengths = &lengths)
            fixed (byte* pMessage = &message) {
                return GLNative.glGetDebugMessageLogAMD(count, bufSize, pCategories, pSeverities, pIds, pLengths, pMessage);
            }
        }


        #endregion GL_AMD_debug_output

        #region GL_AMD_draw_buffers_blend


        #endregion GL_AMD_draw_buffers_blend

        #region GL_AMD_framebuffer_multisample_advanced


        #endregion GL_AMD_framebuffer_multisample_advanced

        #region GL_AMD_framebuffer_sample_positions

        /// <summary>
        /// <para>Require:</para> <para>GL_AMD_framebuffer_sample_positions</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glFramebufferSamplePositionsfvAMD(GLenum target, GLuint numsamples, GLuint pixelindex, const GLfloat * values);</para>
        /// </summary>
        public unsafe static void FramebufferSamplePositionsfvAMD(uint target, uint numsamples, uint pixelindex, ref float values) {
            fixed (float* pValues = &values) {
                GLNative.glFramebufferSamplePositionsfvAMD(target, numsamples, pixelindex, pValues);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_AMD_framebuffer_sample_positions</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glNamedFramebufferSamplePositionsfvAMD(GLuint framebuffer, GLuint numsamples, GLuint pixelindex, const GLfloat * values);</para>
        /// </summary>
        public unsafe static void NamedFramebufferSamplePositionsfvAMD(uint framebuffer, uint numsamples, uint pixelindex, ref float values) {
            fixed (float* pValues = &values) {
                GLNative.glNamedFramebufferSamplePositionsfvAMD(framebuffer, numsamples, pixelindex, pValues);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_AMD_framebuffer_sample_positions</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetFramebufferParameterfvAMD(GLenum target, GLenum pname, GLuint numsamples, GLuint pixelindex, GLsizei size, GLfloat * values);</para>
        /// </summary>
        public unsafe static void GetFramebufferParameterfvAMD(uint target, uint pname, uint numsamples, uint pixelindex, int size, ref float values) {
            fixed (float* pValues = &values) {
                GLNative.glGetFramebufferParameterfvAMD(target, pname, numsamples, pixelindex, size, pValues);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_AMD_framebuffer_sample_positions</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetNamedFramebufferParameterfvAMD(GLuint framebuffer, GLenum pname, GLuint numsamples, GLuint pixelindex, GLsizei size, GLfloat * values);</para>
        /// </summary>
        public unsafe static void GetNamedFramebufferParameterfvAMD(uint framebuffer, uint pname, uint numsamples, uint pixelindex, int size, ref float values) {
            fixed (float* pValues = &values) {
                GLNative.glGetNamedFramebufferParameterfvAMD(framebuffer, pname, numsamples, pixelindex, size, pValues);
            }
        }


        #endregion GL_AMD_framebuffer_sample_positions

        #region GL_AMD_gpu_shader_int64

        /// <summary>
        /// <para>Require:</para> <para>GL_AMD_gpu_shader_int64, GL_NV_gpu_shader5</para>
        /// Supported: <para>gl, gl, glcore, gles2</para>
        /// Original: <para>void glUniform1i64vNV(GLint location, GLsizei count, const GLint64EXT * value);</para>
        /// </summary>
        public unsafe static void Uniform1i64vNV(int location, int count, ref Int64 value) {
            fixed (Int64* pValue = &value) {
                GLNative.glUniform1i64vNV(location, count, pValue);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_AMD_gpu_shader_int64, GL_NV_gpu_shader5</para>
        /// Supported: <para>gl, gl, glcore, gles2</para>
        /// Original: <para>void glUniform2i64vNV(GLint location, GLsizei count, const GLint64EXT * value);</para>
        /// </summary>
        public unsafe static void Uniform2i64vNV(int location, int count, ref Int64 value) {
            fixed (Int64* pValue = &value) {
                GLNative.glUniform2i64vNV(location, count, pValue);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_AMD_gpu_shader_int64, GL_NV_gpu_shader5</para>
        /// Supported: <para>gl, gl, glcore, gles2</para>
        /// Original: <para>void glUniform3i64vNV(GLint location, GLsizei count, const GLint64EXT * value);</para>
        /// </summary>
        public unsafe static void Uniform3i64vNV(int location, int count, ref Int64 value) {
            fixed (Int64* pValue = &value) {
                GLNative.glUniform3i64vNV(location, count, pValue);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_AMD_gpu_shader_int64, GL_NV_gpu_shader5</para>
        /// Supported: <para>gl, gl, glcore, gles2</para>
        /// Original: <para>void glUniform4i64vNV(GLint location, GLsizei count, const GLint64EXT * value);</para>
        /// </summary>
        public unsafe static void Uniform4i64vNV(int location, int count, ref Int64 value) {
            fixed (Int64* pValue = &value) {
                GLNative.glUniform4i64vNV(location, count, pValue);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_AMD_gpu_shader_int64, GL_NV_gpu_shader5</para>
        /// Supported: <para>gl, gl, glcore, gles2</para>
        /// Original: <para>void glUniform1ui64vNV(GLint location, GLsizei count, const GLuint64EXT * value);</para>
        /// </summary>
        public unsafe static void Uniform1ui64vNV(int location, int count, ref UInt64 value) {
            fixed (UInt64* pValue = &value) {
                GLNative.glUniform1ui64vNV(location, count, pValue);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_AMD_gpu_shader_int64, GL_NV_gpu_shader5</para>
        /// Supported: <para>gl, gl, glcore, gles2</para>
        /// Original: <para>void glUniform2ui64vNV(GLint location, GLsizei count, const GLuint64EXT * value);</para>
        /// </summary>
        public unsafe static void Uniform2ui64vNV(int location, int count, ref UInt64 value) {
            fixed (UInt64* pValue = &value) {
                GLNative.glUniform2ui64vNV(location, count, pValue);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_AMD_gpu_shader_int64, GL_NV_gpu_shader5</para>
        /// Supported: <para>gl, gl, glcore, gles2</para>
        /// Original: <para>void glUniform3ui64vNV(GLint location, GLsizei count, const GLuint64EXT * value);</para>
        /// </summary>
        public unsafe static void Uniform3ui64vNV(int location, int count, ref UInt64 value) {
            fixed (UInt64* pValue = &value) {
                GLNative.glUniform3ui64vNV(location, count, pValue);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_AMD_gpu_shader_int64, GL_NV_gpu_shader5</para>
        /// Supported: <para>gl, gl, glcore, gles2</para>
        /// Original: <para>void glUniform4ui64vNV(GLint location, GLsizei count, const GLuint64EXT * value);</para>
        /// </summary>
        public unsafe static void Uniform4ui64vNV(int location, int count, ref UInt64 value) {
            fixed (UInt64* pValue = &value) {
                GLNative.glUniform4ui64vNV(location, count, pValue);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_AMD_gpu_shader_int64, GL_NV_gpu_shader5</para>
        /// Supported: <para>gl, gl, glcore, gles2</para>
        /// Original: <para>void glGetUniformi64vNV(GLuint program, GLint location, GLint64EXT * params);</para>
        /// </summary>
        public unsafe static void GetUniformi64vNV(uint program, int location, ref Int64 ps) {
            fixed (Int64* pPs = &ps) {
                GLNative.glGetUniformi64vNV(program, location, pPs);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_AMD_gpu_shader_int64, GL_NV_shader_buffer_load</para>
        /// Supported: <para>gl, gl, glcore</para>
        /// Original: <para>void glGetUniformui64vNV(GLuint program, GLint location, GLuint64EXT * params);</para>
        /// </summary>
        public unsafe static void GetUniformui64vNV(uint program, int location, ref UInt64 ps) {
            fixed (UInt64* pPs = &ps) {
                GLNative.glGetUniformui64vNV(program, location, pPs);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_AMD_gpu_shader_int64, GL_NV_gpu_shader5</para>
        /// Supported: <para>gl, gl, glcore, gles2</para>
        /// Original: <para>void glProgramUniform1i64vNV(GLuint program, GLint location, GLsizei count, const GLint64EXT * value);</para>
        /// </summary>
        public unsafe static void ProgramUniform1i64vNV(uint program, int location, int count, ref Int64 value) {
            fixed (Int64* pValue = &value) {
                GLNative.glProgramUniform1i64vNV(program, location, count, pValue);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_AMD_gpu_shader_int64, GL_NV_gpu_shader5</para>
        /// Supported: <para>gl, gl, glcore, gles2</para>
        /// Original: <para>void glProgramUniform2i64vNV(GLuint program, GLint location, GLsizei count, const GLint64EXT * value);</para>
        /// </summary>
        public unsafe static void ProgramUniform2i64vNV(uint program, int location, int count, ref Int64 value) {
            fixed (Int64* pValue = &value) {
                GLNative.glProgramUniform2i64vNV(program, location, count, pValue);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_AMD_gpu_shader_int64, GL_NV_gpu_shader5</para>
        /// Supported: <para>gl, gl, glcore, gles2</para>
        /// Original: <para>void glProgramUniform3i64vNV(GLuint program, GLint location, GLsizei count, const GLint64EXT * value);</para>
        /// </summary>
        public unsafe static void ProgramUniform3i64vNV(uint program, int location, int count, ref Int64 value) {
            fixed (Int64* pValue = &value) {
                GLNative.glProgramUniform3i64vNV(program, location, count, pValue);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_AMD_gpu_shader_int64, GL_NV_gpu_shader5</para>
        /// Supported: <para>gl, gl, glcore, gles2</para>
        /// Original: <para>void glProgramUniform4i64vNV(GLuint program, GLint location, GLsizei count, const GLint64EXT * value);</para>
        /// </summary>
        public unsafe static void ProgramUniform4i64vNV(uint program, int location, int count, ref Int64 value) {
            fixed (Int64* pValue = &value) {
                GLNative.glProgramUniform4i64vNV(program, location, count, pValue);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_AMD_gpu_shader_int64, GL_NV_gpu_shader5</para>
        /// Supported: <para>gl, gl, glcore, gles2</para>
        /// Original: <para>void glProgramUniform1ui64vNV(GLuint program, GLint location, GLsizei count, const GLuint64EXT * value);</para>
        /// </summary>
        public unsafe static void ProgramUniform1ui64vNV(uint program, int location, int count, ref UInt64 value) {
            fixed (UInt64* pValue = &value) {
                GLNative.glProgramUniform1ui64vNV(program, location, count, pValue);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_AMD_gpu_shader_int64, GL_NV_gpu_shader5</para>
        /// Supported: <para>gl, gl, glcore, gles2</para>
        /// Original: <para>void glProgramUniform2ui64vNV(GLuint program, GLint location, GLsizei count, const GLuint64EXT * value);</para>
        /// </summary>
        public unsafe static void ProgramUniform2ui64vNV(uint program, int location, int count, ref UInt64 value) {
            fixed (UInt64* pValue = &value) {
                GLNative.glProgramUniform2ui64vNV(program, location, count, pValue);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_AMD_gpu_shader_int64, GL_NV_gpu_shader5</para>
        /// Supported: <para>gl, gl, glcore, gles2</para>
        /// Original: <para>void glProgramUniform3ui64vNV(GLuint program, GLint location, GLsizei count, const GLuint64EXT * value);</para>
        /// </summary>
        public unsafe static void ProgramUniform3ui64vNV(uint program, int location, int count, ref UInt64 value) {
            fixed (UInt64* pValue = &value) {
                GLNative.glProgramUniform3ui64vNV(program, location, count, pValue);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_AMD_gpu_shader_int64, GL_NV_gpu_shader5</para>
        /// Supported: <para>gl, gl, glcore, gles2</para>
        /// Original: <para>void glProgramUniform4ui64vNV(GLuint program, GLint location, GLsizei count, const GLuint64EXT * value);</para>
        /// </summary>
        public unsafe static void ProgramUniform4ui64vNV(uint program, int location, int count, ref UInt64 value) {
            fixed (UInt64* pValue = &value) {
                GLNative.glProgramUniform4ui64vNV(program, location, count, pValue);
            }
        }


        #endregion GL_AMD_gpu_shader_int64

        #region GL_AMD_interleaved_elements


        #endregion GL_AMD_interleaved_elements

        #region GL_AMD_multi_draw_indirect

        /// <summary>
        /// <para>Require:</para> <para>GL_AMD_multi_draw_indirect</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glMultiDrawArraysIndirectAMD(GLenum mode, const void * indirect, GLsizei primcount, GLsizei stride);</para>
        /// </summary>
        public unsafe static void MultiDrawArraysIndirectAMD(uint mode, IntPtr indirect, int primcount, int stride) {
            GLNative.glMultiDrawArraysIndirectAMD(mode, (void*)indirect, primcount, stride);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_AMD_multi_draw_indirect</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glMultiDrawElementsIndirectAMD(GLenum mode, GLenum type, const void * indirect, GLsizei primcount, GLsizei stride);</para>
        /// </summary>
        public unsafe static void MultiDrawElementsIndirectAMD(uint mode, uint type, IntPtr indirect, int primcount, int stride) {
            GLNative.glMultiDrawElementsIndirectAMD(mode, type, (void*)indirect, primcount, stride);
        }


        #endregion GL_AMD_multi_draw_indirect

        #region GL_AMD_name_gen_delete

        /// <summary>
        /// <para>Require:</para> <para>GL_AMD_name_gen_delete</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGenNamesAMD(GLenum identifier, GLuint num, GLuint * names);</para>
        /// </summary>
        public unsafe static void GenNamesAMD(uint identifier, uint num, ref uint names) {
            fixed (uint* pNames = &names) {
                GLNative.glGenNamesAMD(identifier, num, pNames);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_AMD_name_gen_delete</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glDeleteNamesAMD(GLenum identifier, GLuint num, const GLuint * names);</para>
        /// </summary>
        public unsafe static void DeleteNamesAMD(uint identifier, uint num, ref uint names) {
            fixed (uint* pNames = &names) {
                GLNative.glDeleteNamesAMD(identifier, num, pNames);
            }
        }


        #endregion GL_AMD_name_gen_delete

        #region GL_AMD_occlusion_query_event


        #endregion GL_AMD_occlusion_query_event

        #region GL_AMD_performance_monitor

        /// <summary>
        /// <para>Require:</para> <para>GL_AMD_performance_monitor</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glGetPerfMonitorGroupsAMD(GLint * numGroups, GLsizei groupsSize, GLuint * groups);</para>
        /// </summary>
        public unsafe static void GetPerfMonitorGroupsAMD(ref int numGroups, int groupsSize, ref uint groups) {
            fixed (int* pNumGroups = &numGroups)
            fixed (uint* pGroups = &groups) {
                GLNative.glGetPerfMonitorGroupsAMD(pNumGroups, groupsSize, pGroups);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_AMD_performance_monitor</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glGetPerfMonitorCountersAMD(GLuint group, GLint * numCounters, GLint * maxActiveCounters, GLsizei counterSize, GLuint * counters);</para>
        /// </summary>
        public unsafe static void GetPerfMonitorCountersAMD(uint group, ref int numCounters, ref int maxActiveCounters, int counterSize, ref uint counters) {
            fixed (int* pNumCounters = &numCounters)
            fixed (int* pMaxActiveCounters = &maxActiveCounters)
            fixed (uint* pCounters = &counters) {
                GLNative.glGetPerfMonitorCountersAMD(group, pNumCounters, pMaxActiveCounters, counterSize, pCounters);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_AMD_performance_monitor</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glGetPerfMonitorGroupStringAMD(GLuint group, GLsizei bufSize, GLsizei * length, GLchar * groupString);</para>
        /// </summary>
        public unsafe static void GetPerfMonitorGroupStringAMD(uint group, int bufSize, ref int length, ref byte groupString) {
            fixed (int* pLength = &length)
            fixed (byte* pGroupString = &groupString) {
                GLNative.glGetPerfMonitorGroupStringAMD(group, bufSize, pLength, pGroupString);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_AMD_performance_monitor</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glGetPerfMonitorCounterStringAMD(GLuint group, GLuint counter, GLsizei bufSize, GLsizei * length, GLchar * counterString);</para>
        /// </summary>
        public unsafe static void GetPerfMonitorCounterStringAMD(uint group, uint counter, int bufSize, ref int length, ref byte counterString) {
            fixed (int* pLength = &length)
            fixed (byte* pCounterString = &counterString) {
                GLNative.glGetPerfMonitorCounterStringAMD(group, counter, bufSize, pLength, pCounterString);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_AMD_performance_monitor</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glGetPerfMonitorCounterInfoAMD(GLuint group, GLuint counter, GLenum pname, void * data);</para>
        /// </summary>
        public unsafe static void GetPerfMonitorCounterInfoAMD(uint group, uint counter, uint pname, IntPtr data) {
            GLNative.glGetPerfMonitorCounterInfoAMD(group, counter, pname, (void*)data);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_AMD_performance_monitor</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glGenPerfMonitorsAMD(GLsizei n, GLuint * monitors);</para>
        /// </summary>
        public unsafe static void GenPerfMonitorsAMD(int n, ref uint monitors) {
            fixed (uint* pMonitors = &monitors) {
                GLNative.glGenPerfMonitorsAMD(n, pMonitors);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_AMD_performance_monitor</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glDeletePerfMonitorsAMD(GLsizei n, GLuint * monitors);</para>
        /// </summary>
        public unsafe static void DeletePerfMonitorsAMD(int n, ref uint monitors) {
            fixed (uint* pMonitors = &monitors) {
                GLNative.glDeletePerfMonitorsAMD(n, pMonitors);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_AMD_performance_monitor</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glSelectPerfMonitorCountersAMD(GLuint monitor, GLboolean enable, GLuint group, GLint numCounters, GLuint * counterList);</para>
        /// </summary>
        public unsafe static void SelectPerfMonitorCountersAMD(uint monitor, bool enable, uint group, int numCounters, ref uint counterList) {
            fixed (uint* pCounterList = &counterList) {
                GLNative.glSelectPerfMonitorCountersAMD(monitor, enable, group, numCounters, pCounterList);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_AMD_performance_monitor</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glGetPerfMonitorCounterDataAMD(GLuint monitor, GLenum pname, GLsizei dataSize, GLuint * data, GLint * bytesWritten);</para>
        /// </summary>
        public unsafe static void GetPerfMonitorCounterDataAMD(uint monitor, uint pname, int dataSize, ref uint data, ref int bytesWritten) {
            fixed (uint* pData = &data)
            fixed (int* pBytesWritten = &bytesWritten) {
                GLNative.glGetPerfMonitorCounterDataAMD(monitor, pname, dataSize, pData, pBytesWritten);
            }
        }


        #endregion GL_AMD_performance_monitor

        #region GL_AMD_sample_positions

        /// <summary>
        /// <para>Require:</para> <para>GL_AMD_sample_positions</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glSetMultisamplefvAMD(GLenum pname, GLuint index, const GLfloat * val);</para>
        /// </summary>
        public unsafe static void SetMultisamplefvAMD(uint pname, uint index, ref float val) {
            fixed (float* pVal = &val) {
                GLNative.glSetMultisamplefvAMD(pname, index, pVal);
            }
        }


        #endregion GL_AMD_sample_positions

        #region GL_AMD_sparse_texture


        #endregion GL_AMD_sparse_texture

        #region GL_AMD_stencil_operation_extended


        #endregion GL_AMD_stencil_operation_extended

        #region GL_AMD_vertex_shader_tessellator


        #endregion GL_AMD_vertex_shader_tessellator

        #region GL_APPLE_element_array

        /// <summary>
        /// <para>Require:</para> <para>GL_APPLE_element_array</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glElementPointerAPPLE(GLenum type, const void * pointer);</para>
        /// </summary>
        public unsafe static void ElementPointerAPPLE(uint type, IntPtr pointer) {
            GLNative.glElementPointerAPPLE(type, (void*)pointer);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_APPLE_element_array</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glMultiDrawElementArrayAPPLE(GLenum mode, const GLint * first, const GLsizei * count, GLsizei primcount);</para>
        /// </summary>
        public unsafe static void MultiDrawElementArrayAPPLE(uint mode, ref int first, ref int count, int primcount) {
            fixed (int* pFirst = &first)
            fixed (int* pCount = &count) {
                GLNative.glMultiDrawElementArrayAPPLE(mode, pFirst, pCount, primcount);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_APPLE_element_array</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glMultiDrawRangeElementArrayAPPLE(GLenum mode, GLuint start, GLuint end, const GLint * first, const GLsizei * count, GLsizei primcount);</para>
        /// </summary>
        public unsafe static void MultiDrawRangeElementArrayAPPLE(uint mode, uint start, uint end, ref int first, ref int count, int primcount) {
            fixed (int* pFirst = &first)
            fixed (int* pCount = &count) {
                GLNative.glMultiDrawRangeElementArrayAPPLE(mode, start, end, pFirst, pCount, primcount);
            }
        }


        #endregion GL_APPLE_element_array

        #region GL_APPLE_fence

        /// <summary>
        /// <para>Require:</para> <para>GL_APPLE_fence</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGenFencesAPPLE(GLsizei n, GLuint * fences);</para>
        /// </summary>
        public unsafe static void GenFencesAPPLE(int n, ref uint fences) {
            fixed (uint* pFences = &fences) {
                GLNative.glGenFencesAPPLE(n, pFences);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_APPLE_fence</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glDeleteFencesAPPLE(GLsizei n, const GLuint * fences);</para>
        /// </summary>
        public unsafe static void DeleteFencesAPPLE(int n, ref uint fences) {
            fixed (uint* pFences = &fences) {
                GLNative.glDeleteFencesAPPLE(n, pFences);
            }
        }


        #endregion GL_APPLE_fence

        #region GL_APPLE_flush_buffer_range


        #endregion GL_APPLE_flush_buffer_range

        #region GL_APPLE_object_purgeable

        /// <summary>
        /// <para>Require:</para> <para>GL_APPLE_object_purgeable</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetObjectParameterivAPPLE(GLenum objectType, GLuint name, GLenum pname, GLint * params);</para>
        /// </summary>
        public unsafe static void GetObjectParameterivAPPLE(uint objectType, uint name, uint pname, ref int ps) {
            fixed (int* pPs = &ps) {
                GLNative.glGetObjectParameterivAPPLE(objectType, name, pname, pPs);
            }
        }


        #endregion GL_APPLE_object_purgeable

        #region GL_APPLE_texture_range

        /// <summary>
        /// <para>Require:</para> <para>GL_APPLE_texture_range</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glTextureRangeAPPLE(GLenum target, GLsizei length, const void * pointer);</para>
        /// </summary>
        public unsafe static void TextureRangeAPPLE(uint target, int length, IntPtr pointer) {
            GLNative.glTextureRangeAPPLE(target, length, (void*)pointer);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_APPLE_texture_range</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetTexParameterPointervAPPLE(GLenum target, GLenum pname, void ** params);</para>
        /// </summary>
        public unsafe static void GetTexParameterPointervAPPLE(uint target, uint pname, IntPtr ps) {
            GLNative.glGetTexParameterPointervAPPLE(target, pname, (void**)ps);
        }


        #endregion GL_APPLE_texture_range

        #region GL_APPLE_vertex_array_object

        /// <summary>
        /// <para>Require:</para> <para>GL_APPLE_vertex_array_object</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glDeleteVertexArraysAPPLE(GLsizei n, const GLuint * arrays);</para>
        /// </summary>
        public unsafe static void DeleteVertexArraysAPPLE(int n, ref uint arrays) {
            fixed (uint* pArrays = &arrays) {
                GLNative.glDeleteVertexArraysAPPLE(n, pArrays);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_APPLE_vertex_array_object</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGenVertexArraysAPPLE(GLsizei n, GLuint * arrays);</para>
        /// </summary>
        public unsafe static void GenVertexArraysAPPLE(int n, ref uint arrays) {
            fixed (uint* pArrays = &arrays) {
                GLNative.glGenVertexArraysAPPLE(n, pArrays);
            }
        }


        #endregion GL_APPLE_vertex_array_object

        #region GL_APPLE_vertex_array_range

        /// <summary>
        /// <para>Require:</para> <para>GL_APPLE_vertex_array_range</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexArrayRangeAPPLE(GLsizei length, void * pointer);</para>
        /// </summary>
        public unsafe static void VertexArrayRangeAPPLE(int length, IntPtr pointer) {
            GLNative.glVertexArrayRangeAPPLE(length, (void*)pointer);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_APPLE_vertex_array_range</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glFlushVertexArrayRangeAPPLE(GLsizei length, void * pointer);</para>
        /// </summary>
        public unsafe static void FlushVertexArrayRangeAPPLE(int length, IntPtr pointer) {
            GLNative.glFlushVertexArrayRangeAPPLE(length, (void*)pointer);
        }


        #endregion GL_APPLE_vertex_array_range

        #region GL_APPLE_vertex_program_evaluators

        /// <summary>
        /// <para>Require:</para> <para>GL_APPLE_vertex_program_evaluators</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glMapVertexAttrib1dAPPLE(GLuint index, GLuint size, GLdouble u1, GLdouble u2, GLint stride, GLint order, const GLdouble * points);</para>
        /// </summary>
        public unsafe static void MapVertexAttrib1dAPPLE(uint index, uint size, double u1, double u2, int stride, int order, ref double points) {
            fixed (double* pPoints = &points) {
                GLNative.glMapVertexAttrib1dAPPLE(index, size, u1, u2, stride, order, pPoints);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_APPLE_vertex_program_evaluators</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glMapVertexAttrib1fAPPLE(GLuint index, GLuint size, GLfloat u1, GLfloat u2, GLint stride, GLint order, const GLfloat * points);</para>
        /// </summary>
        public unsafe static void MapVertexAttrib1fAPPLE(uint index, uint size, float u1, float u2, int stride, int order, ref float points) {
            fixed (float* pPoints = &points) {
                GLNative.glMapVertexAttrib1fAPPLE(index, size, u1, u2, stride, order, pPoints);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_APPLE_vertex_program_evaluators</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glMapVertexAttrib2dAPPLE(GLuint index, GLuint size, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, const GLdouble * points);</para>
        /// </summary>
        public unsafe static void MapVertexAttrib2dAPPLE(uint index, uint size, double u1, double u2, int ustride, int uorder, double v1, double v2, int vstride, int vorder, ref double points) {
            fixed (double* pPoints = &points) {
                GLNative.glMapVertexAttrib2dAPPLE(index, size, u1, u2, ustride, uorder, v1, v2, vstride, vorder, pPoints);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_APPLE_vertex_program_evaluators</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glMapVertexAttrib2fAPPLE(GLuint index, GLuint size, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, const GLfloat * points);</para>
        /// </summary>
        public unsafe static void MapVertexAttrib2fAPPLE(uint index, uint size, float u1, float u2, int ustride, int uorder, float v1, float v2, int vstride, int vorder, ref float points) {
            fixed (float* pPoints = &points) {
                GLNative.glMapVertexAttrib2fAPPLE(index, size, u1, u2, ustride, uorder, v1, v2, vstride, vorder, pPoints);
            }
        }


        #endregion GL_APPLE_vertex_program_evaluators

        #region GL_ARB_ES2_compatibility

        // void glShaderBinary(GLsizei count, const GLuint * shaders, GLenum binaryFormat, const void * binary, GLsizei length);
        // void glGetShaderPrecisionFormat(GLenum shaderType, GLenum precisionType, GLint * range, GLint * precision);

        #endregion GL_ARB_ES2_compatibility

        #region GL_ARB_ES3_1_compatibility


        #endregion GL_ARB_ES3_1_compatibility

        #region GL_ARB_ES3_2_compatibility


        #endregion GL_ARB_ES3_2_compatibility

        #region GL_ARB_base_instance

        // void glDrawElementsInstancedBaseInstance(GLenum mode, GLsizei count, GLenum type, const void * indices, GLsizei instancecount, GLuint baseinstance);
        // void glDrawElementsInstancedBaseVertexBaseInstance(GLenum mode, GLsizei count, GLenum type, void * indices, GLsizei instancecount, GLint basevertex, GLuint baseinstance);

        #endregion GL_ARB_base_instance

        #region GL_ARB_bindless_texture

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_bindless_texture</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glUniformHandleui64vARB(GLint location, GLsizei count, const GLuint64 * value);</para>
        /// </summary>
        public unsafe static void UniformHandleui64vARB(int location, int count, ref UInt64 value) {
            fixed (UInt64* pValue = &value) {
                GLNative.glUniformHandleui64vARB(location, count, pValue);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_bindless_texture</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glProgramUniformHandleui64vARB(GLuint program, GLint location, GLsizei count, const GLuint64 * values);</para>
        /// </summary>
        public unsafe static void ProgramUniformHandleui64vARB(uint program, int location, int count, ref UInt64 values) {
            fixed (UInt64* pValues = &values) {
                GLNative.glProgramUniformHandleui64vARB(program, location, count, pValues);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_bindless_texture</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glVertexAttribL1ui64vARB(GLuint index, const GLuint64EXT * v);</para>
        /// </summary>
        public unsafe static void VertexAttribL1ui64vARB(uint index, ref UInt64 v) {
            fixed (UInt64* pV = &v) {
                GLNative.glVertexAttribL1ui64vARB(index, pV);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_bindless_texture</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetVertexAttribLui64vARB(GLuint index, GLenum pname, GLuint64EXT * params);</para>
        /// </summary>
        public unsafe static void GetVertexAttribLui64vARB(uint index, uint pname, ref UInt64 ps) {
            fixed (UInt64* pPs = &ps) {
                GLNative.glGetVertexAttribLui64vARB(index, pname, pPs);
            }
        }


        #endregion GL_ARB_bindless_texture

        #region GL_ARB_blend_func_extended

        // void glBindFragDataLocationIndexed(GLuint program, GLuint colorNumber, GLuint index, const char * name);
        // GLint glGetFragDataIndex(GLuint program, const char * name);

        #endregion GL_ARB_blend_func_extended

        #region GL_ARB_buffer_storage

        // void glBufferStorage(GLenum target, GLsizeiptr size, const void * data, GLbitfield flags);

        #endregion GL_ARB_buffer_storage

        #region GL_ARB_cl_event

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_cl_event</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>GLsync glCreateSyncFromCLeventARB(struct _cl_context * context, struct _cl_event * event, GLbitfield flags);</para>
        /// </summary>
        public static IntPtr CreateSyncFromCLeventARB(IntPtr context, IntPtr e, uint flags) {
            return GLNative.glCreateSyncFromCLeventARB(context, e, flags);
        }


        #endregion GL_ARB_cl_event

        #region GL_ARB_clear_buffer_object

        // void glClearBufferData(GLenum target, GLenum internalformat, GLenum format, GLenum type, const void * data);
        // void glClearBufferSubData(GLenum target, GLenum internalformat, GLintptr offset, GLsizeiptr size, GLenum format, GLenum type, const void * data);

        #endregion GL_ARB_clear_buffer_object

        #region GL_ARB_clear_texture

        // void glClearTexImage(GLuint texture, GLint level, GLenum format, GLenum type, const void * data);
        // void glClearTexSubImage(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void * data);

        #endregion GL_ARB_clear_texture

        #region GL_ARB_clip_control


        #endregion GL_ARB_clip_control

        #region GL_ARB_color_buffer_float


        #endregion GL_ARB_color_buffer_float

        #region GL_ARB_compute_shader


        #endregion GL_ARB_compute_shader

        #region GL_ARB_compute_variable_group_size


        #endregion GL_ARB_compute_variable_group_size

        #region GL_ARB_copy_buffer


        #endregion GL_ARB_copy_buffer

        #region GL_ARB_copy_image


        #endregion GL_ARB_copy_image

        #region GL_ARB_debug_output

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_debug_output</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glDebugMessageControlARB(GLenum source, GLenum type, GLenum severity, GLsizei count, const GLuint * ids, GLboolean enabled);</para>
        /// </summary>
        public unsafe static void DebugMessageControlARB(uint source, uint type, uint severity, int count, ref uint ids, bool enabled) {
            fixed (uint* pIds = &ids) {
                GLNative.glDebugMessageControlARB(source, type, severity, count, pIds, enabled);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_debug_output</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glDebugMessageInsertARB(GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const GLchar * buf);</para>
        /// </summary>
        public unsafe static void DebugMessageInsertARB(uint source, uint type, uint id, uint severity, int length, ref byte buf) {
            fixed (byte* pBuf = &buf) {
                GLNative.glDebugMessageInsertARB(source, type, id, severity, length, pBuf);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_debug_output</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glDebugMessageCallbackARB(GLDEBUGPROCARB callback, const void * userParam);</para>
        /// </summary>
        public unsafe static void DebugMessageCallbackARB(GLNativeDelegate.GLDEBUGPROCARB callback, IntPtr userParam) {
            GLNative.glDebugMessageCallbackARB(callback, (void*)userParam);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_debug_output</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>GLuint glGetDebugMessageLogARB(GLuint count, GLsizei bufSize, GLenum * sources, GLenum * types, GLuint * ids, GLenum * severities, GLsizei * lengths, GLchar * messageLog);</para>
        /// </summary>
        public unsafe static uint GetDebugMessageLogARB(uint count, int bufSize, ref uint sources, ref uint types, ref uint ids, ref uint severities, ref int lengths, ref byte messageLog) {
            fixed (uint* pSources = &sources)
            fixed (uint* pTypes = &types)
            fixed (uint* pIds = &ids)
            fixed (uint* pSeverities = &severities)
            fixed (int* pLengths = &lengths)
            fixed (byte* pMessageLog = &messageLog) {
                return GLNative.glGetDebugMessageLogARB(count, bufSize, pSources, pTypes, pIds, pSeverities, pLengths, pMessageLog);
            }
        }


        #endregion GL_ARB_debug_output

        #region GL_ARB_draw_buffers

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_draw_buffers</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glDrawBuffersARB(GLsizei n, const GLenum * bufs);</para>
        /// </summary>
        public unsafe static void DrawBuffersARB(int n, ref uint bufs) {
            fixed (uint* pBufs = &bufs) {
                GLNative.glDrawBuffersARB(n, pBufs);
            }
        }


        #endregion GL_ARB_draw_buffers

        #region GL_ARB_draw_buffers_blend


        #endregion GL_ARB_draw_buffers_blend

        #region GL_ARB_draw_elements_base_vertex

        // void glDrawElementsBaseVertex(GLenum mode, GLsizei count, GLenum type, void * indices, GLint basevertex);
        // void glDrawRangeElementsBaseVertex(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, void * indices, GLint basevertex);
        // void glDrawElementsInstancedBaseVertex(GLenum mode, GLsizei count, GLenum type, void * indices, GLsizei instancecount, GLint basevertex);
        // void glMultiDrawElementsBaseVertex(GLenum mode, const GLsizei * count, GLenum type, const void * const * indices, GLsizei drawcount, const GLint * basevertex);

        #endregion GL_ARB_draw_elements_base_vertex

        #region GL_ARB_draw_indirect

        // void glDrawArraysIndirect(GLenum mode, const void * indirect);
        // void glDrawElementsIndirect(GLenum mode, GLenum type, const void * indirect);

        #endregion GL_ARB_draw_indirect

        #region GL_ARB_draw_instanced

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_draw_instanced</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glDrawElementsInstancedARB(GLenum mode, GLsizei count, GLenum type, const void * indices, GLsizei primcount);</para>
        /// </summary>
        public unsafe static void DrawElementsInstancedARB(uint mode, int count, uint type, IntPtr indices, int primcount) {
            GLNative.glDrawElementsInstancedARB(mode, count, type, (void*)indices, primcount);
        }


        #endregion GL_ARB_draw_instanced

        #region GL_ARB_framebuffer_no_attachments

        // void glGetFramebufferParameteriv(GLenum target, GLenum pname, GLint * ps);

        #endregion GL_ARB_framebuffer_no_attachments

        #region GL_ARB_framebuffer_object

        // void glDeleteRenderbuffers(GLsizei n, GLuint * renderbuffers);
        // void glGenRenderbuffers(GLsizei n, GLuint * renderbuffers);
        // void glGetRenderbufferParameteriv(GLenum target, GLenum pname, GLint * ps);
        // void glDeleteFramebuffers(GLsizei n, GLuint * framebuffers);
        // void glGenFramebuffers(GLsizei n, GLuint * ids);
        // void glGetFramebufferAttachmentParameteriv(GLenum target, GLenum attachment, GLenum pname, GLint * ps);

        #endregion GL_ARB_framebuffer_object

        #region GL_ARB_geometry_shader4


        #endregion GL_ARB_geometry_shader4

        #region GL_ARB_get_program_binary

        // void glGetProgramBinary(GLuint program, GLsizei bufSize, GLsizei * length, GLenum * binaryFormat, void * binary);
        // void glProgramBinary(GLuint program, GLenum binaryFormat, const void * binary, GLsizei length);

        #endregion GL_ARB_get_program_binary

        #region GL_ARB_get_texture_sub_image

        // void glGetTextureSubImage(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, GLsizei bufSize, void * pixels);
        // void glGetCompressedTextureSubImage(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLsizei bufSize, void * pixels);

        #endregion GL_ARB_get_texture_sub_image

        #region GL_ARB_gl_spirv

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_gl_spirv</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glSpecializeShaderARB(GLuint shader, const GLchar * pEntryPoint, GLuint numSpecializationConstants, const GLuint * pConstantIndex, const GLuint * pConstantValue);</para>
        /// </summary>
        public unsafe static void SpecializeShaderARB(uint shader, ref byte pEntryPoint, uint numSpecializationConstants, ref uint pConstantIndex, ref uint pConstantValue) {
            fixed (byte* pPEntryPoint = &pEntryPoint)
            fixed (uint* pPConstantIndex = &pConstantIndex)
            fixed (uint* pPConstantValue = &pConstantValue) {
                GLNative.glSpecializeShaderARB(shader, pPEntryPoint, numSpecializationConstants, pPConstantIndex, pPConstantValue);
            }
        }


        #endregion GL_ARB_gl_spirv

        #region GL_ARB_gpu_shader_fp64

        // void glUniform1dv(GLint location, GLsizei count, const GLdouble * value);
        // void glUniform2dv(GLint location, GLsizei count, const GLdouble * value);
        // void glUniform3dv(GLint location, GLsizei count, const GLdouble * value);
        // void glUniform4dv(GLint location, GLsizei count, const GLdouble * value);
        // void glUniformMatrix2dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);
        // void glUniformMatrix3dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);
        // void glUniformMatrix4dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);
        // void glUniformMatrix2x3dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);
        // void glUniformMatrix2x4dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);
        // void glUniformMatrix3x2dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);
        // void glUniformMatrix3x4dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);
        // void glUniformMatrix4x2dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);
        // void glUniformMatrix4x3dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);
        // void glGetUniformdv(GLuint program, GLint location, GLdouble * ps);

        #endregion GL_ARB_gpu_shader_fp64

        #region GL_ARB_gpu_shader_int64

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_gpu_shader_int64</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glUniform1i64vARB(GLint location, GLsizei count, const GLint64 * value);</para>
        /// </summary>
        public unsafe static void Uniform1i64vARB(int location, int count, ref Int64 value) {
            fixed (Int64* pValue = &value) {
                GLNative.glUniform1i64vARB(location, count, pValue);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_gpu_shader_int64</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glUniform2i64vARB(GLint location, GLsizei count, const GLint64 * value);</para>
        /// </summary>
        public unsafe static void Uniform2i64vARB(int location, int count, ref Int64 value) {
            fixed (Int64* pValue = &value) {
                GLNative.glUniform2i64vARB(location, count, pValue);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_gpu_shader_int64</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glUniform3i64vARB(GLint location, GLsizei count, const GLint64 * value);</para>
        /// </summary>
        public unsafe static void Uniform3i64vARB(int location, int count, ref Int64 value) {
            fixed (Int64* pValue = &value) {
                GLNative.glUniform3i64vARB(location, count, pValue);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_gpu_shader_int64</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glUniform4i64vARB(GLint location, GLsizei count, const GLint64 * value);</para>
        /// </summary>
        public unsafe static void Uniform4i64vARB(int location, int count, ref Int64 value) {
            fixed (Int64* pValue = &value) {
                GLNative.glUniform4i64vARB(location, count, pValue);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_gpu_shader_int64</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glUniform1ui64vARB(GLint location, GLsizei count, const GLuint64 * value);</para>
        /// </summary>
        public unsafe static void Uniform1ui64vARB(int location, int count, ref UInt64 value) {
            fixed (UInt64* pValue = &value) {
                GLNative.glUniform1ui64vARB(location, count, pValue);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_gpu_shader_int64</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glUniform2ui64vARB(GLint location, GLsizei count, const GLuint64 * value);</para>
        /// </summary>
        public unsafe static void Uniform2ui64vARB(int location, int count, ref UInt64 value) {
            fixed (UInt64* pValue = &value) {
                GLNative.glUniform2ui64vARB(location, count, pValue);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_gpu_shader_int64</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glUniform3ui64vARB(GLint location, GLsizei count, const GLuint64 * value);</para>
        /// </summary>
        public unsafe static void Uniform3ui64vARB(int location, int count, ref UInt64 value) {
            fixed (UInt64* pValue = &value) {
                GLNative.glUniform3ui64vARB(location, count, pValue);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_gpu_shader_int64</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glUniform4ui64vARB(GLint location, GLsizei count, const GLuint64 * value);</para>
        /// </summary>
        public unsafe static void Uniform4ui64vARB(int location, int count, ref UInt64 value) {
            fixed (UInt64* pValue = &value) {
                GLNative.glUniform4ui64vARB(location, count, pValue);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_gpu_shader_int64</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetUniformi64vARB(GLuint program, GLint location, GLint64 * params);</para>
        /// </summary>
        public unsafe static void GetUniformi64vARB(uint program, int location, ref UInt64 ps) {
            fixed (UInt64* pPs = &ps) {
                GLNative.glGetUniformi64vARB(program, location, pPs);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_gpu_shader_int64</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetUniformui64vARB(GLuint program, GLint location, GLuint64 * params);</para>
        /// </summary>
        public unsafe static void GetUniformui64vARB(uint program, int location, ref UInt64 ps) {
            fixed (UInt64* pPs = &ps) {
                GLNative.glGetUniformui64vARB(program, location, pPs);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_gpu_shader_int64</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetnUniformi64vARB(GLuint program, GLint location, GLsizei bufSize, GLint64 * params);</para>
        /// </summary>
        public unsafe static void GetnUniformi64vARB(uint program, int location, int bufSize, ref UInt64 ps) {
            fixed (UInt64* pPs = &ps) {
                GLNative.glGetnUniformi64vARB(program, location, bufSize, pPs);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_gpu_shader_int64</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetnUniformui64vARB(GLuint program, GLint location, GLsizei bufSize, GLuint64 * params);</para>
        /// </summary>
        public unsafe static void GetnUniformui64vARB(uint program, int location, int bufSize, ref UInt64 ps) {
            fixed (UInt64* pPs = &ps) {
                GLNative.glGetnUniformui64vARB(program, location, bufSize, pPs);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_gpu_shader_int64</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glProgramUniform1i64vARB(GLuint program, GLint location, GLsizei count, const GLint64 * value);</para>
        /// </summary>
        public unsafe static void ProgramUniform1i64vARB(uint program, int location, int count, ref Int64 value) {
            fixed (Int64* pValue = &value) {
                GLNative.glProgramUniform1i64vARB(program, location, count, pValue);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_gpu_shader_int64</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glProgramUniform2i64vARB(GLuint program, GLint location, GLsizei count, const GLint64 * value);</para>
        /// </summary>
        public unsafe static void ProgramUniform2i64vARB(uint program, int location, int count, ref Int64 value) {
            fixed (Int64* pValue = &value) {
                GLNative.glProgramUniform2i64vARB(program, location, count, pValue);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_gpu_shader_int64</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glProgramUniform3i64vARB(GLuint program, GLint location, GLsizei count, const GLint64 * value);</para>
        /// </summary>
        public unsafe static void ProgramUniform3i64vARB(uint program, int location, int count, ref Int64 value) {
            fixed (Int64* pValue = &value) {
                GLNative.glProgramUniform3i64vARB(program, location, count, pValue);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_gpu_shader_int64</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glProgramUniform4i64vARB(GLuint program, GLint location, GLsizei count, const GLint64 * value);</para>
        /// </summary>
        public unsafe static void ProgramUniform4i64vARB(uint program, int location, int count, ref Int64 value) {
            fixed (Int64* pValue = &value) {
                GLNative.glProgramUniform4i64vARB(program, location, count, pValue);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_gpu_shader_int64</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glProgramUniform1ui64vARB(GLuint program, GLint location, GLsizei count, const GLuint64 * value);</para>
        /// </summary>
        public unsafe static void ProgramUniform1ui64vARB(uint program, int location, int count, ref UInt64 value) {
            fixed (UInt64* pValue = &value) {
                GLNative.glProgramUniform1ui64vARB(program, location, count, pValue);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_gpu_shader_int64</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glProgramUniform2ui64vARB(GLuint program, GLint location, GLsizei count, const GLuint64 * value);</para>
        /// </summary>
        public unsafe static void ProgramUniform2ui64vARB(uint program, int location, int count, ref UInt64 value) {
            fixed (UInt64* pValue = &value) {
                GLNative.glProgramUniform2ui64vARB(program, location, count, pValue);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_gpu_shader_int64</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glProgramUniform3ui64vARB(GLuint program, GLint location, GLsizei count, const GLuint64 * value);</para>
        /// </summary>
        public unsafe static void ProgramUniform3ui64vARB(uint program, int location, int count, ref UInt64 value) {
            fixed (UInt64* pValue = &value) {
                GLNative.glProgramUniform3ui64vARB(program, location, count, pValue);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_gpu_shader_int64</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glProgramUniform4ui64vARB(GLuint program, GLint location, GLsizei count, const GLuint64 * value);</para>
        /// </summary>
        public unsafe static void ProgramUniform4ui64vARB(uint program, int location, int count, ref UInt64 value) {
            fixed (UInt64* pValue = &value) {
                GLNative.glProgramUniform4ui64vARB(program, location, count, pValue);
            }
        }


        #endregion GL_ARB_gpu_shader_int64

        #region GL_ARB_imaging

        /// <summary>
        /// define a color lookup table
        /// <para>Require:</para> <para>GL_ARB_imaging</para>
        /// Supported: <para>gl, glcore</para>
        /// Notes: 
        /// <para>
        /// <see cref="glColorTable"/> is present only if <code>ARB_imaging</code> is returned when  <see cref="glGetString"/> 
        /// is called with an argument of <code>GL_EXTENSIONS</code>.
        /// If <paramref name="target"/> is set to <code>GL_COLOR_TABLE</code>,
        /// <code>GL_POST_CONVOLUTION_COLOR_TABLE</code>,
        /// or <code>GL_POST_COLOR_MATRIX_COLOR_TABLE</code>,
        /// then <paramref name="width"/> must be a power of two or a <code>GL_INVALID_VALUE</code>
        /// error is generated.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="target"/> is not one of the allowable
        /// values.
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="internalformat"/> is not one of the
        /// allowable values.
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="format"/> is not one of the allowable
        /// values.
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="type"/> is not one of the allowable
        /// values.
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="width"/> is less than zero.
        /// <code>GL_TABLE_TOO_LARGE</code> is generated if the requested color table
        /// is too large to be supported by the implementation, and <paramref name="target"/> is
        /// not a <code>GL_PROXY_*</code> target.
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_UNPACK_BUFFER</code> target and the buffer object's data store is currently mapped.
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_UNPACK_BUFFER</code> target and the data would be unpacked from the buffer 
        /// object such that the memory reads required would exceed the data store size.
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_UNPACK_BUFFER</code> target and <paramref name="data"/> is not evenly divisible 
        /// into the number of bytes needed to store in memory a datum indicated by <paramref name="type"/>.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glColorTable"/> is executed
        /// between the execution of  <see cref="glBegin"/>  and the corresponding
        /// execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glColorTable(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const void * data);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Must be one of
        /// <code>GL_COLOR_TABLE</code>,
        /// <code>GL_POST_CONVOLUTION_COLOR_TABLE</code>,
        /// <code>GL_POST_COLOR_MATRIX_COLOR_TABLE</code>,
        /// <code>GL_PROXY_COLOR_TABLE</code>,
        /// <code>GL_PROXY_POST_CONVOLUTION_COLOR_TABLE</code>,
        /// or
        /// <code>GL_PROXY_POST_COLOR_MATRIX_COLOR_TABLE</code>.
        /// </para>
        /// </param>
        /// <param name="internalformat">
        /// <para>
        /// The internal format of the color table.
        /// The allowable values are
        /// <code>GL_ALPHA</code>,
        /// <code>GL_ALPHA4</code>,
        /// <code>GL_ALPHA8</code>,
        /// <code>GL_ALPHA12</code>,
        /// <code>GL_ALPHA16</code>,
        /// <code>GL_LUMINANCE</code>,
        /// <code>GL_LUMINANCE4</code>,
        /// <code>GL_LUMINANCE8</code>,
        /// <code>GL_LUMINANCE12</code>,
        /// <code>GL_LUMINANCE16</code>,
        /// <code>GL_LUMINANCE_ALPHA</code>,
        /// <code>GL_LUMINANCE4_ALPHA4</code>,
        /// <code>GL_LUMINANCE6_ALPHA2</code>,
        /// <code>GL_LUMINANCE8_ALPHA8</code>,
        /// <code>GL_LUMINANCE12_ALPHA4</code>,
        /// <code>GL_LUMINANCE12_ALPHA12</code>,
        /// <code>GL_LUMINANCE16_ALPHA16</code>,
        /// <code>GL_INTENSITY</code>,
        /// <code>GL_INTENSITY4</code>,
        /// <code>GL_INTENSITY8</code>,
        /// <code>GL_INTENSITY12</code>,
        /// <code>GL_INTENSITY16</code>,
        /// <code>GL_R3_G3_B2</code>,
        /// <code>GL_RGB</code>,
        /// <code>GL_RGB4</code>,
        /// <code>GL_RGB5</code>,
        /// <code>GL_RGB8</code>,
        /// <code>GL_RGB10</code>,
        /// <code>GL_RGB12</code>,
        /// <code>GL_RGB16</code>,
        /// <code>GL_RGBA</code>,
        /// <code>GL_RGBA2</code>,
        /// <code>GL_RGBA4</code>,
        /// <code>GL_RGB5_A1</code>,
        /// <code>GL_RGBA8</code>,
        /// <code>GL_RGB10_A2</code>,
        /// <code>GL_RGBA12</code>, and
        /// <code>GL_RGBA16</code>.
        /// </para>
        /// </param>
        /// <param name="width">
        /// The number of entries in the color lookup table specified by <paramref name="data"/>.
        /// </param>
        /// <param name="format">
        /// <para>
        /// The format of the pixel data in <paramref name="data"/>.
        /// The allowable values are
        /// <code>GL_RED</code>,
        /// <code>GL_GREEN</code>,
        /// <code>GL_BLUE</code>,
        /// <code>GL_ALPHA</code>,
        /// <code>GL_LUMINANCE</code>,
        /// <code>GL_LUMINANCE_ALPHA</code>,
        /// <code>GL_RGB</code>,
        /// <code>GL_BGR</code>,
        /// <code>GL_RGBA</code>, and
        /// <code>GL_BGRA</code>.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// The type of the pixel data in <paramref name="data"/>.
        /// The allowable values are
        /// <code>GL_UNSIGNED_BYTE</code>,
        /// <code>GL_BYTE</code>,
        /// <code>GL_UNSIGNED_SHORT</code>,
        /// <code>GL_SHORT</code>,
        /// <code>GL_UNSIGNED_INT</code>,
        /// <code>GL_INT</code>,
        /// <code>GL_FLOAT</code>,
        /// <code>GL_UNSIGNED_BYTE_3_3_2</code>,
        /// <code>GL_UNSIGNED_BYTE_2_3_3_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_5_6_5</code>,
        /// <code>GL_UNSIGNED_SHORT_5_6_5_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_4_4_4_4</code>,
        /// <code>GL_UNSIGNED_SHORT_4_4_4_4_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_5_5_5_1</code>,
        /// <code>GL_UNSIGNED_SHORT_1_5_5_5_REV</code>,
        /// <code>GL_UNSIGNED_INT_8_8_8_8</code>,
        /// <code>GL_UNSIGNED_INT_8_8_8_8_REV</code>,
        /// <code>GL_UNSIGNED_INT_10_10_10_2</code>, and
        /// <code>GL_UNSIGNED_INT_2_10_10_10_REV</code>.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Pointer to a one-dimensional array of pixel data that is processed to
        /// build the color table.
        /// </para>
        /// </param>
        /// <seealso cref="ColorSubTable"/>
        /// <seealso cref="ColorTableParameter"/>
        /// <seealso cref="CopyColorTable"/>
        /// <seealso cref="CopyColorSubTable"/>
        /// <seealso cref="GetColorTable"/>
        public unsafe static void ColorTable(uint target, uint internalformat, int width, uint format, uint type, IntPtr data) {
            GLNative.glColorTable(target, internalformat, width, format, type, (void*)data);
        }

        /// <summary>
        /// set color lookup table parameters
        /// <para>Require:</para> <para>GL_ARB_imaging</para>
        /// Supported: <para>gl, glcore</para>
        /// Notes: 
        /// <para>
        /// <see cref="glColorTableParameter"/> is available only if <code>ARB_imaging</code> is returned from calling
        /// <see cref="glGetString"/>  with an argument of <code>GL_EXTENSIONS</code>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="target"/> or <paramref name="pname"/> is not
        /// an acceptable value.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glColorTableParameter"/> is executed
        /// between the execution of  <see cref="glBegin"/>  and the corresponding
        /// execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glColorTableParameterfv(GLenum target, GLenum pname, const GLfloat * params);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// The target color table.
        /// Must be
        /// <code>GL_COLOR_TABLE</code>,
        /// <code>GL_POST_CONVOLUTION_COLOR_TABLE</code>, or
        /// <code>GL_POST_COLOR_MATRIX_COLOR_TABLE</code>.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// The symbolic name of a texture color lookup table parameter.
        /// Must be one of
        /// <code>GL_COLOR_TABLE_SCALE</code> or
        /// <code>GL_COLOR_TABLE_BIAS</code>.
        /// </para>
        /// </param>
        /// <param name="ps">
        /// A pointer to an array where the values of the parameters are stored.
        /// </param>
        /// <seealso cref="ColorTable"/>
        /// <seealso cref="PixelTransfer"/>
        public unsafe static void ColorTableParameterfv(uint target, uint pname, ref float ps) {
            fixed (float* pPs = &ps) {
                GLNative.glColorTableParameterfv(target, pname, pPs);
            }
        }

        /// <summary>
        /// set color lookup table parameters
        /// <para>Require:</para> <para>GL_ARB_imaging</para>
        /// Supported: <para>gl, glcore</para>
        /// Notes: 
        /// <para>
        /// <see cref="glColorTableParameter"/> is available only if <code>ARB_imaging</code> is returned from calling
        /// <see cref="glGetString"/>  with an argument of <code>GL_EXTENSIONS</code>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="target"/> or <paramref name="pname"/> is not
        /// an acceptable value.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glColorTableParameter"/> is executed
        /// between the execution of  <see cref="glBegin"/>  and the corresponding
        /// execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glColorTableParameteriv(GLenum target, GLenum pname, const GLint * params);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// The target color table.
        /// Must be
        /// <code>GL_COLOR_TABLE</code>,
        /// <code>GL_POST_CONVOLUTION_COLOR_TABLE</code>, or
        /// <code>GL_POST_COLOR_MATRIX_COLOR_TABLE</code>.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// The symbolic name of a texture color lookup table parameter.
        /// Must be one of
        /// <code>GL_COLOR_TABLE_SCALE</code> or
        /// <code>GL_COLOR_TABLE_BIAS</code>.
        /// </para>
        /// </param>
        /// <param name="ps">
        /// A pointer to an array where the values of the parameters are stored.
        /// </param>
        /// <seealso cref="ColorTable"/>
        /// <seealso cref="PixelTransfer"/>
        public unsafe static void ColorTableParameteriv(uint target, uint pname, ref int ps) {
            fixed (int* pPs = &ps) {
                GLNative.glColorTableParameteriv(target, pname, pPs);
            }
        }

        /// <summary>
        /// retrieve contents of a color lookup table
        /// <para>Require:</para> <para>GL_ARB_imaging</para>
        /// Supported: <para>gl, glcore</para>
        /// Notes: 
        /// <para>
        /// <see cref="glGetColorTable"/> is present only if <code>ARB_imaging</code> is returned when  <see cref="glGetString"/> 
        /// is called with an argument of <code>GL_EXTENSIONS</code>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="target"/> is not one of the allowable
        /// values.
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="format"/> is not one of the allowable
        /// values.
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="type"/> is not one of the allowable
        /// values.
        /// <code>GL_INVALID_OPERATION</code> is generated if <paramref name="type"/> is one of
        /// <code>GL_UNSIGNED_BYTE_3_3_2</code>,
        /// <code>GL_UNSIGNED_BYTE_2_3_3_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_5_6_5</code>, or
        /// <code>GL_UNSIGNED_SHORT_5_6_5_REV</code>
        /// and <paramref name="format"/> is not <code>GL_RGB</code>.
        /// <code>GL_INVALID_OPERATION</code> is generated if <paramref name="type"/> is one of
        /// <code>GL_UNSIGNED_SHORT_4_4_4_4</code>,
        /// <code>GL_UNSIGNED_SHORT_4_4_4_4_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_5_5_5_1</code>,
        /// <code>GL_UNSIGNED_SHORT_1_5_5_5_REV</code>,
        /// <code>GL_UNSIGNED_INT_8_8_8_8</code>,
        /// <code>GL_UNSIGNED_INT_8_8_8_8_REV</code>,
        /// <code>GL_UNSIGNED_INT_10_10_10_2</code>, or
        /// <code>GL_UNSIGNED_INT_2_10_10_10_REV</code>
        /// and <paramref name="format"/> is neither <code>GL_RGBA</code> nor <code>GL_BGRA</code>.
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_PACK_BUFFER</code> target and the buffer object's data store is currently mapped.
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_PACK_BUFFER</code> target and the data would be packed to the buffer 
        /// object such that the memory writes required would exceed the data store size.
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_PACK_BUFFER</code> target and <paramref name="table"/> is not evenly divisible 
        /// into the number of bytes needed to store in memory a datum indicated by <paramref name="type"/>.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glGetColorTable"/> is executed
        /// between the execution of  <see cref="glBegin"/>  and the corresponding
        /// execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glGetColorTable(GLenum target, GLenum format, GLenum type, void * table);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Must be <code>GL_COLOR_TABLE</code>,
        /// <code>GL_POST_CONVOLUTION_COLOR_TABLE</code>,
        /// or
        /// <code>GL_POST_COLOR_MATRIX_COLOR_TABLE</code>.
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// The format of the pixel data in <paramref name="table"/>.
        /// The possible values are
        /// <code>GL_RED</code>,
        /// <code>GL_GREEN</code>,
        /// <code>GL_BLUE</code>,
        /// <code>GL_ALPHA</code>,
        /// <code>GL_LUMINANCE</code>,
        /// <code>GL_LUMINANCE_ALPHA</code>,
        /// <code>GL_RGB</code>,
        /// <code>GL_BGR</code>,
        /// <code>GL_RGBA</code>, and
        /// <code>GL_BGRA</code>.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// The type of the pixel data in <paramref name="table"/>.
        /// Symbolic constants
        /// <code>GL_UNSIGNED_BYTE</code>,
        /// <code>GL_BYTE</code>,
        /// <code>GL_BITMAP</code>,
        /// <code>GL_UNSIGNED_SHORT</code>,
        /// <code>GL_SHORT</code>,
        /// <code>GL_UNSIGNED_INT</code>,
        /// <code>GL_INT</code>,
        /// <code>GL_FLOAT</code>,
        /// <code>GL_UNSIGNED_BYTE_3_3_2</code>,
        /// <code>GL_UNSIGNED_BYTE_2_3_3_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_5_6_5</code>,
        /// <code>GL_UNSIGNED_SHORT_5_6_5_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_4_4_4_4</code>,
        /// <code>GL_UNSIGNED_SHORT_4_4_4_4_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_5_5_5_1</code>,
        /// <code>GL_UNSIGNED_SHORT_1_5_5_5_REV</code>,
        /// <code>GL_UNSIGNED_INT_8_8_8_8</code>,
        /// <code>GL_UNSIGNED_INT_8_8_8_8_REV</code>,
        /// <code>GL_UNSIGNED_INT_10_10_10_2</code>, and
        /// <code>GL_UNSIGNED_INT_2_10_10_10_REV</code>
        /// are accepted.
        /// </para>
        /// </param>
        /// <param name="table">
        /// <para>
        /// Pointer to a one-dimensional array of pixel data containing the contents
        /// of the color table.
        /// </para>
        /// </param>
        /// <seealso cref="ColorTable"/>
        /// <seealso cref="ColorTableParameter"/>
        public unsafe static void GetColorTable(uint target, uint format, uint type, IntPtr table) {
            GLNative.glGetColorTable(target, format, type, (void*)table);
        }

        /// <summary>
        /// get color lookup table parameters
        /// <para>Require:</para> <para>GL_ARB_imaging</para>
        /// Supported: <para>gl, glcore</para>
        /// Notes: 
        /// <para>
        /// <see cref="glGetColorTableParameter"/> is present only if <code>ARB_imaging</code> is returned when  <see cref="glGetString"/> 
        /// is called with an argument of <code>GL_EXTENSIONS</code>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="target"/> or <paramref name="pname"/> is not
        /// an acceptable value.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glGetColorTableParameter"/> is executed
        /// between the execution of  <see cref="glBegin"/>  and the corresponding
        /// execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glGetColorTableParameterfv(GLenum target, GLenum pname, GLfloat * params);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// The target color table.
        /// Must be
        /// <code>GL_COLOR_TABLE</code>,
        /// <code>GL_POST_CONVOLUTION_COLOR_TABLE</code>,
        /// <code>GL_POST_COLOR_MATRIX_COLOR_TABLE</code>,
        /// <code>GL_PROXY_COLOR_TABLE</code>,
        /// <code>GL_PROXY_POST_CONVOLUTION_COLOR_TABLE</code>, or
        /// <code>GL_PROXY_POST_COLOR_MATRIX_COLOR_TABLE</code>.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// The symbolic name of a color lookup table parameter.
        /// Must be one of
        /// <code>GL_COLOR_TABLE_BIAS</code>,
        /// <code>GL_COLOR_TABLE_SCALE</code>,
        /// <code>GL_COLOR_TABLE_FORMAT</code>,
        /// <code>GL_COLOR_TABLE_WIDTH</code>,
        /// <code>GL_COLOR_TABLE_RED_SIZE</code>,
        /// <code>GL_COLOR_TABLE_GREEN_SIZE</code>,
        /// <code>GL_COLOR_TABLE_BLUE_SIZE</code>,
        /// <code>GL_COLOR_TABLE_ALPHA_SIZE</code>,
        /// <code>GL_COLOR_TABLE_LUMINANCE_SIZE</code>, or
        /// <code>GL_COLOR_TABLE_INTENSITY_SIZE</code>.
        /// </para>
        /// </param>
        /// <param name="ps">
        /// A pointer to an array where the values of the parameter will be stored.
        /// </param>
        /// <seealso cref="ColorTable"/>
        /// <seealso cref="TexParameter"/>
        /// <seealso cref="ColorTableParameter"/>
        public unsafe static void GetColorTableParameterfv(uint target, uint pname, ref float ps) {
            fixed (float* pPs = &ps) {
                GLNative.glGetColorTableParameterfv(target, pname, pPs);
            }
        }

        /// <summary>
        /// get color lookup table parameters
        /// <para>Require:</para> <para>GL_ARB_imaging</para>
        /// Supported: <para>gl, glcore</para>
        /// Notes: 
        /// <para>
        /// <see cref="glGetColorTableParameter"/> is present only if <code>ARB_imaging</code> is returned when  <see cref="glGetString"/> 
        /// is called with an argument of <code>GL_EXTENSIONS</code>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="target"/> or <paramref name="pname"/> is not
        /// an acceptable value.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glGetColorTableParameter"/> is executed
        /// between the execution of  <see cref="glBegin"/>  and the corresponding
        /// execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glGetColorTableParameteriv(GLenum target, GLenum pname, GLint * params);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// The target color table.
        /// Must be
        /// <code>GL_COLOR_TABLE</code>,
        /// <code>GL_POST_CONVOLUTION_COLOR_TABLE</code>,
        /// <code>GL_POST_COLOR_MATRIX_COLOR_TABLE</code>,
        /// <code>GL_PROXY_COLOR_TABLE</code>,
        /// <code>GL_PROXY_POST_CONVOLUTION_COLOR_TABLE</code>, or
        /// <code>GL_PROXY_POST_COLOR_MATRIX_COLOR_TABLE</code>.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// The symbolic name of a color lookup table parameter.
        /// Must be one of
        /// <code>GL_COLOR_TABLE_BIAS</code>,
        /// <code>GL_COLOR_TABLE_SCALE</code>,
        /// <code>GL_COLOR_TABLE_FORMAT</code>,
        /// <code>GL_COLOR_TABLE_WIDTH</code>,
        /// <code>GL_COLOR_TABLE_RED_SIZE</code>,
        /// <code>GL_COLOR_TABLE_GREEN_SIZE</code>,
        /// <code>GL_COLOR_TABLE_BLUE_SIZE</code>,
        /// <code>GL_COLOR_TABLE_ALPHA_SIZE</code>,
        /// <code>GL_COLOR_TABLE_LUMINANCE_SIZE</code>, or
        /// <code>GL_COLOR_TABLE_INTENSITY_SIZE</code>.
        /// </para>
        /// </param>
        /// <param name="ps">
        /// A pointer to an array where the values of the parameter will be stored.
        /// </param>
        /// <seealso cref="ColorTable"/>
        /// <seealso cref="TexParameter"/>
        /// <seealso cref="ColorTableParameter"/>
        public unsafe static void GetColorTableParameteriv(uint target, uint pname, ref int ps) {
            fixed (int* pPs = &ps) {
                GLNative.glGetColorTableParameteriv(target, pname, pPs);
            }
        }

        /// <summary>
        /// respecify a portion of a color table
        /// <para>Require:</para> <para>GL_ARB_imaging</para>
        /// Supported: <para>gl, glcore</para>
        /// Notes: 
        /// <para>
        /// <see cref="glColorSubTable"/> is present only if <code>ARB_imaging</code> is returned when  <see cref="glGetString"/> 
        /// is called with an argument of <code>GL_EXTENSIONS</code>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="target"/> is not one of the allowable
        /// values.
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="format"/> is not one of the allowable
        /// values.
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="type"/> is not one of the allowable
        /// values.
        /// <code>GL_INVALID_VALUE</code> is generated if 
        /// width:-->
        /// start 
        /// + 
        /// count 
        /// &gt; 
        /// width 
        /// .
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_UNPACK_BUFFER</code> target and the buffer object's data store is currently mapped.
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_UNPACK_BUFFER</code> target and the data would be unpacked from the buffer 
        /// object such that the memory reads required would exceed the data store size.
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_UNPACK_BUFFER</code> target and <paramref name="data"/> is not evenly divisible 
        /// into the number of bytes needed to store in memory a datum indicated by <paramref name="type"/>.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glColorSubTable"/> is executed
        /// between the execution of  <see cref="glBegin"/>  and the corresponding
        /// execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glColorSubTable(GLenum target, GLsizei start, GLsizei count, GLenum format, GLenum type, const void * data);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Must be one of
        /// <code>GL_COLOR_TABLE</code>,
        /// <code>GL_POST_CONVOLUTION_COLOR_TABLE</code>, or
        /// <code>GL_POST_COLOR_MATRIX_COLOR_TABLE</code>.
        /// </para>
        /// </param>
        /// <param name="start">
        /// The starting index of the portion of the color table to be replaced.
        /// </param>
        /// <param name="count">
        /// The number of table entries to replace.
        /// </param>
        /// <param name="format">
        /// <para>
        /// The format of the pixel data in <paramref name="data"/>.
        /// The allowable values are
        /// <code>GL_RED</code>,
        /// <code>GL_GREEN</code>,
        /// <code>GL_BLUE</code>,
        /// <code>GL_ALPHA</code>,
        /// <code>GL_LUMINANCE</code>,
        /// <code>GL_LUMINANCE_ALPHA</code>,
        /// <code>GL_RGB</code>,
        /// <code>GL_BGR</code>,
        /// <code>GL_RGBA</code>, and
        /// <code>GL_BGRA</code>.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// The type of the pixel data in <paramref name="data"/>.
        /// The allowable values are
        /// <code>GL_UNSIGNED_BYTE</code>,
        /// <code>GL_BYTE</code>,
        /// <code>GL_UNSIGNED_SHORT</code>,
        /// <code>GL_SHORT</code>,
        /// <code>GL_UNSIGNED_INT</code>,
        /// <code>GL_INT</code>,
        /// <code>GL_FLOAT</code>,
        /// <code>GL_UNSIGNED_BYTE_3_3_2</code>,
        /// <code>GL_UNSIGNED_BYTE_2_3_3_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_5_6_5</code>,
        /// <code>GL_UNSIGNED_SHORT_5_6_5_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_4_4_4_4</code>,
        /// <code>GL_UNSIGNED_SHORT_4_4_4_4_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_5_5_5_1</code>,
        /// <code>GL_UNSIGNED_SHORT_1_5_5_5_REV</code>,
        /// <code>GL_UNSIGNED_INT_8_8_8_8</code>,
        /// <code>GL_UNSIGNED_INT_8_8_8_8_REV</code>,
        /// <code>GL_UNSIGNED_INT_10_10_10_2</code>, and
        /// <code>GL_UNSIGNED_INT_2_10_10_10_REV</code>.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Pointer to a one-dimensional array of pixel data that is processed to
        /// replace the specified region of the color table.
        /// </para>
        /// </param>
        /// <seealso cref="ColorTable"/>
        /// <seealso cref="ColorTableParameter"/>
        /// <seealso cref="CopyColorTable"/>
        /// <seealso cref="CopyColorSubTable"/>
        /// <seealso cref="GetColorTable"/>
        public unsafe static void ColorSubTable(uint target, int start, int count, uint format, uint type, IntPtr data) {
            GLNative.glColorSubTable(target, start, count, format, type, (void*)data);
        }

        /// <summary>
        /// define a one-dimensional convolution filter
        /// <para>Require:</para> <para>GL_ARB_imaging</para>
        /// Supported: <para>gl, glcore</para>
        /// Notes: 
        /// <para>
        /// <see cref="glConvolutionFilter1D"/> is present only if <code>ARB_imaging</code> is returned when  <see cref="glGetString"/> 
        /// is called with an argument of <code>GL_EXTENSIONS</code>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="target"/> is not
        /// <code>GL_CONVOLUTION_1D</code>.
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="internalformat"/> is not one of the
        /// allowable values.
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="format"/> is not one of the allowable
        /// values.
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="type"/> is not one of the allowable
        /// values.
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="width"/> is less than zero or greater
        /// than the maximum supported value.
        /// This value may be queried with  <see cref="glGetConvolutionParameter"/> 
        /// using target <code>GL_CONVOLUTION_1D</code> and name
        /// <code>GL_MAX_CONVOLUTION_WIDTH</code>.
        /// <code>GL_INVALID_OPERATION</code> is generated if <paramref name="type"/> is one of
        /// <code>GL_UNSIGNED_BYTE_3_3_2</code>,
        /// <code>GL_UNSIGNED_BYTE_2_3_3_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_5_6_5</code>, or
        /// <code>GL_UNSIGNED_SHORT_5_6_5_REV</code>
        /// and <paramref name="format"/> is not <code>GL_RGB</code>.
        /// <code>GL_INVALID_OPERATION</code> is generated if <paramref name="type"/> is one of
        /// <code>GL_UNSIGNED_SHORT_4_4_4_4</code>,
        /// <code>GL_UNSIGNED_SHORT_4_4_4_4_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_5_5_5_1</code>,
        /// <code>GL_UNSIGNED_SHORT_1_5_5_5_REV</code>,
        /// <code>GL_UNSIGNED_INT_8_8_8_8</code>,
        /// <code>GL_UNSIGNED_INT_8_8_8_8_REV</code>,
        /// <code>GL_UNSIGNED_INT_10_10_10_2</code>, or
        /// <code>GL_UNSIGNED_INT_2_10_10_10_REV</code>
        /// and <paramref name="format"/> is neither <code>GL_RGBA</code> nor <code>GL_BGRA</code>.
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_UNPACK_BUFFER</code> target and the buffer object's data store is currently mapped.
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_UNPACK_BUFFER</code> target and the data would be unpacked from the buffer 
        /// object such that the memory reads required would exceed the data store size.
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_UNPACK_BUFFER</code> target and <paramref name="data"/> is not evenly divisible 
        /// into the number of bytes needed to store in memory a datum indicated by <paramref name="type"/>.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glConvolutionFilter1D"/> is executed
        /// between the execution of  <see cref="glBegin"/>  and the corresponding
        /// execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glConvolutionFilter1D(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const void * data);</para>
        /// </summary>
        /// <param name="target">
        /// Must be <code>GL_CONVOLUTION_1D</code>.
        /// </param>
        /// <param name="internalformat">
        /// <para>
        /// The internal format of the convolution filter kernel.
        /// The allowable values are
        /// <code>GL_ALPHA</code>,
        /// <code>GL_ALPHA4</code>,
        /// <code>GL_ALPHA8</code>,
        /// <code>GL_ALPHA12</code>,
        /// <code>GL_ALPHA16</code>,
        /// <code>GL_LUMINANCE</code>,
        /// <code>GL_LUMINANCE4</code>,
        /// <code>GL_LUMINANCE8</code>,
        /// <code>GL_LUMINANCE12</code>,
        /// <code>GL_LUMINANCE16</code>,
        /// <code>GL_LUMINANCE_ALPHA</code>,
        /// <code>GL_LUMINANCE4_ALPHA4</code>,
        /// <code>GL_LUMINANCE6_ALPHA2</code>,
        /// <code>GL_LUMINANCE8_ALPHA8</code>,
        /// <code>GL_LUMINANCE12_ALPHA4</code>,
        /// <code>GL_LUMINANCE12_ALPHA12</code>,
        /// <code>GL_LUMINANCE16_ALPHA16</code>,
        /// <code>GL_INTENSITY</code>,
        /// <code>GL_INTENSITY4</code>,
        /// <code>GL_INTENSITY8</code>,
        /// <code>GL_INTENSITY12</code>,
        /// <code>GL_INTENSITY16</code>,
        /// <code>GL_R3_G3_B2</code>,
        /// <code>GL_RGB</code>,
        /// <code>GL_RGB4</code>,
        /// <code>GL_RGB5</code>,
        /// <code>GL_RGB8</code>,
        /// <code>GL_RGB10</code>,
        /// <code>GL_RGB12</code>,
        /// <code>GL_RGB16</code>,
        /// <code>GL_RGBA</code>,
        /// <code>GL_RGBA2</code>,
        /// <code>GL_RGBA4</code>,
        /// <code>GL_RGB5_A1</code>,
        /// <code>GL_RGBA8</code>,
        /// <code>GL_RGB10_A2</code>,
        /// <code>GL_RGBA12</code>, or
        /// <code>GL_RGBA16</code>.
        /// </para>
        /// </param>
        /// <param name="width">
        /// The width of the pixel array referenced by <paramref name="data"/>.
        /// </param>
        /// <param name="format">
        /// <para>
        /// The format of the pixel data in <paramref name="data"/>.
        /// The allowable values are
        /// <code>GL_ALPHA</code>,
        /// <code>GL_LUMINANCE</code>,
        /// <code>GL_LUMINANCE_ALPHA</code>,
        /// <code>GL_INTENSITY</code>,
        /// <code>GL_RGB</code>, and
        /// <code>GL_RGBA</code>.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// The type of the pixel data in <paramref name="data"/>.
        /// Symbolic constants
        /// <code>GL_UNSIGNED_BYTE</code>,
        /// <code>GL_BYTE</code>,
        /// <code>GL_BITMAP</code>,
        /// <code>GL_UNSIGNED_SHORT</code>,
        /// <code>GL_SHORT</code>,
        /// <code>GL_UNSIGNED_INT</code>,
        /// <code>GL_INT</code>,
        /// <code>GL_FLOAT</code>,
        /// <code>GL_UNSIGNED_BYTE_3_3_2</code>,
        /// <code>GL_UNSIGNED_BYTE_2_3_3_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_5_6_5</code>,
        /// <code>GL_UNSIGNED_SHORT_5_6_5_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_4_4_4_4</code>,
        /// <code>GL_UNSIGNED_SHORT_4_4_4_4_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_5_5_5_1</code>,
        /// <code>GL_UNSIGNED_SHORT_1_5_5_5_REV</code>,
        /// <code>GL_UNSIGNED_INT_8_8_8_8</code>,
        /// <code>GL_UNSIGNED_INT_8_8_8_8_REV</code>,
        /// <code>GL_UNSIGNED_INT_10_10_10_2</code>, and
        /// <code>GL_UNSIGNED_INT_2_10_10_10_REV</code>
        /// are accepted.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Pointer to a one-dimensional array of pixel data that is processed to
        /// build the convolution filter kernel.
        /// </para>
        /// </param>
        /// <seealso cref="ConvolutionFilter2D"/>
        /// <seealso cref="SeparableFilter2D"/>
        /// <seealso cref="ConvolutionParameter"/>
        /// <seealso cref="PixelTransfer"/>
        public unsafe static void ConvolutionFilter1D(uint target, uint internalformat, int width, uint format, uint type, IntPtr data) {
            GLNative.glConvolutionFilter1D(target, internalformat, width, format, type, (void*)data);
        }

        /// <summary>
        /// define a two-dimensional convolution filter
        /// <para>Require:</para> <para>GL_ARB_imaging</para>
        /// Supported: <para>gl, glcore</para>
        /// Notes: 
        /// <para>
        /// <see cref="glConvolutionFilter2D"/> is present only if <code>ARB_imaging</code> is returned when  <see cref="glGetString"/> 
        /// is called with an argument of <code>GL_EXTENSIONS</code>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="target"/> is not
        /// <code>GL_CONVOLUTION_2D</code>.
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="internalformat"/> is not one of the
        /// allowable values.
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="format"/> is not one of the allowable
        /// values.
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="type"/> is not one of the allowable
        /// values.
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="width"/> is less than zero or greater
        /// than the maximum supported value.
        /// This value may be queried with  <see cref="glGetConvolutionParameter"/> 
        /// using target <code>GL_CONVOLUTION_2D</code> and name
        /// <code>GL_MAX_CONVOLUTION_WIDTH</code>.
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="height"/> is less than zero or greater
        /// than the maximum supported value.
        /// This value may be queried with  <see cref="glGetConvolutionParameter"/> 
        /// using target <code>GL_CONVOLUTION_2D</code> and name
        /// <code>GL_MAX_CONVOLUTION_HEIGHT</code>.
        /// <code>GL_INVALID_OPERATION</code> is generated if <paramref name="type"/> is one of
        /// <code>GL_UNSIGNED_BYTE_3_3_2</code>,
        /// <code>GL_UNSIGNED_BYTE_2_3_3_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_5_6_5</code>, or
        /// <code>GL_UNSIGNED_SHORT_5_6_5_REV</code>
        /// and <paramref name="format"/> is not <code>GL_RGB</code>.
        /// <code>GL_INVALID_OPERATION</code> is generated if <paramref name="type"/> is one of
        /// <code>GL_UNSIGNED_SHORT_4_4_4_4</code>,
        /// <code>GL_UNSIGNED_SHORT_4_4_4_4_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_5_5_5_1</code>,
        /// <code>GL_UNSIGNED_SHORT_1_5_5_5_REV</code>,
        /// <code>GL_UNSIGNED_INT_8_8_8_8</code>,
        /// <code>GL_UNSIGNED_INT_8_8_8_8_REV</code>,
        /// <code>GL_UNSIGNED_INT_10_10_10_2</code>, or
        /// <code>GL_UNSIGNED_INT_2_10_10_10_REV</code>
        /// and <paramref name="format"/> is neither <code>GL_RGBA</code> nor <code>GL_BGRA</code>.
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_UNPACK_BUFFER</code> target and the buffer object's data store is currently mapped.
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_UNPACK_BUFFER</code> target and the data would be unpacked from the buffer 
        /// object such that the memory reads required would exceed the data store size.
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_UNPACK_BUFFER</code> target and <paramref name="data"/> is not evenly divisible 
        /// into the number of bytes needed to store in memory a datum indicated by <paramref name="type"/>.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glConvolutionFilter2D"/> is executed
        /// between the execution of  <see cref="glBegin"/>  and the corresponding
        /// execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glConvolutionFilter2D(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const void * data);</para>
        /// </summary>
        /// <param name="target">
        /// Must be <code>GL_CONVOLUTION_2D</code>.
        /// </param>
        /// <param name="internalformat">
        /// <para>
        /// The internal format of the convolution filter kernel.
        /// The allowable values are
        /// <code>GL_ALPHA</code>,
        /// <code>GL_ALPHA4</code>,
        /// <code>GL_ALPHA8</code>,
        /// <code>GL_ALPHA12</code>,
        /// <code>GL_ALPHA16</code>,
        /// <code>GL_LUMINANCE</code>,
        /// <code>GL_LUMINANCE4</code>,
        /// <code>GL_LUMINANCE8</code>,
        /// <code>GL_LUMINANCE12</code>,
        /// <code>GL_LUMINANCE16</code>,
        /// <code>GL_LUMINANCE_ALPHA</code>,
        /// <code>GL_LUMINANCE4_ALPHA4</code>,
        /// <code>GL_LUMINANCE6_ALPHA2</code>,
        /// <code>GL_LUMINANCE8_ALPHA8</code>,
        /// <code>GL_LUMINANCE12_ALPHA4</code>,
        /// <code>GL_LUMINANCE12_ALPHA12</code>,
        /// <code>GL_LUMINANCE16_ALPHA16</code>,
        /// <code>GL_INTENSITY</code>,
        /// <code>GL_INTENSITY4</code>,
        /// <code>GL_INTENSITY8</code>,
        /// <code>GL_INTENSITY12</code>,
        /// <code>GL_INTENSITY16</code>,
        /// <code>GL_R3_G3_B2</code>,
        /// <code>GL_RGB</code>,
        /// <code>GL_RGB4</code>,
        /// <code>GL_RGB5</code>,
        /// <code>GL_RGB8</code>,
        /// <code>GL_RGB10</code>,
        /// <code>GL_RGB12</code>,
        /// <code>GL_RGB16</code>,
        /// <code>GL_RGBA</code>,
        /// <code>GL_RGBA2</code>,
        /// <code>GL_RGBA4</code>,
        /// <code>GL_RGB5_A1</code>,
        /// <code>GL_RGBA8</code>,
        /// <code>GL_RGB10_A2</code>,
        /// <code>GL_RGBA12</code>, or
        /// <code>GL_RGBA16</code>.
        /// </para>
        /// </param>
        /// <param name="width">
        /// The width of the pixel array referenced by <paramref name="data"/>.
        /// </param>
        /// <param name="height">
        /// The height of the pixel array referenced by <paramref name="data"/>.
        /// </param>
        /// <param name="format">
        /// <para>
        /// The format of the pixel data in <paramref name="data"/>.
        /// The allowable values are
        /// <code>GL_RED</code>,
        /// <code>GL_GREEN</code>,
        /// <code>GL_BLUE</code>,
        /// <code>GL_ALPHA</code>,
        /// <code>GL_RGB</code>,
        /// <code>GL_BGR</code>,
        /// <code>GL_RGBA</code>,
        /// <code>GL_BGRA</code>,
        /// <code>GL_LUMINANCE</code>, and
        /// <code>GL_LUMINANCE_ALPHA</code>.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// The type of the pixel data in <paramref name="data"/>.
        /// Symbolic constants
        /// <code>GL_UNSIGNED_BYTE</code>,
        /// <code>GL_BYTE</code>,
        /// <code>GL_BITMAP</code>,
        /// <code>GL_UNSIGNED_SHORT</code>,
        /// <code>GL_SHORT</code>,
        /// <code>GL_UNSIGNED_INT</code>,
        /// <code>GL_INT</code>,
        /// <code>GL_FLOAT</code>,
        /// <code>GL_UNSIGNED_BYTE_3_3_2</code>,
        /// <code>GL_UNSIGNED_BYTE_2_3_3_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_5_6_5</code>,
        /// <code>GL_UNSIGNED_SHORT_5_6_5_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_4_4_4_4</code>,
        /// <code>GL_UNSIGNED_SHORT_4_4_4_4_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_5_5_5_1</code>,
        /// <code>GL_UNSIGNED_SHORT_1_5_5_5_REV</code>,
        /// <code>GL_UNSIGNED_INT_8_8_8_8</code>,
        /// <code>GL_UNSIGNED_INT_8_8_8_8_REV</code>,
        /// <code>GL_UNSIGNED_INT_10_10_10_2</code>, and
        /// <code>GL_UNSIGNED_INT_2_10_10_10_REV</code>
        /// are accepted.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Pointer to a two-dimensional array of pixel data that is processed to
        /// build the convolution filter kernel.
        /// </para>
        /// </param>
        /// <seealso cref="ConvolutionFilter1D"/>
        /// <seealso cref="SeparableFilter2D"/>
        /// <seealso cref="ConvolutionParameter"/>
        /// <seealso cref="PixelTransfer"/>
        public unsafe static void ConvolutionFilter2D(uint target, uint internalformat, int width, int height, uint format, uint type, IntPtr data) {
            GLNative.glConvolutionFilter2D(target, internalformat, width, height, format, type, (void*)data);
        }

        /// <summary>
        /// set convolution parameters
        /// <para>Require:</para> <para>GL_ARB_imaging</para>
        /// Supported: <para>gl, glcore</para>
        /// Notes: 
        /// <para>
        /// <see cref="glConvolutionParameter"/> is present only if <code>ARB_imaging</code> is returned when  <see cref="glGetString"/> 
        /// is called with an argument of <code>GL_EXTENSIONS</code>.
        /// In cases where errors can result from the specification of invalid
        /// image dimensions, it is the dimensions after convolution that are
        /// tested, not the dimensions of the source image.
        /// For example,  <see cref="glTexImage1D"/>  requires power-of-two image size.
        /// When <code>GL_REDUCE</code> border mode is in effect,
        /// the source image must be larger than the final power-of-two size
        /// by one less than the size of the 1D filter kernel.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="target"/> is not one of the allowable
        /// values.
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="pname"/> is not one of the allowable
        /// values.
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="pname"/> is
        /// <code>GL_CONVOLUTION_BORDER_MODE</code> and <paramref name="ps"/> is not one of
        /// <code>GL_REDUCE</code>, <code>GL_CONSTANT_BORDER</code>, or <code>GL_REPLICATE_BORDER</code>.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glConvolutionParameter"/> is executed
        /// between the execution of  <see cref="glBegin"/>  and the corresponding
        /// execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glConvolutionParameterfv(GLenum target, GLenum pname, const GLfloat * params);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// The target for the convolution parameter.
        /// Must be one of
        /// <code>GL_CONVOLUTION_1D</code>,
        /// <code>GL_CONVOLUTION_2D</code>, or
        /// <code>GL_SEPARABLE_2D</code>.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// The parameter to be set.
        /// Must be one of
        /// <code>GL_CONVOLUTION_BORDER_MODE</code>,
        /// <code>GL_CONVOLUTION_BORDER_COLOR</code>,
        /// <code>GL_CONVOLUTION_FILTER_SCALE</code>, or
        /// <code>GL_CONVOLUTION_FILTER_BIAS</code>.
        /// </para>
        /// </param>
        /// <param name="ps">
        /// <para>
        /// The parameter value.
        /// If <paramref name="pname"/>v is <code>GL_CONVOLUTION_BORDER_MODE</code>, <paramref name="ps"/>v must be one of
        /// <code>GL_REDUCE</code>, <code>GL_CONSTANT_BORDER</code>, or <code>GL_REPLICATE_BORDER</code>.
        /// Otherwise, must be a vector of four values (for red, green, blue, and alpha,
        /// respectively) to be used for
        /// scaling (when <paramref name="pname"/>v is <code>GL_CONVOLUTION_FILTER_SCALE</code>), or
        /// biasing (when <paramref name="pname"/>v is <code>GL_CONVOLUTION_FILTER_BIAS</code>) a convolution
        /// filter kernel or setting the constant border color (when <paramref name="pname"/>v is
        /// <code>GL_CONVOLUTION_BORDER_COLOR</code>.
        /// </para>
        /// </param>
        /// <seealso cref="ConvolutionFilter1D"/>
        /// <seealso cref="ConvolutionFilter2D"/>
        /// <seealso cref="SeparableFilter2D"/>
        /// <seealso cref="GetConvolutionParameter"/>
        public unsafe static void ConvolutionParameterfv(uint target, uint pname, ref float ps) {
            fixed (float* pPs = &ps) {
                GLNative.glConvolutionParameterfv(target, pname, pPs);
            }
        }

        /// <summary>
        /// set convolution parameters
        /// <para>Require:</para> <para>GL_ARB_imaging</para>
        /// Supported: <para>gl, glcore</para>
        /// Notes: 
        /// <para>
        /// <see cref="glConvolutionParameter"/> is present only if <code>ARB_imaging</code> is returned when  <see cref="glGetString"/> 
        /// is called with an argument of <code>GL_EXTENSIONS</code>.
        /// In cases where errors can result from the specification of invalid
        /// image dimensions, it is the dimensions after convolution that are
        /// tested, not the dimensions of the source image.
        /// For example,  <see cref="glTexImage1D"/>  requires power-of-two image size.
        /// When <code>GL_REDUCE</code> border mode is in effect,
        /// the source image must be larger than the final power-of-two size
        /// by one less than the size of the 1D filter kernel.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="target"/> is not one of the allowable
        /// values.
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="pname"/> is not one of the allowable
        /// values.
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="pname"/> is
        /// <code>GL_CONVOLUTION_BORDER_MODE</code> and <paramref name="ps"/> is not one of
        /// <code>GL_REDUCE</code>, <code>GL_CONSTANT_BORDER</code>, or <code>GL_REPLICATE_BORDER</code>.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glConvolutionParameter"/> is executed
        /// between the execution of  <see cref="glBegin"/>  and the corresponding
        /// execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glConvolutionParameteriv(GLenum target, GLenum pname, const GLint * params);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// The target for the convolution parameter.
        /// Must be one of
        /// <code>GL_CONVOLUTION_1D</code>,
        /// <code>GL_CONVOLUTION_2D</code>, or
        /// <code>GL_SEPARABLE_2D</code>.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// The parameter to be set.
        /// Must be one of
        /// <code>GL_CONVOLUTION_BORDER_MODE</code>,
        /// <code>GL_CONVOLUTION_BORDER_COLOR</code>,
        /// <code>GL_CONVOLUTION_FILTER_SCALE</code>, or
        /// <code>GL_CONVOLUTION_FILTER_BIAS</code>.
        /// </para>
        /// </param>
        /// <param name="ps">
        /// <para>
        /// The parameter value.
        /// If <paramref name="pname"/>v is <code>GL_CONVOLUTION_BORDER_MODE</code>, <paramref name="ps"/>v must be one of
        /// <code>GL_REDUCE</code>, <code>GL_CONSTANT_BORDER</code>, or <code>GL_REPLICATE_BORDER</code>.
        /// Otherwise, must be a vector of four values (for red, green, blue, and alpha,
        /// respectively) to be used for
        /// scaling (when <paramref name="pname"/>v is <code>GL_CONVOLUTION_FILTER_SCALE</code>), or
        /// biasing (when <paramref name="pname"/>v is <code>GL_CONVOLUTION_FILTER_BIAS</code>) a convolution
        /// filter kernel or setting the constant border color (when <paramref name="pname"/>v is
        /// <code>GL_CONVOLUTION_BORDER_COLOR</code>.
        /// </para>
        /// </param>
        /// <seealso cref="ConvolutionFilter1D"/>
        /// <seealso cref="ConvolutionFilter2D"/>
        /// <seealso cref="SeparableFilter2D"/>
        /// <seealso cref="GetConvolutionParameter"/>
        public unsafe static void ConvolutionParameteriv(uint target, uint pname, ref int ps) {
            fixed (int* pPs = &ps) {
                GLNative.glConvolutionParameteriv(target, pname, pPs);
            }
        }

        /// <summary>
        /// get current 1D or 2D convolution filter kernel
        /// <para>Require:</para> <para>GL_ARB_imaging</para>
        /// Supported: <para>gl, glcore</para>
        /// Notes: 
        /// <para>
        /// <see cref="glGetConvolutionFilter"/> is present only if <code>ARB_imaging</code> is returned when  <see cref="glGetString"/> 
        /// is called with an argument of <code>GL_EXTENSIONS</code>.
        /// The current separable 2D filter must be retrieved with
        /// <see cref="glGetSeparableFilter"/>  rather than <see cref="glGetConvolutionFilter"/>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="target"/> is not one of the allowable
        /// values.
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="format"/> is not one of the allowable
        /// values.
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="type"/> is not one of the allowable
        /// values.
        /// <code>GL_INVALID_OPERATION</code> is generated if <paramref name="type"/> is one of
        /// <code>GL_UNSIGNED_BYTE_3_3_2</code>,
        /// <code>GL_UNSIGNED_BYTE_2_3_3_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_5_6_5</code>, or
        /// <code>GL_UNSIGNED_SHORT_5_6_5_REV</code>
        /// and <paramref name="format"/> is not <code>GL_RGB</code>.
        /// <code>GL_INVALID_OPERATION</code> is generated if <paramref name="type"/> is one of
        /// <code>GL_UNSIGNED_SHORT_4_4_4_4</code>,
        /// <code>GL_UNSIGNED_SHORT_4_4_4_4_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_5_5_5_1</code>,
        /// <code>GL_UNSIGNED_SHORT_1_5_5_5_REV</code>,
        /// <code>GL_UNSIGNED_INT_8_8_8_8</code>,
        /// <code>GL_UNSIGNED_INT_8_8_8_8_REV</code>,
        /// <code>GL_UNSIGNED_INT_10_10_10_2</code>, or
        /// <code>GL_UNSIGNED_INT_2_10_10_10_REV</code>
        /// and <paramref name="format"/> is neither <code>GL_RGBA</code> nor <code>GL_BGRA</code>.
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_PACK_BUFFER</code> target and the buffer object's data store is currently mapped.
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_PACK_BUFFER</code> target and the data would be packed to the buffer 
        /// object such that the memory writes required would exceed the data store size.
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_PACK_BUFFER</code> target and <paramref name="image"/> is not evenly divisible 
        /// into the number of bytes needed to store in memory a datum indicated by <paramref name="type"/>.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glGetConvolutionFilter"/> is executed
        /// between the execution of  <see cref="glBegin"/>  and the corresponding
        /// execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glGetConvolutionFilter(GLenum target, GLenum format, GLenum type, void * image);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// The filter to be retrieved.
        /// Must be one of
        /// <code>GL_CONVOLUTION_1D</code> or
        /// <code>GL_CONVOLUTION_2D</code>.
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// Format of the output image.
        /// Must be one of
        /// <code>GL_RED</code>,
        /// <code>GL_GREEN</code>,
        /// <code>GL_BLUE</code>,
        /// <code>GL_ALPHA</code>,
        /// <code>GL_RGB</code>,
        /// <code>GL_BGR</code>,
        /// <code>GL_RGBA</code>,
        /// <code>GL_BGRA</code>,
        /// <code>GL_LUMINANCE</code>, or
        /// <code>GL_LUMINANCE_ALPHA</code>.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Data type of components in the output image.
        /// Symbolic constants
        /// <code>GL_UNSIGNED_BYTE</code>,
        /// <code>GL_BYTE</code>,
        /// <code>GL_BITMAP</code>,
        /// <code>GL_UNSIGNED_SHORT</code>,
        /// <code>GL_SHORT</code>,
        /// <code>GL_UNSIGNED_INT</code>,
        /// <code>GL_INT</code>,
        /// <code>GL_FLOAT</code>,
        /// <code>GL_UNSIGNED_BYTE_3_3_2</code>,
        /// <code>GL_UNSIGNED_BYTE_2_3_3_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_5_6_5</code>,
        /// <code>GL_UNSIGNED_SHORT_5_6_5_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_4_4_4_4</code>,
        /// <code>GL_UNSIGNED_SHORT_4_4_4_4_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_5_5_5_1</code>,
        /// <code>GL_UNSIGNED_SHORT_1_5_5_5_REV</code>,
        /// <code>GL_UNSIGNED_INT_8_8_8_8</code>,
        /// <code>GL_UNSIGNED_INT_8_8_8_8_REV</code>,
        /// <code>GL_UNSIGNED_INT_10_10_10_2</code>, and
        /// <code>GL_UNSIGNED_INT_2_10_10_10_REV</code>
        /// are accepted.
        /// </para>
        /// </param>
        /// <param name="image">
        /// Pointer to storage for the output image.
        /// </param>
        /// <seealso cref="GetSeparableFilter"/>
        /// <seealso cref="ConvolutionParameter"/>
        /// <seealso cref="ConvolutionFilter1D"/>
        /// <seealso cref="ConvolutionFilter2D"/>
        public unsafe static void GetConvolutionFilter(uint target, uint format, uint type, IntPtr image) {
            GLNative.glGetConvolutionFilter(target, format, type, (void*)image);
        }

        /// <summary>
        /// get convolution parameters
        /// <para>Require:</para> <para>GL_ARB_imaging</para>
        /// Supported: <para>gl, glcore</para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="target"/> is not one of the allowable
        /// values.
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="pname"/> is not one of the allowable
        /// values.
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="target"/> is <code>GL_CONVOLUTION_1D</code>
        /// and <paramref name="pname"/> is <code>GL_CONVOLUTION_HEIGHT</code> or
        /// <code>GL_MAX_CONVOLUTION_HEIGHT</code>.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glGetConvolutionParameter"/> is executed
        /// between the execution of  <see cref="glBegin"/>  and the corresponding
        /// execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glGetConvolutionParameterfv(GLenum target, GLenum pname, GLfloat * params);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// The filter whose parameters are to be retrieved.
        /// Must be one of
        /// <code>GL_CONVOLUTION_1D</code>,
        /// <code>GL_CONVOLUTION_2D</code>, or
        /// <code>GL_SEPARABLE_2D</code>.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// The parameter to be retrieved.
        /// Must be one of
        /// <code>GL_CONVOLUTION_BORDER_MODE</code>,
        /// <code>GL_CONVOLUTION_BORDER_COLOR</code>,
        /// <code>GL_CONVOLUTION_FILTER_SCALE</code>,
        /// <code>GL_CONVOLUTION_FILTER_BIAS</code>,
        /// <code>GL_CONVOLUTION_FORMAT</code>,
        /// <code>GL_CONVOLUTION_WIDTH</code>,
        /// <code>GL_CONVOLUTION_HEIGHT</code>,
        /// <code>GL_MAX_CONVOLUTION_WIDTH</code>, or
        /// <code>GL_MAX_CONVOLUTION_HEIGHT</code>.
        /// </para>
        /// </param>
        /// <param name="ps">
        /// Pointer to storage for the parameters to be retrieved.
        /// </param>
        /// <seealso cref="GetConvolutionFilter"/>
        /// <seealso cref="GetSeparableFilter"/>
        /// <seealso cref="ConvolutionParameter"/>
        public unsafe static void GetConvolutionParameterfv(uint target, uint pname, ref float ps) {
            fixed (float* pPs = &ps) {
                GLNative.glGetConvolutionParameterfv(target, pname, pPs);
            }
        }

        /// <summary>
        /// get convolution parameters
        /// <para>Require:</para> <para>GL_ARB_imaging</para>
        /// Supported: <para>gl, glcore</para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="target"/> is not one of the allowable
        /// values.
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="pname"/> is not one of the allowable
        /// values.
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="target"/> is <code>GL_CONVOLUTION_1D</code>
        /// and <paramref name="pname"/> is <code>GL_CONVOLUTION_HEIGHT</code> or
        /// <code>GL_MAX_CONVOLUTION_HEIGHT</code>.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glGetConvolutionParameter"/> is executed
        /// between the execution of  <see cref="glBegin"/>  and the corresponding
        /// execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glGetConvolutionParameteriv(GLenum target, GLenum pname, GLint * params);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// The filter whose parameters are to be retrieved.
        /// Must be one of
        /// <code>GL_CONVOLUTION_1D</code>,
        /// <code>GL_CONVOLUTION_2D</code>, or
        /// <code>GL_SEPARABLE_2D</code>.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// The parameter to be retrieved.
        /// Must be one of
        /// <code>GL_CONVOLUTION_BORDER_MODE</code>,
        /// <code>GL_CONVOLUTION_BORDER_COLOR</code>,
        /// <code>GL_CONVOLUTION_FILTER_SCALE</code>,
        /// <code>GL_CONVOLUTION_FILTER_BIAS</code>,
        /// <code>GL_CONVOLUTION_FORMAT</code>,
        /// <code>GL_CONVOLUTION_WIDTH</code>,
        /// <code>GL_CONVOLUTION_HEIGHT</code>,
        /// <code>GL_MAX_CONVOLUTION_WIDTH</code>, or
        /// <code>GL_MAX_CONVOLUTION_HEIGHT</code>.
        /// </para>
        /// </param>
        /// <param name="ps">
        /// Pointer to storage for the parameters to be retrieved.
        /// </param>
        /// <seealso cref="GetConvolutionFilter"/>
        /// <seealso cref="GetSeparableFilter"/>
        /// <seealso cref="ConvolutionParameter"/>
        public unsafe static void GetConvolutionParameteriv(uint target, uint pname, ref int ps) {
            fixed (int* pPs = &ps) {
                GLNative.glGetConvolutionParameteriv(target, pname, pPs);
            }
        }

        /// <summary>
        /// get separable convolution filter kernel images
        /// <para>Require:</para> <para>GL_ARB_imaging</para>
        /// Supported: <para>gl, glcore</para>
        /// Notes: 
        /// <para>
        /// <see cref="glGetSeparableFilter"/> is present only if <code>ARB_imaging</code> is returned when  <see cref="glGetString"/> 
        /// is called with an argument of <code>GL_EXTENSIONS</code>.
        /// Non-separable 2D filters must be retrieved with  <see cref="glGetConvolutionFilter"/> .
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="target"/> is not <code>GL_SEPARABLE_2D</code>.
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="format"/> is not one of the allowable
        /// values.
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="type"/> is not one of the allowable
        /// values.
        /// <code>GL_INVALID_OPERATION</code> is generated if <paramref name="type"/> is one of
        /// <code>GL_UNSIGNED_BYTE_3_3_2</code>,
        /// <code>GL_UNSIGNED_BYTE_2_3_3_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_5_6_5</code>, or
        /// <code>GL_UNSIGNED_SHORT_5_6_5_REV</code>
        /// and <paramref name="format"/> is not <code>GL_RGB</code>.
        /// <code>GL_INVALID_OPERATION</code> is generated if <paramref name="type"/> is one of
        /// <code>GL_UNSIGNED_SHORT_4_4_4_4</code>,
        /// <code>GL_UNSIGNED_SHORT_4_4_4_4_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_5_5_5_1</code>,
        /// <code>GL_UNSIGNED_SHORT_1_5_5_5_REV</code>,
        /// <code>GL_UNSIGNED_INT_8_8_8_8</code>,
        /// <code>GL_UNSIGNED_INT_8_8_8_8_REV</code>,
        /// <code>GL_UNSIGNED_INT_10_10_10_2</code>, or
        /// <code>GL_UNSIGNED_INT_2_10_10_10_REV</code>
        /// and <paramref name="format"/> is neither <code>GL_RGBA</code> nor <code>GL_BGRA</code>.
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_PACK_BUFFER</code> target and the buffer object's data store is currently mapped.
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_PACK_BUFFER</code> target and the data would be packed to the buffer 
        /// object such that the memory writes required would exceed the data store size.
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_PACK_BUFFER</code> target and <paramref name="row"/> or <paramref name="column"/> is not evenly divisible 
        /// into the number of bytes needed to store in memory a datum indicated by <paramref name="type"/>.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glGetSeparableFilter"/> is executed
        /// between the execution of  <see cref="glBegin"/>  and the corresponding
        /// execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glGetSeparableFilter(GLenum target, GLenum format, GLenum type, void * row, void * column, void * span);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// The separable filter to be retrieved.
        /// Must be
        /// <code>GL_SEPARABLE_2D</code>.
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// Format of the output images.
        /// Must be one of
        /// <code>GL_RED</code>,
        /// <code>GL_GREEN</code>,
        /// <code>GL_BLUE</code>,
        /// <code>GL_ALPHA</code>,
        /// <code>GL_RGB</code>,
        /// <code>GL_BGR</code>
        /// <code>GL_RGBA</code>,
        /// <code>GL_BGRA</code>,
        /// <code>GL_LUMINANCE</code>, or
        /// <code>GL_LUMINANCE_ALPHA</code>.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Data type of components in the output images.
        /// Symbolic constants
        /// <code>GL_UNSIGNED_BYTE</code>,
        /// <code>GL_BYTE</code>,
        /// <code>GL_BITMAP</code>,
        /// <code>GL_UNSIGNED_SHORT</code>,
        /// <code>GL_SHORT</code>,
        /// <code>GL_UNSIGNED_INT</code>,
        /// <code>GL_INT</code>,
        /// <code>GL_FLOAT</code>,
        /// <code>GL_UNSIGNED_BYTE_3_3_2</code>,
        /// <code>GL_UNSIGNED_BYTE_2_3_3_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_5_6_5</code>,
        /// <code>GL_UNSIGNED_SHORT_5_6_5_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_4_4_4_4</code>,
        /// <code>GL_UNSIGNED_SHORT_4_4_4_4_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_5_5_5_1</code>,
        /// <code>GL_UNSIGNED_SHORT_1_5_5_5_REV</code>,
        /// <code>GL_UNSIGNED_INT_8_8_8_8</code>,
        /// <code>GL_UNSIGNED_INT_8_8_8_8_REV</code>,
        /// <code>GL_UNSIGNED_INT_10_10_10_2</code>, and
        /// <code>GL_UNSIGNED_INT_2_10_10_10_REV</code>
        /// are accepted.
        /// </para>
        /// </param>
        /// <param name="row">
        /// Pointer to storage for the row filter image.
        /// </param>
        /// <param name="column">
        /// Pointer to storage for the column filter image.
        /// </param>
        /// <param name="span">
        /// Pointer to storage for the span filter image (currently unused).
        /// </param>
        /// <seealso cref="GetConvolutionFilter"/>
        /// <seealso cref="ConvolutionParameter"/>
        /// <seealso cref="SeparableFilter2D"/>
        public unsafe static void GetSeparableFilter(uint target, uint format, uint type, IntPtr row, IntPtr column, IntPtr span) {
            GLNative.glGetSeparableFilter(target, format, type, (void*)row, (void*)column, (void*)span);
        }

        /// <summary>
        /// define a separable two-dimensional convolution filter
        /// <para>Require:</para> <para>GL_ARB_imaging</para>
        /// Supported: <para>gl, glcore</para>
        /// Notes: 
        /// <para>
        /// <see cref="glSeparableFilter2D"/> is present only if <code>ARB_imaging</code> is returned when  <see cref="glGetString"/> 
        /// is called with an argument of <code>GL_EXTENSIONS</code>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="target"/> is not
        /// <code>GL_SEPARABLE_2D</code>.
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="internalformat"/> is not one of the
        /// allowable values.
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="format"/> is not one of the allowable
        /// values.
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="type"/> is not one of the allowable
        /// values.
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="width"/> is less than zero or greater
        /// than the maximum supported value.
        /// This value may be queried with  <see cref="glGetConvolutionParameter"/> 
        /// using target <code>GL_SEPARABLE_2D</code> and name
        /// <code>GL_MAX_CONVOLUTION_WIDTH</code>.
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="height"/> is less than zero or greater
        /// than the maximum supported value.
        /// This value may be queried with  <see cref="glGetConvolutionParameter"/> 
        /// using target <code>GL_SEPARABLE_2D</code> and name
        /// <code>GL_MAX_CONVOLUTION_HEIGHT</code>.
        /// <code>GL_INVALID_OPERATION</code> is generated if <paramref name="height"/> is one of
        /// <code>GL_UNSIGNED_BYTE_3_3_2</code>,
        /// <code>GL_UNSIGNED_BYTE_2_3_3_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_5_6_5</code>, or
        /// <code>GL_UNSIGNED_SHORT_5_6_5_REV</code>
        /// and <paramref name="format"/> is not <code>GL_RGB</code>.
        /// <code>GL_INVALID_OPERATION</code> is generated if <paramref name="height"/> is one of
        /// <code>GL_UNSIGNED_SHORT_4_4_4_4</code>,
        /// <code>GL_UNSIGNED_SHORT_4_4_4_4_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_5_5_5_1</code>,
        /// <code>GL_UNSIGNED_SHORT_1_5_5_5_REV</code>,
        /// <code>GL_UNSIGNED_INT_8_8_8_8</code>,
        /// <code>GL_UNSIGNED_INT_8_8_8_8_REV</code>,
        /// <code>GL_UNSIGNED_INT_10_10_10_2</code>, or
        /// <code>GL_UNSIGNED_INT_2_10_10_10_REV</code>
        /// and <paramref name="format"/> is neither <code>GL_RGBA</code> nor <code>GL_BGRA</code>.
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_UNPACK_BUFFER</code> target and the buffer object's data store is currently mapped.
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_UNPACK_BUFFER</code> target and the data would be unpacked from the buffer 
        /// object such that the memory reads required would exceed the data store size.
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_UNPACK_BUFFER</code> target and <paramref name="row"/> or 
        /// <paramref name="column"/> is not evenly divisible 
        /// into the number of bytes needed to store in memory a datum indicated by <paramref name="type"/>.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glSeparableFilter2D"/> is executed
        /// between the execution of  <see cref="glBegin"/>  and the corresponding
        /// execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glSeparableFilter2D(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const void * row, const void * column);</para>
        /// </summary>
        /// <param name="target">
        /// Must be <code>GL_SEPARABLE_2D</code>.
        /// </param>
        /// <param name="internalformat">
        /// <para>
        /// The internal format of the convolution filter kernel.
        /// The allowable values are
        /// <code>GL_ALPHA</code>,
        /// <code>GL_ALPHA4</code>,
        /// <code>GL_ALPHA8</code>,
        /// <code>GL_ALPHA12</code>,
        /// <code>GL_ALPHA16</code>,
        /// <code>GL_LUMINANCE</code>,
        /// <code>GL_LUMINANCE4</code>,
        /// <code>GL_LUMINANCE8</code>,
        /// <code>GL_LUMINANCE12</code>,
        /// <code>GL_LUMINANCE16</code>,
        /// <code>GL_LUMINANCE_ALPHA</code>,
        /// <code>GL_LUMINANCE4_ALPHA4</code>,
        /// <code>GL_LUMINANCE6_ALPHA2</code>,
        /// <code>GL_LUMINANCE8_ALPHA8</code>,
        /// <code>GL_LUMINANCE12_ALPHA4</code>,
        /// <code>GL_LUMINANCE12_ALPHA12</code>,
        /// <code>GL_LUMINANCE16_ALPHA16</code>,
        /// <code>GL_INTENSITY</code>,
        /// <code>GL_INTENSITY4</code>,
        /// <code>GL_INTENSITY8</code>,
        /// <code>GL_INTENSITY12</code>,
        /// <code>GL_INTENSITY16</code>,
        /// <code>GL_R3_G3_B2</code>,
        /// <code>GL_RGB</code>,
        /// <code>GL_RGB4</code>,
        /// <code>GL_RGB5</code>,
        /// <code>GL_RGB8</code>,
        /// <code>GL_RGB10</code>,
        /// <code>GL_RGB12</code>,
        /// <code>GL_RGB16</code>,
        /// <code>GL_RGBA</code>,
        /// <code>GL_RGBA2</code>,
        /// <code>GL_RGBA4</code>,
        /// <code>GL_RGB5_A1</code>,
        /// <code>GL_RGBA8</code>,
        /// <code>GL_RGB10_A2</code>,
        /// <code>GL_RGBA12</code>, or
        /// <code>GL_RGBA16</code>.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// The number of elements in the pixel array referenced by <paramref name="row"/>.
        /// (This is the width of the separable filter kernel.)
        /// </para>
        /// </param>
        /// <param name="height">
        /// <para>
        /// The number of elements in the pixel array referenced by <paramref name="column"/>.
        /// (This is the height of the separable filter kernel.)
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// The format of the pixel data in <paramref name="row"/> and <paramref name="column"/>.
        /// The allowable values are
        /// <code>GL_RED</code>,
        /// <code>GL_GREEN</code>,
        /// <code>GL_BLUE</code>,
        /// <code>GL_ALPHA</code>,
        /// <code>GL_RGB</code>,
        /// <code>GL_BGR</code>,
        /// <code>GL_RGBA</code>,
        /// <code>GL_BGRA</code>,
        /// <code>GL_INTENSITY</code>,
        /// <code>GL_LUMINANCE</code>, and
        /// <code>GL_LUMINANCE_ALPHA</code>.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// The type of the pixel data in <paramref name="row"/> and <paramref name="column"/>.
        /// Symbolic constants
        /// <code>GL_UNSIGNED_BYTE</code>,
        /// <code>GL_BYTE</code>,
        /// <code>GL_BITMAP</code>,
        /// <code>GL_UNSIGNED_SHORT</code>,
        /// <code>GL_SHORT</code>,
        /// <code>GL_UNSIGNED_INT</code>,
        /// <code>GL_INT</code>,
        /// <code>GL_FLOAT</code>,
        /// <code>GL_UNSIGNED_BYTE_3_3_2</code>,
        /// <code>GL_UNSIGNED_BYTE_2_3_3_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_5_6_5</code>,
        /// <code>GL_UNSIGNED_SHORT_5_6_5_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_4_4_4_4</code>,
        /// <code>GL_UNSIGNED_SHORT_4_4_4_4_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_5_5_5_1</code>,
        /// <code>GL_UNSIGNED_SHORT_1_5_5_5_REV</code>,
        /// <code>GL_UNSIGNED_INT_8_8_8_8</code>,
        /// <code>GL_UNSIGNED_INT_8_8_8_8_REV</code>,
        /// <code>GL_UNSIGNED_INT_10_10_10_2</code>, and
        /// <code>GL_UNSIGNED_INT_2_10_10_10_REV</code>
        /// are accepted.
        /// </para>
        /// </param>
        /// <param name="row">
        /// <para>
        /// Pointer to a one-dimensional array of pixel data that is processed to
        /// build the row filter kernel.
        /// </para>
        /// </param>
        /// <param name="column">
        /// <para>
        /// Pointer to a one-dimensional array of pixel data that is processed to
        /// build the column filter kernel.
        /// </para>
        /// </param>
        /// <seealso cref="ConvolutionFilter1D"/>
        /// <seealso cref="ConvolutionFilter2D"/>
        /// <seealso cref="ConvolutionParameter"/>
        /// <seealso cref="PixelTransfer"/>
        public unsafe static void SeparableFilter2D(uint target, uint internalformat, int width, int height, uint format, uint type, IntPtr row, IntPtr column) {
            GLNative.glSeparableFilter2D(target, internalformat, width, height, format, type, (void*)row, (void*)column);
        }

        /// <summary>
        /// get histogram table
        /// <para>Require:</para> <para>GL_ARB_imaging</para>
        /// Supported: <para>gl, glcore</para>
        /// Notes: 
        /// <para>
        /// <see cref="glGetHistogram"/> is present only if <code>ARB_imaging</code> is returned when  <see cref="glGetString"/> 
        /// is called with an argument of <code>GL_EXTENSIONS</code>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="target"/> is not <code>GL_HISTOGRAM</code>.
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="format"/> is not one of the allowable
        /// values.
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="type"/> is not one of the allowable
        /// values.
        /// <code>GL_INVALID_OPERATION</code> is generated if <paramref name="type"/> is one of
        /// <code>GL_UNSIGNED_BYTE_3_3_2</code>,
        /// <code>GL_UNSIGNED_BYTE_2_3_3_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_5_6_5</code>, or
        /// <code>GL_UNSIGNED_SHORT_5_6_5_REV</code>
        /// and <paramref name="format"/> is not <code>GL_RGB</code>.
        /// <code>GL_INVALID_OPERATION</code> is generated if <paramref name="type"/> is one of
        /// <code>GL_UNSIGNED_SHORT_4_4_4_4</code>,
        /// <code>GL_UNSIGNED_SHORT_4_4_4_4_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_5_5_5_1</code>,
        /// <code>GL_UNSIGNED_SHORT_1_5_5_5_REV</code>,
        /// <code>GL_UNSIGNED_INT_8_8_8_8</code>,
        /// <code>GL_UNSIGNED_INT_8_8_8_8_REV</code>,
        /// <code>GL_UNSIGNED_INT_10_10_10_2</code>, or
        /// <code>GL_UNSIGNED_INT_2_10_10_10_REV</code>
        /// and <paramref name="format"/> is neither <code>GL_RGBA</code> nor <code>GL_BGRA</code>.
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_PACK_BUFFER</code> target and the buffer object's data store is currently mapped.
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_PACK_BUFFER</code> target and the data would be packed to the buffer 
        /// object such that the memory writes required would exceed the data store size.
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_PACK_BUFFER</code> target and <paramref name="values"/> is not evenly divisible 
        /// into the number of bytes needed to store in memory a datum indicated by <paramref name="type"/>.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glGetHistogram"/> is executed
        /// between the execution of  <see cref="glBegin"/>  and the corresponding
        /// execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glGetHistogram(GLenum target, GLboolean reset, GLenum format, GLenum type, void * values);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Must be
        /// <code>GL_HISTOGRAM</code>.
        /// </para>
        /// </param>
        /// <param name="reset">
        /// <para>
        /// If <code>GL_TRUE</code>, each component counter that is actually returned
        /// is reset to zero.  (Other counters are unaffected.)
        /// If <code>GL_FALSE</code>, none of the counters in the histogram table is modified.
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// The format of values to be returned in <paramref name="values"/>.
        /// Must be one of
        /// <code>GL_RED</code>,
        /// <code>GL_GREEN</code>,
        /// <code>GL_BLUE</code>,
        /// <code>GL_ALPHA</code>,
        /// <code>GL_RGB</code>,
        /// <code>GL_BGR</code>,
        /// <code>GL_RGBA</code>,
        /// <code>GL_BGRA</code>,
        /// <code>GL_LUMINANCE</code>, or
        /// <code>GL_LUMINANCE_ALPHA</code>.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// The type of values to be returned in <paramref name="values"/>.
        /// Symbolic constants
        /// <code>GL_UNSIGNED_BYTE</code>,
        /// <code>GL_BYTE</code>,
        /// <code>GL_BITMAP</code>,
        /// <code>GL_UNSIGNED_SHORT</code>,
        /// <code>GL_SHORT</code>,
        /// <code>GL_UNSIGNED_INT</code>,
        /// <code>GL_INT</code>,
        /// <code>GL_FLOAT</code>,
        /// <code>GL_UNSIGNED_BYTE_3_3_2</code>,
        /// <code>GL_UNSIGNED_BYTE_2_3_3_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_5_6_5</code>,
        /// <code>GL_UNSIGNED_SHORT_5_6_5_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_4_4_4_4</code>,
        /// <code>GL_UNSIGNED_SHORT_4_4_4_4_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_5_5_5_1</code>,
        /// <code>GL_UNSIGNED_SHORT_1_5_5_5_REV</code>,
        /// <code>GL_UNSIGNED_INT_8_8_8_8</code>,
        /// <code>GL_UNSIGNED_INT_8_8_8_8_REV</code>,
        /// <code>GL_UNSIGNED_INT_10_10_10_2</code>, and
        /// <code>GL_UNSIGNED_INT_2_10_10_10_REV</code>
        /// are accepted.
        /// </para>
        /// </param>
        /// <param name="values">
        /// A pointer to storage for the returned histogram table.
        /// </param>
        /// <seealso cref="Histogram"/>
        /// <seealso cref="ResetHistogram"/>
        public unsafe static void GetHistogram(uint target, bool reset, uint format, uint type, IntPtr values) {
            GLNative.glGetHistogram(target, reset, format, type, (void*)values);
        }

        /// <summary>
        /// get histogram parameters
        /// <para>Require:</para> <para>GL_ARB_imaging</para>
        /// Supported: <para>gl, glcore</para>
        /// Notes: 
        /// <para>
        /// <see cref="glGetHistogramParameter"/> is present only if <code>ARB_imaging</code> is returned when  <see cref="glGetString"/> 
        /// is called with an argument of <code>GL_EXTENSIONS</code>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="target"/> is not one of the allowable
        /// values.
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="pname"/> is not one of the allowable
        /// values.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glGetHistogramParameter"/> is executed
        /// between the execution of  <see cref="glBegin"/>  and the corresponding
        /// execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glGetHistogramParameterfv(GLenum target, GLenum pname, GLfloat * params);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Must be one of
        /// <code>GL_HISTOGRAM</code> or
        /// <code>GL_PROXY_HISTOGRAM</code>.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// The name of the parameter to be retrieved.
        /// Must be one of
        /// <code>GL_HISTOGRAM_WIDTH</code>,
        /// <code>GL_HISTOGRAM_FORMAT</code>,
        /// <code>GL_HISTOGRAM_RED_SIZE</code>,
        /// <code>GL_HISTOGRAM_GREEN_SIZE</code>,
        /// <code>GL_HISTOGRAM_BLUE_SIZE</code>,
        /// <code>GL_HISTOGRAM_ALPHA_SIZE</code>,
        /// <code>GL_HISTOGRAM_LUMINANCE_SIZE</code>, or
        /// <code>GL_HISTOGRAM_SINK</code>.
        /// </para>
        /// </param>
        /// <param name="ps">
        /// Pointer to storage for the returned values.
        /// </param>
        /// <seealso cref="GetHistogram"/>
        /// <seealso cref="Histogram"/>
        public unsafe static void GetHistogramParameterfv(uint target, uint pname, ref float ps) {
            fixed (float* pPs = &ps) {
                GLNative.glGetHistogramParameterfv(target, pname, pPs);
            }
        }

        /// <summary>
        /// get histogram parameters
        /// <para>Require:</para> <para>GL_ARB_imaging</para>
        /// Supported: <para>gl, glcore</para>
        /// Notes: 
        /// <para>
        /// <see cref="glGetHistogramParameter"/> is present only if <code>ARB_imaging</code> is returned when  <see cref="glGetString"/> 
        /// is called with an argument of <code>GL_EXTENSIONS</code>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="target"/> is not one of the allowable
        /// values.
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="pname"/> is not one of the allowable
        /// values.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glGetHistogramParameter"/> is executed
        /// between the execution of  <see cref="glBegin"/>  and the corresponding
        /// execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glGetHistogramParameteriv(GLenum target, GLenum pname, GLint * params);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Must be one of
        /// <code>GL_HISTOGRAM</code> or
        /// <code>GL_PROXY_HISTOGRAM</code>.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// The name of the parameter to be retrieved.
        /// Must be one of
        /// <code>GL_HISTOGRAM_WIDTH</code>,
        /// <code>GL_HISTOGRAM_FORMAT</code>,
        /// <code>GL_HISTOGRAM_RED_SIZE</code>,
        /// <code>GL_HISTOGRAM_GREEN_SIZE</code>,
        /// <code>GL_HISTOGRAM_BLUE_SIZE</code>,
        /// <code>GL_HISTOGRAM_ALPHA_SIZE</code>,
        /// <code>GL_HISTOGRAM_LUMINANCE_SIZE</code>, or
        /// <code>GL_HISTOGRAM_SINK</code>.
        /// </para>
        /// </param>
        /// <param name="ps">
        /// Pointer to storage for the returned values.
        /// </param>
        /// <seealso cref="GetHistogram"/>
        /// <seealso cref="Histogram"/>
        public unsafe static void GetHistogramParameteriv(uint target, uint pname, ref int ps) {
            fixed (int* pPs = &ps) {
                GLNative.glGetHistogramParameteriv(target, pname, pPs);
            }
        }

        /// <summary>
        /// get minimum and maximum pixel values
        /// <para>Require:</para> <para>GL_ARB_imaging</para>
        /// Supported: <para>gl, glcore</para>
        /// Notes: 
        /// <para>
        /// <see cref="glGetMinmax"/> is present only if <code>ARB_imaging</code> is returned when  <see cref="glGetString"/> 
        /// is called with an argument of <code>GL_EXTENSIONS</code>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="target"/> is not <code>GL_MINMAX</code>.
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="format"/> is not one of the allowable
        /// values.
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="types"/> is not one of the allowable
        /// values.
        /// <code>GL_INVALID_OPERATION</code> is generated if <paramref name="types"/> is one of
        /// <code>GL_UNSIGNED_BYTE_3_3_2</code>,
        /// <code>GL_UNSIGNED_BYTE_2_3_3_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_5_6_5</code>, or
        /// <code>GL_UNSIGNED_SHORT_5_6_5_REV</code>
        /// and <paramref name="format"/> is not <code>GL_RGB</code>.
        /// <code>GL_INVALID_OPERATION</code> is generated if <paramref name="types"/> is one of
        /// <code>GL_UNSIGNED_SHORT_4_4_4_4</code>,
        /// <code>GL_UNSIGNED_SHORT_4_4_4_4_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_5_5_5_1</code>,
        /// <code>GL_UNSIGNED_SHORT_1_5_5_5_REV</code>,
        /// <code>GL_UNSIGNED_INT_8_8_8_8</code>,
        /// <code>GL_UNSIGNED_INT_8_8_8_8_REV</code>,
        /// <code>GL_UNSIGNED_INT_10_10_10_2</code>, or
        /// <code>GL_UNSIGNED_INT_2_10_10_10_REV</code>
        /// and <paramref name="format"/> is neither <code>GL_RGBA</code> nor <code>GL_BGRA</code>.
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_PACK_BUFFER</code> target and the buffer object's data store is currently mapped.
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_PACK_BUFFER</code> target and the data would be packed to the buffer 
        /// object such that the memory writes required would exceed the data store size.
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_PACK_BUFFER</code> target and <paramref name="values"/> is not evenly divisible 
        /// into the number of bytes needed to store in memory a datum indicated by <paramref name="type"/>.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glGetMinmax"/> is executed
        /// between the execution of  <see cref="glBegin"/>  and the corresponding
        /// execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glGetMinmax(GLenum target, GLboolean reset, GLenum format, GLenum types, void * values);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Must be
        /// <code>GL_MINMAX</code>.
        /// </para>
        /// </param>
        /// <param name="reset">
        /// <para>
        /// If <code>GL_TRUE</code>, all entries in the minmax table that are actually
        /// returned are reset to their initial values.  (Other entries are unaltered.)
        /// If <code>GL_FALSE</code>, the minmax table is unaltered.
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// The format of the data to be returned in <paramref name="values"/>.
        /// Must be one of
        /// <code>GL_RED</code>,
        /// <code>GL_GREEN</code>,
        /// <code>GL_BLUE</code>,
        /// <code>GL_ALPHA</code>,
        /// <code>GL_RGB</code>,
        /// <code>GL_BGR</code>,
        /// <code>GL_RGBA</code>,
        /// <code>GL_BGRA</code>,
        /// <code>GL_LUMINANCE</code>, or
        /// <code>GL_LUMINANCE_ALPHA</code>.
        /// </para>
        /// </param>
        /// <param name="types">
        /// <para>
        /// The type of the data to be returned in <paramref name="values"/>.
        /// Symbolic constants
        /// <code>GL_UNSIGNED_BYTE</code>,
        /// <code>GL_BYTE</code>,
        /// <code>GL_BITMAP</code>,
        /// <code>GL_UNSIGNED_SHORT</code>,
        /// <code>GL_SHORT</code>,
        /// <code>GL_UNSIGNED_INT</code>,
        /// <code>GL_INT</code>,
        /// <code>GL_FLOAT</code>,
        /// <code>GL_UNSIGNED_BYTE_3_3_2</code>,
        /// <code>GL_UNSIGNED_BYTE_2_3_3_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_5_6_5</code>,
        /// <code>GL_UNSIGNED_SHORT_5_6_5_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_4_4_4_4</code>,
        /// <code>GL_UNSIGNED_SHORT_4_4_4_4_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_5_5_5_1</code>,
        /// <code>GL_UNSIGNED_SHORT_1_5_5_5_REV</code>,
        /// <code>GL_UNSIGNED_INT_8_8_8_8</code>,
        /// <code>GL_UNSIGNED_INT_8_8_8_8_REV</code>,
        /// <code>GL_UNSIGNED_INT_10_10_10_2</code>, and
        /// <code>GL_UNSIGNED_INT_2_10_10_10_REV</code>
        /// are accepted.
        /// </para>
        /// </param>
        /// <param name="values">
        /// A pointer to storage for the returned values.
        /// </param>
        /// <seealso cref="Minmax"/>
        /// <seealso cref="ResetMinmax"/>
        public unsafe static void GetMinmax(uint target, bool reset, uint format, uint types, IntPtr values) {
            GLNative.glGetMinmax(target, reset, format, types, (void*)values);
        }

        /// <summary>
        /// get minmax parameters
        /// <para>Require:</para> <para>GL_ARB_imaging</para>
        /// Supported: <para>gl, glcore</para>
        /// Notes: 
        /// <para>
        /// <see cref="glGetMinmaxParameter"/> is present only if <code>ARB_imaging</code> is returned when  <see cref="glGetString"/> 
        /// is called with an argument of <code>GL_EXTENSIONS</code>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="target"/> is not <code>GL_MINMAX</code>.
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="pname"/> is not one of the allowable
        /// values.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glGetMinmaxParameter"/> is executed
        /// between the execution of  <see cref="glBegin"/>  and the corresponding
        /// execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glGetMinmaxParameterfv(GLenum target, GLenum pname, GLfloat * params);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Must be
        /// <code>GL_MINMAX</code>.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// The parameter to be retrieved.
        /// Must be one of
        /// <code>GL_MINMAX_FORMAT</code> or
        /// <code>GL_MINMAX_SINK</code>.
        /// </para>
        /// </param>
        /// <param name="ps">
        /// A pointer to storage for the retrieved parameters.
        /// </param>
        /// <seealso cref="Minmax"/>
        /// <seealso cref="GetMinmax"/>
        public unsafe static void GetMinmaxParameterfv(uint target, uint pname, ref float ps) {
            fixed (float* pPs = &ps) {
                GLNative.glGetMinmaxParameterfv(target, pname, pPs);
            }
        }

        /// <summary>
        /// get minmax parameters
        /// <para>Require:</para> <para>GL_ARB_imaging</para>
        /// Supported: <para>gl, glcore</para>
        /// Notes: 
        /// <para>
        /// <see cref="glGetMinmaxParameter"/> is present only if <code>ARB_imaging</code> is returned when  <see cref="glGetString"/> 
        /// is called with an argument of <code>GL_EXTENSIONS</code>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="target"/> is not <code>GL_MINMAX</code>.
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="pname"/> is not one of the allowable
        /// values.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glGetMinmaxParameter"/> is executed
        /// between the execution of  <see cref="glBegin"/>  and the corresponding
        /// execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glGetMinmaxParameteriv(GLenum target, GLenum pname, GLint * params);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Must be
        /// <code>GL_MINMAX</code>.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// The parameter to be retrieved.
        /// Must be one of
        /// <code>GL_MINMAX_FORMAT</code> or
        /// <code>GL_MINMAX_SINK</code>.
        /// </para>
        /// </param>
        /// <param name="ps">
        /// A pointer to storage for the retrieved parameters.
        /// </param>
        /// <seealso cref="Minmax"/>
        /// <seealso cref="GetMinmax"/>
        public unsafe static void GetMinmaxParameteriv(uint target, uint pname, ref int ps) {
            fixed (int* pPs = &ps) {
                GLNative.glGetMinmaxParameteriv(target, pname, pPs);
            }
        }


        #endregion GL_ARB_imaging

        #region GL_ARB_indirect_parameters

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_indirect_parameters</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glMultiDrawArraysIndirectCountARB(GLenum mode, const void * indirect, GLintptr drawcount, GLsizei maxdrawcount, GLsizei stride);</para>
        /// </summary>
        public unsafe static void MultiDrawArraysIndirectCountARB(uint mode, IntPtr indirect, IntPtr drawcount, int maxdrawcount, int stride) {
            GLNative.glMultiDrawArraysIndirectCountARB(mode, (void*)indirect, drawcount, maxdrawcount, stride);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_indirect_parameters</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glMultiDrawElementsIndirectCountARB(GLenum mode, GLenum type, const void * indirect, GLintptr drawcount, GLsizei maxdrawcount, GLsizei stride);</para>
        /// </summary>
        public unsafe static void MultiDrawElementsIndirectCountARB(uint mode, uint type, IntPtr indirect, IntPtr drawcount, int maxdrawcount, int stride) {
            GLNative.glMultiDrawElementsIndirectCountARB(mode, type, (void*)indirect, drawcount, maxdrawcount, stride);
        }


        #endregion GL_ARB_indirect_parameters

        #region GL_ARB_instanced_arrays


        #endregion GL_ARB_instanced_arrays

        #region GL_ARB_internalformat_query

        // void glGetInternalformativ(GLenum target, GLenum internalformat, GLenum pname, GLsizei bufSize, GLint * ps);

        #endregion GL_ARB_internalformat_query

        #region GL_ARB_invalidate_subdata

        // void glInvalidateFramebuffer(GLenum target, GLsizei numAttachments, const GLenum * attachments);
        // void glInvalidateSubFramebuffer(GLenum target, GLsizei numAttachments, const GLenum * attachments, GLint x, GLint y, GLint width, GLint height);

        #endregion GL_ARB_invalidate_subdata

        #region GL_ARB_map_buffer_range

        // void * glMapBufferRange(GLenum target, GLintptr offset, GLsizeiptr length, GLbitfield access);

        #endregion GL_ARB_map_buffer_range

        #region GL_ARB_matrix_palette

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_matrix_palette</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glMatrixIndexubvARB(GLint size, const GLubyte * indices);</para>
        /// </summary>
        public unsafe static void MatrixIndexubvARB(int size, ref byte indices) {
            fixed (byte* pIndices = &indices) {
                GLNative.glMatrixIndexubvARB(size, pIndices);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_matrix_palette</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glMatrixIndexusvARB(GLint size, const GLushort * indices);</para>
        /// </summary>
        public unsafe static void MatrixIndexusvARB(int size, ref ushort indices) {
            fixed (ushort* pIndices = &indices) {
                GLNative.glMatrixIndexusvARB(size, pIndices);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_matrix_palette</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glMatrixIndexuivARB(GLint size, const GLuint * indices);</para>
        /// </summary>
        public unsafe static void MatrixIndexuivARB(int size, ref uint indices) {
            fixed (uint* pIndices = &indices) {
                GLNative.glMatrixIndexuivARB(size, pIndices);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_matrix_palette</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glMatrixIndexPointerARB(GLint size, GLenum type, GLsizei stride, const void * pointer);</para>
        /// </summary>
        public unsafe static void MatrixIndexPointerARB(int size, uint type, int stride, IntPtr pointer) {
            GLNative.glMatrixIndexPointerARB(size, type, stride, (void*)pointer);
        }


        #endregion GL_ARB_matrix_palette

        #region GL_ARB_multi_bind

        // void glBindBuffersBase(GLenum target, GLuint first, GLsizei count, const GLuint * buffers);
        // void glBindBuffersRange(GLenum target, GLuint first, GLsizei count, const GLuint * buffers, const GLintptr * offsets, const GLintptr * sizes);
        // void glBindTextures(GLuint first, GLsizei count, const GLuint * textures);
        // void glBindSamplers(GLuint first, GLsizei count, const GLuint * samplers);
        // void glBindImageTextures(GLuint first, GLsizei count, const GLuint * textures);
        // void glBindVertexBuffers(GLuint first, GLsizei count, const GLuint * buffers, const GLintptr * offsets, const GLsizei * strides);

        #endregion GL_ARB_multi_bind

        #region GL_ARB_multi_draw_indirect

        // void glMultiDrawArraysIndirect(GLenum mode, const void * indirect, GLsizei drawcount, GLsizei stride);
        // void glMultiDrawElementsIndirect(GLenum mode, GLenum type, const void * indirect, GLsizei drawcount, GLsizei stride);

        #endregion GL_ARB_multi_draw_indirect

        #region GL_ARB_multisample


        #endregion GL_ARB_multisample

        #region GL_ARB_multitexture

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_multitexture</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glMultiTexCoord1dvARB(GLenum target, const GLdouble * v);</para>
        /// </summary>
        public unsafe static void MultiTexCoord1dvARB(uint target, ref double v) {
            fixed (double* pV = &v) {
                GLNative.glMultiTexCoord1dvARB(target, pV);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_multitexture</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glMultiTexCoord1fvARB(GLenum target, const GLfloat * v);</para>
        /// </summary>
        public unsafe static void MultiTexCoord1fvARB(uint target, ref float v) {
            fixed (float* pV = &v) {
                GLNative.glMultiTexCoord1fvARB(target, pV);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_multitexture</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glMultiTexCoord1ivARB(GLenum target, const GLint * v);</para>
        /// </summary>
        public unsafe static void MultiTexCoord1ivARB(uint target, ref int v) {
            fixed (int* pV = &v) {
                GLNative.glMultiTexCoord1ivARB(target, pV);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_multitexture</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glMultiTexCoord1svARB(GLenum target, const GLshort * v);</para>
        /// </summary>
        public unsafe static void MultiTexCoord1svARB(uint target, ref short v) {
            fixed (short* pV = &v) {
                GLNative.glMultiTexCoord1svARB(target, pV);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_multitexture</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glMultiTexCoord2dvARB(GLenum target, const GLdouble * v);</para>
        /// </summary>
        public unsafe static void MultiTexCoord2dvARB(uint target, ref double v) {
            fixed (double* pV = &v) {
                GLNative.glMultiTexCoord2dvARB(target, pV);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_multitexture</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glMultiTexCoord2fvARB(GLenum target, const GLfloat * v);</para>
        /// </summary>
        public unsafe static void MultiTexCoord2fvARB(uint target, ref float v) {
            fixed (float* pV = &v) {
                GLNative.glMultiTexCoord2fvARB(target, pV);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_multitexture</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glMultiTexCoord2ivARB(GLenum target, const GLint * v);</para>
        /// </summary>
        public unsafe static void MultiTexCoord2ivARB(uint target, ref int v) {
            fixed (int* pV = &v) {
                GLNative.glMultiTexCoord2ivARB(target, pV);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_multitexture</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glMultiTexCoord2svARB(GLenum target, const GLshort * v);</para>
        /// </summary>
        public unsafe static void MultiTexCoord2svARB(uint target, ref short v) {
            fixed (short* pV = &v) {
                GLNative.glMultiTexCoord2svARB(target, pV);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_multitexture</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glMultiTexCoord3dvARB(GLenum target, const GLdouble * v);</para>
        /// </summary>
        public unsafe static void MultiTexCoord3dvARB(uint target, ref double v) {
            fixed (double* pV = &v) {
                GLNative.glMultiTexCoord3dvARB(target, pV);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_multitexture</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glMultiTexCoord3fvARB(GLenum target, const GLfloat * v);</para>
        /// </summary>
        public unsafe static void MultiTexCoord3fvARB(uint target, ref float v) {
            fixed (float* pV = &v) {
                GLNative.glMultiTexCoord3fvARB(target, pV);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_multitexture</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glMultiTexCoord3ivARB(GLenum target, const GLint * v);</para>
        /// </summary>
        public unsafe static void MultiTexCoord3ivARB(uint target, ref int v) {
            fixed (int* pV = &v) {
                GLNative.glMultiTexCoord3ivARB(target, pV);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_multitexture</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glMultiTexCoord3svARB(GLenum target, const GLshort * v);</para>
        /// </summary>
        public unsafe static void MultiTexCoord3svARB(uint target, ref short v) {
            fixed (short* pV = &v) {
                GLNative.glMultiTexCoord3svARB(target, pV);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_multitexture</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glMultiTexCoord4dvARB(GLenum target, const GLdouble * v);</para>
        /// </summary>
        public unsafe static void MultiTexCoord4dvARB(uint target, ref double v) {
            fixed (double* pV = &v) {
                GLNative.glMultiTexCoord4dvARB(target, pV);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_multitexture</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glMultiTexCoord4fvARB(GLenum target, const GLfloat * v);</para>
        /// </summary>
        public unsafe static void MultiTexCoord4fvARB(uint target, ref float v) {
            fixed (float* pV = &v) {
                GLNative.glMultiTexCoord4fvARB(target, pV);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_multitexture</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glMultiTexCoord4ivARB(GLenum target, const GLint * v);</para>
        /// </summary>
        public unsafe static void MultiTexCoord4ivARB(uint target, ref int v) {
            fixed (int* pV = &v) {
                GLNative.glMultiTexCoord4ivARB(target, pV);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_multitexture</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glMultiTexCoord4svARB(GLenum target, const GLshort * v);</para>
        /// </summary>
        public unsafe static void MultiTexCoord4svARB(uint target, ref short v) {
            fixed (short* pV = &v) {
                GLNative.glMultiTexCoord4svARB(target, pV);
            }
        }


        #endregion GL_ARB_multitexture

        #region GL_ARB_occlusion_query

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_occlusion_query</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGenQueriesARB(GLsizei n, GLuint * ids);</para>
        /// </summary>
        public unsafe static void GenQueriesARB(int n, ref uint ids) {
            fixed (uint* pIds = &ids) {
                GLNative.glGenQueriesARB(n, pIds);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_occlusion_query</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glDeleteQueriesARB(GLsizei n, const GLuint * ids);</para>
        /// </summary>
        public unsafe static void DeleteQueriesARB(int n, ref uint ids) {
            fixed (uint* pIds = &ids) {
                GLNative.glDeleteQueriesARB(n, pIds);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_occlusion_query</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetQueryivARB(GLenum target, GLenum pname, GLint * params);</para>
        /// </summary>
        public unsafe static void GetQueryivARB(uint target, uint pname, ref int ps) {
            fixed (int* pPs = &ps) {
                GLNative.glGetQueryivARB(target, pname, pPs);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_occlusion_query</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetQueryObjectivARB(GLuint id, GLenum pname, GLint * params);</para>
        /// </summary>
        public unsafe static void GetQueryObjectivARB(uint id, uint pname, ref int ps) {
            fixed (int* pPs = &ps) {
                GLNative.glGetQueryObjectivARB(id, pname, pPs);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_occlusion_query</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetQueryObjectuivARB(GLuint id, GLenum pname, GLuint * params);</para>
        /// </summary>
        public unsafe static void GetQueryObjectuivARB(uint id, uint pname, ref uint ps) {
            fixed (uint* pPs = &ps) {
                GLNative.glGetQueryObjectuivARB(id, pname, pPs);
            }
        }


        #endregion GL_ARB_occlusion_query

        #region GL_ARB_parallel_shader_compile


        #endregion GL_ARB_parallel_shader_compile

        #region GL_ARB_point_parameters

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_point_parameters</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glPointParameterfvARB(GLenum pname, const GLfloat * params);</para>
        /// </summary>
        public unsafe static void PointParameterfvARB(uint pname, ref float ps) {
            fixed (float* pPs = &ps) {
                GLNative.glPointParameterfvARB(pname, pPs);
            }
        }


        #endregion GL_ARB_point_parameters

        #region GL_ARB_polygon_offset_clamp


        #endregion GL_ARB_polygon_offset_clamp

        #region GL_ARB_program_interface_query

        // void glGetProgramInterfaceiv(GLuint program, GLenum programInterface, GLenum pname, GLint * ps);
        // GLuint glGetProgramResourceIndex(GLuint program, GLenum programInterface, const char * name);
        // void glGetProgramResourceName(GLuint program, GLenum programInterface, GLuint index, GLsizei bufSize, GLsizei * length, char * name);
        // void glGetProgramResourceiv(GLuint program, GLenum programInterface, GLuint index, GLsizei propCount, const GLenum * props, GLsizei bufSize, GLsizei * length, GLint * ps);
        // GLint glGetProgramResourceLocation(GLuint program, GLenum programInterface, const char * name);
        // GLint glGetProgramResourceLocationIndex(GLuint program, GLenum programInterface, const char * name);

        #endregion GL_ARB_program_interface_query

        #region GL_ARB_provoking_vertex


        #endregion GL_ARB_provoking_vertex

        #region GL_ARB_robustness

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_robustness</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetnTexImageARB(GLenum target, GLint level, GLenum format, GLenum type, GLsizei bufSize, void * img);</para>
        /// </summary>
        public unsafe static void GetnTexImageARB(uint target, int level, uint format, uint type, int bufSize, IntPtr img) {
            GLNative.glGetnTexImageARB(target, level, format, type, bufSize, (void*)img);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_robustness</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glReadnPixelsARB(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLsizei bufSize, void * data);</para>
        /// </summary>
        public unsafe static void ReadnPixelsARB(int x, int y, int width, int height, uint format, uint type, int bufSize, IntPtr data) {
            GLNative.glReadnPixelsARB(x, y, width, height, format, type, bufSize, (void*)data);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_robustness</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetnCompressedTexImageARB(GLenum target, GLint lod, GLsizei bufSize, void * img);</para>
        /// </summary>
        public unsafe static void GetnCompressedTexImageARB(uint target, int lod, int bufSize, IntPtr img) {
            GLNative.glGetnCompressedTexImageARB(target, lod, bufSize, (void*)img);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_robustness</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetnUniformfvARB(GLuint program, GLint location, GLsizei bufSize, GLfloat * params);</para>
        /// </summary>
        public unsafe static void GetnUniformfvARB(uint program, int location, int bufSize, ref float ps) {
            fixed (float* pPs = &ps) {
                GLNative.glGetnUniformfvARB(program, location, bufSize, pPs);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_robustness</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetnUniformivARB(GLuint program, GLint location, GLsizei bufSize, GLint * params);</para>
        /// </summary>
        public unsafe static void GetnUniformivARB(uint program, int location, int bufSize, ref int ps) {
            fixed (int* pPs = &ps) {
                GLNative.glGetnUniformivARB(program, location, bufSize, pPs);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_robustness</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetnUniformuivARB(GLuint program, GLint location, GLsizei bufSize, GLuint * params);</para>
        /// </summary>
        public unsafe static void GetnUniformuivARB(uint program, int location, int bufSize, ref uint ps) {
            fixed (uint* pPs = &ps) {
                GLNative.glGetnUniformuivARB(program, location, bufSize, pPs);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_robustness</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetnUniformdvARB(GLuint program, GLint location, GLsizei bufSize, GLdouble * params);</para>
        /// </summary>
        public unsafe static void GetnUniformdvARB(uint program, int location, int bufSize, ref double ps) {
            fixed (double* pPs = &ps) {
                GLNative.glGetnUniformdvARB(program, location, bufSize, pPs);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_robustness</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetnMapdvARB(GLenum target, GLenum query, GLsizei bufSize, GLdouble * v);</para>
        /// </summary>
        public unsafe static void GetnMapdvARB(uint target, uint query, int bufSize, ref double v) {
            fixed (double* pV = &v) {
                GLNative.glGetnMapdvARB(target, query, bufSize, pV);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_robustness</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetnMapfvARB(GLenum target, GLenum query, GLsizei bufSize, GLfloat * v);</para>
        /// </summary>
        public unsafe static void GetnMapfvARB(uint target, uint query, int bufSize, ref float v) {
            fixed (float* pV = &v) {
                GLNative.glGetnMapfvARB(target, query, bufSize, pV);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_robustness</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetnMapivARB(GLenum target, GLenum query, GLsizei bufSize, GLint * v);</para>
        /// </summary>
        public unsafe static void GetnMapivARB(uint target, uint query, int bufSize, ref int v) {
            fixed (int* pV = &v) {
                GLNative.glGetnMapivARB(target, query, bufSize, pV);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_robustness</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetnPixelMapfvARB(GLenum map, GLsizei bufSize, GLfloat * values);</para>
        /// </summary>
        public unsafe static void GetnPixelMapfvARB(uint map, int bufSize, ref float values) {
            fixed (float* pValues = &values) {
                GLNative.glGetnPixelMapfvARB(map, bufSize, pValues);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_robustness</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetnPixelMapuivARB(GLenum map, GLsizei bufSize, GLuint * values);</para>
        /// </summary>
        public unsafe static void GetnPixelMapuivARB(uint map, int bufSize, ref uint values) {
            fixed (uint* pValues = &values) {
                GLNative.glGetnPixelMapuivARB(map, bufSize, pValues);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_robustness</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetnPixelMapusvARB(GLenum map, GLsizei bufSize, GLushort * values);</para>
        /// </summary>
        public unsafe static void GetnPixelMapusvARB(uint map, int bufSize, ref ushort values) {
            fixed (ushort* pValues = &values) {
                GLNative.glGetnPixelMapusvARB(map, bufSize, pValues);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_robustness</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetnPolygonStippleARB(GLsizei bufSize, GLubyte * pattern);</para>
        /// </summary>
        public unsafe static void GetnPolygonStippleARB(int bufSize, ref byte pattern) {
            fixed (byte* pPattern = &pattern) {
                GLNative.glGetnPolygonStippleARB(bufSize, pPattern);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_robustness</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetnColorTableARB(GLenum target, GLenum format, GLenum type, GLsizei bufSize, void * table);</para>
        /// </summary>
        public unsafe static void GetnColorTableARB(uint target, uint format, uint type, int bufSize, IntPtr table) {
            GLNative.glGetnColorTableARB(target, format, type, bufSize, (void*)table);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_robustness</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetnConvolutionFilterARB(GLenum target, GLenum format, GLenum type, GLsizei bufSize, void * image);</para>
        /// </summary>
        public unsafe static void GetnConvolutionFilterARB(uint target, uint format, uint type, int bufSize, IntPtr image) {
            GLNative.glGetnConvolutionFilterARB(target, format, type, bufSize, (void*)image);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_robustness</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetnSeparableFilterARB(GLenum target, GLenum format, GLenum type, GLsizei rowBufSize, void * row, GLsizei columnBufSize, void * column, void * span);</para>
        /// </summary>
        public unsafe static void GetnSeparableFilterARB(uint target, uint format, uint type, int rowBufSize, IntPtr row, int columnBufSize, IntPtr column, IntPtr span) {
            GLNative.glGetnSeparableFilterARB(target, format, type, rowBufSize, (void*)row, columnBufSize, (void*)column, (void*)span);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_robustness</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetnHistogramARB(GLenum target, GLboolean reset, GLenum format, GLenum type, GLsizei bufSize, void * values);</para>
        /// </summary>
        public unsafe static void GetnHistogramARB(uint target, bool reset, uint format, uint type, int bufSize, IntPtr values) {
            GLNative.glGetnHistogramARB(target, reset, format, type, bufSize, (void*)values);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_robustness</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetnMinmaxARB(GLenum target, GLboolean reset, GLenum format, GLenum type, GLsizei bufSize, void * values);</para>
        /// </summary>
        public unsafe static void GetnMinmaxARB(uint target, bool reset, uint format, uint type, int bufSize, IntPtr values) {
            GLNative.glGetnMinmaxARB(target, reset, format, type, bufSize, (void*)values);
        }


        #endregion GL_ARB_robustness

        #region GL_ARB_sample_locations

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_sample_locations</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glFramebufferSampleLocationsfvARB(GLenum target, GLuint start, GLsizei count, const GLfloat * v);</para>
        /// </summary>
        public unsafe static void FramebufferSampleLocationsfvARB(uint target, uint start, int count, ref float v) {
            fixed (float* pV = &v) {
                GLNative.glFramebufferSampleLocationsfvARB(target, start, count, pV);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_sample_locations</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glNamedFramebufferSampleLocationsfvARB(GLuint framebuffer, GLuint start, GLsizei count, const GLfloat * v);</para>
        /// </summary>
        public unsafe static void NamedFramebufferSampleLocationsfvARB(uint framebuffer, uint start, int count, ref float v) {
            fixed (float* pV = &v) {
                GLNative.glNamedFramebufferSampleLocationsfvARB(framebuffer, start, count, pV);
            }
        }


        #endregion GL_ARB_sample_locations

        #region GL_ARB_sample_shading


        #endregion GL_ARB_sample_shading

        #region GL_ARB_sampler_objects

        // void glGenSamplers(GLsizei n, GLuint * samplers);
        // void glDeleteSamplers(GLsizei n, const GLuint * samplers);
        // void glSamplerParameteriv(GLuint sampler, GLenum pname, const GLint * ps);
        // void glSamplerParameterfv(GLuint sampler, GLenum pname, const GLfloat * ps);
        // void glSamplerParameterIiv(GLuint sampler, GLenum pname, const GLint * ps);
        // void glSamplerParameterIuiv(GLuint sampler, GLenum pname, const GLuint * ps);
        // void glGetSamplerParameteriv(GLuint sampler, GLenum pname, GLint * ps);
        // void glGetSamplerParameterIiv(GLuint sampler, GLenum pname, GLint * ps);
        // void glGetSamplerParameterfv(GLuint sampler, GLenum pname, GLfloat * ps);
        // void glGetSamplerParameterIuiv(GLuint sampler, GLenum pname, GLuint * ps);

        #endregion GL_ARB_sampler_objects

        #region GL_ARB_separate_shader_objects

        // GLuint glCreateShaderProgramv(GLenum type, GLsizei count, const char ** strings);
        // void glDeleteProgramPipelines(GLsizei n, const GLuint * pipelines);
        // void glGenProgramPipelines(GLsizei n, GLuint * pipelines);
        // void glGetProgramPipelineiv(GLuint pipeline, GLenum pname, GLint * ps);
        // void glProgramUniform1iv(GLuint program, GLint location, GLsizei count, const GLint * value);
        // void glProgramUniform1fv(GLuint program, GLint location, GLsizei count, const GLfloat * value);
        // void glProgramUniform1dv(GLuint program, GLint location, GLsizei count, const GLdouble * value);
        // void glProgramUniform1uiv(GLuint program, GLint location, GLsizei count, const GLuint * value);
        // void glProgramUniform2iv(GLuint program, GLint location, GLsizei count, const GLint * value);
        // void glProgramUniform2fv(GLuint program, GLint location, GLsizei count, const GLfloat * value);
        // void glProgramUniform2dv(GLuint program, GLint location, GLsizei count, const GLdouble * value);
        // void glProgramUniform2uiv(GLuint program, GLint location, GLsizei count, const GLuint * value);
        // void glProgramUniform3iv(GLuint program, GLint location, GLsizei count, const GLint * value);
        // void glProgramUniform3fv(GLuint program, GLint location, GLsizei count, const GLfloat * value);
        // void glProgramUniform3dv(GLuint program, GLint location, GLsizei count, const GLdouble * value);
        // void glProgramUniform3uiv(GLuint program, GLint location, GLsizei count, const GLuint * value);
        // void glProgramUniform4iv(GLuint program, GLint location, GLsizei count, const GLint * value);
        // void glProgramUniform4fv(GLuint program, GLint location, GLsizei count, const GLfloat * value);
        // void glProgramUniform4dv(GLuint program, GLint location, GLsizei count, const GLdouble * value);
        // void glProgramUniform4uiv(GLuint program, GLint location, GLsizei count, const GLuint * value);
        // void glProgramUniformMatrix2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);
        // void glProgramUniformMatrix3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);
        // void glProgramUniformMatrix4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);
        // void glProgramUniformMatrix2dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);
        // void glProgramUniformMatrix3dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);
        // void glProgramUniformMatrix4dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);
        // void glProgramUniformMatrix2x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);
        // void glProgramUniformMatrix3x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);
        // void glProgramUniformMatrix2x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);
        // void glProgramUniformMatrix4x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);
        // void glProgramUniformMatrix3x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);
        // void glProgramUniformMatrix4x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);
        // void glProgramUniformMatrix2x3dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);
        // void glProgramUniformMatrix3x2dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);
        // void glProgramUniformMatrix2x4dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);
        // void glProgramUniformMatrix4x2dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);
        // void glProgramUniformMatrix3x4dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);
        // void glProgramUniformMatrix4x3dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);
        // void glGetProgramPipelineInfoLog(GLuint pipeline, GLsizei bufSize, GLsizei * length, GLchar * infoLog);

        #endregion GL_ARB_separate_shader_objects

        #region GL_ARB_shader_atomic_counters

        // void glGetActiveAtomicCounterBufferiv(GLuint program, GLuint bufferIndex, GLenum pname, GLint * ps);

        #endregion GL_ARB_shader_atomic_counters

        #region GL_ARB_shader_image_load_store


        #endregion GL_ARB_shader_image_load_store

        #region GL_ARB_shader_objects

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_shader_objects</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glShaderSourceARB(GLhandleARB shaderObj, GLsizei count, const GLcharARB ** string, const GLint * length);</para>
        /// </summary>
        public unsafe static void ShaderSourceARB(uint shaderObj, int count, IntPtr str, ref int length) {
            fixed (int* pLength = &length) {
                GLNative.glShaderSourceARB(shaderObj, count, (uint**)str, pLength);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_shader_objects</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glUniform1fvARB(GLint location, GLsizei count, const GLfloat * value);</para>
        /// </summary>
        public unsafe static void Uniform1fvARB(int location, int count, ref float value) {
            fixed (float* pValue = &value) {
                GLNative.glUniform1fvARB(location, count, pValue);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_shader_objects</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glUniform2fvARB(GLint location, GLsizei count, const GLfloat * value);</para>
        /// </summary>
        public unsafe static void Uniform2fvARB(int location, int count, ref float value) {
            fixed (float* pValue = &value) {
                GLNative.glUniform2fvARB(location, count, pValue);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_shader_objects</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glUniform3fvARB(GLint location, GLsizei count, const GLfloat * value);</para>
        /// </summary>
        public unsafe static void Uniform3fvARB(int location, int count, ref float value) {
            fixed (float* pValue = &value) {
                GLNative.glUniform3fvARB(location, count, pValue);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_shader_objects</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glUniform4fvARB(GLint location, GLsizei count, const GLfloat * value);</para>
        /// </summary>
        public unsafe static void Uniform4fvARB(int location, int count, ref float value) {
            fixed (float* pValue = &value) {
                GLNative.glUniform4fvARB(location, count, pValue);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_shader_objects</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glUniform1ivARB(GLint location, GLsizei count, const GLint * value);</para>
        /// </summary>
        public unsafe static void Uniform1ivARB(int location, int count, ref int value) {
            fixed (int* pValue = &value) {
                GLNative.glUniform1ivARB(location, count, pValue);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_shader_objects</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glUniform2ivARB(GLint location, GLsizei count, const GLint * value);</para>
        /// </summary>
        public unsafe static void Uniform2ivARB(int location, int count, ref int value) {
            fixed (int* pValue = &value) {
                GLNative.glUniform2ivARB(location, count, pValue);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_shader_objects</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glUniform3ivARB(GLint location, GLsizei count, const GLint * value);</para>
        /// </summary>
        public unsafe static void Uniform3ivARB(int location, int count, ref int value) {
            fixed (int* pValue = &value) {
                GLNative.glUniform3ivARB(location, count, pValue);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_shader_objects</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glUniform4ivARB(GLint location, GLsizei count, const GLint * value);</para>
        /// </summary>
        public unsafe static void Uniform4ivARB(int location, int count, ref int value) {
            fixed (int* pValue = &value) {
                GLNative.glUniform4ivARB(location, count, pValue);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_shader_objects</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glUniformMatrix2fvARB(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);</para>
        /// </summary>
        public unsafe static void UniformMatrix2fvARB(int location, int count, bool transpose, ref float value) {
            fixed (float* pValue = &value) {
                GLNative.glUniformMatrix2fvARB(location, count, transpose, pValue);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_shader_objects</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glUniformMatrix3fvARB(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);</para>
        /// </summary>
        public unsafe static void UniformMatrix3fvARB(int location, int count, bool transpose, ref float value) {
            fixed (float* pValue = &value) {
                GLNative.glUniformMatrix3fvARB(location, count, transpose, pValue);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_shader_objects</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glUniformMatrix4fvARB(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);</para>
        /// </summary>
        public unsafe static void UniformMatrix4fvARB(int location, int count, bool transpose, ref float value) {
            fixed (float* pValue = &value) {
                GLNative.glUniformMatrix4fvARB(location, count, transpose, pValue);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_shader_objects</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetObjectParameterfvARB(GLhandleARB obj, GLenum pname, GLfloat * params);</para>
        /// </summary>
        public unsafe static void GetObjectParameterfvARB(uint obj, uint pname, ref float ps) {
            fixed (float* pPs = &ps) {
                GLNative.glGetObjectParameterfvARB(obj, pname, pPs);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_shader_objects</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetObjectParameterivARB(GLhandleARB obj, GLenum pname, GLint * params);</para>
        /// </summary>
        public unsafe static void GetObjectParameterivARB(uint obj, uint pname, ref int ps) {
            fixed (int* pPs = &ps) {
                GLNative.glGetObjectParameterivARB(obj, pname, pPs);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_shader_objects</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetInfoLogARB(GLhandleARB obj, GLsizei maxLength, GLsizei * length, GLcharARB * infoLog);</para>
        /// </summary>
        public unsafe static void GetInfoLogARB(uint obj, int maxLength, ref int length, ref uint infoLog) {
            fixed (int* pLength = &length)
            fixed (uint* pInfoLog = &infoLog) {
                GLNative.glGetInfoLogARB(obj, maxLength, pLength, pInfoLog);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_shader_objects</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetAttachedObjectsARB(GLhandleARB containerObj, GLsizei maxCount, GLsizei * count, GLhandleARB * obj);</para>
        /// </summary>
        public unsafe static void GetAttachedObjectsARB(uint containerObj, int maxCount, ref int count, ref uint obj) {
            fixed (int* pCount = &count)
            fixed (uint* pObj = &obj) {
                GLNative.glGetAttachedObjectsARB(containerObj, maxCount, pCount, pObj);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_shader_objects</para>
        /// Supported: <para>gl</para>
        /// Original: <para>GLint glGetUniformLocationARB(GLhandleARB programObj, const GLcharARB * name);</para>
        /// </summary>
        public unsafe static int GetUniformLocationARB(uint programObj, ref uint name) {
            fixed (uint* pName = &name) {
                return GLNative.glGetUniformLocationARB(programObj, pName);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_shader_objects</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetActiveUniformARB(GLhandleARB programObj, GLuint index, GLsizei maxLength, GLsizei * length, GLint * size, GLenum * type, GLcharARB * name);</para>
        /// </summary>
        public unsafe static void GetActiveUniformARB(uint programObj, uint index, int maxLength, ref int length, ref int size, ref uint type, ref uint name) {
            fixed (int* pLength = &length)
            fixed (int* pSize = &size)
            fixed (uint* pType = &type)
            fixed (uint* pName = &name) {
                GLNative.glGetActiveUniformARB(programObj, index, maxLength, pLength, pSize, pType, pName);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_shader_objects</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetUniformfvARB(GLhandleARB programObj, GLint location, GLfloat * params);</para>
        /// </summary>
        public unsafe static void GetUniformfvARB(uint programObj, int location, ref float ps) {
            fixed (float* pPs = &ps) {
                GLNative.glGetUniformfvARB(programObj, location, pPs);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_shader_objects</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetUniformivARB(GLhandleARB programObj, GLint location, GLint * params);</para>
        /// </summary>
        public unsafe static void GetUniformivARB(uint programObj, int location, ref int ps) {
            fixed (int* pPs = &ps) {
                GLNative.glGetUniformivARB(programObj, location, pPs);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_shader_objects</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetShaderSourceARB(GLhandleARB obj, GLsizei maxLength, GLsizei * length, GLcharARB * source);</para>
        /// </summary>
        public unsafe static void GetShaderSourceARB(uint obj, int maxLength, ref int length, ref uint source) {
            fixed (int* pLength = &length)
            fixed (uint* pSource = &source) {
                GLNative.glGetShaderSourceARB(obj, maxLength, pLength, pSource);
            }
        }


        #endregion GL_ARB_shader_objects

        #region GL_ARB_shader_storage_buffer_object


        #endregion GL_ARB_shader_storage_buffer_object

        #region GL_ARB_shader_subroutine

        // GLint glGetSubroutineUniformLocation(GLuint program, GLenum shadertype, const GLchar * name);
        // GLuint glGetSubroutineIndex(GLuint program, GLenum shadertype, const GLchar * name);
        // void glGetActiveSubroutineUniformiv(GLuint program, GLenum shadertype, GLuint index, GLenum pname, GLint * values);
        // void glGetActiveSubroutineUniformName(GLuint program, GLenum shadertype, GLuint index, GLsizei bufSize, GLsizei * length, GLchar * name);
        // void glGetActiveSubroutineName(GLuint program, GLenum shadertype, GLuint index, GLsizei bufSize, GLsizei * length, GLchar * name);
        // void glUniformSubroutinesuiv(GLenum shadertype, GLsizei count, const GLuint * indices);
        // void glGetUniformSubroutineuiv(GLenum shadertype, GLint location, GLuint * values);
        // void glGetProgramStageiv(GLuint program, GLenum shadertype, GLenum pname, GLint * values);

        #endregion GL_ARB_shader_subroutine

        #region GL_ARB_shading_language_include

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_shading_language_include</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glNamedStringARB(GLenum type, GLint namelen, const GLchar * name, GLint stringlen, const GLchar * string);</para>
        /// </summary>
        public unsafe static void NamedStringARB(uint type, int namelen, ref byte name, int stringlen, ref byte str) {
            fixed (byte* pName = &name)
            fixed (byte* pStr = &str) {
                GLNative.glNamedStringARB(type, namelen, pName, stringlen, pStr);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_shading_language_include</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glDeleteNamedStringARB(GLint namelen, const GLchar * name);</para>
        /// </summary>
        public unsafe static void DeleteNamedStringARB(int namelen, ref byte name) {
            fixed (byte* pName = &name) {
                GLNative.glDeleteNamedStringARB(namelen, pName);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_shading_language_include</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glCompileShaderIncludeARB(GLuint shader, GLsizei count, const GLchar *const* path, const GLint * length);</para>
        /// </summary>
        public unsafe static void CompileShaderIncludeARB(uint shader, int count, IntPtr path, ref int length) {
            fixed (int* pLength = &length) {
                GLNative.glCompileShaderIncludeARB(shader, count, (byte**)path, pLength);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_shading_language_include</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>GLboolean glIsNamedStringARB(GLint namelen, const GLchar * name);</para>
        /// </summary>
        public unsafe static bool IsNamedStringARB(int namelen, ref byte name) {
            fixed (byte* pName = &name) {
                return GLNative.glIsNamedStringARB(namelen, pName);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_shading_language_include</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetNamedStringARB(GLint namelen, const GLchar * name, GLsizei bufSize, GLint * stringlen, GLchar * string);</para>
        /// </summary>
        public unsafe static void GetNamedStringARB(int namelen, ref byte name, int bufSize, ref int stringlen, ref byte str) {
            fixed (byte* pName = &name)
            fixed (int* pStringlen = &stringlen)
            fixed (byte* pStr = &str) {
                GLNative.glGetNamedStringARB(namelen, pName, bufSize, pStringlen, pStr);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_shading_language_include</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetNamedStringivARB(GLint namelen, const GLchar * name, GLenum pname, GLint * params);</para>
        /// </summary>
        public unsafe static void GetNamedStringivARB(int namelen, ref byte name, uint pname, ref int ps) {
            fixed (byte* pName = &name)
            fixed (int* pPs = &ps) {
                GLNative.glGetNamedStringivARB(namelen, pName, pname, pPs);
            }
        }


        #endregion GL_ARB_shading_language_include

        #region GL_ARB_sparse_buffer


        #endregion GL_ARB_sparse_buffer

        #region GL_ARB_sparse_texture


        #endregion GL_ARB_sparse_texture

        #region GL_ARB_sync

        // void glGetInteger64v(GLenum pname, GLint64 * data);
        // void glGetSynciv(GLsync sync, GLenum pname, GLsizei bufSize, GLsizei * length, GLint * values);

        #endregion GL_ARB_sync

        #region GL_ARB_tessellation_shader

        // void glPatchParameterfv(GLenum pname, const GLfloat * values);

        #endregion GL_ARB_tessellation_shader

        #region GL_ARB_texture_barrier


        #endregion GL_ARB_texture_barrier

        #region GL_ARB_texture_buffer_object


        #endregion GL_ARB_texture_buffer_object

        #region GL_ARB_texture_buffer_range


        #endregion GL_ARB_texture_buffer_range

        #region GL_ARB_texture_compression

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_texture_compression</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glCompressedTexImage3DARB(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const void * data);</para>
        /// </summary>
        public unsafe static void CompressedTexImage3DARB(uint target, int level, uint internalformat, int width, int height, int depth, int border, int imageSize, IntPtr data) {
            GLNative.glCompressedTexImage3DARB(target, level, internalformat, width, height, depth, border, imageSize, (void*)data);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_texture_compression</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glCompressedTexImage2DARB(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const void * data);</para>
        /// </summary>
        public unsafe static void CompressedTexImage2DARB(uint target, int level, uint internalformat, int width, int height, int border, int imageSize, IntPtr data) {
            GLNative.glCompressedTexImage2DARB(target, level, internalformat, width, height, border, imageSize, (void*)data);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_texture_compression</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glCompressedTexImage1DARB(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const void * data);</para>
        /// </summary>
        public unsafe static void CompressedTexImage1DARB(uint target, int level, uint internalformat, int width, int border, int imageSize, IntPtr data) {
            GLNative.glCompressedTexImage1DARB(target, level, internalformat, width, border, imageSize, (void*)data);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_texture_compression</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glCompressedTexSubImage3DARB(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void * data);</para>
        /// </summary>
        public unsafe static void CompressedTexSubImage3DARB(uint target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, uint format, int imageSize, IntPtr data) {
            GLNative.glCompressedTexSubImage3DARB(target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, (void*)data);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_texture_compression</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glCompressedTexSubImage2DARB(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void * data);</para>
        /// </summary>
        public unsafe static void CompressedTexSubImage2DARB(uint target, int level, int xoffset, int yoffset, int width, int height, uint format, int imageSize, IntPtr data) {
            GLNative.glCompressedTexSubImage2DARB(target, level, xoffset, yoffset, width, height, format, imageSize, (void*)data);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_texture_compression</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glCompressedTexSubImage1DARB(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const void * data);</para>
        /// </summary>
        public unsafe static void CompressedTexSubImage1DARB(uint target, int level, int xoffset, int width, uint format, int imageSize, IntPtr data) {
            GLNative.glCompressedTexSubImage1DARB(target, level, xoffset, width, format, imageSize, (void*)data);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_texture_compression</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetCompressedTexImageARB(GLenum target, GLint level, void * img);</para>
        /// </summary>
        public unsafe static void GetCompressedTexImageARB(uint target, int level, IntPtr img) {
            GLNative.glGetCompressedTexImageARB(target, level, (void*)img);
        }


        #endregion GL_ARB_texture_compression

        #region GL_ARB_texture_multisample

        // void glGetMultisamplefv(GLenum pname, GLuint index, GLfloat * val);

        #endregion GL_ARB_texture_multisample

        #region GL_ARB_texture_storage


        #endregion GL_ARB_texture_storage

        #region GL_ARB_texture_storage_multisample


        #endregion GL_ARB_texture_storage_multisample

        #region GL_ARB_texture_view


        #endregion GL_ARB_texture_view

        #region GL_ARB_timer_query

        // void glGetQueryObjecti64v(GLuint id, GLenum pname, GLint64 * ps);
        // void glGetQueryObjectui64v(GLuint id, GLenum pname, GLuint64 * ps);

        #endregion GL_ARB_timer_query

        #region GL_ARB_transform_feedback2

        // void glDeleteTransformFeedbacks(GLsizei n, const GLuint * ids);
        // void glGenTransformFeedbacks(GLsizei n, GLuint * ids);

        #endregion GL_ARB_transform_feedback2

        #region GL_ARB_transform_feedback3

        // void glGetQueryIndexediv(GLenum target, GLuint index, GLenum pname, GLint * ps);

        #endregion GL_ARB_transform_feedback3

        #region GL_ARB_transform_feedback_instanced


        #endregion GL_ARB_transform_feedback_instanced

        #region GL_ARB_transpose_matrix

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_transpose_matrix</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glLoadTransposeMatrixfARB(const GLfloat * m);</para>
        /// </summary>
        public unsafe static void LoadTransposeMatrixfARB(ref float m) {
            fixed (float* pM = &m) {
                GLNative.glLoadTransposeMatrixfARB(pM);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_transpose_matrix</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glLoadTransposeMatrixdARB(const GLdouble * m);</para>
        /// </summary>
        public unsafe static void LoadTransposeMatrixdARB(ref double m) {
            fixed (double* pM = &m) {
                GLNative.glLoadTransposeMatrixdARB(pM);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_transpose_matrix</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glMultTransposeMatrixfARB(const GLfloat * m);</para>
        /// </summary>
        public unsafe static void MultTransposeMatrixfARB(ref float m) {
            fixed (float* pM = &m) {
                GLNative.glMultTransposeMatrixfARB(pM);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_transpose_matrix</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glMultTransposeMatrixdARB(const GLdouble * m);</para>
        /// </summary>
        public unsafe static void MultTransposeMatrixdARB(ref double m) {
            fixed (double* pM = &m) {
                GLNative.glMultTransposeMatrixdARB(pM);
            }
        }


        #endregion GL_ARB_transpose_matrix

        #region GL_ARB_uniform_buffer_object

        // void glGetUniformIndices(GLuint program, GLsizei uniformCount, const GLchar ** uniformNames, GLuint * uniformIndices);
        // void glGetActiveUniformsiv(GLuint program, GLsizei uniformCount, const GLuint * uniformIndices, GLenum pname, GLint * ps);
        // void glGetActiveUniformName(GLuint program, GLuint uniformIndex, GLsizei bufSize, GLsizei * length, GLchar * uniformName);
        // GLuint glGetUniformBlockIndex(GLuint program, const GLchar * uniformBlockName);
        // void glGetActiveUniformBlockiv(GLuint program, GLuint uniformBlockIndex, GLenum pname, GLint * ps);
        // void glGetActiveUniformBlockName(GLuint program, GLuint uniformBlockIndex, GLsizei bufSize, GLsizei * length, GLchar * uniformBlockName);
        // void glGetIntegeri_v(GLenum target, GLuint index, GLint * data);

        #endregion GL_ARB_uniform_buffer_object

        #region GL_ARB_vertex_array_object

        // void glDeleteVertexArrays(GLsizei n, const GLuint * arrays);
        // void glGenVertexArrays(GLsizei n, GLuint * arrays);

        #endregion GL_ARB_vertex_array_object

        #region GL_ARB_vertex_attrib_64bit

        // void glVertexAttribL1dv(GLuint index, const GLdouble * v);
        // void glVertexAttribL2dv(GLuint index, const GLdouble * v);
        // void glVertexAttribL3dv(GLuint index, const GLdouble * v);
        // void glVertexAttribL4dv(GLuint index, const GLdouble * v);
        // void glVertexAttribLPointer(GLuint index, GLint size, GLenum type, GLsizei stride, const void * pointer);
        // void glGetVertexAttribLdv(GLuint index, GLenum pname, GLdouble * ps);

        #endregion GL_ARB_vertex_attrib_64bit

        #region GL_ARB_vertex_attrib_binding


        #endregion GL_ARB_vertex_attrib_binding

        #region GL_ARB_vertex_blend

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_vertex_blend</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glWeightbvARB(GLint size, const GLbyte * weights);</para>
        /// </summary>
        public unsafe static void WeightbvARB(int size, ref byte weights) {
            fixed (byte* pWeights = &weights) {
                GLNative.glWeightbvARB(size, pWeights);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_vertex_blend</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glWeightsvARB(GLint size, const GLshort * weights);</para>
        /// </summary>
        public unsafe static void WeightsvARB(int size, ref short weights) {
            fixed (short* pWeights = &weights) {
                GLNative.glWeightsvARB(size, pWeights);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_vertex_blend</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glWeightivARB(GLint size, const GLint * weights);</para>
        /// </summary>
        public unsafe static void WeightivARB(int size, ref int weights) {
            fixed (int* pWeights = &weights) {
                GLNative.glWeightivARB(size, pWeights);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_vertex_blend</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glWeightfvARB(GLint size, const GLfloat * weights);</para>
        /// </summary>
        public unsafe static void WeightfvARB(int size, ref float weights) {
            fixed (float* pWeights = &weights) {
                GLNative.glWeightfvARB(size, pWeights);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_vertex_blend</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glWeightdvARB(GLint size, const GLdouble * weights);</para>
        /// </summary>
        public unsafe static void WeightdvARB(int size, ref double weights) {
            fixed (double* pWeights = &weights) {
                GLNative.glWeightdvARB(size, pWeights);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_vertex_blend</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glWeightubvARB(GLint size, const GLubyte * weights);</para>
        /// </summary>
        public unsafe static void WeightubvARB(int size, ref byte weights) {
            fixed (byte* pWeights = &weights) {
                GLNative.glWeightubvARB(size, pWeights);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_vertex_blend</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glWeightusvARB(GLint size, const GLushort * weights);</para>
        /// </summary>
        public unsafe static void WeightusvARB(int size, ref ushort weights) {
            fixed (ushort* pWeights = &weights) {
                GLNative.glWeightusvARB(size, pWeights);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_vertex_blend</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glWeightuivARB(GLint size, const GLuint * weights);</para>
        /// </summary>
        public unsafe static void WeightuivARB(int size, ref uint weights) {
            fixed (uint* pWeights = &weights) {
                GLNative.glWeightuivARB(size, pWeights);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_vertex_blend</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glWeightPointerARB(GLint size, GLenum type, GLsizei stride, const void * pointer);</para>
        /// </summary>
        public unsafe static void WeightPointerARB(int size, uint type, int stride, IntPtr pointer) {
            GLNative.glWeightPointerARB(size, type, stride, (void*)pointer);
        }


        #endregion GL_ARB_vertex_blend

        #region GL_ARB_vertex_buffer_object

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_vertex_buffer_object</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glDeleteBuffersARB(GLsizei n, const GLuint * buffers);</para>
        /// </summary>
        public unsafe static void DeleteBuffersARB(int n, ref uint buffers) {
            fixed (uint* pBuffers = &buffers) {
                GLNative.glDeleteBuffersARB(n, pBuffers);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_vertex_buffer_object</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGenBuffersARB(GLsizei n, GLuint * buffers);</para>
        /// </summary>
        public unsafe static void GenBuffersARB(int n, ref uint buffers) {
            fixed (uint* pBuffers = &buffers) {
                GLNative.glGenBuffersARB(n, pBuffers);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_vertex_buffer_object</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glBufferDataARB(GLenum target, GLsizeiptrARB size, const void * data, GLenum usage);</para>
        /// </summary>
        public unsafe static void BufferDataARB(uint target, IntPtr size, IntPtr data, uint usage) {
            GLNative.glBufferDataARB(target, size, (void*)data, usage);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_vertex_buffer_object</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glBufferSubDataARB(GLenum target, GLintptrARB offset, GLsizeiptrARB size, const void * data);</para>
        /// </summary>
        public unsafe static void BufferSubDataARB(uint target, IntPtr offset, IntPtr size, IntPtr data) {
            GLNative.glBufferSubDataARB(target, offset, size, (void*)data);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_vertex_buffer_object</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetBufferSubDataARB(GLenum target, GLintptrARB offset, GLsizeiptrARB size, void * data);</para>
        /// </summary>
        public unsafe static void GetBufferSubDataARB(uint target, IntPtr offset, IntPtr size, IntPtr data) {
            GLNative.glGetBufferSubDataARB(target, offset, size, (void*)data);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_vertex_buffer_object</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void * glMapBufferARB(GLenum target, GLenum access);</para>
        /// </summary>
        public unsafe static IntPtr MapBufferARB(uint target, uint access) {
            return (IntPtr)GLNative.glMapBufferARB(target, access);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_vertex_buffer_object</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetBufferParameterivARB(GLenum target, GLenum pname, GLint * params);</para>
        /// </summary>
        public unsafe static void GetBufferParameterivARB(uint target, uint pname, ref int ps) {
            fixed (int* pPs = &ps) {
                GLNative.glGetBufferParameterivARB(target, pname, pPs);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_vertex_buffer_object</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetBufferPointervARB(GLenum target, GLenum pname, void ** params);</para>
        /// </summary>
        public unsafe static void GetBufferPointervARB(uint target, uint pname, IntPtr ps) {
            GLNative.glGetBufferPointervARB(target, pname, (void**)ps);
        }


        #endregion GL_ARB_vertex_buffer_object

        #region GL_ARB_vertex_program

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_vertex_program, GL_ARB_vertex_shader</para>
        /// Supported: <para>gl, gl</para>
        /// Original: <para>void glVertexAttrib1dvARB(GLuint index, const GLdouble * v);</para>
        /// </summary>
        public unsafe static void VertexAttrib1dvARB(uint index, ref double v) {
            fixed (double* pV = &v) {
                GLNative.glVertexAttrib1dvARB(index, pV);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_vertex_program, GL_ARB_vertex_shader</para>
        /// Supported: <para>gl, gl</para>
        /// Original: <para>void glVertexAttrib1fvARB(GLuint index, const GLfloat * v);</para>
        /// </summary>
        public unsafe static void VertexAttrib1fvARB(uint index, ref float v) {
            fixed (float* pV = &v) {
                GLNative.glVertexAttrib1fvARB(index, pV);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_vertex_program, GL_ARB_vertex_shader</para>
        /// Supported: <para>gl, gl</para>
        /// Original: <para>void glVertexAttrib1svARB(GLuint index, const GLshort * v);</para>
        /// </summary>
        public unsafe static void VertexAttrib1svARB(uint index, ref short v) {
            fixed (short* pV = &v) {
                GLNative.glVertexAttrib1svARB(index, pV);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_vertex_program, GL_ARB_vertex_shader</para>
        /// Supported: <para>gl, gl</para>
        /// Original: <para>void glVertexAttrib2dvARB(GLuint index, const GLdouble * v);</para>
        /// </summary>
        public unsafe static void VertexAttrib2dvARB(uint index, ref double v) {
            fixed (double* pV = &v) {
                GLNative.glVertexAttrib2dvARB(index, pV);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_vertex_program, GL_ARB_vertex_shader</para>
        /// Supported: <para>gl, gl</para>
        /// Original: <para>void glVertexAttrib2fvARB(GLuint index, const GLfloat * v);</para>
        /// </summary>
        public unsafe static void VertexAttrib2fvARB(uint index, ref float v) {
            fixed (float* pV = &v) {
                GLNative.glVertexAttrib2fvARB(index, pV);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_vertex_program, GL_ARB_vertex_shader</para>
        /// Supported: <para>gl, gl</para>
        /// Original: <para>void glVertexAttrib2svARB(GLuint index, const GLshort * v);</para>
        /// </summary>
        public unsafe static void VertexAttrib2svARB(uint index, ref short v) {
            fixed (short* pV = &v) {
                GLNative.glVertexAttrib2svARB(index, pV);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_vertex_program, GL_ARB_vertex_shader</para>
        /// Supported: <para>gl, gl</para>
        /// Original: <para>void glVertexAttrib3dvARB(GLuint index, const GLdouble * v);</para>
        /// </summary>
        public unsafe static void VertexAttrib3dvARB(uint index, ref double v) {
            fixed (double* pV = &v) {
                GLNative.glVertexAttrib3dvARB(index, pV);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_vertex_program, GL_ARB_vertex_shader</para>
        /// Supported: <para>gl, gl</para>
        /// Original: <para>void glVertexAttrib3fvARB(GLuint index, const GLfloat * v);</para>
        /// </summary>
        public unsafe static void VertexAttrib3fvARB(uint index, ref float v) {
            fixed (float* pV = &v) {
                GLNative.glVertexAttrib3fvARB(index, pV);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_vertex_program, GL_ARB_vertex_shader</para>
        /// Supported: <para>gl, gl</para>
        /// Original: <para>void glVertexAttrib3svARB(GLuint index, const GLshort * v);</para>
        /// </summary>
        public unsafe static void VertexAttrib3svARB(uint index, ref short v) {
            fixed (short* pV = &v) {
                GLNative.glVertexAttrib3svARB(index, pV);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_vertex_program, GL_ARB_vertex_shader</para>
        /// Supported: <para>gl, gl</para>
        /// Original: <para>void glVertexAttrib4NbvARB(GLuint index, const GLbyte * v);</para>
        /// </summary>
        public unsafe static void VertexAttrib4NbvARB(uint index, ref byte v) {
            fixed (byte* pV = &v) {
                GLNative.glVertexAttrib4NbvARB(index, pV);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_vertex_program, GL_ARB_vertex_shader</para>
        /// Supported: <para>gl, gl</para>
        /// Original: <para>void glVertexAttrib4NivARB(GLuint index, const GLint * v);</para>
        /// </summary>
        public unsafe static void VertexAttrib4NivARB(uint index, ref int v) {
            fixed (int* pV = &v) {
                GLNative.glVertexAttrib4NivARB(index, pV);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_vertex_program, GL_ARB_vertex_shader</para>
        /// Supported: <para>gl, gl</para>
        /// Original: <para>void glVertexAttrib4NsvARB(GLuint index, const GLshort * v);</para>
        /// </summary>
        public unsafe static void VertexAttrib4NsvARB(uint index, ref short v) {
            fixed (short* pV = &v) {
                GLNative.glVertexAttrib4NsvARB(index, pV);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_vertex_program, GL_ARB_vertex_shader</para>
        /// Supported: <para>gl, gl</para>
        /// Original: <para>void glVertexAttrib4NubvARB(GLuint index, const GLubyte * v);</para>
        /// </summary>
        public unsafe static void VertexAttrib4NubvARB(uint index, ref byte v) {
            fixed (byte* pV = &v) {
                GLNative.glVertexAttrib4NubvARB(index, pV);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_vertex_program, GL_ARB_vertex_shader</para>
        /// Supported: <para>gl, gl</para>
        /// Original: <para>void glVertexAttrib4NuivARB(GLuint index, const GLuint * v);</para>
        /// </summary>
        public unsafe static void VertexAttrib4NuivARB(uint index, ref uint v) {
            fixed (uint* pV = &v) {
                GLNative.glVertexAttrib4NuivARB(index, pV);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_vertex_program, GL_ARB_vertex_shader</para>
        /// Supported: <para>gl, gl</para>
        /// Original: <para>void glVertexAttrib4NusvARB(GLuint index, const GLushort * v);</para>
        /// </summary>
        public unsafe static void VertexAttrib4NusvARB(uint index, ref ushort v) {
            fixed (ushort* pV = &v) {
                GLNative.glVertexAttrib4NusvARB(index, pV);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_vertex_program, GL_ARB_vertex_shader</para>
        /// Supported: <para>gl, gl</para>
        /// Original: <para>void glVertexAttrib4bvARB(GLuint index, const GLbyte * v);</para>
        /// </summary>
        public unsafe static void VertexAttrib4bvARB(uint index, ref byte v) {
            fixed (byte* pV = &v) {
                GLNative.glVertexAttrib4bvARB(index, pV);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_vertex_program, GL_ARB_vertex_shader</para>
        /// Supported: <para>gl, gl</para>
        /// Original: <para>void glVertexAttrib4dvARB(GLuint index, const GLdouble * v);</para>
        /// </summary>
        public unsafe static void VertexAttrib4dvARB(uint index, ref double v) {
            fixed (double* pV = &v) {
                GLNative.glVertexAttrib4dvARB(index, pV);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_vertex_program, GL_ARB_vertex_shader</para>
        /// Supported: <para>gl, gl</para>
        /// Original: <para>void glVertexAttrib4fvARB(GLuint index, const GLfloat * v);</para>
        /// </summary>
        public unsafe static void VertexAttrib4fvARB(uint index, ref float v) {
            fixed (float* pV = &v) {
                GLNative.glVertexAttrib4fvARB(index, pV);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_vertex_program, GL_ARB_vertex_shader</para>
        /// Supported: <para>gl, gl</para>
        /// Original: <para>void glVertexAttrib4ivARB(GLuint index, const GLint * v);</para>
        /// </summary>
        public unsafe static void VertexAttrib4ivARB(uint index, ref int v) {
            fixed (int* pV = &v) {
                GLNative.glVertexAttrib4ivARB(index, pV);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_vertex_program, GL_ARB_vertex_shader</para>
        /// Supported: <para>gl, gl</para>
        /// Original: <para>void glVertexAttrib4svARB(GLuint index, const GLshort * v);</para>
        /// </summary>
        public unsafe static void VertexAttrib4svARB(uint index, ref short v) {
            fixed (short* pV = &v) {
                GLNative.glVertexAttrib4svARB(index, pV);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_vertex_program, GL_ARB_vertex_shader</para>
        /// Supported: <para>gl, gl</para>
        /// Original: <para>void glVertexAttrib4ubvARB(GLuint index, const GLubyte * v);</para>
        /// </summary>
        public unsafe static void VertexAttrib4ubvARB(uint index, ref byte v) {
            fixed (byte* pV = &v) {
                GLNative.glVertexAttrib4ubvARB(index, pV);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_vertex_program, GL_ARB_vertex_shader</para>
        /// Supported: <para>gl, gl</para>
        /// Original: <para>void glVertexAttrib4uivARB(GLuint index, const GLuint * v);</para>
        /// </summary>
        public unsafe static void VertexAttrib4uivARB(uint index, ref uint v) {
            fixed (uint* pV = &v) {
                GLNative.glVertexAttrib4uivARB(index, pV);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_vertex_program, GL_ARB_vertex_shader</para>
        /// Supported: <para>gl, gl</para>
        /// Original: <para>void glVertexAttrib4usvARB(GLuint index, const GLushort * v);</para>
        /// </summary>
        public unsafe static void VertexAttrib4usvARB(uint index, ref ushort v) {
            fixed (ushort* pV = &v) {
                GLNative.glVertexAttrib4usvARB(index, pV);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_vertex_program, GL_ARB_vertex_shader</para>
        /// Supported: <para>gl, gl</para>
        /// Original: <para>void glVertexAttribPointerARB(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const void * pointer);</para>
        /// </summary>
        public unsafe static void VertexAttribPointerARB(uint index, int size, uint type, bool normalized, int stride, IntPtr pointer) {
            GLNative.glVertexAttribPointerARB(index, size, type, normalized, stride, (void*)pointer);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_fragment_program, GL_ARB_vertex_program</para>
        /// Supported: <para>gl, gl</para>
        /// Original: <para>void glProgramStringARB(GLenum target, GLenum format, GLsizei len, const void * string);</para>
        /// </summary>
        public unsafe static void ProgramStringARB(uint target, uint format, int len, IntPtr str) {
            GLNative.glProgramStringARB(target, format, len, (void*)str);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_fragment_program, GL_ARB_vertex_program</para>
        /// Supported: <para>gl, gl</para>
        /// Original: <para>void glDeleteProgramsARB(GLsizei n, const GLuint * programs);</para>
        /// </summary>
        public unsafe static void DeleteProgramsARB(int n, ref uint programs) {
            fixed (uint* pPrograms = &programs) {
                GLNative.glDeleteProgramsARB(n, pPrograms);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_fragment_program, GL_ARB_vertex_program</para>
        /// Supported: <para>gl, gl</para>
        /// Original: <para>void glGenProgramsARB(GLsizei n, GLuint * programs);</para>
        /// </summary>
        public unsafe static void GenProgramsARB(int n, ref uint programs) {
            fixed (uint* pPrograms = &programs) {
                GLNative.glGenProgramsARB(n, pPrograms);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_fragment_program, GL_ARB_vertex_program</para>
        /// Supported: <para>gl, gl</para>
        /// Original: <para>void glProgramEnvParameter4dvARB(GLenum target, GLuint index, const GLdouble * params);</para>
        /// </summary>
        public unsafe static void ProgramEnvParameter4dvARB(uint target, uint index, ref double ps) {
            fixed (double* pPs = &ps) {
                GLNative.glProgramEnvParameter4dvARB(target, index, pPs);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_fragment_program, GL_ARB_vertex_program</para>
        /// Supported: <para>gl, gl</para>
        /// Original: <para>void glProgramEnvParameter4fvARB(GLenum target, GLuint index, const GLfloat * params);</para>
        /// </summary>
        public unsafe static void ProgramEnvParameter4fvARB(uint target, uint index, ref float ps) {
            fixed (float* pPs = &ps) {
                GLNative.glProgramEnvParameter4fvARB(target, index, pPs);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_fragment_program, GL_ARB_vertex_program</para>
        /// Supported: <para>gl, gl</para>
        /// Original: <para>void glProgramLocalParameter4dvARB(GLenum target, GLuint index, const GLdouble * params);</para>
        /// </summary>
        public unsafe static void ProgramLocalParameter4dvARB(uint target, uint index, ref double ps) {
            fixed (double* pPs = &ps) {
                GLNative.glProgramLocalParameter4dvARB(target, index, pPs);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_fragment_program, GL_ARB_vertex_program</para>
        /// Supported: <para>gl, gl</para>
        /// Original: <para>void glProgramLocalParameter4fvARB(GLenum target, GLuint index, const GLfloat * params);</para>
        /// </summary>
        public unsafe static void ProgramLocalParameter4fvARB(uint target, uint index, ref float ps) {
            fixed (float* pPs = &ps) {
                GLNative.glProgramLocalParameter4fvARB(target, index, pPs);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_fragment_program, GL_ARB_vertex_program</para>
        /// Supported: <para>gl, gl</para>
        /// Original: <para>void glGetProgramEnvParameterdvARB(GLenum target, GLuint index, GLdouble * params);</para>
        /// </summary>
        public unsafe static void GetProgramEnvParameterdvARB(uint target, uint index, ref double ps) {
            fixed (double* pPs = &ps) {
                GLNative.glGetProgramEnvParameterdvARB(target, index, pPs);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_fragment_program, GL_ARB_vertex_program</para>
        /// Supported: <para>gl, gl</para>
        /// Original: <para>void glGetProgramEnvParameterfvARB(GLenum target, GLuint index, GLfloat * params);</para>
        /// </summary>
        public unsafe static void GetProgramEnvParameterfvARB(uint target, uint index, ref float ps) {
            fixed (float* pPs = &ps) {
                GLNative.glGetProgramEnvParameterfvARB(target, index, pPs);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_fragment_program, GL_ARB_vertex_program</para>
        /// Supported: <para>gl, gl</para>
        /// Original: <para>void glGetProgramLocalParameterdvARB(GLenum target, GLuint index, GLdouble * params);</para>
        /// </summary>
        public unsafe static void GetProgramLocalParameterdvARB(uint target, uint index, ref double ps) {
            fixed (double* pPs = &ps) {
                GLNative.glGetProgramLocalParameterdvARB(target, index, pPs);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_fragment_program, GL_ARB_vertex_program</para>
        /// Supported: <para>gl, gl</para>
        /// Original: <para>void glGetProgramLocalParameterfvARB(GLenum target, GLuint index, GLfloat * params);</para>
        /// </summary>
        public unsafe static void GetProgramLocalParameterfvARB(uint target, uint index, ref float ps) {
            fixed (float* pPs = &ps) {
                GLNative.glGetProgramLocalParameterfvARB(target, index, pPs);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_fragment_program, GL_ARB_vertex_program</para>
        /// Supported: <para>gl, gl</para>
        /// Original: <para>void glGetProgramivARB(GLenum target, GLenum pname, GLint * params);</para>
        /// </summary>
        public unsafe static void GetProgramivARB(uint target, uint pname, ref int ps) {
            fixed (int* pPs = &ps) {
                GLNative.glGetProgramivARB(target, pname, pPs);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_fragment_program, GL_ARB_vertex_program</para>
        /// Supported: <para>gl, gl</para>
        /// Original: <para>void glGetProgramStringARB(GLenum target, GLenum pname, void * string);</para>
        /// </summary>
        public unsafe static void GetProgramStringARB(uint target, uint pname, IntPtr str) {
            GLNative.glGetProgramStringARB(target, pname, (void*)str);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_vertex_program, GL_ARB_vertex_shader</para>
        /// Supported: <para>gl, gl</para>
        /// Original: <para>void glGetVertexAttribdvARB(GLuint index, GLenum pname, GLdouble * params);</para>
        /// </summary>
        public unsafe static void GetVertexAttribdvARB(uint index, uint pname, ref double ps) {
            fixed (double* pPs = &ps) {
                GLNative.glGetVertexAttribdvARB(index, pname, pPs);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_vertex_program, GL_ARB_vertex_shader</para>
        /// Supported: <para>gl, gl</para>
        /// Original: <para>void glGetVertexAttribfvARB(GLuint index, GLenum pname, GLfloat * params);</para>
        /// </summary>
        public unsafe static void GetVertexAttribfvARB(uint index, uint pname, ref float ps) {
            fixed (float* pPs = &ps) {
                GLNative.glGetVertexAttribfvARB(index, pname, pPs);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_vertex_program, GL_ARB_vertex_shader</para>
        /// Supported: <para>gl, gl</para>
        /// Original: <para>void glGetVertexAttribivARB(GLuint index, GLenum pname, GLint * params);</para>
        /// </summary>
        public unsafe static void GetVertexAttribivARB(uint index, uint pname, ref int ps) {
            fixed (int* pPs = &ps) {
                GLNative.glGetVertexAttribivARB(index, pname, pPs);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_vertex_program, GL_ARB_vertex_shader</para>
        /// Supported: <para>gl, gl</para>
        /// Original: <para>void glGetVertexAttribPointervARB(GLuint index, GLenum pname, void ** pointer);</para>
        /// </summary>
        public unsafe static void GetVertexAttribPointervARB(uint index, uint pname, IntPtr pointer) {
            GLNative.glGetVertexAttribPointervARB(index, pname, (void**)pointer);
        }


        #endregion GL_ARB_vertex_program

        #region GL_ARB_vertex_shader

        // void glVertexAttrib1fvARB(GLuint index, const GLfloat * v);
        // void glVertexAttrib1svARB(GLuint index, const GLshort * v);
        // void glVertexAttrib1dvARB(GLuint index, const GLdouble * v);
        // void glVertexAttrib2fvARB(GLuint index, const GLfloat * v);
        // void glVertexAttrib2svARB(GLuint index, const GLshort * v);
        // void glVertexAttrib2dvARB(GLuint index, const GLdouble * v);
        // void glVertexAttrib3fvARB(GLuint index, const GLfloat * v);
        // void glVertexAttrib3svARB(GLuint index, const GLshort * v);
        // void glVertexAttrib3dvARB(GLuint index, const GLdouble * v);
        // void glVertexAttrib4fvARB(GLuint index, const GLfloat * v);
        // void glVertexAttrib4svARB(GLuint index, const GLshort * v);
        // void glVertexAttrib4dvARB(GLuint index, const GLdouble * v);
        // void glVertexAttrib4ivARB(GLuint index, const GLint * v);
        // void glVertexAttrib4bvARB(GLuint index, const GLbyte * v);
        // void glVertexAttrib4ubvARB(GLuint index, const GLubyte * v);
        // void glVertexAttrib4usvARB(GLuint index, const GLushort * v);
        // void glVertexAttrib4uivARB(GLuint index, const GLuint * v);
        // void glVertexAttrib4NbvARB(GLuint index, const GLbyte * v);
        // void glVertexAttrib4NsvARB(GLuint index, const GLshort * v);
        // void glVertexAttrib4NivARB(GLuint index, const GLint * v);
        // void glVertexAttrib4NubvARB(GLuint index, const GLubyte * v);
        // void glVertexAttrib4NusvARB(GLuint index, const GLushort * v);
        // void glVertexAttrib4NuivARB(GLuint index, const GLuint * v);
        // void glVertexAttribPointerARB(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const void * pointer);
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_vertex_shader</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glBindAttribLocationARB(GLhandleARB programObj, GLuint index, const GLcharARB * name);</para>
        /// </summary>
        public unsafe static void BindAttribLocationARB(uint programObj, uint index, ref uint name) {
            fixed (uint* pName = &name) {
                GLNative.glBindAttribLocationARB(programObj, index, pName);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_vertex_shader</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetActiveAttribARB(GLhandleARB programObj, GLuint index, GLsizei maxLength, GLsizei * length, GLint * size, GLenum * type, GLcharARB * name);</para>
        /// </summary>
        public unsafe static void GetActiveAttribARB(uint programObj, uint index, int maxLength, ref int length, ref int size, ref uint type, ref uint name) {
            fixed (int* pLength = &length)
            fixed (int* pSize = &size)
            fixed (uint* pType = &type)
            fixed (uint* pName = &name) {
                GLNative.glGetActiveAttribARB(programObj, index, maxLength, pLength, pSize, pType, pName);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_vertex_shader</para>
        /// Supported: <para>gl</para>
        /// Original: <para>GLint glGetAttribLocationARB(GLhandleARB programObj, const GLcharARB * name);</para>
        /// </summary>
        public unsafe static int GetAttribLocationARB(uint programObj, ref uint name) {
            fixed (uint* pName = &name) {
                return GLNative.glGetAttribLocationARB(programObj, pName);
            }
        }

        // void glGetVertexAttribdvARB(GLuint index, GLenum pname, GLdouble * ps);
        // void glGetVertexAttribfvARB(GLuint index, GLenum pname, GLfloat * ps);
        // void glGetVertexAttribivARB(GLuint index, GLenum pname, GLint * ps);
        // void glGetVertexAttribPointervARB(GLuint index, GLenum pname, void ** pointer);

        #endregion GL_ARB_vertex_shader

        #region GL_ARB_vertex_type_2_10_10_10_rev

        // void glVertexAttribP1uiv(GLuint index, GLenum type, GLboolean normalized, const GLuint * value);
        // void glVertexAttribP2uiv(GLuint index, GLenum type, GLboolean normalized, const GLuint * value);
        // void glVertexAttribP3uiv(GLuint index, GLenum type, GLboolean normalized, const GLuint * value);
        // void glVertexAttribP4uiv(GLuint index, GLenum type, GLboolean normalized, const GLuint * value);
        // void glVertexP2uiv(GLenum type, const GLuint * value);
        // void glVertexP3uiv(GLenum type, const GLuint * value);
        // void glVertexP4uiv(GLenum type, const GLuint * value);
        // void glTexCoordP1uiv(GLenum type, const GLuint * coords);
        // void glTexCoordP2uiv(GLenum type, const GLuint * coords);
        // void glTexCoordP3uiv(GLenum type, const GLuint * coords);
        // void glTexCoordP4uiv(GLenum type, const GLuint * coords);
        // void glMultiTexCoordP1uiv(GLenum texture, GLenum type, const GLuint * coords);
        // void glMultiTexCoordP2uiv(GLenum texture, GLenum type, const GLuint * coords);
        // void glMultiTexCoordP3uiv(GLenum texture, GLenum type, const GLuint * coords);
        // void glMultiTexCoordP4uiv(GLenum texture, GLenum type, const GLuint * coords);
        // void glNormalP3uiv(GLenum type, const GLuint * coords);
        // void glColorP3uiv(GLenum type, const GLuint * color);
        // void glColorP4uiv(GLenum type, const GLuint * color);
        // void glSecondaryColorP3uiv(GLenum type, const GLuint * color);

        #endregion GL_ARB_vertex_type_2_10_10_10_rev

        #region GL_ARB_viewport_array

        // void glViewportArrayv(GLuint first, GLsizei count, const GLfloat * v);
        // void glViewportIndexedfv(GLuint index, const GLfloat * v);
        // void glScissorArrayv(GLuint first, GLsizei count, const GLint * v);
        // void glScissorIndexedv(GLuint index, const GLint * v);
        // void glDepthRangeArrayv(GLuint first, GLsizei count, const GLdouble * v);
        // void glGetFloati_v(GLenum target, GLuint index, GLfloat * data);
        // void glGetDoublei_v(GLenum target, GLuint index, GLdouble * data);
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_viewport_array</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glDepthRangeArraydvNV(GLuint first, GLsizei count, const GLdouble * v);</para>
        /// </summary>
        public unsafe static void DepthRangeArraydvNV(uint first, int count, ref double v) {
            fixed (double* pV = &v) {
                GLNative.glDepthRangeArraydvNV(first, count, pV);
            }
        }


        #endregion GL_ARB_viewport_array

        #region GL_ARB_window_pos

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_window_pos</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glWindowPos2dvARB(const GLdouble * v);</para>
        /// </summary>
        public unsafe static void WindowPos2dvARB(ref double v) {
            fixed (double* pV = &v) {
                GLNative.glWindowPos2dvARB(pV);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_window_pos</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glWindowPos2fvARB(const GLfloat * v);</para>
        /// </summary>
        public unsafe static void WindowPos2fvARB(ref float v) {
            fixed (float* pV = &v) {
                GLNative.glWindowPos2fvARB(pV);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_window_pos</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glWindowPos2ivARB(const GLint * v);</para>
        /// </summary>
        public unsafe static void WindowPos2ivARB(ref int v) {
            fixed (int* pV = &v) {
                GLNative.glWindowPos2ivARB(pV);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_window_pos</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glWindowPos2svARB(const GLshort * v);</para>
        /// </summary>
        public unsafe static void WindowPos2svARB(ref short v) {
            fixed (short* pV = &v) {
                GLNative.glWindowPos2svARB(pV);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_window_pos</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glWindowPos3dvARB(const GLdouble * v);</para>
        /// </summary>
        public unsafe static void WindowPos3dvARB(ref double v) {
            fixed (double* pV = &v) {
                GLNative.glWindowPos3dvARB(pV);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_window_pos</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glWindowPos3fvARB(const GLfloat * v);</para>
        /// </summary>
        public unsafe static void WindowPos3fvARB(ref float v) {
            fixed (float* pV = &v) {
                GLNative.glWindowPos3fvARB(pV);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_window_pos</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glWindowPos3ivARB(const GLint * v);</para>
        /// </summary>
        public unsafe static void WindowPos3ivARB(ref int v) {
            fixed (int* pV = &v) {
                GLNative.glWindowPos3ivARB(pV);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_window_pos</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glWindowPos3svARB(const GLshort * v);</para>
        /// </summary>
        public unsafe static void WindowPos3svARB(ref short v) {
            fixed (short* pV = &v) {
                GLNative.glWindowPos3svARB(pV);
            }
        }


        #endregion GL_ARB_window_pos

        #region GL_ATI_draw_buffers

        /// <summary>
        /// <para>Require:</para> <para>GL_ATI_draw_buffers</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glDrawBuffersATI(GLsizei n, const GLenum * bufs);</para>
        /// </summary>
        public unsafe static void DrawBuffersATI(int n, ref uint bufs) {
            fixed (uint* pBufs = &bufs) {
                GLNative.glDrawBuffersATI(n, pBufs);
            }
        }


        #endregion GL_ATI_draw_buffers

        #region GL_ATI_element_array

        /// <summary>
        /// <para>Require:</para> <para>GL_ATI_element_array</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glElementPointerATI(GLenum type, const void * pointer);</para>
        /// </summary>
        public unsafe static void ElementPointerATI(uint type, IntPtr pointer) {
            GLNative.glElementPointerATI(type, (void*)pointer);
        }


        #endregion GL_ATI_element_array

        #region GL_ATI_envmap_bumpmap

        /// <summary>
        /// <para>Require:</para> <para>GL_ATI_envmap_bumpmap</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glTexBumpParameterivATI(GLenum pname, const GLint * param);</para>
        /// </summary>
        public unsafe static void TexBumpParameterivATI(uint pname, ref int param) {
            fixed (int* pParam = &param) {
                GLNative.glTexBumpParameterivATI(pname, pParam);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ATI_envmap_bumpmap</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glTexBumpParameterfvATI(GLenum pname, const GLfloat * param);</para>
        /// </summary>
        public unsafe static void TexBumpParameterfvATI(uint pname, ref float param) {
            fixed (float* pParam = &param) {
                GLNative.glTexBumpParameterfvATI(pname, pParam);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ATI_envmap_bumpmap</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetTexBumpParameterivATI(GLenum pname, GLint * param);</para>
        /// </summary>
        public unsafe static void GetTexBumpParameterivATI(uint pname, ref int param) {
            fixed (int* pParam = &param) {
                GLNative.glGetTexBumpParameterivATI(pname, pParam);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ATI_envmap_bumpmap</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetTexBumpParameterfvATI(GLenum pname, GLfloat * param);</para>
        /// </summary>
        public unsafe static void GetTexBumpParameterfvATI(uint pname, ref float param) {
            fixed (float* pParam = &param) {
                GLNative.glGetTexBumpParameterfvATI(pname, pParam);
            }
        }


        #endregion GL_ATI_envmap_bumpmap

        #region GL_ATI_fragment_shader

        /// <summary>
        /// <para>Require:</para> <para>GL_ATI_fragment_shader</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glSetFragmentShaderConstantATI(GLuint dst, const GLfloat * value);</para>
        /// </summary>
        public unsafe static void SetFragmentShaderConstantATI(uint dst, ref float value) {
            fixed (float* pValue = &value) {
                GLNative.glSetFragmentShaderConstantATI(dst, pValue);
            }
        }


        #endregion GL_ATI_fragment_shader

        #region GL_ATI_map_object_buffer

        /// <summary>
        /// <para>Require:</para> <para>GL_ATI_map_object_buffer</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void * glMapObjectBufferATI(GLuint buffer);</para>
        /// </summary>
        public unsafe static IntPtr MapObjectBufferATI(uint buffer) {
            return (IntPtr)GLNative.glMapObjectBufferATI(buffer);
        }


        #endregion GL_ATI_map_object_buffer

        #region GL_ATI_pn_triangles


        #endregion GL_ATI_pn_triangles

        #region GL_ATI_separate_stencil


        #endregion GL_ATI_separate_stencil

        #region GL_ATI_vertex_array_object

        /// <summary>
        /// <para>Require:</para> <para>GL_ATI_vertex_array_object</para>
        /// Supported: <para>gl</para>
        /// Original: <para>GLuint glNewObjectBufferATI(GLsizei size, const void * pointer, GLenum usage);</para>
        /// </summary>
        public unsafe static uint NewObjectBufferATI(int size, IntPtr pointer, uint usage) {
            return GLNative.glNewObjectBufferATI(size, (void*)pointer, usage);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ATI_vertex_array_object</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glUpdateObjectBufferATI(GLuint buffer, GLuint offset, GLsizei size, const void * pointer, GLenum preserve);</para>
        /// </summary>
        public unsafe static void UpdateObjectBufferATI(uint buffer, uint offset, int size, IntPtr pointer, uint preserve) {
            GLNative.glUpdateObjectBufferATI(buffer, offset, size, (void*)pointer, preserve);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ATI_vertex_array_object</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetObjectBufferfvATI(GLuint buffer, GLenum pname, GLfloat * params);</para>
        /// </summary>
        public unsafe static void GetObjectBufferfvATI(uint buffer, uint pname, ref float ps) {
            fixed (float* pPs = &ps) {
                GLNative.glGetObjectBufferfvATI(buffer, pname, pPs);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ATI_vertex_array_object</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetObjectBufferivATI(GLuint buffer, GLenum pname, GLint * params);</para>
        /// </summary>
        public unsafe static void GetObjectBufferivATI(uint buffer, uint pname, ref int ps) {
            fixed (int* pPs = &ps) {
                GLNative.glGetObjectBufferivATI(buffer, pname, pPs);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ATI_vertex_array_object</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetArrayObjectfvATI(GLenum array, GLenum pname, GLfloat * params);</para>
        /// </summary>
        public unsafe static void GetArrayObjectfvATI(uint array, uint pname, ref float ps) {
            fixed (float* pPs = &ps) {
                GLNative.glGetArrayObjectfvATI(array, pname, pPs);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ATI_vertex_array_object</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetArrayObjectivATI(GLenum array, GLenum pname, GLint * params);</para>
        /// </summary>
        public unsafe static void GetArrayObjectivATI(uint array, uint pname, ref int ps) {
            fixed (int* pPs = &ps) {
                GLNative.glGetArrayObjectivATI(array, pname, pPs);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ATI_vertex_array_object</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetVariantArrayObjectfvATI(GLuint id, GLenum pname, GLfloat * params);</para>
        /// </summary>
        public unsafe static void GetVariantArrayObjectfvATI(uint id, uint pname, ref float ps) {
            fixed (float* pPs = &ps) {
                GLNative.glGetVariantArrayObjectfvATI(id, pname, pPs);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ATI_vertex_array_object</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetVariantArrayObjectivATI(GLuint id, GLenum pname, GLint * params);</para>
        /// </summary>
        public unsafe static void GetVariantArrayObjectivATI(uint id, uint pname, ref int ps) {
            fixed (int* pPs = &ps) {
                GLNative.glGetVariantArrayObjectivATI(id, pname, pPs);
            }
        }


        #endregion GL_ATI_vertex_array_object

        #region GL_ATI_vertex_attrib_array_object

        /// <summary>
        /// <para>Require:</para> <para>GL_ATI_vertex_attrib_array_object</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetVertexAttribArrayObjectfvATI(GLuint index, GLenum pname, GLfloat * params);</para>
        /// </summary>
        public unsafe static void GetVertexAttribArrayObjectfvATI(uint index, uint pname, ref float ps) {
            fixed (float* pPs = &ps) {
                GLNative.glGetVertexAttribArrayObjectfvATI(index, pname, pPs);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ATI_vertex_attrib_array_object</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetVertexAttribArrayObjectivATI(GLuint index, GLenum pname, GLint * params);</para>
        /// </summary>
        public unsafe static void GetVertexAttribArrayObjectivATI(uint index, uint pname, ref int ps) {
            fixed (int* pPs = &ps) {
                GLNative.glGetVertexAttribArrayObjectivATI(index, pname, pPs);
            }
        }


        #endregion GL_ATI_vertex_attrib_array_object

        #region GL_ATI_vertex_streams

        /// <summary>
        /// <para>Require:</para> <para>GL_ATI_vertex_streams</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexStream1svATI(GLenum stream, const GLshort * coords);</para>
        /// </summary>
        public unsafe static void VertexStream1svATI(uint stream, ref short coords) {
            fixed (short* pCoords = &coords) {
                GLNative.glVertexStream1svATI(stream, pCoords);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ATI_vertex_streams</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexStream1ivATI(GLenum stream, const GLint * coords);</para>
        /// </summary>
        public unsafe static void VertexStream1ivATI(uint stream, ref int coords) {
            fixed (int* pCoords = &coords) {
                GLNative.glVertexStream1ivATI(stream, pCoords);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ATI_vertex_streams</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexStream1fvATI(GLenum stream, const GLfloat * coords);</para>
        /// </summary>
        public unsafe static void VertexStream1fvATI(uint stream, ref float coords) {
            fixed (float* pCoords = &coords) {
                GLNative.glVertexStream1fvATI(stream, pCoords);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ATI_vertex_streams</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexStream1dvATI(GLenum stream, const GLdouble * coords);</para>
        /// </summary>
        public unsafe static void VertexStream1dvATI(uint stream, ref double coords) {
            fixed (double* pCoords = &coords) {
                GLNative.glVertexStream1dvATI(stream, pCoords);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ATI_vertex_streams</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexStream2svATI(GLenum stream, const GLshort * coords);</para>
        /// </summary>
        public unsafe static void VertexStream2svATI(uint stream, ref short coords) {
            fixed (short* pCoords = &coords) {
                GLNative.glVertexStream2svATI(stream, pCoords);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ATI_vertex_streams</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexStream2ivATI(GLenum stream, const GLint * coords);</para>
        /// </summary>
        public unsafe static void VertexStream2ivATI(uint stream, ref int coords) {
            fixed (int* pCoords = &coords) {
                GLNative.glVertexStream2ivATI(stream, pCoords);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ATI_vertex_streams</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexStream2fvATI(GLenum stream, const GLfloat * coords);</para>
        /// </summary>
        public unsafe static void VertexStream2fvATI(uint stream, ref float coords) {
            fixed (float* pCoords = &coords) {
                GLNative.glVertexStream2fvATI(stream, pCoords);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ATI_vertex_streams</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexStream2dvATI(GLenum stream, const GLdouble * coords);</para>
        /// </summary>
        public unsafe static void VertexStream2dvATI(uint stream, ref double coords) {
            fixed (double* pCoords = &coords) {
                GLNative.glVertexStream2dvATI(stream, pCoords);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ATI_vertex_streams</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexStream3svATI(GLenum stream, const GLshort * coords);</para>
        /// </summary>
        public unsafe static void VertexStream3svATI(uint stream, ref short coords) {
            fixed (short* pCoords = &coords) {
                GLNative.glVertexStream3svATI(stream, pCoords);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ATI_vertex_streams</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexStream3ivATI(GLenum stream, const GLint * coords);</para>
        /// </summary>
        public unsafe static void VertexStream3ivATI(uint stream, ref int coords) {
            fixed (int* pCoords = &coords) {
                GLNative.glVertexStream3ivATI(stream, pCoords);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ATI_vertex_streams</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexStream3fvATI(GLenum stream, const GLfloat * coords);</para>
        /// </summary>
        public unsafe static void VertexStream3fvATI(uint stream, ref float coords) {
            fixed (float* pCoords = &coords) {
                GLNative.glVertexStream3fvATI(stream, pCoords);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ATI_vertex_streams</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexStream3dvATI(GLenum stream, const GLdouble * coords);</para>
        /// </summary>
        public unsafe static void VertexStream3dvATI(uint stream, ref double coords) {
            fixed (double* pCoords = &coords) {
                GLNative.glVertexStream3dvATI(stream, pCoords);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ATI_vertex_streams</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexStream4svATI(GLenum stream, const GLshort * coords);</para>
        /// </summary>
        public unsafe static void VertexStream4svATI(uint stream, ref short coords) {
            fixed (short* pCoords = &coords) {
                GLNative.glVertexStream4svATI(stream, pCoords);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ATI_vertex_streams</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexStream4ivATI(GLenum stream, const GLint * coords);</para>
        /// </summary>
        public unsafe static void VertexStream4ivATI(uint stream, ref int coords) {
            fixed (int* pCoords = &coords) {
                GLNative.glVertexStream4ivATI(stream, pCoords);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ATI_vertex_streams</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexStream4fvATI(GLenum stream, const GLfloat * coords);</para>
        /// </summary>
        public unsafe static void VertexStream4fvATI(uint stream, ref float coords) {
            fixed (float* pCoords = &coords) {
                GLNative.glVertexStream4fvATI(stream, pCoords);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ATI_vertex_streams</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexStream4dvATI(GLenum stream, const GLdouble * coords);</para>
        /// </summary>
        public unsafe static void VertexStream4dvATI(uint stream, ref double coords) {
            fixed (double* pCoords = &coords) {
                GLNative.glVertexStream4dvATI(stream, pCoords);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ATI_vertex_streams</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glNormalStream3bvATI(GLenum stream, const GLbyte * coords);</para>
        /// </summary>
        public unsafe static void NormalStream3bvATI(uint stream, ref byte coords) {
            fixed (byte* pCoords = &coords) {
                GLNative.glNormalStream3bvATI(stream, pCoords);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ATI_vertex_streams</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glNormalStream3svATI(GLenum stream, const GLshort * coords);</para>
        /// </summary>
        public unsafe static void NormalStream3svATI(uint stream, ref short coords) {
            fixed (short* pCoords = &coords) {
                GLNative.glNormalStream3svATI(stream, pCoords);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ATI_vertex_streams</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glNormalStream3ivATI(GLenum stream, const GLint * coords);</para>
        /// </summary>
        public unsafe static void NormalStream3ivATI(uint stream, ref int coords) {
            fixed (int* pCoords = &coords) {
                GLNative.glNormalStream3ivATI(stream, pCoords);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ATI_vertex_streams</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glNormalStream3fvATI(GLenum stream, const GLfloat * coords);</para>
        /// </summary>
        public unsafe static void NormalStream3fvATI(uint stream, ref float coords) {
            fixed (float* pCoords = &coords) {
                GLNative.glNormalStream3fvATI(stream, pCoords);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ATI_vertex_streams</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glNormalStream3dvATI(GLenum stream, const GLdouble * coords);</para>
        /// </summary>
        public unsafe static void NormalStream3dvATI(uint stream, ref double coords) {
            fixed (double* pCoords = &coords) {
                GLNative.glNormalStream3dvATI(stream, pCoords);
            }
        }


        #endregion GL_ATI_vertex_streams

        #region GL_EXT_EGL_image_storage

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_EGL_image_storage</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glEGLImageTargetTexStorageEXT(GLenum target, GLeglImageOES image, const GLint* attrib_list);</para>
        /// </summary>
        public unsafe static void EGLImageTargetTexStorageEXT(uint target, IntPtr image, ref int attrib_list) {
            fixed (int* pAttrib_list = &attrib_list) {
                GLNative.glEGLImageTargetTexStorageEXT(target, image, pAttrib_list);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_EGL_image_storage</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glEGLImageTargetTextureStorageEXT(GLuint texture, GLeglImageOES image, const GLint* attrib_list);</para>
        /// </summary>
        public unsafe static void EGLImageTargetTextureStorageEXT(uint texture, IntPtr image, ref int attrib_list) {
            fixed (int* pAttrib_list = &attrib_list) {
                GLNative.glEGLImageTargetTextureStorageEXT(texture, image, pAttrib_list);
            }
        }


        #endregion GL_EXT_EGL_image_storage

        #region GL_EXT_bindable_uniform


        #endregion GL_EXT_bindable_uniform

        #region GL_EXT_blend_color


        #endregion GL_EXT_blend_color

        #region GL_EXT_blend_equation_separate


        #endregion GL_EXT_blend_equation_separate

        #region GL_EXT_blend_func_separate


        #endregion GL_EXT_blend_func_separate

        #region GL_EXT_color_subtable

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_color_subtable</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glColorSubTableEXT(GLenum target, GLsizei start, GLsizei count, GLenum format, GLenum type, const void * data);</para>
        /// </summary>
        public unsafe static void ColorSubTableEXT(uint target, int start, int count, uint format, uint type, IntPtr data) {
            GLNative.glColorSubTableEXT(target, start, count, format, type, (void*)data);
        }


        #endregion GL_EXT_color_subtable

        #region GL_EXT_compiled_vertex_array


        #endregion GL_EXT_compiled_vertex_array

        #region GL_EXT_convolution

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_convolution</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glConvolutionFilter1DEXT(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const void * image);</para>
        /// </summary>
        public unsafe static void ConvolutionFilter1DEXT(uint target, uint internalformat, int width, uint format, uint type, IntPtr image) {
            GLNative.glConvolutionFilter1DEXT(target, internalformat, width, format, type, (void*)image);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_convolution</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glConvolutionFilter2DEXT(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const void * image);</para>
        /// </summary>
        public unsafe static void ConvolutionFilter2DEXT(uint target, uint internalformat, int width, int height, uint format, uint type, IntPtr image) {
            GLNative.glConvolutionFilter2DEXT(target, internalformat, width, height, format, type, (void*)image);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_convolution</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glConvolutionParameterfvEXT(GLenum target, GLenum pname, const GLfloat * params);</para>
        /// </summary>
        public unsafe static void ConvolutionParameterfvEXT(uint target, uint pname, ref float ps) {
            fixed (float* pPs = &ps) {
                GLNative.glConvolutionParameterfvEXT(target, pname, pPs);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_convolution</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glConvolutionParameterivEXT(GLenum target, GLenum pname, const GLint * params);</para>
        /// </summary>
        public unsafe static void ConvolutionParameterivEXT(uint target, uint pname, ref int ps) {
            fixed (int* pPs = &ps) {
                GLNative.glConvolutionParameterivEXT(target, pname, pPs);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_convolution</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetConvolutionFilterEXT(GLenum target, GLenum format, GLenum type, void * image);</para>
        /// </summary>
        public unsafe static void GetConvolutionFilterEXT(uint target, uint format, uint type, IntPtr image) {
            GLNative.glGetConvolutionFilterEXT(target, format, type, (void*)image);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_convolution</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetConvolutionParameterfvEXT(GLenum target, GLenum pname, GLfloat * params);</para>
        /// </summary>
        public unsafe static void GetConvolutionParameterfvEXT(uint target, uint pname, ref float ps) {
            fixed (float* pPs = &ps) {
                GLNative.glGetConvolutionParameterfvEXT(target, pname, pPs);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_convolution</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetConvolutionParameterivEXT(GLenum target, GLenum pname, GLint * params);</para>
        /// </summary>
        public unsafe static void GetConvolutionParameterivEXT(uint target, uint pname, ref int ps) {
            fixed (int* pPs = &ps) {
                GLNative.glGetConvolutionParameterivEXT(target, pname, pPs);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_convolution</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetSeparableFilterEXT(GLenum target, GLenum format, GLenum type, void * row, void * column, void * span);</para>
        /// </summary>
        public unsafe static void GetSeparableFilterEXT(uint target, uint format, uint type, IntPtr row, IntPtr column, IntPtr span) {
            GLNative.glGetSeparableFilterEXT(target, format, type, (void*)row, (void*)column, (void*)span);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_convolution</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glSeparableFilter2DEXT(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const void * row, const void * column);</para>
        /// </summary>
        public unsafe static void SeparableFilter2DEXT(uint target, uint internalformat, int width, int height, uint format, uint type, IntPtr row, IntPtr column) {
            GLNative.glSeparableFilter2DEXT(target, internalformat, width, height, format, type, (void*)row, (void*)column);
        }


        #endregion GL_EXT_convolution

        #region GL_EXT_coordinate_frame

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_coordinate_frame</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glTangent3bvEXT(const GLbyte * v);</para>
        /// </summary>
        public unsafe static void Tangent3bvEXT(ref byte v) {
            fixed (byte* pV = &v) {
                GLNative.glTangent3bvEXT(pV);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_coordinate_frame</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glTangent3dvEXT(const GLdouble * v);</para>
        /// </summary>
        public unsafe static void Tangent3dvEXT(ref double v) {
            fixed (double* pV = &v) {
                GLNative.glTangent3dvEXT(pV);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_coordinate_frame</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glTangent3fvEXT(const GLfloat * v);</para>
        /// </summary>
        public unsafe static void Tangent3fvEXT(ref float v) {
            fixed (float* pV = &v) {
                GLNative.glTangent3fvEXT(pV);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_coordinate_frame</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glTangent3ivEXT(const GLint * v);</para>
        /// </summary>
        public unsafe static void Tangent3ivEXT(ref int v) {
            fixed (int* pV = &v) {
                GLNative.glTangent3ivEXT(pV);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_coordinate_frame</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glTangent3svEXT(const GLshort * v);</para>
        /// </summary>
        public unsafe static void Tangent3svEXT(ref short v) {
            fixed (short* pV = &v) {
                GLNative.glTangent3svEXT(pV);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_coordinate_frame</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glBinormal3bvEXT(const GLbyte * v);</para>
        /// </summary>
        public unsafe static void Binormal3bvEXT(ref byte v) {
            fixed (byte* pV = &v) {
                GLNative.glBinormal3bvEXT(pV);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_coordinate_frame</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glBinormal3dvEXT(const GLdouble * v);</para>
        /// </summary>
        public unsafe static void Binormal3dvEXT(ref double v) {
            fixed (double* pV = &v) {
                GLNative.glBinormal3dvEXT(pV);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_coordinate_frame</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glBinormal3fvEXT(const GLfloat * v);</para>
        /// </summary>
        public unsafe static void Binormal3fvEXT(ref float v) {
            fixed (float* pV = &v) {
                GLNative.glBinormal3fvEXT(pV);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_coordinate_frame</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glBinormal3ivEXT(const GLint * v);</para>
        /// </summary>
        public unsafe static void Binormal3ivEXT(ref int v) {
            fixed (int* pV = &v) {
                GLNative.glBinormal3ivEXT(pV);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_coordinate_frame</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glBinormal3svEXT(const GLshort * v);</para>
        /// </summary>
        public unsafe static void Binormal3svEXT(ref short v) {
            fixed (short* pV = &v) {
                GLNative.glBinormal3svEXT(pV);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_coordinate_frame</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glTangentPointerEXT(GLenum type, GLsizei stride, const void * pointer);</para>
        /// </summary>
        public unsafe static void TangentPointerEXT(uint type, int stride, IntPtr pointer) {
            GLNative.glTangentPointerEXT(type, stride, (void*)pointer);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_coordinate_frame</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glBinormalPointerEXT(GLenum type, GLsizei stride, const void * pointer);</para>
        /// </summary>
        public unsafe static void BinormalPointerEXT(uint type, int stride, IntPtr pointer) {
            GLNative.glBinormalPointerEXT(type, stride, (void*)pointer);
        }


        #endregion GL_EXT_coordinate_frame

        #region GL_EXT_copy_texture


        #endregion GL_EXT_copy_texture

        #region GL_EXT_cull_vertex

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_cull_vertex</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glCullParameterdvEXT(GLenum pname, GLdouble * params);</para>
        /// </summary>
        public unsafe static void CullParameterdvEXT(uint pname, ref double ps) {
            fixed (double* pPs = &ps) {
                GLNative.glCullParameterdvEXT(pname, pPs);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_cull_vertex</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glCullParameterfvEXT(GLenum pname, GLfloat * params);</para>
        /// </summary>
        public unsafe static void CullParameterfvEXT(uint pname, ref float ps) {
            fixed (float* pPs = &ps) {
                GLNative.glCullParameterfvEXT(pname, pPs);
            }
        }


        #endregion GL_EXT_cull_vertex

        #region GL_EXT_debug_label

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_debug_label</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glLabelObjectEXT(GLenum type, GLuint object, GLsizei length, const GLchar * label);</para>
        /// </summary>
        public unsafe static void LabelObjectEXT(uint type, uint obj, int length, ref byte label) {
            fixed (byte* pLabel = &label) {
                GLNative.glLabelObjectEXT(type, obj, length, pLabel);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_debug_label</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glGetObjectLabelEXT(GLenum type, GLuint object, GLsizei bufSize, GLsizei * length, GLchar * label);</para>
        /// </summary>
        public unsafe static void GetObjectLabelEXT(uint type, uint obj, int bufSize, ref int length, ref byte label) {
            fixed (int* pLength = &length)
            fixed (byte* pLabel = &label) {
                GLNative.glGetObjectLabelEXT(type, obj, bufSize, pLength, pLabel);
            }
        }


        #endregion GL_EXT_debug_label

        #region GL_EXT_debug_marker

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_debug_marker</para>
        /// Supported: <para>gl, glcore, gles1, gles2</para>
        /// Original: <para>void glInsertEventMarkerEXT(GLsizei length, const GLchar * marker);</para>
        /// </summary>
        public unsafe static void InsertEventMarkerEXT(int length, ref byte marker) {
            fixed (byte* pMarker = &marker) {
                GLNative.glInsertEventMarkerEXT(length, pMarker);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_debug_marker</para>
        /// Supported: <para>gl, glcore, gles1, gles2</para>
        /// Original: <para>void glPushGroupMarkerEXT(GLsizei length, const GLchar * marker);</para>
        /// </summary>
        public unsafe static void PushGroupMarkerEXT(int length, ref byte marker) {
            fixed (byte* pMarker = &marker) {
                GLNative.glPushGroupMarkerEXT(length, pMarker);
            }
        }


        #endregion GL_EXT_debug_marker

        #region GL_EXT_depth_bounds_test


        #endregion GL_EXT_depth_bounds_test

        #region GL_EXT_draw_buffers2

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_direct_state_access, GL_EXT_draw_buffers2</para>
        /// Supported: <para>gl, glcore, gl</para>
        /// Original: <para>void glGetBooleanIndexedvEXT(GLenum target, GLuint index, GLboolean * data);</para>
        /// </summary>
        public unsafe static void GetBooleanIndexedvEXT(uint target, uint index, ref bool data) {
            fixed (bool* pData = &data) {
                GLNative.glGetBooleanIndexedvEXT(target, index, pData);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_direct_state_access, GL_EXT_draw_buffers2</para>
        /// Supported: <para>gl, glcore, gl</para>
        /// Original: <para>void glGetIntegerIndexedvEXT(GLenum target, GLuint index, GLint * data);</para>
        /// </summary>
        public unsafe static void GetIntegerIndexedvEXT(uint target, uint index, ref int data) {
            fixed (int* pData = &data) {
                GLNative.glGetIntegerIndexedvEXT(target, index, pData);
            }
        }


        #endregion GL_EXT_draw_buffers2

        #region GL_EXT_draw_instanced

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_draw_instanced, GL_EXT_instanced_arrays</para>
        /// Supported: <para>gl, glcore, gles2, gles2</para>
        /// Original: <para>void glDrawElementsInstancedEXT(GLenum mode, GLsizei count, GLenum type, const void * indices, GLsizei primcount);</para>
        /// </summary>
        public unsafe static void DrawElementsInstancedEXT(uint mode, int count, uint type, IntPtr indices, int primcount) {
            GLNative.glDrawElementsInstancedEXT(mode, count, type, (void*)indices, primcount);
        }


        #endregion GL_EXT_draw_instanced

        #region GL_EXT_draw_range_elements

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_draw_range_elements</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glDrawRangeElementsEXT(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const void * indices);</para>
        /// </summary>
        public unsafe static void DrawRangeElementsEXT(uint mode, uint start, uint end, int count, uint type, IntPtr indices) {
            GLNative.glDrawRangeElementsEXT(mode, start, end, count, type, (void*)indices);
        }


        #endregion GL_EXT_draw_range_elements

        #region GL_EXT_external_buffer


        #endregion GL_EXT_external_buffer

        #region GL_EXT_fog_coord

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_fog_coord</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glFogCoordfvEXT(const GLfloat * coord);</para>
        /// </summary>
        public unsafe static void FogCoordfvEXT(ref float coord) {
            fixed (float* pCoord = &coord) {
                GLNative.glFogCoordfvEXT(pCoord);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_fog_coord</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glFogCoorddvEXT(const GLdouble * coord);</para>
        /// </summary>
        public unsafe static void FogCoorddvEXT(ref double coord) {
            fixed (double* pCoord = &coord) {
                GLNative.glFogCoorddvEXT(pCoord);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_fog_coord</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glFogCoordPointerEXT(GLenum type, GLsizei stride, const void * pointer);</para>
        /// </summary>
        public unsafe static void FogCoordPointerEXT(uint type, int stride, IntPtr pointer) {
            GLNative.glFogCoordPointerEXT(type, stride, (void*)pointer);
        }


        #endregion GL_EXT_fog_coord

        #region GL_EXT_framebuffer_blit


        #endregion GL_EXT_framebuffer_blit

        #region GL_EXT_framebuffer_multisample


        #endregion GL_EXT_framebuffer_multisample

        #region GL_EXT_framebuffer_object

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_framebuffer_object</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glDeleteRenderbuffersEXT(GLsizei n, const GLuint * renderbuffers);</para>
        /// </summary>
        public unsafe static void DeleteRenderbuffersEXT(int n, ref uint renderbuffers) {
            fixed (uint* pRenderbuffers = &renderbuffers) {
                GLNative.glDeleteRenderbuffersEXT(n, pRenderbuffers);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_framebuffer_object</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGenRenderbuffersEXT(GLsizei n, GLuint * renderbuffers);</para>
        /// </summary>
        public unsafe static void GenRenderbuffersEXT(int n, ref uint renderbuffers) {
            fixed (uint* pRenderbuffers = &renderbuffers) {
                GLNative.glGenRenderbuffersEXT(n, pRenderbuffers);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_framebuffer_object</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetRenderbufferParameterivEXT(GLenum target, GLenum pname, GLint * params);</para>
        /// </summary>
        public unsafe static void GetRenderbufferParameterivEXT(uint target, uint pname, ref int ps) {
            fixed (int* pPs = &ps) {
                GLNative.glGetRenderbufferParameterivEXT(target, pname, pPs);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_framebuffer_object</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glDeleteFramebuffersEXT(GLsizei n, const GLuint * framebuffers);</para>
        /// </summary>
        public unsafe static void DeleteFramebuffersEXT(int n, ref uint framebuffers) {
            fixed (uint* pFramebuffers = &framebuffers) {
                GLNative.glDeleteFramebuffersEXT(n, pFramebuffers);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_framebuffer_object</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGenFramebuffersEXT(GLsizei n, GLuint * framebuffers);</para>
        /// </summary>
        public unsafe static void GenFramebuffersEXT(int n, ref uint framebuffers) {
            fixed (uint* pFramebuffers = &framebuffers) {
                GLNative.glGenFramebuffersEXT(n, pFramebuffers);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_framebuffer_object</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetFramebufferAttachmentParameterivEXT(GLenum target, GLenum attachment, GLenum pname, GLint * params);</para>
        /// </summary>
        public unsafe static void GetFramebufferAttachmentParameterivEXT(uint target, uint attachment, uint pname, ref int ps) {
            fixed (int* pPs = &ps) {
                GLNative.glGetFramebufferAttachmentParameterivEXT(target, attachment, pname, pPs);
            }
        }


        #endregion GL_EXT_framebuffer_object

        #region GL_EXT_geometry_shader4


        #endregion GL_EXT_geometry_shader4

        #region GL_EXT_gpu_program_parameters

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_gpu_program_parameters</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glProgramEnvParameters4fvEXT(GLenum target, GLuint index, GLsizei count, const GLfloat * params);</para>
        /// </summary>
        public unsafe static void ProgramEnvParameters4fvEXT(uint target, uint index, int count, ref float ps) {
            fixed (float* pPs = &ps) {
                GLNative.glProgramEnvParameters4fvEXT(target, index, count, pPs);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_gpu_program_parameters</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glProgramLocalParameters4fvEXT(GLenum target, GLuint index, GLsizei count, const GLfloat * params);</para>
        /// </summary>
        public unsafe static void ProgramLocalParameters4fvEXT(uint target, uint index, int count, ref float ps) {
            fixed (float* pPs = &ps) {
                GLNative.glProgramLocalParameters4fvEXT(target, index, count, pPs);
            }
        }


        #endregion GL_EXT_gpu_program_parameters

        #region GL_EXT_gpu_shader4

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_gpu_shader4</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetUniformuivEXT(GLuint program, GLint location, GLuint * params);</para>
        /// </summary>
        public unsafe static void GetUniformuivEXT(uint program, int location, ref uint ps) {
            fixed (uint* pPs = &ps) {
                GLNative.glGetUniformuivEXT(program, location, pPs);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_blend_func_extended, GL_EXT_gpu_shader4</para>
        /// Supported: <para>gles2, gl</para>
        /// Original: <para>void glBindFragDataLocationEXT(GLuint program, GLuint color, const GLchar * name);</para>
        /// </summary>
        public unsafe static void BindFragDataLocationEXT(uint program, uint color, ref byte name) {
            fixed (byte* pName = &name) {
                GLNative.glBindFragDataLocationEXT(program, color, pName);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_gpu_shader4</para>
        /// Supported: <para>gl</para>
        /// Original: <para>GLint glGetFragDataLocationEXT(GLuint program, const GLchar * name);</para>
        /// </summary>
        public unsafe static int GetFragDataLocationEXT(uint program, ref byte name) {
            fixed (byte* pName = &name) {
                return GLNative.glGetFragDataLocationEXT(program, pName);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_gpu_shader4</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glUniform1uivEXT(GLint location, GLsizei count, const GLuint * value);</para>
        /// </summary>
        public unsafe static void Uniform1uivEXT(int location, int count, ref uint value) {
            fixed (uint* pValue = &value) {
                GLNative.glUniform1uivEXT(location, count, pValue);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_gpu_shader4</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glUniform2uivEXT(GLint location, GLsizei count, const GLuint * value);</para>
        /// </summary>
        public unsafe static void Uniform2uivEXT(int location, int count, ref uint value) {
            fixed (uint* pValue = &value) {
                GLNative.glUniform2uivEXT(location, count, pValue);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_gpu_shader4</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glUniform3uivEXT(GLint location, GLsizei count, const GLuint * value);</para>
        /// </summary>
        public unsafe static void Uniform3uivEXT(int location, int count, ref uint value) {
            fixed (uint* pValue = &value) {
                GLNative.glUniform3uivEXT(location, count, pValue);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_gpu_shader4</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glUniform4uivEXT(GLint location, GLsizei count, const GLuint * value);</para>
        /// </summary>
        public unsafe static void Uniform4uivEXT(int location, int count, ref uint value) {
            fixed (uint* pValue = &value) {
                GLNative.glUniform4uivEXT(location, count, pValue);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_gpu_shader4, GL_NV_vertex_program4</para>
        /// Supported: <para>gl, gl</para>
        /// Original: <para>void glVertexAttribI1ivEXT(GLuint index, const GLint * v);</para>
        /// </summary>
        public unsafe static void VertexAttribI1ivEXT(uint index, ref int v) {
            fixed (int* pV = &v) {
                GLNative.glVertexAttribI1ivEXT(index, pV);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_gpu_shader4, GL_NV_vertex_program4</para>
        /// Supported: <para>gl, gl</para>
        /// Original: <para>void glVertexAttribI2ivEXT(GLuint index, const GLint * v);</para>
        /// </summary>
        public unsafe static void VertexAttribI2ivEXT(uint index, ref int v) {
            fixed (int* pV = &v) {
                GLNative.glVertexAttribI2ivEXT(index, pV);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_gpu_shader4, GL_NV_vertex_program4</para>
        /// Supported: <para>gl, gl</para>
        /// Original: <para>void glVertexAttribI3ivEXT(GLuint index, const GLint * v);</para>
        /// </summary>
        public unsafe static void VertexAttribI3ivEXT(uint index, ref int v) {
            fixed (int* pV = &v) {
                GLNative.glVertexAttribI3ivEXT(index, pV);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_gpu_shader4, GL_NV_vertex_program4</para>
        /// Supported: <para>gl, gl</para>
        /// Original: <para>void glVertexAttribI4ivEXT(GLuint index, const GLint * v);</para>
        /// </summary>
        public unsafe static void VertexAttribI4ivEXT(uint index, ref int v) {
            fixed (int* pV = &v) {
                GLNative.glVertexAttribI4ivEXT(index, pV);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_gpu_shader4, GL_NV_vertex_program4</para>
        /// Supported: <para>gl, gl</para>
        /// Original: <para>void glVertexAttribI1uivEXT(GLuint index, const GLuint * v);</para>
        /// </summary>
        public unsafe static void VertexAttribI1uivEXT(uint index, ref uint v) {
            fixed (uint* pV = &v) {
                GLNative.glVertexAttribI1uivEXT(index, pV);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_gpu_shader4, GL_NV_vertex_program4</para>
        /// Supported: <para>gl, gl</para>
        /// Original: <para>void glVertexAttribI2uivEXT(GLuint index, const GLuint * v);</para>
        /// </summary>
        public unsafe static void VertexAttribI2uivEXT(uint index, ref uint v) {
            fixed (uint* pV = &v) {
                GLNative.glVertexAttribI2uivEXT(index, pV);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_gpu_shader4, GL_NV_vertex_program4</para>
        /// Supported: <para>gl, gl</para>
        /// Original: <para>void glVertexAttribI3uivEXT(GLuint index, const GLuint * v);</para>
        /// </summary>
        public unsafe static void VertexAttribI3uivEXT(uint index, ref uint v) {
            fixed (uint* pV = &v) {
                GLNative.glVertexAttribI3uivEXT(index, pV);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_gpu_shader4, GL_NV_vertex_program4</para>
        /// Supported: <para>gl, gl</para>
        /// Original: <para>void glVertexAttribI4uivEXT(GLuint index, const GLuint * v);</para>
        /// </summary>
        public unsafe static void VertexAttribI4uivEXT(uint index, ref uint v) {
            fixed (uint* pV = &v) {
                GLNative.glVertexAttribI4uivEXT(index, pV);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_gpu_shader4, GL_NV_vertex_program4</para>
        /// Supported: <para>gl, gl</para>
        /// Original: <para>void glVertexAttribI4bvEXT(GLuint index, const GLbyte * v);</para>
        /// </summary>
        public unsafe static void VertexAttribI4bvEXT(uint index, ref byte v) {
            fixed (byte* pV = &v) {
                GLNative.glVertexAttribI4bvEXT(index, pV);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_gpu_shader4, GL_NV_vertex_program4</para>
        /// Supported: <para>gl, gl</para>
        /// Original: <para>void glVertexAttribI4svEXT(GLuint index, const GLshort * v);</para>
        /// </summary>
        public unsafe static void VertexAttribI4svEXT(uint index, ref short v) {
            fixed (short* pV = &v) {
                GLNative.glVertexAttribI4svEXT(index, pV);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_gpu_shader4, GL_NV_vertex_program4</para>
        /// Supported: <para>gl, gl</para>
        /// Original: <para>void glVertexAttribI4ubvEXT(GLuint index, const GLubyte * v);</para>
        /// </summary>
        public unsafe static void VertexAttribI4ubvEXT(uint index, ref byte v) {
            fixed (byte* pV = &v) {
                GLNative.glVertexAttribI4ubvEXT(index, pV);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_gpu_shader4, GL_NV_vertex_program4</para>
        /// Supported: <para>gl, gl</para>
        /// Original: <para>void glVertexAttribI4usvEXT(GLuint index, const GLushort * v);</para>
        /// </summary>
        public unsafe static void VertexAttribI4usvEXT(uint index, ref ushort v) {
            fixed (ushort* pV = &v) {
                GLNative.glVertexAttribI4usvEXT(index, pV);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_gpu_shader4, GL_NV_vertex_program4</para>
        /// Supported: <para>gl, gl</para>
        /// Original: <para>void glVertexAttribIPointerEXT(GLuint index, GLint size, GLenum type, GLsizei stride, const void * pointer);</para>
        /// </summary>
        public unsafe static void VertexAttribIPointerEXT(uint index, int size, uint type, int stride, IntPtr pointer) {
            GLNative.glVertexAttribIPointerEXT(index, size, type, stride, (void*)pointer);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_gpu_shader4, GL_NV_vertex_program4</para>
        /// Supported: <para>gl, gl</para>
        /// Original: <para>void glGetVertexAttribIivEXT(GLuint index, GLenum pname, GLint * params);</para>
        /// </summary>
        public unsafe static void GetVertexAttribIivEXT(uint index, uint pname, ref int ps) {
            fixed (int* pPs = &ps) {
                GLNative.glGetVertexAttribIivEXT(index, pname, pPs);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_gpu_shader4, GL_NV_vertex_program4</para>
        /// Supported: <para>gl, gl</para>
        /// Original: <para>void glGetVertexAttribIuivEXT(GLuint index, GLenum pname, GLuint * params);</para>
        /// </summary>
        public unsafe static void GetVertexAttribIuivEXT(uint index, uint pname, ref uint ps) {
            fixed (uint* pPs = &ps) {
                GLNative.glGetVertexAttribIuivEXT(index, pname, pPs);
            }
        }


        #endregion GL_EXT_gpu_shader4

        #region GL_EXT_histogram

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_histogram</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetHistogramEXT(GLenum target, GLboolean reset, GLenum format, GLenum type, void * values);</para>
        /// </summary>
        public unsafe static void GetHistogramEXT(uint target, bool reset, uint format, uint type, IntPtr values) {
            GLNative.glGetHistogramEXT(target, reset, format, type, (void*)values);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_histogram</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetHistogramParameterfvEXT(GLenum target, GLenum pname, GLfloat * params);</para>
        /// </summary>
        public unsafe static void GetHistogramParameterfvEXT(uint target, uint pname, ref float ps) {
            fixed (float* pPs = &ps) {
                GLNative.glGetHistogramParameterfvEXT(target, pname, pPs);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_histogram</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetHistogramParameterivEXT(GLenum target, GLenum pname, GLint * params);</para>
        /// </summary>
        public unsafe static void GetHistogramParameterivEXT(uint target, uint pname, ref int ps) {
            fixed (int* pPs = &ps) {
                GLNative.glGetHistogramParameterivEXT(target, pname, pPs);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_histogram</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetMinmaxEXT(GLenum target, GLboolean reset, GLenum format, GLenum type, void * values);</para>
        /// </summary>
        public unsafe static void GetMinmaxEXT(uint target, bool reset, uint format, uint type, IntPtr values) {
            GLNative.glGetMinmaxEXT(target, reset, format, type, (void*)values);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_histogram</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetMinmaxParameterfvEXT(GLenum target, GLenum pname, GLfloat * params);</para>
        /// </summary>
        public unsafe static void GetMinmaxParameterfvEXT(uint target, uint pname, ref float ps) {
            fixed (float* pPs = &ps) {
                GLNative.glGetMinmaxParameterfvEXT(target, pname, pPs);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_histogram</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetMinmaxParameterivEXT(GLenum target, GLenum pname, GLint * params);</para>
        /// </summary>
        public unsafe static void GetMinmaxParameterivEXT(uint target, uint pname, ref int ps) {
            fixed (int* pPs = &ps) {
                GLNative.glGetMinmaxParameterivEXT(target, pname, pPs);
            }
        }


        #endregion GL_EXT_histogram

        #region GL_EXT_index_func


        #endregion GL_EXT_index_func

        #region GL_EXT_index_material


        #endregion GL_EXT_index_material

        #region GL_EXT_light_texture


        #endregion GL_EXT_light_texture

        #region GL_EXT_memory_object

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_memory_object, GL_EXT_semaphore</para>
        /// Supported: <para>gl, gles2, gl, gles2</para>
        /// Original: <para>void glGetUnsignedBytevEXT(GLenum pname, GLubyte * data);</para>
        /// </summary>
        public unsafe static void GetUnsignedBytevEXT(uint pname, ref byte data) {
            fixed (byte* pData = &data) {
                GLNative.glGetUnsignedBytevEXT(pname, pData);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_memory_object, GL_EXT_semaphore</para>
        /// Supported: <para>gl, gles2, gl, gles2</para>
        /// Original: <para>void glGetUnsignedBytei_vEXT(GLenum target, GLuint index, GLubyte * data);</para>
        /// </summary>
        public unsafe static void GetUnsignedBytei_vEXT(uint target, uint index, ref byte data) {
            fixed (byte* pData = &data) {
                GLNative.glGetUnsignedBytei_vEXT(target, index, pData);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_memory_object</para>
        /// Supported: <para>gl, gles2</para>
        /// Original: <para>void glDeleteMemoryObjectsEXT(GLsizei n, const GLuint * memoryObjects);</para>
        /// </summary>
        public unsafe static void DeleteMemoryObjectsEXT(int n, ref uint memoryObjects) {
            fixed (uint* pMemoryObjects = &memoryObjects) {
                GLNative.glDeleteMemoryObjectsEXT(n, pMemoryObjects);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_memory_object</para>
        /// Supported: <para>gl, gles2</para>
        /// Original: <para>void glCreateMemoryObjectsEXT(GLsizei n, GLuint * memoryObjects);</para>
        /// </summary>
        public unsafe static void CreateMemoryObjectsEXT(int n, ref uint memoryObjects) {
            fixed (uint* pMemoryObjects = &memoryObjects) {
                GLNative.glCreateMemoryObjectsEXT(n, pMemoryObjects);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_memory_object</para>
        /// Supported: <para>gl, gles2</para>
        /// Original: <para>void glMemoryObjectParameterivEXT(GLuint memoryObject, GLenum pname, const GLint * params);</para>
        /// </summary>
        public unsafe static void MemoryObjectParameterivEXT(uint memoryObject, uint pname, ref int ps) {
            fixed (int* pPs = &ps) {
                GLNative.glMemoryObjectParameterivEXT(memoryObject, pname, pPs);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_memory_object</para>
        /// Supported: <para>gl, gles2</para>
        /// Original: <para>void glGetMemoryObjectParameterivEXT(GLuint memoryObject, GLenum pname, GLint * params);</para>
        /// </summary>
        public unsafe static void GetMemoryObjectParameterivEXT(uint memoryObject, uint pname, ref int ps) {
            fixed (int* pPs = &ps) {
                GLNative.glGetMemoryObjectParameterivEXT(memoryObject, pname, pPs);
            }
        }


        #endregion GL_EXT_memory_object

        #region GL_EXT_memory_object_fd


        #endregion GL_EXT_memory_object_fd

        #region GL_EXT_memory_object_win32

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_memory_object_win32</para>
        /// Supported: <para>gl, gles2</para>
        /// Original: <para>void glImportMemoryWin32HandleEXT(GLuint memory, GLuint64 size, GLenum handleType, void * handle);</para>
        /// </summary>
        public unsafe static void ImportMemoryWin32HandleEXT(uint memory, UInt64 size, uint handleType, IntPtr handle) {
            GLNative.glImportMemoryWin32HandleEXT(memory, size, handleType, (void*)handle);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_memory_object_win32</para>
        /// Supported: <para>gl, gles2</para>
        /// Original: <para>void glImportMemoryWin32NameEXT(GLuint memory, GLuint64 size, GLenum handleType, const void * name);</para>
        /// </summary>
        public unsafe static void ImportMemoryWin32NameEXT(uint memory, UInt64 size, uint handleType, IntPtr name) {
            GLNative.glImportMemoryWin32NameEXT(memory, size, handleType, (void*)name);
        }


        #endregion GL_EXT_memory_object_win32

        #region GL_EXT_multi_draw_arrays

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_multi_draw_arrays</para>
        /// Supported: <para>gl, gles1, gles2</para>
        /// Original: <para>void glMultiDrawArraysEXT(GLenum mode, const GLint * first, const GLsizei * count, GLsizei primcount);</para>
        /// </summary>
        public unsafe static void MultiDrawArraysEXT(uint mode, ref int first, ref int count, int primcount) {
            fixed (int* pFirst = &first)
            fixed (int* pCount = &count) {
                GLNative.glMultiDrawArraysEXT(mode, pFirst, pCount, primcount);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_multi_draw_arrays</para>
        /// Supported: <para>gl, gles1, gles2</para>
        /// Original: <para>void glMultiDrawElementsEXT(GLenum mode, const GLsizei * count, GLenum type, const void *const* indices, GLsizei primcount);</para>
        /// </summary>
        public unsafe static void MultiDrawElementsEXT(uint mode, ref int count, uint type, IntPtr indices, int primcount) {
            fixed (int* pCount = &count) {
                GLNative.glMultiDrawElementsEXT(mode, pCount, type, indices, primcount);
            }
        }


        #endregion GL_EXT_multi_draw_arrays

        #region GL_EXT_multisample


        #endregion GL_EXT_multisample

        #region GL_EXT_paletted_texture

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_paletted_texture</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glColorTableEXT(GLenum target, GLenum internalFormat, GLsizei width, GLenum format, GLenum type, const void * table);</para>
        /// </summary>
        public unsafe static void ColorTableEXT(uint target, uint internalFormat, int width, uint format, uint type, IntPtr table) {
            GLNative.glColorTableEXT(target, internalFormat, width, format, type, (void*)table);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_paletted_texture</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetColorTableEXT(GLenum target, GLenum format, GLenum type, void * data);</para>
        /// </summary>
        public unsafe static void GetColorTableEXT(uint target, uint format, uint type, IntPtr data) {
            GLNative.glGetColorTableEXT(target, format, type, (void*)data);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_paletted_texture</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetColorTableParameterivEXT(GLenum target, GLenum pname, GLint * params);</para>
        /// </summary>
        public unsafe static void GetColorTableParameterivEXT(uint target, uint pname, ref int ps) {
            fixed (int* pPs = &ps) {
                GLNative.glGetColorTableParameterivEXT(target, pname, pPs);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_paletted_texture</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetColorTableParameterfvEXT(GLenum target, GLenum pname, GLfloat * params);</para>
        /// </summary>
        public unsafe static void GetColorTableParameterfvEXT(uint target, uint pname, ref float ps) {
            fixed (float* pPs = &ps) {
                GLNative.glGetColorTableParameterfvEXT(target, pname, pPs);
            }
        }


        #endregion GL_EXT_paletted_texture

        #region GL_EXT_pixel_transform

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_pixel_transform</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glPixelTransformParameterivEXT(GLenum target, GLenum pname, const GLint * params);</para>
        /// </summary>
        public unsafe static void PixelTransformParameterivEXT(uint target, uint pname, ref int ps) {
            fixed (int* pPs = &ps) {
                GLNative.glPixelTransformParameterivEXT(target, pname, pPs);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_pixel_transform</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glPixelTransformParameterfvEXT(GLenum target, GLenum pname, const GLfloat * params);</para>
        /// </summary>
        public unsafe static void PixelTransformParameterfvEXT(uint target, uint pname, ref float ps) {
            fixed (float* pPs = &ps) {
                GLNative.glPixelTransformParameterfvEXT(target, pname, pPs);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_pixel_transform</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetPixelTransformParameterivEXT(GLenum target, GLenum pname, GLint * params);</para>
        /// </summary>
        public unsafe static void GetPixelTransformParameterivEXT(uint target, uint pname, ref int ps) {
            fixed (int* pPs = &ps) {
                GLNative.glGetPixelTransformParameterivEXT(target, pname, pPs);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_pixel_transform</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetPixelTransformParameterfvEXT(GLenum target, GLenum pname, GLfloat * params);</para>
        /// </summary>
        public unsafe static void GetPixelTransformParameterfvEXT(uint target, uint pname, ref float ps) {
            fixed (float* pPs = &ps) {
                GLNative.glGetPixelTransformParameterfvEXT(target, pname, pPs);
            }
        }


        #endregion GL_EXT_pixel_transform

        #region GL_EXT_point_parameters

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_point_parameters</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glPointParameterfvEXT(GLenum pname, const GLfloat * params);</para>
        /// </summary>
        public unsafe static void PointParameterfvEXT(uint pname, ref float ps) {
            fixed (float* pPs = &ps) {
                GLNative.glPointParameterfvEXT(pname, pPs);
            }
        }


        #endregion GL_EXT_point_parameters

        #region GL_EXT_polygon_offset


        #endregion GL_EXT_polygon_offset

        #region GL_EXT_polygon_offset_clamp


        #endregion GL_EXT_polygon_offset_clamp

        #region GL_EXT_provoking_vertex


        #endregion GL_EXT_provoking_vertex

        #region GL_EXT_raster_multisample


        #endregion GL_EXT_raster_multisample

        #region GL_EXT_semaphore

        // void glGetUnsignedBytevEXT(GLenum pname, GLubyte * data);
        // void glGetUnsignedBytei_vEXT(GLenum target, GLuint index, GLubyte * data);
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_semaphore</para>
        /// Supported: <para>gl, gles2</para>
        /// Original: <para>void glGenSemaphoresEXT(GLsizei n, GLuint * semaphores);</para>
        /// </summary>
        public unsafe static void GenSemaphoresEXT(int n, ref uint semaphores) {
            fixed (uint* pSemaphores = &semaphores) {
                GLNative.glGenSemaphoresEXT(n, pSemaphores);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_semaphore</para>
        /// Supported: <para>gl, gles2</para>
        /// Original: <para>void glDeleteSemaphoresEXT(GLsizei n, const GLuint * semaphores);</para>
        /// </summary>
        public unsafe static void DeleteSemaphoresEXT(int n, ref uint semaphores) {
            fixed (uint* pSemaphores = &semaphores) {
                GLNative.glDeleteSemaphoresEXT(n, pSemaphores);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_semaphore</para>
        /// Supported: <para>gl, gles2</para>
        /// Original: <para>void glSemaphoreParameterui64vEXT(GLuint semaphore, GLenum pname, const GLuint64 * params);</para>
        /// </summary>
        public unsafe static void SemaphoreParameterui64vEXT(uint semaphore, uint pname, ref UInt64 ps) {
            fixed (UInt64* pPs = &ps) {
                GLNative.glSemaphoreParameterui64vEXT(semaphore, pname, pPs);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_semaphore</para>
        /// Supported: <para>gl, gles2</para>
        /// Original: <para>void glGetSemaphoreParameterui64vEXT(GLuint semaphore, GLenum pname, GLuint64 * params);</para>
        /// </summary>
        public unsafe static void GetSemaphoreParameterui64vEXT(uint semaphore, uint pname, ref UInt64 ps) {
            fixed (UInt64* pPs = &ps) {
                GLNative.glGetSemaphoreParameterui64vEXT(semaphore, pname, pPs);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_semaphore</para>
        /// Supported: <para>gl, gles2</para>
        /// Original: <para>void glWaitSemaphoreEXT(GLuint semaphore, GLuint numBufferBarriers, const GLuint * buffers, GLuint numTextureBarriers, const GLuint * textures, const GLenum * srcLayouts);</para>
        /// </summary>
        public unsafe static void WaitSemaphoreEXT(uint semaphore, uint numBufferBarriers, ref uint buffers, uint numTextureBarriers, ref uint textures, ref uint srcLayouts) {
            fixed (uint* pBuffers = &buffers)
            fixed (uint* pTextures = &textures)
            fixed (uint* pSrcLayouts = &srcLayouts) {
                GLNative.glWaitSemaphoreEXT(semaphore, numBufferBarriers, pBuffers, numTextureBarriers, pTextures, pSrcLayouts);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_semaphore</para>
        /// Supported: <para>gl, gles2</para>
        /// Original: <para>void glSignalSemaphoreEXT(GLuint semaphore, GLuint numBufferBarriers, const GLuint * buffers, GLuint numTextureBarriers, const GLuint * textures, const GLenum * dstLayouts);</para>
        /// </summary>
        public unsafe static void SignalSemaphoreEXT(uint semaphore, uint numBufferBarriers, ref uint buffers, uint numTextureBarriers, ref uint textures, ref uint dstLayouts) {
            fixed (uint* pBuffers = &buffers)
            fixed (uint* pTextures = &textures)
            fixed (uint* pDstLayouts = &dstLayouts) {
                GLNative.glSignalSemaphoreEXT(semaphore, numBufferBarriers, pBuffers, numTextureBarriers, pTextures, pDstLayouts);
            }
        }


        #endregion GL_EXT_semaphore

        #region GL_EXT_semaphore_fd


        #endregion GL_EXT_semaphore_fd

        #region GL_EXT_semaphore_win32

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_semaphore_win32</para>
        /// Supported: <para>gl, gles2</para>
        /// Original: <para>void glImportSemaphoreWin32HandleEXT(GLuint semaphore, GLenum handleType, void * handle);</para>
        /// </summary>
        public unsafe static void ImportSemaphoreWin32HandleEXT(uint semaphore, uint handleType, IntPtr handle) {
            GLNative.glImportSemaphoreWin32HandleEXT(semaphore, handleType, (void*)handle);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_semaphore_win32</para>
        /// Supported: <para>gl, gles2</para>
        /// Original: <para>void glImportSemaphoreWin32NameEXT(GLuint semaphore, GLenum handleType, const void * name);</para>
        /// </summary>
        public unsafe static void ImportSemaphoreWin32NameEXT(uint semaphore, uint handleType, IntPtr name) {
            GLNative.glImportSemaphoreWin32NameEXT(semaphore, handleType, (void*)name);
        }


        #endregion GL_EXT_semaphore_win32

        #region GL_EXT_secondary_color

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_secondary_color</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glSecondaryColor3bvEXT(const GLbyte * v);</para>
        /// </summary>
        public unsafe static void SecondaryColor3bvEXT(ref byte v) {
            fixed (byte* pV = &v) {
                GLNative.glSecondaryColor3bvEXT(pV);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_secondary_color</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glSecondaryColor3dvEXT(const GLdouble * v);</para>
        /// </summary>
        public unsafe static void SecondaryColor3dvEXT(ref double v) {
            fixed (double* pV = &v) {
                GLNative.glSecondaryColor3dvEXT(pV);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_secondary_color</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glSecondaryColor3fvEXT(const GLfloat * v);</para>
        /// </summary>
        public unsafe static void SecondaryColor3fvEXT(ref float v) {
            fixed (float* pV = &v) {
                GLNative.glSecondaryColor3fvEXT(pV);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_secondary_color</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glSecondaryColor3ivEXT(const GLint * v);</para>
        /// </summary>
        public unsafe static void SecondaryColor3ivEXT(ref int v) {
            fixed (int* pV = &v) {
                GLNative.glSecondaryColor3ivEXT(pV);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_secondary_color</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glSecondaryColor3svEXT(const GLshort * v);</para>
        /// </summary>
        public unsafe static void SecondaryColor3svEXT(ref short v) {
            fixed (short* pV = &v) {
                GLNative.glSecondaryColor3svEXT(pV);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_secondary_color</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glSecondaryColor3ubvEXT(const GLubyte * v);</para>
        /// </summary>
        public unsafe static void SecondaryColor3ubvEXT(ref byte v) {
            fixed (byte* pV = &v) {
                GLNative.glSecondaryColor3ubvEXT(pV);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_secondary_color</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glSecondaryColor3uivEXT(const GLuint * v);</para>
        /// </summary>
        public unsafe static void SecondaryColor3uivEXT(ref uint v) {
            fixed (uint* pV = &v) {
                GLNative.glSecondaryColor3uivEXT(pV);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_secondary_color</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glSecondaryColor3usvEXT(const GLushort * v);</para>
        /// </summary>
        public unsafe static void SecondaryColor3usvEXT(ref ushort v) {
            fixed (ushort* pV = &v) {
                GLNative.glSecondaryColor3usvEXT(pV);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_secondary_color</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glSecondaryColorPointerEXT(GLint size, GLenum type, GLsizei stride, const void * pointer);</para>
        /// </summary>
        public unsafe static void SecondaryColorPointerEXT(int size, uint type, int stride, IntPtr pointer) {
            GLNative.glSecondaryColorPointerEXT(size, type, stride, (void*)pointer);
        }


        #endregion GL_EXT_secondary_color

        #region GL_EXT_separate_shader_objects

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_separate_shader_objects</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>GLuint glCreateShaderProgramEXT(GLenum type, const GLchar * string);</para>
        /// </summary>
        public unsafe static uint CreateShaderProgramEXT(uint type, ref byte str) {
            fixed (byte* pStr = &str) {
                return GLNative.glCreateShaderProgramEXT(type, pStr);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_separate_shader_objects</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>GLuint glCreateShaderProgramvEXT(GLenum type, GLsizei count, const GLchar ** strings);</para>
        /// </summary>
        public unsafe static uint CreateShaderProgramvEXT(uint type, int count, IntPtr strings) {
            return GLNative.glCreateShaderProgramvEXT(type, count, (byte**)strings);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_separate_shader_objects</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glDeleteProgramPipelinesEXT(GLsizei n, const GLuint * pipelines);</para>
        /// </summary>
        public unsafe static void DeleteProgramPipelinesEXT(int n, ref uint pipelines) {
            fixed (uint* pPipelines = &pipelines) {
                GLNative.glDeleteProgramPipelinesEXT(n, pPipelines);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_separate_shader_objects</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glGenProgramPipelinesEXT(GLsizei n, GLuint * pipelines);</para>
        /// </summary>
        public unsafe static void GenProgramPipelinesEXT(int n, ref uint pipelines) {
            fixed (uint* pPipelines = &pipelines) {
                GLNative.glGenProgramPipelinesEXT(n, pPipelines);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_separate_shader_objects</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glGetProgramPipelineInfoLogEXT(GLuint pipeline, GLsizei bufSize, GLsizei * length, GLchar * infoLog);</para>
        /// </summary>
        public unsafe static void GetProgramPipelineInfoLogEXT(uint pipeline, int bufSize, ref int length, ref byte infoLog) {
            fixed (int* pLength = &length)
            fixed (byte* pInfoLog = &infoLog) {
                GLNative.glGetProgramPipelineInfoLogEXT(pipeline, bufSize, pLength, pInfoLog);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_separate_shader_objects</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glGetProgramPipelineivEXT(GLuint pipeline, GLenum pname, GLint * params);</para>
        /// </summary>
        public unsafe static void GetProgramPipelineivEXT(uint pipeline, uint pname, ref int ps) {
            fixed (int* pPs = &ps) {
                GLNative.glGetProgramPipelineivEXT(pipeline, pname, pPs);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_direct_state_access, GL_EXT_separate_shader_objects</para>
        /// Supported: <para>gl, glcore, gl, glcore, gles2</para>
        /// Original: <para>void glProgramUniform1fvEXT(GLuint program, GLint location, GLsizei count, const GLfloat * value);</para>
        /// </summary>
        public unsafe static void ProgramUniform1fvEXT(uint program, int location, int count, ref float value) {
            fixed (float* pValue = &value) {
                GLNative.glProgramUniform1fvEXT(program, location, count, pValue);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_direct_state_access, GL_EXT_separate_shader_objects</para>
        /// Supported: <para>gl, glcore, gl, glcore, gles2</para>
        /// Original: <para>void glProgramUniform1ivEXT(GLuint program, GLint location, GLsizei count, const GLint * value);</para>
        /// </summary>
        public unsafe static void ProgramUniform1ivEXT(uint program, int location, int count, ref int value) {
            fixed (int* pValue = &value) {
                GLNative.glProgramUniform1ivEXT(program, location, count, pValue);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_direct_state_access, GL_EXT_separate_shader_objects</para>
        /// Supported: <para>gl, glcore, gl, glcore, gles2</para>
        /// Original: <para>void glProgramUniform2fvEXT(GLuint program, GLint location, GLsizei count, const GLfloat * value);</para>
        /// </summary>
        public unsafe static void ProgramUniform2fvEXT(uint program, int location, int count, ref float value) {
            fixed (float* pValue = &value) {
                GLNative.glProgramUniform2fvEXT(program, location, count, pValue);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_direct_state_access, GL_EXT_separate_shader_objects</para>
        /// Supported: <para>gl, glcore, gl, glcore, gles2</para>
        /// Original: <para>void glProgramUniform2ivEXT(GLuint program, GLint location, GLsizei count, const GLint * value);</para>
        /// </summary>
        public unsafe static void ProgramUniform2ivEXT(uint program, int location, int count, ref int value) {
            fixed (int* pValue = &value) {
                GLNative.glProgramUniform2ivEXT(program, location, count, pValue);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_direct_state_access, GL_EXT_separate_shader_objects</para>
        /// Supported: <para>gl, glcore, gl, glcore, gles2</para>
        /// Original: <para>void glProgramUniform3fvEXT(GLuint program, GLint location, GLsizei count, const GLfloat * value);</para>
        /// </summary>
        public unsafe static void ProgramUniform3fvEXT(uint program, int location, int count, ref float value) {
            fixed (float* pValue = &value) {
                GLNative.glProgramUniform3fvEXT(program, location, count, pValue);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_direct_state_access, GL_EXT_separate_shader_objects</para>
        /// Supported: <para>gl, glcore, gl, glcore, gles2</para>
        /// Original: <para>void glProgramUniform3ivEXT(GLuint program, GLint location, GLsizei count, const GLint * value);</para>
        /// </summary>
        public unsafe static void ProgramUniform3ivEXT(uint program, int location, int count, ref int value) {
            fixed (int* pValue = &value) {
                GLNative.glProgramUniform3ivEXT(program, location, count, pValue);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_direct_state_access, GL_EXT_separate_shader_objects</para>
        /// Supported: <para>gl, glcore, gl, glcore, gles2</para>
        /// Original: <para>void glProgramUniform4fvEXT(GLuint program, GLint location, GLsizei count, const GLfloat * value);</para>
        /// </summary>
        public unsafe static void ProgramUniform4fvEXT(uint program, int location, int count, ref float value) {
            fixed (float* pValue = &value) {
                GLNative.glProgramUniform4fvEXT(program, location, count, pValue);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_direct_state_access, GL_EXT_separate_shader_objects</para>
        /// Supported: <para>gl, glcore, gl, glcore, gles2</para>
        /// Original: <para>void glProgramUniform4ivEXT(GLuint program, GLint location, GLsizei count, const GLint * value);</para>
        /// </summary>
        public unsafe static void ProgramUniform4ivEXT(uint program, int location, int count, ref int value) {
            fixed (int* pValue = &value) {
                GLNative.glProgramUniform4ivEXT(program, location, count, pValue);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_direct_state_access, GL_EXT_separate_shader_objects</para>
        /// Supported: <para>gl, glcore, gl, glcore, gles2</para>
        /// Original: <para>void glProgramUniformMatrix2fvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);</para>
        /// </summary>
        public unsafe static void ProgramUniformMatrix2fvEXT(uint program, int location, int count, bool transpose, ref float value) {
            fixed (float* pValue = &value) {
                GLNative.glProgramUniformMatrix2fvEXT(program, location, count, transpose, pValue);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_direct_state_access, GL_EXT_separate_shader_objects</para>
        /// Supported: <para>gl, glcore, gl, glcore, gles2</para>
        /// Original: <para>void glProgramUniformMatrix3fvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);</para>
        /// </summary>
        public unsafe static void ProgramUniformMatrix3fvEXT(uint program, int location, int count, bool transpose, ref float value) {
            fixed (float* pValue = &value) {
                GLNative.glProgramUniformMatrix3fvEXT(program, location, count, transpose, pValue);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_direct_state_access, GL_EXT_separate_shader_objects</para>
        /// Supported: <para>gl, glcore, gl, glcore, gles2</para>
        /// Original: <para>void glProgramUniformMatrix4fvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);</para>
        /// </summary>
        public unsafe static void ProgramUniformMatrix4fvEXT(uint program, int location, int count, bool transpose, ref float value) {
            fixed (float* pValue = &value) {
                GLNative.glProgramUniformMatrix4fvEXT(program, location, count, transpose, pValue);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_direct_state_access, GL_EXT_separate_shader_objects</para>
        /// Supported: <para>gl, glcore, gl, glcore, gles2</para>
        /// Original: <para>void glProgramUniform1uivEXT(GLuint program, GLint location, GLsizei count, const GLuint * value);</para>
        /// </summary>
        public unsafe static void ProgramUniform1uivEXT(uint program, int location, int count, ref uint value) {
            fixed (uint* pValue = &value) {
                GLNative.glProgramUniform1uivEXT(program, location, count, pValue);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_direct_state_access, GL_EXT_separate_shader_objects</para>
        /// Supported: <para>gl, glcore, gl, glcore, gles2</para>
        /// Original: <para>void glProgramUniform2uivEXT(GLuint program, GLint location, GLsizei count, const GLuint * value);</para>
        /// </summary>
        public unsafe static void ProgramUniform2uivEXT(uint program, int location, int count, ref uint value) {
            fixed (uint* pValue = &value) {
                GLNative.glProgramUniform2uivEXT(program, location, count, pValue);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_direct_state_access, GL_EXT_separate_shader_objects</para>
        /// Supported: <para>gl, glcore, gl, glcore, gles2</para>
        /// Original: <para>void glProgramUniform3uivEXT(GLuint program, GLint location, GLsizei count, const GLuint * value);</para>
        /// </summary>
        public unsafe static void ProgramUniform3uivEXT(uint program, int location, int count, ref uint value) {
            fixed (uint* pValue = &value) {
                GLNative.glProgramUniform3uivEXT(program, location, count, pValue);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_direct_state_access, GL_EXT_separate_shader_objects</para>
        /// Supported: <para>gl, glcore, gl, glcore, gles2</para>
        /// Original: <para>void glProgramUniform4uivEXT(GLuint program, GLint location, GLsizei count, const GLuint * value);</para>
        /// </summary>
        public unsafe static void ProgramUniform4uivEXT(uint program, int location, int count, ref uint value) {
            fixed (uint* pValue = &value) {
                GLNative.glProgramUniform4uivEXT(program, location, count, pValue);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_direct_state_access, GL_EXT_separate_shader_objects</para>
        /// Supported: <para>gl, glcore, gl, glcore, gles2</para>
        /// Original: <para>void glProgramUniformMatrix2x3fvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);</para>
        /// </summary>
        public unsafe static void ProgramUniformMatrix2x3fvEXT(uint program, int location, int count, bool transpose, ref float value) {
            fixed (float* pValue = &value) {
                GLNative.glProgramUniformMatrix2x3fvEXT(program, location, count, transpose, pValue);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_direct_state_access, GL_EXT_separate_shader_objects</para>
        /// Supported: <para>gl, glcore, gl, glcore, gles2</para>
        /// Original: <para>void glProgramUniformMatrix3x2fvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);</para>
        /// </summary>
        public unsafe static void ProgramUniformMatrix3x2fvEXT(uint program, int location, int count, bool transpose, ref float value) {
            fixed (float* pValue = &value) {
                GLNative.glProgramUniformMatrix3x2fvEXT(program, location, count, transpose, pValue);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_direct_state_access, GL_EXT_separate_shader_objects</para>
        /// Supported: <para>gl, glcore, gl, glcore, gles2</para>
        /// Original: <para>void glProgramUniformMatrix2x4fvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);</para>
        /// </summary>
        public unsafe static void ProgramUniformMatrix2x4fvEXT(uint program, int location, int count, bool transpose, ref float value) {
            fixed (float* pValue = &value) {
                GLNative.glProgramUniformMatrix2x4fvEXT(program, location, count, transpose, pValue);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_direct_state_access, GL_EXT_separate_shader_objects</para>
        /// Supported: <para>gl, glcore, gl, glcore, gles2</para>
        /// Original: <para>void glProgramUniformMatrix4x2fvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);</para>
        /// </summary>
        public unsafe static void ProgramUniformMatrix4x2fvEXT(uint program, int location, int count, bool transpose, ref float value) {
            fixed (float* pValue = &value) {
                GLNative.glProgramUniformMatrix4x2fvEXT(program, location, count, transpose, pValue);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_direct_state_access, GL_EXT_separate_shader_objects</para>
        /// Supported: <para>gl, glcore, gl, glcore, gles2</para>
        /// Original: <para>void glProgramUniformMatrix3x4fvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);</para>
        /// </summary>
        public unsafe static void ProgramUniformMatrix3x4fvEXT(uint program, int location, int count, bool transpose, ref float value) {
            fixed (float* pValue = &value) {
                GLNative.glProgramUniformMatrix3x4fvEXT(program, location, count, transpose, pValue);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_direct_state_access, GL_EXT_separate_shader_objects</para>
        /// Supported: <para>gl, glcore, gl, glcore, gles2</para>
        /// Original: <para>void glProgramUniformMatrix4x3fvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);</para>
        /// </summary>
        public unsafe static void ProgramUniformMatrix4x3fvEXT(uint program, int location, int count, bool transpose, ref float value) {
            fixed (float* pValue = &value) {
                GLNative.glProgramUniformMatrix4x3fvEXT(program, location, count, transpose, pValue);
            }
        }


        #endregion GL_EXT_separate_shader_objects

        #region GL_EXT_shader_framebuffer_fetch_non_coherent


        #endregion GL_EXT_shader_framebuffer_fetch_non_coherent

        #region GL_EXT_shader_image_load_store


        #endregion GL_EXT_shader_image_load_store

        #region GL_EXT_stencil_clear_tag


        #endregion GL_EXT_stencil_clear_tag

        #region GL_EXT_stencil_two_side


        #endregion GL_EXT_stencil_two_side

        #region GL_EXT_subtexture

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_subtexture</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glTexSubImage1DEXT(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const void * pixels);</para>
        /// </summary>
        public unsafe static void TexSubImage1DEXT(uint target, int level, int xoffset, int width, uint format, uint type, IntPtr pixels) {
            GLNative.glTexSubImage1DEXT(target, level, xoffset, width, format, type, (void*)pixels);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_subtexture</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glTexSubImage2DEXT(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const void * pixels);</para>
        /// </summary>
        public unsafe static void TexSubImage2DEXT(uint target, int level, int xoffset, int yoffset, int width, int height, uint format, uint type, IntPtr pixels) {
            GLNative.glTexSubImage2DEXT(target, level, xoffset, yoffset, width, height, format, type, (void*)pixels);
        }


        #endregion GL_EXT_subtexture

        #region GL_EXT_texture3D

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_texture3D</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glTexImage3DEXT(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const void * pixels);</para>
        /// </summary>
        public unsafe static void TexImage3DEXT(uint target, int level, uint internalformat, int width, int height, int depth, int border, uint format, uint type, IntPtr pixels) {
            GLNative.glTexImage3DEXT(target, level, internalformat, width, height, depth, border, format, type, (void*)pixels);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_texture3D</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glTexSubImage3DEXT(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void * pixels);</para>
        /// </summary>
        public unsafe static void TexSubImage3DEXT(uint target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, uint format, uint type, IntPtr pixels) {
            GLNative.glTexSubImage3DEXT(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, (void*)pixels);
        }


        #endregion GL_EXT_texture3D

        #region GL_EXT_texture_array


        #endregion GL_EXT_texture_array

        #region GL_EXT_texture_buffer_object


        #endregion GL_EXT_texture_buffer_object

        #region GL_EXT_texture_integer

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_texture_border_clamp, GL_EXT_texture_integer</para>
        /// Supported: <para>gles2, gl</para>
        /// Original: <para>void glTexParameterIivEXT(GLenum target, GLenum pname, const GLint * params);</para>
        /// </summary>
        public unsafe static void TexParameterIivEXT(uint target, uint pname, ref int ps) {
            fixed (int* pPs = &ps) {
                GLNative.glTexParameterIivEXT(target, pname, pPs);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_texture_border_clamp, GL_EXT_texture_integer</para>
        /// Supported: <para>gles2, gl</para>
        /// Original: <para>void glTexParameterIuivEXT(GLenum target, GLenum pname, const GLuint * params);</para>
        /// </summary>
        public unsafe static void TexParameterIuivEXT(uint target, uint pname, ref uint ps) {
            fixed (uint* pPs = &ps) {
                GLNative.glTexParameterIuivEXT(target, pname, pPs);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_texture_border_clamp, GL_EXT_texture_integer</para>
        /// Supported: <para>gles2, gl</para>
        /// Original: <para>void glGetTexParameterIivEXT(GLenum target, GLenum pname, GLint * params);</para>
        /// </summary>
        public unsafe static void GetTexParameterIivEXT(uint target, uint pname, ref int ps) {
            fixed (int* pPs = &ps) {
                GLNative.glGetTexParameterIivEXT(target, pname, pPs);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_texture_border_clamp, GL_EXT_texture_integer</para>
        /// Supported: <para>gles2, gl</para>
        /// Original: <para>void glGetTexParameterIuivEXT(GLenum target, GLenum pname, GLuint * params);</para>
        /// </summary>
        public unsafe static void GetTexParameterIuivEXT(uint target, uint pname, ref uint ps) {
            fixed (uint* pPs = &ps) {
                GLNative.glGetTexParameterIuivEXT(target, pname, pPs);
            }
        }


        #endregion GL_EXT_texture_integer

        #region GL_EXT_texture_object

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_texture_object</para>
        /// Supported: <para>gl</para>
        /// Original: <para>GLboolean glAreTexturesResidentEXT(GLsizei n, const GLuint * textures, GLboolean * residences);</para>
        /// </summary>
        public unsafe static bool AreTexturesResidentEXT(int n, ref uint textures, ref bool residences) {
            fixed (uint* pTextures = &textures)
            fixed (bool* pResidences = &residences) {
                return GLNative.glAreTexturesResidentEXT(n, pTextures, pResidences);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_texture_object</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glDeleteTexturesEXT(GLsizei n, const GLuint * textures);</para>
        /// </summary>
        public unsafe static void DeleteTexturesEXT(int n, ref uint textures) {
            fixed (uint* pTextures = &textures) {
                GLNative.glDeleteTexturesEXT(n, pTextures);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_texture_object</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGenTexturesEXT(GLsizei n, GLuint * textures);</para>
        /// </summary>
        public unsafe static void GenTexturesEXT(int n, ref uint textures) {
            fixed (uint* pTextures = &textures) {
                GLNative.glGenTexturesEXT(n, pTextures);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_texture_object</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glPrioritizeTexturesEXT(GLsizei n, const GLuint * textures, const GLclampf * priorities);</para>
        /// </summary>
        public unsafe static void PrioritizeTexturesEXT(int n, ref uint textures, ref float priorities) {
            fixed (uint* pTextures = &textures)
            fixed (float* pPriorities = &priorities) {
                GLNative.glPrioritizeTexturesEXT(n, pTextures, pPriorities);
            }
        }


        #endregion GL_EXT_texture_object

        #region GL_EXT_texture_perturb_normal


        #endregion GL_EXT_texture_perturb_normal

        #region GL_EXT_texture_storage


        #endregion GL_EXT_texture_storage

        #region GL_NV_timeline_semaphore

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_timeline_semaphore</para>
        /// Supported: <para>gl, gles2</para>
        /// Original: <para>void glCreateSemaphoresNV(GLsizei n, GLuint * semaphores);</para>
        /// </summary>
        public unsafe static void CreateSemaphoresNV(int n, ref uint semaphores) {
            fixed (uint* pSemaphores = &semaphores) {
                GLNative.glCreateSemaphoresNV(n, pSemaphores);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_timeline_semaphore</para>
        /// Supported: <para>gl, gles2</para>
        /// Original: <para>void glSemaphoreParameterivNV(GLuint semaphore, GLenum pname, const GLint * params);</para>
        /// </summary>
        public unsafe static void SemaphoreParameterivNV(uint semaphore, uint pname, ref int ps) {
            fixed (int* pPs = &ps) {
                GLNative.glSemaphoreParameterivNV(semaphore, pname, pPs);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_timeline_semaphore</para>
        /// Supported: <para>gl, gles2</para>
        /// Original: <para>void glGetSemaphoreParameterivNV(GLuint semaphore, GLenum pname, GLint * params);</para>
        /// </summary>
        public unsafe static void GetSemaphoreParameterivNV(uint semaphore, uint pname, ref int ps) {
            fixed (int* pPs = &ps) {
                GLNative.glGetSemaphoreParameterivNV(semaphore, pname, pPs);
            }
        }


        #endregion GL_NV_timeline_semaphore

        #region GL_EXT_timer_query

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_disjoint_timer_query, GL_EXT_timer_query</para>
        /// Supported: <para>gles2, gl</para>
        /// Original: <para>void glGetQueryObjecti64vEXT(GLuint id, GLenum pname, GLint64 * params);</para>
        /// </summary>
        public unsafe static void GetQueryObjecti64vEXT(uint id, uint pname, ref UInt64 ps) {
            fixed (UInt64* pPs = &ps) {
                GLNative.glGetQueryObjecti64vEXT(id, pname, pPs);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_disjoint_timer_query, GL_EXT_timer_query</para>
        /// Supported: <para>gles2, gl</para>
        /// Original: <para>void glGetQueryObjectui64vEXT(GLuint id, GLenum pname, GLuint64 * params);</para>
        /// </summary>
        public unsafe static void GetQueryObjectui64vEXT(uint id, uint pname, ref UInt64 ps) {
            fixed (UInt64* pPs = &ps) {
                GLNative.glGetQueryObjectui64vEXT(id, pname, pPs);
            }
        }


        #endregion GL_EXT_timer_query

        #region GL_EXT_transform_feedback

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_transform_feedback</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glTransformFeedbackVaryingsEXT(GLuint program, GLsizei count, const GLchar *const* varyings, GLenum bufferMode);</para>
        /// </summary>
        public unsafe static void TransformFeedbackVaryingsEXT(uint program, int count, IntPtr varyings, uint bufferMode) {
            GLNative.glTransformFeedbackVaryingsEXT(program, count, (byte**)varyings, bufferMode);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_transform_feedback</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetTransformFeedbackVaryingEXT(GLuint program, GLuint index, GLsizei bufSize, GLsizei * length, GLsizei * size, GLenum * type, GLchar * name);</para>
        /// </summary>
        public unsafe static void GetTransformFeedbackVaryingEXT(uint program, uint index, int bufSize, ref int length, ref int size, ref uint type, ref byte name) {
            fixed (int* pLength = &length)
            fixed (int* pSize = &size)
            fixed (uint* pType = &type)
            fixed (byte* pName = &name) {
                GLNative.glGetTransformFeedbackVaryingEXT(program, index, bufSize, pLength, pSize, pType, pName);
            }
        }


        #endregion GL_EXT_transform_feedback

        #region GL_EXT_vertex_array

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_vertex_array</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glColorPointerEXT(GLint size, GLenum type, GLsizei stride, GLsizei count, const void * pointer);</para>
        /// </summary>
        public unsafe static void ColorPointerEXT(int size, uint type, int stride, int count, IntPtr pointer) {
            GLNative.glColorPointerEXT(size, type, stride, count, (void*)pointer);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_vertex_array</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glEdgeFlagPointerEXT(GLsizei stride, GLsizei count, const GLboolean * pointer);</para>
        /// </summary>
        public unsafe static void EdgeFlagPointerEXT(int stride, int count, ref bool pointer) {
            fixed (bool* pPointer = &pointer) {
                GLNative.glEdgeFlagPointerEXT(stride, count, pPointer);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_vertex_array</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetPointervEXT(GLenum pname, void ** params);</para>
        /// </summary>
        public unsafe static void GetPointervEXT(uint pname, IntPtr ps) {
            GLNative.glGetPointervEXT(pname, (void**)ps);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_vertex_array</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glIndexPointerEXT(GLenum type, GLsizei stride, GLsizei count, const void * pointer);</para>
        /// </summary>
        public unsafe static void IndexPointerEXT(uint type, int stride, int count, IntPtr pointer) {
            GLNative.glIndexPointerEXT(type, stride, count, (void*)pointer);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_vertex_array</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glNormalPointerEXT(GLenum type, GLsizei stride, GLsizei count, const void * pointer);</para>
        /// </summary>
        public unsafe static void NormalPointerEXT(uint type, int stride, int count, IntPtr pointer) {
            GLNative.glNormalPointerEXT(type, stride, count, (void*)pointer);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_vertex_array</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glTexCoordPointerEXT(GLint size, GLenum type, GLsizei stride, GLsizei count, const void * pointer);</para>
        /// </summary>
        public unsafe static void TexCoordPointerEXT(int size, uint type, int stride, int count, IntPtr pointer) {
            GLNative.glTexCoordPointerEXT(size, type, stride, count, (void*)pointer);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_vertex_array</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexPointerEXT(GLint size, GLenum type, GLsizei stride, GLsizei count, const void * pointer);</para>
        /// </summary>
        public unsafe static void VertexPointerEXT(int size, uint type, int stride, int count, IntPtr pointer) {
            GLNative.glVertexPointerEXT(size, type, stride, count, (void*)pointer);
        }


        #endregion GL_EXT_vertex_array

        #region GL_EXT_vertex_attrib_64bit

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_vertex_attrib_64bit</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexAttribL1dvEXT(GLuint index, const GLdouble * v);</para>
        /// </summary>
        public unsafe static void VertexAttribL1dvEXT(uint index, ref double v) {
            fixed (double* pV = &v) {
                GLNative.glVertexAttribL1dvEXT(index, pV);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_vertex_attrib_64bit</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexAttribL2dvEXT(GLuint index, const GLdouble * v);</para>
        /// </summary>
        public unsafe static void VertexAttribL2dvEXT(uint index, ref double v) {
            fixed (double* pV = &v) {
                GLNative.glVertexAttribL2dvEXT(index, pV);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_vertex_attrib_64bit</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexAttribL3dvEXT(GLuint index, const GLdouble * v);</para>
        /// </summary>
        public unsafe static void VertexAttribL3dvEXT(uint index, ref double v) {
            fixed (double* pV = &v) {
                GLNative.glVertexAttribL3dvEXT(index, pV);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_vertex_attrib_64bit</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexAttribL4dvEXT(GLuint index, const GLdouble * v);</para>
        /// </summary>
        public unsafe static void VertexAttribL4dvEXT(uint index, ref double v) {
            fixed (double* pV = &v) {
                GLNative.glVertexAttribL4dvEXT(index, pV);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_vertex_attrib_64bit</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexAttribLPointerEXT(GLuint index, GLint size, GLenum type, GLsizei stride, const void * pointer);</para>
        /// </summary>
        public unsafe static void VertexAttribLPointerEXT(uint index, int size, uint type, int stride, IntPtr pointer) {
            GLNative.glVertexAttribLPointerEXT(index, size, type, stride, (void*)pointer);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_vertex_attrib_64bit</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetVertexAttribLdvEXT(GLuint index, GLenum pname, GLdouble * params);</para>
        /// </summary>
        public unsafe static void GetVertexAttribLdvEXT(uint index, uint pname, ref double ps) {
            fixed (double* pPs = &ps) {
                GLNative.glGetVertexAttribLdvEXT(index, pname, pPs);
            }
        }


        #endregion GL_EXT_vertex_attrib_64bit

        #region GL_EXT_vertex_shader

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_vertex_shader</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glSetInvariantEXT(GLuint id, GLenum type, const void * addr);</para>
        /// </summary>
        public unsafe static void SetInvariantEXT(uint id, uint type, IntPtr addr) {
            GLNative.glSetInvariantEXT(id, type, (void*)addr);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_vertex_shader</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glSetLocalConstantEXT(GLuint id, GLenum type, const void * addr);</para>
        /// </summary>
        public unsafe static void SetLocalConstantEXT(uint id, uint type, IntPtr addr) {
            GLNative.glSetLocalConstantEXT(id, type, (void*)addr);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_vertex_shader</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVariantbvEXT(GLuint id, const GLbyte * addr);</para>
        /// </summary>
        public unsafe static void VariantbvEXT(uint id, ref byte addr) {
            fixed (byte* pAddr = &addr) {
                GLNative.glVariantbvEXT(id, pAddr);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_vertex_shader</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVariantsvEXT(GLuint id, const GLshort * addr);</para>
        /// </summary>
        public unsafe static void VariantsvEXT(uint id, ref short addr) {
            fixed (short* pAddr = &addr) {
                GLNative.glVariantsvEXT(id, pAddr);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_vertex_shader</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVariantivEXT(GLuint id, const GLint * addr);</para>
        /// </summary>
        public unsafe static void VariantivEXT(uint id, ref int addr) {
            fixed (int* pAddr = &addr) {
                GLNative.glVariantivEXT(id, pAddr);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_vertex_shader</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVariantfvEXT(GLuint id, const GLfloat * addr);</para>
        /// </summary>
        public unsafe static void VariantfvEXT(uint id, ref float addr) {
            fixed (float* pAddr = &addr) {
                GLNative.glVariantfvEXT(id, pAddr);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_vertex_shader</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVariantdvEXT(GLuint id, const GLdouble * addr);</para>
        /// </summary>
        public unsafe static void VariantdvEXT(uint id, ref double addr) {
            fixed (double* pAddr = &addr) {
                GLNative.glVariantdvEXT(id, pAddr);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_vertex_shader</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVariantubvEXT(GLuint id, const GLubyte * addr);</para>
        /// </summary>
        public unsafe static void VariantubvEXT(uint id, ref byte addr) {
            fixed (byte* pAddr = &addr) {
                GLNative.glVariantubvEXT(id, pAddr);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_vertex_shader</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVariantusvEXT(GLuint id, const GLushort * addr);</para>
        /// </summary>
        public unsafe static void VariantusvEXT(uint id, ref ushort addr) {
            fixed (ushort* pAddr = &addr) {
                GLNative.glVariantusvEXT(id, pAddr);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_vertex_shader</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVariantuivEXT(GLuint id, const GLuint * addr);</para>
        /// </summary>
        public unsafe static void VariantuivEXT(uint id, ref uint addr) {
            fixed (uint* pAddr = &addr) {
                GLNative.glVariantuivEXT(id, pAddr);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_vertex_shader</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVariantPointerEXT(GLuint id, GLenum type, GLuint stride, const void * addr);</para>
        /// </summary>
        public unsafe static void VariantPointerEXT(uint id, uint type, uint stride, IntPtr addr) {
            GLNative.glVariantPointerEXT(id, type, stride, (void*)addr);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_vertex_shader</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetVariantBooleanvEXT(GLuint id, GLenum value, GLboolean * data);</para>
        /// </summary>
        public unsafe static void GetVariantBooleanvEXT(uint id, uint value, ref bool data) {
            fixed (bool* pData = &data) {
                GLNative.glGetVariantBooleanvEXT(id, value, pData);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_vertex_shader</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetVariantIntegervEXT(GLuint id, GLenum value, GLint * data);</para>
        /// </summary>
        public unsafe static void GetVariantIntegervEXT(uint id, uint value, ref int data) {
            fixed (int* pData = &data) {
                GLNative.glGetVariantIntegervEXT(id, value, pData);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_vertex_shader</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetVariantFloatvEXT(GLuint id, GLenum value, GLfloat * data);</para>
        /// </summary>
        public unsafe static void GetVariantFloatvEXT(uint id, uint value, ref float data) {
            fixed (float* pData = &data) {
                GLNative.glGetVariantFloatvEXT(id, value, pData);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_vertex_shader</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetVariantPointervEXT(GLuint id, GLenum value, void ** data);</para>
        /// </summary>
        public unsafe static void GetVariantPointervEXT(uint id, uint value, IntPtr data) {
            GLNative.glGetVariantPointervEXT(id, value, (void**)data);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_vertex_shader</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetInvariantBooleanvEXT(GLuint id, GLenum value, GLboolean * data);</para>
        /// </summary>
        public unsafe static void GetInvariantBooleanvEXT(uint id, uint value, ref bool data) {
            fixed (bool* pData = &data) {
                GLNative.glGetInvariantBooleanvEXT(id, value, pData);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_vertex_shader</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetInvariantIntegervEXT(GLuint id, GLenum value, GLint * data);</para>
        /// </summary>
        public unsafe static void GetInvariantIntegervEXT(uint id, uint value, ref int data) {
            fixed (int* pData = &data) {
                GLNative.glGetInvariantIntegervEXT(id, value, pData);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_vertex_shader</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetInvariantFloatvEXT(GLuint id, GLenum value, GLfloat * data);</para>
        /// </summary>
        public unsafe static void GetInvariantFloatvEXT(uint id, uint value, ref float data) {
            fixed (float* pData = &data) {
                GLNative.glGetInvariantFloatvEXT(id, value, pData);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_vertex_shader</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetLocalConstantBooleanvEXT(GLuint id, GLenum value, GLboolean * data);</para>
        /// </summary>
        public unsafe static void GetLocalConstantBooleanvEXT(uint id, uint value, ref bool data) {
            fixed (bool* pData = &data) {
                GLNative.glGetLocalConstantBooleanvEXT(id, value, pData);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_vertex_shader</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetLocalConstantIntegervEXT(GLuint id, GLenum value, GLint * data);</para>
        /// </summary>
        public unsafe static void GetLocalConstantIntegervEXT(uint id, uint value, ref int data) {
            fixed (int* pData = &data) {
                GLNative.glGetLocalConstantIntegervEXT(id, value, pData);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_vertex_shader</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetLocalConstantFloatvEXT(GLuint id, GLenum value, GLfloat * data);</para>
        /// </summary>
        public unsafe static void GetLocalConstantFloatvEXT(uint id, uint value, ref float data) {
            fixed (float* pData = &data) {
                GLNative.glGetLocalConstantFloatvEXT(id, value, pData);
            }
        }


        #endregion GL_EXT_vertex_shader

        #region GL_EXT_vertex_weighting

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_vertex_weighting</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexWeightfvEXT(const GLfloat * weight);</para>
        /// </summary>
        public unsafe static void VertexWeightfvEXT(ref float weight) {
            fixed (float* pWeight = &weight) {
                GLNative.glVertexWeightfvEXT(pWeight);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_vertex_weighting</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexWeightPointerEXT(GLint size, GLenum type, GLsizei stride, const void * pointer);</para>
        /// </summary>
        public unsafe static void VertexWeightPointerEXT(int size, uint type, int stride, IntPtr pointer) {
            GLNative.glVertexWeightPointerEXT(size, type, stride, (void*)pointer);
        }


        #endregion GL_EXT_vertex_weighting

        #region GL_EXT_win32_keyed_mutex


        #endregion GL_EXT_win32_keyed_mutex

        #region GL_EXT_window_rectangles

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_window_rectangles</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glWindowRectanglesEXT(GLenum mode, GLsizei count, const GLint * box);</para>
        /// </summary>
        public unsafe static void WindowRectanglesEXT(uint mode, int count, ref int box) {
            fixed (int* pBox = &box) {
                GLNative.glWindowRectanglesEXT(mode, count, pBox);
            }
        }


        #endregion GL_EXT_window_rectangles

        #region GL_EXT_x11_sync_object


        #endregion GL_EXT_x11_sync_object

        #region GL_GREMEDY_frame_terminator


        #endregion GL_GREMEDY_frame_terminator

        #region GL_GREMEDY_string_marker

        /// <summary>
        /// <para>Require:</para> <para>GL_GREMEDY_string_marker</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glStringMarkerGREMEDY(GLsizei len, const void * string);</para>
        /// </summary>
        public unsafe static void StringMarkerGREMEDY(int len, IntPtr str) {
            GLNative.glStringMarkerGREMEDY(len, (void*)str);
        }


        #endregion GL_GREMEDY_string_marker

        #region GL_HP_image_transform

        /// <summary>
        /// <para>Require:</para> <para>GL_HP_image_transform</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glImageTransformParameterivHP(GLenum target, GLenum pname, const GLint * params);</para>
        /// </summary>
        public unsafe static void ImageTransformParameterivHP(uint target, uint pname, ref int ps) {
            fixed (int* pPs = &ps) {
                GLNative.glImageTransformParameterivHP(target, pname, pPs);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_HP_image_transform</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glImageTransformParameterfvHP(GLenum target, GLenum pname, const GLfloat * params);</para>
        /// </summary>
        public unsafe static void ImageTransformParameterfvHP(uint target, uint pname, ref float ps) {
            fixed (float* pPs = &ps) {
                GLNative.glImageTransformParameterfvHP(target, pname, pPs);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_HP_image_transform</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetImageTransformParameterivHP(GLenum target, GLenum pname, GLint * params);</para>
        /// </summary>
        public unsafe static void GetImageTransformParameterivHP(uint target, uint pname, ref int ps) {
            fixed (int* pPs = &ps) {
                GLNative.glGetImageTransformParameterivHP(target, pname, pPs);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_HP_image_transform</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetImageTransformParameterfvHP(GLenum target, GLenum pname, GLfloat * params);</para>
        /// </summary>
        public unsafe static void GetImageTransformParameterfvHP(uint target, uint pname, ref float ps) {
            fixed (float* pPs = &ps) {
                GLNative.glGetImageTransformParameterfvHP(target, pname, pPs);
            }
        }


        #endregion GL_HP_image_transform

        #region GL_IBM_multimode_draw_arrays

        /// <summary>
        /// <para>Require:</para> <para>GL_IBM_multimode_draw_arrays</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glMultiModeDrawArraysIBM(const GLenum * mode, const GLint * first, const GLsizei * count, GLsizei primcount, GLint modestride);</para>
        /// </summary>
        public unsafe static void MultiModeDrawArraysIBM(ref uint mode, ref int first, ref int count, int primcount, int modestride) {
            fixed (uint* pMode = &mode)
            fixed (int* pFirst = &first)
            fixed (int* pCount = &count) {
                GLNative.glMultiModeDrawArraysIBM(pMode, pFirst, pCount, primcount, modestride);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_IBM_multimode_draw_arrays</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glMultiModeDrawElementsIBM(const GLenum * mode, const GLsizei * count, GLenum type, const void *const* indices, GLsizei primcount, GLint modestride);</para>
        /// </summary>
        public unsafe static void MultiModeDrawElementsIBM(ref uint mode, ref int count, uint type, IntPtr indices, int primcount, int modestride) {
            fixed (uint* pMode = &mode)
            fixed (int* pCount = &count) {
                GLNative.glMultiModeDrawElementsIBM(pMode, pCount, type, indices, primcount, modestride);
            }
        }


        #endregion GL_IBM_multimode_draw_arrays

        #region GL_IBM_static_data


        #endregion GL_IBM_static_data

        #region GL_IBM_vertex_array_lists

        /// <summary>
        /// <para>Require:</para> <para>GL_IBM_vertex_array_lists</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glColorPointerListIBM(GLint size, GLenum type, GLint stride, const void ** pointer, GLint ptrstride);</para>
        /// </summary>
        public unsafe static void ColorPointerListIBM(int size, uint type, int stride, IntPtr pointer, int ptrstride) {
            GLNative.glColorPointerListIBM(size, type, stride, (void**)pointer, ptrstride);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_IBM_vertex_array_lists</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glSecondaryColorPointerListIBM(GLint size, GLenum type, GLint stride, const void ** pointer, GLint ptrstride);</para>
        /// </summary>
        public unsafe static void SecondaryColorPointerListIBM(int size, uint type, int stride, IntPtr pointer, int ptrstride) {
            GLNative.glSecondaryColorPointerListIBM(size, type, stride, (void**)pointer, ptrstride);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_IBM_vertex_array_lists</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glEdgeFlagPointerListIBM(GLint stride, const GLboolean ** pointer, GLint ptrstride);</para>
        /// </summary>
        public unsafe static void EdgeFlagPointerListIBM(int stride, IntPtr pointer, int ptrstride) {
            GLNative.glEdgeFlagPointerListIBM(stride, (bool**)pointer, ptrstride);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_IBM_vertex_array_lists</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glFogCoordPointerListIBM(GLenum type, GLint stride, const void ** pointer, GLint ptrstride);</para>
        /// </summary>
        public unsafe static void FogCoordPointerListIBM(uint type, int stride, IntPtr pointer, int ptrstride) {
            GLNative.glFogCoordPointerListIBM(type, stride, (void**)pointer, ptrstride);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_IBM_vertex_array_lists</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glIndexPointerListIBM(GLenum type, GLint stride, const void ** pointer, GLint ptrstride);</para>
        /// </summary>
        public unsafe static void IndexPointerListIBM(uint type, int stride, IntPtr pointer, int ptrstride) {
            GLNative.glIndexPointerListIBM(type, stride, (void**)pointer, ptrstride);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_IBM_vertex_array_lists</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glNormalPointerListIBM(GLenum type, GLint stride, const void ** pointer, GLint ptrstride);</para>
        /// </summary>
        public unsafe static void NormalPointerListIBM(uint type, int stride, IntPtr pointer, int ptrstride) {
            GLNative.glNormalPointerListIBM(type, stride, (void**)pointer, ptrstride);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_IBM_vertex_array_lists</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glTexCoordPointerListIBM(GLint size, GLenum type, GLint stride, const void ** pointer, GLint ptrstride);</para>
        /// </summary>
        public unsafe static void TexCoordPointerListIBM(int size, uint type, int stride, IntPtr pointer, int ptrstride) {
            GLNative.glTexCoordPointerListIBM(size, type, stride, (void**)pointer, ptrstride);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_IBM_vertex_array_lists</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexPointerListIBM(GLint size, GLenum type, GLint stride, const void ** pointer, GLint ptrstride);</para>
        /// </summary>
        public unsafe static void VertexPointerListIBM(int size, uint type, int stride, IntPtr pointer, int ptrstride) {
            GLNative.glVertexPointerListIBM(size, type, stride, (void**)pointer, ptrstride);
        }


        #endregion GL_IBM_vertex_array_lists

        #region GL_INGR_blend_func_separate


        #endregion GL_INGR_blend_func_separate

        #region GL_INTEL_framebuffer_CMAA


        #endregion GL_INTEL_framebuffer_CMAA

        #region GL_INTEL_map_texture

        /// <summary>
        /// <para>Require:</para> <para>GL_INTEL_map_texture</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void * glMapTexture2DINTEL(GLuint texture, GLint level, GLbitfield access, GLint * stride, GLenum * layout);</para>
        /// </summary>
        public unsafe static IntPtr MapTexture2DINTEL(uint texture, int level, uint access, ref int stride, ref uint layout) {
            fixed (int* pStride = &stride)
            fixed (uint* pLayout = &layout) {
                return (IntPtr)GLNative.glMapTexture2DINTEL(texture, level, access, pStride, pLayout);
            }
        }


        #endregion GL_INTEL_map_texture

        #region GL_INTEL_parallel_arrays

        /// <summary>
        /// <para>Require:</para> <para>GL_INTEL_parallel_arrays</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexPointervINTEL(GLint size, GLenum type, const void ** pointer);</para>
        /// </summary>
        public unsafe static void VertexPointervINTEL(int size, uint type, IntPtr pointer) {
            GLNative.glVertexPointervINTEL(size, type, (void**)pointer);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_INTEL_parallel_arrays</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glNormalPointervINTEL(GLenum type, const void ** pointer);</para>
        /// </summary>
        public unsafe static void NormalPointervINTEL(uint type, IntPtr pointer) {
            GLNative.glNormalPointervINTEL(type, (void**)pointer);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_INTEL_parallel_arrays</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glColorPointervINTEL(GLint size, GLenum type, const void ** pointer);</para>
        /// </summary>
        public unsafe static void ColorPointervINTEL(int size, uint type, IntPtr pointer) {
            GLNative.glColorPointervINTEL(size, type, (void**)pointer);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_INTEL_parallel_arrays</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glTexCoordPointervINTEL(GLint size, GLenum type, const void ** pointer);</para>
        /// </summary>
        public unsafe static void TexCoordPointervINTEL(int size, uint type, IntPtr pointer) {
            GLNative.glTexCoordPointervINTEL(size, type, (void**)pointer);
        }


        #endregion GL_INTEL_parallel_arrays

        #region GL_INTEL_performance_query

        /// <summary>
        /// <para>Require:</para> <para>GL_INTEL_performance_query</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glCreatePerfQueryINTEL(GLuint queryId, GLuint * queryHandle);</para>
        /// </summary>
        public unsafe static void CreatePerfQueryINTEL(uint queryId, ref uint queryHandle) {
            fixed (uint* pQueryHandle = &queryHandle) {
                GLNative.glCreatePerfQueryINTEL(queryId, pQueryHandle);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_INTEL_performance_query</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glGetFirstPerfQueryIdINTEL(GLuint * queryId);</para>
        /// </summary>
        public unsafe static void GetFirstPerfQueryIdINTEL(ref uint queryId) {
            fixed (uint* pQueryId = &queryId) {
                GLNative.glGetFirstPerfQueryIdINTEL(pQueryId);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_INTEL_performance_query</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glGetNextPerfQueryIdINTEL(GLuint queryId, GLuint * nextQueryId);</para>
        /// </summary>
        public unsafe static void GetNextPerfQueryIdINTEL(uint queryId, ref uint nextQueryId) {
            fixed (uint* pNextQueryId = &nextQueryId) {
                GLNative.glGetNextPerfQueryIdINTEL(queryId, pNextQueryId);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_INTEL_performance_query</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glGetPerfCounterInfoINTEL(GLuint queryId, GLuint counterId, GLuint counterNameLength, GLchar * counterName, GLuint counterDescLength, GLchar * counterDesc, GLuint * counterOffset, GLuint * counterDataSize, GLuint * counterTypeEnum, GLuint * counterDataTypeEnum, GLuint64 * rawCounterMaxValue);</para>
        /// </summary>
        public unsafe static void GetPerfCounterInfoINTEL(uint queryId, uint counterId, uint counterNameLength, ref byte counterName, uint counterDescLength, ref byte counterDesc, ref uint counterOffset, ref uint counterDataSize, ref uint counterTypeEnum, ref uint counterDataTypeEnum, ref UInt64 rawCounterMaxValue) {
            fixed (byte* pCounterName = &counterName)
            fixed (byte* pCounterDesc = &counterDesc)
            fixed (uint* pCounterOffset = &counterOffset)
            fixed (uint* pCounterDataSize = &counterDataSize)
            fixed (uint* pCounterTypeEnum = &counterTypeEnum)
            fixed (uint* pCounterDataTypeEnum = &counterDataTypeEnum)
            fixed (UInt64* pRawCounterMaxValue = &rawCounterMaxValue) {
                GLNative.glGetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, pCounterName, counterDescLength, pCounterDesc, pCounterOffset, pCounterDataSize, pCounterTypeEnum, pCounterDataTypeEnum, pRawCounterMaxValue);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_INTEL_performance_query</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glGetPerfQueryDataINTEL(GLuint queryHandle, GLuint flags, GLsizei dataSize, void * data, GLuint * bytesWritten);</para>
        /// </summary>
        public unsafe static void GetPerfQueryDataINTEL(uint queryHandle, uint flags, int dataSize, IntPtr data, ref uint bytesWritten) {
            fixed (uint* pBytesWritten = &bytesWritten) {
                GLNative.glGetPerfQueryDataINTEL(queryHandle, flags, dataSize, (void*)data, pBytesWritten);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_INTEL_performance_query</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glGetPerfQueryIdByNameINTEL(GLchar * queryName, GLuint * queryId);</para>
        /// </summary>
        public unsafe static void GetPerfQueryIdByNameINTEL(ref byte queryName, ref uint queryId) {
            fixed (byte* pQueryName = &queryName)
            fixed (uint* pQueryId = &queryId) {
                GLNative.glGetPerfQueryIdByNameINTEL(pQueryName, pQueryId);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_INTEL_performance_query</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glGetPerfQueryInfoINTEL(GLuint queryId, GLuint queryNameLength, GLchar * queryName, GLuint * dataSize, GLuint * noCounters, GLuint * noInstances, GLuint * capsMask);</para>
        /// </summary>
        public unsafe static void GetPerfQueryInfoINTEL(uint queryId, uint queryNameLength, ref byte queryName, ref uint dataSize, ref uint noCounters, ref uint noInstances, ref uint capsMask) {
            fixed (byte* pQueryName = &queryName)
            fixed (uint* pDataSize = &dataSize)
            fixed (uint* pNoCounters = &noCounters)
            fixed (uint* pNoInstances = &noInstances)
            fixed (uint* pCapsMask = &capsMask) {
                GLNative.glGetPerfQueryInfoINTEL(queryId, queryNameLength, pQueryName, pDataSize, pNoCounters, pNoInstances, pCapsMask);
            }
        }


        #endregion GL_INTEL_performance_query

        #region GL_KHR_blend_equation_advanced


        #endregion GL_KHR_blend_equation_advanced

        #region GL_KHR_debug

        // void glDebugMessageControl(GLenum source, GLenum type, GLenum severity, GLsizei count, const GLuint * ids, GLboolean enabled);
        // void glDebugMessageInsert(GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const char * message);
        // void glDebugMessageCallback(GLDEBUGPROC callback, const void * userParam);
        // GLuint glGetDebugMessageLog(GLuint count, GLsizei bufSize, GLenum * sources, GLenum * types, GLuint * ids, GLenum * severities, GLsizei * lengths, GLchar * messageLog);
        // void glPushDebugGroup(GLenum source, GLuint id, GLsizei length, const char * message);
        // void glObjectLabel(GLenum identifier, GLuint name, GLsizei length, const char * label);
        // void glGetObjectLabel(GLenum identifier, GLuint name, GLsizei bufSize, GLsizei * length, char * label);
        // void glObjectPtrLabel(void * ptr, GLsizei length, const char * label);
        // void glGetObjectPtrLabel(void * ptr, GLsizei bufSize, GLsizei * length, char * label);
        // void glGetPointerv(GLenum pname, void ** ps);
        /// <summary>
        /// <para>Require:</para> <para>GL_KHR_debug</para>
        /// Supported: <para>gl, glcore, gles1, gles2</para>
        /// Original: <para>void glDebugMessageControlKHR(GLenum source, GLenum type, GLenum severity, GLsizei count, const GLuint * ids, GLboolean enabled);</para>
        /// </summary>
        public unsafe static void DebugMessageControlKHR(uint source, uint type, uint severity, int count, ref uint ids, bool enabled) {
            fixed (uint* pIds = &ids) {
                GLNative.glDebugMessageControlKHR(source, type, severity, count, pIds, enabled);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_KHR_debug</para>
        /// Supported: <para>gl, glcore, gles1, gles2</para>
        /// Original: <para>void glDebugMessageInsertKHR(GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const GLchar * buf);</para>
        /// </summary>
        public unsafe static void DebugMessageInsertKHR(uint source, uint type, uint id, uint severity, int length, ref byte buf) {
            fixed (byte* pBuf = &buf) {
                GLNative.glDebugMessageInsertKHR(source, type, id, severity, length, pBuf);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_KHR_debug</para>
        /// Supported: <para>gl, glcore, gles1, gles2</para>
        /// Original: <para>void glDebugMessageCallbackKHR(GLDEBUGPROCKHR callback, const void * userParam);</para>
        /// </summary>
        public unsafe static void DebugMessageCallbackKHR(GLNativeDelegate.GLDEBUGPROCKHR callback, IntPtr userParam) {
            GLNative.glDebugMessageCallbackKHR(callback, (void*)userParam);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_KHR_debug</para>
        /// Supported: <para>gl, glcore, gles1, gles2</para>
        /// Original: <para>GLuint glGetDebugMessageLogKHR(GLuint count, GLsizei bufSize, GLenum * sources, GLenum * types, GLuint * ids, GLenum * severities, GLsizei * lengths, GLchar * messageLog);</para>
        /// </summary>
        public unsafe static uint GetDebugMessageLogKHR(uint count, int bufSize, ref uint sources, ref uint types, ref uint ids, ref uint severities, ref int lengths, ref byte messageLog) {
            fixed (uint* pSources = &sources)
            fixed (uint* pTypes = &types)
            fixed (uint* pIds = &ids)
            fixed (uint* pSeverities = &severities)
            fixed (int* pLengths = &lengths)
            fixed (byte* pMessageLog = &messageLog) {
                return GLNative.glGetDebugMessageLogKHR(count, bufSize, pSources, pTypes, pIds, pSeverities, pLengths, pMessageLog);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_KHR_debug</para>
        /// Supported: <para>gl, glcore, gles1, gles2</para>
        /// Original: <para>void glPushDebugGroupKHR(GLenum source, GLuint id, GLsizei length, const GLchar * message);</para>
        /// </summary>
        public unsafe static void PushDebugGroupKHR(uint source, uint id, int length, ref byte message) {
            fixed (byte* pMessage = &message) {
                GLNative.glPushDebugGroupKHR(source, id, length, pMessage);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_KHR_debug</para>
        /// Supported: <para>gl, glcore, gles1, gles2</para>
        /// Original: <para>void glObjectLabelKHR(GLenum identifier, GLuint name, GLsizei length, const GLchar * label);</para>
        /// </summary>
        public unsafe static void ObjectLabelKHR(uint identifier, uint name, int length, ref byte label) {
            fixed (byte* pLabel = &label) {
                GLNative.glObjectLabelKHR(identifier, name, length, pLabel);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_KHR_debug</para>
        /// Supported: <para>gl, glcore, gles1, gles2</para>
        /// Original: <para>void glGetObjectLabelKHR(GLenum identifier, GLuint name, GLsizei bufSize, GLsizei * length, GLchar * label);</para>
        /// </summary>
        public unsafe static void GetObjectLabelKHR(uint identifier, uint name, int bufSize, ref int length, ref byte label) {
            fixed (int* pLength = &length)
            fixed (byte* pLabel = &label) {
                GLNative.glGetObjectLabelKHR(identifier, name, bufSize, pLength, pLabel);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_KHR_debug</para>
        /// Supported: <para>gl, glcore, gles1, gles2</para>
        /// Original: <para>void glObjectPtrLabelKHR(const void * ptr, GLsizei length, const GLchar * label);</para>
        /// </summary>
        public unsafe static void ObjectPtrLabelKHR(IntPtr ptr, int length, ref byte label) {
            fixed (byte* pLabel = &label) {
                GLNative.glObjectPtrLabelKHR((void*)ptr, length, pLabel);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_KHR_debug</para>
        /// Supported: <para>gl, glcore, gles1, gles2</para>
        /// Original: <para>void glGetObjectPtrLabelKHR(const void * ptr, GLsizei bufSize, GLsizei * length, GLchar * label);</para>
        /// </summary>
        public unsafe static void GetObjectPtrLabelKHR(IntPtr ptr, int bufSize, ref int length, ref byte label) {
            fixed (int* pLength = &length)
            fixed (byte* pLabel = &label) {
                GLNative.glGetObjectPtrLabelKHR((void*)ptr, bufSize, pLength, pLabel);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_KHR_debug</para>
        /// Supported: <para>gl, glcore, gles1, gles2</para>
        /// Original: <para>void glGetPointervKHR(GLenum pname, void ** params);</para>
        /// </summary>
        public unsafe static void GetPointervKHR(uint pname, IntPtr ps) {
            GLNative.glGetPointervKHR(pname, (void**)ps);
        }


        #endregion GL_KHR_debug

        #region GL_KHR_robustness

        // void glReadnPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLsizei bufSize, void * data);
        // void glGetnUniformfv(GLuint program, GLint location, GLsizei bufSize, GLfloat * ps);
        // void glGetnUniformiv(GLuint program, GLint location, GLsizei bufSize, GLint * ps);
        // void glGetnUniformuiv(GLuint program, GLint location, GLsizei bufSize, GLuint * ps);
        /// <summary>
        /// <para>Require:</para> <para>GL_KHR_robustness</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glReadnPixelsKHR(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLsizei bufSize, void * data);</para>
        /// </summary>
        public unsafe static void ReadnPixelsKHR(int x, int y, int width, int height, uint format, uint type, int bufSize, IntPtr data) {
            GLNative.glReadnPixelsKHR(x, y, width, height, format, type, bufSize, (void*)data);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_KHR_robustness</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glGetnUniformfvKHR(GLuint program, GLint location, GLsizei bufSize, GLfloat * params);</para>
        /// </summary>
        public unsafe static void GetnUniformfvKHR(uint program, int location, int bufSize, ref float ps) {
            fixed (float* pPs = &ps) {
                GLNative.glGetnUniformfvKHR(program, location, bufSize, pPs);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_KHR_robustness</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glGetnUniformivKHR(GLuint program, GLint location, GLsizei bufSize, GLint * params);</para>
        /// </summary>
        public unsafe static void GetnUniformivKHR(uint program, int location, int bufSize, ref int ps) {
            fixed (int* pPs = &ps) {
                GLNative.glGetnUniformivKHR(program, location, bufSize, pPs);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_KHR_robustness</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glGetnUniformuivKHR(GLuint program, GLint location, GLsizei bufSize, GLuint * params);</para>
        /// </summary>
        public unsafe static void GetnUniformuivKHR(uint program, int location, int bufSize, ref uint ps) {
            fixed (uint* pPs = &ps) {
                GLNative.glGetnUniformuivKHR(program, location, bufSize, pPs);
            }
        }


        #endregion GL_KHR_robustness

        #region GL_KHR_parallel_shader_compile


        #endregion GL_KHR_parallel_shader_compile

        #region GL_MESA_framebuffer_flip_y

        /// <summary>
        /// <para>Require:</para> <para>GL_MESA_framebuffer_flip_y</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glGetFramebufferParameterivMESA(GLenum target, GLenum pname, GLint * params);</para>
        /// </summary>
        public unsafe static void GetFramebufferParameterivMESA(uint target, uint pname, ref int ps) {
            fixed (int* pPs = &ps) {
                GLNative.glGetFramebufferParameterivMESA(target, pname, pPs);
            }
        }


        #endregion GL_MESA_framebuffer_flip_y

        #region GL_MESA_resize_buffers


        #endregion GL_MESA_resize_buffers

        #region GL_MESA_window_pos

        /// <summary>
        /// <para>Require:</para> <para>GL_MESA_window_pos</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glWindowPos2dvMESA(const GLdouble * v);</para>
        /// </summary>
        public unsafe static void WindowPos2dvMESA(ref double v) {
            fixed (double* pV = &v) {
                GLNative.glWindowPos2dvMESA(pV);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_MESA_window_pos</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glWindowPos2fvMESA(const GLfloat * v);</para>
        /// </summary>
        public unsafe static void WindowPos2fvMESA(ref float v) {
            fixed (float* pV = &v) {
                GLNative.glWindowPos2fvMESA(pV);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_MESA_window_pos</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glWindowPos2ivMESA(const GLint * v);</para>
        /// </summary>
        public unsafe static void WindowPos2ivMESA(ref int v) {
            fixed (int* pV = &v) {
                GLNative.glWindowPos2ivMESA(pV);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_MESA_window_pos</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glWindowPos2svMESA(const GLshort * v);</para>
        /// </summary>
        public unsafe static void WindowPos2svMESA(ref short v) {
            fixed (short* pV = &v) {
                GLNative.glWindowPos2svMESA(pV);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_MESA_window_pos</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glWindowPos3dvMESA(const GLdouble * v);</para>
        /// </summary>
        public unsafe static void WindowPos3dvMESA(ref double v) {
            fixed (double* pV = &v) {
                GLNative.glWindowPos3dvMESA(pV);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_MESA_window_pos</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glWindowPos3fvMESA(const GLfloat * v);</para>
        /// </summary>
        public unsafe static void WindowPos3fvMESA(ref float v) {
            fixed (float* pV = &v) {
                GLNative.glWindowPos3fvMESA(pV);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_MESA_window_pos</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glWindowPos3ivMESA(const GLint * v);</para>
        /// </summary>
        public unsafe static void WindowPos3ivMESA(ref int v) {
            fixed (int* pV = &v) {
                GLNative.glWindowPos3ivMESA(pV);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_MESA_window_pos</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glWindowPos3svMESA(const GLshort * v);</para>
        /// </summary>
        public unsafe static void WindowPos3svMESA(ref short v) {
            fixed (short* pV = &v) {
                GLNative.glWindowPos3svMESA(pV);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_MESA_window_pos</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glWindowPos4dvMESA(const GLdouble * v);</para>
        /// </summary>
        public unsafe static void WindowPos4dvMESA(ref double v) {
            fixed (double* pV = &v) {
                GLNative.glWindowPos4dvMESA(pV);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_MESA_window_pos</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glWindowPos4fvMESA(const GLfloat * v);</para>
        /// </summary>
        public unsafe static void WindowPos4fvMESA(ref float v) {
            fixed (float* pV = &v) {
                GLNative.glWindowPos4fvMESA(pV);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_MESA_window_pos</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glWindowPos4ivMESA(const GLint * v);</para>
        /// </summary>
        public unsafe static void WindowPos4ivMESA(ref int v) {
            fixed (int* pV = &v) {
                GLNative.glWindowPos4ivMESA(pV);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_MESA_window_pos</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glWindowPos4svMESA(const GLshort * v);</para>
        /// </summary>
        public unsafe static void WindowPos4svMESA(ref short v) {
            fixed (short* pV = &v) {
                GLNative.glWindowPos4svMESA(pV);
            }
        }


        #endregion GL_MESA_window_pos

        #region GL_NVX_conditional_render


        #endregion GL_NVX_conditional_render

        #region GL_NVX_linked_gpu_multicast

        /// <summary>
        /// <para>Require:</para> <para>GL_NVX_linked_gpu_multicast</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glLGPUNamedBufferSubDataNVX(GLbitfield gpuMask, GLuint buffer, GLintptr offset, GLsizeiptr size, const void * data);</para>
        /// </summary>
        public unsafe static void LGPUNamedBufferSubDataNVX(uint gpuMask, uint buffer, IntPtr offset, IntPtr size, IntPtr data) {
            GLNative.glLGPUNamedBufferSubDataNVX(gpuMask, buffer, offset, size, (void*)data);
        }


        #endregion GL_NVX_linked_gpu_multicast

        #region GL_NV_alpha_to_coverage_dither_control


        #endregion GL_NV_alpha_to_coverage_dither_control

        #region GL_NV_bindless_multi_draw_indirect

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_bindless_multi_draw_indirect</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glMultiDrawArraysIndirectBindlessNV(GLenum mode, const void * indirect, GLsizei drawCount, GLsizei stride, GLint vertexBufferCount);</para>
        /// </summary>
        public unsafe static void MultiDrawArraysIndirectBindlessNV(uint mode, IntPtr indirect, int drawCount, int stride, int vertexBufferCount) {
            GLNative.glMultiDrawArraysIndirectBindlessNV(mode, (void*)indirect, drawCount, stride, vertexBufferCount);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_bindless_multi_draw_indirect</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glMultiDrawElementsIndirectBindlessNV(GLenum mode, GLenum type, const void * indirect, GLsizei drawCount, GLsizei stride, GLint vertexBufferCount);</para>
        /// </summary>
        public unsafe static void MultiDrawElementsIndirectBindlessNV(uint mode, uint type, IntPtr indirect, int drawCount, int stride, int vertexBufferCount) {
            GLNative.glMultiDrawElementsIndirectBindlessNV(mode, type, (void*)indirect, drawCount, stride, vertexBufferCount);
        }


        #endregion GL_NV_bindless_multi_draw_indirect

        #region GL_NV_bindless_multi_draw_indirect_count

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_bindless_multi_draw_indirect_count</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glMultiDrawArraysIndirectBindlessCountNV(GLenum mode, const void * indirect, GLsizei drawCount, GLsizei maxDrawCount, GLsizei stride, GLint vertexBufferCount);</para>
        /// </summary>
        public unsafe static void MultiDrawArraysIndirectBindlessCountNV(uint mode, IntPtr indirect, int drawCount, int maxDrawCount, int stride, int vertexBufferCount) {
            GLNative.glMultiDrawArraysIndirectBindlessCountNV(mode, (void*)indirect, drawCount, maxDrawCount, stride, vertexBufferCount);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_bindless_multi_draw_indirect_count</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glMultiDrawElementsIndirectBindlessCountNV(GLenum mode, GLenum type, const void * indirect, GLsizei drawCount, GLsizei maxDrawCount, GLsizei stride, GLint vertexBufferCount);</para>
        /// </summary>
        public unsafe static void MultiDrawElementsIndirectBindlessCountNV(uint mode, uint type, IntPtr indirect, int drawCount, int maxDrawCount, int stride, int vertexBufferCount) {
            GLNative.glMultiDrawElementsIndirectBindlessCountNV(mode, type, (void*)indirect, drawCount, maxDrawCount, stride, vertexBufferCount);
        }


        #endregion GL_NV_bindless_multi_draw_indirect_count

        #region GL_NV_bindless_texture

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_bindless_texture</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glUniformHandleui64vNV(GLint location, GLsizei count, const GLuint64 * value);</para>
        /// </summary>
        public unsafe static void UniformHandleui64vNV(int location, int count, ref UInt64 value) {
            fixed (UInt64* pValue = &value) {
                GLNative.glUniformHandleui64vNV(location, count, pValue);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_bindless_texture</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glProgramUniformHandleui64vNV(GLuint program, GLint location, GLsizei count, const GLuint64 * values);</para>
        /// </summary>
        public unsafe static void ProgramUniformHandleui64vNV(uint program, int location, int count, ref UInt64 values) {
            fixed (UInt64* pValues = &values) {
                GLNative.glProgramUniformHandleui64vNV(program, location, count, pValues);
            }
        }


        #endregion GL_NV_bindless_texture

        #region GL_NV_blend_equation_advanced


        #endregion GL_NV_blend_equation_advanced

        #region GL_NV_clip_space_w_scaling


        #endregion GL_NV_clip_space_w_scaling

        #region GL_NV_command_list

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_command_list</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glCreateStatesNV(GLsizei n, GLuint * states);</para>
        /// </summary>
        public unsafe static void CreateStatesNV(int n, ref uint states) {
            fixed (uint* pStates = &states) {
                GLNative.glCreateStatesNV(n, pStates);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_command_list</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glDeleteStatesNV(GLsizei n, const GLuint * states);</para>
        /// </summary>
        public unsafe static void DeleteStatesNV(int n, ref uint states) {
            fixed (uint* pStates = &states) {
                GLNative.glDeleteStatesNV(n, pStates);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_command_list</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glDrawCommandsNV(GLenum primitiveMode, GLuint buffer, const GLintptr * indirects, const GLsizei * sizes, GLuint count);</para>
        /// </summary>
        public unsafe static void DrawCommandsNV(uint primitiveMode, uint buffer, IntPtr indirects, ref int sizes, uint count) {
            fixed (int* pSizes = &sizes) {
                GLNative.glDrawCommandsNV(primitiveMode, buffer, indirects, pSizes, count);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_command_list</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glDrawCommandsAddressNV(GLenum primitiveMode, const GLuint64 * indirects, const GLsizei * sizes, GLuint count);</para>
        /// </summary>
        public unsafe static void DrawCommandsAddressNV(uint primitiveMode, ref UInt64 indirects, ref int sizes, uint count) {
            fixed (UInt64* pIndirects = &indirects)
            fixed (int* pSizes = &sizes) {
                GLNative.glDrawCommandsAddressNV(primitiveMode, pIndirects, pSizes, count);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_command_list</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glDrawCommandsStatesNV(GLuint buffer, const GLintptr * indirects, const GLsizei * sizes, const GLuint * states, const GLuint * fbos, GLuint count);</para>
        /// </summary>
        public unsafe static void DrawCommandsStatesNV(uint buffer, IntPtr indirects, ref int sizes, ref uint states, ref uint fbos, uint count) {
            fixed (int* pSizes = &sizes)
            fixed (uint* pStates = &states)
            fixed (uint* pFbos = &fbos) {
                GLNative.glDrawCommandsStatesNV(buffer, indirects, pSizes, pStates, pFbos, count);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_command_list</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glDrawCommandsStatesAddressNV(const GLuint64 * indirects, const GLsizei * sizes, const GLuint * states, const GLuint * fbos, GLuint count);</para>
        /// </summary>
        public unsafe static void DrawCommandsStatesAddressNV(ref UInt64 indirects, ref int sizes, ref uint states, ref uint fbos, uint count) {
            fixed (UInt64* pIndirects = &indirects)
            fixed (int* pSizes = &sizes)
            fixed (uint* pStates = &states)
            fixed (uint* pFbos = &fbos) {
                GLNative.glDrawCommandsStatesAddressNV(pIndirects, pSizes, pStates, pFbos, count);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_command_list</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glCreateCommandListsNV(GLsizei n, GLuint * lists);</para>
        /// </summary>
        public unsafe static void CreateCommandListsNV(int n, ref uint lists) {
            fixed (uint* pLists = &lists) {
                GLNative.glCreateCommandListsNV(n, pLists);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_command_list</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glDeleteCommandListsNV(GLsizei n, const GLuint * lists);</para>
        /// </summary>
        public unsafe static void DeleteCommandListsNV(int n, ref uint lists) {
            fixed (uint* pLists = &lists) {
                GLNative.glDeleteCommandListsNV(n, pLists);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_command_list</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glListDrawCommandsStatesClientNV(GLuint list, GLuint segment, const void ** indirects, const GLsizei * sizes, const GLuint * states, const GLuint * fbos, GLuint count);</para>
        /// </summary>
        public unsafe static void ListDrawCommandsStatesClientNV(uint list, uint segment, IntPtr indirects, ref int sizes, ref uint states, ref uint fbos, uint count) {
            fixed (int* pSizes = &sizes)
            fixed (uint* pStates = &states)
            fixed (uint* pFbos = &fbos) {
                GLNative.glListDrawCommandsStatesClientNV(list, segment, (void**)indirects, pSizes, pStates, pFbos, count);
            }
        }


        #endregion GL_NV_command_list

        #region GL_NV_conditional_render


        #endregion GL_NV_conditional_render

        #region GL_NV_conservative_raster


        #endregion GL_NV_conservative_raster

        #region GL_NV_conservative_raster_dilate


        #endregion GL_NV_conservative_raster_dilate

        #region GL_NV_conservative_raster_pre_snap_triangles


        #endregion GL_NV_conservative_raster_pre_snap_triangles

        #region GL_NV_copy_image


        #endregion GL_NV_copy_image

        #region GL_NV_depth_buffer_float


        #endregion GL_NV_depth_buffer_float

        #region GL_NV_draw_texture


        #endregion GL_NV_draw_texture

        #region GL_NV_draw_vulkan_image

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_draw_vulkan_image</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>GLVULKANPROCNV glGetVkProcAddrNV(const GLchar * name);</para>
        /// </summary>
        public unsafe static IntPtr GetVkProcAddrNV(ref byte name) {
            fixed (byte* pName = &name) {
                return GLNative.glGetVkProcAddrNV(pName);
            }
        }


        #endregion GL_NV_draw_vulkan_image

        #region GL_NV_evaluators

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_evaluators</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glMapControlPointsNV(GLenum target, GLuint index, GLenum type, GLsizei ustride, GLsizei vstride, GLint uorder, GLint vorder, GLboolean packed, const void * points);</para>
        /// </summary>
        public unsafe static void MapControlPointsNV(uint target, uint index, uint type, int ustride, int vstride, int uorder, int vorder, bool packed, IntPtr points) {
            GLNative.glMapControlPointsNV(target, index, type, ustride, vstride, uorder, vorder, packed, (void*)points);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_evaluators</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glMapParameterivNV(GLenum target, GLenum pname, const GLint * params);</para>
        /// </summary>
        public unsafe static void MapParameterivNV(uint target, uint pname, ref int ps) {
            fixed (int* pPs = &ps) {
                GLNative.glMapParameterivNV(target, pname, pPs);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_evaluators</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glMapParameterfvNV(GLenum target, GLenum pname, const GLfloat * params);</para>
        /// </summary>
        public unsafe static void MapParameterfvNV(uint target, uint pname, ref float ps) {
            fixed (float* pPs = &ps) {
                GLNative.glMapParameterfvNV(target, pname, pPs);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_evaluators</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetMapControlPointsNV(GLenum target, GLuint index, GLenum type, GLsizei ustride, GLsizei vstride, GLboolean packed, void * points);</para>
        /// </summary>
        public unsafe static void GetMapControlPointsNV(uint target, uint index, uint type, int ustride, int vstride, bool packed, IntPtr points) {
            GLNative.glGetMapControlPointsNV(target, index, type, ustride, vstride, packed, (void*)points);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_evaluators</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetMapParameterivNV(GLenum target, GLenum pname, GLint * params);</para>
        /// </summary>
        public unsafe static void GetMapParameterivNV(uint target, uint pname, ref int ps) {
            fixed (int* pPs = &ps) {
                GLNative.glGetMapParameterivNV(target, pname, pPs);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_evaluators</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetMapParameterfvNV(GLenum target, GLenum pname, GLfloat * params);</para>
        /// </summary>
        public unsafe static void GetMapParameterfvNV(uint target, uint pname, ref float ps) {
            fixed (float* pPs = &ps) {
                GLNative.glGetMapParameterfvNV(target, pname, pPs);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_evaluators</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetMapAttribParameterivNV(GLenum target, GLuint index, GLenum pname, GLint * params);</para>
        /// </summary>
        public unsafe static void GetMapAttribParameterivNV(uint target, uint index, uint pname, ref int ps) {
            fixed (int* pPs = &ps) {
                GLNative.glGetMapAttribParameterivNV(target, index, pname, pPs);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_evaluators</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetMapAttribParameterfvNV(GLenum target, GLuint index, GLenum pname, GLfloat * params);</para>
        /// </summary>
        public unsafe static void GetMapAttribParameterfvNV(uint target, uint index, uint pname, ref float ps) {
            fixed (float* pPs = &ps) {
                GLNative.glGetMapAttribParameterfvNV(target, index, pname, pPs);
            }
        }


        #endregion GL_NV_evaluators

        #region GL_NV_explicit_multisample

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_explicit_multisample</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetMultisamplefvNV(GLenum pname, GLuint index, GLfloat * val);</para>
        /// </summary>
        public unsafe static void GetMultisamplefvNV(uint pname, uint index, ref float val) {
            fixed (float* pVal = &val) {
                GLNative.glGetMultisamplefvNV(pname, index, pVal);
            }
        }


        #endregion GL_NV_explicit_multisample

        #region GL_NV_fence

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_fence</para>
        /// Supported: <para>gl, gles1, gles2</para>
        /// Original: <para>void glDeleteFencesNV(GLsizei n, const GLuint * fences);</para>
        /// </summary>
        public unsafe static void DeleteFencesNV(int n, ref uint fences) {
            fixed (uint* pFences = &fences) {
                GLNative.glDeleteFencesNV(n, pFences);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_fence</para>
        /// Supported: <para>gl, gles1, gles2</para>
        /// Original: <para>void glGenFencesNV(GLsizei n, GLuint * fences);</para>
        /// </summary>
        public unsafe static void GenFencesNV(int n, ref uint fences) {
            fixed (uint* pFences = &fences) {
                GLNative.glGenFencesNV(n, pFences);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_fence</para>
        /// Supported: <para>gl, gles1, gles2</para>
        /// Original: <para>void glGetFenceivNV(GLuint fence, GLenum pname, GLint * params);</para>
        /// </summary>
        public unsafe static void GetFenceivNV(uint fence, uint pname, ref int ps) {
            fixed (int* pPs = &ps) {
                GLNative.glGetFenceivNV(fence, pname, pPs);
            }
        }


        #endregion GL_NV_fence

        #region GL_NV_fragment_coverage_to_color


        #endregion GL_NV_fragment_coverage_to_color

        #region GL_NV_framebuffer_mixed_samples

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_framebuffer_mixed_samples</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glCoverageModulationTableNV(GLsizei n, const GLfloat * v);</para>
        /// </summary>
        public unsafe static void CoverageModulationTableNV(int n, ref float v) {
            fixed (float* pV = &v) {
                GLNative.glCoverageModulationTableNV(n, pV);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_framebuffer_mixed_samples</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glGetCoverageModulationTableNV(GLsizei bufSize, GLfloat * v);</para>
        /// </summary>
        public unsafe static void GetCoverageModulationTableNV(int bufSize, ref float v) {
            fixed (float* pV = &v) {
                GLNative.glGetCoverageModulationTableNV(bufSize, pV);
            }
        }


        #endregion GL_NV_framebuffer_mixed_samples

        #region GL_NV_framebuffer_multisample_coverage


        #endregion GL_NV_framebuffer_multisample_coverage

        #region GL_NV_geometry_program4


        #endregion GL_NV_geometry_program4

        #region GL_NV_gpu_program4

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_gpu_program4</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glProgramLocalParameterI4ivNV(GLenum target, GLuint index, const GLint * params);</para>
        /// </summary>
        public unsafe static void ProgramLocalParameterI4ivNV(uint target, uint index, ref int ps) {
            fixed (int* pPs = &ps) {
                GLNative.glProgramLocalParameterI4ivNV(target, index, pPs);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_gpu_program4</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glProgramLocalParametersI4ivNV(GLenum target, GLuint index, GLsizei count, const GLint * params);</para>
        /// </summary>
        public unsafe static void ProgramLocalParametersI4ivNV(uint target, uint index, int count, ref int ps) {
            fixed (int* pPs = &ps) {
                GLNative.glProgramLocalParametersI4ivNV(target, index, count, pPs);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_gpu_program4</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glProgramLocalParameterI4uivNV(GLenum target, GLuint index, const GLuint * params);</para>
        /// </summary>
        public unsafe static void ProgramLocalParameterI4uivNV(uint target, uint index, ref uint ps) {
            fixed (uint* pPs = &ps) {
                GLNative.glProgramLocalParameterI4uivNV(target, index, pPs);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_gpu_program4</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glProgramLocalParametersI4uivNV(GLenum target, GLuint index, GLsizei count, const GLuint * params);</para>
        /// </summary>
        public unsafe static void ProgramLocalParametersI4uivNV(uint target, uint index, int count, ref uint ps) {
            fixed (uint* pPs = &ps) {
                GLNative.glProgramLocalParametersI4uivNV(target, index, count, pPs);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_gpu_program4</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glProgramEnvParameterI4ivNV(GLenum target, GLuint index, const GLint * params);</para>
        /// </summary>
        public unsafe static void ProgramEnvParameterI4ivNV(uint target, uint index, ref int ps) {
            fixed (int* pPs = &ps) {
                GLNative.glProgramEnvParameterI4ivNV(target, index, pPs);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_gpu_program4</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glProgramEnvParametersI4ivNV(GLenum target, GLuint index, GLsizei count, const GLint * params);</para>
        /// </summary>
        public unsafe static void ProgramEnvParametersI4ivNV(uint target, uint index, int count, ref int ps) {
            fixed (int* pPs = &ps) {
                GLNative.glProgramEnvParametersI4ivNV(target, index, count, pPs);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_gpu_program4</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glProgramEnvParameterI4uivNV(GLenum target, GLuint index, const GLuint * params);</para>
        /// </summary>
        public unsafe static void ProgramEnvParameterI4uivNV(uint target, uint index, ref uint ps) {
            fixed (uint* pPs = &ps) {
                GLNative.glProgramEnvParameterI4uivNV(target, index, pPs);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_gpu_program4</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glProgramEnvParametersI4uivNV(GLenum target, GLuint index, GLsizei count, const GLuint * params);</para>
        /// </summary>
        public unsafe static void ProgramEnvParametersI4uivNV(uint target, uint index, int count, ref uint ps) {
            fixed (uint* pPs = &ps) {
                GLNative.glProgramEnvParametersI4uivNV(target, index, count, pPs);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_gpu_program4</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetProgramLocalParameterIivNV(GLenum target, GLuint index, GLint * params);</para>
        /// </summary>
        public unsafe static void GetProgramLocalParameterIivNV(uint target, uint index, ref int ps) {
            fixed (int* pPs = &ps) {
                GLNative.glGetProgramLocalParameterIivNV(target, index, pPs);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_gpu_program4</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetProgramLocalParameterIuivNV(GLenum target, GLuint index, GLuint * params);</para>
        /// </summary>
        public unsafe static void GetProgramLocalParameterIuivNV(uint target, uint index, ref uint ps) {
            fixed (uint* pPs = &ps) {
                GLNative.glGetProgramLocalParameterIuivNV(target, index, pPs);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_gpu_program4</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetProgramEnvParameterIivNV(GLenum target, GLuint index, GLint * params);</para>
        /// </summary>
        public unsafe static void GetProgramEnvParameterIivNV(uint target, uint index, ref int ps) {
            fixed (int* pPs = &ps) {
                GLNative.glGetProgramEnvParameterIivNV(target, index, pPs);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_gpu_program4</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetProgramEnvParameterIuivNV(GLenum target, GLuint index, GLuint * params);</para>
        /// </summary>
        public unsafe static void GetProgramEnvParameterIuivNV(uint target, uint index, ref uint ps) {
            fixed (uint* pPs = &ps) {
                GLNative.glGetProgramEnvParameterIuivNV(target, index, pPs);
            }
        }


        #endregion GL_NV_gpu_program4

        #region GL_NV_gpu_program5

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_gpu_program5</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glProgramSubroutineParametersuivNV(GLenum target, GLsizei count, const GLuint * params);</para>
        /// </summary>
        public unsafe static void ProgramSubroutineParametersuivNV(uint target, int count, ref uint ps) {
            fixed (uint* pPs = &ps) {
                GLNative.glProgramSubroutineParametersuivNV(target, count, pPs);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_gpu_program5</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetProgramSubroutineParameteruivNV(GLenum target, GLuint index, GLuint * param);</para>
        /// </summary>
        public unsafe static void GetProgramSubroutineParameteruivNV(uint target, uint index, ref uint param) {
            fixed (uint* pParam = &param) {
                GLNative.glGetProgramSubroutineParameteruivNV(target, index, pParam);
            }
        }


        #endregion GL_NV_gpu_program5

        #region GL_NV_gpu_shader5

        // void glUniform1i64vNV(GLint location, GLsizei count, const GLint64EXT * value);
        // void glUniform2i64vNV(GLint location, GLsizei count, const GLint64EXT * value);
        // void glUniform3i64vNV(GLint location, GLsizei count, const GLint64EXT * value);
        // void glUniform4i64vNV(GLint location, GLsizei count, const GLint64EXT * value);
        // void glUniform1ui64vNV(GLint location, GLsizei count, const GLuint64EXT * value);
        // void glUniform2ui64vNV(GLint location, GLsizei count, const GLuint64EXT * value);
        // void glUniform3ui64vNV(GLint location, GLsizei count, const GLuint64EXT * value);
        // void glUniform4ui64vNV(GLint location, GLsizei count, const GLuint64EXT * value);
        // void glGetUniformi64vNV(GLuint program, GLint location, GLint64EXT * ps);
        // void glProgramUniform1i64vNV(GLuint program, GLint location, GLsizei count, const GLint64EXT * value);
        // void glProgramUniform2i64vNV(GLuint program, GLint location, GLsizei count, const GLint64EXT * value);
        // void glProgramUniform3i64vNV(GLuint program, GLint location, GLsizei count, const GLint64EXT * value);
        // void glProgramUniform4i64vNV(GLuint program, GLint location, GLsizei count, const GLint64EXT * value);
        // void glProgramUniform1ui64vNV(GLuint program, GLint location, GLsizei count, const GLuint64EXT * value);
        // void glProgramUniform2ui64vNV(GLuint program, GLint location, GLsizei count, const GLuint64EXT * value);
        // void glProgramUniform3ui64vNV(GLuint program, GLint location, GLsizei count, const GLuint64EXT * value);
        // void glProgramUniform4ui64vNV(GLuint program, GLint location, GLsizei count, const GLuint64EXT * value);

        #endregion GL_NV_gpu_shader5

        #region GL_NV_half_float

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_half_float</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertex2hvNV(const GLhalfNV * v);</para>
        /// </summary>
        public unsafe static void Vertex2hvNV(ref ushort v) {
            fixed (ushort* pV = &v) {
                GLNative.glVertex2hvNV(pV);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_half_float</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertex3hvNV(const GLhalfNV * v);</para>
        /// </summary>
        public unsafe static void Vertex3hvNV(ref ushort v) {
            fixed (ushort* pV = &v) {
                GLNative.glVertex3hvNV(pV);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_half_float</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertex4hvNV(const GLhalfNV * v);</para>
        /// </summary>
        public unsafe static void Vertex4hvNV(ref ushort v) {
            fixed (ushort* pV = &v) {
                GLNative.glVertex4hvNV(pV);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_half_float</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glNormal3hvNV(const GLhalfNV * v);</para>
        /// </summary>
        public unsafe static void Normal3hvNV(ref ushort v) {
            fixed (ushort* pV = &v) {
                GLNative.glNormal3hvNV(pV);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_half_float</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glColor3hvNV(const GLhalfNV * v);</para>
        /// </summary>
        public unsafe static void Color3hvNV(ref ushort v) {
            fixed (ushort* pV = &v) {
                GLNative.glColor3hvNV(pV);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_half_float</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glColor4hvNV(const GLhalfNV * v);</para>
        /// </summary>
        public unsafe static void Color4hvNV(ref ushort v) {
            fixed (ushort* pV = &v) {
                GLNative.glColor4hvNV(pV);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_half_float</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glTexCoord1hvNV(const GLhalfNV * v);</para>
        /// </summary>
        public unsafe static void TexCoord1hvNV(ref ushort v) {
            fixed (ushort* pV = &v) {
                GLNative.glTexCoord1hvNV(pV);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_half_float</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glTexCoord2hvNV(const GLhalfNV * v);</para>
        /// </summary>
        public unsafe static void TexCoord2hvNV(ref ushort v) {
            fixed (ushort* pV = &v) {
                GLNative.glTexCoord2hvNV(pV);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_half_float</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glTexCoord3hvNV(const GLhalfNV * v);</para>
        /// </summary>
        public unsafe static void TexCoord3hvNV(ref ushort v) {
            fixed (ushort* pV = &v) {
                GLNative.glTexCoord3hvNV(pV);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_half_float</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glTexCoord4hvNV(const GLhalfNV * v);</para>
        /// </summary>
        public unsafe static void TexCoord4hvNV(ref ushort v) {
            fixed (ushort* pV = &v) {
                GLNative.glTexCoord4hvNV(pV);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_half_float</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glMultiTexCoord1hvNV(GLenum target, const GLhalfNV * v);</para>
        /// </summary>
        public unsafe static void MultiTexCoord1hvNV(uint target, ref ushort v) {
            fixed (ushort* pV = &v) {
                GLNative.glMultiTexCoord1hvNV(target, pV);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_half_float</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glMultiTexCoord2hvNV(GLenum target, const GLhalfNV * v);</para>
        /// </summary>
        public unsafe static void MultiTexCoord2hvNV(uint target, ref ushort v) {
            fixed (ushort* pV = &v) {
                GLNative.glMultiTexCoord2hvNV(target, pV);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_half_float</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glMultiTexCoord3hvNV(GLenum target, const GLhalfNV * v);</para>
        /// </summary>
        public unsafe static void MultiTexCoord3hvNV(uint target, ref ushort v) {
            fixed (ushort* pV = &v) {
                GLNative.glMultiTexCoord3hvNV(target, pV);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_half_float</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glMultiTexCoord4hvNV(GLenum target, const GLhalfNV * v);</para>
        /// </summary>
        public unsafe static void MultiTexCoord4hvNV(uint target, ref ushort v) {
            fixed (ushort* pV = &v) {
                GLNative.glMultiTexCoord4hvNV(target, pV);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_half_float</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glFogCoordhvNV(const GLhalfNV * fog);</para>
        /// </summary>
        public unsafe static void FogCoordhvNV(ref ushort fog) {
            fixed (ushort* pFog = &fog) {
                GLNative.glFogCoordhvNV(pFog);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_half_float</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glSecondaryColor3hvNV(const GLhalfNV * v);</para>
        /// </summary>
        public unsafe static void SecondaryColor3hvNV(ref ushort v) {
            fixed (ushort* pV = &v) {
                GLNative.glSecondaryColor3hvNV(pV);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_half_float</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexWeighthvNV(const GLhalfNV * weight);</para>
        /// </summary>
        public unsafe static void VertexWeighthvNV(ref ushort weight) {
            fixed (ushort* pWeight = &weight) {
                GLNative.glVertexWeighthvNV(pWeight);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_half_float</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexAttrib1hvNV(GLuint index, const GLhalfNV * v);</para>
        /// </summary>
        public unsafe static void VertexAttrib1hvNV(uint index, ref ushort v) {
            fixed (ushort* pV = &v) {
                GLNative.glVertexAttrib1hvNV(index, pV);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_half_float</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexAttrib2hvNV(GLuint index, const GLhalfNV * v);</para>
        /// </summary>
        public unsafe static void VertexAttrib2hvNV(uint index, ref ushort v) {
            fixed (ushort* pV = &v) {
                GLNative.glVertexAttrib2hvNV(index, pV);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_half_float</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexAttrib3hvNV(GLuint index, const GLhalfNV * v);</para>
        /// </summary>
        public unsafe static void VertexAttrib3hvNV(uint index, ref ushort v) {
            fixed (ushort* pV = &v) {
                GLNative.glVertexAttrib3hvNV(index, pV);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_half_float</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexAttrib4hvNV(GLuint index, const GLhalfNV * v);</para>
        /// </summary>
        public unsafe static void VertexAttrib4hvNV(uint index, ref ushort v) {
            fixed (ushort* pV = &v) {
                GLNative.glVertexAttrib4hvNV(index, pV);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_half_float</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexAttribs1hvNV(GLuint index, GLsizei n, const GLhalfNV * v);</para>
        /// </summary>
        public unsafe static void VertexAttribs1hvNV(uint index, int n, ref ushort v) {
            fixed (ushort* pV = &v) {
                GLNative.glVertexAttribs1hvNV(index, n, pV);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_half_float</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexAttribs2hvNV(GLuint index, GLsizei n, const GLhalfNV * v);</para>
        /// </summary>
        public unsafe static void VertexAttribs2hvNV(uint index, int n, ref ushort v) {
            fixed (ushort* pV = &v) {
                GLNative.glVertexAttribs2hvNV(index, n, pV);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_half_float</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexAttribs3hvNV(GLuint index, GLsizei n, const GLhalfNV * v);</para>
        /// </summary>
        public unsafe static void VertexAttribs3hvNV(uint index, int n, ref ushort v) {
            fixed (ushort* pV = &v) {
                GLNative.glVertexAttribs3hvNV(index, n, pV);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_half_float</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexAttribs4hvNV(GLuint index, GLsizei n, const GLhalfNV * v);</para>
        /// </summary>
        public unsafe static void VertexAttribs4hvNV(uint index, int n, ref ushort v) {
            fixed (ushort* pV = &v) {
                GLNative.glVertexAttribs4hvNV(index, n, pV);
            }
        }


        #endregion GL_NV_half_float

        #region GL_NV_internalformat_sample_query

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_internalformat_sample_query</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glGetInternalformatSampleivNV(GLenum target, GLenum internalformat, GLsizei samples, GLenum pname, GLsizei count, GLint * params);</para>
        /// </summary>
        public unsafe static void GetInternalformatSampleivNV(uint target, uint internalformat, int samples, uint pname, int count, ref int ps) {
            fixed (int* pPs = &ps) {
                GLNative.glGetInternalformatSampleivNV(target, internalformat, samples, pname, count, pPs);
            }
        }


        #endregion GL_NV_internalformat_sample_query

        #region GL_NV_gpu_multicast

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_gpu_multicast</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glMulticastBufferSubDataNV(GLbitfield gpuMask, GLuint buffer, GLintptr offset, GLsizeiptr size, const void * data);</para>
        /// </summary>
        public unsafe static void MulticastBufferSubDataNV(uint gpuMask, uint buffer, IntPtr offset, IntPtr size, IntPtr data) {
            GLNative.glMulticastBufferSubDataNV(gpuMask, buffer, offset, size, (void*)data);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_gpu_multicast</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glMulticastFramebufferSampleLocationsfvNV(GLuint gpu, GLuint framebuffer, GLuint start, GLsizei count, const GLfloat * v);</para>
        /// </summary>
        public unsafe static void MulticastFramebufferSampleLocationsfvNV(uint gpu, uint framebuffer, uint start, int count, ref float v) {
            fixed (float* pV = &v) {
                GLNative.glMulticastFramebufferSampleLocationsfvNV(gpu, framebuffer, start, count, pV);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_gpu_multicast</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glMulticastGetQueryObjectivNV(GLuint gpu, GLuint id, GLenum pname, GLint * params);</para>
        /// </summary>
        public unsafe static void MulticastGetQueryObjectivNV(uint gpu, uint id, uint pname, ref int ps) {
            fixed (int* pPs = &ps) {
                GLNative.glMulticastGetQueryObjectivNV(gpu, id, pname, pPs);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_gpu_multicast</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glMulticastGetQueryObjectuivNV(GLuint gpu, GLuint id, GLenum pname, GLuint * params);</para>
        /// </summary>
        public unsafe static void MulticastGetQueryObjectuivNV(uint gpu, uint id, uint pname, ref uint ps) {
            fixed (uint* pPs = &ps) {
                GLNative.glMulticastGetQueryObjectuivNV(gpu, id, pname, pPs);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_gpu_multicast</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glMulticastGetQueryObjecti64vNV(GLuint gpu, GLuint id, GLenum pname, GLint64 * params);</para>
        /// </summary>
        public unsafe static void MulticastGetQueryObjecti64vNV(uint gpu, uint id, uint pname, ref UInt64 ps) {
            fixed (UInt64* pPs = &ps) {
                GLNative.glMulticastGetQueryObjecti64vNV(gpu, id, pname, pPs);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_gpu_multicast</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glMulticastGetQueryObjectui64vNV(GLuint gpu, GLuint id, GLenum pname, GLuint64 * params);</para>
        /// </summary>
        public unsafe static void MulticastGetQueryObjectui64vNV(uint gpu, uint id, uint pname, ref UInt64 ps) {
            fixed (UInt64* pPs = &ps) {
                GLNative.glMulticastGetQueryObjectui64vNV(gpu, id, pname, pPs);
            }
        }


        #endregion GL_NV_gpu_multicast

        #region GL_NVX_gpu_multicast2

        /// <summary>
        /// <para>Require:</para> <para>GL_NVX_gpu_multicast2</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glMulticastViewportArrayvNVX(GLuint gpu, GLuint first, GLsizei count, const GLfloat * v);</para>
        /// </summary>
        public unsafe static void MulticastViewportArrayvNVX(uint gpu, uint first, int count, ref float v) {
            fixed (float* pV = &v) {
                GLNative.glMulticastViewportArrayvNVX(gpu, first, count, pV);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NVX_gpu_multicast2</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glMulticastScissorArrayvNVX(GLuint gpu, GLuint first, GLsizei count, const GLint * v);</para>
        /// </summary>
        public unsafe static void MulticastScissorArrayvNVX(uint gpu, uint first, int count, ref int v) {
            fixed (int* pV = &v) {
                GLNative.glMulticastScissorArrayvNVX(gpu, first, count, pV);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NVX_gpu_multicast2</para>
        /// Supported: <para>gl</para>
        /// Original: <para>GLuint glAsyncCopyBufferSubDataNVX(GLsizei waitSemaphoreCount, const GLuint * waitSemaphoreArray, const GLuint64 * fenceValueArray, GLuint readGpu, GLbitfield writeGpuMask, GLuint readBuffer, GLuint writeBuffer, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size, GLsizei signalSemaphoreCount, const GLuint * signalSemaphoreArray, const GLuint64 * signalValueArray);</para>
        /// </summary>
        public unsafe static uint AsyncCopyBufferSubDataNVX(int waitSemaphoreCount, ref uint waitSemaphoreArray, ref UInt64 fenceValueArray, uint readGpu, uint writeGpuMask, uint readBuffer, uint writeBuffer, IntPtr readOffset, IntPtr writeOffset, IntPtr size, int signalSemaphoreCount, ref uint signalSemaphoreArray, ref UInt64 signalValueArray) {
            fixed (uint* pWaitSemaphoreArray = &waitSemaphoreArray)
            fixed (UInt64* pFenceValueArray = &fenceValueArray)
            fixed (uint* pSignalSemaphoreArray = &signalSemaphoreArray)
            fixed (UInt64* pSignalValueArray = &signalValueArray) {
                return GLNative.glAsyncCopyBufferSubDataNVX(waitSemaphoreCount, pWaitSemaphoreArray, pFenceValueArray, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, pSignalSemaphoreArray, pSignalValueArray);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NVX_gpu_multicast2</para>
        /// Supported: <para>gl</para>
        /// Original: <para>GLuint glAsyncCopyImageSubDataNVX(GLsizei waitSemaphoreCount, const GLuint * waitSemaphoreArray, const GLuint64 * waitValueArray, GLuint srcGpu, GLbitfield dstGpuMask, GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei srcWidth, GLsizei srcHeight, GLsizei srcDepth, GLsizei signalSemaphoreCount, const GLuint * signalSemaphoreArray, const GLuint64 * signalValueArray);</para>
        /// </summary>
        public unsafe static uint AsyncCopyImageSubDataNVX(int waitSemaphoreCount, ref uint waitSemaphoreArray, ref UInt64 waitValueArray, uint srcGpu, uint dstGpuMask, uint srcName, uint srcTarget, int srcLevel, int srcX, int srcY, int srcZ, uint dstName, uint dstTarget, int dstLevel, int dstX, int dstY, int dstZ, int srcWidth, int srcHeight, int srcDepth, int signalSemaphoreCount, ref uint signalSemaphoreArray, ref UInt64 signalValueArray) {
            fixed (uint* pWaitSemaphoreArray = &waitSemaphoreArray)
            fixed (UInt64* pWaitValueArray = &waitValueArray)
            fixed (uint* pSignalSemaphoreArray = &signalSemaphoreArray)
            fixed (UInt64* pSignalValueArray = &signalValueArray) {
                return GLNative.glAsyncCopyImageSubDataNVX(waitSemaphoreCount, pWaitSemaphoreArray, pWaitValueArray, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, pSignalSemaphoreArray, pSignalValueArray);
            }
        }


        #endregion GL_NVX_gpu_multicast2

        #region GL_NVX_progress_fence

        /// <summary>
        /// <para>Require:</para> <para>GL_NVX_progress_fence</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glSignalSemaphoreui64NVX(GLuint signalGpu, GLsizei fenceObjectCount, const GLuint * semaphoreArray, const GLuint64 * fenceValueArray);</para>
        /// </summary>
        public unsafe static void SignalSemaphoreui64NVX(uint signalGpu, int fenceObjectCount, ref uint semaphoreArray, ref UInt64 fenceValueArray) {
            fixed (uint* pSemaphoreArray = &semaphoreArray)
            fixed (UInt64* pFenceValueArray = &fenceValueArray) {
                GLNative.glSignalSemaphoreui64NVX(signalGpu, fenceObjectCount, pSemaphoreArray, pFenceValueArray);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NVX_progress_fence</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glWaitSemaphoreui64NVX(GLuint waitGpu, GLsizei fenceObjectCount, const GLuint * semaphoreArray, const GLuint64 * fenceValueArray);</para>
        /// </summary>
        public unsafe static void WaitSemaphoreui64NVX(uint waitGpu, int fenceObjectCount, ref uint semaphoreArray, ref UInt64 fenceValueArray) {
            fixed (uint* pSemaphoreArray = &semaphoreArray)
            fixed (UInt64* pFenceValueArray = &fenceValueArray) {
                GLNative.glWaitSemaphoreui64NVX(waitGpu, fenceObjectCount, pSemaphoreArray, pFenceValueArray);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NVX_progress_fence</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glClientWaitSemaphoreui64NVX(GLsizei fenceObjectCount, const GLuint * semaphoreArray, const GLuint64 * fenceValueArray);</para>
        /// </summary>
        public unsafe static void ClientWaitSemaphoreui64NVX(int fenceObjectCount, ref uint semaphoreArray, ref UInt64 fenceValueArray) {
            fixed (uint* pSemaphoreArray = &semaphoreArray)
            fixed (UInt64* pFenceValueArray = &fenceValueArray) {
                GLNative.glClientWaitSemaphoreui64NVX(fenceObjectCount, pSemaphoreArray, pFenceValueArray);
            }
        }


        #endregion GL_NVX_progress_fence

        #region GL_NV_memory_attachment

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_memory_attachment</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glGetMemoryObjectDetachedResourcesuivNV(GLuint memory, GLenum pname, GLint first, GLsizei count, GLuint * params);</para>
        /// </summary>
        public unsafe static void GetMemoryObjectDetachedResourcesuivNV(uint memory, uint pname, int first, int count, ref uint ps) {
            fixed (uint* pPs = &ps) {
                GLNative.glGetMemoryObjectDetachedResourcesuivNV(memory, pname, first, count, pPs);
            }
        }


        #endregion GL_NV_memory_attachment

        #region GL_NV_memory_object_sparse


        #endregion GL_NV_memory_object_sparse

        #region GL_NV_mesh_shader


        #endregion GL_NV_mesh_shader

        #region GL_NV_occlusion_query

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_occlusion_query</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGenOcclusionQueriesNV(GLsizei n, GLuint * ids);</para>
        /// </summary>
        public unsafe static void GenOcclusionQueriesNV(int n, ref uint ids) {
            fixed (uint* pIds = &ids) {
                GLNative.glGenOcclusionQueriesNV(n, pIds);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_occlusion_query</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glDeleteOcclusionQueriesNV(GLsizei n, const GLuint * ids);</para>
        /// </summary>
        public unsafe static void DeleteOcclusionQueriesNV(int n, ref uint ids) {
            fixed (uint* pIds = &ids) {
                GLNative.glDeleteOcclusionQueriesNV(n, pIds);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_occlusion_query</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetOcclusionQueryivNV(GLuint id, GLenum pname, GLint * params);</para>
        /// </summary>
        public unsafe static void GetOcclusionQueryivNV(uint id, uint pname, ref int ps) {
            fixed (int* pPs = &ps) {
                GLNative.glGetOcclusionQueryivNV(id, pname, pPs);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_occlusion_query</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetOcclusionQueryuivNV(GLuint id, GLenum pname, GLuint * params);</para>
        /// </summary>
        public unsafe static void GetOcclusionQueryuivNV(uint id, uint pname, ref uint ps) {
            fixed (uint* pPs = &ps) {
                GLNative.glGetOcclusionQueryuivNV(id, pname, pPs);
            }
        }


        #endregion GL_NV_occlusion_query

        #region GL_NV_parameter_buffer_object

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_parameter_buffer_object</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glProgramBufferParametersfvNV(GLenum target, GLuint bindingIndex, GLuint wordIndex, GLsizei count, const GLfloat * params);</para>
        /// </summary>
        public unsafe static void ProgramBufferParametersfvNV(uint target, uint bindingIndex, uint wordIndex, int count, ref float ps) {
            fixed (float* pPs = &ps) {
                GLNative.glProgramBufferParametersfvNV(target, bindingIndex, wordIndex, count, pPs);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_parameter_buffer_object</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glProgramBufferParametersIivNV(GLenum target, GLuint bindingIndex, GLuint wordIndex, GLsizei count, const GLint * params);</para>
        /// </summary>
        public unsafe static void ProgramBufferParametersIivNV(uint target, uint bindingIndex, uint wordIndex, int count, ref int ps) {
            fixed (int* pPs = &ps) {
                GLNative.glProgramBufferParametersIivNV(target, bindingIndex, wordIndex, count, pPs);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_parameter_buffer_object</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glProgramBufferParametersIuivNV(GLenum target, GLuint bindingIndex, GLuint wordIndex, GLsizei count, const GLuint * params);</para>
        /// </summary>
        public unsafe static void ProgramBufferParametersIuivNV(uint target, uint bindingIndex, uint wordIndex, int count, ref uint ps) {
            fixed (uint* pPs = &ps) {
                GLNative.glProgramBufferParametersIuivNV(target, bindingIndex, wordIndex, count, pPs);
            }
        }


        #endregion GL_NV_parameter_buffer_object

        #region GL_NV_path_rendering

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_path_rendering</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glPathCommandsNV(GLuint path, GLsizei numCommands, const GLubyte * commands, GLsizei numCoords, GLenum coordType, const void * coords);</para>
        /// </summary>
        public unsafe static void PathCommandsNV(uint path, int numCommands, ref byte commands, int numCoords, uint coordType, IntPtr coords) {
            fixed (byte* pCommands = &commands) {
                GLNative.glPathCommandsNV(path, numCommands, pCommands, numCoords, coordType, (void*)coords);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_path_rendering</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glPathCoordsNV(GLuint path, GLsizei numCoords, GLenum coordType, const void * coords);</para>
        /// </summary>
        public unsafe static void PathCoordsNV(uint path, int numCoords, uint coordType, IntPtr coords) {
            GLNative.glPathCoordsNV(path, numCoords, coordType, (void*)coords);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_path_rendering</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glPathSubCommandsNV(GLuint path, GLsizei commandStart, GLsizei commandsToDelete, GLsizei numCommands, const GLubyte * commands, GLsizei numCoords, GLenum coordType, const void * coords);</para>
        /// </summary>
        public unsafe static void PathSubCommandsNV(uint path, int commandStart, int commandsToDelete, int numCommands, ref byte commands, int numCoords, uint coordType, IntPtr coords) {
            fixed (byte* pCommands = &commands) {
                GLNative.glPathSubCommandsNV(path, commandStart, commandsToDelete, numCommands, pCommands, numCoords, coordType, (void*)coords);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_path_rendering</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glPathSubCoordsNV(GLuint path, GLsizei coordStart, GLsizei numCoords, GLenum coordType, const void * coords);</para>
        /// </summary>
        public unsafe static void PathSubCoordsNV(uint path, int coordStart, int numCoords, uint coordType, IntPtr coords) {
            GLNative.glPathSubCoordsNV(path, coordStart, numCoords, coordType, (void*)coords);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_path_rendering</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glPathStringNV(GLuint path, GLenum format, GLsizei length, const void * pathString);</para>
        /// </summary>
        public unsafe static void PathStringNV(uint path, uint format, int length, IntPtr pathString) {
            GLNative.glPathStringNV(path, format, length, (void*)pathString);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_path_rendering</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glPathGlyphsNV(GLuint firstPathName, GLenum fontTarget, const void * fontName, GLbitfield fontStyle, GLsizei numGlyphs, GLenum type, const void * charcodes, GLenum handleMissingGlyphs, GLuint pathParameterTemplate, GLfloat emScale);</para>
        /// </summary>
        public unsafe static void PathGlyphsNV(uint firstPathName, uint fontTarget, IntPtr fontName, uint fontStyle, int numGlyphs, uint type, IntPtr charcodes, uint handleMissingGlyphs, uint pathParameterTemplate, float emScale) {
            GLNative.glPathGlyphsNV(firstPathName, fontTarget, (void*)fontName, fontStyle, numGlyphs, type, (void*)charcodes, handleMissingGlyphs, pathParameterTemplate, emScale);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_path_rendering</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glPathGlyphRangeNV(GLuint firstPathName, GLenum fontTarget, const void * fontName, GLbitfield fontStyle, GLuint firstGlyph, GLsizei numGlyphs, GLenum handleMissingGlyphs, GLuint pathParameterTemplate, GLfloat emScale);</para>
        /// </summary>
        public unsafe static void PathGlyphRangeNV(uint firstPathName, uint fontTarget, IntPtr fontName, uint fontStyle, uint firstGlyph, int numGlyphs, uint handleMissingGlyphs, uint pathParameterTemplate, float emScale) {
            GLNative.glPathGlyphRangeNV(firstPathName, fontTarget, (void*)fontName, fontStyle, firstGlyph, numGlyphs, handleMissingGlyphs, pathParameterTemplate, emScale);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_path_rendering</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glWeightPathsNV(GLuint resultPath, GLsizei numPaths, const GLuint * paths, const GLfloat * weights);</para>
        /// </summary>
        public unsafe static void WeightPathsNV(uint resultPath, int numPaths, ref uint paths, ref float weights) {
            fixed (uint* pPaths = &paths)
            fixed (float* pWeights = &weights) {
                GLNative.glWeightPathsNV(resultPath, numPaths, pPaths, pWeights);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_path_rendering</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glTransformPathNV(GLuint resultPath, GLuint srcPath, GLenum transformType, const GLfloat * transformValues);</para>
        /// </summary>
        public unsafe static void TransformPathNV(uint resultPath, uint srcPath, uint transformType, ref float transformValues) {
            fixed (float* pTransformValues = &transformValues) {
                GLNative.glTransformPathNV(resultPath, srcPath, transformType, pTransformValues);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_path_rendering</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glPathParameterivNV(GLuint path, GLenum pname, const GLint * value);</para>
        /// </summary>
        public unsafe static void PathParameterivNV(uint path, uint pname, ref int value) {
            fixed (int* pValue = &value) {
                GLNative.glPathParameterivNV(path, pname, pValue);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_path_rendering</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glPathParameterfvNV(GLuint path, GLenum pname, const GLfloat * value);</para>
        /// </summary>
        public unsafe static void PathParameterfvNV(uint path, uint pname, ref float value) {
            fixed (float* pValue = &value) {
                GLNative.glPathParameterfvNV(path, pname, pValue);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_path_rendering</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glPathDashArrayNV(GLuint path, GLsizei dashCount, const GLfloat * dashArray);</para>
        /// </summary>
        public unsafe static void PathDashArrayNV(uint path, int dashCount, ref float dashArray) {
            fixed (float* pDashArray = &dashArray) {
                GLNative.glPathDashArrayNV(path, dashCount, pDashArray);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_path_rendering</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glStencilFillPathInstancedNV(GLsizei numPaths, GLenum pathNameType, const void * paths, GLuint pathBase, GLenum fillMode, GLuint mask, GLenum transformType, const GLfloat * transformValues);</para>
        /// </summary>
        public unsafe static void StencilFillPathInstancedNV(int numPaths, uint pathNameType, IntPtr paths, uint pathBase, uint fillMode, uint mask, uint transformType, ref float transformValues) {
            fixed (float* pTransformValues = &transformValues) {
                GLNative.glStencilFillPathInstancedNV(numPaths, pathNameType, (void*)paths, pathBase, fillMode, mask, transformType, pTransformValues);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_path_rendering</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glStencilStrokePathInstancedNV(GLsizei numPaths, GLenum pathNameType, const void * paths, GLuint pathBase, GLint reference, GLuint mask, GLenum transformType, const GLfloat * transformValues);</para>
        /// </summary>
        public unsafe static void StencilStrokePathInstancedNV(int numPaths, uint pathNameType, IntPtr paths, uint pathBase, int reference, uint mask, uint transformType, ref float transformValues) {
            fixed (float* pTransformValues = &transformValues) {
                GLNative.glStencilStrokePathInstancedNV(numPaths, pathNameType, (void*)paths, pathBase, reference, mask, transformType, pTransformValues);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_path_rendering</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glCoverFillPathInstancedNV(GLsizei numPaths, GLenum pathNameType, const void * paths, GLuint pathBase, GLenum coverMode, GLenum transformType, const GLfloat * transformValues);</para>
        /// </summary>
        public unsafe static void CoverFillPathInstancedNV(int numPaths, uint pathNameType, IntPtr paths, uint pathBase, uint coverMode, uint transformType, ref float transformValues) {
            fixed (float* pTransformValues = &transformValues) {
                GLNative.glCoverFillPathInstancedNV(numPaths, pathNameType, (void*)paths, pathBase, coverMode, transformType, pTransformValues);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_path_rendering</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glCoverStrokePathInstancedNV(GLsizei numPaths, GLenum pathNameType, const void * paths, GLuint pathBase, GLenum coverMode, GLenum transformType, const GLfloat * transformValues);</para>
        /// </summary>
        public unsafe static void CoverStrokePathInstancedNV(int numPaths, uint pathNameType, IntPtr paths, uint pathBase, uint coverMode, uint transformType, ref float transformValues) {
            fixed (float* pTransformValues = &transformValues) {
                GLNative.glCoverStrokePathInstancedNV(numPaths, pathNameType, (void*)paths, pathBase, coverMode, transformType, pTransformValues);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_path_rendering</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glGetPathParameterivNV(GLuint path, GLenum pname, GLint * value);</para>
        /// </summary>
        public unsafe static void GetPathParameterivNV(uint path, uint pname, ref int value) {
            fixed (int* pValue = &value) {
                GLNative.glGetPathParameterivNV(path, pname, pValue);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_path_rendering</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glGetPathParameterfvNV(GLuint path, GLenum pname, GLfloat * value);</para>
        /// </summary>
        public unsafe static void GetPathParameterfvNV(uint path, uint pname, ref float value) {
            fixed (float* pValue = &value) {
                GLNative.glGetPathParameterfvNV(path, pname, pValue);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_path_rendering</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glGetPathCommandsNV(GLuint path, GLubyte * commands);</para>
        /// </summary>
        public unsafe static void GetPathCommandsNV(uint path, ref byte commands) {
            fixed (byte* pCommands = &commands) {
                GLNative.glGetPathCommandsNV(path, pCommands);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_path_rendering</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glGetPathCoordsNV(GLuint path, GLfloat * coords);</para>
        /// </summary>
        public unsafe static void GetPathCoordsNV(uint path, ref float coords) {
            fixed (float* pCoords = &coords) {
                GLNative.glGetPathCoordsNV(path, pCoords);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_path_rendering</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glGetPathDashArrayNV(GLuint path, GLfloat * dashArray);</para>
        /// </summary>
        public unsafe static void GetPathDashArrayNV(uint path, ref float dashArray) {
            fixed (float* pDashArray = &dashArray) {
                GLNative.glGetPathDashArrayNV(path, pDashArray);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_path_rendering</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glGetPathMetricsNV(GLbitfield metricQueryMask, GLsizei numPaths, GLenum pathNameType, const void * paths, GLuint pathBase, GLsizei stride, GLfloat * metrics);</para>
        /// </summary>
        public unsafe static void GetPathMetricsNV(uint metricQueryMask, int numPaths, uint pathNameType, IntPtr paths, uint pathBase, int stride, ref float metrics) {
            fixed (float* pMetrics = &metrics) {
                GLNative.glGetPathMetricsNV(metricQueryMask, numPaths, pathNameType, (void*)paths, pathBase, stride, pMetrics);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_path_rendering</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glGetPathMetricRangeNV(GLbitfield metricQueryMask, GLuint firstPathName, GLsizei numPaths, GLsizei stride, GLfloat * metrics);</para>
        /// </summary>
        public unsafe static void GetPathMetricRangeNV(uint metricQueryMask, uint firstPathName, int numPaths, int stride, ref float metrics) {
            fixed (float* pMetrics = &metrics) {
                GLNative.glGetPathMetricRangeNV(metricQueryMask, firstPathName, numPaths, stride, pMetrics);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_path_rendering</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glGetPathSpacingNV(GLenum pathListMode, GLsizei numPaths, GLenum pathNameType, const void * paths, GLuint pathBase, GLfloat advanceScale, GLfloat kerningScale, GLenum transformType, GLfloat * returnedSpacing);</para>
        /// </summary>
        public unsafe static void GetPathSpacingNV(uint pathListMode, int numPaths, uint pathNameType, IntPtr paths, uint pathBase, float advanceScale, float kerningScale, uint transformType, ref float returnedSpacing) {
            fixed (float* pReturnedSpacing = &returnedSpacing) {
                GLNative.glGetPathSpacingNV(pathListMode, numPaths, pathNameType, (void*)paths, pathBase, advanceScale, kerningScale, transformType, pReturnedSpacing);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_path_rendering</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>GLboolean glPointAlongPathNV(GLuint path, GLsizei startSegment, GLsizei numSegments, GLfloat distance, GLfloat * x, GLfloat * y, GLfloat * tangentX, GLfloat * tangentY);</para>
        /// </summary>
        public unsafe static bool PointAlongPathNV(uint path, int startSegment, int numSegments, float distance, ref float x, ref float y, ref float tangentX, ref float tangentY) {
            fixed (float* pX = &x)
            fixed (float* pY = &y)
            fixed (float* pTangentX = &tangentX)
            fixed (float* pTangentY = &tangentY) {
                return GLNative.glPointAlongPathNV(path, startSegment, numSegments, distance, pX, pY, pTangentX, pTangentY);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_path_rendering</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glMatrixLoad3x2fNV(GLenum matrixMode, const GLfloat * m);</para>
        /// </summary>
        public unsafe static void MatrixLoad3x2fNV(uint matrixMode, ref float m) {
            fixed (float* pM = &m) {
                GLNative.glMatrixLoad3x2fNV(matrixMode, pM);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_path_rendering</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glMatrixLoad3x3fNV(GLenum matrixMode, const GLfloat * m);</para>
        /// </summary>
        public unsafe static void MatrixLoad3x3fNV(uint matrixMode, ref float m) {
            fixed (float* pM = &m) {
                GLNative.glMatrixLoad3x3fNV(matrixMode, pM);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_path_rendering</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glMatrixLoadTranspose3x3fNV(GLenum matrixMode, const GLfloat * m);</para>
        /// </summary>
        public unsafe static void MatrixLoadTranspose3x3fNV(uint matrixMode, ref float m) {
            fixed (float* pM = &m) {
                GLNative.glMatrixLoadTranspose3x3fNV(matrixMode, pM);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_path_rendering</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glMatrixMult3x2fNV(GLenum matrixMode, const GLfloat * m);</para>
        /// </summary>
        public unsafe static void MatrixMult3x2fNV(uint matrixMode, ref float m) {
            fixed (float* pM = &m) {
                GLNative.glMatrixMult3x2fNV(matrixMode, pM);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_path_rendering</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glMatrixMult3x3fNV(GLenum matrixMode, const GLfloat * m);</para>
        /// </summary>
        public unsafe static void MatrixMult3x3fNV(uint matrixMode, ref float m) {
            fixed (float* pM = &m) {
                GLNative.glMatrixMult3x3fNV(matrixMode, pM);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_path_rendering</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glMatrixMultTranspose3x3fNV(GLenum matrixMode, const GLfloat * m);</para>
        /// </summary>
        public unsafe static void MatrixMultTranspose3x3fNV(uint matrixMode, ref float m) {
            fixed (float* pM = &m) {
                GLNative.glMatrixMultTranspose3x3fNV(matrixMode, pM);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_path_rendering</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glStencilThenCoverFillPathInstancedNV(GLsizei numPaths, GLenum pathNameType, const void * paths, GLuint pathBase, GLenum fillMode, GLuint mask, GLenum coverMode, GLenum transformType, const GLfloat * transformValues);</para>
        /// </summary>
        public unsafe static void StencilThenCoverFillPathInstancedNV(int numPaths, uint pathNameType, IntPtr paths, uint pathBase, uint fillMode, uint mask, uint coverMode, uint transformType, ref float transformValues) {
            fixed (float* pTransformValues = &transformValues) {
                GLNative.glStencilThenCoverFillPathInstancedNV(numPaths, pathNameType, (void*)paths, pathBase, fillMode, mask, coverMode, transformType, pTransformValues);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_path_rendering</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glStencilThenCoverStrokePathInstancedNV(GLsizei numPaths, GLenum pathNameType, const void * paths, GLuint pathBase, GLint reference, GLuint mask, GLenum coverMode, GLenum transformType, const GLfloat * transformValues);</para>
        /// </summary>
        public unsafe static void StencilThenCoverStrokePathInstancedNV(int numPaths, uint pathNameType, IntPtr paths, uint pathBase, int reference, uint mask, uint coverMode, uint transformType, ref float transformValues) {
            fixed (float* pTransformValues = &transformValues) {
                GLNative.glStencilThenCoverStrokePathInstancedNV(numPaths, pathNameType, (void*)paths, pathBase, reference, mask, coverMode, transformType, pTransformValues);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_path_rendering</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>GLenum glPathGlyphIndexRangeNV(GLenum fontTarget, const void * fontName, GLbitfield fontStyle, GLuint pathParameterTemplate, GLfloat emScale, GLuint * baseAndCount);</para>
        /// </summary>
        public unsafe static uint PathGlyphIndexRangeNV(uint fontTarget, IntPtr fontName, uint fontStyle, uint pathParameterTemplate, float emScale, ref uint baseAndCount) {
            fixed (uint* pBaseAndCount = &baseAndCount) {
                return GLNative.glPathGlyphIndexRangeNV(fontTarget, (void*)fontName, fontStyle, pathParameterTemplate, emScale, pBaseAndCount);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_path_rendering</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>GLenum glPathGlyphIndexArrayNV(GLuint firstPathName, GLenum fontTarget, const void * fontName, GLbitfield fontStyle, GLuint firstGlyphIndex, GLsizei numGlyphs, GLuint pathParameterTemplate, GLfloat emScale);</para>
        /// </summary>
        public unsafe static uint PathGlyphIndexArrayNV(uint firstPathName, uint fontTarget, IntPtr fontName, uint fontStyle, uint firstGlyphIndex, int numGlyphs, uint pathParameterTemplate, float emScale) {
            return GLNative.glPathGlyphIndexArrayNV(firstPathName, fontTarget, (void*)fontName, fontStyle, firstGlyphIndex, numGlyphs, pathParameterTemplate, emScale);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_path_rendering</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>GLenum glPathMemoryGlyphIndexArrayNV(GLuint firstPathName, GLenum fontTarget, GLsizeiptr fontSize, const void * fontData, GLsizei faceIndex, GLuint firstGlyphIndex, GLsizei numGlyphs, GLuint pathParameterTemplate, GLfloat emScale);</para>
        /// </summary>
        public unsafe static uint PathMemoryGlyphIndexArrayNV(uint firstPathName, uint fontTarget, IntPtr fontSize, IntPtr fontData, int faceIndex, uint firstGlyphIndex, int numGlyphs, uint pathParameterTemplate, float emScale) {
            return GLNative.glPathMemoryGlyphIndexArrayNV(firstPathName, fontTarget, fontSize, (void*)fontData, faceIndex, firstGlyphIndex, numGlyphs, pathParameterTemplate, emScale);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_path_rendering</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glProgramPathFragmentInputGenNV(GLuint program, GLint location, GLenum genMode, GLint components, const GLfloat * coeffs);</para>
        /// </summary>
        public unsafe static void ProgramPathFragmentInputGenNV(uint program, int location, uint genMode, int components, ref float coeffs) {
            fixed (float* pCoeffs = &coeffs) {
                GLNative.glProgramPathFragmentInputGenNV(program, location, genMode, components, pCoeffs);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_path_rendering</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glGetProgramResourcefvNV(GLuint program, GLenum programInterface, GLuint index, GLsizei propCount, const GLenum * props, GLsizei count, GLsizei * length, GLfloat * params);</para>
        /// </summary>
        public unsafe static void GetProgramResourcefvNV(uint program, uint programInterface, uint index, int propCount, ref uint props, int count, ref int length, ref float ps) {
            fixed (uint* pProps = &props)
            fixed (int* pLength = &length)
            fixed (float* pPs = &ps) {
                GLNative.glGetProgramResourcefvNV(program, programInterface, index, propCount, pProps, count, pLength, pPs);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_path_rendering</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glPathColorGenNV(GLenum color, GLenum genMode, GLenum colorFormat, const GLfloat * coeffs);</para>
        /// </summary>
        public unsafe static void PathColorGenNV(uint color, uint genMode, uint colorFormat, ref float coeffs) {
            fixed (float* pCoeffs = &coeffs) {
                GLNative.glPathColorGenNV(color, genMode, colorFormat, pCoeffs);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_path_rendering</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glPathTexGenNV(GLenum texCoordSet, GLenum genMode, GLint components, const GLfloat * coeffs);</para>
        /// </summary>
        public unsafe static void PathTexGenNV(uint texCoordSet, uint genMode, int components, ref float coeffs) {
            fixed (float* pCoeffs = &coeffs) {
                GLNative.glPathTexGenNV(texCoordSet, genMode, components, pCoeffs);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_path_rendering</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glGetPathColorGenivNV(GLenum color, GLenum pname, GLint * value);</para>
        /// </summary>
        public unsafe static void GetPathColorGenivNV(uint color, uint pname, ref int value) {
            fixed (int* pValue = &value) {
                GLNative.glGetPathColorGenivNV(color, pname, pValue);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_path_rendering</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glGetPathColorGenfvNV(GLenum color, GLenum pname, GLfloat * value);</para>
        /// </summary>
        public unsafe static void GetPathColorGenfvNV(uint color, uint pname, ref float value) {
            fixed (float* pValue = &value) {
                GLNative.glGetPathColorGenfvNV(color, pname, pValue);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_path_rendering</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glGetPathTexGenivNV(GLenum texCoordSet, GLenum pname, GLint * value);</para>
        /// </summary>
        public unsafe static void GetPathTexGenivNV(uint texCoordSet, uint pname, ref int value) {
            fixed (int* pValue = &value) {
                GLNative.glGetPathTexGenivNV(texCoordSet, pname, pValue);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_path_rendering</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glGetPathTexGenfvNV(GLenum texCoordSet, GLenum pname, GLfloat * value);</para>
        /// </summary>
        public unsafe static void GetPathTexGenfvNV(uint texCoordSet, uint pname, ref float value) {
            fixed (float* pValue = &value) {
                GLNative.glGetPathTexGenfvNV(texCoordSet, pname, pValue);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_direct_state_access, GL_NV_path_rendering</para>
        /// Supported: <para>gl, glcore, gl, glcore, gles2</para>
        /// Original: <para>void glMatrixLoadTransposefEXT(GLenum mode, const GLfloat * m);</para>
        /// </summary>
        public unsafe static void MatrixLoadTransposefEXT(uint mode, ref float m) {
            fixed (float* pM = &m) {
                GLNative.glMatrixLoadTransposefEXT(mode, pM);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_direct_state_access, GL_NV_path_rendering</para>
        /// Supported: <para>gl, glcore, gl, glcore, gles2</para>
        /// Original: <para>void glMatrixLoadTransposedEXT(GLenum mode, const GLdouble * m);</para>
        /// </summary>
        public unsafe static void MatrixLoadTransposedEXT(uint mode, ref double m) {
            fixed (double* pM = &m) {
                GLNative.glMatrixLoadTransposedEXT(mode, pM);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_direct_state_access, GL_NV_path_rendering</para>
        /// Supported: <para>gl, glcore, gl, glcore, gles2</para>
        /// Original: <para>void glMatrixLoadfEXT(GLenum mode, const GLfloat * m);</para>
        /// </summary>
        public unsafe static void MatrixLoadfEXT(uint mode, ref float m) {
            fixed (float* pM = &m) {
                GLNative.glMatrixLoadfEXT(mode, pM);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_direct_state_access, GL_NV_path_rendering</para>
        /// Supported: <para>gl, glcore, gl, glcore, gles2</para>
        /// Original: <para>void glMatrixLoaddEXT(GLenum mode, const GLdouble * m);</para>
        /// </summary>
        public unsafe static void MatrixLoaddEXT(uint mode, ref double m) {
            fixed (double* pM = &m) {
                GLNative.glMatrixLoaddEXT(mode, pM);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_direct_state_access, GL_NV_path_rendering</para>
        /// Supported: <para>gl, glcore, gl, glcore, gles2</para>
        /// Original: <para>void glMatrixMultTransposefEXT(GLenum mode, const GLfloat * m);</para>
        /// </summary>
        public unsafe static void MatrixMultTransposefEXT(uint mode, ref float m) {
            fixed (float* pM = &m) {
                GLNative.glMatrixMultTransposefEXT(mode, pM);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_direct_state_access, GL_NV_path_rendering</para>
        /// Supported: <para>gl, glcore, gl, glcore, gles2</para>
        /// Original: <para>void glMatrixMultTransposedEXT(GLenum mode, const GLdouble * m);</para>
        /// </summary>
        public unsafe static void MatrixMultTransposedEXT(uint mode, ref double m) {
            fixed (double* pM = &m) {
                GLNative.glMatrixMultTransposedEXT(mode, pM);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_direct_state_access, GL_NV_path_rendering</para>
        /// Supported: <para>gl, glcore, gl, glcore, gles2</para>
        /// Original: <para>void glMatrixMultfEXT(GLenum mode, const GLfloat * m);</para>
        /// </summary>
        public unsafe static void MatrixMultfEXT(uint mode, ref float m) {
            fixed (float* pM = &m) {
                GLNative.glMatrixMultfEXT(mode, pM);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_direct_state_access, GL_NV_path_rendering</para>
        /// Supported: <para>gl, glcore, gl, glcore, gles2</para>
        /// Original: <para>void glMatrixMultdEXT(GLenum mode, const GLdouble * m);</para>
        /// </summary>
        public unsafe static void MatrixMultdEXT(uint mode, ref double m) {
            fixed (double* pM = &m) {
                GLNative.glMatrixMultdEXT(mode, pM);
            }
        }


        #endregion GL_NV_path_rendering

        #region GL_NV_pixel_data_range

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_pixel_data_range</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glPixelDataRangeNV(GLenum target, GLsizei length, const void * pointer);</para>
        /// </summary>
        public unsafe static void PixelDataRangeNV(uint target, int length, IntPtr pointer) {
            GLNative.glPixelDataRangeNV(target, length, (void*)pointer);
        }


        #endregion GL_NV_pixel_data_range

        #region GL_NV_point_sprite

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_point_sprite</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glPointParameterivNV(GLenum pname, const GLint * params);</para>
        /// </summary>
        public unsafe static void PointParameterivNV(uint pname, ref int ps) {
            fixed (int* pPs = &ps) {
                GLNative.glPointParameterivNV(pname, pPs);
            }
        }


        #endregion GL_NV_point_sprite

        #region GL_NV_present_video

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_present_video</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetVideoivNV(GLuint video_slot, GLenum pname, GLint * params);</para>
        /// </summary>
        public unsafe static void GetVideoivNV(uint video_slot, uint pname, ref int ps) {
            fixed (int* pPs = &ps) {
                GLNative.glGetVideoivNV(video_slot, pname, pPs);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_present_video</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetVideouivNV(GLuint video_slot, GLenum pname, GLuint * params);</para>
        /// </summary>
        public unsafe static void GetVideouivNV(uint video_slot, uint pname, ref uint ps) {
            fixed (uint* pPs = &ps) {
                GLNative.glGetVideouivNV(video_slot, pname, pPs);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_present_video</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetVideoi64vNV(GLuint video_slot, GLenum pname, GLint64EXT * params);</para>
        /// </summary>
        public unsafe static void GetVideoi64vNV(uint video_slot, uint pname, ref Int64 ps) {
            fixed (Int64* pPs = &ps) {
                GLNative.glGetVideoi64vNV(video_slot, pname, pPs);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_present_video</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetVideoui64vNV(GLuint video_slot, GLenum pname, GLuint64EXT * params);</para>
        /// </summary>
        public unsafe static void GetVideoui64vNV(uint video_slot, uint pname, ref UInt64 ps) {
            fixed (UInt64* pPs = &ps) {
                GLNative.glGetVideoui64vNV(video_slot, pname, pPs);
            }
        }


        #endregion GL_NV_present_video

        #region GL_NV_primitive_restart


        #endregion GL_NV_primitive_restart

        #region GL_NV_query_resource

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_query_resource</para>
        /// Supported: <para>gl</para>
        /// Original: <para>GLint glQueryResourceNV(GLenum queryType, GLint tagId, GLuint count, GLint * buffer);</para>
        /// </summary>
        public unsafe static int QueryResourceNV(uint queryType, int tagId, uint count, ref int buffer) {
            fixed (int* pBuffer = &buffer) {
                return GLNative.glQueryResourceNV(queryType, tagId, count, pBuffer);
            }
        }


        #endregion GL_NV_query_resource

        #region GL_NV_query_resource_tag

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_query_resource_tag</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGenQueryResourceTagNV(GLsizei n, GLint * tagIds);</para>
        /// </summary>
        public unsafe static void GenQueryResourceTagNV(int n, ref int tagIds) {
            fixed (int* pTagIds = &tagIds) {
                GLNative.glGenQueryResourceTagNV(n, pTagIds);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_query_resource_tag</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glDeleteQueryResourceTagNV(GLsizei n, const GLint * tagIds);</para>
        /// </summary>
        public unsafe static void DeleteQueryResourceTagNV(int n, ref int tagIds) {
            fixed (int* pTagIds = &tagIds) {
                GLNative.glDeleteQueryResourceTagNV(n, pTagIds);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_query_resource_tag</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glQueryResourceTagNV(GLint tagId, const GLchar * tagString);</para>
        /// </summary>
        public unsafe static void QueryResourceTagNV(int tagId, ref byte tagString) {
            fixed (byte* pTagString = &tagString) {
                GLNative.glQueryResourceTagNV(tagId, pTagString);
            }
        }


        #endregion GL_NV_query_resource_tag

        #region GL_NV_register_combiners

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_register_combiners</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glCombinerParameterfvNV(GLenum pname, const GLfloat * params);</para>
        /// </summary>
        public unsafe static void CombinerParameterfvNV(uint pname, ref float ps) {
            fixed (float* pPs = &ps) {
                GLNative.glCombinerParameterfvNV(pname, pPs);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_register_combiners</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glCombinerParameterivNV(GLenum pname, const GLint * params);</para>
        /// </summary>
        public unsafe static void CombinerParameterivNV(uint pname, ref int ps) {
            fixed (int* pPs = &ps) {
                GLNative.glCombinerParameterivNV(pname, pPs);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_register_combiners</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetCombinerInputParameterfvNV(GLenum stage, GLenum portion, GLenum variable, GLenum pname, GLfloat * params);</para>
        /// </summary>
        public unsafe static void GetCombinerInputParameterfvNV(uint stage, uint portion, uint variable, uint pname, ref float ps) {
            fixed (float* pPs = &ps) {
                GLNative.glGetCombinerInputParameterfvNV(stage, portion, variable, pname, pPs);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_register_combiners</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetCombinerInputParameterivNV(GLenum stage, GLenum portion, GLenum variable, GLenum pname, GLint * params);</para>
        /// </summary>
        public unsafe static void GetCombinerInputParameterivNV(uint stage, uint portion, uint variable, uint pname, ref int ps) {
            fixed (int* pPs = &ps) {
                GLNative.glGetCombinerInputParameterivNV(stage, portion, variable, pname, pPs);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_register_combiners</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetCombinerOutputParameterfvNV(GLenum stage, GLenum portion, GLenum pname, GLfloat * params);</para>
        /// </summary>
        public unsafe static void GetCombinerOutputParameterfvNV(uint stage, uint portion, uint pname, ref float ps) {
            fixed (float* pPs = &ps) {
                GLNative.glGetCombinerOutputParameterfvNV(stage, portion, pname, pPs);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_register_combiners</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetCombinerOutputParameterivNV(GLenum stage, GLenum portion, GLenum pname, GLint * params);</para>
        /// </summary>
        public unsafe static void GetCombinerOutputParameterivNV(uint stage, uint portion, uint pname, ref int ps) {
            fixed (int* pPs = &ps) {
                GLNative.glGetCombinerOutputParameterivNV(stage, portion, pname, pPs);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_register_combiners</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetFinalCombinerInputParameterfvNV(GLenum variable, GLenum pname, GLfloat * params);</para>
        /// </summary>
        public unsafe static void GetFinalCombinerInputParameterfvNV(uint variable, uint pname, ref float ps) {
            fixed (float* pPs = &ps) {
                GLNative.glGetFinalCombinerInputParameterfvNV(variable, pname, pPs);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_register_combiners</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetFinalCombinerInputParameterivNV(GLenum variable, GLenum pname, GLint * params);</para>
        /// </summary>
        public unsafe static void GetFinalCombinerInputParameterivNV(uint variable, uint pname, ref int ps) {
            fixed (int* pPs = &ps) {
                GLNative.glGetFinalCombinerInputParameterivNV(variable, pname, pPs);
            }
        }


        #endregion GL_NV_register_combiners

        #region GL_NV_register_combiners2

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_register_combiners2</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glCombinerStageParameterfvNV(GLenum stage, GLenum pname, const GLfloat * params);</para>
        /// </summary>
        public unsafe static void CombinerStageParameterfvNV(uint stage, uint pname, ref float ps) {
            fixed (float* pPs = &ps) {
                GLNative.glCombinerStageParameterfvNV(stage, pname, pPs);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_register_combiners2</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetCombinerStageParameterfvNV(GLenum stage, GLenum pname, GLfloat * params);</para>
        /// </summary>
        public unsafe static void GetCombinerStageParameterfvNV(uint stage, uint pname, ref float ps) {
            fixed (float* pPs = &ps) {
                GLNative.glGetCombinerStageParameterfvNV(stage, pname, pPs);
            }
        }


        #endregion GL_NV_register_combiners2

        #region GL_NV_sample_locations

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_sample_locations</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glFramebufferSampleLocationsfvNV(GLenum target, GLuint start, GLsizei count, const GLfloat * v);</para>
        /// </summary>
        public unsafe static void FramebufferSampleLocationsfvNV(uint target, uint start, int count, ref float v) {
            fixed (float* pV = &v) {
                GLNative.glFramebufferSampleLocationsfvNV(target, start, count, pV);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_sample_locations</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glNamedFramebufferSampleLocationsfvNV(GLuint framebuffer, GLuint start, GLsizei count, const GLfloat * v);</para>
        /// </summary>
        public unsafe static void NamedFramebufferSampleLocationsfvNV(uint framebuffer, uint start, int count, ref float v) {
            fixed (float* pV = &v) {
                GLNative.glNamedFramebufferSampleLocationsfvNV(framebuffer, start, count, pV);
            }
        }


        #endregion GL_NV_sample_locations

        #region GL_NV_scissor_exclusive

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_scissor_exclusive</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glScissorExclusiveArrayvNV(GLuint first, GLsizei count, const GLint * v);</para>
        /// </summary>
        public unsafe static void ScissorExclusiveArrayvNV(uint first, int count, ref int v) {
            fixed (int* pV = &v) {
                GLNative.glScissorExclusiveArrayvNV(first, count, pV);
            }
        }


        #endregion GL_NV_scissor_exclusive

        #region GL_NV_shader_buffer_load

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_shader_buffer_load</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetBufferParameterui64vNV(GLenum target, GLenum pname, GLuint64EXT * params);</para>
        /// </summary>
        public unsafe static void GetBufferParameterui64vNV(uint target, uint pname, ref UInt64 ps) {
            fixed (UInt64* pPs = &ps) {
                GLNative.glGetBufferParameterui64vNV(target, pname, pPs);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_shader_buffer_load</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetNamedBufferParameterui64vNV(GLuint buffer, GLenum pname, GLuint64EXT * params);</para>
        /// </summary>
        public unsafe static void GetNamedBufferParameterui64vNV(uint buffer, uint pname, ref UInt64 ps) {
            fixed (UInt64* pPs = &ps) {
                GLNative.glGetNamedBufferParameterui64vNV(buffer, pname, pPs);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_shader_buffer_load</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetIntegerui64vNV(GLenum value, GLuint64EXT * result);</para>
        /// </summary>
        public unsafe static void GetIntegerui64vNV(uint value, ref UInt64 result) {
            fixed (UInt64* pResult = &result) {
                GLNative.glGetIntegerui64vNV(value, pResult);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_shader_buffer_load</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glUniformui64vNV(GLint location, GLsizei count, const GLuint64EXT * value);</para>
        /// </summary>
        public unsafe static void Uniformui64vNV(int location, int count, ref UInt64 value) {
            fixed (UInt64* pValue = &value) {
                GLNative.glUniformui64vNV(location, count, pValue);
            }
        }

        // void glGetUniformui64vNV(GLuint program, GLint location, GLuint64EXT * ps);
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_shader_buffer_load</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glProgramUniformui64vNV(GLuint program, GLint location, GLsizei count, const GLuint64EXT * value);</para>
        /// </summary>
        public unsafe static void ProgramUniformui64vNV(uint program, int location, int count, ref UInt64 value) {
            fixed (UInt64* pValue = &value) {
                GLNative.glProgramUniformui64vNV(program, location, count, pValue);
            }
        }


        #endregion GL_NV_shader_buffer_load

        #region GL_NV_shading_rate_image

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_shading_rate_image</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glGetShadingRateImagePaletteNV(GLuint viewport, GLuint entry, GLenum * rate);</para>
        /// </summary>
        public unsafe static void GetShadingRateImagePaletteNV(uint viewport, uint entry, ref uint rate) {
            fixed (uint* pRate = &rate) {
                GLNative.glGetShadingRateImagePaletteNV(viewport, entry, pRate);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_shading_rate_image</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glGetShadingRateSampleLocationivNV(GLenum rate, GLuint samples, GLuint index, GLint * location);</para>
        /// </summary>
        public unsafe static void GetShadingRateSampleLocationivNV(uint rate, uint samples, uint index, ref int location) {
            fixed (int* pLocation = &location) {
                GLNative.glGetShadingRateSampleLocationivNV(rate, samples, index, pLocation);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_shading_rate_image</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glShadingRateImagePaletteNV(GLuint viewport, GLuint first, GLsizei count, const GLenum * rates);</para>
        /// </summary>
        public unsafe static void ShadingRateImagePaletteNV(uint viewport, uint first, int count, ref uint rates) {
            fixed (uint* pRates = &rates) {
                GLNative.glShadingRateImagePaletteNV(viewport, first, count, pRates);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_shading_rate_image</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glShadingRateSampleOrderCustomNV(GLenum rate, GLuint samples, const GLint * locations);</para>
        /// </summary>
        public unsafe static void ShadingRateSampleOrderCustomNV(uint rate, uint samples, ref int locations) {
            fixed (int* pLocations = &locations) {
                GLNative.glShadingRateSampleOrderCustomNV(rate, samples, pLocations);
            }
        }


        #endregion GL_NV_shading_rate_image

        #region GL_NV_texture_barrier


        #endregion GL_NV_texture_barrier

        #region GL_NV_texture_multisample


        #endregion GL_NV_texture_multisample

        #region GL_NV_transform_feedback

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_transform_feedback</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glTransformFeedbackAttribsNV(GLsizei count, const GLint * attribs, GLenum bufferMode);</para>
        /// </summary>
        public unsafe static void TransformFeedbackAttribsNV(int count, ref int attribs, uint bufferMode) {
            fixed (int* pAttribs = &attribs) {
                GLNative.glTransformFeedbackAttribsNV(count, pAttribs, bufferMode);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_transform_feedback</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glTransformFeedbackVaryingsNV(GLuint program, GLsizei count, const GLint * locations, GLenum bufferMode);</para>
        /// </summary>
        public unsafe static void TransformFeedbackVaryingsNV(uint program, int count, ref int locations, uint bufferMode) {
            fixed (int* pLocations = &locations) {
                GLNative.glTransformFeedbackVaryingsNV(program, count, pLocations, bufferMode);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_transform_feedback</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glActiveVaryingNV(GLuint program, const GLchar * name);</para>
        /// </summary>
        public unsafe static void ActiveVaryingNV(uint program, ref byte name) {
            fixed (byte* pName = &name) {
                GLNative.glActiveVaryingNV(program, pName);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_transform_feedback</para>
        /// Supported: <para>gl</para>
        /// Original: <para>GLint glGetVaryingLocationNV(GLuint program, const GLchar * name);</para>
        /// </summary>
        public unsafe static int GetVaryingLocationNV(uint program, ref byte name) {
            fixed (byte* pName = &name) {
                return GLNative.glGetVaryingLocationNV(program, pName);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_transform_feedback</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetActiveVaryingNV(GLuint program, GLuint index, GLsizei bufSize, GLsizei * length, GLsizei * size, GLenum * type, GLchar * name);</para>
        /// </summary>
        public unsafe static void GetActiveVaryingNV(uint program, uint index, int bufSize, ref int length, ref int size, ref uint type, ref byte name) {
            fixed (int* pLength = &length)
            fixed (int* pSize = &size)
            fixed (uint* pType = &type)
            fixed (byte* pName = &name) {
                GLNative.glGetActiveVaryingNV(program, index, bufSize, pLength, pSize, pType, pName);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_transform_feedback</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetTransformFeedbackVaryingNV(GLuint program, GLuint index, GLint * location);</para>
        /// </summary>
        public unsafe static void GetTransformFeedbackVaryingNV(uint program, uint index, ref int location) {
            fixed (int* pLocation = &location) {
                GLNative.glGetTransformFeedbackVaryingNV(program, index, pLocation);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_transform_feedback</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glTransformFeedbackStreamAttribsNV(GLsizei count, const GLint * attribs, GLsizei nbuffers, const GLint * bufstreams, GLenum bufferMode);</para>
        /// </summary>
        public unsafe static void TransformFeedbackStreamAttribsNV(int count, ref int attribs, int nbuffers, ref int bufstreams, uint bufferMode) {
            fixed (int* pAttribs = &attribs)
            fixed (int* pBufstreams = &bufstreams) {
                GLNative.glTransformFeedbackStreamAttribsNV(count, pAttribs, nbuffers, pBufstreams, bufferMode);
            }
        }


        #endregion GL_NV_transform_feedback

        #region GL_NV_transform_feedback2

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_transform_feedback2</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glDeleteTransformFeedbacksNV(GLsizei n, const GLuint * ids);</para>
        /// </summary>
        public unsafe static void DeleteTransformFeedbacksNV(int n, ref uint ids) {
            fixed (uint* pIds = &ids) {
                GLNative.glDeleteTransformFeedbacksNV(n, pIds);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_transform_feedback2</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGenTransformFeedbacksNV(GLsizei n, GLuint * ids);</para>
        /// </summary>
        public unsafe static void GenTransformFeedbacksNV(int n, ref uint ids) {
            fixed (uint* pIds = &ids) {
                GLNative.glGenTransformFeedbacksNV(n, pIds);
            }
        }


        #endregion GL_NV_transform_feedback2

        #region GL_NV_vdpau_interop

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vdpau_interop</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVDPAUInitNV(const void * vdpDevice, const void * getProcAddress);</para>
        /// </summary>
        public unsafe static void VDPAUInitNV(IntPtr vdpDevice, IntPtr getProcAddress) {
            GLNative.glVDPAUInitNV((void*)vdpDevice, (void*)getProcAddress);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vdpau_interop</para>
        /// Supported: <para>gl</para>
        /// Original: <para>GLvdpauSurfaceNV glVDPAURegisterVideoSurfaceNV(const void * vdpSurface, GLenum target, GLsizei numTextureNames, const GLuint * textureNames);</para>
        /// </summary>
        public unsafe static IntPtr VDPAURegisterVideoSurfaceNV(IntPtr vdpSurface, uint target, int numTextureNames, ref uint textureNames) {
            fixed (uint* pTextureNames = &textureNames) {
                return GLNative.glVDPAURegisterVideoSurfaceNV((void*)vdpSurface, target, numTextureNames, pTextureNames);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vdpau_interop</para>
        /// Supported: <para>gl</para>
        /// Original: <para>GLvdpauSurfaceNV glVDPAURegisterOutputSurfaceNV(const void * vdpSurface, GLenum target, GLsizei numTextureNames, const GLuint * textureNames);</para>
        /// </summary>
        public unsafe static IntPtr VDPAURegisterOutputSurfaceNV(IntPtr vdpSurface, uint target, int numTextureNames, ref uint textureNames) {
            fixed (uint* pTextureNames = &textureNames) {
                return GLNative.glVDPAURegisterOutputSurfaceNV((void*)vdpSurface, target, numTextureNames, pTextureNames);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vdpau_interop</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVDPAUGetSurfaceivNV(GLvdpauSurfaceNV surface, GLenum pname, GLsizei count, GLsizei * length, GLint * values);</para>
        /// </summary>
        public unsafe static void VDPAUGetSurfaceivNV(IntPtr surface, uint pname, int count, ref int length, ref int values) {
            fixed (int* pLength = &length)
            fixed (int* pValues = &values) {
                GLNative.glVDPAUGetSurfaceivNV(surface, pname, count, pLength, pValues);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vdpau_interop</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVDPAUMapSurfacesNV(GLsizei numSurfaces, const GLvdpauSurfaceNV * surfaces);</para>
        /// </summary>
        public static void VDPAUMapSurfacesNV(int numSurfaces, IntPtr surfaces) {
            GLNative.glVDPAUMapSurfacesNV(numSurfaces, surfaces);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vdpau_interop</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVDPAUUnmapSurfacesNV(GLsizei numSurface, const GLvdpauSurfaceNV * surfaces);</para>
        /// </summary>
        public static void VDPAUUnmapSurfacesNV(int numSurface, IntPtr surfaces) {
            GLNative.glVDPAUUnmapSurfacesNV(numSurface, surfaces);
        }


        #endregion GL_NV_vdpau_interop

        #region GL_NV_vdpau_interop2

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vdpau_interop2</para>
        /// Supported: <para>gl</para>
        /// Original: <para>GLvdpauSurfaceNV glVDPAURegisterVideoSurfaceWithPictureStructureNV(const void * vdpSurface, GLenum target, GLsizei numTextureNames, const GLuint * textureNames, GLboolean isFrameStructure);</para>
        /// </summary>
        public unsafe static IntPtr VDPAURegisterVideoSurfaceWithPictureStructureNV(IntPtr vdpSurface, uint target, int numTextureNames, ref uint textureNames, bool isFrameStructure) {
            fixed (uint* pTextureNames = &textureNames) {
                return GLNative.glVDPAURegisterVideoSurfaceWithPictureStructureNV((void*)vdpSurface, target, numTextureNames, pTextureNames, isFrameStructure);
            }
        }


        #endregion GL_NV_vdpau_interop2

        #region GL_NV_vertex_array_range

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_array_range</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexArrayRangeNV(GLsizei length, const void * pointer);</para>
        /// </summary>
        public unsafe static void VertexArrayRangeNV(int length, IntPtr pointer) {
            GLNative.glVertexArrayRangeNV(length, (void*)pointer);
        }


        #endregion GL_NV_vertex_array_range

        #region GL_NV_vertex_attrib_integer_64bit

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_attrib_integer_64bit</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glVertexAttribL1i64vNV(GLuint index, const GLint64EXT * v);</para>
        /// </summary>
        public unsafe static void VertexAttribL1i64vNV(uint index, ref Int64 v) {
            fixed (Int64* pV = &v) {
                GLNative.glVertexAttribL1i64vNV(index, pV);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_attrib_integer_64bit</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glVertexAttribL2i64vNV(GLuint index, const GLint64EXT * v);</para>
        /// </summary>
        public unsafe static void VertexAttribL2i64vNV(uint index, ref Int64 v) {
            fixed (Int64* pV = &v) {
                GLNative.glVertexAttribL2i64vNV(index, pV);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_attrib_integer_64bit</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glVertexAttribL3i64vNV(GLuint index, const GLint64EXT * v);</para>
        /// </summary>
        public unsafe static void VertexAttribL3i64vNV(uint index, ref Int64 v) {
            fixed (Int64* pV = &v) {
                GLNative.glVertexAttribL3i64vNV(index, pV);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_attrib_integer_64bit</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glVertexAttribL4i64vNV(GLuint index, const GLint64EXT * v);</para>
        /// </summary>
        public unsafe static void VertexAttribL4i64vNV(uint index, ref Int64 v) {
            fixed (Int64* pV = &v) {
                GLNative.glVertexAttribL4i64vNV(index, pV);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_attrib_integer_64bit</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glVertexAttribL1ui64vNV(GLuint index, const GLuint64EXT * v);</para>
        /// </summary>
        public unsafe static void VertexAttribL1ui64vNV(uint index, ref UInt64 v) {
            fixed (UInt64* pV = &v) {
                GLNative.glVertexAttribL1ui64vNV(index, pV);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_attrib_integer_64bit</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glVertexAttribL2ui64vNV(GLuint index, const GLuint64EXT * v);</para>
        /// </summary>
        public unsafe static void VertexAttribL2ui64vNV(uint index, ref UInt64 v) {
            fixed (UInt64* pV = &v) {
                GLNative.glVertexAttribL2ui64vNV(index, pV);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_attrib_integer_64bit</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glVertexAttribL3ui64vNV(GLuint index, const GLuint64EXT * v);</para>
        /// </summary>
        public unsafe static void VertexAttribL3ui64vNV(uint index, ref UInt64 v) {
            fixed (UInt64* pV = &v) {
                GLNative.glVertexAttribL3ui64vNV(index, pV);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_attrib_integer_64bit</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glVertexAttribL4ui64vNV(GLuint index, const GLuint64EXT * v);</para>
        /// </summary>
        public unsafe static void VertexAttribL4ui64vNV(uint index, ref UInt64 v) {
            fixed (UInt64* pV = &v) {
                GLNative.glVertexAttribL4ui64vNV(index, pV);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_attrib_integer_64bit</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetVertexAttribLi64vNV(GLuint index, GLenum pname, GLint64EXT * params);</para>
        /// </summary>
        public unsafe static void GetVertexAttribLi64vNV(uint index, uint pname, ref Int64 ps) {
            fixed (Int64* pPs = &ps) {
                GLNative.glGetVertexAttribLi64vNV(index, pname, pPs);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_attrib_integer_64bit</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetVertexAttribLui64vNV(GLuint index, GLenum pname, GLuint64EXT * params);</para>
        /// </summary>
        public unsafe static void GetVertexAttribLui64vNV(uint index, uint pname, ref UInt64 ps) {
            fixed (UInt64* pPs = &ps) {
                GLNative.glGetVertexAttribLui64vNV(index, pname, pPs);
            }
        }


        #endregion GL_NV_vertex_attrib_integer_64bit

        #region GL_NV_vertex_buffer_unified_memory

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_buffer_unified_memory</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetIntegerui64i_vNV(GLenum value, GLuint index, GLuint64EXT * result);</para>
        /// </summary>
        public unsafe static void GetIntegerui64i_vNV(uint value, uint index, ref UInt64 result) {
            fixed (UInt64* pResult = &result) {
                GLNative.glGetIntegerui64i_vNV(value, index, pResult);
            }
        }


        #endregion GL_NV_vertex_buffer_unified_memory

        #region GL_NV_vertex_program

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_program</para>
        /// Supported: <para>gl</para>
        /// Original: <para>GLboolean glAreProgramsResidentNV(GLsizei n, const GLuint * programs, GLboolean * residences);</para>
        /// </summary>
        public unsafe static bool AreProgramsResidentNV(int n, ref uint programs, ref bool residences) {
            fixed (uint* pPrograms = &programs)
            fixed (bool* pResidences = &residences) {
                return GLNative.glAreProgramsResidentNV(n, pPrograms, pResidences);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_program</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glDeleteProgramsNV(GLsizei n, const GLuint * programs);</para>
        /// </summary>
        public unsafe static void DeleteProgramsNV(int n, ref uint programs) {
            fixed (uint* pPrograms = &programs) {
                GLNative.glDeleteProgramsNV(n, pPrograms);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_program</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glExecuteProgramNV(GLenum target, GLuint id, const GLfloat * params);</para>
        /// </summary>
        public unsafe static void ExecuteProgramNV(uint target, uint id, ref float ps) {
            fixed (float* pPs = &ps) {
                GLNative.glExecuteProgramNV(target, id, pPs);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_program</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGenProgramsNV(GLsizei n, GLuint * programs);</para>
        /// </summary>
        public unsafe static void GenProgramsNV(int n, ref uint programs) {
            fixed (uint* pPrograms = &programs) {
                GLNative.glGenProgramsNV(n, pPrograms);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_program</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetProgramParameterdvNV(GLenum target, GLuint index, GLenum pname, GLdouble * params);</para>
        /// </summary>
        public unsafe static void GetProgramParameterdvNV(uint target, uint index, uint pname, ref double ps) {
            fixed (double* pPs = &ps) {
                GLNative.glGetProgramParameterdvNV(target, index, pname, pPs);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_program</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetProgramParameterfvNV(GLenum target, GLuint index, GLenum pname, GLfloat * params);</para>
        /// </summary>
        public unsafe static void GetProgramParameterfvNV(uint target, uint index, uint pname, ref float ps) {
            fixed (float* pPs = &ps) {
                GLNative.glGetProgramParameterfvNV(target, index, pname, pPs);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_program</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetProgramivNV(GLuint id, GLenum pname, GLint * params);</para>
        /// </summary>
        public unsafe static void GetProgramivNV(uint id, uint pname, ref int ps) {
            fixed (int* pPs = &ps) {
                GLNative.glGetProgramivNV(id, pname, pPs);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_program</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetProgramStringNV(GLuint id, GLenum pname, GLubyte * program);</para>
        /// </summary>
        public unsafe static void GetProgramStringNV(uint id, uint pname, ref byte program) {
            fixed (byte* pProgram = &program) {
                GLNative.glGetProgramStringNV(id, pname, pProgram);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_program</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetTrackMatrixivNV(GLenum target, GLuint address, GLenum pname, GLint * params);</para>
        /// </summary>
        public unsafe static void GetTrackMatrixivNV(uint target, uint address, uint pname, ref int ps) {
            fixed (int* pPs = &ps) {
                GLNative.glGetTrackMatrixivNV(target, address, pname, pPs);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_program</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetVertexAttribdvNV(GLuint index, GLenum pname, GLdouble * params);</para>
        /// </summary>
        public unsafe static void GetVertexAttribdvNV(uint index, uint pname, ref double ps) {
            fixed (double* pPs = &ps) {
                GLNative.glGetVertexAttribdvNV(index, pname, pPs);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_program</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetVertexAttribfvNV(GLuint index, GLenum pname, GLfloat * params);</para>
        /// </summary>
        public unsafe static void GetVertexAttribfvNV(uint index, uint pname, ref float ps) {
            fixed (float* pPs = &ps) {
                GLNative.glGetVertexAttribfvNV(index, pname, pPs);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_program</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetVertexAttribivNV(GLuint index, GLenum pname, GLint * params);</para>
        /// </summary>
        public unsafe static void GetVertexAttribivNV(uint index, uint pname, ref int ps) {
            fixed (int* pPs = &ps) {
                GLNative.glGetVertexAttribivNV(index, pname, pPs);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_program</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetVertexAttribPointervNV(GLuint index, GLenum pname, void ** pointer);</para>
        /// </summary>
        public unsafe static void GetVertexAttribPointervNV(uint index, uint pname, IntPtr pointer) {
            GLNative.glGetVertexAttribPointervNV(index, pname, (void**)pointer);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_program</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glLoadProgramNV(GLenum target, GLuint id, GLsizei len, const GLubyte * program);</para>
        /// </summary>
        public unsafe static void LoadProgramNV(uint target, uint id, int len, ref byte program) {
            fixed (byte* pProgram = &program) {
                GLNative.glLoadProgramNV(target, id, len, pProgram);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_program</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glProgramParameter4dvNV(GLenum target, GLuint index, const GLdouble * v);</para>
        /// </summary>
        public unsafe static void ProgramParameter4dvNV(uint target, uint index, ref double v) {
            fixed (double* pV = &v) {
                GLNative.glProgramParameter4dvNV(target, index, pV);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_program</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glProgramParameter4fvNV(GLenum target, GLuint index, const GLfloat * v);</para>
        /// </summary>
        public unsafe static void ProgramParameter4fvNV(uint target, uint index, ref float v) {
            fixed (float* pV = &v) {
                GLNative.glProgramParameter4fvNV(target, index, pV);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_program</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glProgramParameters4dvNV(GLenum target, GLuint index, GLsizei count, const GLdouble * v);</para>
        /// </summary>
        public unsafe static void ProgramParameters4dvNV(uint target, uint index, int count, ref double v) {
            fixed (double* pV = &v) {
                GLNative.glProgramParameters4dvNV(target, index, count, pV);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_program</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glProgramParameters4fvNV(GLenum target, GLuint index, GLsizei count, const GLfloat * v);</para>
        /// </summary>
        public unsafe static void ProgramParameters4fvNV(uint target, uint index, int count, ref float v) {
            fixed (float* pV = &v) {
                GLNative.glProgramParameters4fvNV(target, index, count, pV);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_program</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glRequestResidentProgramsNV(GLsizei n, const GLuint * programs);</para>
        /// </summary>
        public unsafe static void RequestResidentProgramsNV(int n, ref uint programs) {
            fixed (uint* pPrograms = &programs) {
                GLNative.glRequestResidentProgramsNV(n, pPrograms);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_program</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexAttribPointerNV(GLuint index, GLint fsize, GLenum type, GLsizei stride, const void * pointer);</para>
        /// </summary>
        public unsafe static void VertexAttribPointerNV(uint index, int fsize, uint type, int stride, IntPtr pointer) {
            GLNative.glVertexAttribPointerNV(index, fsize, type, stride, (void*)pointer);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_program</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexAttrib1dvNV(GLuint index, const GLdouble * v);</para>
        /// </summary>
        public unsafe static void VertexAttrib1dvNV(uint index, ref double v) {
            fixed (double* pV = &v) {
                GLNative.glVertexAttrib1dvNV(index, pV);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_program</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexAttrib1fvNV(GLuint index, const GLfloat * v);</para>
        /// </summary>
        public unsafe static void VertexAttrib1fvNV(uint index, ref float v) {
            fixed (float* pV = &v) {
                GLNative.glVertexAttrib1fvNV(index, pV);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_program</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexAttrib1svNV(GLuint index, const GLshort * v);</para>
        /// </summary>
        public unsafe static void VertexAttrib1svNV(uint index, ref short v) {
            fixed (short* pV = &v) {
                GLNative.glVertexAttrib1svNV(index, pV);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_program</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexAttrib2dvNV(GLuint index, const GLdouble * v);</para>
        /// </summary>
        public unsafe static void VertexAttrib2dvNV(uint index, ref double v) {
            fixed (double* pV = &v) {
                GLNative.glVertexAttrib2dvNV(index, pV);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_program</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexAttrib2fvNV(GLuint index, const GLfloat * v);</para>
        /// </summary>
        public unsafe static void VertexAttrib2fvNV(uint index, ref float v) {
            fixed (float* pV = &v) {
                GLNative.glVertexAttrib2fvNV(index, pV);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_program</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexAttrib2svNV(GLuint index, const GLshort * v);</para>
        /// </summary>
        public unsafe static void VertexAttrib2svNV(uint index, ref short v) {
            fixed (short* pV = &v) {
                GLNative.glVertexAttrib2svNV(index, pV);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_program</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexAttrib3dvNV(GLuint index, const GLdouble * v);</para>
        /// </summary>
        public unsafe static void VertexAttrib3dvNV(uint index, ref double v) {
            fixed (double* pV = &v) {
                GLNative.glVertexAttrib3dvNV(index, pV);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_program</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexAttrib3fvNV(GLuint index, const GLfloat * v);</para>
        /// </summary>
        public unsafe static void VertexAttrib3fvNV(uint index, ref float v) {
            fixed (float* pV = &v) {
                GLNative.glVertexAttrib3fvNV(index, pV);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_program</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexAttrib3svNV(GLuint index, const GLshort * v);</para>
        /// </summary>
        public unsafe static void VertexAttrib3svNV(uint index, ref short v) {
            fixed (short* pV = &v) {
                GLNative.glVertexAttrib3svNV(index, pV);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_program</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexAttrib4dvNV(GLuint index, const GLdouble * v);</para>
        /// </summary>
        public unsafe static void VertexAttrib4dvNV(uint index, ref double v) {
            fixed (double* pV = &v) {
                GLNative.glVertexAttrib4dvNV(index, pV);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_program</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexAttrib4fvNV(GLuint index, const GLfloat * v);</para>
        /// </summary>
        public unsafe static void VertexAttrib4fvNV(uint index, ref float v) {
            fixed (float* pV = &v) {
                GLNative.glVertexAttrib4fvNV(index, pV);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_program</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexAttrib4svNV(GLuint index, const GLshort * v);</para>
        /// </summary>
        public unsafe static void VertexAttrib4svNV(uint index, ref short v) {
            fixed (short* pV = &v) {
                GLNative.glVertexAttrib4svNV(index, pV);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_program</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexAttrib4ubvNV(GLuint index, const GLubyte * v);</para>
        /// </summary>
        public unsafe static void VertexAttrib4ubvNV(uint index, ref byte v) {
            fixed (byte* pV = &v) {
                GLNative.glVertexAttrib4ubvNV(index, pV);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_program</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexAttribs1dvNV(GLuint index, GLsizei count, const GLdouble * v);</para>
        /// </summary>
        public unsafe static void VertexAttribs1dvNV(uint index, int count, ref double v) {
            fixed (double* pV = &v) {
                GLNative.glVertexAttribs1dvNV(index, count, pV);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_program</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexAttribs1fvNV(GLuint index, GLsizei count, const GLfloat * v);</para>
        /// </summary>
        public unsafe static void VertexAttribs1fvNV(uint index, int count, ref float v) {
            fixed (float* pV = &v) {
                GLNative.glVertexAttribs1fvNV(index, count, pV);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_program</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexAttribs1svNV(GLuint index, GLsizei count, const GLshort * v);</para>
        /// </summary>
        public unsafe static void VertexAttribs1svNV(uint index, int count, ref short v) {
            fixed (short* pV = &v) {
                GLNative.glVertexAttribs1svNV(index, count, pV);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_program</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexAttribs2dvNV(GLuint index, GLsizei count, const GLdouble * v);</para>
        /// </summary>
        public unsafe static void VertexAttribs2dvNV(uint index, int count, ref double v) {
            fixed (double* pV = &v) {
                GLNative.glVertexAttribs2dvNV(index, count, pV);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_program</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexAttribs2fvNV(GLuint index, GLsizei count, const GLfloat * v);</para>
        /// </summary>
        public unsafe static void VertexAttribs2fvNV(uint index, int count, ref float v) {
            fixed (float* pV = &v) {
                GLNative.glVertexAttribs2fvNV(index, count, pV);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_program</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexAttribs2svNV(GLuint index, GLsizei count, const GLshort * v);</para>
        /// </summary>
        public unsafe static void VertexAttribs2svNV(uint index, int count, ref short v) {
            fixed (short* pV = &v) {
                GLNative.glVertexAttribs2svNV(index, count, pV);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_program</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexAttribs3dvNV(GLuint index, GLsizei count, const GLdouble * v);</para>
        /// </summary>
        public unsafe static void VertexAttribs3dvNV(uint index, int count, ref double v) {
            fixed (double* pV = &v) {
                GLNative.glVertexAttribs3dvNV(index, count, pV);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_program</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexAttribs3fvNV(GLuint index, GLsizei count, const GLfloat * v);</para>
        /// </summary>
        public unsafe static void VertexAttribs3fvNV(uint index, int count, ref float v) {
            fixed (float* pV = &v) {
                GLNative.glVertexAttribs3fvNV(index, count, pV);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_program</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexAttribs3svNV(GLuint index, GLsizei count, const GLshort * v);</para>
        /// </summary>
        public unsafe static void VertexAttribs3svNV(uint index, int count, ref short v) {
            fixed (short* pV = &v) {
                GLNative.glVertexAttribs3svNV(index, count, pV);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_program</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexAttribs4dvNV(GLuint index, GLsizei count, const GLdouble * v);</para>
        /// </summary>
        public unsafe static void VertexAttribs4dvNV(uint index, int count, ref double v) {
            fixed (double* pV = &v) {
                GLNative.glVertexAttribs4dvNV(index, count, pV);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_program</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexAttribs4fvNV(GLuint index, GLsizei count, const GLfloat * v);</para>
        /// </summary>
        public unsafe static void VertexAttribs4fvNV(uint index, int count, ref float v) {
            fixed (float* pV = &v) {
                GLNative.glVertexAttribs4fvNV(index, count, pV);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_program</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexAttribs4svNV(GLuint index, GLsizei count, const GLshort * v);</para>
        /// </summary>
        public unsafe static void VertexAttribs4svNV(uint index, int count, ref short v) {
            fixed (short* pV = &v) {
                GLNative.glVertexAttribs4svNV(index, count, pV);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_program</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexAttribs4ubvNV(GLuint index, GLsizei count, const GLubyte * v);</para>
        /// </summary>
        public unsafe static void VertexAttribs4ubvNV(uint index, int count, ref byte v) {
            fixed (byte* pV = &v) {
                GLNative.glVertexAttribs4ubvNV(index, count, pV);
            }
        }


        #endregion GL_NV_vertex_program

        #region GL_NV_vertex_program4

        // void glVertexAttribI1ivEXT(GLuint index, const GLint * v);
        // void glVertexAttribI2ivEXT(GLuint index, const GLint * v);
        // void glVertexAttribI3ivEXT(GLuint index, const GLint * v);
        // void glVertexAttribI4ivEXT(GLuint index, const GLint * v);
        // void glVertexAttribI1uivEXT(GLuint index, const GLuint * v);
        // void glVertexAttribI2uivEXT(GLuint index, const GLuint * v);
        // void glVertexAttribI3uivEXT(GLuint index, const GLuint * v);
        // void glVertexAttribI4uivEXT(GLuint index, const GLuint * v);
        // void glVertexAttribI4bvEXT(GLuint index, const GLbyte * v);
        // void glVertexAttribI4svEXT(GLuint index, const GLshort * v);
        // void glVertexAttribI4ubvEXT(GLuint index, const GLubyte * v);
        // void glVertexAttribI4usvEXT(GLuint index, const GLushort * v);
        // void glVertexAttribIPointerEXT(GLuint index, GLint size, GLenum type, GLsizei stride, const void * pointer);
        // void glGetVertexAttribIivEXT(GLuint index, GLenum pname, GLint * ps);
        // void glGetVertexAttribIuivEXT(GLuint index, GLenum pname, GLuint * ps);

        #endregion GL_NV_vertex_program4

        #region GL_NV_video_capture

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_video_capture</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetVideoCaptureivNV(GLuint video_capture_slot, GLenum pname, GLint * params);</para>
        /// </summary>
        public unsafe static void GetVideoCaptureivNV(uint video_capture_slot, uint pname, ref int ps) {
            fixed (int* pPs = &ps) {
                GLNative.glGetVideoCaptureivNV(video_capture_slot, pname, pPs);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_video_capture</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetVideoCaptureStreamivNV(GLuint video_capture_slot, GLuint stream, GLenum pname, GLint * params);</para>
        /// </summary>
        public unsafe static void GetVideoCaptureStreamivNV(uint video_capture_slot, uint stream, uint pname, ref int ps) {
            fixed (int* pPs = &ps) {
                GLNative.glGetVideoCaptureStreamivNV(video_capture_slot, stream, pname, pPs);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_video_capture</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetVideoCaptureStreamfvNV(GLuint video_capture_slot, GLuint stream, GLenum pname, GLfloat * params);</para>
        /// </summary>
        public unsafe static void GetVideoCaptureStreamfvNV(uint video_capture_slot, uint stream, uint pname, ref float ps) {
            fixed (float* pPs = &ps) {
                GLNative.glGetVideoCaptureStreamfvNV(video_capture_slot, stream, pname, pPs);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_video_capture</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetVideoCaptureStreamdvNV(GLuint video_capture_slot, GLuint stream, GLenum pname, GLdouble * params);</para>
        /// </summary>
        public unsafe static void GetVideoCaptureStreamdvNV(uint video_capture_slot, uint stream, uint pname, ref double ps) {
            fixed (double* pPs = &ps) {
                GLNative.glGetVideoCaptureStreamdvNV(video_capture_slot, stream, pname, pPs);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_video_capture</para>
        /// Supported: <para>gl</para>
        /// Original: <para>GLenum glVideoCaptureNV(GLuint video_capture_slot, GLuint * sequence_num, GLuint64EXT * capture_time);</para>
        /// </summary>
        public unsafe static uint VideoCaptureNV(uint video_capture_slot, ref uint sequence_num, ref UInt64 capture_time) {
            fixed (uint* pSequence_num = &sequence_num)
            fixed (UInt64* pCapture_time = &capture_time) {
                return GLNative.glVideoCaptureNV(video_capture_slot, pSequence_num, pCapture_time);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_video_capture</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVideoCaptureStreamParameterivNV(GLuint video_capture_slot, GLuint stream, GLenum pname, const GLint * params);</para>
        /// </summary>
        public unsafe static void VideoCaptureStreamParameterivNV(uint video_capture_slot, uint stream, uint pname, ref int ps) {
            fixed (int* pPs = &ps) {
                GLNative.glVideoCaptureStreamParameterivNV(video_capture_slot, stream, pname, pPs);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_video_capture</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVideoCaptureStreamParameterfvNV(GLuint video_capture_slot, GLuint stream, GLenum pname, const GLfloat * params);</para>
        /// </summary>
        public unsafe static void VideoCaptureStreamParameterfvNV(uint video_capture_slot, uint stream, uint pname, ref float ps) {
            fixed (float* pPs = &ps) {
                GLNative.glVideoCaptureStreamParameterfvNV(video_capture_slot, stream, pname, pPs);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_video_capture</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVideoCaptureStreamParameterdvNV(GLuint video_capture_slot, GLuint stream, GLenum pname, const GLdouble * params);</para>
        /// </summary>
        public unsafe static void VideoCaptureStreamParameterdvNV(uint video_capture_slot, uint stream, uint pname, ref double ps) {
            fixed (double* pPs = &ps) {
                GLNative.glVideoCaptureStreamParameterdvNV(video_capture_slot, stream, pname, pPs);
            }
        }


        #endregion GL_NV_video_capture

        #region GL_NV_viewport_swizzle


        #endregion GL_NV_viewport_swizzle

        #region GL_OES_fixed_point

        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glClipPlanexOES(GLenum plane, const GLfixed * equation);</para>
        /// </summary>
        public unsafe static void ClipPlanexOES(uint plane, ref int equation) {
            fixed (int* pEquation = &equation) {
                GLNative.glClipPlanexOES(plane, pEquation);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glFogxvOES(GLenum pname, const GLfixed * param);</para>
        /// </summary>
        public unsafe static void FogxvOES(uint pname, ref int param) {
            fixed (int* pParam = &param) {
                GLNative.glFogxvOES(pname, pParam);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glGetClipPlanexOES(GLenum plane, GLfixed * equation);</para>
        /// </summary>
        public unsafe static void GetClipPlanexOES(uint plane, ref int equation) {
            fixed (int* pEquation = &equation) {
                GLNative.glGetClipPlanexOES(plane, pEquation);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glGetFixedvOES(GLenum pname, GLfixed * params);</para>
        /// </summary>
        public unsafe static void GetFixedvOES(uint pname, ref int ps) {
            fixed (int* pPs = &ps) {
                GLNative.glGetFixedvOES(pname, pPs);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glGetTexEnvxvOES(GLenum target, GLenum pname, GLfixed * params);</para>
        /// </summary>
        public unsafe static void GetTexEnvxvOES(uint target, uint pname, ref int ps) {
            fixed (int* pPs = &ps) {
                GLNative.glGetTexEnvxvOES(target, pname, pPs);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glGetTexParameterxvOES(GLenum target, GLenum pname, GLfixed * params);</para>
        /// </summary>
        public unsafe static void GetTexParameterxvOES(uint target, uint pname, ref int ps) {
            fixed (int* pPs = &ps) {
                GLNative.glGetTexParameterxvOES(target, pname, pPs);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glLightModelxvOES(GLenum pname, const GLfixed * param);</para>
        /// </summary>
        public unsafe static void LightModelxvOES(uint pname, ref int param) {
            fixed (int* pParam = &param) {
                GLNative.glLightModelxvOES(pname, pParam);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glLightxvOES(GLenum light, GLenum pname, const GLfixed * params);</para>
        /// </summary>
        public unsafe static void LightxvOES(uint light, uint pname, ref int ps) {
            fixed (int* pPs = &ps) {
                GLNative.glLightxvOES(light, pname, pPs);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glLoadMatrixxOES(const GLfixed * m);</para>
        /// </summary>
        public unsafe static void LoadMatrixxOES(ref int m) {
            fixed (int* pM = &m) {
                GLNative.glLoadMatrixxOES(pM);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glMaterialxvOES(GLenum face, GLenum pname, const GLfixed * param);</para>
        /// </summary>
        public unsafe static void MaterialxvOES(uint face, uint pname, ref int param) {
            fixed (int* pParam = &param) {
                GLNative.glMaterialxvOES(face, pname, pParam);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glMultMatrixxOES(const GLfixed * m);</para>
        /// </summary>
        public unsafe static void MultMatrixxOES(ref int m) {
            fixed (int* pM = &m) {
                GLNative.glMultMatrixxOES(pM);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glPointParameterxvOES(GLenum pname, const GLfixed * params);</para>
        /// </summary>
        public unsafe static void PointParameterxvOES(uint pname, ref int ps) {
            fixed (int* pPs = &ps) {
                GLNative.glPointParameterxvOES(pname, pPs);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glTexEnvxvOES(GLenum target, GLenum pname, const GLfixed * params);</para>
        /// </summary>
        public unsafe static void TexEnvxvOES(uint target, uint pname, ref int ps) {
            fixed (int* pPs = &ps) {
                GLNative.glTexEnvxvOES(target, pname, pPs);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glTexParameterxvOES(GLenum target, GLenum pname, const GLfixed * params);</para>
        /// </summary>
        public unsafe static void TexParameterxvOES(uint target, uint pname, ref int ps) {
            fixed (int* pPs = &ps) {
                GLNative.glTexParameterxvOES(target, pname, pPs);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glGetLightxvOES(GLenum light, GLenum pname, GLfixed * params);</para>
        /// </summary>
        public unsafe static void GetLightxvOES(uint light, uint pname, ref int ps) {
            fixed (int* pPs = &ps) {
                GLNative.glGetLightxvOES(light, pname, pPs);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glGetMaterialxvOES(GLenum face, GLenum pname, GLfixed * params);</para>
        /// </summary>
        public unsafe static void GetMaterialxvOES(uint face, uint pname, ref int ps) {
            fixed (int* pPs = &ps) {
                GLNative.glGetMaterialxvOES(face, pname, pPs);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glBitmapxOES(GLsizei width, GLsizei height, GLfixed xorig, GLfixed yorig, GLfixed xmove, GLfixed ymove, const GLubyte * bitmap);</para>
        /// </summary>
        public unsafe static void BitmapxOES(int width, int height, int xorig, int yorig, int xmove, int ymove, ref byte bitmap) {
            fixed (byte* pBitmap = &bitmap) {
                GLNative.glBitmapxOES(width, height, xorig, yorig, xmove, ymove, pBitmap);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glColor3xvOES(const GLfixed * components);</para>
        /// </summary>
        public unsafe static void Color3xvOES(ref int components) {
            fixed (int* pComponents = &components) {
                GLNative.glColor3xvOES(pComponents);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glColor4xvOES(const GLfixed * components);</para>
        /// </summary>
        public unsafe static void Color4xvOES(ref int components) {
            fixed (int* pComponents = &components) {
                GLNative.glColor4xvOES(pComponents);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glConvolutionParameterxvOES(GLenum target, GLenum pname, const GLfixed * params);</para>
        /// </summary>
        public unsafe static void ConvolutionParameterxvOES(uint target, uint pname, ref int ps) {
            fixed (int* pPs = &ps) {
                GLNative.glConvolutionParameterxvOES(target, pname, pPs);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glEvalCoord1xvOES(const GLfixed * coords);</para>
        /// </summary>
        public unsafe static void EvalCoord1xvOES(ref int coords) {
            fixed (int* pCoords = &coords) {
                GLNative.glEvalCoord1xvOES(pCoords);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glEvalCoord2xvOES(const GLfixed * coords);</para>
        /// </summary>
        public unsafe static void EvalCoord2xvOES(ref int coords) {
            fixed (int* pCoords = &coords) {
                GLNative.glEvalCoord2xvOES(pCoords);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glFeedbackBufferxOES(GLsizei n, GLenum type, const GLfixed * buffer);</para>
        /// </summary>
        public unsafe static void FeedbackBufferxOES(int n, uint type, ref int buffer) {
            fixed (int* pBuffer = &buffer) {
                GLNative.glFeedbackBufferxOES(n, type, pBuffer);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glGetConvolutionParameterxvOES(GLenum target, GLenum pname, GLfixed * params);</para>
        /// </summary>
        public unsafe static void GetConvolutionParameterxvOES(uint target, uint pname, ref int ps) {
            fixed (int* pPs = &ps) {
                GLNative.glGetConvolutionParameterxvOES(target, pname, pPs);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glGetHistogramParameterxvOES(GLenum target, GLenum pname, GLfixed * params);</para>
        /// </summary>
        public unsafe static void GetHistogramParameterxvOES(uint target, uint pname, ref int ps) {
            fixed (int* pPs = &ps) {
                GLNative.glGetHistogramParameterxvOES(target, pname, pPs);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glGetLightxOES(GLenum light, GLenum pname, GLfixed * params);</para>
        /// </summary>
        public unsafe static void GetLightxOES(uint light, uint pname, ref int ps) {
            fixed (int* pPs = &ps) {
                GLNative.glGetLightxOES(light, pname, pPs);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glGetMapxvOES(GLenum target, GLenum query, GLfixed * v);</para>
        /// </summary>
        public unsafe static void GetMapxvOES(uint target, uint query, ref int v) {
            fixed (int* pV = &v) {
                GLNative.glGetMapxvOES(target, query, pV);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glGetPixelMapxv(GLenum map, GLint size, GLfixed * values);</para>
        /// </summary>
        public unsafe static void GetPixelMapxv(uint map, int size, ref int values) {
            fixed (int* pValues = &values) {
                GLNative.glGetPixelMapxv(map, size, pValues);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point, GL_OES_texture_cube_map</para>
        /// Supported: <para>gl, gles1, gles1</para>
        /// Original: <para>void glGetTexGenxvOES(GLenum coord, GLenum pname, GLfixed * params);</para>
        /// </summary>
        public unsafe static void GetTexGenxvOES(uint coord, uint pname, ref int ps) {
            fixed (int* pPs = &ps) {
                GLNative.glGetTexGenxvOES(coord, pname, pPs);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glGetTexLevelParameterxvOES(GLenum target, GLint level, GLenum pname, GLfixed * params);</para>
        /// </summary>
        public unsafe static void GetTexLevelParameterxvOES(uint target, int level, uint pname, ref int ps) {
            fixed (int* pPs = &ps) {
                GLNative.glGetTexLevelParameterxvOES(target, level, pname, pPs);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glIndexxvOES(const GLfixed * component);</para>
        /// </summary>
        public unsafe static void IndexxvOES(ref int component) {
            fixed (int* pComponent = &component) {
                GLNative.glIndexxvOES(pComponent);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glLoadTransposeMatrixxOES(const GLfixed * m);</para>
        /// </summary>
        public unsafe static void LoadTransposeMatrixxOES(ref int m) {
            fixed (int* pM = &m) {
                GLNative.glLoadTransposeMatrixxOES(pM);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glMultTransposeMatrixxOES(const GLfixed * m);</para>
        /// </summary>
        public unsafe static void MultTransposeMatrixxOES(ref int m) {
            fixed (int* pM = &m) {
                GLNative.glMultTransposeMatrixxOES(pM);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glMultiTexCoord1xvOES(GLenum texture, const GLfixed * coords);</para>
        /// </summary>
        public unsafe static void MultiTexCoord1xvOES(uint texture, ref int coords) {
            fixed (int* pCoords = &coords) {
                GLNative.glMultiTexCoord1xvOES(texture, pCoords);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glMultiTexCoord2xvOES(GLenum texture, const GLfixed * coords);</para>
        /// </summary>
        public unsafe static void MultiTexCoord2xvOES(uint texture, ref int coords) {
            fixed (int* pCoords = &coords) {
                GLNative.glMultiTexCoord2xvOES(texture, pCoords);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glMultiTexCoord3xvOES(GLenum texture, const GLfixed * coords);</para>
        /// </summary>
        public unsafe static void MultiTexCoord3xvOES(uint texture, ref int coords) {
            fixed (int* pCoords = &coords) {
                GLNative.glMultiTexCoord3xvOES(texture, pCoords);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glMultiTexCoord4xvOES(GLenum texture, const GLfixed * coords);</para>
        /// </summary>
        public unsafe static void MultiTexCoord4xvOES(uint texture, ref int coords) {
            fixed (int* pCoords = &coords) {
                GLNative.glMultiTexCoord4xvOES(texture, pCoords);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glNormal3xvOES(const GLfixed * coords);</para>
        /// </summary>
        public unsafe static void Normal3xvOES(ref int coords) {
            fixed (int* pCoords = &coords) {
                GLNative.glNormal3xvOES(pCoords);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glPixelMapx(GLenum map, GLint size, const GLfixed * values);</para>
        /// </summary>
        public unsafe static void PixelMapx(uint map, int size, ref int values) {
            fixed (int* pValues = &values) {
                GLNative.glPixelMapx(map, size, pValues);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glPrioritizeTexturesxOES(GLsizei n, const GLuint * textures, const GLfixed * priorities);</para>
        /// </summary>
        public unsafe static void PrioritizeTexturesxOES(int n, ref uint textures, ref int priorities) {
            fixed (uint* pTextures = &textures)
            fixed (int* pPriorities = &priorities) {
                GLNative.glPrioritizeTexturesxOES(n, pTextures, pPriorities);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glRasterPos2xvOES(const GLfixed * coords);</para>
        /// </summary>
        public unsafe static void RasterPos2xvOES(ref int coords) {
            fixed (int* pCoords = &coords) {
                GLNative.glRasterPos2xvOES(pCoords);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glRasterPos3xvOES(const GLfixed * coords);</para>
        /// </summary>
        public unsafe static void RasterPos3xvOES(ref int coords) {
            fixed (int* pCoords = &coords) {
                GLNative.glRasterPos3xvOES(pCoords);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glRasterPos4xvOES(const GLfixed * coords);</para>
        /// </summary>
        public unsafe static void RasterPos4xvOES(ref int coords) {
            fixed (int* pCoords = &coords) {
                GLNative.glRasterPos4xvOES(pCoords);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glRectxvOES(const GLfixed * v1, const GLfixed * v2);</para>
        /// </summary>
        public unsafe static void RectxvOES(ref int v1, ref int v2) {
            fixed (int* pV1 = &v1)
            fixed (int* pV2 = &v2) {
                GLNative.glRectxvOES(pV1, pV2);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glTexCoord1xvOES(const GLfixed * coords);</para>
        /// </summary>
        public unsafe static void TexCoord1xvOES(ref int coords) {
            fixed (int* pCoords = &coords) {
                GLNative.glTexCoord1xvOES(pCoords);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glTexCoord2xvOES(const GLfixed * coords);</para>
        /// </summary>
        public unsafe static void TexCoord2xvOES(ref int coords) {
            fixed (int* pCoords = &coords) {
                GLNative.glTexCoord2xvOES(pCoords);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glTexCoord3xvOES(const GLfixed * coords);</para>
        /// </summary>
        public unsafe static void TexCoord3xvOES(ref int coords) {
            fixed (int* pCoords = &coords) {
                GLNative.glTexCoord3xvOES(pCoords);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glTexCoord4xvOES(const GLfixed * coords);</para>
        /// </summary>
        public unsafe static void TexCoord4xvOES(ref int coords) {
            fixed (int* pCoords = &coords) {
                GLNative.glTexCoord4xvOES(pCoords);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point, GL_OES_texture_cube_map</para>
        /// Supported: <para>gl, gles1, gles1</para>
        /// Original: <para>void glTexGenxvOES(GLenum coord, GLenum pname, const GLfixed * params);</para>
        /// </summary>
        public unsafe static void TexGenxvOES(uint coord, uint pname, ref int ps) {
            fixed (int* pPs = &ps) {
                GLNative.glTexGenxvOES(coord, pname, pPs);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glVertex2xvOES(const GLfixed * coords);</para>
        /// </summary>
        public unsafe static void Vertex2xvOES(ref int coords) {
            fixed (int* pCoords = &coords) {
                GLNative.glVertex2xvOES(pCoords);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glVertex3xvOES(const GLfixed * coords);</para>
        /// </summary>
        public unsafe static void Vertex3xvOES(ref int coords) {
            fixed (int* pCoords = &coords) {
                GLNative.glVertex3xvOES(pCoords);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glVertex4xvOES(const GLfixed * coords);</para>
        /// </summary>
        public unsafe static void Vertex4xvOES(ref int coords) {
            fixed (int* pCoords = &coords) {
                GLNative.glVertex4xvOES(pCoords);
            }
        }


        #endregion GL_OES_fixed_point

        #region GL_OES_query_matrix

        /// <summary>
        /// <para>Require:</para> <para>GL_OES_query_matrix</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>GLbitfield glQueryMatrixxOES(GLfixed * mantissa, GLint * exponent);</para>
        /// </summary>
        public unsafe static uint QueryMatrixxOES(ref int mantissa, ref int exponent) {
            fixed (int* pMantissa = &mantissa)
            fixed (int* pExponent = &exponent) {
                return GLNative.glQueryMatrixxOES(pMantissa, pExponent);
            }
        }


        #endregion GL_OES_query_matrix

        #region GL_OES_single_precision

        /// <summary>
        /// <para>Require:</para> <para>GL_OES_single_precision</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glClipPlanefOES(GLenum plane, const GLfloat * equation);</para>
        /// </summary>
        public unsafe static void ClipPlanefOES(uint plane, ref float equation) {
            fixed (float* pEquation = &equation) {
                GLNative.glClipPlanefOES(plane, pEquation);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_OES_single_precision</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glGetClipPlanefOES(GLenum plane, GLfloat * equation);</para>
        /// </summary>
        public unsafe static void GetClipPlanefOES(uint plane, ref float equation) {
            fixed (float* pEquation = &equation) {
                GLNative.glGetClipPlanefOES(plane, pEquation);
            }
        }


        #endregion GL_OES_single_precision

        #region GL_OVR_multiview


        #endregion GL_OVR_multiview

        #region GL_PGI_misc_hints


        #endregion GL_PGI_misc_hints

        #region GL_SGIS_detail_texture

        /// <summary>
        /// <para>Require:</para> <para>GL_SGIS_detail_texture</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glDetailTexFuncSGIS(GLenum target, GLsizei n, const GLfloat * points);</para>
        /// </summary>
        public unsafe static void DetailTexFuncSGIS(uint target, int n, ref float points) {
            fixed (float* pPoints = &points) {
                GLNative.glDetailTexFuncSGIS(target, n, pPoints);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_SGIS_detail_texture</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetDetailTexFuncSGIS(GLenum target, GLfloat * points);</para>
        /// </summary>
        public unsafe static void GetDetailTexFuncSGIS(uint target, ref float points) {
            fixed (float* pPoints = &points) {
                GLNative.glGetDetailTexFuncSGIS(target, pPoints);
            }
        }


        #endregion GL_SGIS_detail_texture

        #region GL_SGIS_fog_function

        /// <summary>
        /// <para>Require:</para> <para>GL_SGIS_fog_function</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glFogFuncSGIS(GLsizei n, const GLfloat * points);</para>
        /// </summary>
        public unsafe static void FogFuncSGIS(int n, ref float points) {
            fixed (float* pPoints = &points) {
                GLNative.glFogFuncSGIS(n, pPoints);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_SGIS_fog_function</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetFogFuncSGIS(GLfloat * points);</para>
        /// </summary>
        public unsafe static void GetFogFuncSGIS(ref float points) {
            fixed (float* pPoints = &points) {
                GLNative.glGetFogFuncSGIS(pPoints);
            }
        }


        #endregion GL_SGIS_fog_function

        #region GL_SGIS_multisample


        #endregion GL_SGIS_multisample

        #region GL_SGIS_pixel_texture

        /// <summary>
        /// <para>Require:</para> <para>GL_SGIS_pixel_texture</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glPixelTexGenParameterivSGIS(GLenum pname, const GLint * params);</para>
        /// </summary>
        public unsafe static void PixelTexGenParameterivSGIS(uint pname, ref int ps) {
            fixed (int* pPs = &ps) {
                GLNative.glPixelTexGenParameterivSGIS(pname, pPs);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_SGIS_pixel_texture</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glPixelTexGenParameterfvSGIS(GLenum pname, const GLfloat * params);</para>
        /// </summary>
        public unsafe static void PixelTexGenParameterfvSGIS(uint pname, ref float ps) {
            fixed (float* pPs = &ps) {
                GLNative.glPixelTexGenParameterfvSGIS(pname, pPs);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_SGIS_pixel_texture</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetPixelTexGenParameterivSGIS(GLenum pname, GLint * params);</para>
        /// </summary>
        public unsafe static void GetPixelTexGenParameterivSGIS(uint pname, ref int ps) {
            fixed (int* pPs = &ps) {
                GLNative.glGetPixelTexGenParameterivSGIS(pname, pPs);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_SGIS_pixel_texture</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetPixelTexGenParameterfvSGIS(GLenum pname, GLfloat * params);</para>
        /// </summary>
        public unsafe static void GetPixelTexGenParameterfvSGIS(uint pname, ref float ps) {
            fixed (float* pPs = &ps) {
                GLNative.glGetPixelTexGenParameterfvSGIS(pname, pPs);
            }
        }


        #endregion GL_SGIS_pixel_texture

        #region GL_SGIS_point_parameters

        /// <summary>
        /// <para>Require:</para> <para>GL_SGIS_point_parameters</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glPointParameterfvSGIS(GLenum pname, const GLfloat * params);</para>
        /// </summary>
        public unsafe static void PointParameterfvSGIS(uint pname, ref float ps) {
            fixed (float* pPs = &ps) {
                GLNative.glPointParameterfvSGIS(pname, pPs);
            }
        }


        #endregion GL_SGIS_point_parameters

        #region GL_SGIS_sharpen_texture

        /// <summary>
        /// <para>Require:</para> <para>GL_SGIS_sharpen_texture</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glSharpenTexFuncSGIS(GLenum target, GLsizei n, const GLfloat * points);</para>
        /// </summary>
        public unsafe static void SharpenTexFuncSGIS(uint target, int n, ref float points) {
            fixed (float* pPoints = &points) {
                GLNative.glSharpenTexFuncSGIS(target, n, pPoints);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_SGIS_sharpen_texture</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetSharpenTexFuncSGIS(GLenum target, GLfloat * points);</para>
        /// </summary>
        public unsafe static void GetSharpenTexFuncSGIS(uint target, ref float points) {
            fixed (float* pPoints = &points) {
                GLNative.glGetSharpenTexFuncSGIS(target, pPoints);
            }
        }


        #endregion GL_SGIS_sharpen_texture

        #region GL_SGIS_texture4D

        /// <summary>
        /// <para>Require:</para> <para>GL_SGIS_texture4D</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glTexImage4DSGIS(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLsizei size4d, GLint border, GLenum format, GLenum type, const void * pixels);</para>
        /// </summary>
        public unsafe static void TexImage4DSGIS(uint target, int level, uint internalformat, int width, int height, int depth, int size4d, int border, uint format, uint type, IntPtr pixels) {
            GLNative.glTexImage4DSGIS(target, level, internalformat, width, height, depth, size4d, border, format, type, (void*)pixels);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_SGIS_texture4D</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glTexSubImage4DSGIS(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint woffset, GLsizei width, GLsizei height, GLsizei depth, GLsizei size4d, GLenum format, GLenum type, const void * pixels);</para>
        /// </summary>
        public unsafe static void TexSubImage4DSGIS(uint target, int level, int xoffset, int yoffset, int zoffset, int woffset, int width, int height, int depth, int size4d, uint format, uint type, IntPtr pixels) {
            GLNative.glTexSubImage4DSGIS(target, level, xoffset, yoffset, zoffset, woffset, width, height, depth, size4d, format, type, (void*)pixels);
        }


        #endregion GL_SGIS_texture4D

        #region GL_SGIS_texture_color_mask


        #endregion GL_SGIS_texture_color_mask

        #region GL_SGIS_texture_filter4

        /// <summary>
        /// <para>Require:</para> <para>GL_SGIS_texture_filter4</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetTexFilterFuncSGIS(GLenum target, GLenum filter, GLfloat * weights);</para>
        /// </summary>
        public unsafe static void GetTexFilterFuncSGIS(uint target, uint filter, ref float weights) {
            fixed (float* pWeights = &weights) {
                GLNative.glGetTexFilterFuncSGIS(target, filter, pWeights);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_SGIS_texture_filter4</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glTexFilterFuncSGIS(GLenum target, GLenum filter, GLsizei n, const GLfloat * weights);</para>
        /// </summary>
        public unsafe static void TexFilterFuncSGIS(uint target, uint filter, int n, ref float weights) {
            fixed (float* pWeights = &weights) {
                GLNative.glTexFilterFuncSGIS(target, filter, n, pWeights);
            }
        }


        #endregion GL_SGIS_texture_filter4

        #region GL_SGIX_async

        /// <summary>
        /// <para>Require:</para> <para>GL_SGIX_async</para>
        /// Supported: <para>gl</para>
        /// Original: <para>GLint glFinishAsyncSGIX(GLuint * markerp);</para>
        /// </summary>
        public unsafe static int FinishAsyncSGIX(ref uint markerp) {
            fixed (uint* pMarkerp = &markerp) {
                return GLNative.glFinishAsyncSGIX(pMarkerp);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_SGIX_async</para>
        /// Supported: <para>gl</para>
        /// Original: <para>GLint glPollAsyncSGIX(GLuint * markerp);</para>
        /// </summary>
        public unsafe static int PollAsyncSGIX(ref uint markerp) {
            fixed (uint* pMarkerp = &markerp) {
                return GLNative.glPollAsyncSGIX(pMarkerp);
            }
        }


        #endregion GL_SGIX_async

        #region GL_SGIX_flush_raster


        #endregion GL_SGIX_flush_raster

        #region GL_SGIX_fragment_lighting

        /// <summary>
        /// <para>Require:</para> <para>GL_SGIX_fragment_lighting</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glFragmentLightfvSGIX(GLenum light, GLenum pname, const GLfloat * params);</para>
        /// </summary>
        public unsafe static void FragmentLightfvSGIX(uint light, uint pname, ref float ps) {
            fixed (float* pPs = &ps) {
                GLNative.glFragmentLightfvSGIX(light, pname, pPs);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_SGIX_fragment_lighting</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glFragmentLightivSGIX(GLenum light, GLenum pname, const GLint * params);</para>
        /// </summary>
        public unsafe static void FragmentLightivSGIX(uint light, uint pname, ref int ps) {
            fixed (int* pPs = &ps) {
                GLNative.glFragmentLightivSGIX(light, pname, pPs);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_SGIX_fragment_lighting</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glFragmentLightModelfvSGIX(GLenum pname, const GLfloat * params);</para>
        /// </summary>
        public unsafe static void FragmentLightModelfvSGIX(uint pname, ref float ps) {
            fixed (float* pPs = &ps) {
                GLNative.glFragmentLightModelfvSGIX(pname, pPs);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_SGIX_fragment_lighting</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glFragmentLightModelivSGIX(GLenum pname, const GLint * params);</para>
        /// </summary>
        public unsafe static void FragmentLightModelivSGIX(uint pname, ref int ps) {
            fixed (int* pPs = &ps) {
                GLNative.glFragmentLightModelivSGIX(pname, pPs);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_SGIX_fragment_lighting</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glFragmentMaterialfvSGIX(GLenum face, GLenum pname, const GLfloat * params);</para>
        /// </summary>
        public unsafe static void FragmentMaterialfvSGIX(uint face, uint pname, ref float ps) {
            fixed (float* pPs = &ps) {
                GLNative.glFragmentMaterialfvSGIX(face, pname, pPs);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_SGIX_fragment_lighting</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glFragmentMaterialivSGIX(GLenum face, GLenum pname, const GLint * params);</para>
        /// </summary>
        public unsafe static void FragmentMaterialivSGIX(uint face, uint pname, ref int ps) {
            fixed (int* pPs = &ps) {
                GLNative.glFragmentMaterialivSGIX(face, pname, pPs);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_SGIX_fragment_lighting</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetFragmentLightfvSGIX(GLenum light, GLenum pname, GLfloat * params);</para>
        /// </summary>
        public unsafe static void GetFragmentLightfvSGIX(uint light, uint pname, ref float ps) {
            fixed (float* pPs = &ps) {
                GLNative.glGetFragmentLightfvSGIX(light, pname, pPs);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_SGIX_fragment_lighting</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetFragmentLightivSGIX(GLenum light, GLenum pname, GLint * params);</para>
        /// </summary>
        public unsafe static void GetFragmentLightivSGIX(uint light, uint pname, ref int ps) {
            fixed (int* pPs = &ps) {
                GLNative.glGetFragmentLightivSGIX(light, pname, pPs);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_SGIX_fragment_lighting</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetFragmentMaterialfvSGIX(GLenum face, GLenum pname, GLfloat * params);</para>
        /// </summary>
        public unsafe static void GetFragmentMaterialfvSGIX(uint face, uint pname, ref float ps) {
            fixed (float* pPs = &ps) {
                GLNative.glGetFragmentMaterialfvSGIX(face, pname, pPs);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_SGIX_fragment_lighting</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetFragmentMaterialivSGIX(GLenum face, GLenum pname, GLint * params);</para>
        /// </summary>
        public unsafe static void GetFragmentMaterialivSGIX(uint face, uint pname, ref int ps) {
            fixed (int* pPs = &ps) {
                GLNative.glGetFragmentMaterialivSGIX(face, pname, pPs);
            }
        }


        #endregion GL_SGIX_fragment_lighting

        #region GL_SGIX_framezoom


        #endregion GL_SGIX_framezoom

        #region GL_SGIX_igloo_interface

        /// <summary>
        /// <para>Require:</para> <para>GL_SGIX_igloo_interface</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glIglooInterfaceSGIX(GLenum pname, const void * params);</para>
        /// </summary>
        public unsafe static void IglooInterfaceSGIX(uint pname, IntPtr ps) {
            GLNative.glIglooInterfaceSGIX(pname, (void*)ps);
        }


        #endregion GL_SGIX_igloo_interface

        #region GL_SGIX_instruments

        /// <summary>
        /// <para>Require:</para> <para>GL_SGIX_instruments</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glInstrumentsBufferSGIX(GLsizei size, GLint * buffer);</para>
        /// </summary>
        public unsafe static void InstrumentsBufferSGIX(int size, ref int buffer) {
            fixed (int* pBuffer = &buffer) {
                GLNative.glInstrumentsBufferSGIX(size, pBuffer);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_SGIX_instruments</para>
        /// Supported: <para>gl</para>
        /// Original: <para>GLint glPollInstrumentsSGIX(GLint * marker_p);</para>
        /// </summary>
        public unsafe static int PollInstrumentsSGIX(ref int marker_p) {
            fixed (int* pMarker_p = &marker_p) {
                return GLNative.glPollInstrumentsSGIX(pMarker_p);
            }
        }


        #endregion GL_SGIX_instruments

        #region GL_SGIX_list_priority

        /// <summary>
        /// <para>Require:</para> <para>GL_SGIX_list_priority</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetListParameterfvSGIX(GLuint list, GLenum pname, GLfloat * params);</para>
        /// </summary>
        public unsafe static void GetListParameterfvSGIX(uint list, uint pname, ref float ps) {
            fixed (float* pPs = &ps) {
                GLNative.glGetListParameterfvSGIX(list, pname, pPs);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_SGIX_list_priority</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetListParameterivSGIX(GLuint list, GLenum pname, GLint * params);</para>
        /// </summary>
        public unsafe static void GetListParameterivSGIX(uint list, uint pname, ref int ps) {
            fixed (int* pPs = &ps) {
                GLNative.glGetListParameterivSGIX(list, pname, pPs);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_SGIX_list_priority</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glListParameterfvSGIX(GLuint list, GLenum pname, const GLfloat * params);</para>
        /// </summary>
        public unsafe static void ListParameterfvSGIX(uint list, uint pname, ref float ps) {
            fixed (float* pPs = &ps) {
                GLNative.glListParameterfvSGIX(list, pname, pPs);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_SGIX_list_priority</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glListParameterivSGIX(GLuint list, GLenum pname, const GLint * params);</para>
        /// </summary>
        public unsafe static void ListParameterivSGIX(uint list, uint pname, ref int ps) {
            fixed (int* pPs = &ps) {
                GLNative.glListParameterivSGIX(list, pname, pPs);
            }
        }


        #endregion GL_SGIX_list_priority

        #region GL_SGIX_pixel_texture


        #endregion GL_SGIX_pixel_texture

        #region GL_SGIX_polynomial_ffd

        /// <summary>
        /// <para>Require:</para> <para>GL_SGIX_polynomial_ffd</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glDeformationMap3dSGIX(GLenum target, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, GLdouble w1, GLdouble w2, GLint wstride, GLint worder, const GLdouble * points);</para>
        /// </summary>
        public unsafe static void DeformationMap3dSGIX(uint target, double u1, double u2, int ustride, int uorder, double v1, double v2, int vstride, int vorder, double w1, double w2, int wstride, int worder, ref double points) {
            fixed (double* pPoints = &points) {
                GLNative.glDeformationMap3dSGIX(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, w1, w2, wstride, worder, pPoints);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_SGIX_polynomial_ffd</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glDeformationMap3fSGIX(GLenum target, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, GLfloat w1, GLfloat w2, GLint wstride, GLint worder, const GLfloat * points);</para>
        /// </summary>
        public unsafe static void DeformationMap3fSGIX(uint target, float u1, float u2, int ustride, int uorder, float v1, float v2, int vstride, int vorder, float w1, float w2, int wstride, int worder, ref float points) {
            fixed (float* pPoints = &points) {
                GLNative.glDeformationMap3fSGIX(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, w1, w2, wstride, worder, pPoints);
            }
        }


        #endregion GL_SGIX_polynomial_ffd

        #region GL_SGIX_reference_plane

        /// <summary>
        /// <para>Require:</para> <para>GL_SGIX_reference_plane</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glReferencePlaneSGIX(const GLdouble * equation);</para>
        /// </summary>
        public unsafe static void ReferencePlaneSGIX(ref double equation) {
            fixed (double* pEquation = &equation) {
                GLNative.glReferencePlaneSGIX(pEquation);
            }
        }


        #endregion GL_SGIX_reference_plane

        #region GL_SGIX_sprite

        /// <summary>
        /// <para>Require:</para> <para>GL_SGIX_sprite</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glSpriteParameterfvSGIX(GLenum pname, const GLfloat * params);</para>
        /// </summary>
        public unsafe static void SpriteParameterfvSGIX(uint pname, ref float ps) {
            fixed (float* pPs = &ps) {
                GLNative.glSpriteParameterfvSGIX(pname, pPs);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_SGIX_sprite</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glSpriteParameterivSGIX(GLenum pname, const GLint * params);</para>
        /// </summary>
        public unsafe static void SpriteParameterivSGIX(uint pname, ref int ps) {
            fixed (int* pPs = &ps) {
                GLNative.glSpriteParameterivSGIX(pname, pPs);
            }
        }


        #endregion GL_SGIX_sprite

        #region GL_SGIX_tag_sample_buffer


        #endregion GL_SGIX_tag_sample_buffer

        #region GL_SGI_color_table

        /// <summary>
        /// <para>Require:</para> <para>GL_SGI_color_table</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glColorTableSGI(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const void * table);</para>
        /// </summary>
        public unsafe static void ColorTableSGI(uint target, uint internalformat, int width, uint format, uint type, IntPtr table) {
            GLNative.glColorTableSGI(target, internalformat, width, format, type, (void*)table);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_SGI_color_table</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glColorTableParameterfvSGI(GLenum target, GLenum pname, const GLfloat * params);</para>
        /// </summary>
        public unsafe static void ColorTableParameterfvSGI(uint target, uint pname, ref float ps) {
            fixed (float* pPs = &ps) {
                GLNative.glColorTableParameterfvSGI(target, pname, pPs);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_SGI_color_table</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glColorTableParameterivSGI(GLenum target, GLenum pname, const GLint * params);</para>
        /// </summary>
        public unsafe static void ColorTableParameterivSGI(uint target, uint pname, ref int ps) {
            fixed (int* pPs = &ps) {
                GLNative.glColorTableParameterivSGI(target, pname, pPs);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_SGI_color_table</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetColorTableSGI(GLenum target, GLenum format, GLenum type, void * table);</para>
        /// </summary>
        public unsafe static void GetColorTableSGI(uint target, uint format, uint type, IntPtr table) {
            GLNative.glGetColorTableSGI(target, format, type, (void*)table);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_SGI_color_table</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetColorTableParameterfvSGI(GLenum target, GLenum pname, GLfloat * params);</para>
        /// </summary>
        public unsafe static void GetColorTableParameterfvSGI(uint target, uint pname, ref float ps) {
            fixed (float* pPs = &ps) {
                GLNative.glGetColorTableParameterfvSGI(target, pname, pPs);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_SGI_color_table</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetColorTableParameterivSGI(GLenum target, GLenum pname, GLint * params);</para>
        /// </summary>
        public unsafe static void GetColorTableParameterivSGI(uint target, uint pname, ref int ps) {
            fixed (int* pPs = &ps) {
                GLNative.glGetColorTableParameterivSGI(target, pname, pPs);
            }
        }


        #endregion GL_SGI_color_table

        #region GL_SUNX_constant_data


        #endregion GL_SUNX_constant_data

        #region GL_SUN_global_alpha


        #endregion GL_SUN_global_alpha

        #region GL_SUN_mesh_array


        #endregion GL_SUN_mesh_array

        #region GL_SUN_triangle_list

        /// <summary>
        /// <para>Require:</para> <para>GL_SUN_triangle_list</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glReplacementCodeuivSUN(const GLuint * code);</para>
        /// </summary>
        public unsafe static void ReplacementCodeuivSUN(ref uint code) {
            fixed (uint* pCode = &code) {
                GLNative.glReplacementCodeuivSUN(pCode);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_SUN_triangle_list</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glReplacementCodeusvSUN(const GLushort * code);</para>
        /// </summary>
        public unsafe static void ReplacementCodeusvSUN(ref ushort code) {
            fixed (ushort* pCode = &code) {
                GLNative.glReplacementCodeusvSUN(pCode);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_SUN_triangle_list</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glReplacementCodeubvSUN(const GLubyte * code);</para>
        /// </summary>
        public unsafe static void ReplacementCodeubvSUN(ref byte code) {
            fixed (byte* pCode = &code) {
                GLNative.glReplacementCodeubvSUN(pCode);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_SUN_triangle_list</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glReplacementCodePointerSUN(GLenum type, GLsizei stride, const void ** pointer);</para>
        /// </summary>
        public unsafe static void ReplacementCodePointerSUN(uint type, int stride, IntPtr pointer) {
            GLNative.glReplacementCodePointerSUN(type, stride, (void**)pointer);
        }


        #endregion GL_SUN_triangle_list

        #region GL_SUN_vertex

        /// <summary>
        /// <para>Require:</para> <para>GL_SUN_vertex</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glColor4ubVertex2fvSUN(const GLubyte * c, const GLfloat * v);</para>
        /// </summary>
        public unsafe static void Color4ubVertex2fvSUN(ref byte c, ref float v) {
            fixed (byte* pC = &c)
            fixed (float* pV = &v) {
                GLNative.glColor4ubVertex2fvSUN(pC, pV);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_SUN_vertex</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glColor4ubVertex3fvSUN(const GLubyte * c, const GLfloat * v);</para>
        /// </summary>
        public unsafe static void Color4ubVertex3fvSUN(ref byte c, ref float v) {
            fixed (byte* pC = &c)
            fixed (float* pV = &v) {
                GLNative.glColor4ubVertex3fvSUN(pC, pV);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_SUN_vertex</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glColor3fVertex3fvSUN(const GLfloat * c, const GLfloat * v);</para>
        /// </summary>
        public unsafe static void Color3fVertex3fvSUN(ref float c, ref float v) {
            fixed (float* pC = &c)
            fixed (float* pV = &v) {
                GLNative.glColor3fVertex3fvSUN(pC, pV);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_SUN_vertex</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glNormal3fVertex3fvSUN(const GLfloat * n, const GLfloat * v);</para>
        /// </summary>
        public unsafe static void Normal3fVertex3fvSUN(ref float n, ref float v) {
            fixed (float* pN = &n)
            fixed (float* pV = &v) {
                GLNative.glNormal3fVertex3fvSUN(pN, pV);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_SUN_vertex</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glColor4fNormal3fVertex3fvSUN(const GLfloat * c, const GLfloat * n, const GLfloat * v);</para>
        /// </summary>
        public unsafe static void Color4fNormal3fVertex3fvSUN(ref float c, ref float n, ref float v) {
            fixed (float* pC = &c)
            fixed (float* pN = &n)
            fixed (float* pV = &v) {
                GLNative.glColor4fNormal3fVertex3fvSUN(pC, pN, pV);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_SUN_vertex</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glTexCoord2fVertex3fvSUN(const GLfloat * tc, const GLfloat * v);</para>
        /// </summary>
        public unsafe static void TexCoord2fVertex3fvSUN(ref float tc, ref float v) {
            fixed (float* pTc = &tc)
            fixed (float* pV = &v) {
                GLNative.glTexCoord2fVertex3fvSUN(pTc, pV);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_SUN_vertex</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glTexCoord4fVertex4fvSUN(const GLfloat * tc, const GLfloat * v);</para>
        /// </summary>
        public unsafe static void TexCoord4fVertex4fvSUN(ref float tc, ref float v) {
            fixed (float* pTc = &tc)
            fixed (float* pV = &v) {
                GLNative.glTexCoord4fVertex4fvSUN(pTc, pV);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_SUN_vertex</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glTexCoord2fColor4ubVertex3fvSUN(const GLfloat * tc, const GLubyte * c, const GLfloat * v);</para>
        /// </summary>
        public unsafe static void TexCoord2fColor4ubVertex3fvSUN(ref float tc, ref byte c, ref float v) {
            fixed (float* pTc = &tc)
            fixed (byte* pC = &c)
            fixed (float* pV = &v) {
                GLNative.glTexCoord2fColor4ubVertex3fvSUN(pTc, pC, pV);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_SUN_vertex</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glTexCoord2fColor3fVertex3fvSUN(const GLfloat * tc, const GLfloat * c, const GLfloat * v);</para>
        /// </summary>
        public unsafe static void TexCoord2fColor3fVertex3fvSUN(ref float tc, ref float c, ref float v) {
            fixed (float* pTc = &tc)
            fixed (float* pC = &c)
            fixed (float* pV = &v) {
                GLNative.glTexCoord2fColor3fVertex3fvSUN(pTc, pC, pV);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_SUN_vertex</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glTexCoord2fNormal3fVertex3fvSUN(const GLfloat * tc, const GLfloat * n, const GLfloat * v);</para>
        /// </summary>
        public unsafe static void TexCoord2fNormal3fVertex3fvSUN(ref float tc, ref float n, ref float v) {
            fixed (float* pTc = &tc)
            fixed (float* pN = &n)
            fixed (float* pV = &v) {
                GLNative.glTexCoord2fNormal3fVertex3fvSUN(pTc, pN, pV);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_SUN_vertex</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glTexCoord2fColor4fNormal3fVertex3fvSUN(const GLfloat * tc, const GLfloat * c, const GLfloat * n, const GLfloat * v);</para>
        /// </summary>
        public unsafe static void TexCoord2fColor4fNormal3fVertex3fvSUN(ref float tc, ref float c, ref float n, ref float v) {
            fixed (float* pTc = &tc)
            fixed (float* pC = &c)
            fixed (float* pN = &n)
            fixed (float* pV = &v) {
                GLNative.glTexCoord2fColor4fNormal3fVertex3fvSUN(pTc, pC, pN, pV);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_SUN_vertex</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glTexCoord4fColor4fNormal3fVertex4fvSUN(const GLfloat * tc, const GLfloat * c, const GLfloat * n, const GLfloat * v);</para>
        /// </summary>
        public unsafe static void TexCoord4fColor4fNormal3fVertex4fvSUN(ref float tc, ref float c, ref float n, ref float v) {
            fixed (float* pTc = &tc)
            fixed (float* pC = &c)
            fixed (float* pN = &n)
            fixed (float* pV = &v) {
                GLNative.glTexCoord4fColor4fNormal3fVertex4fvSUN(pTc, pC, pN, pV);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_SUN_vertex</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glReplacementCodeuiVertex3fvSUN(const GLuint * rc, const GLfloat * v);</para>
        /// </summary>
        public unsafe static void ReplacementCodeuiVertex3fvSUN(ref uint rc, ref float v) {
            fixed (uint* pRc = &rc)
            fixed (float* pV = &v) {
                GLNative.glReplacementCodeuiVertex3fvSUN(pRc, pV);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_SUN_vertex</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glReplacementCodeuiColor4ubVertex3fvSUN(const GLuint * rc, const GLubyte * c, const GLfloat * v);</para>
        /// </summary>
        public unsafe static void ReplacementCodeuiColor4ubVertex3fvSUN(ref uint rc, ref byte c, ref float v) {
            fixed (uint* pRc = &rc)
            fixed (byte* pC = &c)
            fixed (float* pV = &v) {
                GLNative.glReplacementCodeuiColor4ubVertex3fvSUN(pRc, pC, pV);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_SUN_vertex</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glReplacementCodeuiColor3fVertex3fvSUN(const GLuint * rc, const GLfloat * c, const GLfloat * v);</para>
        /// </summary>
        public unsafe static void ReplacementCodeuiColor3fVertex3fvSUN(ref uint rc, ref float c, ref float v) {
            fixed (uint* pRc = &rc)
            fixed (float* pC = &c)
            fixed (float* pV = &v) {
                GLNative.glReplacementCodeuiColor3fVertex3fvSUN(pRc, pC, pV);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_SUN_vertex</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glReplacementCodeuiNormal3fVertex3fvSUN(const GLuint * rc, const GLfloat * n, const GLfloat * v);</para>
        /// </summary>
        public unsafe static void ReplacementCodeuiNormal3fVertex3fvSUN(ref uint rc, ref float n, ref float v) {
            fixed (uint* pRc = &rc)
            fixed (float* pN = &n)
            fixed (float* pV = &v) {
                GLNative.glReplacementCodeuiNormal3fVertex3fvSUN(pRc, pN, pV);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_SUN_vertex</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glReplacementCodeuiColor4fNormal3fVertex3fvSUN(const GLuint * rc, const GLfloat * c, const GLfloat * n, const GLfloat * v);</para>
        /// </summary>
        public unsafe static void ReplacementCodeuiColor4fNormal3fVertex3fvSUN(ref uint rc, ref float c, ref float n, ref float v) {
            fixed (uint* pRc = &rc)
            fixed (float* pC = &c)
            fixed (float* pN = &n)
            fixed (float* pV = &v) {
                GLNative.glReplacementCodeuiColor4fNormal3fVertex3fvSUN(pRc, pC, pN, pV);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_SUN_vertex</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glReplacementCodeuiTexCoord2fVertex3fvSUN(const GLuint * rc, const GLfloat * tc, const GLfloat * v);</para>
        /// </summary>
        public unsafe static void ReplacementCodeuiTexCoord2fVertex3fvSUN(ref uint rc, ref float tc, ref float v) {
            fixed (uint* pRc = &rc)
            fixed (float* pTc = &tc)
            fixed (float* pV = &v) {
                GLNative.glReplacementCodeuiTexCoord2fVertex3fvSUN(pRc, pTc, pV);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_SUN_vertex</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(const GLuint * rc, const GLfloat * tc, const GLfloat * n, const GLfloat * v);</para>
        /// </summary>
        public unsafe static void ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(ref uint rc, ref float tc, ref float n, ref float v) {
            fixed (uint* pRc = &rc)
            fixed (float* pTc = &tc)
            fixed (float* pN = &n)
            fixed (float* pV = &v) {
                GLNative.glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(pRc, pTc, pN, pV);
            }
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_SUN_vertex</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(const GLuint * rc, const GLfloat * tc, const GLfloat * c, const GLfloat * n, const GLfloat * v);</para>
        /// </summary>
        public unsafe static void ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(ref uint rc, ref float tc, ref float c, ref float n, ref float v) {
            fixed (uint* pRc = &rc)
            fixed (float* pTc = &tc)
            fixed (float* pC = &c)
            fixed (float* pN = &n)
            fixed (float* pV = &v) {
                GLNative.glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(pRc, pTc, pC, pN, pV);
            }
        }


        #endregion GL_SUN_vertex

    }
}
