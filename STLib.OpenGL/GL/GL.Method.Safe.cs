using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Runtime.InteropServices;

namespace STLib.OpenGL.GL
{
    public partial class GL // GL.Method.Safe.cs
    {
        /**********************************************************************************
         * These functions do not contain pointers and can be called directly.
         * ********************************************************************************
         * Note: These codes are automatically created from OpenGL's documentation.
         *       If there is something wrong, it must be because the author is too stupid.
         * Link: https://github.com/KhronosGroup/OpenGL-Registry/xml/gl.xml
         *       https://github.com/KhronosGroup/OpenGL-Refpages/tree/main/gl2.1
         *       https://github.com/KhronosGroup/OpenGL-Refpages/tree/main/gl4
         **********************************************************************************/

        #region GL_VERSION_1_0

        /// <summary>
        /// specify whether front- or back-facing facets can be culled
        /// <para>Require:</para> <para>GL_VERSION_1_0, GL_VERSION_ES_CM_1_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// If <paramref name="mode"/> is <code>GL_FRONT_AND_BACK</code>, no facets are drawn, but other
        /// primitives such as points and lines are drawn.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="mode"/> is not an accepted value.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glCullFace"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glCullFace(GLenum mode);</para>
        /// </summary>
        /// <param name="mode">
        /// <para>
        /// Specifies whether front- or back-facing facets are candidates for culling.
        /// Symbolic constants
        /// <code>GL_FRONT</code>, <code>GL_BACK</code>, and <code>GL_FRONT_AND_BACK</code> are accepted.
        /// The initial value is <code>GL_BACK</code>.
        /// </para>
        /// </param>
        /// <seealso cref="Enable"/>
        /// <seealso cref="FrontFace"/>
        public static void CullFace(uint mode) {
            GLNative.glCullFace(mode);
        }

        /// <summary>
        /// define front- and back-facing polygons
        /// <para>Require:</para> <para>GL_VERSION_1_0, GL_VERSION_ES_CM_1_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="mode"/> is not an accepted value.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glFrontFace"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glFrontFace(GLenum mode);</para>
        /// </summary>
        /// <param name="mode">
        /// <para>
        /// Specifies the orientation of front-facing polygons.
        /// <code>GL_CW</code> and <code>GL_CCW</code> are accepted.
        /// The initial value is <code>GL_CCW</code>.
        /// </para>
        /// </param>
        /// <seealso cref="CullFace"/>
        /// <seealso cref="LightModel"/>
        public static void FrontFace(uint mode) {
            GLNative.glFrontFace(mode);
        }

        /// <summary>
        /// specify implementation-specific hints
        /// <para>Require:</para> <para>GL_VERSION_1_0, GL_VERSION_ES_CM_1_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The interpretation of hints depends on the implementation.
        /// Some implementations ignore <see cref="glHint"/> settings.
        /// <code>GL_TEXTURE_COMPRESSION_HINT</code> is available only if the GL version is 1.3
        /// or greater.
        /// <code>GL_GENERATE_MIPMAP_HINT</code> is available only if the GL version is 1.4
        /// or greater.
        /// <code>GL_FRAGMENT_SHADER_DERIVATIVE_HINT</code> is available only if the GL version is 2.0
        /// or greater.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if either <paramref name="target"/> or <paramref name="mode"/> is not
        /// an accepted value.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glHint"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glHint(GLenum target, GLenum mode);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies a symbolic constant indicating the behavior to be controlled.
        /// <code>GL_FOG_HINT</code>,	
        /// <code>GL_GENERATE_MIPMAP_HINT</code>,
        /// <code>GL_LINE_SMOOTH_HINT</code>,
        /// <code>GL_PERSPECTIVE_CORRECTION_HINT</code>,
        /// <code>GL_POINT_SMOOTH_HINT</code>,
        /// <code>GL_POLYGON_SMOOTH_HINT</code>,
        /// <code>GL_TEXTURE_COMPRESSION_HINT</code>, and
        /// <code>GL_FRAGMENT_SHADER_DERIVATIVE_HINT</code>
        /// are accepted.
        /// </para>
        /// </param>
        /// <param name="mode">
        /// <para>
        /// Specifies a symbolic constant indicating the desired behavior.
        /// <code>GL_FASTEST</code>,
        /// <code>GL_NICEST</code>, and
        /// <code>GL_DONT_CARE</code> are accepted.
        /// </para>
        /// </param>
        public static void Hint(uint target, uint mode) {
            GLNative.glHint(target, mode);
        }

        /// <summary>
        /// specify the width of rasterized lines
        /// <para>Require:</para> <para>GL_VERSION_1_0, GL_VERSION_ES_CM_1_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The line width specified by <see cref="glLineWidth"/> is always returned when <code>GL_LINE_WIDTH</code>
        /// is queried.
        /// Clamping and rounding for aliased and antialiased lines have no effect on the specified value.
        /// Nonantialiased line width may be clamped to an implementation-dependent maximum.  Call  <see cref="glGet"/>  with <code>GL_ALIASED_LINE_WIDTH_RANGE</code> to determine the maximum width.
        /// In OpenGL 1.2, the tokens <code>GL_LINE_WIDTH_RANGE</code> and <code>GL_LINE_WIDTH_GRANULARITY</code> were replaced by <code>GL_ALIASED_LINE_WIDTH_RANGE</code>,
        /// <code>GL_SMOOTH_LINE_WIDTH_RANGE</code>, and <code>GL_SMOOTH_LINE_WIDTH_GRANULARITY</code>.  The old names are retained for backward compatibility, but should not be used in new code.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="width"/> is less than or equal to 0.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glLineWidth"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glLineWidth(GLfloat width);</para>
        /// </summary>
        /// <param name="width">
        /// <para>
        /// Specifies the width of rasterized lines.
        /// The initial value is 1.
        /// </para>
        /// </param>
        /// <seealso cref="Enable"/>
        public static void LineWidth(float width) {
            GLNative.glLineWidth(width);
        }

        /// <summary>
        /// specify the diameter of rasterized points
        /// <para>Require:</para> <para>GL_VERSION_1_0, GL_VERSION_ES_CM_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The point size specified by <see cref="glPointSize"/> is always returned when
        /// <code>GL_POINT_SIZE</code> is queried.  Clamping and rounding for aliased and
        /// antialiased points have no effect on the specified value.
        /// A non-antialiased point size may be clamped to an implementation-dependent
        /// maximum.  Although this maximum cannot be queried, it must be no less than
        /// the maximum value for antialiased points, rounded to the nearest integer
        /// value.
        /// <code>GL_POINT_SIZE_RANGE</code> and <code>GL_POINT_SIZE_GRANULARITY</code> are
        /// deprecated in GL versions 1.2 and greater.  Their functionality has been
        /// replaced by <code>GL_SMOOTH_POINT_SIZE_RANGE</code> and
        /// <code>GL_SMOOTH_POINT_SIZE_GRANULARITY</code>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="size"/> is less than or equal to 0.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glPointSize"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glPointSize(GLfloat size);</para>
        /// </summary>
        /// <param name="size">
        /// <para>
        /// Specifies the diameter of rasterized points.
        /// The initial value is 1.
        /// </para>
        /// </param>
        /// <seealso cref="Enable"/>
        /// <seealso cref="PointParameter"/>
        public static void PointSize(float size) {
            GLNative.glPointSize(size);
        }

        /// <summary>
        /// select a polygon rasterization mode
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// Vertices are marked as boundary or nonboundary with an edge flag.
        /// Edge flags are generated internally by the GL when it decomposes
        /// polygons; they can be set explicitly using  <see cref="glEdgeFlag"/> .
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if either <paramref name="face"/> or <paramref name="mode"/> is not
        /// an accepted value.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glPolygonMode"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glPolygonMode(GLenum face, GLenum mode);</para>
        /// </summary>
        /// <param name="face">
        /// <para>
        /// Specifies the polygons that <paramref name="mode"/> applies to.
        /// Must be
        /// <code>GL_FRONT</code> for front-facing polygons,
        /// <code>GL_BACK</code> for back-facing polygons,
        /// or <code>GL_FRONT_AND_BACK</code> for front- and back-facing polygons.
        /// </para>
        /// </param>
        /// <param name="mode">
        /// <para>
        /// Specifies how polygons will be rasterized.
        /// Accepted values are
        /// <code>GL_POINT</code>,
        /// <code>GL_LINE</code>, and
        /// <code>GL_FILL</code>.
        /// The initial value is <code>GL_FILL</code> for both front- and back-facing polygons.
        /// </para>
        /// </param>
        /// <seealso cref="Begin"/>
        /// <seealso cref="EdgeFlag"/>
        /// <seealso cref="LineStipple"/>
        /// <seealso cref="LineWidth"/>
        /// <seealso cref="PointSize"/>
        /// <seealso cref="PolygonStipple"/>
        public static void PolygonMode(uint face, uint mode) {
            GLNative.glPolygonMode(face, mode);
        }

        /// <summary>
        /// define the scissor box
        /// <para>Require:</para> <para>GL_VERSION_1_0, GL_VERSION_ES_CM_1_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if either <paramref name="width"/> or <paramref name="height"/> is negative.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glScissor"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glScissor(GLint x, GLint y, GLsizei width, GLsizei height);</para>
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify the lower left corner of the scissor box.
        /// Initially (0, 0).
        /// </para>
        /// </param>
        /// <param name="y">
        /// <para>
        /// Specify the lower left corner of the scissor box.
        /// Initially (0, 0).
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// Specify the width and height of the scissor box.
        /// When a GL context is first attached to a window,
        /// <paramref name="width"/> and <paramref name="height"/> are set to the dimensions of that
        /// window.
        /// </para>
        /// </param>
        /// <param name="height">
        /// <para>
        /// Specify the width and height of the scissor box.
        /// When a GL context is first attached to a window,
        /// <paramref name="width"/> and <paramref name="height"/> are set to the dimensions of that
        /// window.
        /// </para>
        /// </param>
        /// <seealso cref="Enable"/>
        /// <seealso cref="Viewport"/>
        public static void Scissor(int x, int y, int width, int height) {
            GLNative.glScissor(x, y, width, height);
        }

        /// <summary>
        /// set texture parameters
        /// <para>Require:</para> <para>GL_VERSION_1_0, GL_VERSION_ES_CM_1_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <code>GL_TEXTURE_3D</code>, <code>GL_TEXTURE_MIN_LOD</code>, <code>GL_TEXTURE_MAX_LOD</code>,
        /// <code>GL_CLAMP_TO_EDGE</code>, <code>GL_TEXTURE_BASE_LEVEL</code>, and <code>GL_TEXTURE_MAX_LEVEL</code> are
        /// available only if the GL version is 1.2 or greater.
        /// <code>GL_CLAMP_TO_BORDER</code> is available only if the GL version is 1.3 or greater.
        /// <code>GL_MIRRORED_REPEAT</code>, <code>GL_TEXTURE_COMPARE_MODE</code>,
        /// <code>GL_TEXTURE_COMPARE_FUNC</code>, <code>GL_DEPTH_TEXTURE_MODE</code>, and
        /// <code>GL_GENERATE_MIPMAP</code> are available only if the GL version is 1.4 or
        /// greater.
        /// <code>GL_TEXTURE_COMPARE_FUNC</code> allows the following additional comparison modes only
        /// if the GL version is 1.5 or greater:
        /// <code>GL_LESS</code>, <code>GL_GREATER</code>,
        /// <code>GL_EQUAL</code>, <code>GL_NOTEQUAL</code>,
        /// <code>GL_ALWAYS</code>, and <code>GL_NEVER</code>.
        /// Suppose that a program has enabled texturing (by calling  <see cref="glEnable"/>  with
        /// argument <code>GL_TEXTURE_1D</code>, <code>GL_TEXTURE_2D</code>, or <code>GL_TEXTURE_3D</code>) and
        /// has set <code>GL_TEXTURE_MIN_FILTER</code> to one of the functions that requires a
        /// mipmap.  If either the dimensions of the texture images currently defined
        /// (with previous calls to  <see cref="glTexImage1D"/> ,  <see cref="glTexImage2D"/> ,
        /// <see cref="glTexImage3D"/> ,  <see cref="glCopyTexImage1D"/> , or  <see cref="glCopyTexImage2D"/> ) do not
        /// follow the proper sequence for mipmaps (described above), or there are
        /// fewer texture images defined than are needed, or the set of texture images
        /// have differing numbers of texture components, then it is as if texture
        /// mapping were disabled.
        /// Linear filtering accesses the four nearest texture elements only in 2D
        /// textures.  In 1D textures, linear filtering accesses the two nearest
        /// texture elements.
        /// For OpenGL versions 1.3 and greater, or when the <code>ARB_multitexture</code> extension is supported, <see cref="glTexParameter"/>
        /// specifies the texture parameters for the active texture unit, specified
        /// by calling  <see cref="glActiveTexture"/> .
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="target"/> or <paramref name="pname"/> is not
        /// one of the accepted defined values.
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="ps"/> should have a defined
        /// constant value (based on the value of <paramref name="pname"/>) and does not.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glTexParameter"/> is executed between the
        /// execution of  <see cref="glBegin"/>  and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glTexParameterf(GLenum target, GLenum pname, GLfloat param);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target texture,
        /// which must be either <code>GL_TEXTURE_1D</code>, <code>GL_TEXTURE_2D</code>,
        /// <code>GL_TEXTURE_3D</code>, or <code>GL_TEXTURE_CUBE_MAP</code>.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of a single-valued texture parameter.
        /// <paramref name="pname"/> can be one of the following:
        /// <code>GL_TEXTURE_MIN_FILTER</code>,
        /// <code>GL_TEXTURE_MAG_FILTER</code>,
        /// <code>GL_TEXTURE_MIN_LOD</code>,
        /// <code>GL_TEXTURE_MAX_LOD</code>,
        /// <code>GL_TEXTURE_BASE_LEVEL</code>,
        /// <code>GL_TEXTURE_MAX_LEVEL</code>,
        /// <code>GL_TEXTURE_WRAP_S</code>,
        /// <code>GL_TEXTURE_WRAP_T</code>,
        /// <code>GL_TEXTURE_WRAP_R</code>,
        /// <code>GL_TEXTURE_PRIORITY</code>,
        /// <code>GL_TEXTURE_COMPARE_MODE</code>,
        /// <code>GL_TEXTURE_COMPARE_FUNC</code>,
        /// <code>GL_DEPTH_TEXTURE_MODE</code>, or
        /// <code>GL_GENERATE_MIPMAP</code>.
        /// </para>
        /// </param>
        /// <param name="param">
        /// Specifies the value of <paramref name="pname"/>.
        /// </param>
        /// <seealso cref="ActiveTexture"/>
        /// <seealso cref="BindTexture"/>
        /// <seealso cref="CopyPixels"/>
        /// <seealso cref="CopyTexImage1D"/>
        /// <seealso cref="CopyTexImage2D"/>
        /// <seealso cref="CopyTexSubImage1D"/>
        /// <seealso cref="CopyTexSubImage2D"/>
        /// <seealso cref="CopyTexSubImage3D"/>
        /// <seealso cref="DrawPixels"/>
        /// <seealso cref="PixelStore"/>
        /// <seealso cref="PixelTransfer"/>
        /// <seealso cref="PrioritizeTextures"/>
        /// <seealso cref="TexEnv"/>
        /// <seealso cref="TexGen"/>
        /// <seealso cref="TexImage1D"/>
        /// <seealso cref="TexImage2D"/>
        /// <seealso cref="TexImage3D"/>
        /// <seealso cref="TexSubImage1D"/>
        /// <seealso cref="TexSubImage2D"/>
        /// <seealso cref="TexSubImage3D"/>
        public static void TexParameterf(uint target, uint pname, float param) {
            GLNative.glTexParameterf(target, pname, param);
        }

        /// <summary>
        /// set texture parameters
        /// <para>Require:</para> <para>GL_VERSION_1_0, GL_VERSION_ES_CM_1_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <code>GL_TEXTURE_3D</code>, <code>GL_TEXTURE_MIN_LOD</code>, <code>GL_TEXTURE_MAX_LOD</code>,
        /// <code>GL_CLAMP_TO_EDGE</code>, <code>GL_TEXTURE_BASE_LEVEL</code>, and <code>GL_TEXTURE_MAX_LEVEL</code> are
        /// available only if the GL version is 1.2 or greater.
        /// <code>GL_CLAMP_TO_BORDER</code> is available only if the GL version is 1.3 or greater.
        /// <code>GL_MIRRORED_REPEAT</code>, <code>GL_TEXTURE_COMPARE_MODE</code>,
        /// <code>GL_TEXTURE_COMPARE_FUNC</code>, <code>GL_DEPTH_TEXTURE_MODE</code>, and
        /// <code>GL_GENERATE_MIPMAP</code> are available only if the GL version is 1.4 or
        /// greater.
        /// <code>GL_TEXTURE_COMPARE_FUNC</code> allows the following additional comparison modes only
        /// if the GL version is 1.5 or greater:
        /// <code>GL_LESS</code>, <code>GL_GREATER</code>,
        /// <code>GL_EQUAL</code>, <code>GL_NOTEQUAL</code>,
        /// <code>GL_ALWAYS</code>, and <code>GL_NEVER</code>.
        /// Suppose that a program has enabled texturing (by calling  <see cref="glEnable"/>  with
        /// argument <code>GL_TEXTURE_1D</code>, <code>GL_TEXTURE_2D</code>, or <code>GL_TEXTURE_3D</code>) and
        /// has set <code>GL_TEXTURE_MIN_FILTER</code> to one of the functions that requires a
        /// mipmap.  If either the dimensions of the texture images currently defined
        /// (with previous calls to  <see cref="glTexImage1D"/> ,  <see cref="glTexImage2D"/> ,
        /// <see cref="glTexImage3D"/> ,  <see cref="glCopyTexImage1D"/> , or  <see cref="glCopyTexImage2D"/> ) do not
        /// follow the proper sequence for mipmaps (described above), or there are
        /// fewer texture images defined than are needed, or the set of texture images
        /// have differing numbers of texture components, then it is as if texture
        /// mapping were disabled.
        /// Linear filtering accesses the four nearest texture elements only in 2D
        /// textures.  In 1D textures, linear filtering accesses the two nearest
        /// texture elements.
        /// For OpenGL versions 1.3 and greater, or when the <code>ARB_multitexture</code> extension is supported, <see cref="glTexParameter"/>
        /// specifies the texture parameters for the active texture unit, specified
        /// by calling  <see cref="glActiveTexture"/> .
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="target"/> or <paramref name="pname"/> is not
        /// one of the accepted defined values.
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="ps"/> should have a defined
        /// constant value (based on the value of <paramref name="pname"/>) and does not.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glTexParameter"/> is executed between the
        /// execution of  <see cref="glBegin"/>  and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glTexParameteri(GLenum target, GLenum pname, GLint param);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target texture,
        /// which must be either <code>GL_TEXTURE_1D</code>, <code>GL_TEXTURE_2D</code>,
        /// <code>GL_TEXTURE_3D</code>, or <code>GL_TEXTURE_CUBE_MAP</code>.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of a single-valued texture parameter.
        /// <paramref name="pname"/> can be one of the following:
        /// <code>GL_TEXTURE_MIN_FILTER</code>,
        /// <code>GL_TEXTURE_MAG_FILTER</code>,
        /// <code>GL_TEXTURE_MIN_LOD</code>,
        /// <code>GL_TEXTURE_MAX_LOD</code>,
        /// <code>GL_TEXTURE_BASE_LEVEL</code>,
        /// <code>GL_TEXTURE_MAX_LEVEL</code>,
        /// <code>GL_TEXTURE_WRAP_S</code>,
        /// <code>GL_TEXTURE_WRAP_T</code>,
        /// <code>GL_TEXTURE_WRAP_R</code>,
        /// <code>GL_TEXTURE_PRIORITY</code>,
        /// <code>GL_TEXTURE_COMPARE_MODE</code>,
        /// <code>GL_TEXTURE_COMPARE_FUNC</code>,
        /// <code>GL_DEPTH_TEXTURE_MODE</code>, or
        /// <code>GL_GENERATE_MIPMAP</code>.
        /// </para>
        /// </param>
        /// <param name="param">
        /// Specifies the value of <paramref name="pname"/>.
        /// </param>
        /// <seealso cref="ActiveTexture"/>
        /// <seealso cref="BindTexture"/>
        /// <seealso cref="CopyPixels"/>
        /// <seealso cref="CopyTexImage1D"/>
        /// <seealso cref="CopyTexImage2D"/>
        /// <seealso cref="CopyTexSubImage1D"/>
        /// <seealso cref="CopyTexSubImage2D"/>
        /// <seealso cref="CopyTexSubImage3D"/>
        /// <seealso cref="DrawPixels"/>
        /// <seealso cref="PixelStore"/>
        /// <seealso cref="PixelTransfer"/>
        /// <seealso cref="PrioritizeTextures"/>
        /// <seealso cref="TexEnv"/>
        /// <seealso cref="TexGen"/>
        /// <seealso cref="TexImage1D"/>
        /// <seealso cref="TexImage2D"/>
        /// <seealso cref="TexImage3D"/>
        /// <seealso cref="TexSubImage1D"/>
        /// <seealso cref="TexSubImage2D"/>
        /// <seealso cref="TexSubImage3D"/>
        public static void TexParameteri(uint target, uint pname, int param) {
            GLNative.glTexParameteri(target, pname, param);
        }

        /// <summary>
        /// specify which color buffers are to be drawn into
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// It is always the case that <code>GL_AUX</code>
        /// i   
        /// = <code>GL_AUX0</code> + 
        /// i   .
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="mode"/> is not an accepted value.
        /// <code>GL_INVALID_OPERATION</code> is generated if none of the buffers indicated
        /// by <paramref name="mode"/> exists.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glDrawBuffer"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glDrawBuffer(GLenum mode);</para>
        /// </summary>
        /// <param name="mode">
        /// <para>
        /// Specifies up to four color buffers to be drawn into.
        /// Symbolic constants
        /// <code>GL_NONE</code>,
        /// <code>GL_FRONT_LEFT</code>,
        /// <code>GL_FRONT_RIGHT</code>,
        /// <code>GL_BACK_LEFT</code>,
        /// <code>GL_BACK_RIGHT</code>,
        /// <code>GL_FRONT</code>,
        /// <code>GL_BACK</code>,
        /// <code>GL_LEFT</code>,
        /// <code>GL_RIGHT</code>,
        /// <code>GL_FRONT_AND_BACK</code>, and
        /// <code>GL_AUX</code> i ,
        /// where  i  is between 0 and the value of <code>GL_AUX_BUFFERS</code> minus 1,
        /// are accepted.  (<code>GL_AUX_BUFFERS</code> is not the upper limit; use  <see cref="glGet"/> 
        /// to query the number of available aux buffers.)
        /// The initial value is <code>GL_FRONT</code> for single-buffered contexts,
        /// and <code>GL_BACK</code> for double-buffered contexts.
        /// </para>
        /// </param>
        /// <seealso cref="BlendFunc"/>
        /// <seealso cref="ColorMask"/>
        /// <seealso cref="IndexMask"/>
        /// <seealso cref="LogicOp"/>
        /// <seealso cref="ReadBuffer"/>
        public static void DrawBuffer(uint mode) {
            GLNative.glDrawBuffer(mode);
        }

        /// <summary>
        /// clear buffers to preset values
        /// <para>Require:</para> <para>GL_VERSION_1_0, GL_VERSION_ES_CM_1_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// If a buffer is not present,
        /// then a <see cref="glClear"/> directed at that buffer has no effect.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if any bit other than the four defined
        /// bits is set in <paramref name="mask"/>.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glClear"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glClear(GLbitfield mask);</para>
        /// </summary>
        /// <param name="mask">
        /// <para>
        /// Bitwise OR of masks that indicate the buffers to be cleared.
        /// The four masks are
        /// <code>GL_COLOR_BUFFER_BIT</code>,
        /// <code>GL_DEPTH_BUFFER_BIT</code>,
        /// <code>GL_ACCUM_BUFFER_BIT</code>, and
        /// <code>GL_STENCIL_BUFFER_BIT</code>.
        /// </para>
        /// </param>
        /// <seealso cref="ClearAccum"/>
        /// <seealso cref="ClearColor"/>
        /// <seealso cref="ClearDepth"/>
        /// <seealso cref="ClearIndex"/>
        /// <seealso cref="ClearStencil"/>
        /// <seealso cref="ColorMask"/>
        /// <seealso cref="DepthMask"/>
        /// <seealso cref="DrawBuffer"/>
        /// <seealso cref="Scissor"/>
        /// <seealso cref="StencilMask"/>
        public static void Clear(uint mask) {
            GLNative.glClear(mask);
        }

        /// <summary>
        /// specify clear values for the color buffers
        /// <para>Require:</para> <para>GL_VERSION_1_0, GL_VERSION_ES_CM_1_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glClearColor"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glClearColor(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha);</para>
        /// </summary>
        /// <param name="red">
        /// <para>
        /// Specify the red, green, blue, and alpha values used when the
        /// color buffers are cleared.
        /// The initial values are all 0.
        /// </para>
        /// </param>
        /// <param name="green">
        /// <para>
        /// Specify the red, green, blue, and alpha values used when the
        /// color buffers are cleared.
        /// The initial values are all 0.
        /// </para>
        /// </param>
        /// <param name="blue">
        /// <para>
        /// Specify the red, green, blue, and alpha values used when the
        /// color buffers are cleared.
        /// The initial values are all 0.
        /// </para>
        /// </param>
        /// <param name="alpha">
        /// <para>
        /// Specify the red, green, blue, and alpha values used when the
        /// color buffers are cleared.
        /// The initial values are all 0.
        /// </para>
        /// </param>
        /// <seealso cref="Clear"/>
        public static void ClearColor(float red, float green, float blue, float alpha) {
            GLNative.glClearColor(red, green, blue, alpha);
        }

        /// <summary>
        /// specify the clear value for the stencil buffer
        /// <para>Require:</para> <para>GL_VERSION_1_0, GL_VERSION_ES_CM_1_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glClearStencil"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glClearStencil(GLint s);</para>
        /// </summary>
        /// <param name="s">
        /// <para>
        /// Specifies the index used when the stencil buffer is cleared.
        /// The initial value is 0.
        /// </para>
        /// </param>
        /// <seealso cref="Clear"/>
        /// <seealso cref="StencilFunc"/>
        /// <seealso cref="StencilFuncSeparate"/>
        /// <seealso cref="StencilMask"/>
        /// <seealso cref="StencilMaskSeparate"/>
        /// <seealso cref="StencilOp"/>
        /// <seealso cref="StencilOpSeparate"/>
        public static void ClearStencil(int s) {
            GLNative.glClearStencil(s);
        }

        /// <summary>
        /// specify the clear value for the depth buffer
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glClearDepth"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glClearDepth(GLclampd depth);</para>
        /// </summary>
        /// <param name="depth">
        /// <para>
        /// Specifies the depth value used when the depth buffer is cleared. The
        /// initial value is 1.
        /// </para>
        /// </param>
        /// <seealso cref="Clear"/>
        public static void ClearDepth(double depth) {
            GLNative.glClearDepth(depth);
        }

        /// <summary>
        /// control the front and back writing of individual bits in the stencil planes
        /// <para>Require:</para> <para>GL_VERSION_1_0, GL_VERSION_ES_CM_1_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glStencilMask"/>  is the same as
        /// calling  <see cref="glStencilMaskSeparate"/> 
        /// with <paramref name="face"/> set to <code>GL_FRONT_AND_BACK</code>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glStencilMask"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glStencilMask(GLuint mask);</para>
        /// </summary>
        /// <param name="mask">
        /// <para>
        /// Specifies a bit mask to enable and disable writing of individual bits
        /// in the stencil planes.
        /// Initially, the mask is all 1's.
        /// </para>
        /// </param>
        /// <seealso cref="ColorMask"/>
        /// <seealso cref="DepthMask"/>
        /// <seealso cref="IndexMask"/>
        /// <seealso cref="StencilFunc"/>
        /// <seealso cref="StencilFuncSeparate"/>
        /// <seealso cref="StencilMaskSeparate"/>
        /// <seealso cref="StencilOp"/>
        /// <seealso cref="StencilOpSeparate"/>
        public static void StencilMask(uint mask) {
            GLNative.glStencilMask(mask);
        }

        /// <summary>
        /// enable and disable writing of frame buffer color components
        /// <para>Require:</para> <para>GL_VERSION_1_0, GL_VERSION_ES_CM_1_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glColorMask"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glColorMask(GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha);</para>
        /// </summary>
        /// <param name="red">
        /// <para>
        /// Specify whether red, green, blue, and alpha can or cannot be written
        /// into the frame buffer.
        /// The initial values are all <code>GL_TRUE</code>,
        /// indicating that the color components can be written.
        /// </para>
        /// </param>
        /// <param name="green">
        /// <para>
        /// Specify whether red, green, blue, and alpha can or cannot be written
        /// into the frame buffer.
        /// The initial values are all <code>GL_TRUE</code>,
        /// indicating that the color components can be written.
        /// </para>
        /// </param>
        /// <param name="blue">
        /// <para>
        /// Specify whether red, green, blue, and alpha can or cannot be written
        /// into the frame buffer.
        /// The initial values are all <code>GL_TRUE</code>,
        /// indicating that the color components can be written.
        /// </para>
        /// </param>
        /// <param name="alpha">
        /// <para>
        /// Specify whether red, green, blue, and alpha can or cannot be written
        /// into the frame buffer.
        /// The initial values are all <code>GL_TRUE</code>,
        /// indicating that the color components can be written.
        /// </para>
        /// </param>
        /// <seealso cref="Clear"/>
        /// <seealso cref="Color"/>
        /// <seealso cref="ColorPointer"/>
        /// <seealso cref="DepthMask"/>
        /// <seealso cref="Index"/>
        /// <seealso cref="IndexPointer"/>
        /// <seealso cref="IndexMask"/>
        /// <seealso cref="StencilMask"/>
        public static void ColorMask(bool red, bool green, bool blue, bool alpha) {
            GLNative.glColorMask(red, green, blue, alpha);
        }

        /// <summary>
        /// enable or disable writing into the depth buffer
        /// <para>Require:</para> <para>GL_VERSION_1_0, GL_VERSION_ES_CM_1_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glDepthMask"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glDepthMask(GLboolean flag);</para>
        /// </summary>
        /// <param name="flag">
        /// <para>
        /// Specifies whether the depth buffer is enabled for writing.
        /// If <paramref name="flag"/> is <code>GL_FALSE</code>,
        /// depth buffer writing is disabled.
        /// Otherwise, it is enabled.
        /// Initially, depth buffer writing is enabled.
        /// </para>
        /// </param>
        /// <seealso cref="ColorMask"/>
        /// <seealso cref="DepthFunc"/>
        /// <seealso cref="DepthRange"/>
        /// <seealso cref="IndexMask"/>
        /// <seealso cref="StencilMask"/>
        public static void DepthMask(bool flag) {
            GLNative.glDepthMask(flag);
        }

        /// <summary>
        /// enable or disable server-side GL capabilities
        /// <para>Require:</para> <para>GL_VERSION_1_0, GL_VERSION_ES_CM_1_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <code>GL_POLYGON_OFFSET_FILL</code>, <code>GL_POLYGON_OFFSET_LINE</code>,
        /// <code>GL_POLYGON_OFFSET_POINT</code>,
        /// <code>GL_COLOR_LOGIC_OP</code>, and <code>GL_INDEX_LOGIC_OP</code> are available
        /// only if the GL version is 1.1 or greater.
        /// <code>GL_RESCALE_NORMAL</code>, and <code>GL_TEXTURE_3D</code> are available only if the
        /// GL version is 1.2 or greater.
        /// <code>GL_MULTISAMPLE</code>,
        /// <code>GL_SAMPLE_ALPHA_TO_COVERAGE</code>,
        /// <code>GL_SAMPLE_ALPHA_TO_ONE</code>,
        /// <code>GL_SAMPLE_COVERAGE</code>,
        /// <code>GL_TEXTURE_CUBE_MAP</code>
        /// are available only if the GL version is 1.3 or greater.
        /// <code>GL_POINT_SPRITE</code>,
        /// <code>GL_VERTEX_PROGRAM_POINT_SIZE</code>, and
        /// <code>GL_VERTEX_PROGRAM_TWO_SIDE</code>
        /// is available only if the GL version is 2.0 or greater.
        /// <code>GL_COLOR_TABLE</code>, <code>GL_CONVOLUTION_1D</code>, <code>GL_CONVOLUTION_2D</code>,
        /// <code>GL_HISTOGRAM</code>, <code>GL_MINMAX</code>,
        /// <code>GL_POST_COLOR_MATRIX_COLOR_TABLE</code>,
        /// <code>GL_POST_CONVOLUTION_COLOR_TABLE</code>, and
        /// <code>GL_SEPARABLE_2D</code> are available only if <code>ARB_imaging</code> is returned
        /// from  <see cref="glGet"/>  with an argument of <code>GL_EXTENSIONS</code>.
        /// For OpenGL versions 1.3 and greater, or when <code>ARB_multitexture</code> is supported, <code>GL_TEXTURE_1D</code>,
        /// <code>GL_TEXTURE_2D</code>, <code>GL_TEXTURE_3D</code>, <code>GL_TEXTURE_GEN_S</code>,
        /// <code>GL_TEXTURE_GEN_T</code>, <code>GL_TEXTURE_GEN_R</code>, and <code>GL_TEXTURE_GEN_Q</code>
        /// enable or disable the respective state for the active texture unit
        /// specified with  <see cref="glActiveTexture"/> .
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="cap"/> is not one of the values
        /// listed previously.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glEnable"/> or  <see cref="glDisable"/> 
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glDisable(GLenum cap);</para>
        /// </summary>
        /// <param name="cap">
        /// Specifies a symbolic constant indicating a GL capability.
        /// </param>
        /// <seealso cref="ActiveTexture"/>
        /// <seealso cref="AlphaFunc"/>
        /// <seealso cref="BlendFunc"/>
        /// <seealso cref="ClipPlane"/>
        /// <seealso cref="ColorMaterial"/>
        /// <seealso cref="CullFace"/>
        /// <seealso cref="DepthFunc"/>
        /// <seealso cref="DepthRange"/>
        /// <seealso cref="EnableClientState"/>
        /// <seealso cref="Fog"/>
        /// <seealso cref="Get"/>
        /// <seealso cref="IsEnabled"/>
        /// <seealso cref="Light"/>
        /// <seealso cref="LightModel"/>
        /// <seealso cref="LineWidth"/>
        /// <seealso cref="LineStipple"/>
        /// <seealso cref="LogicOp"/>
        /// <seealso cref="Map1"/>
        /// <seealso cref="Map2"/>
        /// <seealso cref="Material"/>
        /// <seealso cref="Normal"/>
        /// <seealso cref="NormalPointer"/>
        /// <seealso cref="PointSize"/>
        /// <seealso cref="PolygonMode"/>
        /// <seealso cref="PolygonOffset"/>
        /// <seealso cref="PolygonStipple"/>
        /// <seealso cref="SampleCoverage"/>
        /// <seealso cref="Scissor"/>
        /// <seealso cref="StencilFunc"/>
        /// <seealso cref="StencilOp"/>
        /// <seealso cref="TexGen"/>
        /// <seealso cref="TexImage1D"/>
        /// <seealso cref="TexImage2D"/>
        /// <seealso cref="TexImage3D"/>
        public static void Disable(uint cap) {
            GLNative.glDisable(cap);
        }

        /// <summary>
        /// enable or disable server-side GL capabilities
        /// <para>Require:</para> <para>GL_VERSION_1_0, GL_VERSION_ES_CM_1_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <code>GL_POLYGON_OFFSET_FILL</code>, <code>GL_POLYGON_OFFSET_LINE</code>,
        /// <code>GL_POLYGON_OFFSET_POINT</code>,
        /// <code>GL_COLOR_LOGIC_OP</code>, and <code>GL_INDEX_LOGIC_OP</code> are available
        /// only if the GL version is 1.1 or greater.
        /// <code>GL_RESCALE_NORMAL</code>, and <code>GL_TEXTURE_3D</code> are available only if the
        /// GL version is 1.2 or greater.
        /// <code>GL_MULTISAMPLE</code>,
        /// <code>GL_SAMPLE_ALPHA_TO_COVERAGE</code>,
        /// <code>GL_SAMPLE_ALPHA_TO_ONE</code>,
        /// <code>GL_SAMPLE_COVERAGE</code>,
        /// <code>GL_TEXTURE_CUBE_MAP</code>
        /// are available only if the GL version is 1.3 or greater.
        /// <code>GL_POINT_SPRITE</code>,
        /// <code>GL_VERTEX_PROGRAM_POINT_SIZE</code>, and
        /// <code>GL_VERTEX_PROGRAM_TWO_SIDE</code>
        /// is available only if the GL version is 2.0 or greater.
        /// <code>GL_COLOR_TABLE</code>, <code>GL_CONVOLUTION_1D</code>, <code>GL_CONVOLUTION_2D</code>,
        /// <code>GL_HISTOGRAM</code>, <code>GL_MINMAX</code>,
        /// <code>GL_POST_COLOR_MATRIX_COLOR_TABLE</code>,
        /// <code>GL_POST_CONVOLUTION_COLOR_TABLE</code>, and
        /// <code>GL_SEPARABLE_2D</code> are available only if <code>ARB_imaging</code> is returned
        /// from  <see cref="glGet"/>  with an argument of <code>GL_EXTENSIONS</code>.
        /// For OpenGL versions 1.3 and greater, or when <code>ARB_multitexture</code> is supported, <code>GL_TEXTURE_1D</code>,
        /// <code>GL_TEXTURE_2D</code>, <code>GL_TEXTURE_3D</code>, <code>GL_TEXTURE_GEN_S</code>,
        /// <code>GL_TEXTURE_GEN_T</code>, <code>GL_TEXTURE_GEN_R</code>, and <code>GL_TEXTURE_GEN_Q</code>
        /// enable or disable the respective state for the active texture unit
        /// specified with  <see cref="glActiveTexture"/> .
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="cap"/> is not one of the values
        /// listed previously.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glEnable"/> or  <see cref="glDisable"/> 
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glEnable(GLenum cap);</para>
        /// </summary>
        /// <param name="cap">
        /// Specifies a symbolic constant indicating a GL capability.
        /// </param>
        /// <seealso cref="ActiveTexture"/>
        /// <seealso cref="AlphaFunc"/>
        /// <seealso cref="BlendFunc"/>
        /// <seealso cref="ClipPlane"/>
        /// <seealso cref="ColorMaterial"/>
        /// <seealso cref="CullFace"/>
        /// <seealso cref="DepthFunc"/>
        /// <seealso cref="DepthRange"/>
        /// <seealso cref="EnableClientState"/>
        /// <seealso cref="Fog"/>
        /// <seealso cref="Get"/>
        /// <seealso cref="IsEnabled"/>
        /// <seealso cref="Light"/>
        /// <seealso cref="LightModel"/>
        /// <seealso cref="LineWidth"/>
        /// <seealso cref="LineStipple"/>
        /// <seealso cref="LogicOp"/>
        /// <seealso cref="Map1"/>
        /// <seealso cref="Map2"/>
        /// <seealso cref="Material"/>
        /// <seealso cref="Normal"/>
        /// <seealso cref="NormalPointer"/>
        /// <seealso cref="PointSize"/>
        /// <seealso cref="PolygonMode"/>
        /// <seealso cref="PolygonOffset"/>
        /// <seealso cref="PolygonStipple"/>
        /// <seealso cref="SampleCoverage"/>
        /// <seealso cref="Scissor"/>
        /// <seealso cref="StencilFunc"/>
        /// <seealso cref="StencilOp"/>
        /// <seealso cref="TexGen"/>
        /// <seealso cref="TexImage1D"/>
        /// <seealso cref="TexImage2D"/>
        /// <seealso cref="TexImage3D"/>
        public static void Enable(uint cap) {
            GLNative.glEnable(cap);
        }

        /// <summary>
        /// block until all GL execution is complete
        /// <para>Require:</para> <para>GL_VERSION_1_0, GL_VERSION_ES_CM_1_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <see cref="glFinish"/> requires a round trip to the server.
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glFinish"/> is executed between
        /// the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glFinish();</para>
        /// </summary>
        /// <seealso cref="Flush"/>
        public static void Finish() {
            GLNative.glFinish();
        }

        /// <summary>
        /// force execution of GL commands in finite time
        /// <para>Require:</para> <para>GL_VERSION_1_0, GL_VERSION_ES_CM_1_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glFlush"/> can return at any time.
        /// It does not wait until the execution of all previously
        /// issued GL commands is complete.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glFlush"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glFlush();</para>
        /// </summary>
        /// <seealso cref="Finish"/>
        public static void Flush() {
            GLNative.glFlush();
        }

        /// <summary>
        /// specify pixel arithmetic
        /// <para>Require:</para> <para>GL_VERSION_1_0, GL_VERSION_ES_CM_1_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// Incoming (source) alpha is correctly thought of as a material opacity,
        /// ranging from 1.0 
        /// (  
        /// K 
        /// A 
        /// ),
        /// representing complete opacity,
        /// to 0.0 (0), representing complete
        /// transparency.
        /// When more than one color buffer is enabled for drawing,
        /// the GL performs blending separately for each enabled buffer,
        /// using the contents of that buffer for destination color.
        /// (See  <see cref="glDrawBuffer"/> .)
        /// Blending affects only RGBA rendering.
        /// It is ignored by color index renderers.
        /// <code>GL_CONSTANT_COLOR</code>, <code>GL_ONE_MINUS_CONSTANT_COLOR</code>,
        /// <code>GL_CONSTANT_ALPHA</code>, <code>GL_ONE_MINUS_CONSTANT_ALPHA</code> are available only
        /// if the GL version is 1.4 or greater or if the <code>ARB_imaging</code> is
        /// supported by your implementation.
        /// <code>GL_SRC_COLOR</code> and <code>GL_ONE_MINUS_SRC_COLOR</code> are valid only for
        /// <paramref name="sfactor"/> if the GL version is 1.4 or greater.
        /// <code>GL_DST_COLOR</code> and <code>GL_ONE_MINUS_DST_COLOR</code> are valid only for
        /// <paramref name="dfactor"/> if the GL version is 1.4 or greater.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if either <paramref name="sfactor"/> or <paramref name="dfactor"/> is not an
        /// accepted value.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glBlendFunc"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glBlendFunc(GLenum sfactor, GLenum dfactor);</para>
        /// </summary>
        /// <param name="sfactor">
        /// <para>
        /// Specifies how the red, green, blue,
        /// and alpha source blending factors are computed.
        /// The following symbolic constants are accepted:
        /// <code>GL_ZERO</code>,
        /// <code>GL_ONE</code>,
        /// <code>GL_SRC_COLOR</code>,
        /// <code>GL_ONE_MINUS_SRC_COLOR</code>,
        /// <code>GL_DST_COLOR</code>,
        /// <code>GL_ONE_MINUS_DST_COLOR</code>,
        /// <code>GL_SRC_ALPHA</code>,
        /// <code>GL_ONE_MINUS_SRC_ALPHA</code>,
        /// <code>GL_DST_ALPHA</code>,
        /// <code>GL_ONE_MINUS_DST_ALPHA</code>,
        /// <code>GL_CONSTANT_COLOR</code>,
        /// <code>GL_ONE_MINUS_CONSTANT_COLOR</code>,
        /// <code>GL_CONSTANT_ALPHA</code>,
        /// <code>GL_ONE_MINUS_CONSTANT_ALPHA</code>, and
        /// <code>GL_SRC_ALPHA_SATURATE</code>.
        /// The initial value is <code>GL_ONE</code>.
        /// </para>
        /// </param>
        /// <param name="dfactor">
        /// <para>
        /// Specifies how the red, green, blue,
        /// and alpha destination blending factors are computed.
        /// The following symbolic constants are accepted:
        /// <code>GL_ZERO</code>,
        /// <code>GL_ONE</code>,
        /// <code>GL_SRC_COLOR</code>,
        /// <code>GL_ONE_MINUS_SRC_COLOR</code>,
        /// <code>GL_DST_COLOR</code>,
        /// <code>GL_ONE_MINUS_DST_COLOR</code>,
        /// <code>GL_SRC_ALPHA</code>,
        /// <code>GL_ONE_MINUS_SRC_ALPHA</code>,
        /// <code>GL_DST_ALPHA</code>,
        /// <code>GL_ONE_MINUS_DST_ALPHA</code>.
        /// <code>GL_CONSTANT_COLOR</code>,
        /// <code>GL_ONE_MINUS_CONSTANT_COLOR</code>,
        /// <code>GL_CONSTANT_ALPHA</code>, and
        /// <code>GL_ONE_MINUS_CONSTANT_ALPHA</code>.
        /// The initial value is <code>GL_ZERO</code>.
        /// </para>
        /// </param>
        /// <seealso cref="AlphaFunc"/>
        /// <seealso cref="BlendColor"/>
        /// <seealso cref="BlendEquation"/>
        /// <seealso cref="BlendFuncSeparate"/>
        /// <seealso cref="Clear"/>
        /// <seealso cref="DrawBuffer"/>
        /// <seealso cref="Enable"/>
        /// <seealso cref="LogicOp"/>
        /// <seealso cref="StencilFunc"/>
        public static void BlendFunc(uint sfactor, uint dfactor) {
            GLNative.glBlendFunc(sfactor, dfactor);
        }

        /// <summary>
        /// specify a logical pixel operation for color index rendering
        /// <para>Require:</para> <para>GL_VERSION_1_0, GL_VERSION_ES_CM_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// Color index logical operations are always supported. RGBA logical
        /// operations are supported only if the GL version is 1.1 or greater.
        /// When more than one RGBA color or index buffer is enabled for drawing,
        /// logical operations are performed separately for each enabled buffer,
        /// using for the destination value the contents of that buffer
        /// (see  <see cref="glDrawBuffer"/> ).
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="opcode"/> is not an accepted value.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glLogicOp"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glLogicOp(GLenum opcode);</para>
        /// </summary>
        /// <param name="opcode">
        /// <para>
        /// Specifies a symbolic constant that selects a logical operation.
        /// The following symbols are accepted:
        /// <code>GL_CLEAR</code>,
        /// <code>GL_SET</code>,
        /// <code>GL_COPY</code>,
        /// <code>GL_COPY_INVERTED</code>,
        /// <code>GL_NOOP</code>,
        /// <code>GL_INVERT</code>,
        /// <code>GL_AND</code>,
        /// <code>GL_NAND</code>,
        /// <code>GL_OR</code>,
        /// <code>GL_NOR</code>,
        /// <code>GL_XOR</code>,
        /// <code>GL_EQUIV</code>,
        /// <code>GL_AND_REVERSE</code>,
        /// <code>GL_AND_INVERTED</code>,
        /// <code>GL_OR_REVERSE</code>, and
        /// <code>GL_OR_INVERTED</code>. The initial value is <code>GL_COPY</code>.
        /// </para>
        /// </param>
        /// <seealso cref="AlphaFunc"/>
        /// <seealso cref="BlendFunc"/>
        /// <seealso cref="DrawBuffer"/>
        /// <seealso cref="Enable"/>
        /// <seealso cref="StencilOp"/>
        public static void LogicOp(uint opcode) {
            GLNative.glLogicOp(opcode);
        }

        /// <summary>
        /// set front and back function and reference value for stencil testing
        /// <para>Require:</para> <para>GL_VERSION_1_0, GL_VERSION_ES_CM_1_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// Initially, the stencil test is disabled.
        /// If there is no stencil buffer,
        /// no stencil modification can occur and it is as if
        /// the stencil test always passes.
        /// <see cref="glStencilFunc"/>  is the same as
        /// calling  <see cref="glStencilFuncSeparate"/> 
        /// with <paramref name="face"/> set to <code>GL_FRONT_AND_BACK</code>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="func"/> is not one of the eight
        /// accepted values.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glStencilFunc"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glStencilFunc(GLenum func, GLint ref, GLuint mask);</para>
        /// </summary>
        /// <param name="func">
        /// <para>
        /// Specifies the test function.
        /// Eight symbolic constants are valid:
        /// <code>GL_NEVER</code>,
        /// <code>GL_LESS</code>,
        /// <code>GL_LEQUAL</code>,
        /// <code>GL_GREATER</code>,
        /// <code>GL_GEQUAL</code>,
        /// <code>GL_EQUAL</code>,
        /// <code>GL_NOTEQUAL</code>, and
        /// <code>GL_ALWAYS</code>. The initial value is <code>GL_ALWAYS</code>.
        /// </para>
        /// </param>
        /// <param name="r">
        /// <para>
        /// Specifies the reference value for the stencil test.
        /// <paramref name="r"/> is clamped to the range 
        /// 0 
        /// 2 
        /// n 
        /// - 
        /// 1 
        /// ,
        /// where 
        /// n   
        /// is the number of bitplanes in the stencil buffer. The
        /// initial value is 0.
        /// </para>
        /// </param>
        /// <param name="mask">
        /// <para>
        /// Specifies a mask that is ANDed with both the reference value
        /// and the stored stencil value when the test is done. The initial value
        /// is all 1's.
        /// </para>
        /// </param>
        /// <seealso cref="AlphaFunc"/>
        /// <seealso cref="BlendFunc"/>
        /// <seealso cref="DepthFunc"/>
        /// <seealso cref="Enable"/>
        /// <seealso cref="LogicOp"/>
        /// <seealso cref="StencilFuncSeparate"/>
        /// <seealso cref="StencilMask"/>
        /// <seealso cref="StencilMaskSeparate"/>
        /// <seealso cref="StencilOp"/>
        /// <seealso cref="StencilOpSeparate"/>
        public static void StencilFunc(uint func, int r, uint mask) {
            GLNative.glStencilFunc(func, r, mask);
        }

        /// <summary>
        /// set front and back stencil test actions
        /// <para>Require:</para> <para>GL_VERSION_1_0, GL_VERSION_ES_CM_1_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <code>GL_DECR_WRAP</code> and <code>GL_INCR_WRAP</code> are available only if the GL
        /// version is 1.4 or greater.
        /// Initially the stencil test is disabled.
        /// If there is no stencil buffer,
        /// no stencil modification can occur
        /// and it is as if the stencil tests always pass,
        /// regardless of any call to <see cref="glStencilOp"/>.
        /// <see cref="glStencilOp"/>  is the same as
        /// calling  <see cref="glStencilOpSeparate"/> 
        /// with <paramref name="face"/> set to <code>GL_FRONT_AND_BACK</code>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="sfail"/>,
        /// <paramref name="dpfail"/>, or <paramref name="dppass"/> is any value other than the eight defined constant values.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glStencilOp"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glStencilOp(GLenum sfail, GLenum dpfail, GLenum dppass);</para>
        /// </summary>
        /// <param name="sfail">
        /// <para>
        /// Specifies the action to take when the stencil test fails.
        /// Eight symbolic constants are accepted:
        /// <code>GL_KEEP</code>,
        /// <code>GL_ZERO</code>,
        /// <code>GL_REPLACE</code>,
        /// <code>GL_INCR</code>,
        /// <code>GL_INCR_WRAP</code>,
        /// <code>GL_DECR</code>,
        /// <code>GL_DECR_WRAP</code>, and
        /// <code>GL_INVERT</code>. The initial value is <code>GL_KEEP</code>.
        /// </para>
        /// </param>
        /// <param name="dpfail">
        /// <para>
        /// Specifies the stencil action when the stencil test passes,
        /// but the depth test fails.
        /// <paramref name="dpfail"/> accepts the same symbolic constants as <paramref name="sfail"/>. The initial value
        /// is <code>GL_KEEP</code>.
        /// </para>
        /// </param>
        /// <param name="dppass">
        /// <para>
        /// Specifies the stencil action when both the stencil test and the depth
        /// test pass, or when the stencil test passes and either there is no
        /// depth buffer or depth testing is not enabled.
        /// <paramref name="dppass"/> accepts the same symbolic constants as <paramref name="sfail"/>. The initial value
        /// is <code>GL_KEEP</code>.
        /// </para>
        /// </param>
        /// <seealso cref="AlphaFunc"/>
        /// <seealso cref="BlendFunc"/>
        /// <seealso cref="DepthFunc"/>
        /// <seealso cref="Enable"/>
        /// <seealso cref="LogicOp"/>
        /// <seealso cref="StencilFunc"/>
        /// <seealso cref="StencilFuncSeparate"/>
        /// <seealso cref="StencilMask"/>
        /// <seealso cref="StencilMaskSeparate"/>
        /// <seealso cref="StencilOpSeparate"/>
        public static void StencilOp(uint sfail, uint dpfail, uint dppass) {
            GLNative.glStencilOp(sfail, dpfail, dppass);
        }

        /// <summary>
        /// specify the value used for depth buffer comparisons
        /// <para>Require:</para> <para>GL_VERSION_1_0, GL_VERSION_ES_CM_1_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// Even if the depth buffer exists and the depth mask is non-zero, the
        /// depth buffer is not updated if the depth test is disabled.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="func"/> is not an accepted value.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glDepthFunc"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glDepthFunc(GLenum func);</para>
        /// </summary>
        /// <param name="func">
        /// <para>
        /// Specifies the depth comparison function.
        /// Symbolic constants
        /// <code>GL_NEVER</code>,
        /// <code>GL_LESS</code>,
        /// <code>GL_EQUAL</code>,
        /// <code>GL_LEQUAL</code>,
        /// <code>GL_GREATER</code>,
        /// <code>GL_NOTEQUAL</code>,
        /// <code>GL_GEQUAL</code>, and
        /// <code>GL_ALWAYS</code> are accepted.
        /// The initial value is <code>GL_LESS</code>.
        /// </para>
        /// </param>
        /// <seealso cref="DepthRange"/>
        /// <seealso cref="Enable"/>
        /// <seealso cref="PolygonOffset"/>
        public static void DepthFunc(uint func) {
            GLNative.glDepthFunc(func);
        }

        /// <summary>
        /// set pixel storage modes
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The pixel storage modes in effect when
        /// <see cref="glDrawPixels"/> ,
        /// <see cref="glReadPixels"/> ,
        /// <see cref="glTexImage1D"/> ,
        /// <see cref="glTexImage2D"/> ,
        /// <see cref="glTexImage3D"/> ,
        /// <see cref="glTexSubImage1D"/> ,
        /// <see cref="glTexSubImage2D"/> ,
        /// <see cref="glTexSubImage3D"/> ,
        /// <see cref="glBitmap"/> ,
        /// or  <see cref="glPolygonStipple"/>  is placed in a display list control the interpretation
        /// of memory data.
        /// Likewise, if the <code>ARB_imaging</code> extension is supported, the pixel
        /// storage modes in effect when
        /// <see cref="glColorTable"/> ,
        /// <see cref="glColorSubTable"/> ,
        /// <see cref="glConvolutionFilter1D"/> ,
        /// <see cref="glConvolutionFilter2D"/> , of
        /// <see cref="glSeparableFilter2D"/>  is placed in a display list control the
        /// interpretation of memory data.
        /// The pixel storage modes in effect when a display list is executed are
        /// not significant.
        /// Pixel storage modes are client state and must be pushed and restored
        /// using
        /// <see cref="glPushClientAttrib"/>  and  <see cref="glPopClientAttrib"/> .
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="pname"/> is not an accepted value.
        /// <code>GL_INVALID_VALUE</code> is generated if a negative row length,
        /// pixel skip,
        /// or row skip value is specified,
        /// or if alignment is specified as other than 1, 2, 4, or 8.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glPixelStore"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glPixelStoref(GLenum pname, GLfloat param);</para>
        /// </summary>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of the parameter to be set.
        /// Six values affect the packing of pixel data into memory:
        /// <code>GL_PACK_SWAP_BYTES</code>,
        /// <code>GL_PACK_LSB_FIRST</code>,
        /// <code>GL_PACK_ROW_LENGTH</code>,
        /// <code>GL_PACK_IMAGE_HEIGHT</code>,
        /// <code>GL_PACK_SKIP_PIXELS</code>,
        /// <code>GL_PACK_SKIP_ROWS</code>,
        /// <code>GL_PACK_SKIP_IMAGES</code>, and
        /// <code>GL_PACK_ALIGNMENT</code>.
        /// Six more affect the unpacking of pixel data  from  memory:
        /// <code>GL_UNPACK_SWAP_BYTES</code>,
        /// <code>GL_UNPACK_LSB_FIRST</code>,
        /// <code>GL_UNPACK_ROW_LENGTH</code>,
        /// <code>GL_UNPACK_IMAGE_HEIGHT</code>,
        /// <code>GL_UNPACK_SKIP_PIXELS</code>,
        /// <code>GL_UNPACK_SKIP_ROWS</code>,
        /// <code>GL_UNPACK_SKIP_IMAGES</code>, and
        /// <code>GL_UNPACK_ALIGNMENT</code>.
        /// </para>
        /// </param>
        /// <param name="param">
        /// Specifies the value that <paramref name="pname"/> is set to.
        /// </param>
        /// <seealso cref="Bitmap"/>
        /// <seealso cref="ColorTable"/>
        /// <seealso cref="ColorSubTable"/>
        /// <seealso cref="ConvolutionFilter1D"/>
        /// <seealso cref="ConvolutionFilter2D"/>
        /// <seealso cref="SeparableFilter2D"/>
        /// <seealso cref="DrawPixels"/>
        /// <seealso cref="Histogram"/>
        /// <seealso cref="Minmax"/>
        /// <seealso cref="PixelMap"/>
        /// <seealso cref="PixelTransfer"/>
        /// <seealso cref="PixelZoom"/>
        /// <seealso cref="PolygonStipple"/>
        /// <seealso cref="PushClientAttrib"/>
        /// <seealso cref="ReadPixels"/>
        /// <seealso cref="TexImage1D"/>
        /// <seealso cref="TexImage2D"/>
        /// <seealso cref="TexImage3D"/>
        /// <seealso cref="TexSubImage1D"/>
        /// <seealso cref="TexSubImage2D"/>
        /// <seealso cref="TexSubImage3D"/>
        public static void PixelStoref(uint pname, float param) {
            GLNative.glPixelStoref(pname, param);
        }

        /// <summary>
        /// set pixel storage modes
        /// <para>Require:</para> <para>GL_VERSION_1_0, GL_VERSION_ES_CM_1_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The pixel storage modes in effect when
        /// <see cref="glDrawPixels"/> ,
        /// <see cref="glReadPixels"/> ,
        /// <see cref="glTexImage1D"/> ,
        /// <see cref="glTexImage2D"/> ,
        /// <see cref="glTexImage3D"/> ,
        /// <see cref="glTexSubImage1D"/> ,
        /// <see cref="glTexSubImage2D"/> ,
        /// <see cref="glTexSubImage3D"/> ,
        /// <see cref="glBitmap"/> ,
        /// or  <see cref="glPolygonStipple"/>  is placed in a display list control the interpretation
        /// of memory data.
        /// Likewise, if the <code>ARB_imaging</code> extension is supported, the pixel
        /// storage modes in effect when
        /// <see cref="glColorTable"/> ,
        /// <see cref="glColorSubTable"/> ,
        /// <see cref="glConvolutionFilter1D"/> ,
        /// <see cref="glConvolutionFilter2D"/> , of
        /// <see cref="glSeparableFilter2D"/>  is placed in a display list control the
        /// interpretation of memory data.
        /// The pixel storage modes in effect when a display list is executed are
        /// not significant.
        /// Pixel storage modes are client state and must be pushed and restored
        /// using
        /// <see cref="glPushClientAttrib"/>  and  <see cref="glPopClientAttrib"/> .
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="pname"/> is not an accepted value.
        /// <code>GL_INVALID_VALUE</code> is generated if a negative row length,
        /// pixel skip,
        /// or row skip value is specified,
        /// or if alignment is specified as other than 1, 2, 4, or 8.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glPixelStore"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glPixelStorei(GLenum pname, GLint param);</para>
        /// </summary>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of the parameter to be set.
        /// Six values affect the packing of pixel data into memory:
        /// <code>GL_PACK_SWAP_BYTES</code>,
        /// <code>GL_PACK_LSB_FIRST</code>,
        /// <code>GL_PACK_ROW_LENGTH</code>,
        /// <code>GL_PACK_IMAGE_HEIGHT</code>,
        /// <code>GL_PACK_SKIP_PIXELS</code>,
        /// <code>GL_PACK_SKIP_ROWS</code>,
        /// <code>GL_PACK_SKIP_IMAGES</code>, and
        /// <code>GL_PACK_ALIGNMENT</code>.
        /// Six more affect the unpacking of pixel data  from  memory:
        /// <code>GL_UNPACK_SWAP_BYTES</code>,
        /// <code>GL_UNPACK_LSB_FIRST</code>,
        /// <code>GL_UNPACK_ROW_LENGTH</code>,
        /// <code>GL_UNPACK_IMAGE_HEIGHT</code>,
        /// <code>GL_UNPACK_SKIP_PIXELS</code>,
        /// <code>GL_UNPACK_SKIP_ROWS</code>,
        /// <code>GL_UNPACK_SKIP_IMAGES</code>, and
        /// <code>GL_UNPACK_ALIGNMENT</code>.
        /// </para>
        /// </param>
        /// <param name="param">
        /// Specifies the value that <paramref name="pname"/> is set to.
        /// </param>
        /// <seealso cref="Bitmap"/>
        /// <seealso cref="ColorTable"/>
        /// <seealso cref="ColorSubTable"/>
        /// <seealso cref="ConvolutionFilter1D"/>
        /// <seealso cref="ConvolutionFilter2D"/>
        /// <seealso cref="SeparableFilter2D"/>
        /// <seealso cref="DrawPixels"/>
        /// <seealso cref="Histogram"/>
        /// <seealso cref="Minmax"/>
        /// <seealso cref="PixelMap"/>
        /// <seealso cref="PixelTransfer"/>
        /// <seealso cref="PixelZoom"/>
        /// <seealso cref="PolygonStipple"/>
        /// <seealso cref="PushClientAttrib"/>
        /// <seealso cref="ReadPixels"/>
        /// <seealso cref="TexImage1D"/>
        /// <seealso cref="TexImage2D"/>
        /// <seealso cref="TexImage3D"/>
        /// <seealso cref="TexSubImage1D"/>
        /// <seealso cref="TexSubImage2D"/>
        /// <seealso cref="TexSubImage3D"/>
        public static void PixelStorei(uint pname, int param) {
            GLNative.glPixelStorei(pname, param);
        }

        /// <summary>
        /// select a color buffer source for pixels
        /// <para>Require:</para> <para>GL_VERSION_1_0, GL_ES_VERSION_3_0</para>
        /// Supported: <para>GL</para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="mode"/> is not one of the twelve
        /// (or more) accepted values.
        /// <code>GL_INVALID_OPERATION</code> is generated if <paramref name="mode"/> specifies a buffer
        /// that does not exist.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glReadBuffer"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glReadBuffer(GLenum mode);</para>
        /// </summary>
        /// <param name="mode">
        /// <para>
        /// Specifies a color buffer.
        /// Accepted values are
        /// <code>GL_FRONT_LEFT</code>,
        /// <code>GL_FRONT_RIGHT</code>,
        /// <code>GL_BACK_LEFT</code>,
        /// <code>GL_BACK_RIGHT</code>,
        /// <code>GL_FRONT</code>,
        /// <code>GL_BACK</code>,
        /// <code>GL_LEFT</code>,
        /// <code>GL_RIGHT</code>, and
        /// <code>GL_AUX</code> i ,
        /// where  i  is between 0 and the value of <code>GL_AUX_BUFFERS</code> minus 1.
        /// </para>
        /// </param>
        /// <seealso cref="CopyPixels"/>
        /// <seealso cref="CopyTexImage1D"/>
        /// <seealso cref="CopyTexImage2D"/>
        /// <seealso cref="CopyTexSubImage1D"/>
        /// <seealso cref="CopyTexSubImage2D"/>
        /// <seealso cref="CopyTexSubImage3D"/>
        /// <seealso cref="DrawBuffer"/>
        /// <seealso cref="ReadPixels"/>
        public static void ReadBuffer(uint mode) {
            GLNative.glReadBuffer(mode);
        }

        /// <summary>
        /// return error information
        /// <para>Require:</para> <para>GL_VERSION_1_0, GL_VERSION_ES_CM_1_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <code>GL_TABLE_TOO_LARGE</code> was introduced in GL version 1.2.
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glGetError"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// In this case, <see cref="glGetError"/> returns 0.
        /// </para>
        /// Original: <para>GLenum glGetError();</para>
        /// </summary>
        public static uint GetError() {
            return GLNative.glGetError();
        }

        /// <summary>
        /// test whether a capability is enabled
        /// <para>Require:</para> <para>GL_VERSION_1_0, GL_VERSION_ES_CM_1_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// If an error is generated,
        /// <see cref="glIsEnabled"/> returns 0.
        /// <code>GL_COLOR_LOGIC_OP</code>,
        /// <code>GL_COLOR_ARRAY</code>,
        /// <code>GL_EDGE_FLAG_ARRAY</code>,
        /// <code>GL_INDEX_ARRAY</code>,
        /// <code>GL_INDEX_LOGIC_OP</code>,
        /// <code>GL_NORMAL_ARRAY</code>,
        /// <code>GL_POLYGON_OFFSET_FILL</code>,
        /// <code>GL_POLYGON_OFFSET_LINE</code>,
        /// <code>GL_POLYGON_OFFSET_POINT</code>,
        /// <code>GL_TEXTURE_COORD_ARRAY</code>, and
        /// <code>GL_VERTEX_ARRAY</code>
        /// are available only
        /// if the GL version is 1.1 or greater.
        /// <code>GL_RESCALE_NORMAL</code>, and <code>GL_TEXTURE_3D</code> are available only if the GL
        /// version is 1.2 or greater.
        /// <code>GL_MULTISAMPLE</code>,
        /// <code>GL_SAMPLE_ALPHA_TO_COVERAGE</code>,
        /// <code>GL_SAMPLE_ALPHA_TO_ONE</code>,
        /// <code>GL_SAMPLE_COVERAGE</code>,
        /// <code>GL_TEXTURE_CUBE_MAP</code>
        /// are available only if the GL version is 1.3 or greater.
        /// <code>GL_FOG_COORD_ARRAY</code> and <code>GL_SECONDARY_COLOR_ARRAY</code>
        /// are available only if the GL version is 1.4 or greater.
        /// <code>GL_POINT_SPRITE</code>,
        /// <code>GL_VERTEX_PROGRAM_POINT_SIZE</code>, and
        /// <code>GL_VERTEX_PROGRAM_TWO_SIDE</code>
        /// are available only if the GL version is 2.0 or greater.
        /// <code>GL_COLOR_TABLE</code>, <code>GL_CONVOLUTION_1D</code>, <code>GL_CONVOLUTION_2D</code>,
        /// <code>GL_HISTOGRAM</code>, <code>GL_MINMAX</code>,
        /// <code>GL_POST_COLOR_MATRIX_COLOR_TABLE</code>,
        /// <code>GL_POST_CONVOLUTION_COLOR_TABLE</code>, and
        /// <code>GL_SEPARABLE_2D</code> are available only if <code>ARB_imaging</code> is
        /// returned when  <see cref="glGet"/>  is called with <code>GL_EXTENSIONS</code>.
        /// For OpenGL versions 1.3 and greater, or when the <code>ARB_multitexture</code> extension is supported, the following
        /// parameters return the associated value for the active texture unit:
        /// <code>GL_TEXTURE_1D</code>,
        /// <code>GL_TEXTURE_2D</code>,
        /// <code>GL_TEXTURE_3D</code>,
        /// <code>GL_TEXTURE_CUBE_MAP</code>,
        /// <code>GL_TEXTURE_GEN_S</code>,
        /// <code>GL_TEXTURE_GEN_T</code>,
        /// <code>GL_TEXTURE_GEN_R</code>,
        /// <code>GL_TEXTURE_GEN_Q</code>,
        /// <code>GL_TEXTURE_MATRIX</code>, and
        /// <code>GL_TEXTURE_STACK_DEPTH</code>.
        /// Likewise, the following parameters return the associated value for the
        /// active client texture unit:
        /// <code>GL_TEXTURE_COORD_ARRAY</code>,
        /// <code>GL_TEXTURE_COORD_ARRAY_SIZE</code>,
        /// <code>GL_TEXTURE_COORD_ARRAY_STRIDE</code>,
        /// <code>GL_TEXTURE_COORD_ARRAY_TYPE</code>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="cap"/> is not an accepted value.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glIsEnabled"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>GLboolean glIsEnabled(GLenum cap);</para>
        /// </summary>
        /// <param name="cap">
        /// Specifies a symbolic constant indicating a GL capability.
        /// </param>
        /// <seealso cref="Enable"/>
        /// <seealso cref="EnableClientState"/>
        /// <seealso cref="Get"/>
        public static bool IsEnabled(uint cap) {
            return GLNative.glIsEnabled(cap);
        }

        /// <summary>
        /// specify mapping of depth values from normalized device coordinates to window coordinates
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// It is not necessary that <paramref name="nearVal"/> be less than <paramref name="farVal"/>.
        /// Reverse mappings such as 
        /// nearVal 
        /// = 
        /// 1 
        /// ,
        /// and 
        /// farVal 
        /// = 
        /// 0 
        /// are acceptable.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glDepthRange"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glDepthRange(GLclampd nearVal, GLclampd farVal);</para>
        /// </summary>
        /// <param name="nearVal">
        /// <para>
        /// Specifies the mapping of the near clipping plane to window coordinates.
        /// The initial value is 0.
        /// </para>
        /// </param>
        /// <param name="farVal">
        /// <para>
        /// Specifies the mapping of the far clipping plane to window coordinates.
        /// The initial value is 1.
        /// </para>
        /// </param>
        /// <seealso cref="DepthFunc"/>
        /// <seealso cref="PolygonOffset"/>
        /// <seealso cref="Viewport"/>
        public static void DepthRange(double nearVal, double farVal) {
            GLNative.glDepthRange(nearVal, farVal);
        }

        /// <summary>
        /// set the viewport
        /// <para>Require:</para> <para>GL_VERSION_1_0, GL_VERSION_ES_CM_1_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if either <paramref name="width"/> or <paramref name="height"/> is negative.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glViewport"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glViewport(GLint x, GLint y, GLsizei width, GLsizei height);</para>
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify the lower left corner of the viewport rectangle,
        /// in pixels. The initial value is (0,0).
        /// </para>
        /// </param>
        /// <param name="y">
        /// <para>
        /// Specify the lower left corner of the viewport rectangle,
        /// in pixels. The initial value is (0,0).
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// Specify the width and height
        /// of the viewport.
        /// When a GL context is first attached to a window,
        /// <paramref name="width"/> and <paramref name="height"/> are set to the dimensions of that
        /// window.
        /// </para>
        /// </param>
        /// <param name="height">
        /// <para>
        /// Specify the width and height
        /// of the viewport.
        /// When a GL context is first attached to a window,
        /// <paramref name="width"/> and <paramref name="height"/> are set to the dimensions of that
        /// window.
        /// </para>
        /// </param>
        /// <seealso cref="DepthRange"/>
        public static void Viewport(int x, int y, int width, int height) {
            GLNative.glViewport(x, y, width, height);
        }

        /// <summary>
        /// create or replace a display list
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glCallList"/>  and  <see cref="glCallLists"/>  can be entered into display lists.
        /// Commands in the display list or lists executed by  <see cref="glCallList"/> 
        /// or  <see cref="glCallLists"/>  are not included in the display list being created,
        /// even if the list creation mode is <code>GL_COMPILE_AND_EXECUTE</code>.
        /// A display list is just a group of commands and arguments, so errors
        /// generated by commands in a display list must be generated when the list is
        /// executed. If the list is created in <code>GL_COMPILE</code> mode, errors are
        /// not generated until the list is executed.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="list"/> is 0.
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="mode"/> is not an accepted value.
        /// <code>GL_INVALID_OPERATION</code> is generated if  <see cref="glEndList"/>  is called
        /// without a preceding <see cref="glNewList"/>,
        /// or if <see cref="glNewList"/> is called while a display list is being defined.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glNewList"/> or  <see cref="glEndList"/> 
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// <code>GL_OUT_OF_MEMORY</code> is generated if there is insufficient memory to
        /// compile the display list. If the GL version is 1.1 or greater, no
        /// change is made to the previous contents of the display list, if any,
        /// and no other change is made to the GL state. (It is as if no attempt
        /// had been made to create the new display list.)
        /// </para>
        /// Original: <para>void glNewList(GLuint list, GLenum mode);</para>
        /// </summary>
        /// <param name="list">
        /// Specifies the display-list name.
        /// </param>
        /// <param name="mode">
        /// <para>
        /// Specifies the compilation mode,
        /// which can be
        /// <code>GL_COMPILE</code> or
        /// <code>GL_COMPILE_AND_EXECUTE</code>.
        /// </para>
        /// </param>
        /// <seealso cref="CallList"/>
        /// <seealso cref="CallLists"/>
        /// <seealso cref="DeleteLists"/>
        /// <seealso cref="GenLists"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void NewList(uint list, uint mode) {
            GLNative.glNewList(list, mode);
        }

        /// <summary>
        /// create or replace a display list
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glCallList"/>  and  <see cref="glCallLists"/>  can be entered into display lists.
        /// Commands in the display list or lists executed by  <see cref="glCallList"/> 
        /// or  <see cref="glCallLists"/>  are not included in the display list being created,
        /// even if the list creation mode is <code>GL_COMPILE_AND_EXECUTE</code>.
        /// A display list is just a group of commands and arguments, so errors
        /// generated by commands in a display list must be generated when the list is
        /// executed. If the list is created in <code>GL_COMPILE</code> mode, errors are
        /// not generated until the list is executed.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="list"/> is 0.
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="mode"/> is not an accepted value.
        /// <code>GL_INVALID_OPERATION</code> is generated if  <see cref="glEndList"/>  is called
        /// without a preceding <see cref="glNewList"/>,
        /// or if <see cref="glNewList"/> is called while a display list is being defined.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glNewList"/> or  <see cref="glEndList"/> 
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// <code>GL_OUT_OF_MEMORY</code> is generated if there is insufficient memory to
        /// compile the display list. If the GL version is 1.1 or greater, no
        /// change is made to the previous contents of the display list, if any,
        /// and no other change is made to the GL state. (It is as if no attempt
        /// had been made to create the new display list.)
        /// </para>
        /// Original: <para>void glEndList();</para>
        /// </summary>
        /// <seealso cref="CallList"/>
        /// <seealso cref="CallLists"/>
        /// <seealso cref="DeleteLists"/>
        /// <seealso cref="GenLists"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void EndList() {
            GLNative.glEndList();
        }

        /// <summary>
        /// execute a display list
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// Display lists can be executed between a call to  <see cref="glBegin"/> 
        /// and the corresponding call to  <see cref="glEnd"/> ,
        /// as long as the display list includes only commands that are allowed
        /// in this interval.
        /// </para>
        /// Original: <para>void glCallList(GLuint list);</para>
        /// </summary>
        /// <param name="list">
        /// Specifies the integer name of the display list to be executed.
        /// </param>
        /// <seealso cref="CallLists"/>
        /// <seealso cref="DeleteLists"/>
        /// <seealso cref="GenLists"/>
        /// <seealso cref="NewList"/>
        /// <seealso cref="PushAttrib"/>
        /// <seealso cref="PushMatrix"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void CallList(uint list) {
            GLNative.glCallList(list);
        }

        /// <summary>
        /// delete a contiguous group of display lists
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="range"/> is negative.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glDeleteLists"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glDeleteLists(GLuint list, GLsizei range);</para>
        /// </summary>
        /// <param name="list">
        /// Specifies the integer name of the first display list to delete.
        /// </param>
        /// <param name="range">
        /// Specifies the number of display lists to delete.
        /// </param>
        /// <seealso cref="CallList"/>
        /// <seealso cref="CallLists"/>
        /// <seealso cref="GenLists"/>
        /// <seealso cref="IsList"/>
        /// <seealso cref="NewList"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void DeleteLists(uint list, int range) {
            GLNative.glDeleteLists(list, range);
        }

        /// <summary>
        /// generate a contiguous set of empty display lists
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="range"/> is negative.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glGenLists"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>GLuint glGenLists(GLsizei range);</para>
        /// </summary>
        /// <param name="range">
        /// <para>
        /// Specifies the number of contiguous empty display lists
        /// to be generated.
        /// </para>
        /// </param>
        /// <seealso cref="CallList"/>
        /// <seealso cref="CallLists"/>
        /// <seealso cref="DeleteLists"/>
        /// <seealso cref="NewList"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static uint GenLists(int range) {
            return GLNative.glGenLists(range);
        }

        /// <summary>
        /// set the display-list base for  <see cref="glCallLists"/>
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glListBase"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glListBase(GLuint base);</para>
        /// </summary>
        /// <param name="b">
        /// <para>
        /// Specifies an integer offset that will be added to  <see cref="glCallLists"/> 
        /// offsets to generate display-list names.
        /// The initial value is 0.
        /// </para>
        /// </param>
        /// <seealso cref="CallLists"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void ListBase(uint b) {
            GLNative.glListBase(b);
        }

        /// <summary>
        /// delimit the vertices of a primitive or a group of like primitives
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="mode"/> is set to an unaccepted value.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glBegin"/> is executed between a
        /// <see cref="glBegin"/>
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// <code>GL_INVALID_OPERATION</code> is generated if  <see cref="glEnd"/>  is executed without being
        /// preceded by a <see cref="glBegin"/>.
        /// <code>GL_INVALID_OPERATION</code> is generated if a command other than
        /// <see cref="glVertex"/> ,
        /// <see cref="glColor"/> ,
        /// <see cref="glSecondaryColor"/> ,
        /// <see cref="glIndex"/> ,
        /// <see cref="glNormal"/> ,
        /// <see cref="glFogCoord"/> ,
        /// <see cref="glTexCoord"/> ,
        /// <see cref="glMultiTexCoord"/> ,
        /// <see cref="glVertexAttrib"/> ,
        /// <see cref="glEvalCoord"/> ,
        /// <see cref="glEvalPoint"/> ,
        /// <see cref="glArrayElement"/> ,
        /// <see cref="glMaterial"/> ,
        /// <see cref="glEdgeFlag"/> ,
        /// <see cref="glCallList"/> , or
        /// <see cref="glCallLists"/>  is executed between
        /// the execution of <see cref="glBegin"/> and the corresponding
        /// execution  <see cref="glEnd"/> .
        /// Execution of
        /// <see cref="glEnableClientState"/> ,
        /// <see cref="glDisableClientState"/> ,
        /// <see cref="glEdgeFlagPointer"/> ,
        /// <see cref="glFogCoordPointer"/> ,
        /// <see cref="glTexCoordPointer"/> ,
        /// <see cref="glColorPointer"/> ,
        /// <see cref="glSecondaryColorPointer"/> ,
        /// <see cref="glIndexPointer"/> ,
        /// <see cref="glNormalPointer"/> ,
        /// <see cref="glVertexPointer"/> ,
        /// <see cref="glVertexAttribPointer"/> ,
        /// <see cref="glInterleavedArrays"/> , or
        /// <see cref="glPixelStore"/>  is not allowed after a call to <see cref="glBegin"/> and before
        /// the corresponding call to  <see cref="glEnd"/> ,
        /// but an error may or may not be generated.
        /// </para>
        /// Original: <para>void glBegin(GLenum mode);</para>
        /// </summary>
        /// <param name="mode">
        /// <para>
        /// Specifies the primitive or primitives that will be created from vertices
        /// presented between <see cref="glBegin"/> and the subsequent  <see cref="glEnd"/> .
        /// Ten symbolic constants are accepted:
        /// <code>GL_POINTS</code>,
        /// <code>GL_LINES</code>,
        /// <code>GL_LINE_STRIP</code>,
        /// <code>GL_LINE_LOOP</code>,
        /// <code>GL_TRIANGLES</code>,
        /// <code>GL_TRIANGLE_STRIP</code>,
        /// <code>GL_TRIANGLE_FAN</code>,
        /// <code>GL_QUADS</code>,
        /// <code>GL_QUAD_STRIP</code>, and
        /// <code>GL_POLYGON</code>.
        /// </para>
        /// </param>
        /// <seealso cref="ArrayElement"/>
        /// <seealso cref="CallList"/>
        /// <seealso cref="CallLists"/>
        /// <seealso cref="Color"/>
        /// <seealso cref="EdgeFlag"/>
        /// <seealso cref="EvalCoord"/>
        /// <seealso cref="EvalPoint"/>
        /// <seealso cref="FogCoord"/>
        /// <seealso cref="Index"/>
        /// <seealso cref="Material"/>
        /// <seealso cref="MultiTexCoord"/>
        /// <seealso cref="Normal"/>
        /// <seealso cref="SecondaryColor"/>
        /// <seealso cref="TexCoord"/>
        /// <seealso cref="Vertex"/>
        /// <seealso cref="VertexAttrib"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void Begin(uint mode) {
            GLNative.glBegin(mode);
        }

        /// <summary>
        /// set the current color
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The initial value for the current color is (1, 1, 1, 1).
        /// The current color can be updated at any time.
        /// In particular,
        /// <see cref="glColor"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glColor3b(GLbyte red, GLbyte green, GLbyte blue);</para>
        /// </summary>
        /// <param name="red">
        /// Specify new red, green, and blue values for the current color.
        /// </param>
        /// <param name="green">
        /// Specify new red, green, and blue values for the current color.
        /// </param>
        /// <param name="blue">
        /// Specify new red, green, and blue values for the current color.
        /// </param>
        /// <seealso cref="ColorPointer"/>
        /// <seealso cref="Index"/>
        /// <seealso cref="SecondaryColor"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void Color3b(byte red, byte green, byte blue) {
            GLNative.glColor3b(red, green, blue);
        }

        /// <summary>
        /// set the current color
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The initial value for the current color is (1, 1, 1, 1).
        /// The current color can be updated at any time.
        /// In particular,
        /// <see cref="glColor"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glColor3d(GLdouble red, GLdouble green, GLdouble blue);</para>
        /// </summary>
        /// <param name="red">
        /// Specify new red, green, and blue values for the current color.
        /// </param>
        /// <param name="green">
        /// Specify new red, green, and blue values for the current color.
        /// </param>
        /// <param name="blue">
        /// Specify new red, green, and blue values for the current color.
        /// </param>
        /// <seealso cref="ColorPointer"/>
        /// <seealso cref="Index"/>
        /// <seealso cref="SecondaryColor"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void Color3d(double red, double green, double blue) {
            GLNative.glColor3d(red, green, blue);
        }

        /// <summary>
        /// set the current color
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The initial value for the current color is (1, 1, 1, 1).
        /// The current color can be updated at any time.
        /// In particular,
        /// <see cref="glColor"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glColor3f(GLfloat red, GLfloat green, GLfloat blue);</para>
        /// </summary>
        /// <param name="red">
        /// Specify new red, green, and blue values for the current color.
        /// </param>
        /// <param name="green">
        /// Specify new red, green, and blue values for the current color.
        /// </param>
        /// <param name="blue">
        /// Specify new red, green, and blue values for the current color.
        /// </param>
        /// <seealso cref="ColorPointer"/>
        /// <seealso cref="Index"/>
        /// <seealso cref="SecondaryColor"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void Color3f(float red, float green, float blue) {
            GLNative.glColor3f(red, green, blue);
        }

        /// <summary>
        /// set the current color
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The initial value for the current color is (1, 1, 1, 1).
        /// The current color can be updated at any time.
        /// In particular,
        /// <see cref="glColor"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glColor3i(GLint red, GLint green, GLint blue);</para>
        /// </summary>
        /// <param name="red">
        /// Specify new red, green, and blue values for the current color.
        /// </param>
        /// <param name="green">
        /// Specify new red, green, and blue values for the current color.
        /// </param>
        /// <param name="blue">
        /// Specify new red, green, and blue values for the current color.
        /// </param>
        /// <seealso cref="ColorPointer"/>
        /// <seealso cref="Index"/>
        /// <seealso cref="SecondaryColor"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void Color3i(int red, int green, int blue) {
            GLNative.glColor3i(red, green, blue);
        }

        /// <summary>
        /// set the current color
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The initial value for the current color is (1, 1, 1, 1).
        /// The current color can be updated at any time.
        /// In particular,
        /// <see cref="glColor"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glColor3s(GLshort red, GLshort green, GLshort blue);</para>
        /// </summary>
        /// <param name="red">
        /// Specify new red, green, and blue values for the current color.
        /// </param>
        /// <param name="green">
        /// Specify new red, green, and blue values for the current color.
        /// </param>
        /// <param name="blue">
        /// Specify new red, green, and blue values for the current color.
        /// </param>
        /// <seealso cref="ColorPointer"/>
        /// <seealso cref="Index"/>
        /// <seealso cref="SecondaryColor"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void Color3s(short red, short green, short blue) {
            GLNative.glColor3s(red, green, blue);
        }

        /// <summary>
        /// set the current color
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The initial value for the current color is (1, 1, 1, 1).
        /// The current color can be updated at any time.
        /// In particular,
        /// <see cref="glColor"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glColor3ub(GLubyte red, GLubyte green, GLubyte blue);</para>
        /// </summary>
        /// <param name="red">
        /// Specify new red, green, and blue values for the current color.
        /// </param>
        /// <param name="green">
        /// Specify new red, green, and blue values for the current color.
        /// </param>
        /// <param name="blue">
        /// Specify new red, green, and blue values for the current color.
        /// </param>
        /// <seealso cref="ColorPointer"/>
        /// <seealso cref="Index"/>
        /// <seealso cref="SecondaryColor"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void Color3ub(byte red, byte green, byte blue) {
            GLNative.glColor3ub(red, green, blue);
        }

        /// <summary>
        /// set the current color
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The initial value for the current color is (1, 1, 1, 1).
        /// The current color can be updated at any time.
        /// In particular,
        /// <see cref="glColor"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glColor3ui(GLuint red, GLuint green, GLuint blue);</para>
        /// </summary>
        /// <param name="red">
        /// Specify new red, green, and blue values for the current color.
        /// </param>
        /// <param name="green">
        /// Specify new red, green, and blue values for the current color.
        /// </param>
        /// <param name="blue">
        /// Specify new red, green, and blue values for the current color.
        /// </param>
        /// <seealso cref="ColorPointer"/>
        /// <seealso cref="Index"/>
        /// <seealso cref="SecondaryColor"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void Color3ui(uint red, uint green, uint blue) {
            GLNative.glColor3ui(red, green, blue);
        }

        /// <summary>
        /// set the current color
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The initial value for the current color is (1, 1, 1, 1).
        /// The current color can be updated at any time.
        /// In particular,
        /// <see cref="glColor"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glColor3us(GLushort red, GLushort green, GLushort blue);</para>
        /// </summary>
        /// <param name="red">
        /// Specify new red, green, and blue values for the current color.
        /// </param>
        /// <param name="green">
        /// Specify new red, green, and blue values for the current color.
        /// </param>
        /// <param name="blue">
        /// Specify new red, green, and blue values for the current color.
        /// </param>
        /// <seealso cref="ColorPointer"/>
        /// <seealso cref="Index"/>
        /// <seealso cref="SecondaryColor"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void Color3us(ushort red, ushort green, ushort blue) {
            GLNative.glColor3us(red, green, blue);
        }

        /// <summary>
        /// set the current color
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The initial value for the current color is (1, 1, 1, 1).
        /// The current color can be updated at any time.
        /// In particular,
        /// <see cref="glColor"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glColor4b(GLbyte red, GLbyte green, GLbyte blue, GLbyte alpha);</para>
        /// </summary>
        /// <param name="red">
        /// Specify new red, green, and blue values for the current color.
        /// </param>
        /// <param name="green">
        /// Specify new red, green, and blue values for the current color.
        /// </param>
        /// <param name="blue">
        /// Specify new red, green, and blue values for the current color.
        /// </param>
        /// <param name="alpha">
        /// <para>
        /// Specifies a new alpha value for the current color.
        /// Included only in the four-argument <see cref="glColor4"/> commands.
        /// </para>
        /// </param>
        /// <seealso cref="ColorPointer"/>
        /// <seealso cref="Index"/>
        /// <seealso cref="SecondaryColor"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void Color4b(byte red, byte green, byte blue, byte alpha) {
            GLNative.glColor4b(red, green, blue, alpha);
        }

        /// <summary>
        /// set the current color
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The initial value for the current color is (1, 1, 1, 1).
        /// The current color can be updated at any time.
        /// In particular,
        /// <see cref="glColor"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glColor4d(GLdouble red, GLdouble green, GLdouble blue, GLdouble alpha);</para>
        /// </summary>
        /// <param name="red">
        /// Specify new red, green, and blue values for the current color.
        /// </param>
        /// <param name="green">
        /// Specify new red, green, and blue values for the current color.
        /// </param>
        /// <param name="blue">
        /// Specify new red, green, and blue values for the current color.
        /// </param>
        /// <param name="alpha">
        /// <para>
        /// Specifies a new alpha value for the current color.
        /// Included only in the four-argument <see cref="glColor4"/> commands.
        /// </para>
        /// </param>
        /// <seealso cref="ColorPointer"/>
        /// <seealso cref="Index"/>
        /// <seealso cref="SecondaryColor"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void Color4d(double red, double green, double blue, double alpha) {
            GLNative.glColor4d(red, green, blue, alpha);
        }

        /// <summary>
        /// set the current color
        /// <para>Require:</para> <para>GL_VERSION_1_0, GL_VERSION_ES_CM_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The initial value for the current color is (1, 1, 1, 1).
        /// The current color can be updated at any time.
        /// In particular,
        /// <see cref="glColor"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glColor4f(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha);</para>
        /// </summary>
        /// <param name="red">
        /// Specify new red, green, and blue values for the current color.
        /// </param>
        /// <param name="green">
        /// Specify new red, green, and blue values for the current color.
        /// </param>
        /// <param name="blue">
        /// Specify new red, green, and blue values for the current color.
        /// </param>
        /// <param name="alpha">
        /// <para>
        /// Specifies a new alpha value for the current color.
        /// Included only in the four-argument <see cref="glColor4"/> commands.
        /// </para>
        /// </param>
        /// <seealso cref="ColorPointer"/>
        /// <seealso cref="Index"/>
        /// <seealso cref="SecondaryColor"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void Color4f(float red, float green, float blue, float alpha) {
            GLNative.glColor4f(red, green, blue, alpha);
        }

        /// <summary>
        /// set the current color
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The initial value for the current color is (1, 1, 1, 1).
        /// The current color can be updated at any time.
        /// In particular,
        /// <see cref="glColor"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glColor4i(GLint red, GLint green, GLint blue, GLint alpha);</para>
        /// </summary>
        /// <param name="red">
        /// Specify new red, green, and blue values for the current color.
        /// </param>
        /// <param name="green">
        /// Specify new red, green, and blue values for the current color.
        /// </param>
        /// <param name="blue">
        /// Specify new red, green, and blue values for the current color.
        /// </param>
        /// <param name="alpha">
        /// <para>
        /// Specifies a new alpha value for the current color.
        /// Included only in the four-argument <see cref="glColor4"/> commands.
        /// </para>
        /// </param>
        /// <seealso cref="ColorPointer"/>
        /// <seealso cref="Index"/>
        /// <seealso cref="SecondaryColor"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void Color4i(int red, int green, int blue, int alpha) {
            GLNative.glColor4i(red, green, blue, alpha);
        }

        /// <summary>
        /// set the current color
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The initial value for the current color is (1, 1, 1, 1).
        /// The current color can be updated at any time.
        /// In particular,
        /// <see cref="glColor"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glColor4s(GLshort red, GLshort green, GLshort blue, GLshort alpha);</para>
        /// </summary>
        /// <param name="red">
        /// Specify new red, green, and blue values for the current color.
        /// </param>
        /// <param name="green">
        /// Specify new red, green, and blue values for the current color.
        /// </param>
        /// <param name="blue">
        /// Specify new red, green, and blue values for the current color.
        /// </param>
        /// <param name="alpha">
        /// <para>
        /// Specifies a new alpha value for the current color.
        /// Included only in the four-argument <see cref="glColor4"/> commands.
        /// </para>
        /// </param>
        /// <seealso cref="ColorPointer"/>
        /// <seealso cref="Index"/>
        /// <seealso cref="SecondaryColor"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void Color4s(short red, short green, short blue, short alpha) {
            GLNative.glColor4s(red, green, blue, alpha);
        }

        /// <summary>
        /// set the current color
        /// <para>Require:</para> <para>GL_VERSION_1_0, GL_VERSION_ES_CM_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The initial value for the current color is (1, 1, 1, 1).
        /// The current color can be updated at any time.
        /// In particular,
        /// <see cref="glColor"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glColor4ub(GLubyte red, GLubyte green, GLubyte blue, GLubyte alpha);</para>
        /// </summary>
        /// <param name="red">
        /// Specify new red, green, and blue values for the current color.
        /// </param>
        /// <param name="green">
        /// Specify new red, green, and blue values for the current color.
        /// </param>
        /// <param name="blue">
        /// Specify new red, green, and blue values for the current color.
        /// </param>
        /// <param name="alpha">
        /// <para>
        /// Specifies a new alpha value for the current color.
        /// Included only in the four-argument <see cref="glColor4"/> commands.
        /// </para>
        /// </param>
        /// <seealso cref="ColorPointer"/>
        /// <seealso cref="Index"/>
        /// <seealso cref="SecondaryColor"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void Color4ub(byte red, byte green, byte blue, byte alpha) {
            GLNative.glColor4ub(red, green, blue, alpha);
        }

        /// <summary>
        /// set the current color
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The initial value for the current color is (1, 1, 1, 1).
        /// The current color can be updated at any time.
        /// In particular,
        /// <see cref="glColor"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glColor4ui(GLuint red, GLuint green, GLuint blue, GLuint alpha);</para>
        /// </summary>
        /// <param name="red">
        /// Specify new red, green, and blue values for the current color.
        /// </param>
        /// <param name="green">
        /// Specify new red, green, and blue values for the current color.
        /// </param>
        /// <param name="blue">
        /// Specify new red, green, and blue values for the current color.
        /// </param>
        /// <param name="alpha">
        /// <para>
        /// Specifies a new alpha value for the current color.
        /// Included only in the four-argument <see cref="glColor4"/> commands.
        /// </para>
        /// </param>
        /// <seealso cref="ColorPointer"/>
        /// <seealso cref="Index"/>
        /// <seealso cref="SecondaryColor"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void Color4ui(uint red, uint green, uint blue, uint alpha) {
            GLNative.glColor4ui(red, green, blue, alpha);
        }

        /// <summary>
        /// set the current color
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The initial value for the current color is (1, 1, 1, 1).
        /// The current color can be updated at any time.
        /// In particular,
        /// <see cref="glColor"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glColor4us(GLushort red, GLushort green, GLushort blue, GLushort alpha);</para>
        /// </summary>
        /// <param name="red">
        /// Specify new red, green, and blue values for the current color.
        /// </param>
        /// <param name="green">
        /// Specify new red, green, and blue values for the current color.
        /// </param>
        /// <param name="blue">
        /// Specify new red, green, and blue values for the current color.
        /// </param>
        /// <param name="alpha">
        /// <para>
        /// Specifies a new alpha value for the current color.
        /// Included only in the four-argument <see cref="glColor4"/> commands.
        /// </para>
        /// </param>
        /// <seealso cref="ColorPointer"/>
        /// <seealso cref="Index"/>
        /// <seealso cref="SecondaryColor"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void Color4us(ushort red, ushort green, ushort blue, ushort alpha) {
            GLNative.glColor4us(red, green, blue, alpha);
        }

        /// <summary>
        /// flag edges as either boundary or nonboundary
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The current edge flag can be updated at any time.
        /// In particular,
        /// <see cref="glEdgeFlag"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glEdgeFlag(GLboolean flag);</para>
        /// </summary>
        /// <param name="flag">
        /// <para>
        /// Specifies the current edge flag value,
        /// either <code>GL_TRUE</code> or <code>GL_FALSE</code>. The initial value is <code>GL_TRUE</code>.
        /// </para>
        /// </param>
        /// <seealso cref="Begin"/>
        /// <seealso cref="EdgeFlagPointer"/>
        /// <seealso cref="PolygonMode"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void EdgeFlag(bool flag) {
            GLNative.glEdgeFlag(flag);
        }

        /// <summary>
        /// delimit the vertices of a primitive or a group of like primitives
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="mode"/> is set to an unaccepted value.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glBegin"/> is executed between a
        /// <see cref="glBegin"/>
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// <code>GL_INVALID_OPERATION</code> is generated if  <see cref="glEnd"/>  is executed without being
        /// preceded by a <see cref="glBegin"/>.
        /// <code>GL_INVALID_OPERATION</code> is generated if a command other than
        /// <see cref="glVertex"/> ,
        /// <see cref="glColor"/> ,
        /// <see cref="glSecondaryColor"/> ,
        /// <see cref="glIndex"/> ,
        /// <see cref="glNormal"/> ,
        /// <see cref="glFogCoord"/> ,
        /// <see cref="glTexCoord"/> ,
        /// <see cref="glMultiTexCoord"/> ,
        /// <see cref="glVertexAttrib"/> ,
        /// <see cref="glEvalCoord"/> ,
        /// <see cref="glEvalPoint"/> ,
        /// <see cref="glArrayElement"/> ,
        /// <see cref="glMaterial"/> ,
        /// <see cref="glEdgeFlag"/> ,
        /// <see cref="glCallList"/> , or
        /// <see cref="glCallLists"/>  is executed between
        /// the execution of <see cref="glBegin"/> and the corresponding
        /// execution  <see cref="glEnd"/> .
        /// Execution of
        /// <see cref="glEnableClientState"/> ,
        /// <see cref="glDisableClientState"/> ,
        /// <see cref="glEdgeFlagPointer"/> ,
        /// <see cref="glFogCoordPointer"/> ,
        /// <see cref="glTexCoordPointer"/> ,
        /// <see cref="glColorPointer"/> ,
        /// <see cref="glSecondaryColorPointer"/> ,
        /// <see cref="glIndexPointer"/> ,
        /// <see cref="glNormalPointer"/> ,
        /// <see cref="glVertexPointer"/> ,
        /// <see cref="glVertexAttribPointer"/> ,
        /// <see cref="glInterleavedArrays"/> , or
        /// <see cref="glPixelStore"/>  is not allowed after a call to <see cref="glBegin"/> and before
        /// the corresponding call to  <see cref="glEnd"/> ,
        /// but an error may or may not be generated.
        /// </para>
        /// Original: <para>void glEnd();</para>
        /// </summary>
        /// <seealso cref="ArrayElement"/>
        /// <seealso cref="CallList"/>
        /// <seealso cref="CallLists"/>
        /// <seealso cref="Color"/>
        /// <seealso cref="EdgeFlag"/>
        /// <seealso cref="EvalCoord"/>
        /// <seealso cref="EvalPoint"/>
        /// <seealso cref="FogCoord"/>
        /// <seealso cref="Index"/>
        /// <seealso cref="Material"/>
        /// <seealso cref="MultiTexCoord"/>
        /// <seealso cref="Normal"/>
        /// <seealso cref="SecondaryColor"/>
        /// <seealso cref="TexCoord"/>
        /// <seealso cref="Vertex"/>
        /// <seealso cref="VertexAttrib"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void End() {
            GLNative.glEnd();
        }

        /// <summary>
        /// set the current color index
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glIndexub"/> and <see cref="glIndexubv"/> are available only if the GL version is
        /// 1.1 or greater.
        /// The current index can be updated at any time.
        /// In particular,
        /// <see cref="glIndex"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glIndexd(GLdouble c);</para>
        /// </summary>
        /// <param name="c">
        /// Specifies the new value for the current color index.
        /// </param>
        /// <seealso cref="Color"/>
        /// <seealso cref="IndexPointer"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void Indexd(double c) {
            GLNative.glIndexd(c);
        }

        /// <summary>
        /// set the current color index
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glIndexub"/> and <see cref="glIndexubv"/> are available only if the GL version is
        /// 1.1 or greater.
        /// The current index can be updated at any time.
        /// In particular,
        /// <see cref="glIndex"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glIndexf(GLfloat c);</para>
        /// </summary>
        /// <param name="c">
        /// Specifies the new value for the current color index.
        /// </param>
        /// <seealso cref="Color"/>
        /// <seealso cref="IndexPointer"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void Indexf(float c) {
            GLNative.glIndexf(c);
        }

        /// <summary>
        /// set the current color index
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glIndexub"/> and <see cref="glIndexubv"/> are available only if the GL version is
        /// 1.1 or greater.
        /// The current index can be updated at any time.
        /// In particular,
        /// <see cref="glIndex"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glIndexi(GLint c);</para>
        /// </summary>
        /// <param name="c">
        /// Specifies the new value for the current color index.
        /// </param>
        /// <seealso cref="Color"/>
        /// <seealso cref="IndexPointer"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void Indexi(int c) {
            GLNative.glIndexi(c);
        }

        /// <summary>
        /// set the current color index
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glIndexub"/> and <see cref="glIndexubv"/> are available only if the GL version is
        /// 1.1 or greater.
        /// The current index can be updated at any time.
        /// In particular,
        /// <see cref="glIndex"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glIndexs(GLshort c);</para>
        /// </summary>
        /// <param name="c">
        /// Specifies the new value for the current color index.
        /// </param>
        /// <seealso cref="Color"/>
        /// <seealso cref="IndexPointer"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void Indexs(short c) {
            GLNative.glIndexs(c);
        }

        /// <summary>
        /// set the current normal vector
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The current normal can be updated at any time.
        /// In particular, <see cref="glNormal"/> can be called between a call to  <see cref="glBegin"/>  and
        /// the corresponding call to  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glNormal3b(GLbyte nx, GLbyte ny, GLbyte nz);</para>
        /// </summary>
        /// <param name="nx">
        /// <para>
        /// Specify the 
        /// x   ,
        /// y   ,
        /// and 
        /// z   
        /// coordinates of the new current normal.
        /// The initial value of the current normal is the unit vector, (0, 0, 1).
        /// </para>
        /// </param>
        /// <param name="ny">
        /// <para>
        /// Specify the 
        /// x   ,
        /// y   ,
        /// and 
        /// z   
        /// coordinates of the new current normal.
        /// The initial value of the current normal is the unit vector, (0, 0, 1).
        /// </para>
        /// </param>
        /// <param name="nz">
        /// <para>
        /// Specify the 
        /// x   ,
        /// y   ,
        /// and 
        /// z   
        /// coordinates of the new current normal.
        /// The initial value of the current normal is the unit vector, (0, 0, 1).
        /// </para>
        /// </param>
        /// <seealso cref="Begin"/>
        /// <seealso cref="Color"/>
        /// <seealso cref="Index"/>
        /// <seealso cref="MultiTexCoord"/>
        /// <seealso cref="NormalPointer"/>
        /// <seealso cref="TexCoord"/>
        /// <seealso cref="Vertex"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void Normal3b(byte nx, byte ny, byte nz) {
            GLNative.glNormal3b(nx, ny, nz);
        }

        /// <summary>
        /// set the current normal vector
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The current normal can be updated at any time.
        /// In particular, <see cref="glNormal"/> can be called between a call to  <see cref="glBegin"/>  and
        /// the corresponding call to  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glNormal3d(GLdouble nx, GLdouble ny, GLdouble nz);</para>
        /// </summary>
        /// <param name="nx">
        /// <para>
        /// Specify the 
        /// x   ,
        /// y   ,
        /// and 
        /// z   
        /// coordinates of the new current normal.
        /// The initial value of the current normal is the unit vector, (0, 0, 1).
        /// </para>
        /// </param>
        /// <param name="ny">
        /// <para>
        /// Specify the 
        /// x   ,
        /// y   ,
        /// and 
        /// z   
        /// coordinates of the new current normal.
        /// The initial value of the current normal is the unit vector, (0, 0, 1).
        /// </para>
        /// </param>
        /// <param name="nz">
        /// <para>
        /// Specify the 
        /// x   ,
        /// y   ,
        /// and 
        /// z   
        /// coordinates of the new current normal.
        /// The initial value of the current normal is the unit vector, (0, 0, 1).
        /// </para>
        /// </param>
        /// <seealso cref="Begin"/>
        /// <seealso cref="Color"/>
        /// <seealso cref="Index"/>
        /// <seealso cref="MultiTexCoord"/>
        /// <seealso cref="NormalPointer"/>
        /// <seealso cref="TexCoord"/>
        /// <seealso cref="Vertex"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void Normal3d(double nx, double ny, double nz) {
            GLNative.glNormal3d(nx, ny, nz);
        }

        /// <summary>
        /// set the current normal vector
        /// <para>Require:</para> <para>GL_VERSION_1_0, GL_VERSION_ES_CM_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The current normal can be updated at any time.
        /// In particular, <see cref="glNormal"/> can be called between a call to  <see cref="glBegin"/>  and
        /// the corresponding call to  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glNormal3f(GLfloat nx, GLfloat ny, GLfloat nz);</para>
        /// </summary>
        /// <param name="nx">
        /// <para>
        /// Specify the 
        /// x   ,
        /// y   ,
        /// and 
        /// z   
        /// coordinates of the new current normal.
        /// The initial value of the current normal is the unit vector, (0, 0, 1).
        /// </para>
        /// </param>
        /// <param name="ny">
        /// <para>
        /// Specify the 
        /// x   ,
        /// y   ,
        /// and 
        /// z   
        /// coordinates of the new current normal.
        /// The initial value of the current normal is the unit vector, (0, 0, 1).
        /// </para>
        /// </param>
        /// <param name="nz">
        /// <para>
        /// Specify the 
        /// x   ,
        /// y   ,
        /// and 
        /// z   
        /// coordinates of the new current normal.
        /// The initial value of the current normal is the unit vector, (0, 0, 1).
        /// </para>
        /// </param>
        /// <seealso cref="Begin"/>
        /// <seealso cref="Color"/>
        /// <seealso cref="Index"/>
        /// <seealso cref="MultiTexCoord"/>
        /// <seealso cref="NormalPointer"/>
        /// <seealso cref="TexCoord"/>
        /// <seealso cref="Vertex"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void Normal3f(float nx, float ny, float nz) {
            GLNative.glNormal3f(nx, ny, nz);
        }

        /// <summary>
        /// set the current normal vector
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The current normal can be updated at any time.
        /// In particular, <see cref="glNormal"/> can be called between a call to  <see cref="glBegin"/>  and
        /// the corresponding call to  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glNormal3i(GLint nx, GLint ny, GLint nz);</para>
        /// </summary>
        /// <param name="nx">
        /// <para>
        /// Specify the 
        /// x   ,
        /// y   ,
        /// and 
        /// z   
        /// coordinates of the new current normal.
        /// The initial value of the current normal is the unit vector, (0, 0, 1).
        /// </para>
        /// </param>
        /// <param name="ny">
        /// <para>
        /// Specify the 
        /// x   ,
        /// y   ,
        /// and 
        /// z   
        /// coordinates of the new current normal.
        /// The initial value of the current normal is the unit vector, (0, 0, 1).
        /// </para>
        /// </param>
        /// <param name="nz">
        /// <para>
        /// Specify the 
        /// x   ,
        /// y   ,
        /// and 
        /// z   
        /// coordinates of the new current normal.
        /// The initial value of the current normal is the unit vector, (0, 0, 1).
        /// </para>
        /// </param>
        /// <seealso cref="Begin"/>
        /// <seealso cref="Color"/>
        /// <seealso cref="Index"/>
        /// <seealso cref="MultiTexCoord"/>
        /// <seealso cref="NormalPointer"/>
        /// <seealso cref="TexCoord"/>
        /// <seealso cref="Vertex"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void Normal3i(int nx, int ny, int nz) {
            GLNative.glNormal3i(nx, ny, nz);
        }

        /// <summary>
        /// set the current normal vector
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The current normal can be updated at any time.
        /// In particular, <see cref="glNormal"/> can be called between a call to  <see cref="glBegin"/>  and
        /// the corresponding call to  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glNormal3s(GLshort nx, GLshort ny, GLshort nz);</para>
        /// </summary>
        /// <param name="nx">
        /// <para>
        /// Specify the 
        /// x   ,
        /// y   ,
        /// and 
        /// z   
        /// coordinates of the new current normal.
        /// The initial value of the current normal is the unit vector, (0, 0, 1).
        /// </para>
        /// </param>
        /// <param name="ny">
        /// <para>
        /// Specify the 
        /// x   ,
        /// y   ,
        /// and 
        /// z   
        /// coordinates of the new current normal.
        /// The initial value of the current normal is the unit vector, (0, 0, 1).
        /// </para>
        /// </param>
        /// <param name="nz">
        /// <para>
        /// Specify the 
        /// x   ,
        /// y   ,
        /// and 
        /// z   
        /// coordinates of the new current normal.
        /// The initial value of the current normal is the unit vector, (0, 0, 1).
        /// </para>
        /// </param>
        /// <seealso cref="Begin"/>
        /// <seealso cref="Color"/>
        /// <seealso cref="Index"/>
        /// <seealso cref="MultiTexCoord"/>
        /// <seealso cref="NormalPointer"/>
        /// <seealso cref="TexCoord"/>
        /// <seealso cref="Vertex"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void Normal3s(short nx, short ny, short nz) {
            GLNative.glNormal3s(nx, ny, nz);
        }

        /// <summary>
        /// specify the raster position for pixel operations
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The raster position is modified by <see cref="glRasterPos"/>,  <see cref="glBitmap"/> , and  <see cref="glWindowPos"/> .
        /// When the raster position coordinates are invalid,
        /// drawing commands that are based on the raster position are
        /// ignored (that is, they do not result in changes to GL state).
        /// Calling  <see cref="glDrawElements"/>  or  <see cref="glDrawRangeElements"/>  may leave the
        /// current color or index indeterminate.
        /// If <see cref="glRasterPos"/> is executed while the current color or index is indeterminate, the
        /// current raster color or current raster index remains indeterminate.
        /// To set a valid raster position outside the viewport, first set a valid
        /// raster position, then call  <see cref="glBitmap"/>  with NULL as the  bitmap 
        /// parameter.
        /// When the <code>ARB_imaging</code> extension is supported, there are distinct
        /// raster texture coordinates for each texture unit. Each texture unit's
        /// current raster texture coordinates are updated by <see cref="glRasterPos"/>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glRasterPos"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glRasterPos2d(GLdouble x, GLdouble y);</para>
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify the 
        /// x   ,
        /// y   ,
        /// z   ,
        /// and 
        /// w   
        /// object coordinates
        /// (if present)
        /// for the raster
        /// position.
        /// </para>
        /// </param>
        /// <param name="y">
        /// <para>
        /// Specify the 
        /// x   ,
        /// y   ,
        /// z   ,
        /// and 
        /// w   
        /// object coordinates
        /// (if present)
        /// for the raster
        /// position.
        /// </para>
        /// </param>
        /// <seealso cref="Bitmap"/>
        /// <seealso cref="CopyPixels"/>
        /// <seealso cref="DrawArrays"/>
        /// <seealso cref="DrawElements"/>
        /// <seealso cref="DrawRangeElements"/>
        /// <seealso cref="DrawPixels"/>
        /// <seealso cref="MultiTexCoord"/>
        /// <seealso cref="TexCoord"/>
        /// <seealso cref="TexGen"/>
        /// <seealso cref="Vertex"/>
        /// <seealso cref="WindowPos"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void RasterPos2d(double x, double y) {
            GLNative.glRasterPos2d(x, y);
        }

        /// <summary>
        /// specify the raster position for pixel operations
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The raster position is modified by <see cref="glRasterPos"/>,  <see cref="glBitmap"/> , and  <see cref="glWindowPos"/> .
        /// When the raster position coordinates are invalid,
        /// drawing commands that are based on the raster position are
        /// ignored (that is, they do not result in changes to GL state).
        /// Calling  <see cref="glDrawElements"/>  or  <see cref="glDrawRangeElements"/>  may leave the
        /// current color or index indeterminate.
        /// If <see cref="glRasterPos"/> is executed while the current color or index is indeterminate, the
        /// current raster color or current raster index remains indeterminate.
        /// To set a valid raster position outside the viewport, first set a valid
        /// raster position, then call  <see cref="glBitmap"/>  with NULL as the  bitmap 
        /// parameter.
        /// When the <code>ARB_imaging</code> extension is supported, there are distinct
        /// raster texture coordinates for each texture unit. Each texture unit's
        /// current raster texture coordinates are updated by <see cref="glRasterPos"/>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glRasterPos"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glRasterPos2f(GLfloat x, GLfloat y);</para>
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify the 
        /// x   ,
        /// y   ,
        /// z   ,
        /// and 
        /// w   
        /// object coordinates
        /// (if present)
        /// for the raster
        /// position.
        /// </para>
        /// </param>
        /// <param name="y">
        /// <para>
        /// Specify the 
        /// x   ,
        /// y   ,
        /// z   ,
        /// and 
        /// w   
        /// object coordinates
        /// (if present)
        /// for the raster
        /// position.
        /// </para>
        /// </param>
        /// <seealso cref="Bitmap"/>
        /// <seealso cref="CopyPixels"/>
        /// <seealso cref="DrawArrays"/>
        /// <seealso cref="DrawElements"/>
        /// <seealso cref="DrawRangeElements"/>
        /// <seealso cref="DrawPixels"/>
        /// <seealso cref="MultiTexCoord"/>
        /// <seealso cref="TexCoord"/>
        /// <seealso cref="TexGen"/>
        /// <seealso cref="Vertex"/>
        /// <seealso cref="WindowPos"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void RasterPos2f(float x, float y) {
            GLNative.glRasterPos2f(x, y);
        }

        /// <summary>
        /// specify the raster position for pixel operations
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The raster position is modified by <see cref="glRasterPos"/>,  <see cref="glBitmap"/> , and  <see cref="glWindowPos"/> .
        /// When the raster position coordinates are invalid,
        /// drawing commands that are based on the raster position are
        /// ignored (that is, they do not result in changes to GL state).
        /// Calling  <see cref="glDrawElements"/>  or  <see cref="glDrawRangeElements"/>  may leave the
        /// current color or index indeterminate.
        /// If <see cref="glRasterPos"/> is executed while the current color or index is indeterminate, the
        /// current raster color or current raster index remains indeterminate.
        /// To set a valid raster position outside the viewport, first set a valid
        /// raster position, then call  <see cref="glBitmap"/>  with NULL as the  bitmap 
        /// parameter.
        /// When the <code>ARB_imaging</code> extension is supported, there are distinct
        /// raster texture coordinates for each texture unit. Each texture unit's
        /// current raster texture coordinates are updated by <see cref="glRasterPos"/>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glRasterPos"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glRasterPos2i(GLint x, GLint y);</para>
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify the 
        /// x   ,
        /// y   ,
        /// z   ,
        /// and 
        /// w   
        /// object coordinates
        /// (if present)
        /// for the raster
        /// position.
        /// </para>
        /// </param>
        /// <param name="y">
        /// <para>
        /// Specify the 
        /// x   ,
        /// y   ,
        /// z   ,
        /// and 
        /// w   
        /// object coordinates
        /// (if present)
        /// for the raster
        /// position.
        /// </para>
        /// </param>
        /// <seealso cref="Bitmap"/>
        /// <seealso cref="CopyPixels"/>
        /// <seealso cref="DrawArrays"/>
        /// <seealso cref="DrawElements"/>
        /// <seealso cref="DrawRangeElements"/>
        /// <seealso cref="DrawPixels"/>
        /// <seealso cref="MultiTexCoord"/>
        /// <seealso cref="TexCoord"/>
        /// <seealso cref="TexGen"/>
        /// <seealso cref="Vertex"/>
        /// <seealso cref="WindowPos"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void RasterPos2i(int x, int y) {
            GLNative.glRasterPos2i(x, y);
        }

        /// <summary>
        /// specify the raster position for pixel operations
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The raster position is modified by <see cref="glRasterPos"/>,  <see cref="glBitmap"/> , and  <see cref="glWindowPos"/> .
        /// When the raster position coordinates are invalid,
        /// drawing commands that are based on the raster position are
        /// ignored (that is, they do not result in changes to GL state).
        /// Calling  <see cref="glDrawElements"/>  or  <see cref="glDrawRangeElements"/>  may leave the
        /// current color or index indeterminate.
        /// If <see cref="glRasterPos"/> is executed while the current color or index is indeterminate, the
        /// current raster color or current raster index remains indeterminate.
        /// To set a valid raster position outside the viewport, first set a valid
        /// raster position, then call  <see cref="glBitmap"/>  with NULL as the  bitmap 
        /// parameter.
        /// When the <code>ARB_imaging</code> extension is supported, there are distinct
        /// raster texture coordinates for each texture unit. Each texture unit's
        /// current raster texture coordinates are updated by <see cref="glRasterPos"/>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glRasterPos"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glRasterPos2s(GLshort x, GLshort y);</para>
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify the 
        /// x   ,
        /// y   ,
        /// z   ,
        /// and 
        /// w   
        /// object coordinates
        /// (if present)
        /// for the raster
        /// position.
        /// </para>
        /// </param>
        /// <param name="y">
        /// <para>
        /// Specify the 
        /// x   ,
        /// y   ,
        /// z   ,
        /// and 
        /// w   
        /// object coordinates
        /// (if present)
        /// for the raster
        /// position.
        /// </para>
        /// </param>
        /// <seealso cref="Bitmap"/>
        /// <seealso cref="CopyPixels"/>
        /// <seealso cref="DrawArrays"/>
        /// <seealso cref="DrawElements"/>
        /// <seealso cref="DrawRangeElements"/>
        /// <seealso cref="DrawPixels"/>
        /// <seealso cref="MultiTexCoord"/>
        /// <seealso cref="TexCoord"/>
        /// <seealso cref="TexGen"/>
        /// <seealso cref="Vertex"/>
        /// <seealso cref="WindowPos"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void RasterPos2s(short x, short y) {
            GLNative.glRasterPos2s(x, y);
        }

        /// <summary>
        /// specify the raster position for pixel operations
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The raster position is modified by <see cref="glRasterPos"/>,  <see cref="glBitmap"/> , and  <see cref="glWindowPos"/> .
        /// When the raster position coordinates are invalid,
        /// drawing commands that are based on the raster position are
        /// ignored (that is, they do not result in changes to GL state).
        /// Calling  <see cref="glDrawElements"/>  or  <see cref="glDrawRangeElements"/>  may leave the
        /// current color or index indeterminate.
        /// If <see cref="glRasterPos"/> is executed while the current color or index is indeterminate, the
        /// current raster color or current raster index remains indeterminate.
        /// To set a valid raster position outside the viewport, first set a valid
        /// raster position, then call  <see cref="glBitmap"/>  with NULL as the  bitmap 
        /// parameter.
        /// When the <code>ARB_imaging</code> extension is supported, there are distinct
        /// raster texture coordinates for each texture unit. Each texture unit's
        /// current raster texture coordinates are updated by <see cref="glRasterPos"/>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glRasterPos"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glRasterPos3d(GLdouble x, GLdouble y, GLdouble z);</para>
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify the 
        /// x   ,
        /// y   ,
        /// z   ,
        /// and 
        /// w   
        /// object coordinates
        /// (if present)
        /// for the raster
        /// position.
        /// </para>
        /// </param>
        /// <param name="y">
        /// <para>
        /// Specify the 
        /// x   ,
        /// y   ,
        /// z   ,
        /// and 
        /// w   
        /// object coordinates
        /// (if present)
        /// for the raster
        /// position.
        /// </para>
        /// </param>
        /// <param name="z">
        /// <para>
        /// Specify the 
        /// x   ,
        /// y   ,
        /// z   ,
        /// and 
        /// w   
        /// object coordinates
        /// (if present)
        /// for the raster
        /// position.
        /// </para>
        /// </param>
        /// <seealso cref="Bitmap"/>
        /// <seealso cref="CopyPixels"/>
        /// <seealso cref="DrawArrays"/>
        /// <seealso cref="DrawElements"/>
        /// <seealso cref="DrawRangeElements"/>
        /// <seealso cref="DrawPixels"/>
        /// <seealso cref="MultiTexCoord"/>
        /// <seealso cref="TexCoord"/>
        /// <seealso cref="TexGen"/>
        /// <seealso cref="Vertex"/>
        /// <seealso cref="WindowPos"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void RasterPos3d(double x, double y, double z) {
            GLNative.glRasterPos3d(x, y, z);
        }

        /// <summary>
        /// specify the raster position for pixel operations
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The raster position is modified by <see cref="glRasterPos"/>,  <see cref="glBitmap"/> , and  <see cref="glWindowPos"/> .
        /// When the raster position coordinates are invalid,
        /// drawing commands that are based on the raster position are
        /// ignored (that is, they do not result in changes to GL state).
        /// Calling  <see cref="glDrawElements"/>  or  <see cref="glDrawRangeElements"/>  may leave the
        /// current color or index indeterminate.
        /// If <see cref="glRasterPos"/> is executed while the current color or index is indeterminate, the
        /// current raster color or current raster index remains indeterminate.
        /// To set a valid raster position outside the viewport, first set a valid
        /// raster position, then call  <see cref="glBitmap"/>  with NULL as the  bitmap 
        /// parameter.
        /// When the <code>ARB_imaging</code> extension is supported, there are distinct
        /// raster texture coordinates for each texture unit. Each texture unit's
        /// current raster texture coordinates are updated by <see cref="glRasterPos"/>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glRasterPos"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glRasterPos3f(GLfloat x, GLfloat y, GLfloat z);</para>
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify the 
        /// x   ,
        /// y   ,
        /// z   ,
        /// and 
        /// w   
        /// object coordinates
        /// (if present)
        /// for the raster
        /// position.
        /// </para>
        /// </param>
        /// <param name="y">
        /// <para>
        /// Specify the 
        /// x   ,
        /// y   ,
        /// z   ,
        /// and 
        /// w   
        /// object coordinates
        /// (if present)
        /// for the raster
        /// position.
        /// </para>
        /// </param>
        /// <param name="z">
        /// <para>
        /// Specify the 
        /// x   ,
        /// y   ,
        /// z   ,
        /// and 
        /// w   
        /// object coordinates
        /// (if present)
        /// for the raster
        /// position.
        /// </para>
        /// </param>
        /// <seealso cref="Bitmap"/>
        /// <seealso cref="CopyPixels"/>
        /// <seealso cref="DrawArrays"/>
        /// <seealso cref="DrawElements"/>
        /// <seealso cref="DrawRangeElements"/>
        /// <seealso cref="DrawPixels"/>
        /// <seealso cref="MultiTexCoord"/>
        /// <seealso cref="TexCoord"/>
        /// <seealso cref="TexGen"/>
        /// <seealso cref="Vertex"/>
        /// <seealso cref="WindowPos"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void RasterPos3f(float x, float y, float z) {
            GLNative.glRasterPos3f(x, y, z);
        }

        /// <summary>
        /// specify the raster position for pixel operations
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The raster position is modified by <see cref="glRasterPos"/>,  <see cref="glBitmap"/> , and  <see cref="glWindowPos"/> .
        /// When the raster position coordinates are invalid,
        /// drawing commands that are based on the raster position are
        /// ignored (that is, they do not result in changes to GL state).
        /// Calling  <see cref="glDrawElements"/>  or  <see cref="glDrawRangeElements"/>  may leave the
        /// current color or index indeterminate.
        /// If <see cref="glRasterPos"/> is executed while the current color or index is indeterminate, the
        /// current raster color or current raster index remains indeterminate.
        /// To set a valid raster position outside the viewport, first set a valid
        /// raster position, then call  <see cref="glBitmap"/>  with NULL as the  bitmap 
        /// parameter.
        /// When the <code>ARB_imaging</code> extension is supported, there are distinct
        /// raster texture coordinates for each texture unit. Each texture unit's
        /// current raster texture coordinates are updated by <see cref="glRasterPos"/>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glRasterPos"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glRasterPos3i(GLint x, GLint y, GLint z);</para>
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify the 
        /// x   ,
        /// y   ,
        /// z   ,
        /// and 
        /// w   
        /// object coordinates
        /// (if present)
        /// for the raster
        /// position.
        /// </para>
        /// </param>
        /// <param name="y">
        /// <para>
        /// Specify the 
        /// x   ,
        /// y   ,
        /// z   ,
        /// and 
        /// w   
        /// object coordinates
        /// (if present)
        /// for the raster
        /// position.
        /// </para>
        /// </param>
        /// <param name="z">
        /// <para>
        /// Specify the 
        /// x   ,
        /// y   ,
        /// z   ,
        /// and 
        /// w   
        /// object coordinates
        /// (if present)
        /// for the raster
        /// position.
        /// </para>
        /// </param>
        /// <seealso cref="Bitmap"/>
        /// <seealso cref="CopyPixels"/>
        /// <seealso cref="DrawArrays"/>
        /// <seealso cref="DrawElements"/>
        /// <seealso cref="DrawRangeElements"/>
        /// <seealso cref="DrawPixels"/>
        /// <seealso cref="MultiTexCoord"/>
        /// <seealso cref="TexCoord"/>
        /// <seealso cref="TexGen"/>
        /// <seealso cref="Vertex"/>
        /// <seealso cref="WindowPos"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void RasterPos3i(int x, int y, int z) {
            GLNative.glRasterPos3i(x, y, z);
        }

        /// <summary>
        /// specify the raster position for pixel operations
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The raster position is modified by <see cref="glRasterPos"/>,  <see cref="glBitmap"/> , and  <see cref="glWindowPos"/> .
        /// When the raster position coordinates are invalid,
        /// drawing commands that are based on the raster position are
        /// ignored (that is, they do not result in changes to GL state).
        /// Calling  <see cref="glDrawElements"/>  or  <see cref="glDrawRangeElements"/>  may leave the
        /// current color or index indeterminate.
        /// If <see cref="glRasterPos"/> is executed while the current color or index is indeterminate, the
        /// current raster color or current raster index remains indeterminate.
        /// To set a valid raster position outside the viewport, first set a valid
        /// raster position, then call  <see cref="glBitmap"/>  with NULL as the  bitmap 
        /// parameter.
        /// When the <code>ARB_imaging</code> extension is supported, there are distinct
        /// raster texture coordinates for each texture unit. Each texture unit's
        /// current raster texture coordinates are updated by <see cref="glRasterPos"/>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glRasterPos"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glRasterPos3s(GLshort x, GLshort y, GLshort z);</para>
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify the 
        /// x   ,
        /// y   ,
        /// z   ,
        /// and 
        /// w   
        /// object coordinates
        /// (if present)
        /// for the raster
        /// position.
        /// </para>
        /// </param>
        /// <param name="y">
        /// <para>
        /// Specify the 
        /// x   ,
        /// y   ,
        /// z   ,
        /// and 
        /// w   
        /// object coordinates
        /// (if present)
        /// for the raster
        /// position.
        /// </para>
        /// </param>
        /// <param name="z">
        /// <para>
        /// Specify the 
        /// x   ,
        /// y   ,
        /// z   ,
        /// and 
        /// w   
        /// object coordinates
        /// (if present)
        /// for the raster
        /// position.
        /// </para>
        /// </param>
        /// <seealso cref="Bitmap"/>
        /// <seealso cref="CopyPixels"/>
        /// <seealso cref="DrawArrays"/>
        /// <seealso cref="DrawElements"/>
        /// <seealso cref="DrawRangeElements"/>
        /// <seealso cref="DrawPixels"/>
        /// <seealso cref="MultiTexCoord"/>
        /// <seealso cref="TexCoord"/>
        /// <seealso cref="TexGen"/>
        /// <seealso cref="Vertex"/>
        /// <seealso cref="WindowPos"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void RasterPos3s(short x, short y, short z) {
            GLNative.glRasterPos3s(x, y, z);
        }

        /// <summary>
        /// specify the raster position for pixel operations
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The raster position is modified by <see cref="glRasterPos"/>,  <see cref="glBitmap"/> , and  <see cref="glWindowPos"/> .
        /// When the raster position coordinates are invalid,
        /// drawing commands that are based on the raster position are
        /// ignored (that is, they do not result in changes to GL state).
        /// Calling  <see cref="glDrawElements"/>  or  <see cref="glDrawRangeElements"/>  may leave the
        /// current color or index indeterminate.
        /// If <see cref="glRasterPos"/> is executed while the current color or index is indeterminate, the
        /// current raster color or current raster index remains indeterminate.
        /// To set a valid raster position outside the viewport, first set a valid
        /// raster position, then call  <see cref="glBitmap"/>  with NULL as the  bitmap 
        /// parameter.
        /// When the <code>ARB_imaging</code> extension is supported, there are distinct
        /// raster texture coordinates for each texture unit. Each texture unit's
        /// current raster texture coordinates are updated by <see cref="glRasterPos"/>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glRasterPos"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glRasterPos4d(GLdouble x, GLdouble y, GLdouble z, GLdouble w);</para>
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify the 
        /// x   ,
        /// y   ,
        /// z   ,
        /// and 
        /// w   
        /// object coordinates
        /// (if present)
        /// for the raster
        /// position.
        /// </para>
        /// </param>
        /// <param name="y">
        /// <para>
        /// Specify the 
        /// x   ,
        /// y   ,
        /// z   ,
        /// and 
        /// w   
        /// object coordinates
        /// (if present)
        /// for the raster
        /// position.
        /// </para>
        /// </param>
        /// <param name="z">
        /// <para>
        /// Specify the 
        /// x   ,
        /// y   ,
        /// z   ,
        /// and 
        /// w   
        /// object coordinates
        /// (if present)
        /// for the raster
        /// position.
        /// </para>
        /// </param>
        /// <param name="w">
        /// <para>
        /// Specify the 
        /// x   ,
        /// y   ,
        /// z   ,
        /// and 
        /// w   
        /// object coordinates
        /// (if present)
        /// for the raster
        /// position.
        /// </para>
        /// </param>
        /// <seealso cref="Bitmap"/>
        /// <seealso cref="CopyPixels"/>
        /// <seealso cref="DrawArrays"/>
        /// <seealso cref="DrawElements"/>
        /// <seealso cref="DrawRangeElements"/>
        /// <seealso cref="DrawPixels"/>
        /// <seealso cref="MultiTexCoord"/>
        /// <seealso cref="TexCoord"/>
        /// <seealso cref="TexGen"/>
        /// <seealso cref="Vertex"/>
        /// <seealso cref="WindowPos"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void RasterPos4d(double x, double y, double z, double w) {
            GLNative.glRasterPos4d(x, y, z, w);
        }

        /// <summary>
        /// specify the raster position for pixel operations
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The raster position is modified by <see cref="glRasterPos"/>,  <see cref="glBitmap"/> , and  <see cref="glWindowPos"/> .
        /// When the raster position coordinates are invalid,
        /// drawing commands that are based on the raster position are
        /// ignored (that is, they do not result in changes to GL state).
        /// Calling  <see cref="glDrawElements"/>  or  <see cref="glDrawRangeElements"/>  may leave the
        /// current color or index indeterminate.
        /// If <see cref="glRasterPos"/> is executed while the current color or index is indeterminate, the
        /// current raster color or current raster index remains indeterminate.
        /// To set a valid raster position outside the viewport, first set a valid
        /// raster position, then call  <see cref="glBitmap"/>  with NULL as the  bitmap 
        /// parameter.
        /// When the <code>ARB_imaging</code> extension is supported, there are distinct
        /// raster texture coordinates for each texture unit. Each texture unit's
        /// current raster texture coordinates are updated by <see cref="glRasterPos"/>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glRasterPos"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glRasterPos4f(GLfloat x, GLfloat y, GLfloat z, GLfloat w);</para>
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify the 
        /// x   ,
        /// y   ,
        /// z   ,
        /// and 
        /// w   
        /// object coordinates
        /// (if present)
        /// for the raster
        /// position.
        /// </para>
        /// </param>
        /// <param name="y">
        /// <para>
        /// Specify the 
        /// x   ,
        /// y   ,
        /// z   ,
        /// and 
        /// w   
        /// object coordinates
        /// (if present)
        /// for the raster
        /// position.
        /// </para>
        /// </param>
        /// <param name="z">
        /// <para>
        /// Specify the 
        /// x   ,
        /// y   ,
        /// z   ,
        /// and 
        /// w   
        /// object coordinates
        /// (if present)
        /// for the raster
        /// position.
        /// </para>
        /// </param>
        /// <param name="w">
        /// <para>
        /// Specify the 
        /// x   ,
        /// y   ,
        /// z   ,
        /// and 
        /// w   
        /// object coordinates
        /// (if present)
        /// for the raster
        /// position.
        /// </para>
        /// </param>
        /// <seealso cref="Bitmap"/>
        /// <seealso cref="CopyPixels"/>
        /// <seealso cref="DrawArrays"/>
        /// <seealso cref="DrawElements"/>
        /// <seealso cref="DrawRangeElements"/>
        /// <seealso cref="DrawPixels"/>
        /// <seealso cref="MultiTexCoord"/>
        /// <seealso cref="TexCoord"/>
        /// <seealso cref="TexGen"/>
        /// <seealso cref="Vertex"/>
        /// <seealso cref="WindowPos"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void RasterPos4f(float x, float y, float z, float w) {
            GLNative.glRasterPos4f(x, y, z, w);
        }

        /// <summary>
        /// specify the raster position for pixel operations
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The raster position is modified by <see cref="glRasterPos"/>,  <see cref="glBitmap"/> , and  <see cref="glWindowPos"/> .
        /// When the raster position coordinates are invalid,
        /// drawing commands that are based on the raster position are
        /// ignored (that is, they do not result in changes to GL state).
        /// Calling  <see cref="glDrawElements"/>  or  <see cref="glDrawRangeElements"/>  may leave the
        /// current color or index indeterminate.
        /// If <see cref="glRasterPos"/> is executed while the current color or index is indeterminate, the
        /// current raster color or current raster index remains indeterminate.
        /// To set a valid raster position outside the viewport, first set a valid
        /// raster position, then call  <see cref="glBitmap"/>  with NULL as the  bitmap 
        /// parameter.
        /// When the <code>ARB_imaging</code> extension is supported, there are distinct
        /// raster texture coordinates for each texture unit. Each texture unit's
        /// current raster texture coordinates are updated by <see cref="glRasterPos"/>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glRasterPos"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glRasterPos4i(GLint x, GLint y, GLint z, GLint w);</para>
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify the 
        /// x   ,
        /// y   ,
        /// z   ,
        /// and 
        /// w   
        /// object coordinates
        /// (if present)
        /// for the raster
        /// position.
        /// </para>
        /// </param>
        /// <param name="y">
        /// <para>
        /// Specify the 
        /// x   ,
        /// y   ,
        /// z   ,
        /// and 
        /// w   
        /// object coordinates
        /// (if present)
        /// for the raster
        /// position.
        /// </para>
        /// </param>
        /// <param name="z">
        /// <para>
        /// Specify the 
        /// x   ,
        /// y   ,
        /// z   ,
        /// and 
        /// w   
        /// object coordinates
        /// (if present)
        /// for the raster
        /// position.
        /// </para>
        /// </param>
        /// <param name="w">
        /// <para>
        /// Specify the 
        /// x   ,
        /// y   ,
        /// z   ,
        /// and 
        /// w   
        /// object coordinates
        /// (if present)
        /// for the raster
        /// position.
        /// </para>
        /// </param>
        /// <seealso cref="Bitmap"/>
        /// <seealso cref="CopyPixels"/>
        /// <seealso cref="DrawArrays"/>
        /// <seealso cref="DrawElements"/>
        /// <seealso cref="DrawRangeElements"/>
        /// <seealso cref="DrawPixels"/>
        /// <seealso cref="MultiTexCoord"/>
        /// <seealso cref="TexCoord"/>
        /// <seealso cref="TexGen"/>
        /// <seealso cref="Vertex"/>
        /// <seealso cref="WindowPos"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void RasterPos4i(int x, int y, int z, int w) {
            GLNative.glRasterPos4i(x, y, z, w);
        }

        /// <summary>
        /// specify the raster position for pixel operations
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The raster position is modified by <see cref="glRasterPos"/>,  <see cref="glBitmap"/> , and  <see cref="glWindowPos"/> .
        /// When the raster position coordinates are invalid,
        /// drawing commands that are based on the raster position are
        /// ignored (that is, they do not result in changes to GL state).
        /// Calling  <see cref="glDrawElements"/>  or  <see cref="glDrawRangeElements"/>  may leave the
        /// current color or index indeterminate.
        /// If <see cref="glRasterPos"/> is executed while the current color or index is indeterminate, the
        /// current raster color or current raster index remains indeterminate.
        /// To set a valid raster position outside the viewport, first set a valid
        /// raster position, then call  <see cref="glBitmap"/>  with NULL as the  bitmap 
        /// parameter.
        /// When the <code>ARB_imaging</code> extension is supported, there are distinct
        /// raster texture coordinates for each texture unit. Each texture unit's
        /// current raster texture coordinates are updated by <see cref="glRasterPos"/>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glRasterPos"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glRasterPos4s(GLshort x, GLshort y, GLshort z, GLshort w);</para>
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify the 
        /// x   ,
        /// y   ,
        /// z   ,
        /// and 
        /// w   
        /// object coordinates
        /// (if present)
        /// for the raster
        /// position.
        /// </para>
        /// </param>
        /// <param name="y">
        /// <para>
        /// Specify the 
        /// x   ,
        /// y   ,
        /// z   ,
        /// and 
        /// w   
        /// object coordinates
        /// (if present)
        /// for the raster
        /// position.
        /// </para>
        /// </param>
        /// <param name="z">
        /// <para>
        /// Specify the 
        /// x   ,
        /// y   ,
        /// z   ,
        /// and 
        /// w   
        /// object coordinates
        /// (if present)
        /// for the raster
        /// position.
        /// </para>
        /// </param>
        /// <param name="w">
        /// <para>
        /// Specify the 
        /// x   ,
        /// y   ,
        /// z   ,
        /// and 
        /// w   
        /// object coordinates
        /// (if present)
        /// for the raster
        /// position.
        /// </para>
        /// </param>
        /// <seealso cref="Bitmap"/>
        /// <seealso cref="CopyPixels"/>
        /// <seealso cref="DrawArrays"/>
        /// <seealso cref="DrawElements"/>
        /// <seealso cref="DrawRangeElements"/>
        /// <seealso cref="DrawPixels"/>
        /// <seealso cref="MultiTexCoord"/>
        /// <seealso cref="TexCoord"/>
        /// <seealso cref="TexGen"/>
        /// <seealso cref="Vertex"/>
        /// <seealso cref="WindowPos"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void RasterPos4s(short x, short y, short z, short w) {
            GLNative.glRasterPos4s(x, y, z, w);
        }

        /// <summary>
        /// draw a rectangle
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glRect"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glRectd(GLdouble x1, GLdouble y1, GLdouble x2, GLdouble y2);</para>
        /// </summary>
        /// <param name="x1">
        /// Specify one vertex of a rectangle.
        /// </param>
        /// <param name="y1">
        /// Specify one vertex of a rectangle.
        /// </param>
        /// <param name="x2">
        /// Specify the opposite vertex of the rectangle.
        /// </param>
        /// <param name="y2">
        /// Specify the opposite vertex of the rectangle.
        /// </param>
        /// <seealso cref="Begin"/>
        /// <seealso cref="Vertex"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void Rectd(double x1, double y1, double x2, double y2) {
            GLNative.glRectd(x1, y1, x2, y2);
        }

        /// <summary>
        /// draw a rectangle
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glRect"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glRectf(GLfloat x1, GLfloat y1, GLfloat x2, GLfloat y2);</para>
        /// </summary>
        /// <param name="x1">
        /// Specify one vertex of a rectangle.
        /// </param>
        /// <param name="y1">
        /// Specify one vertex of a rectangle.
        /// </param>
        /// <param name="x2">
        /// Specify the opposite vertex of the rectangle.
        /// </param>
        /// <param name="y2">
        /// Specify the opposite vertex of the rectangle.
        /// </param>
        /// <seealso cref="Begin"/>
        /// <seealso cref="Vertex"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void Rectf(float x1, float y1, float x2, float y2) {
            GLNative.glRectf(x1, y1, x2, y2);
        }

        /// <summary>
        /// draw a rectangle
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glRect"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glRecti(GLint x1, GLint y1, GLint x2, GLint y2);</para>
        /// </summary>
        /// <param name="x1">
        /// Specify one vertex of a rectangle.
        /// </param>
        /// <param name="y1">
        /// Specify one vertex of a rectangle.
        /// </param>
        /// <param name="x2">
        /// Specify the opposite vertex of the rectangle.
        /// </param>
        /// <param name="y2">
        /// Specify the opposite vertex of the rectangle.
        /// </param>
        /// <seealso cref="Begin"/>
        /// <seealso cref="Vertex"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void Recti(int x1, int y1, int x2, int y2) {
            GLNative.glRecti(x1, y1, x2, y2);
        }

        /// <summary>
        /// draw a rectangle
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glRect"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glRects(GLshort x1, GLshort y1, GLshort x2, GLshort y2);</para>
        /// </summary>
        /// <param name="x1">
        /// Specify one vertex of a rectangle.
        /// </param>
        /// <param name="y1">
        /// Specify one vertex of a rectangle.
        /// </param>
        /// <param name="x2">
        /// Specify the opposite vertex of the rectangle.
        /// </param>
        /// <param name="y2">
        /// Specify the opposite vertex of the rectangle.
        /// </param>
        /// <seealso cref="Begin"/>
        /// <seealso cref="Vertex"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void Rects(short x1, short y1, short x2, short y2) {
            GLNative.glRects(x1, y1, x2, y2);
        }

        /// <summary>
        /// set the current texture coordinates
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The current texture coordinates can be updated at any time.
        /// In particular,
        /// <see cref="glTexCoord"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// When the <code>ARB_imaging</code> extension is supported, <see cref="glTexCoord"/> always
        /// updates texture unit <code>GL_TEXTURE0</code>.
        /// </para>
        /// Original: <para>void glTexCoord1d(GLdouble s);</para>
        /// </summary>
        /// <param name="s">
        /// <para>
        /// Specify  s ,  t ,  r , and  q   texture coordinates.
        /// Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        /// <seealso cref="MultiTexCoord"/>
        /// <seealso cref="TexCoordPointer"/>
        /// <seealso cref="Vertex"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void TexCoord1d(double s) {
            GLNative.glTexCoord1d(s);
        }

        /// <summary>
        /// set the current texture coordinates
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The current texture coordinates can be updated at any time.
        /// In particular,
        /// <see cref="glTexCoord"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// When the <code>ARB_imaging</code> extension is supported, <see cref="glTexCoord"/> always
        /// updates texture unit <code>GL_TEXTURE0</code>.
        /// </para>
        /// Original: <para>void glTexCoord1f(GLfloat s);</para>
        /// </summary>
        /// <param name="s">
        /// <para>
        /// Specify  s ,  t ,  r , and  q   texture coordinates.
        /// Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        /// <seealso cref="MultiTexCoord"/>
        /// <seealso cref="TexCoordPointer"/>
        /// <seealso cref="Vertex"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void TexCoord1f(float s) {
            GLNative.glTexCoord1f(s);
        }

        /// <summary>
        /// set the current texture coordinates
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The current texture coordinates can be updated at any time.
        /// In particular,
        /// <see cref="glTexCoord"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// When the <code>ARB_imaging</code> extension is supported, <see cref="glTexCoord"/> always
        /// updates texture unit <code>GL_TEXTURE0</code>.
        /// </para>
        /// Original: <para>void glTexCoord1i(GLint s);</para>
        /// </summary>
        /// <param name="s">
        /// <para>
        /// Specify  s ,  t ,  r , and  q   texture coordinates.
        /// Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        /// <seealso cref="MultiTexCoord"/>
        /// <seealso cref="TexCoordPointer"/>
        /// <seealso cref="Vertex"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void TexCoord1i(int s) {
            GLNative.glTexCoord1i(s);
        }

        /// <summary>
        /// set the current texture coordinates
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The current texture coordinates can be updated at any time.
        /// In particular,
        /// <see cref="glTexCoord"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// When the <code>ARB_imaging</code> extension is supported, <see cref="glTexCoord"/> always
        /// updates texture unit <code>GL_TEXTURE0</code>.
        /// </para>
        /// Original: <para>void glTexCoord1s(GLshort s);</para>
        /// </summary>
        /// <param name="s">
        /// <para>
        /// Specify  s ,  t ,  r , and  q   texture coordinates.
        /// Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        /// <seealso cref="MultiTexCoord"/>
        /// <seealso cref="TexCoordPointer"/>
        /// <seealso cref="Vertex"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void TexCoord1s(short s) {
            GLNative.glTexCoord1s(s);
        }

        /// <summary>
        /// set the current texture coordinates
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The current texture coordinates can be updated at any time.
        /// In particular,
        /// <see cref="glTexCoord"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// When the <code>ARB_imaging</code> extension is supported, <see cref="glTexCoord"/> always
        /// updates texture unit <code>GL_TEXTURE0</code>.
        /// </para>
        /// Original: <para>void glTexCoord2d(GLdouble s, GLdouble t);</para>
        /// </summary>
        /// <param name="s">
        /// <para>
        /// Specify  s ,  t ,  r , and  q   texture coordinates.
        /// Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        /// <param name="t">
        /// <para>
        /// Specify  s ,  t ,  r , and  q   texture coordinates.
        /// Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        /// <seealso cref="MultiTexCoord"/>
        /// <seealso cref="TexCoordPointer"/>
        /// <seealso cref="Vertex"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void TexCoord2d(double s, double t) {
            GLNative.glTexCoord2d(s, t);
        }

        /// <summary>
        /// set the current texture coordinates
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The current texture coordinates can be updated at any time.
        /// In particular,
        /// <see cref="glTexCoord"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// When the <code>ARB_imaging</code> extension is supported, <see cref="glTexCoord"/> always
        /// updates texture unit <code>GL_TEXTURE0</code>.
        /// </para>
        /// Original: <para>void glTexCoord2f(GLfloat s, GLfloat t);</para>
        /// </summary>
        /// <param name="s">
        /// <para>
        /// Specify  s ,  t ,  r , and  q   texture coordinates.
        /// Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        /// <param name="t">
        /// <para>
        /// Specify  s ,  t ,  r , and  q   texture coordinates.
        /// Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        /// <seealso cref="MultiTexCoord"/>
        /// <seealso cref="TexCoordPointer"/>
        /// <seealso cref="Vertex"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void TexCoord2f(float s, float t) {
            GLNative.glTexCoord2f(s, t);
        }

        /// <summary>
        /// set the current texture coordinates
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The current texture coordinates can be updated at any time.
        /// In particular,
        /// <see cref="glTexCoord"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// When the <code>ARB_imaging</code> extension is supported, <see cref="glTexCoord"/> always
        /// updates texture unit <code>GL_TEXTURE0</code>.
        /// </para>
        /// Original: <para>void glTexCoord2i(GLint s, GLint t);</para>
        /// </summary>
        /// <param name="s">
        /// <para>
        /// Specify  s ,  t ,  r , and  q   texture coordinates.
        /// Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        /// <param name="t">
        /// <para>
        /// Specify  s ,  t ,  r , and  q   texture coordinates.
        /// Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        /// <seealso cref="MultiTexCoord"/>
        /// <seealso cref="TexCoordPointer"/>
        /// <seealso cref="Vertex"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void TexCoord2i(int s, int t) {
            GLNative.glTexCoord2i(s, t);
        }

        /// <summary>
        /// set the current texture coordinates
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The current texture coordinates can be updated at any time.
        /// In particular,
        /// <see cref="glTexCoord"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// When the <code>ARB_imaging</code> extension is supported, <see cref="glTexCoord"/> always
        /// updates texture unit <code>GL_TEXTURE0</code>.
        /// </para>
        /// Original: <para>void glTexCoord2s(GLshort s, GLshort t);</para>
        /// </summary>
        /// <param name="s">
        /// <para>
        /// Specify  s ,  t ,  r , and  q   texture coordinates.
        /// Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        /// <param name="t">
        /// <para>
        /// Specify  s ,  t ,  r , and  q   texture coordinates.
        /// Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        /// <seealso cref="MultiTexCoord"/>
        /// <seealso cref="TexCoordPointer"/>
        /// <seealso cref="Vertex"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void TexCoord2s(short s, short t) {
            GLNative.glTexCoord2s(s, t);
        }

        /// <summary>
        /// set the current texture coordinates
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The current texture coordinates can be updated at any time.
        /// In particular,
        /// <see cref="glTexCoord"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// When the <code>ARB_imaging</code> extension is supported, <see cref="glTexCoord"/> always
        /// updates texture unit <code>GL_TEXTURE0</code>.
        /// </para>
        /// Original: <para>void glTexCoord3d(GLdouble s, GLdouble t, GLdouble r);</para>
        /// </summary>
        /// <param name="s">
        /// <para>
        /// Specify  s ,  t ,  r , and  q   texture coordinates.
        /// Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        /// <param name="t">
        /// <para>
        /// Specify  s ,  t ,  r , and  q   texture coordinates.
        /// Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        /// <param name="r">
        /// <para>
        /// Specify  s ,  t ,  r , and  q   texture coordinates.
        /// Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        /// <seealso cref="MultiTexCoord"/>
        /// <seealso cref="TexCoordPointer"/>
        /// <seealso cref="Vertex"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void TexCoord3d(double s, double t, double r) {
            GLNative.glTexCoord3d(s, t, r);
        }

        /// <summary>
        /// set the current texture coordinates
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The current texture coordinates can be updated at any time.
        /// In particular,
        /// <see cref="glTexCoord"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// When the <code>ARB_imaging</code> extension is supported, <see cref="glTexCoord"/> always
        /// updates texture unit <code>GL_TEXTURE0</code>.
        /// </para>
        /// Original: <para>void glTexCoord3f(GLfloat s, GLfloat t, GLfloat r);</para>
        /// </summary>
        /// <param name="s">
        /// <para>
        /// Specify  s ,  t ,  r , and  q   texture coordinates.
        /// Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        /// <param name="t">
        /// <para>
        /// Specify  s ,  t ,  r , and  q   texture coordinates.
        /// Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        /// <param name="r">
        /// <para>
        /// Specify  s ,  t ,  r , and  q   texture coordinates.
        /// Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        /// <seealso cref="MultiTexCoord"/>
        /// <seealso cref="TexCoordPointer"/>
        /// <seealso cref="Vertex"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void TexCoord3f(float s, float t, float r) {
            GLNative.glTexCoord3f(s, t, r);
        }

        /// <summary>
        /// set the current texture coordinates
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The current texture coordinates can be updated at any time.
        /// In particular,
        /// <see cref="glTexCoord"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// When the <code>ARB_imaging</code> extension is supported, <see cref="glTexCoord"/> always
        /// updates texture unit <code>GL_TEXTURE0</code>.
        /// </para>
        /// Original: <para>void glTexCoord3i(GLint s, GLint t, GLint r);</para>
        /// </summary>
        /// <param name="s">
        /// <para>
        /// Specify  s ,  t ,  r , and  q   texture coordinates.
        /// Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        /// <param name="t">
        /// <para>
        /// Specify  s ,  t ,  r , and  q   texture coordinates.
        /// Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        /// <param name="r">
        /// <para>
        /// Specify  s ,  t ,  r , and  q   texture coordinates.
        /// Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        /// <seealso cref="MultiTexCoord"/>
        /// <seealso cref="TexCoordPointer"/>
        /// <seealso cref="Vertex"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void TexCoord3i(int s, int t, int r) {
            GLNative.glTexCoord3i(s, t, r);
        }

        /// <summary>
        /// set the current texture coordinates
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The current texture coordinates can be updated at any time.
        /// In particular,
        /// <see cref="glTexCoord"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// When the <code>ARB_imaging</code> extension is supported, <see cref="glTexCoord"/> always
        /// updates texture unit <code>GL_TEXTURE0</code>.
        /// </para>
        /// Original: <para>void glTexCoord3s(GLshort s, GLshort t, GLshort r);</para>
        /// </summary>
        /// <param name="s">
        /// <para>
        /// Specify  s ,  t ,  r , and  q   texture coordinates.
        /// Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        /// <param name="t">
        /// <para>
        /// Specify  s ,  t ,  r , and  q   texture coordinates.
        /// Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        /// <param name="r">
        /// <para>
        /// Specify  s ,  t ,  r , and  q   texture coordinates.
        /// Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        /// <seealso cref="MultiTexCoord"/>
        /// <seealso cref="TexCoordPointer"/>
        /// <seealso cref="Vertex"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void TexCoord3s(short s, short t, short r) {
            GLNative.glTexCoord3s(s, t, r);
        }

        /// <summary>
        /// set the current texture coordinates
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The current texture coordinates can be updated at any time.
        /// In particular,
        /// <see cref="glTexCoord"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// When the <code>ARB_imaging</code> extension is supported, <see cref="glTexCoord"/> always
        /// updates texture unit <code>GL_TEXTURE0</code>.
        /// </para>
        /// Original: <para>void glTexCoord4d(GLdouble s, GLdouble t, GLdouble r, GLdouble q);</para>
        /// </summary>
        /// <param name="s">
        /// <para>
        /// Specify  s ,  t ,  r , and  q   texture coordinates.
        /// Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        /// <param name="t">
        /// <para>
        /// Specify  s ,  t ,  r , and  q   texture coordinates.
        /// Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        /// <param name="r">
        /// <para>
        /// Specify  s ,  t ,  r , and  q   texture coordinates.
        /// Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        /// <param name="q">
        /// <para>
        /// Specify  s ,  t ,  r , and  q   texture coordinates.
        /// Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        /// <seealso cref="MultiTexCoord"/>
        /// <seealso cref="TexCoordPointer"/>
        /// <seealso cref="Vertex"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void TexCoord4d(double s, double t, double r, double q) {
            GLNative.glTexCoord4d(s, t, r, q);
        }

        /// <summary>
        /// set the current texture coordinates
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The current texture coordinates can be updated at any time.
        /// In particular,
        /// <see cref="glTexCoord"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// When the <code>ARB_imaging</code> extension is supported, <see cref="glTexCoord"/> always
        /// updates texture unit <code>GL_TEXTURE0</code>.
        /// </para>
        /// Original: <para>void glTexCoord4f(GLfloat s, GLfloat t, GLfloat r, GLfloat q);</para>
        /// </summary>
        /// <param name="s">
        /// <para>
        /// Specify  s ,  t ,  r , and  q   texture coordinates.
        /// Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        /// <param name="t">
        /// <para>
        /// Specify  s ,  t ,  r , and  q   texture coordinates.
        /// Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        /// <param name="r">
        /// <para>
        /// Specify  s ,  t ,  r , and  q   texture coordinates.
        /// Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        /// <param name="q">
        /// <para>
        /// Specify  s ,  t ,  r , and  q   texture coordinates.
        /// Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        /// <seealso cref="MultiTexCoord"/>
        /// <seealso cref="TexCoordPointer"/>
        /// <seealso cref="Vertex"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void TexCoord4f(float s, float t, float r, float q) {
            GLNative.glTexCoord4f(s, t, r, q);
        }

        /// <summary>
        /// set the current texture coordinates
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The current texture coordinates can be updated at any time.
        /// In particular,
        /// <see cref="glTexCoord"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// When the <code>ARB_imaging</code> extension is supported, <see cref="glTexCoord"/> always
        /// updates texture unit <code>GL_TEXTURE0</code>.
        /// </para>
        /// Original: <para>void glTexCoord4i(GLint s, GLint t, GLint r, GLint q);</para>
        /// </summary>
        /// <param name="s">
        /// <para>
        /// Specify  s ,  t ,  r , and  q   texture coordinates.
        /// Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        /// <param name="t">
        /// <para>
        /// Specify  s ,  t ,  r , and  q   texture coordinates.
        /// Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        /// <param name="r">
        /// <para>
        /// Specify  s ,  t ,  r , and  q   texture coordinates.
        /// Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        /// <param name="q">
        /// <para>
        /// Specify  s ,  t ,  r , and  q   texture coordinates.
        /// Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        /// <seealso cref="MultiTexCoord"/>
        /// <seealso cref="TexCoordPointer"/>
        /// <seealso cref="Vertex"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void TexCoord4i(int s, int t, int r, int q) {
            GLNative.glTexCoord4i(s, t, r, q);
        }

        /// <summary>
        /// set the current texture coordinates
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The current texture coordinates can be updated at any time.
        /// In particular,
        /// <see cref="glTexCoord"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// When the <code>ARB_imaging</code> extension is supported, <see cref="glTexCoord"/> always
        /// updates texture unit <code>GL_TEXTURE0</code>.
        /// </para>
        /// Original: <para>void glTexCoord4s(GLshort s, GLshort t, GLshort r, GLshort q);</para>
        /// </summary>
        /// <param name="s">
        /// <para>
        /// Specify  s ,  t ,  r , and  q   texture coordinates.
        /// Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        /// <param name="t">
        /// <para>
        /// Specify  s ,  t ,  r , and  q   texture coordinates.
        /// Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        /// <param name="r">
        /// <para>
        /// Specify  s ,  t ,  r , and  q   texture coordinates.
        /// Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        /// <param name="q">
        /// <para>
        /// Specify  s ,  t ,  r , and  q   texture coordinates.
        /// Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        /// <seealso cref="MultiTexCoord"/>
        /// <seealso cref="TexCoordPointer"/>
        /// <seealso cref="Vertex"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void TexCoord4s(short s, short t, short r, short q) {
            GLNative.glTexCoord4s(s, t, r, q);
        }

        /// <summary>
        /// specify a vertex
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// Invoking <see cref="glVertex"/> outside of a  <see cref="glBegin"/> / <see cref="glEnd"/>  pair
        /// results in undefined behavior.
        /// </para>
        /// Original: <para>void glVertex2d(GLdouble x, GLdouble y);</para>
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify  x ,  y ,  z , and  w  coordinates of a vertex.
        /// Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        /// <param name="y">
        /// <para>
        /// Specify  x ,  y ,  z , and  w  coordinates of a vertex.
        /// Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        /// <seealso cref="Begin"/>
        /// <seealso cref="CallList"/>
        /// <seealso cref="Color"/>
        /// <seealso cref="EdgeFlag"/>
        /// <seealso cref="EvalCoord"/>
        /// <seealso cref="FogCoord"/>
        /// <seealso cref="Index"/>
        /// <seealso cref="Material"/>
        /// <seealso cref="MultiTexCoord"/>
        /// <seealso cref="Normal"/>
        /// <seealso cref="Rect"/>
        /// <seealso cref="TexCoord"/>
        /// <seealso cref="VertexPointer"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void Vertex2d(double x, double y) {
            GLNative.glVertex2d(x, y);
        }

        /// <summary>
        /// specify a vertex
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// Invoking <see cref="glVertex"/> outside of a  <see cref="glBegin"/> / <see cref="glEnd"/>  pair
        /// results in undefined behavior.
        /// </para>
        /// Original: <para>void glVertex2f(GLfloat x, GLfloat y);</para>
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify  x ,  y ,  z , and  w  coordinates of a vertex.
        /// Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        /// <param name="y">
        /// <para>
        /// Specify  x ,  y ,  z , and  w  coordinates of a vertex.
        /// Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        /// <seealso cref="Begin"/>
        /// <seealso cref="CallList"/>
        /// <seealso cref="Color"/>
        /// <seealso cref="EdgeFlag"/>
        /// <seealso cref="EvalCoord"/>
        /// <seealso cref="FogCoord"/>
        /// <seealso cref="Index"/>
        /// <seealso cref="Material"/>
        /// <seealso cref="MultiTexCoord"/>
        /// <seealso cref="Normal"/>
        /// <seealso cref="Rect"/>
        /// <seealso cref="TexCoord"/>
        /// <seealso cref="VertexPointer"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void Vertex2f(float x, float y) {
            GLNative.glVertex2f(x, y);
        }

        /// <summary>
        /// specify a vertex
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// Invoking <see cref="glVertex"/> outside of a  <see cref="glBegin"/> / <see cref="glEnd"/>  pair
        /// results in undefined behavior.
        /// </para>
        /// Original: <para>void glVertex2i(GLint x, GLint y);</para>
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify  x ,  y ,  z , and  w  coordinates of a vertex.
        /// Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        /// <param name="y">
        /// <para>
        /// Specify  x ,  y ,  z , and  w  coordinates of a vertex.
        /// Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        /// <seealso cref="Begin"/>
        /// <seealso cref="CallList"/>
        /// <seealso cref="Color"/>
        /// <seealso cref="EdgeFlag"/>
        /// <seealso cref="EvalCoord"/>
        /// <seealso cref="FogCoord"/>
        /// <seealso cref="Index"/>
        /// <seealso cref="Material"/>
        /// <seealso cref="MultiTexCoord"/>
        /// <seealso cref="Normal"/>
        /// <seealso cref="Rect"/>
        /// <seealso cref="TexCoord"/>
        /// <seealso cref="VertexPointer"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void Vertex2i(int x, int y) {
            GLNative.glVertex2i(x, y);
        }

        /// <summary>
        /// specify a vertex
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// Invoking <see cref="glVertex"/> outside of a  <see cref="glBegin"/> / <see cref="glEnd"/>  pair
        /// results in undefined behavior.
        /// </para>
        /// Original: <para>void glVertex2s(GLshort x, GLshort y);</para>
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify  x ,  y ,  z , and  w  coordinates of a vertex.
        /// Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        /// <param name="y">
        /// <para>
        /// Specify  x ,  y ,  z , and  w  coordinates of a vertex.
        /// Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        /// <seealso cref="Begin"/>
        /// <seealso cref="CallList"/>
        /// <seealso cref="Color"/>
        /// <seealso cref="EdgeFlag"/>
        /// <seealso cref="EvalCoord"/>
        /// <seealso cref="FogCoord"/>
        /// <seealso cref="Index"/>
        /// <seealso cref="Material"/>
        /// <seealso cref="MultiTexCoord"/>
        /// <seealso cref="Normal"/>
        /// <seealso cref="Rect"/>
        /// <seealso cref="TexCoord"/>
        /// <seealso cref="VertexPointer"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void Vertex2s(short x, short y) {
            GLNative.glVertex2s(x, y);
        }

        /// <summary>
        /// specify a vertex
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// Invoking <see cref="glVertex"/> outside of a  <see cref="glBegin"/> / <see cref="glEnd"/>  pair
        /// results in undefined behavior.
        /// </para>
        /// Original: <para>void glVertex3d(GLdouble x, GLdouble y, GLdouble z);</para>
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify  x ,  y ,  z , and  w  coordinates of a vertex.
        /// Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        /// <param name="y">
        /// <para>
        /// Specify  x ,  y ,  z , and  w  coordinates of a vertex.
        /// Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        /// <param name="z">
        /// <para>
        /// Specify  x ,  y ,  z , and  w  coordinates of a vertex.
        /// Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        /// <seealso cref="Begin"/>
        /// <seealso cref="CallList"/>
        /// <seealso cref="Color"/>
        /// <seealso cref="EdgeFlag"/>
        /// <seealso cref="EvalCoord"/>
        /// <seealso cref="FogCoord"/>
        /// <seealso cref="Index"/>
        /// <seealso cref="Material"/>
        /// <seealso cref="MultiTexCoord"/>
        /// <seealso cref="Normal"/>
        /// <seealso cref="Rect"/>
        /// <seealso cref="TexCoord"/>
        /// <seealso cref="VertexPointer"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void Vertex3d(double x, double y, double z) {
            GLNative.glVertex3d(x, y, z);
        }

        /// <summary>
        /// specify a vertex
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// Invoking <see cref="glVertex"/> outside of a  <see cref="glBegin"/> / <see cref="glEnd"/>  pair
        /// results in undefined behavior.
        /// </para>
        /// Original: <para>void glVertex3f(GLfloat x, GLfloat y, GLfloat z);</para>
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify  x ,  y ,  z , and  w  coordinates of a vertex.
        /// Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        /// <param name="y">
        /// <para>
        /// Specify  x ,  y ,  z , and  w  coordinates of a vertex.
        /// Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        /// <param name="z">
        /// <para>
        /// Specify  x ,  y ,  z , and  w  coordinates of a vertex.
        /// Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        /// <seealso cref="Begin"/>
        /// <seealso cref="CallList"/>
        /// <seealso cref="Color"/>
        /// <seealso cref="EdgeFlag"/>
        /// <seealso cref="EvalCoord"/>
        /// <seealso cref="FogCoord"/>
        /// <seealso cref="Index"/>
        /// <seealso cref="Material"/>
        /// <seealso cref="MultiTexCoord"/>
        /// <seealso cref="Normal"/>
        /// <seealso cref="Rect"/>
        /// <seealso cref="TexCoord"/>
        /// <seealso cref="VertexPointer"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void Vertex3f(float x, float y, float z) {
            GLNative.glVertex3f(x, y, z);
        }

        /// <summary>
        /// specify a vertex
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// Invoking <see cref="glVertex"/> outside of a  <see cref="glBegin"/> / <see cref="glEnd"/>  pair
        /// results in undefined behavior.
        /// </para>
        /// Original: <para>void glVertex3i(GLint x, GLint y, GLint z);</para>
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify  x ,  y ,  z , and  w  coordinates of a vertex.
        /// Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        /// <param name="y">
        /// <para>
        /// Specify  x ,  y ,  z , and  w  coordinates of a vertex.
        /// Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        /// <param name="z">
        /// <para>
        /// Specify  x ,  y ,  z , and  w  coordinates of a vertex.
        /// Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        /// <seealso cref="Begin"/>
        /// <seealso cref="CallList"/>
        /// <seealso cref="Color"/>
        /// <seealso cref="EdgeFlag"/>
        /// <seealso cref="EvalCoord"/>
        /// <seealso cref="FogCoord"/>
        /// <seealso cref="Index"/>
        /// <seealso cref="Material"/>
        /// <seealso cref="MultiTexCoord"/>
        /// <seealso cref="Normal"/>
        /// <seealso cref="Rect"/>
        /// <seealso cref="TexCoord"/>
        /// <seealso cref="VertexPointer"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void Vertex3i(int x, int y, int z) {
            GLNative.glVertex3i(x, y, z);
        }

        /// <summary>
        /// specify a vertex
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// Invoking <see cref="glVertex"/> outside of a  <see cref="glBegin"/> / <see cref="glEnd"/>  pair
        /// results in undefined behavior.
        /// </para>
        /// Original: <para>void glVertex3s(GLshort x, GLshort y, GLshort z);</para>
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify  x ,  y ,  z , and  w  coordinates of a vertex.
        /// Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        /// <param name="y">
        /// <para>
        /// Specify  x ,  y ,  z , and  w  coordinates of a vertex.
        /// Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        /// <param name="z">
        /// <para>
        /// Specify  x ,  y ,  z , and  w  coordinates of a vertex.
        /// Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        /// <seealso cref="Begin"/>
        /// <seealso cref="CallList"/>
        /// <seealso cref="Color"/>
        /// <seealso cref="EdgeFlag"/>
        /// <seealso cref="EvalCoord"/>
        /// <seealso cref="FogCoord"/>
        /// <seealso cref="Index"/>
        /// <seealso cref="Material"/>
        /// <seealso cref="MultiTexCoord"/>
        /// <seealso cref="Normal"/>
        /// <seealso cref="Rect"/>
        /// <seealso cref="TexCoord"/>
        /// <seealso cref="VertexPointer"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void Vertex3s(short x, short y, short z) {
            GLNative.glVertex3s(x, y, z);
        }

        /// <summary>
        /// specify a vertex
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// Invoking <see cref="glVertex"/> outside of a  <see cref="glBegin"/> / <see cref="glEnd"/>  pair
        /// results in undefined behavior.
        /// </para>
        /// Original: <para>void glVertex4d(GLdouble x, GLdouble y, GLdouble z, GLdouble w);</para>
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify  x ,  y ,  z , and  w  coordinates of a vertex.
        /// Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        /// <param name="y">
        /// <para>
        /// Specify  x ,  y ,  z , and  w  coordinates of a vertex.
        /// Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        /// <param name="z">
        /// <para>
        /// Specify  x ,  y ,  z , and  w  coordinates of a vertex.
        /// Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        /// <param name="w">
        /// <para>
        /// Specify  x ,  y ,  z , and  w  coordinates of a vertex.
        /// Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        /// <seealso cref="Begin"/>
        /// <seealso cref="CallList"/>
        /// <seealso cref="Color"/>
        /// <seealso cref="EdgeFlag"/>
        /// <seealso cref="EvalCoord"/>
        /// <seealso cref="FogCoord"/>
        /// <seealso cref="Index"/>
        /// <seealso cref="Material"/>
        /// <seealso cref="MultiTexCoord"/>
        /// <seealso cref="Normal"/>
        /// <seealso cref="Rect"/>
        /// <seealso cref="TexCoord"/>
        /// <seealso cref="VertexPointer"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void Vertex4d(double x, double y, double z, double w) {
            GLNative.glVertex4d(x, y, z, w);
        }

        /// <summary>
        /// specify a vertex
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// Invoking <see cref="glVertex"/> outside of a  <see cref="glBegin"/> / <see cref="glEnd"/>  pair
        /// results in undefined behavior.
        /// </para>
        /// Original: <para>void glVertex4f(GLfloat x, GLfloat y, GLfloat z, GLfloat w);</para>
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify  x ,  y ,  z , and  w  coordinates of a vertex.
        /// Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        /// <param name="y">
        /// <para>
        /// Specify  x ,  y ,  z , and  w  coordinates of a vertex.
        /// Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        /// <param name="z">
        /// <para>
        /// Specify  x ,  y ,  z , and  w  coordinates of a vertex.
        /// Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        /// <param name="w">
        /// <para>
        /// Specify  x ,  y ,  z , and  w  coordinates of a vertex.
        /// Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        /// <seealso cref="Begin"/>
        /// <seealso cref="CallList"/>
        /// <seealso cref="Color"/>
        /// <seealso cref="EdgeFlag"/>
        /// <seealso cref="EvalCoord"/>
        /// <seealso cref="FogCoord"/>
        /// <seealso cref="Index"/>
        /// <seealso cref="Material"/>
        /// <seealso cref="MultiTexCoord"/>
        /// <seealso cref="Normal"/>
        /// <seealso cref="Rect"/>
        /// <seealso cref="TexCoord"/>
        /// <seealso cref="VertexPointer"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void Vertex4f(float x, float y, float z, float w) {
            GLNative.glVertex4f(x, y, z, w);
        }

        /// <summary>
        /// specify a vertex
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// Invoking <see cref="glVertex"/> outside of a  <see cref="glBegin"/> / <see cref="glEnd"/>  pair
        /// results in undefined behavior.
        /// </para>
        /// Original: <para>void glVertex4i(GLint x, GLint y, GLint z, GLint w);</para>
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify  x ,  y ,  z , and  w  coordinates of a vertex.
        /// Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        /// <param name="y">
        /// <para>
        /// Specify  x ,  y ,  z , and  w  coordinates of a vertex.
        /// Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        /// <param name="z">
        /// <para>
        /// Specify  x ,  y ,  z , and  w  coordinates of a vertex.
        /// Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        /// <param name="w">
        /// <para>
        /// Specify  x ,  y ,  z , and  w  coordinates of a vertex.
        /// Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        /// <seealso cref="Begin"/>
        /// <seealso cref="CallList"/>
        /// <seealso cref="Color"/>
        /// <seealso cref="EdgeFlag"/>
        /// <seealso cref="EvalCoord"/>
        /// <seealso cref="FogCoord"/>
        /// <seealso cref="Index"/>
        /// <seealso cref="Material"/>
        /// <seealso cref="MultiTexCoord"/>
        /// <seealso cref="Normal"/>
        /// <seealso cref="Rect"/>
        /// <seealso cref="TexCoord"/>
        /// <seealso cref="VertexPointer"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void Vertex4i(int x, int y, int z, int w) {
            GLNative.glVertex4i(x, y, z, w);
        }

        /// <summary>
        /// specify a vertex
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// Invoking <see cref="glVertex"/> outside of a  <see cref="glBegin"/> / <see cref="glEnd"/>  pair
        /// results in undefined behavior.
        /// </para>
        /// Original: <para>void glVertex4s(GLshort x, GLshort y, GLshort z, GLshort w);</para>
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify  x ,  y ,  z , and  w  coordinates of a vertex.
        /// Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        /// <param name="y">
        /// <para>
        /// Specify  x ,  y ,  z , and  w  coordinates of a vertex.
        /// Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        /// <param name="z">
        /// <para>
        /// Specify  x ,  y ,  z , and  w  coordinates of a vertex.
        /// Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        /// <param name="w">
        /// <para>
        /// Specify  x ,  y ,  z , and  w  coordinates of a vertex.
        /// Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        /// <seealso cref="Begin"/>
        /// <seealso cref="CallList"/>
        /// <seealso cref="Color"/>
        /// <seealso cref="EdgeFlag"/>
        /// <seealso cref="EvalCoord"/>
        /// <seealso cref="FogCoord"/>
        /// <seealso cref="Index"/>
        /// <seealso cref="Material"/>
        /// <seealso cref="MultiTexCoord"/>
        /// <seealso cref="Normal"/>
        /// <seealso cref="Rect"/>
        /// <seealso cref="TexCoord"/>
        /// <seealso cref="VertexPointer"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void Vertex4s(short x, short y, short z, short w) {
            GLNative.glVertex4s(x, y, z, w);
        }

        /// <summary>
        /// cause a material color to track the current color
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glColorMaterial"/> makes it possible to change a subset of material parameters for each
        /// vertex using only the  <see cref="glColor"/>  command,
        /// without calling  <see cref="glMaterial"/> .
        /// If only such a subset of parameters is to be specified for each
        /// vertex, calling <see cref="glColorMaterial"/> is preferable to calling  <see cref="glMaterial"/> .
        /// Call <see cref="glColorMaterial"/> before enabling <code>GL_COLOR_MATERIAL</code>.
        /// Calling  <see cref="glDrawElements"/> ,  <see cref="glDrawArrays"/> , or  <see cref="glDrawRangeElements"/> 
        /// may leave the current color indeterminate, if the color array is enabled.
        /// If
        /// <see cref="glColorMaterial"/> is enabled while the current color is indeterminate, the
        /// lighting material state specified by <paramref name="face"/> and <paramref name="mode"/> is also indeterminate.
        /// If the GL version is 1.1 or greater, and <code>GL_COLOR_MATERIAL</code> is
        /// enabled, evaluated color values affect the results of the lighting
        /// equation as if the current color were being modified, but no change is
        /// made to the tracking lighting parameter of the current color.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="face"/> or <paramref name="mode"/> is not an
        /// accepted value.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glColorMaterial"/> is executed between
        /// the execution of  <see cref="glBegin"/>  and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glColorMaterial(GLenum face, GLenum mode);</para>
        /// </summary>
        /// <param name="face">
        /// <para>
        /// Specifies whether front,
        /// back,
        /// or both front and back material parameters should track the current color.
        /// Accepted values are
        /// <code>GL_FRONT</code>,
        /// <code>GL_BACK</code>,
        /// and <code>GL_FRONT_AND_BACK</code>.
        /// The initial value is <code>GL_FRONT_AND_BACK</code>.
        /// </para>
        /// </param>
        /// <param name="mode">
        /// <para>
        /// Specifies which of several material parameters track the current color.
        /// Accepted values are
        /// <code>GL_EMISSION</code>,
        /// <code>GL_AMBIENT</code>,
        /// <code>GL_DIFFUSE</code>,
        /// <code>GL_SPECULAR</code>,
        /// and <code>GL_AMBIENT_AND_DIFFUSE</code>.
        /// The initial value is <code>GL_AMBIENT_AND_DIFFUSE</code>.
        /// </para>
        /// </param>
        /// <seealso cref="Color"/>
        /// <seealso cref="ColorPointer"/>
        /// <seealso cref="DrawArrays"/>
        /// <seealso cref="DrawElements"/>
        /// <seealso cref="DrawRangeElements"/>
        /// <seealso cref="Enable"/>
        /// <seealso cref="Light"/>
        /// <seealso cref="LightModel"/>
        /// <seealso cref="Material"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void ColorMaterial(uint face, uint mode) {
            GLNative.glColorMaterial(face, mode);
        }

        /// <summary>
        /// specify fog parameters
        /// <para>Require:</para> <para>GL_VERSION_1_0, GL_VERSION_ES_CM_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <code>GL_FOG_COORD_SRC</code> is available only if the GL version is 1.4 or
        /// greater.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="pname"/> is not an accepted value,
        /// or if <paramref name="pname"/> is <code>GL_FOG_MODE</code> and <paramref name="ps"/> is not an accepted value.
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="pname"/> is <code>GL_FOG_DENSITY</code>
        /// and <paramref name="ps"/> is negative.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glFog"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glFogf(GLenum pname, GLfloat param);</para>
        /// </summary>
        /// <param name="pname">
        /// <para>
        /// Specifies a single-valued fog parameter.
        /// <code>GL_FOG_MODE</code>,
        /// <code>GL_FOG_DENSITY</code>,
        /// <code>GL_FOG_START</code>,
        /// <code>GL_FOG_END</code>,
        /// <code>GL_FOG_INDEX</code>, and
        /// <code>GL_FOG_COORD_SRC</code>
        /// are accepted.
        /// </para>
        /// </param>
        /// <param name="param">
        /// Specifies the value that <paramref name="pname"/> will be set to.
        /// </param>
        /// <seealso cref="Enable"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void Fogf(uint pname, float param) {
            GLNative.glFogf(pname, param);
        }

        /// <summary>
        /// specify fog parameters
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <code>GL_FOG_COORD_SRC</code> is available only if the GL version is 1.4 or
        /// greater.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="pname"/> is not an accepted value,
        /// or if <paramref name="pname"/> is <code>GL_FOG_MODE</code> and <paramref name="ps"/> is not an accepted value.
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="pname"/> is <code>GL_FOG_DENSITY</code>
        /// and <paramref name="ps"/> is negative.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glFog"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glFogi(GLenum pname, GLint param);</para>
        /// </summary>
        /// <param name="pname">
        /// <para>
        /// Specifies a single-valued fog parameter.
        /// <code>GL_FOG_MODE</code>,
        /// <code>GL_FOG_DENSITY</code>,
        /// <code>GL_FOG_START</code>,
        /// <code>GL_FOG_END</code>,
        /// <code>GL_FOG_INDEX</code>, and
        /// <code>GL_FOG_COORD_SRC</code>
        /// are accepted.
        /// </para>
        /// </param>
        /// <param name="param">
        /// Specifies the value that <paramref name="pname"/> will be set to.
        /// </param>
        /// <seealso cref="Enable"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void Fogi(uint pname, int param) {
            GLNative.glFogi(pname, param);
        }

        /// <summary>
        /// set light source parameters
        /// <para>Require:</para> <para>GL_VERSION_1_0, GL_VERSION_ES_CM_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// It is always the case that <code>GL_LIGHT</code>
        /// i   
        /// = <code>GL_LIGHT0</code> + 
        /// i   .
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if either <paramref name="light"/> or <paramref name="pname"/>
        /// is not an accepted value.
        /// <code>GL_INVALID_VALUE</code> is generated if a spot exponent value is specified
        /// outside the range 
        /// 0 
        /// 128 
        /// ,
        /// or if spot cutoff is specified outside the range 
        /// 0 
        /// 90 
        /// (except for the
        /// special value 180),
        /// or if a negative attenuation factor is specified.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glLight"/> is executed between
        /// the execution of
        /// <see cref="glBegin"/>  and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glLightf(GLenum light, GLenum pname, GLfloat param);</para>
        /// </summary>
        /// <param name="light">
        /// <para>
        /// Specifies a light.
        /// The number of lights depends on the implementation,
        /// but at least eight lights are supported.
        /// They are identified by symbolic names of the form <code>GL_LIGHT</code>
        /// i   ,
        /// where i ranges from 0 to the value of <code>GL_MAX_LIGHTS</code> - 1.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies a single-valued light source parameter for <paramref name="light"/>.
        /// <code>GL_SPOT_EXPONENT</code>,
        /// <code>GL_SPOT_CUTOFF</code>,
        /// <code>GL_CONSTANT_ATTENUATION</code>,
        /// <code>GL_LINEAR_ATTENUATION</code>, and
        /// <code>GL_QUADRATIC_ATTENUATION</code> are accepted.
        /// </para>
        /// </param>
        /// <param name="param">
        /// <para>
        /// Specifies the value that parameter <paramref name="pname"/> of light source <paramref name="light"/>
        /// will be set to.
        /// </para>
        /// </param>
        /// <seealso cref="ColorMaterial"/>
        /// <seealso cref="LightModel"/>
        /// <seealso cref="Material"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void Lightf(uint light, uint pname, float param) {
            GLNative.glLightf(light, pname, param);
        }

        /// <summary>
        /// set light source parameters
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// It is always the case that <code>GL_LIGHT</code>
        /// i   
        /// = <code>GL_LIGHT0</code> + 
        /// i   .
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if either <paramref name="light"/> or <paramref name="pname"/>
        /// is not an accepted value.
        /// <code>GL_INVALID_VALUE</code> is generated if a spot exponent value is specified
        /// outside the range 
        /// 0 
        /// 128 
        /// ,
        /// or if spot cutoff is specified outside the range 
        /// 0 
        /// 90 
        /// (except for the
        /// special value 180),
        /// or if a negative attenuation factor is specified.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glLight"/> is executed between
        /// the execution of
        /// <see cref="glBegin"/>  and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glLighti(GLenum light, GLenum pname, GLint param);</para>
        /// </summary>
        /// <param name="light">
        /// <para>
        /// Specifies a light.
        /// The number of lights depends on the implementation,
        /// but at least eight lights are supported.
        /// They are identified by symbolic names of the form <code>GL_LIGHT</code>
        /// i   ,
        /// where i ranges from 0 to the value of <code>GL_MAX_LIGHTS</code> - 1.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies a single-valued light source parameter for <paramref name="light"/>.
        /// <code>GL_SPOT_EXPONENT</code>,
        /// <code>GL_SPOT_CUTOFF</code>,
        /// <code>GL_CONSTANT_ATTENUATION</code>,
        /// <code>GL_LINEAR_ATTENUATION</code>, and
        /// <code>GL_QUADRATIC_ATTENUATION</code> are accepted.
        /// </para>
        /// </param>
        /// <param name="param">
        /// <para>
        /// Specifies the value that parameter <paramref name="pname"/> of light source <paramref name="light"/>
        /// will be set to.
        /// </para>
        /// </param>
        /// <seealso cref="ColorMaterial"/>
        /// <seealso cref="LightModel"/>
        /// <seealso cref="Material"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void Lighti(uint light, uint pname, int param) {
            GLNative.glLighti(light, pname, param);
        }

        /// <summary>
        /// set the lighting model parameters
        /// <para>Require:</para> <para>GL_VERSION_1_0, GL_VERSION_ES_CM_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <code>GL_LIGHT_MODEL_COLOR_CONTROL</code> is available only if the GL version is
        /// 1.2 or greater.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="pname"/> is not an accepted value.
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="pname"/> is
        /// <code>GL_LIGHT_MODEL_COLOR_CONTROL</code> and <paramref name="ps"/> is not one of
        /// <code>GL_SINGLE_COLOR</code> or <code>GL_SEPARATE_SPECULAR_COLOR</code>.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glLightModel"/> is executed between
        /// the execution of  <see cref="glBegin"/>  and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glLightModelf(GLenum pname, GLfloat param);</para>
        /// </summary>
        /// <param name="pname">
        /// <para>
        /// Specifies a single-valued lighting model parameter.
        /// <code>GL_LIGHT_MODEL_LOCAL_VIEWER</code>,
        /// <code>GL_LIGHT_MODEL_COLOR_CONTROL</code>, and
        /// <code>GL_LIGHT_MODEL_TWO_SIDE</code> are accepted.
        /// </para>
        /// </param>
        /// <param name="param">
        /// Specifies the value that <paramref name="param"/> will be set to.
        /// </param>
        /// <seealso cref="Light"/>
        /// <seealso cref="Material"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void LightModelf(uint pname, float param) {
            GLNative.glLightModelf(pname, param);
        }

        /// <summary>
        /// set the lighting model parameters
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <code>GL_LIGHT_MODEL_COLOR_CONTROL</code> is available only if the GL version is
        /// 1.2 or greater.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="pname"/> is not an accepted value.
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="pname"/> is
        /// <code>GL_LIGHT_MODEL_COLOR_CONTROL</code> and <paramref name="ps"/> is not one of
        /// <code>GL_SINGLE_COLOR</code> or <code>GL_SEPARATE_SPECULAR_COLOR</code>.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glLightModel"/> is executed between
        /// the execution of  <see cref="glBegin"/>  and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glLightModeli(GLenum pname, GLint param);</para>
        /// </summary>
        /// <param name="pname">
        /// <para>
        /// Specifies a single-valued lighting model parameter.
        /// <code>GL_LIGHT_MODEL_LOCAL_VIEWER</code>,
        /// <code>GL_LIGHT_MODEL_COLOR_CONTROL</code>, and
        /// <code>GL_LIGHT_MODEL_TWO_SIDE</code> are accepted.
        /// </para>
        /// </param>
        /// <param name="param">
        /// Specifies the value that <paramref name="param"/> will be set to.
        /// </param>
        /// <seealso cref="Light"/>
        /// <seealso cref="Material"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void LightModeli(uint pname, int param) {
            GLNative.glLightModeli(pname, param);
        }

        /// <summary>
        /// specify the line stipple pattern
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glLineStipple"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glLineStipple(GLint factor, GLushort pattern);</para>
        /// </summary>
        /// <param name="factor">
        /// <para>
        /// Specifies a multiplier for each bit in the line stipple pattern.
        /// If <paramref name="factor"/> is 3,
        /// for example,
        /// each bit in the pattern is used three times
        /// before the next bit in the pattern is used.
        /// <paramref name="factor"/> is clamped to the range [1, 256] and defaults to 1.
        /// </para>
        /// </param>
        /// <param name="pattern">
        /// <para>
        /// Specifies a 16-bit integer whose bit pattern determines
        /// which fragments of a line will be drawn when the line is rasterized.
        /// Bit zero is used first; the default pattern is all 1's.
        /// </para>
        /// </param>
        /// <seealso cref="LineWidth"/>
        /// <seealso cref="PolygonStipple"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void LineStipple(int factor, ushort pattern) {
            GLNative.glLineStipple(factor, pattern);
        }

        /// <summary>
        /// specify material parameters for the lighting model
        /// <para>Require:</para> <para>GL_VERSION_1_0, GL_VERSION_ES_CM_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The material parameters can be updated at any time.
        /// In particular,
        /// <see cref="glMaterial"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// If only a single material parameter is to be changed per vertex,
        /// however,
        /// <see cref="glColorMaterial"/>  is preferred over <see cref="glMaterial"/>
        /// (see  <see cref="glColorMaterial"/> ).
        /// While the ambient, diffuse, specular and emission material parameters
        /// all have alpha components, only the diffuse alpha component is used in
        /// the lighting computation.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if either <paramref name="face"/> or <paramref name="pname"/> is not
        /// an accepted value.
        /// <code>GL_INVALID_VALUE</code> is generated if a specular exponent outside the range
        /// 0 
        /// 128 
        /// is specified.
        /// </para>
        /// Original: <para>void glMaterialf(GLenum face, GLenum pname, GLfloat param);</para>
        /// </summary>
        /// <param name="face">
        /// <para>
        /// Specifies which face or faces are being updated.
        /// Must be one of
        /// <code>GL_FRONT</code>,
        /// <code>GL_BACK</code>, or
        /// <code>GL_FRONT_AND_BACK</code>.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the single-valued material parameter of the face or faces
        /// that is being updated.
        /// Must be <code>GL_SHININESS</code>.
        /// </para>
        /// </param>
        /// <param name="param">
        /// Specifies the value that parameter <code>GL_SHININESS</code> will be set to.
        /// </param>
        /// <seealso cref="ColorMaterial"/>
        /// <seealso cref="Light"/>
        /// <seealso cref="LightModel"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void Materialf(uint face, uint pname, float param) {
            GLNative.glMaterialf(face, pname, param);
        }

        /// <summary>
        /// specify material parameters for the lighting model
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The material parameters can be updated at any time.
        /// In particular,
        /// <see cref="glMaterial"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// If only a single material parameter is to be changed per vertex,
        /// however,
        /// <see cref="glColorMaterial"/>  is preferred over <see cref="glMaterial"/>
        /// (see  <see cref="glColorMaterial"/> ).
        /// While the ambient, diffuse, specular and emission material parameters
        /// all have alpha components, only the diffuse alpha component is used in
        /// the lighting computation.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if either <paramref name="face"/> or <paramref name="pname"/> is not
        /// an accepted value.
        /// <code>GL_INVALID_VALUE</code> is generated if a specular exponent outside the range
        /// 0 
        /// 128 
        /// is specified.
        /// </para>
        /// Original: <para>void glMateriali(GLenum face, GLenum pname, GLint param);</para>
        /// </summary>
        /// <param name="face">
        /// <para>
        /// Specifies which face or faces are being updated.
        /// Must be one of
        /// <code>GL_FRONT</code>,
        /// <code>GL_BACK</code>, or
        /// <code>GL_FRONT_AND_BACK</code>.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the single-valued material parameter of the face or faces
        /// that is being updated.
        /// Must be <code>GL_SHININESS</code>.
        /// </para>
        /// </param>
        /// <param name="param">
        /// Specifies the value that parameter <code>GL_SHININESS</code> will be set to.
        /// </param>
        /// <seealso cref="ColorMaterial"/>
        /// <seealso cref="Light"/>
        /// <seealso cref="LightModel"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void Materiali(uint face, uint pname, int param) {
            GLNative.glMateriali(face, pname, param);
        }

        /// <summary>
        /// select flat or smooth shading
        /// <para>Require:</para> <para>GL_VERSION_1_0, GL_VERSION_ES_CM_1_0</para>
        /// Supported: <para>GL</para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="mode"/> is any value other than
        /// <code>GL_FLAT</code> or <code>GL_SMOOTH</code>.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glShadeModel"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glShadeModel(GLenum mode);</para>
        /// </summary>
        /// <param name="mode">
        /// <para>
        /// Specifies a symbolic value representing a shading technique.
        /// Accepted values are <code>GL_FLAT</code> and <code>GL_SMOOTH</code>.
        /// The initial value is <code>GL_SMOOTH</code>.
        /// </para>
        /// </param>
        /// <seealso cref="Begin"/>
        /// <seealso cref="Color"/>
        /// <seealso cref="Light"/>
        /// <seealso cref="LightModel"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void ShadeModel(uint mode) {
            GLNative.glShadeModel(mode);
        }

        /// <summary>
        /// set texture environment parameters
        /// <para>Require:</para> <para>GL_VERSION_1_0, GL_VERSION_ES_CM_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <code>GL_REPLACE</code> may only be used if the GL version is 1.1 or greater.
        /// <code>GL_TEXTURE_FILTER_CONTROL</code> and <code>GL_TEXTURE_LOD_BIAS</code> may only be
        /// used if the GL version is 1.4 or greater.
        /// <code>GL_COMBINE</code> mode and its associated constants may only be used if the
        /// GL version is 1.3 or greater.
        /// <code>GL_TEXTUREn</code> may only be used if the GL version is 1.4 or greater.
        /// Internal formats other than 1, 2, 3, or 4 may only be used if the GL
        /// version is 1.1 or greater.
        /// For OpenGL versions 1.3 and greater, or when the <code>ARB_multitexture</code> extension is supported, <see cref="glTexEnv"/> controls
        /// the texture environment for the current active texture unit, selected by
        /// <see cref="glActiveTexture"/> .
        /// <code>GL_POINT_SPRITE</code> and <code>GL_COORD_REPLACE</code> are available
        /// only if the GL version is 2.0 or greater.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated when <paramref name="target"/> or <paramref name="pname"/> is not
        /// one of the accepted defined values,
        /// or when <paramref name="ps"/> should have a defined constant value
        /// (based on the value of <paramref name="pname"/>)
        /// and does not.
        /// <code>GL_INVALID_VALUE</code> is generated if the <paramref name="ps"/> value for
        /// <code>GL_RGB_SCALE</code> or <code>GL_ALPHA_SCALE</code> are not one of 1.0, 2.0,
        /// or 4.0.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glTexEnv"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glTexEnvf(GLenum target, GLenum pname, GLfloat param);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies a texture environment.
        /// May be <code>GL_TEXTURE_ENV</code>, <code>GL_TEXTURE_FILTER_CONTROL</code> or <code>GL_POINT_SPRITE</code>.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of a single-valued texture environment parameter.
        /// May be either <code>GL_TEXTURE_ENV_MODE</code>, <code>GL_TEXTURE_LOD_BIAS</code>,
        /// <code>GL_COMBINE_RGB</code>,
        /// <code>GL_COMBINE_ALPHA</code>,
        /// <code>GL_SRC0_RGB</code>,
        /// <code>GL_SRC1_RGB</code>,
        /// <code>GL_SRC2_RGB</code>,
        /// <code>GL_SRC0_ALPHA</code>,
        /// <code>GL_SRC1_ALPHA</code>,
        /// <code>GL_SRC2_ALPHA</code>,
        /// <code>GL_OPERAND0_RGB</code>,
        /// <code>GL_OPERAND1_RGB</code>,
        /// <code>GL_OPERAND2_RGB</code>,
        /// <code>GL_OPERAND0_ALPHA</code>,
        /// <code>GL_OPERAND1_ALPHA</code>,
        /// <code>GL_OPERAND2_ALPHA</code>,
        /// <code>GL_RGB_SCALE</code>,
        /// <code>GL_ALPHA_SCALE</code>, or
        /// <code>GL_COORD_REPLACE</code>.
        /// </para>
        /// </param>
        /// <param name="param">
        /// <para>
        /// Specifies a single symbolic constant, one of <code>GL_ADD</code>,
        /// <code>GL_ADD_SIGNED</code>, <code>GL_INTERPOLATE</code>, <code>GL_MODULATE</code>, <code>GL_DECAL</code>,
        /// <code>GL_BLEND</code>, <code>GL_REPLACE</code>, <code>GL_SUBTRACT</code>, <code>GL_COMBINE</code>,
        /// <code>GL_TEXTURE</code>, <code>GL_CONSTANT</code>, <code>GL_PRIMARY_COLOR</code>, <code>GL_PREVIOUS</code>,
        /// <code>GL_SRC_COLOR</code>, <code>GL_ONE_MINUS_SRC_COLOR</code>, <code>GL_SRC_ALPHA</code>,
        /// <code>GL_ONE_MINUS_SRC_ALPHA</code>,
        /// a single boolean value for the point sprite texture coordinate replacement,
        /// a single floating-point value for the texture level-of-detail bias,
        /// or 1.0, 2.0, or 4.0 when specifying the <code>GL_RGB_SCALE</code> or <code>GL_ALPHA_SCALE</code>.
        /// </para>
        /// </param>
        /// <seealso cref="ActiveTexture"/>
        /// <seealso cref="CopyPixels"/>
        /// <seealso cref="CopyTexImage1D"/>
        /// <seealso cref="CopyTexImage2D"/>
        /// <seealso cref="CopyTexSubImage1D"/>
        /// <seealso cref="CopyTexSubImage2D"/>
        /// <seealso cref="CopyTexSubImage3D"/>
        /// <seealso cref="TexImage1D"/>
        /// <seealso cref="TexImage2D"/>
        /// <seealso cref="TexImage3D"/>
        /// <seealso cref="TexParameter"/>
        /// <seealso cref="TexSubImage1D"/>
        /// <seealso cref="TexSubImage2D"/>
        /// <seealso cref="TexSubImage3D"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void TexEnvf(uint target, uint pname, float param) {
            GLNative.glTexEnvf(target, pname, param);
        }

        /// <summary>
        /// set texture environment parameters
        /// <para>Require:</para> <para>GL_VERSION_1_0, GL_VERSION_ES_CM_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <code>GL_REPLACE</code> may only be used if the GL version is 1.1 or greater.
        /// <code>GL_TEXTURE_FILTER_CONTROL</code> and <code>GL_TEXTURE_LOD_BIAS</code> may only be
        /// used if the GL version is 1.4 or greater.
        /// <code>GL_COMBINE</code> mode and its associated constants may only be used if the
        /// GL version is 1.3 or greater.
        /// <code>GL_TEXTUREn</code> may only be used if the GL version is 1.4 or greater.
        /// Internal formats other than 1, 2, 3, or 4 may only be used if the GL
        /// version is 1.1 or greater.
        /// For OpenGL versions 1.3 and greater, or when the <code>ARB_multitexture</code> extension is supported, <see cref="glTexEnv"/> controls
        /// the texture environment for the current active texture unit, selected by
        /// <see cref="glActiveTexture"/> .
        /// <code>GL_POINT_SPRITE</code> and <code>GL_COORD_REPLACE</code> are available
        /// only if the GL version is 2.0 or greater.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated when <paramref name="target"/> or <paramref name="pname"/> is not
        /// one of the accepted defined values,
        /// or when <paramref name="ps"/> should have a defined constant value
        /// (based on the value of <paramref name="pname"/>)
        /// and does not.
        /// <code>GL_INVALID_VALUE</code> is generated if the <paramref name="ps"/> value for
        /// <code>GL_RGB_SCALE</code> or <code>GL_ALPHA_SCALE</code> are not one of 1.0, 2.0,
        /// or 4.0.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glTexEnv"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glTexEnvi(GLenum target, GLenum pname, GLint param);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies a texture environment.
        /// May be <code>GL_TEXTURE_ENV</code>, <code>GL_TEXTURE_FILTER_CONTROL</code> or <code>GL_POINT_SPRITE</code>.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of a single-valued texture environment parameter.
        /// May be either <code>GL_TEXTURE_ENV_MODE</code>, <code>GL_TEXTURE_LOD_BIAS</code>,
        /// <code>GL_COMBINE_RGB</code>,
        /// <code>GL_COMBINE_ALPHA</code>,
        /// <code>GL_SRC0_RGB</code>,
        /// <code>GL_SRC1_RGB</code>,
        /// <code>GL_SRC2_RGB</code>,
        /// <code>GL_SRC0_ALPHA</code>,
        /// <code>GL_SRC1_ALPHA</code>,
        /// <code>GL_SRC2_ALPHA</code>,
        /// <code>GL_OPERAND0_RGB</code>,
        /// <code>GL_OPERAND1_RGB</code>,
        /// <code>GL_OPERAND2_RGB</code>,
        /// <code>GL_OPERAND0_ALPHA</code>,
        /// <code>GL_OPERAND1_ALPHA</code>,
        /// <code>GL_OPERAND2_ALPHA</code>,
        /// <code>GL_RGB_SCALE</code>,
        /// <code>GL_ALPHA_SCALE</code>, or
        /// <code>GL_COORD_REPLACE</code>.
        /// </para>
        /// </param>
        /// <param name="param">
        /// <para>
        /// Specifies a single symbolic constant, one of <code>GL_ADD</code>,
        /// <code>GL_ADD_SIGNED</code>, <code>GL_INTERPOLATE</code>, <code>GL_MODULATE</code>, <code>GL_DECAL</code>,
        /// <code>GL_BLEND</code>, <code>GL_REPLACE</code>, <code>GL_SUBTRACT</code>, <code>GL_COMBINE</code>,
        /// <code>GL_TEXTURE</code>, <code>GL_CONSTANT</code>, <code>GL_PRIMARY_COLOR</code>, <code>GL_PREVIOUS</code>,
        /// <code>GL_SRC_COLOR</code>, <code>GL_ONE_MINUS_SRC_COLOR</code>, <code>GL_SRC_ALPHA</code>,
        /// <code>GL_ONE_MINUS_SRC_ALPHA</code>,
        /// a single boolean value for the point sprite texture coordinate replacement,
        /// a single floating-point value for the texture level-of-detail bias,
        /// or 1.0, 2.0, or 4.0 when specifying the <code>GL_RGB_SCALE</code> or <code>GL_ALPHA_SCALE</code>.
        /// </para>
        /// </param>
        /// <seealso cref="ActiveTexture"/>
        /// <seealso cref="CopyPixels"/>
        /// <seealso cref="CopyTexImage1D"/>
        /// <seealso cref="CopyTexImage2D"/>
        /// <seealso cref="CopyTexSubImage1D"/>
        /// <seealso cref="CopyTexSubImage2D"/>
        /// <seealso cref="CopyTexSubImage3D"/>
        /// <seealso cref="TexImage1D"/>
        /// <seealso cref="TexImage2D"/>
        /// <seealso cref="TexImage3D"/>
        /// <seealso cref="TexParameter"/>
        /// <seealso cref="TexSubImage1D"/>
        /// <seealso cref="TexSubImage2D"/>
        /// <seealso cref="TexSubImage3D"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void TexEnvi(uint target, uint pname, int param) {
            GLNative.glTexEnvi(target, pname, param);
        }

        /// <summary>
        /// control the generation of texture coordinates
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated when <paramref name="coord"/> or <paramref name="pname"/> is not an
        /// accepted defined value,
        /// or when <paramref name="pname"/> is <code>GL_TEXTURE_GEN_MODE</code> and <paramref name="ps"/> is not an
        /// accepted defined value.
        /// <code>GL_INVALID_ENUM</code> is generated when <paramref name="pname"/> is <code>GL_TEXTURE_GEN_MODE</code>,
        /// <paramref name="ps"/> is <code>GL_SPHERE_MAP</code>,
        /// and <paramref name="coord"/> is either <code>GL_R</code> or <code>GL_Q</code>.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glTexGen"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glTexGend(GLenum coord, GLenum pname, GLdouble param);</para>
        /// </summary>
        /// <param name="coord">
        /// <para>
        /// Specifies a texture coordinate.
        /// Must be one of <code>GL_S</code>, <code>GL_T</code>, <code>GL_R</code>, or <code>GL_Q</code>.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of the texture-coordinate generation function.
        /// Must be <code>GL_TEXTURE_GEN_MODE</code>.
        /// </para>
        /// </param>
        /// <param name="param">
        /// <para>
        /// Specifies a single-valued texture generation parameter,
        /// one of <code>GL_OBJECT_LINEAR</code>, <code>GL_EYE_LINEAR</code>, <code>GL_SPHERE_MAP</code>,
        /// <code>GL_NORMAL_MAP</code>, or <code>GL_REFLECTION_MAP</code>.
        /// </para>
        /// </param>
        /// <seealso cref="ActiveTexture"/>
        /// <seealso cref="CopyPixels"/>
        /// <seealso cref="CopyTexImage2D"/>
        /// <seealso cref="CopyTexSubImage1D"/>
        /// <seealso cref="CopyTexSubImage2D"/>
        /// <seealso cref="CopyTexSubImage3D"/>
        /// <seealso cref="TexEnv"/>
        /// <seealso cref="TexImage1D"/>
        /// <seealso cref="TexImage2D"/>
        /// <seealso cref="TexImage3D"/>
        /// <seealso cref="TexParameter"/>
        /// <seealso cref="TexSubImage1D"/>
        /// <seealso cref="TexSubImage2D"/>
        /// <seealso cref="TexSubImage3D"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void TexGend(uint coord, uint pname, double param) {
            GLNative.glTexGend(coord, pname, param);
        }

        /// <summary>
        /// control the generation of texture coordinates
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated when <paramref name="coord"/> or <paramref name="pname"/> is not an
        /// accepted defined value,
        /// or when <paramref name="pname"/> is <code>GL_TEXTURE_GEN_MODE</code> and <paramref name="ps"/> is not an
        /// accepted defined value.
        /// <code>GL_INVALID_ENUM</code> is generated when <paramref name="pname"/> is <code>GL_TEXTURE_GEN_MODE</code>,
        /// <paramref name="ps"/> is <code>GL_SPHERE_MAP</code>,
        /// and <paramref name="coord"/> is either <code>GL_R</code> or <code>GL_Q</code>.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glTexGen"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glTexGenf(GLenum coord, GLenum pname, GLfloat param);</para>
        /// </summary>
        /// <param name="coord">
        /// <para>
        /// Specifies a texture coordinate.
        /// Must be one of <code>GL_S</code>, <code>GL_T</code>, <code>GL_R</code>, or <code>GL_Q</code>.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of the texture-coordinate generation function.
        /// Must be <code>GL_TEXTURE_GEN_MODE</code>.
        /// </para>
        /// </param>
        /// <param name="param">
        /// <para>
        /// Specifies a single-valued texture generation parameter,
        /// one of <code>GL_OBJECT_LINEAR</code>, <code>GL_EYE_LINEAR</code>, <code>GL_SPHERE_MAP</code>,
        /// <code>GL_NORMAL_MAP</code>, or <code>GL_REFLECTION_MAP</code>.
        /// </para>
        /// </param>
        /// <seealso cref="ActiveTexture"/>
        /// <seealso cref="CopyPixels"/>
        /// <seealso cref="CopyTexImage2D"/>
        /// <seealso cref="CopyTexSubImage1D"/>
        /// <seealso cref="CopyTexSubImage2D"/>
        /// <seealso cref="CopyTexSubImage3D"/>
        /// <seealso cref="TexEnv"/>
        /// <seealso cref="TexImage1D"/>
        /// <seealso cref="TexImage2D"/>
        /// <seealso cref="TexImage3D"/>
        /// <seealso cref="TexParameter"/>
        /// <seealso cref="TexSubImage1D"/>
        /// <seealso cref="TexSubImage2D"/>
        /// <seealso cref="TexSubImage3D"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void TexGenf(uint coord, uint pname, float param) {
            GLNative.glTexGenf(coord, pname, param);
        }

        /// <summary>
        /// control the generation of texture coordinates
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated when <paramref name="coord"/> or <paramref name="pname"/> is not an
        /// accepted defined value,
        /// or when <paramref name="pname"/> is <code>GL_TEXTURE_GEN_MODE</code> and <paramref name="ps"/> is not an
        /// accepted defined value.
        /// <code>GL_INVALID_ENUM</code> is generated when <paramref name="pname"/> is <code>GL_TEXTURE_GEN_MODE</code>,
        /// <paramref name="ps"/> is <code>GL_SPHERE_MAP</code>,
        /// and <paramref name="coord"/> is either <code>GL_R</code> or <code>GL_Q</code>.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glTexGen"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glTexGeni(GLenum coord, GLenum pname, GLint param);</para>
        /// </summary>
        /// <param name="coord">
        /// <para>
        /// Specifies a texture coordinate.
        /// Must be one of <code>GL_S</code>, <code>GL_T</code>, <code>GL_R</code>, or <code>GL_Q</code>.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of the texture-coordinate generation function.
        /// Must be <code>GL_TEXTURE_GEN_MODE</code>.
        /// </para>
        /// </param>
        /// <param name="param">
        /// <para>
        /// Specifies a single-valued texture generation parameter,
        /// one of <code>GL_OBJECT_LINEAR</code>, <code>GL_EYE_LINEAR</code>, <code>GL_SPHERE_MAP</code>,
        /// <code>GL_NORMAL_MAP</code>, or <code>GL_REFLECTION_MAP</code>.
        /// </para>
        /// </param>
        /// <seealso cref="ActiveTexture"/>
        /// <seealso cref="CopyPixels"/>
        /// <seealso cref="CopyTexImage2D"/>
        /// <seealso cref="CopyTexSubImage1D"/>
        /// <seealso cref="CopyTexSubImage2D"/>
        /// <seealso cref="CopyTexSubImage3D"/>
        /// <seealso cref="TexEnv"/>
        /// <seealso cref="TexImage1D"/>
        /// <seealso cref="TexImage2D"/>
        /// <seealso cref="TexImage3D"/>
        /// <seealso cref="TexParameter"/>
        /// <seealso cref="TexSubImage1D"/>
        /// <seealso cref="TexSubImage2D"/>
        /// <seealso cref="TexSubImage3D"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void TexGeni(uint coord, uint pname, int param) {
            GLNative.glTexGeni(coord, pname, param);
        }

        /// <summary>
        /// set rasterization mode
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// If an error is generated,
        /// <see cref="glRenderMode"/> returns 0 regardless of the current render mode.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="mode"/> is not one of the three
        /// accepted values.
        /// <code>GL_INVALID_OPERATION</code> is generated if  <see cref="glSelectBuffer"/>  is called
        /// while the render mode is <code>GL_SELECT</code>,
        /// or if <see cref="glRenderMode"/> is called with argument <code>GL_SELECT</code> before
        /// <see cref="glSelectBuffer"/>  is called at least once.
        /// <code>GL_INVALID_OPERATION</code> is generated if  <see cref="glFeedbackBuffer"/>  is called
        /// while the render mode is <code>GL_FEEDBACK</code>,
        /// or if <see cref="glRenderMode"/> is called with argument <code>GL_FEEDBACK</code> before
        /// <see cref="glFeedbackBuffer"/>  is called at least once.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glRenderMode"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>GLint glRenderMode(GLenum mode);</para>
        /// </summary>
        /// <param name="mode">
        /// <para>
        /// Specifies the rasterization mode.
        /// Three values are accepted:
        /// <code>GL_RENDER</code>,
        /// <code>GL_SELECT</code>, and
        /// <code>GL_FEEDBACK</code>.
        /// The initial value is <code>GL_RENDER</code>.
        /// </para>
        /// </param>
        /// <seealso cref="FeedbackBuffer"/>
        /// <seealso cref="InitNames"/>
        /// <seealso cref="LoadName"/>
        /// <seealso cref="PassThrough"/>
        /// <seealso cref="PushName"/>
        /// <seealso cref="SelectBuffer"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static int RenderMode(uint mode) {
            return GLNative.glRenderMode(mode);
        }

        /// <summary>
        /// initialize the name stack
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glInitNames"/>
        /// is executed between the execution of  <see cref="glBegin"/>  and the corresponding execution of
        /// <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glInitNames();</para>
        /// </summary>
        /// <seealso cref="LoadName"/>
        /// <seealso cref="PushName"/>
        /// <seealso cref="RenderMode"/>
        /// <seealso cref="SelectBuffer"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void InitNames() {
            GLNative.glInitNames();
        }

        /// <summary>
        /// load a name onto the name stack
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glLoadName"/> is called while the
        /// name stack is empty.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glLoadName"/> is executed between
        /// the execution of  <see cref="glBegin"/>  and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glLoadName(GLuint name);</para>
        /// </summary>
        /// <param name="name">
        /// Specifies a name that will replace the top value on the name stack.
        /// </param>
        /// <seealso cref="InitNames"/>
        /// <seealso cref="PushName"/>
        /// <seealso cref="RenderMode"/>
        /// <seealso cref="SelectBuffer"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void LoadName(uint name) {
            GLNative.glLoadName(name);
        }

        /// <summary>
        /// place a marker in the feedback buffer
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <see cref="glPassThrough"/> is ignored if the GL is not in feedback mode.
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glPassThrough"/> is executed between
        /// the execution of  <see cref="glBegin"/>  and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glPassThrough(GLfloat token);</para>
        /// </summary>
        /// <param name="token">
        /// <para>
        /// Specifies a marker value to be placed in the feedback buffer
        /// following a <code>GL_PASS_THROUGH_TOKEN</code>.
        /// </para>
        /// </param>
        /// <seealso cref="FeedbackBuffer"/>
        /// <seealso cref="RenderMode"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void PassThrough(float token) {
            GLNative.glPassThrough(token);
        }

        /// <summary>
        /// push and pop the name stack
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Errors: 
        /// <para>
        /// <code>GL_STACK_OVERFLOW</code> is generated if <see cref="glPushName"/> is called while the
        /// name stack is full.
        /// <code>GL_STACK_UNDERFLOW</code> is generated if  <see cref="glPopName"/>  is called while the
        /// name stack is empty.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glPushName"/> or  <see cref="glPopName"/> 
        /// is executed between a call to  <see cref="glBegin"/>  and the corresponding call to
        /// <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glPopName();</para>
        /// </summary>
        /// <seealso cref="InitNames"/>
        /// <seealso cref="LoadName"/>
        /// <seealso cref="RenderMode"/>
        /// <seealso cref="SelectBuffer"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void PopName() {
            GLNative.glPopName();
        }

        /// <summary>
        /// push and pop the name stack
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Errors: 
        /// <para>
        /// <code>GL_STACK_OVERFLOW</code> is generated if <see cref="glPushName"/> is called while the
        /// name stack is full.
        /// <code>GL_STACK_UNDERFLOW</code> is generated if  <see cref="glPopName"/>  is called while the
        /// name stack is empty.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glPushName"/> or  <see cref="glPopName"/> 
        /// is executed between a call to  <see cref="glBegin"/>  and the corresponding call to
        /// <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glPushName(GLuint name);</para>
        /// </summary>
        /// <param name="name">
        /// Specifies a name that will be pushed onto the name stack.
        /// </param>
        /// <seealso cref="InitNames"/>
        /// <seealso cref="LoadName"/>
        /// <seealso cref="RenderMode"/>
        /// <seealso cref="SelectBuffer"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void PushName(uint name) {
            GLNative.glPushName(name);
        }

        /// <summary>
        /// specify clear values for the accumulation buffer
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glClearAccum"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glClearAccum(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha);</para>
        /// </summary>
        /// <param name="red">
        /// <para>
        /// Specify the red, green, blue, and alpha values used when the
        /// accumulation buffer is cleared.
        /// The initial values are all 0.
        /// </para>
        /// </param>
        /// <param name="green">
        /// <para>
        /// Specify the red, green, blue, and alpha values used when the
        /// accumulation buffer is cleared.
        /// The initial values are all 0.
        /// </para>
        /// </param>
        /// <param name="blue">
        /// <para>
        /// Specify the red, green, blue, and alpha values used when the
        /// accumulation buffer is cleared.
        /// The initial values are all 0.
        /// </para>
        /// </param>
        /// <param name="alpha">
        /// <para>
        /// Specify the red, green, blue, and alpha values used when the
        /// accumulation buffer is cleared.
        /// The initial values are all 0.
        /// </para>
        /// </param>
        /// <seealso cref="Accum"/>
        /// <seealso cref="Clear"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void ClearAccum(float red, float green, float blue, float alpha) {
            GLNative.glClearAccum(red, green, blue, alpha);
        }

        /// <summary>
        /// specify the clear value for the color index buffers
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glClearIndex"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glClearIndex(GLfloat c);</para>
        /// </summary>
        /// <param name="c">
        /// <para>
        /// Specifies the index used when the color index buffers are cleared.
        /// The initial value is 0.
        /// </para>
        /// </param>
        /// <seealso cref="Clear"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void ClearIndex(float c) {
            GLNative.glClearIndex(c);
        }

        /// <summary>
        /// control the writing of individual bits in the color index buffers
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glIndexMask"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glIndexMask(GLuint mask);</para>
        /// </summary>
        /// <param name="mask">
        /// <para>
        /// Specifies a bit mask to enable and disable the writing of individual bits
        /// in the color index buffers.
        /// Initially, the mask is all 1's.
        /// </para>
        /// </param>
        /// <seealso cref="ColorMask"/>
        /// <seealso cref="DepthMask"/>
        /// <seealso cref="DrawBuffer"/>
        /// <seealso cref="Index"/>
        /// <seealso cref="IndexPointer"/>
        /// <seealso cref="StencilMask"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void IndexMask(uint mask) {
            GLNative.glIndexMask(mask);
        }

        /// <summary>
        /// operate on the accumulation buffer
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// Only pixels within the current scissor box are updated by a
        /// <see cref="glAccum"/> operation.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="op"/> is not an accepted value.
        /// <code>GL_INVALID_OPERATION</code> is generated if there is no accumulation buffer.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glAccum"/>
        /// is executed between the execution of
        /// <see cref="glBegin"/>  and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glAccum(GLenum op, GLfloat value);</para>
        /// </summary>
        /// <param name="op">
        /// <para>
        /// Specifies the accumulation buffer operation.
        /// Symbolic constants
        /// <code>GL_ACCUM</code>,
        /// <code>GL_LOAD</code>,
        /// <code>GL_ADD</code>,
        /// <code>GL_MULT</code>,
        /// and
        /// <code>GL_RETURN</code> are accepted.
        /// </para>
        /// </param>
        /// <param name="value">
        /// <para>
        /// Specifies a floating-point value used in the accumulation buffer operation.
        /// <paramref name="op"/> determines how <paramref name="value"/> is used.
        /// </para>
        /// </param>
        /// <seealso cref="Clear"/>
        /// <seealso cref="ClearAccum"/>
        /// <seealso cref="CopyPixels"/>
        /// <seealso cref="DrawBuffer"/>
        /// <seealso cref="Get"/>
        /// <seealso cref="ReadBuffer"/>
        /// <seealso cref="ReadPixels"/>
        /// <seealso cref="Scissor"/>
        /// <seealso cref="StencilOp"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void Accum(uint op, float value) {
            GLNative.glAccum(op, value);
        }

        /// <summary>
        /// push and pop the server attribute stack
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// Not all values for GL state can be saved on the attribute stack.
        /// For example,
        /// render mode state,
        /// and select and feedback state cannot be saved.
        /// Client state must be saved with
        /// <see cref="glPushClientAttrib"/> .
        /// The depth of the attribute stack depends on the implementation,
        /// but it must be at least 16.
        /// For OpenGL versions 1.3 and greater, or when the <code>ARB_multitexture</code> extension is supported, pushing and
        /// popping texture state applies to all supported texture units.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_STACK_OVERFLOW</code> is generated if <see cref="glPushAttrib"/> is called while
        /// the attribute stack is full.
        /// <code>GL_STACK_UNDERFLOW</code> is generated if  <see cref="glPopAttrib"/>  is called while
        /// the attribute stack is empty.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glPushAttrib"/> or  <see cref="glPopAttrib"/> 
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glPopAttrib();</para>
        /// </summary>
        /// <seealso cref="Get"/>
        /// <seealso cref="GetClipPlane"/>
        /// <seealso cref="GetError"/>
        /// <seealso cref="GetLight"/>
        /// <seealso cref="GetMap"/>
        /// <seealso cref="GetMaterial"/>
        /// <seealso cref="GetPixelMap"/>
        /// <seealso cref="GetPolygonStipple"/>
        /// <seealso cref="GetString"/>
        /// <seealso cref="GetTexEnv"/>
        /// <seealso cref="GetTexGen"/>
        /// <seealso cref="GetTexImage"/>
        /// <seealso cref="GetTexLevelParameter"/>
        /// <seealso cref="GetTexParameter"/>
        /// <seealso cref="IsEnabled"/>
        /// <seealso cref="PushClientAttrib"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void PopAttrib() {
            GLNative.glPopAttrib();
        }

        /// <summary>
        /// push and pop the server attribute stack
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// Not all values for GL state can be saved on the attribute stack.
        /// For example,
        /// render mode state,
        /// and select and feedback state cannot be saved.
        /// Client state must be saved with
        /// <see cref="glPushClientAttrib"/> .
        /// The depth of the attribute stack depends on the implementation,
        /// but it must be at least 16.
        /// For OpenGL versions 1.3 and greater, or when the <code>ARB_multitexture</code> extension is supported, pushing and
        /// popping texture state applies to all supported texture units.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_STACK_OVERFLOW</code> is generated if <see cref="glPushAttrib"/> is called while
        /// the attribute stack is full.
        /// <code>GL_STACK_UNDERFLOW</code> is generated if  <see cref="glPopAttrib"/>  is called while
        /// the attribute stack is empty.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glPushAttrib"/> or  <see cref="glPopAttrib"/> 
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glPushAttrib(GLbitfield mask);</para>
        /// </summary>
        /// <param name="mask">
        /// <para>
        /// Specifies a mask that indicates which attributes to save. Values for
        /// <paramref name="mask"/> are listed below.
        /// </para>
        /// </param>
        /// <seealso cref="Get"/>
        /// <seealso cref="GetClipPlane"/>
        /// <seealso cref="GetError"/>
        /// <seealso cref="GetLight"/>
        /// <seealso cref="GetMap"/>
        /// <seealso cref="GetMaterial"/>
        /// <seealso cref="GetPixelMap"/>
        /// <seealso cref="GetPolygonStipple"/>
        /// <seealso cref="GetString"/>
        /// <seealso cref="GetTexEnv"/>
        /// <seealso cref="GetTexGen"/>
        /// <seealso cref="GetTexImage"/>
        /// <seealso cref="GetTexLevelParameter"/>
        /// <seealso cref="GetTexParameter"/>
        /// <seealso cref="IsEnabled"/>
        /// <seealso cref="PushClientAttrib"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void PushAttrib(uint mask) {
            GLNative.glPushAttrib(mask);
        }

        /// <summary>
        /// define a one- or two-dimensional mesh
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if either <paramref name="un"/> or <paramref name="vn"/> is not
        /// positive.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glMapGrid"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glMapGrid1d(GLint un, GLdouble u1, GLdouble u2);</para>
        /// </summary>
        /// <param name="un">
        /// <para>
        /// Specifies the number of partitions in the grid range interval
        /// [<paramref name="u1"/>, <paramref name="u2"/>].
        /// Must be positive.
        /// </para>
        /// </param>
        /// <param name="u1">
        /// <para>
        /// Specify the mappings for integer grid domain values 
        /// i 
        /// = 
        /// 0 
        /// and 
        /// i 
        /// = 
        /// un 
        /// .
        /// </para>
        /// </param>
        /// <param name="u2">
        /// <para>
        /// Specify the mappings for integer grid domain values 
        /// i 
        /// = 
        /// 0 
        /// and 
        /// i 
        /// = 
        /// un 
        /// .
        /// </para>
        /// </param>
        /// <seealso cref="EvalCoord"/>
        /// <seealso cref="EvalMesh"/>
        /// <seealso cref="EvalPoint"/>
        /// <seealso cref="Map1"/>
        /// <seealso cref="Map2"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void MapGrid1d(int un, double u1, double u2) {
            GLNative.glMapGrid1d(un, u1, u2);
        }

        /// <summary>
        /// define a one- or two-dimensional mesh
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if either <paramref name="un"/> or <paramref name="vn"/> is not
        /// positive.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glMapGrid"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glMapGrid1f(GLint un, GLfloat u1, GLfloat u2);</para>
        /// </summary>
        /// <param name="un">
        /// <para>
        /// Specifies the number of partitions in the grid range interval
        /// [<paramref name="u1"/>, <paramref name="u2"/>].
        /// Must be positive.
        /// </para>
        /// </param>
        /// <param name="u1">
        /// <para>
        /// Specify the mappings for integer grid domain values 
        /// i 
        /// = 
        /// 0 
        /// and 
        /// i 
        /// = 
        /// un 
        /// .
        /// </para>
        /// </param>
        /// <param name="u2">
        /// <para>
        /// Specify the mappings for integer grid domain values 
        /// i 
        /// = 
        /// 0 
        /// and 
        /// i 
        /// = 
        /// un 
        /// .
        /// </para>
        /// </param>
        /// <seealso cref="EvalCoord"/>
        /// <seealso cref="EvalMesh"/>
        /// <seealso cref="EvalPoint"/>
        /// <seealso cref="Map1"/>
        /// <seealso cref="Map2"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void MapGrid1f(int un, float u1, float u2) {
            GLNative.glMapGrid1f(un, u1, u2);
        }

        /// <summary>
        /// define a one- or two-dimensional mesh
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if either <paramref name="un"/> or <paramref name="vn"/> is not
        /// positive.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glMapGrid"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glMapGrid2d(GLint un, GLdouble u1, GLdouble u2, GLint vn, GLdouble v1, GLdouble v2);</para>
        /// </summary>
        /// <param name="un">
        /// <para>
        /// Specifies the number of partitions in the grid range interval
        /// [<paramref name="u1"/>, <paramref name="u2"/>].
        /// Must be positive.
        /// </para>
        /// </param>
        /// <param name="u1">
        /// <para>
        /// Specify the mappings for integer grid domain values 
        /// i 
        /// = 
        /// 0 
        /// and 
        /// i 
        /// = 
        /// un 
        /// .
        /// </para>
        /// </param>
        /// <param name="u2">
        /// <para>
        /// Specify the mappings for integer grid domain values 
        /// i 
        /// = 
        /// 0 
        /// and 
        /// i 
        /// = 
        /// un 
        /// .
        /// </para>
        /// </param>
        /// <param name="vn">
        /// <para>
        /// Specifies the number of partitions in the grid range interval
        /// [<paramref name="v1"/>, <paramref name="v2"/>]
        /// (<see cref="glMapGrid2"/> only).
        /// </para>
        /// </param>
        /// <param name="v1">
        /// <para>
        /// Specify the mappings for integer grid domain values 
        /// j 
        /// = 
        /// 0 
        /// and 
        /// j 
        /// = 
        /// vn 
        /// (<see cref="glMapGrid2"/> only).
        /// </para>
        /// </param>
        /// <param name="v2">
        /// <para>
        /// Specify the mappings for integer grid domain values 
        /// j 
        /// = 
        /// 0 
        /// and 
        /// j 
        /// = 
        /// vn 
        /// (<see cref="glMapGrid2"/> only).
        /// </para>
        /// </param>
        /// <seealso cref="EvalCoord"/>
        /// <seealso cref="EvalMesh"/>
        /// <seealso cref="EvalPoint"/>
        /// <seealso cref="Map1"/>
        /// <seealso cref="Map2"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void MapGrid2d(int un, double u1, double u2, int vn, double v1, double v2) {
            GLNative.glMapGrid2d(un, u1, u2, vn, v1, v2);
        }

        /// <summary>
        /// define a one- or two-dimensional mesh
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if either <paramref name="un"/> or <paramref name="vn"/> is not
        /// positive.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glMapGrid"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glMapGrid2f(GLint un, GLfloat u1, GLfloat u2, GLint vn, GLfloat v1, GLfloat v2);</para>
        /// </summary>
        /// <param name="un">
        /// <para>
        /// Specifies the number of partitions in the grid range interval
        /// [<paramref name="u1"/>, <paramref name="u2"/>].
        /// Must be positive.
        /// </para>
        /// </param>
        /// <param name="u1">
        /// <para>
        /// Specify the mappings for integer grid domain values 
        /// i 
        /// = 
        /// 0 
        /// and 
        /// i 
        /// = 
        /// un 
        /// .
        /// </para>
        /// </param>
        /// <param name="u2">
        /// <para>
        /// Specify the mappings for integer grid domain values 
        /// i 
        /// = 
        /// 0 
        /// and 
        /// i 
        /// = 
        /// un 
        /// .
        /// </para>
        /// </param>
        /// <param name="vn">
        /// <para>
        /// Specifies the number of partitions in the grid range interval
        /// [<paramref name="v1"/>, <paramref name="v2"/>]
        /// (<see cref="glMapGrid2"/> only).
        /// </para>
        /// </param>
        /// <param name="v1">
        /// <para>
        /// Specify the mappings for integer grid domain values 
        /// j 
        /// = 
        /// 0 
        /// and 
        /// j 
        /// = 
        /// vn 
        /// (<see cref="glMapGrid2"/> only).
        /// </para>
        /// </param>
        /// <param name="v2">
        /// <para>
        /// Specify the mappings for integer grid domain values 
        /// j 
        /// = 
        /// 0 
        /// and 
        /// j 
        /// = 
        /// vn 
        /// (<see cref="glMapGrid2"/> only).
        /// </para>
        /// </param>
        /// <seealso cref="EvalCoord"/>
        /// <seealso cref="EvalMesh"/>
        /// <seealso cref="EvalPoint"/>
        /// <seealso cref="Map1"/>
        /// <seealso cref="Map2"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void MapGrid2f(int un, float u1, float u2, int vn, float v1, float v2) {
            GLNative.glMapGrid2f(un, u1, u2, vn, v1, v2);
        }

        /// <summary>
        /// evaluate enabled one- and two-dimensional maps
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glEvalCoord1d(GLdouble u);</para>
        /// </summary>
        /// <param name="u">
        /// <para>
        /// Specifies a value that is the domain coordinate 
        /// u   
        /// to the basis function
        /// defined in a previous  <see cref="glMap1"/>  or  <see cref="glMap2"/>  command.
        /// </para>
        /// </param>
        /// <seealso cref="Begin"/>
        /// <seealso cref="Color"/>
        /// <seealso cref="Enable"/>
        /// <seealso cref="EvalMesh"/>
        /// <seealso cref="EvalPoint"/>
        /// <seealso cref="Index"/>
        /// <seealso cref="Map1"/>
        /// <seealso cref="Map2"/>
        /// <seealso cref="MapGrid"/>
        /// <seealso cref="Normal"/>
        /// <seealso cref="TexCoord"/>
        /// <seealso cref="Vertex"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void EvalCoord1d(double u) {
            GLNative.glEvalCoord1d(u);
        }

        /// <summary>
        /// evaluate enabled one- and two-dimensional maps
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glEvalCoord1f(GLfloat u);</para>
        /// </summary>
        /// <param name="u">
        /// <para>
        /// Specifies a value that is the domain coordinate 
        /// u   
        /// to the basis function
        /// defined in a previous  <see cref="glMap1"/>  or  <see cref="glMap2"/>  command.
        /// </para>
        /// </param>
        /// <seealso cref="Begin"/>
        /// <seealso cref="Color"/>
        /// <seealso cref="Enable"/>
        /// <seealso cref="EvalMesh"/>
        /// <seealso cref="EvalPoint"/>
        /// <seealso cref="Index"/>
        /// <seealso cref="Map1"/>
        /// <seealso cref="Map2"/>
        /// <seealso cref="MapGrid"/>
        /// <seealso cref="Normal"/>
        /// <seealso cref="TexCoord"/>
        /// <seealso cref="Vertex"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void EvalCoord1f(float u) {
            GLNative.glEvalCoord1f(u);
        }

        /// <summary>
        /// evaluate enabled one- and two-dimensional maps
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glEvalCoord2d(GLdouble u, GLdouble v);</para>
        /// </summary>
        /// <param name="u">
        /// <para>
        /// Specifies a value that is the domain coordinate 
        /// u   
        /// to the basis function
        /// defined in a previous  <see cref="glMap1"/>  or  <see cref="glMap2"/>  command.
        /// </para>
        /// </param>
        /// <param name="v">
        /// <para>
        /// Specifies a value that is the domain coordinate 
        /// v   
        /// to the basis function
        /// defined in a previous  <see cref="glMap2"/>  command.
        /// This argument is not present in a <see cref="glEvalCoord1"/> command.
        /// </para>
        /// </param>
        /// <seealso cref="Begin"/>
        /// <seealso cref="Color"/>
        /// <seealso cref="Enable"/>
        /// <seealso cref="EvalMesh"/>
        /// <seealso cref="EvalPoint"/>
        /// <seealso cref="Index"/>
        /// <seealso cref="Map1"/>
        /// <seealso cref="Map2"/>
        /// <seealso cref="MapGrid"/>
        /// <seealso cref="Normal"/>
        /// <seealso cref="TexCoord"/>
        /// <seealso cref="Vertex"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void EvalCoord2d(double u, double v) {
            GLNative.glEvalCoord2d(u, v);
        }

        /// <summary>
        /// evaluate enabled one- and two-dimensional maps
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glEvalCoord2f(GLfloat u, GLfloat v);</para>
        /// </summary>
        /// <param name="u">
        /// <para>
        /// Specifies a value that is the domain coordinate 
        /// u   
        /// to the basis function
        /// defined in a previous  <see cref="glMap1"/>  or  <see cref="glMap2"/>  command.
        /// </para>
        /// </param>
        /// <param name="v">
        /// <para>
        /// Specifies a value that is the domain coordinate 
        /// v   
        /// to the basis function
        /// defined in a previous  <see cref="glMap2"/>  command.
        /// This argument is not present in a <see cref="glEvalCoord1"/> command.
        /// </para>
        /// </param>
        /// <seealso cref="Begin"/>
        /// <seealso cref="Color"/>
        /// <seealso cref="Enable"/>
        /// <seealso cref="EvalMesh"/>
        /// <seealso cref="EvalPoint"/>
        /// <seealso cref="Index"/>
        /// <seealso cref="Map1"/>
        /// <seealso cref="Map2"/>
        /// <seealso cref="MapGrid"/>
        /// <seealso cref="Normal"/>
        /// <seealso cref="TexCoord"/>
        /// <seealso cref="Vertex"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void EvalCoord2f(float u, float v) {
            GLNative.glEvalCoord2f(u, v);
        }

        /// <summary>
        /// compute a one- or two-dimensional grid of points or lines
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="mode"/> is not an accepted value.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glEvalMesh"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glEvalMesh1(GLenum mode, GLint i1, GLint i2);</para>
        /// </summary>
        /// <param name="mode">
        /// <para>
        /// In <see cref="glEvalMesh1"/>, specifies whether to compute a one-dimensional mesh of points or lines.
        /// Symbolic constants
        /// <code>GL_POINT</code> and
        /// <code>GL_LINE</code> are accepted.
        /// </para>
        /// </param>
        /// <param name="i1">
        /// <para>
        /// Specify the first and last integer values for grid domain variable 
        /// i   .
        /// </para>
        /// </param>
        /// <param name="i2">
        /// <para>
        /// Specify the first and last integer values for grid domain variable 
        /// i   .
        /// </para>
        /// </param>
        /// <seealso cref="Begin"/>
        /// <seealso cref="EvalCoord"/>
        /// <seealso cref="EvalPoint"/>
        /// <seealso cref="Map1"/>
        /// <seealso cref="Map2"/>
        /// <seealso cref="MapGrid"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void EvalMesh1(uint mode, int i1, int i2) {
            GLNative.glEvalMesh1(mode, i1, i2);
        }

        /// <summary>
        /// generate and evaluate a single point in a mesh
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glEvalPoint1(GLint i);</para>
        /// </summary>
        /// <param name="i">
        /// <para>
        /// Specifies the integer value for grid domain variable 
        /// i   .
        /// </para>
        /// </param>
        /// <seealso cref="EvalCoord"/>
        /// <seealso cref="EvalMesh"/>
        /// <seealso cref="Map1"/>
        /// <seealso cref="Map2"/>
        /// <seealso cref="MapGrid"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void EvalPoint1(int i) {
            GLNative.glEvalPoint1(i);
        }

        /// <summary>
        /// compute a one- or two-dimensional grid of points or lines
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="mode"/> is not an accepted value.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glEvalMesh"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glEvalMesh2(GLenum mode, GLint i1, GLint i2, GLint j1, GLint j2);</para>
        /// </summary>
        /// <param name="mode">
        /// <para>
        /// In <see cref="glEvalMesh2"/>, specifies whether to compute a two-dimensional mesh of points, lines,
        /// or polygons.
        /// Symbolic constants
        /// <code>GL_POINT</code>,
        /// <code>GL_LINE</code>, and
        /// <code>GL_FILL</code> are accepted.
        /// </para>
        /// </param>
        /// <param name="i1">
        /// <para>
        /// Specify the first and last integer values for grid domain variable 
        /// i   .
        /// </para>
        /// </param>
        /// <param name="i2">
        /// <para>
        /// Specify the first and last integer values for grid domain variable 
        /// i   .
        /// </para>
        /// </param>
        /// <param name="j1">
        /// <para>
        /// Specify the first and last integer values for grid domain variable 
        /// j   .
        /// </para>
        /// </param>
        /// <param name="j2">
        /// <para>
        /// Specify the first and last integer values for grid domain variable 
        /// j   .
        /// </para>
        /// </param>
        /// <seealso cref="Begin"/>
        /// <seealso cref="EvalCoord"/>
        /// <seealso cref="EvalPoint"/>
        /// <seealso cref="Map1"/>
        /// <seealso cref="Map2"/>
        /// <seealso cref="MapGrid"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void EvalMesh2(uint mode, int i1, int i2, int j1, int j2) {
            GLNative.glEvalMesh2(mode, i1, i2, j1, j2);
        }

        /// <summary>
        /// generate and evaluate a single point in a mesh
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glEvalPoint2(GLint i, GLint j);</para>
        /// </summary>
        /// <param name="i">
        /// <para>
        /// Specifies the integer value for grid domain variable 
        /// i   .
        /// </para>
        /// </param>
        /// <param name="j">
        /// <para>
        /// Specifies the integer value for grid domain variable 
        /// j   
        /// (<see cref="glEvalPoint2"/> only).
        /// </para>
        /// </param>
        /// <seealso cref="EvalCoord"/>
        /// <seealso cref="EvalMesh"/>
        /// <seealso cref="Map1"/>
        /// <seealso cref="Map2"/>
        /// <seealso cref="MapGrid"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void EvalPoint2(int i, int j) {
            GLNative.glEvalPoint2(i, j);
        }

        /// <summary>
        /// specify the alpha test function
        /// <para>Require:</para> <para>GL_VERSION_1_0, GL_VERSION_ES_CM_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// Alpha testing is performed only in RGBA mode.
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="func"/> is not an accepted value.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glAlphaFunc"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glAlphaFunc(GLenum func, GLclampf ref);</para>
        /// </summary>
        /// <param name="func">
        /// <para>
        /// Specifies the alpha comparison function.
        /// Symbolic constants
        /// <code>GL_NEVER</code>,
        /// <code>GL_LESS</code>,
        /// <code>GL_EQUAL</code>,
        /// <code>GL_LEQUAL</code>,
        /// <code>GL_GREATER</code>,
        /// <code>GL_NOTEQUAL</code>,
        /// <code>GL_GEQUAL</code>, and
        /// <code>GL_ALWAYS</code> are accepted. The initial value is <code>GL_ALWAYS</code>.
        /// </para>
        /// </param>
        /// <param name="r">
        /// <para>
        /// Specifies the reference value that incoming alpha values are compared to.
        /// This value is clamped to the range 
        /// 0 
        /// 1 
        /// ,
        /// where 0 represents the lowest possible alpha value
        /// and 1 the highest possible value.
        /// The initial reference value is 0.
        /// </para>
        /// </param>
        /// <seealso cref="BlendFunc"/>
        /// <seealso cref="Clear"/>
        /// <seealso cref="DepthFunc"/>
        /// <seealso cref="Enable"/>
        /// <seealso cref="StencilFunc"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void AlphaFunc(uint func, float r) {
            GLNative.glAlphaFunc(func, r);
        }

        /// <summary>
        /// specify the pixel zoom factors
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glPixelZoom"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glPixelZoom(GLfloat xfactor, GLfloat yfactor);</para>
        /// </summary>
        /// <param name="xfactor">
        /// <para>
        /// Specify the 
        /// x   
        /// and 
        /// y   
        /// zoom factors for pixel write operations.
        /// </para>
        /// </param>
        /// <param name="yfactor">
        /// <para>
        /// Specify the 
        /// x   
        /// and 
        /// y   
        /// zoom factors for pixel write operations.
        /// </para>
        /// </param>
        /// <seealso cref="CopyPixels"/>
        /// <seealso cref="DrawPixels"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void PixelZoom(float xfactor, float yfactor) {
            GLNative.glPixelZoom(xfactor, yfactor);
        }

        /// <summary>
        /// set pixel transfer modes
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// If a
        /// <see cref="glColorTable"/> ,
        /// <see cref="glColorSubTable"/> ,
        /// <see cref="glConvolutionFilter1D"/> ,
        /// <see cref="glConvolutionFilter2D"/> ,
        /// <see cref="glCopyPixels"/> ,
        /// <see cref="glCopyTexImage1D"/> ,
        /// <see cref="glCopyTexImage2D"/> ,
        /// <see cref="glCopyTexSubImage1D"/> ,
        /// <see cref="glCopyTexSubImage2D"/> ,
        /// <see cref="glCopyTexSubImage3D"/> ,
        /// <see cref="glDrawPixels"/> ,
        /// <see cref="glReadPixels"/> ,
        /// <see cref="glSeparableFilter2D"/> ,
        /// <see cref="glTexImage1D"/> ,
        /// <see cref="glTexImage2D"/> ,
        /// <see cref="glTexImage3D"/> ,
        /// <see cref="glTexSubImage1D"/> ,
        /// <see cref="glTexSubImage2D"/> , or
        /// <see cref="glTexSubImage3D"/> 
        /// command is placed in a display list
        /// (see  <see cref="glNewList"/>  and  <see cref="glCallList"/> ),
        /// the pixel transfer mode settings in effect when the display list is
        /// executed 
        /// are the ones that are used.
        /// They may be different from the settings when the command was compiled
        /// into the display list.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="pname"/> is not an accepted value.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glPixelTransfer"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glPixelTransferf(GLenum pname, GLfloat param);</para>
        /// </summary>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of the pixel transfer parameter to be set.
        /// Must be one of the following:
        /// <code>GL_MAP_COLOR</code>,
        /// <code>GL_MAP_STENCIL</code>,
        /// <code>GL_INDEX_SHIFT</code>,
        /// <code>GL_INDEX_OFFSET</code>,
        /// <code>GL_RED_SCALE</code>,
        /// <code>GL_RED_BIAS</code>,
        /// <code>GL_GREEN_SCALE</code>,
        /// <code>GL_GREEN_BIAS</code>,
        /// <code>GL_BLUE_SCALE</code>,
        /// <code>GL_BLUE_BIAS</code>,
        /// <code>GL_ALPHA_SCALE</code>,
        /// <code>GL_ALPHA_BIAS</code>,
        /// <code>GL_DEPTH_SCALE</code>, or
        /// <code>GL_DEPTH_BIAS</code>.
        /// </para>
        /// <para>
        /// Additionally, if the <code>ARB_imaging</code> extension is supported, the
        /// following symbolic names are accepted:
        /// <code>GL_POST_COLOR_MATRIX_RED_SCALE</code>,
        /// <code>GL_POST_COLOR_MATRIX_GREEN_SCALE</code>,
        /// <code>GL_POST_COLOR_MATRIX_BLUE_SCALE</code>,
        /// <code>GL_POST_COLOR_MATRIX_ALPHA_SCALE</code>,
        /// <code>GL_POST_COLOR_MATRIX_RED_BIAS</code>,
        /// <code>GL_POST_COLOR_MATRIX_GREEN_BIAS</code>,
        /// <code>GL_POST_COLOR_MATRIX_BLUE_BIAS</code>,
        /// <code>GL_POST_COLOR_MATRIX_ALPHA_BIAS</code>,
        /// <code>GL_POST_CONVOLUTION_RED_SCALE</code>,
        /// <code>GL_POST_CONVOLUTION_GREEN_SCALE</code>,
        /// <code>GL_POST_CONVOLUTION_BLUE_SCALE</code>,
        /// <code>GL_POST_CONVOLUTION_ALPHA_SCALE</code>,
        /// <code>GL_POST_CONVOLUTION_RED_BIAS</code>,
        /// <code>GL_POST_CONVOLUTION_GREEN_BIAS</code>,
        /// <code>GL_POST_CONVOLUTION_BLUE_BIAS</code>, and
        /// <code>GL_POST_CONVOLUTION_ALPHA_BIAS</code>.
        /// </para>
        /// </param>
        /// <param name="param">
        /// Specifies the value that <paramref name="pname"/> is set to.
        /// </param>
        /// <seealso cref="CallList"/>
        /// <seealso cref="ColorTable"/>
        /// <seealso cref="ColorSubTable"/>
        /// <seealso cref="ConvolutionFilter1D"/>
        /// <seealso cref="ConvolutionFilter2D"/>
        /// <seealso cref="CopyPixels"/>
        /// <seealso cref="CopyTexImage1D"/>
        /// <seealso cref="CopyTexImage2D"/>
        /// <seealso cref="CopyTexSubImage1D"/>
        /// <seealso cref="CopyTexSubImage2D"/>
        /// <seealso cref="CopyTexSubImage3D"/>
        /// <seealso cref="DrawPixels"/>
        /// <seealso cref="NewList"/>
        /// <seealso cref="PixelMap"/>
        /// <seealso cref="PixelStore"/>
        /// <seealso cref="PixelZoom"/>
        /// <seealso cref="ReadPixels"/>
        /// <seealso cref="TexImage1D"/>
        /// <seealso cref="TexImage2D"/>
        /// <seealso cref="TexImage3D"/>
        /// <seealso cref="TexSubImage1D"/>
        /// <seealso cref="TexSubImage2D"/>
        /// <seealso cref="TexSubImage3D"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void PixelTransferf(uint pname, float param) {
            GLNative.glPixelTransferf(pname, param);
        }

        /// <summary>
        /// set pixel transfer modes
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// If a
        /// <see cref="glColorTable"/> ,
        /// <see cref="glColorSubTable"/> ,
        /// <see cref="glConvolutionFilter1D"/> ,
        /// <see cref="glConvolutionFilter2D"/> ,
        /// <see cref="glCopyPixels"/> ,
        /// <see cref="glCopyTexImage1D"/> ,
        /// <see cref="glCopyTexImage2D"/> ,
        /// <see cref="glCopyTexSubImage1D"/> ,
        /// <see cref="glCopyTexSubImage2D"/> ,
        /// <see cref="glCopyTexSubImage3D"/> ,
        /// <see cref="glDrawPixels"/> ,
        /// <see cref="glReadPixels"/> ,
        /// <see cref="glSeparableFilter2D"/> ,
        /// <see cref="glTexImage1D"/> ,
        /// <see cref="glTexImage2D"/> ,
        /// <see cref="glTexImage3D"/> ,
        /// <see cref="glTexSubImage1D"/> ,
        /// <see cref="glTexSubImage2D"/> , or
        /// <see cref="glTexSubImage3D"/> 
        /// command is placed in a display list
        /// (see  <see cref="glNewList"/>  and  <see cref="glCallList"/> ),
        /// the pixel transfer mode settings in effect when the display list is
        /// executed 
        /// are the ones that are used.
        /// They may be different from the settings when the command was compiled
        /// into the display list.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="pname"/> is not an accepted value.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glPixelTransfer"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glPixelTransferi(GLenum pname, GLint param);</para>
        /// </summary>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of the pixel transfer parameter to be set.
        /// Must be one of the following:
        /// <code>GL_MAP_COLOR</code>,
        /// <code>GL_MAP_STENCIL</code>,
        /// <code>GL_INDEX_SHIFT</code>,
        /// <code>GL_INDEX_OFFSET</code>,
        /// <code>GL_RED_SCALE</code>,
        /// <code>GL_RED_BIAS</code>,
        /// <code>GL_GREEN_SCALE</code>,
        /// <code>GL_GREEN_BIAS</code>,
        /// <code>GL_BLUE_SCALE</code>,
        /// <code>GL_BLUE_BIAS</code>,
        /// <code>GL_ALPHA_SCALE</code>,
        /// <code>GL_ALPHA_BIAS</code>,
        /// <code>GL_DEPTH_SCALE</code>, or
        /// <code>GL_DEPTH_BIAS</code>.
        /// </para>
        /// <para>
        /// Additionally, if the <code>ARB_imaging</code> extension is supported, the
        /// following symbolic names are accepted:
        /// <code>GL_POST_COLOR_MATRIX_RED_SCALE</code>,
        /// <code>GL_POST_COLOR_MATRIX_GREEN_SCALE</code>,
        /// <code>GL_POST_COLOR_MATRIX_BLUE_SCALE</code>,
        /// <code>GL_POST_COLOR_MATRIX_ALPHA_SCALE</code>,
        /// <code>GL_POST_COLOR_MATRIX_RED_BIAS</code>,
        /// <code>GL_POST_COLOR_MATRIX_GREEN_BIAS</code>,
        /// <code>GL_POST_COLOR_MATRIX_BLUE_BIAS</code>,
        /// <code>GL_POST_COLOR_MATRIX_ALPHA_BIAS</code>,
        /// <code>GL_POST_CONVOLUTION_RED_SCALE</code>,
        /// <code>GL_POST_CONVOLUTION_GREEN_SCALE</code>,
        /// <code>GL_POST_CONVOLUTION_BLUE_SCALE</code>,
        /// <code>GL_POST_CONVOLUTION_ALPHA_SCALE</code>,
        /// <code>GL_POST_CONVOLUTION_RED_BIAS</code>,
        /// <code>GL_POST_CONVOLUTION_GREEN_BIAS</code>,
        /// <code>GL_POST_CONVOLUTION_BLUE_BIAS</code>, and
        /// <code>GL_POST_CONVOLUTION_ALPHA_BIAS</code>.
        /// </para>
        /// </param>
        /// <param name="param">
        /// Specifies the value that <paramref name="pname"/> is set to.
        /// </param>
        /// <seealso cref="CallList"/>
        /// <seealso cref="ColorTable"/>
        /// <seealso cref="ColorSubTable"/>
        /// <seealso cref="ConvolutionFilter1D"/>
        /// <seealso cref="ConvolutionFilter2D"/>
        /// <seealso cref="CopyPixels"/>
        /// <seealso cref="CopyTexImage1D"/>
        /// <seealso cref="CopyTexImage2D"/>
        /// <seealso cref="CopyTexSubImage1D"/>
        /// <seealso cref="CopyTexSubImage2D"/>
        /// <seealso cref="CopyTexSubImage3D"/>
        /// <seealso cref="DrawPixels"/>
        /// <seealso cref="NewList"/>
        /// <seealso cref="PixelMap"/>
        /// <seealso cref="PixelStore"/>
        /// <seealso cref="PixelZoom"/>
        /// <seealso cref="ReadPixels"/>
        /// <seealso cref="TexImage1D"/>
        /// <seealso cref="TexImage2D"/>
        /// <seealso cref="TexImage3D"/>
        /// <seealso cref="TexSubImage1D"/>
        /// <seealso cref="TexSubImage2D"/>
        /// <seealso cref="TexSubImage3D"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void PixelTransferi(uint pname, int param) {
            GLNative.glPixelTransferi(pname, param);
        }

        /// <summary>
        /// copy pixels in the frame buffer
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// Modes specified by  <see cref="glPixelStore"/>  have no effect on the operation
        /// of <see cref="glCopyPixels"/>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="type"/> is not an accepted value.
        /// <code>GL_INVALID_VALUE</code> is generated if either <paramref name="width"/> or <paramref name="height"/> is negative.
        /// <code>GL_INVALID_OPERATION</code> is generated if <paramref name="type"/> is <code>GL_DEPTH</code>
        /// and there is no depth buffer.
        /// <code>GL_INVALID_OPERATION</code> is generated if <paramref name="type"/> is <code>GL_STENCIL</code>
        /// and there is no stencil buffer.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glCopyPixels"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glCopyPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum type);</para>
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify the window coordinates of the lower left corner
        /// of the rectangular region of pixels to be copied.
        /// </para>
        /// </param>
        /// <param name="y">
        /// <para>
        /// Specify the window coordinates of the lower left corner
        /// of the rectangular region of pixels to be copied.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// Specify the dimensions of the rectangular region of pixels to be copied.
        /// Both must be nonnegative.
        /// </para>
        /// </param>
        /// <param name="height">
        /// <para>
        /// Specify the dimensions of the rectangular region of pixels to be copied.
        /// Both must be nonnegative.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies whether color values,
        /// depth values,
        /// or stencil values are to be copied.
        /// Symbolic constants
        /// <code>GL_COLOR</code>,
        /// <code>GL_DEPTH</code>,
        /// and <code>GL_STENCIL</code> are accepted.
        /// </para>
        /// </param>
        /// <seealso cref="ColorTable"/>
        /// <seealso cref="ConvolutionFilter1D"/>
        /// <seealso cref="ConvolutionFilter2D"/>
        /// <seealso cref="DepthFunc"/>
        /// <seealso cref="DrawBuffer"/>
        /// <seealso cref="DrawPixels"/>
        /// <seealso cref="MatrixMode"/>
        /// <seealso cref="PixelMap"/>
        /// <seealso cref="PixelTransfer"/>
        /// <seealso cref="PixelZoom"/>
        /// <seealso cref="RasterPos"/>
        /// <seealso cref="ReadBuffer"/>
        /// <seealso cref="ReadPixels"/>
        /// <seealso cref="SeparableFilter2D"/>
        /// <seealso cref="StencilFunc"/>
        /// <seealso cref="WindowPos"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void CopyPixels(int x, int y, int width, int height, uint type) {
            GLNative.glCopyPixels(x, y, width, height, type);
        }

        /// <summary>
        /// determine if a name corresponds to a display list
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glIsList"/>
        /// is executed between the execution of
        /// <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>GLboolean glIsList(GLuint list);</para>
        /// </summary>
        /// <param name="list">
        /// Specifies a potential display list name.
        /// </param>
        /// <seealso cref="CallList"/>
        /// <seealso cref="CallLists"/>
        /// <seealso cref="DeleteLists"/>
        /// <seealso cref="GenLists"/>
        /// <seealso cref="NewList"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static bool IsList(uint list) {
            return GLNative.glIsList(list);
        }

        /// <summary>
        /// multiply the current matrix by a perspective matrix
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// Depth buffer precision is affected by the values specified for
        /// <paramref name="nearVal"/> and <paramref name="farVal"/>.
        /// The greater the ratio of <paramref name="farVal"/> to <paramref name="nearVal"/> is,
        /// the less effective the depth buffer will be at distinguishing between
        /// surfaces that are near each other.
        /// If
        /// r 
        /// = 
        /// farVal 
        /// nearVal 
        /// roughly 
        /// log 
        /// 2 
        /// &af; 
        /// r 
        /// bits of depth buffer precision are lost.
        /// Because 
        /// r   
        /// approaches infinity as <paramref name="nearVal"/> approaches 0,
        /// <paramref name="nearVal"/> must never be set to 0.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="nearVal"/> or <paramref name="farVal"/> is not
        /// positive, or if <paramref name="left"/> = <paramref name="right"/>, or <paramref name="bottom"/> = <paramref name="top"/>,
        /// or <paramref name="near"/> = <paramref name="far"/>.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glFrustum"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glFrustum(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble nearVal, GLdouble farVal);</para>
        /// </summary>
        /// <param name="left">
        /// Specify the coordinates for the left and right vertical clipping planes.
        /// </param>
        /// <param name="right">
        /// Specify the coordinates for the left and right vertical clipping planes.
        /// </param>
        /// <param name="bottom">
        /// Specify the coordinates for the bottom and top horizontal clipping planes.
        /// </param>
        /// <param name="top">
        /// Specify the coordinates for the bottom and top horizontal clipping planes.
        /// </param>
        /// <param name="nearVal">
        /// <para>
        /// Specify the distances to the near and far depth clipping planes.
        /// Both distances must be positive.
        /// </para>
        /// </param>
        /// <param name="farVal">
        /// <para>
        /// Specify the distances to the near and far depth clipping planes.
        /// Both distances must be positive.
        /// </para>
        /// </param>
        /// <seealso cref="Ortho"/>
        /// <seealso cref="MatrixMode"/>
        /// <seealso cref="MultMatrix"/>
        /// <seealso cref="PushMatrix"/>
        /// <seealso cref="Viewport"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void Frustum(double left, double right, double bottom, double top, double nearVal, double farVal) {
            GLNative.glFrustum(left, right, bottom, top, nearVal, farVal);
        }

        /// <summary>
        /// replace the current matrix with the identity matrix
        /// <para>Require:</para> <para>GL_VERSION_1_0, GL_VERSION_ES_CM_1_0</para>
        /// Supported: <para>GL</para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glLoadIdentity"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glLoadIdentity();</para>
        /// </summary>
        /// <seealso cref="LoadMatrix"/>
        /// <seealso cref="LoadTransposeMatrix"/>
        /// <seealso cref="MatrixMode"/>
        /// <seealso cref="MultMatrix"/>
        /// <seealso cref="MultTransposeMatrix"/>
        /// <seealso cref="PushMatrix"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void LoadIdentity() {
            GLNative.glLoadIdentity();
        }

        /// <summary>
        /// specify which matrix is the current matrix
        /// <para>Require:</para> <para>GL_VERSION_1_0, GL_VERSION_ES_CM_1_0</para>
        /// Supported: <para>GL</para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="mode"/> is not an accepted value.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glMatrixMode"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glMatrixMode(GLenum mode);</para>
        /// </summary>
        /// <param name="mode">
        /// <para>
        /// Specifies which matrix stack is the target
        /// for subsequent matrix operations.
        /// Three values are accepted:
        /// <code>GL_MODELVIEW</code>,
        /// <code>GL_PROJECTION</code>, and
        /// <code>GL_TEXTURE</code>.
        /// The initial value is <code>GL_MODELVIEW</code>.
        /// Additionally, if the <code>ARB_imaging</code> extension is supported,
        /// <code>GL_COLOR</code> is also accepted.
        /// </para>
        /// </param>
        /// <seealso cref="LoadMatrix"/>
        /// <seealso cref="LoadTransposeMatrix"/>
        /// <seealso cref="MultMatrix"/>
        /// <seealso cref="MultTransposeMatrix"/>
        /// <seealso cref="PopMatrix"/>
        /// <seealso cref="PushMatrix"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void MatrixMode(uint mode) {
            GLNative.glMatrixMode(mode);
        }

        /// <summary>
        /// multiply the current matrix with an orthographic matrix
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="left"/> = <paramref name="right"/>, or
        /// <paramref name="bottom"/> = <paramref name="top"/>, or
        /// <paramref name="near"/> = <paramref name="far"/>.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glOrtho"/>
        /// is executed between the execution of
        /// <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glOrtho(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble nearVal, GLdouble farVal);</para>
        /// </summary>
        /// <param name="left">
        /// Specify the coordinates for the left and right vertical clipping planes.
        /// </param>
        /// <param name="right">
        /// Specify the coordinates for the left and right vertical clipping planes.
        /// </param>
        /// <param name="bottom">
        /// Specify the coordinates for the bottom and top horizontal clipping planes.
        /// </param>
        /// <param name="top">
        /// Specify the coordinates for the bottom and top horizontal clipping planes.
        /// </param>
        /// <param name="nearVal">
        /// <para>
        /// Specify the distances to the nearer and farther depth clipping planes.
        /// These values are negative if the plane is to be behind the viewer.
        /// </para>
        /// </param>
        /// <param name="farVal">
        /// <para>
        /// Specify the distances to the nearer and farther depth clipping planes.
        /// These values are negative if the plane is to be behind the viewer.
        /// </para>
        /// </param>
        /// <seealso cref="Frustum"/>
        /// <seealso cref="MatrixMode"/>
        /// <seealso cref="MultMatrix"/>
        /// <seealso cref="PushMatrix"/>
        /// <seealso cref="Viewport"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void Ortho(double left, double right, double bottom, double top, double nearVal, double farVal) {
            GLNative.glOrtho(left, right, bottom, top, nearVal, farVal);
        }

        /// <summary>
        /// push and pop the current matrix stack
        /// <para>Require:</para> <para>GL_VERSION_1_0, GL_VERSION_ES_CM_1_0</para>
        /// Supported: <para>GL</para>
        /// Errors: 
        /// <para>
        /// <code>GL_STACK_OVERFLOW</code> is generated if <see cref="glPushMatrix"/> is called while
        /// the current matrix stack is full.
        /// <code>GL_STACK_UNDERFLOW</code> is generated if  <see cref="glPopMatrix"/>  is called while
        /// the current matrix stack contains only a single matrix.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glPushMatrix"/> or  <see cref="glPopMatrix"/> 
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glPopMatrix();</para>
        /// </summary>
        /// <seealso cref="Frustum"/>
        /// <seealso cref="LoadIdentity"/>
        /// <seealso cref="LoadMatrix"/>
        /// <seealso cref="LoadTransposeMatrix"/>
        /// <seealso cref="MatrixMode"/>
        /// <seealso cref="MultMatrix"/>
        /// <seealso cref="MultTransposeMatrix"/>
        /// <seealso cref="Ortho"/>
        /// <seealso cref="Rotate"/>
        /// <seealso cref="Scale"/>
        /// <seealso cref="Translate"/>
        /// <seealso cref="Viewport"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void PopMatrix() {
            GLNative.glPopMatrix();
        }

        /// <summary>
        /// push and pop the current matrix stack
        /// <para>Require:</para> <para>GL_VERSION_1_0, GL_VERSION_ES_CM_1_0</para>
        /// Supported: <para>GL</para>
        /// Errors: 
        /// <para>
        /// <code>GL_STACK_OVERFLOW</code> is generated if <see cref="glPushMatrix"/> is called while
        /// the current matrix stack is full.
        /// <code>GL_STACK_UNDERFLOW</code> is generated if  <see cref="glPopMatrix"/>  is called while
        /// the current matrix stack contains only a single matrix.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glPushMatrix"/> or  <see cref="glPopMatrix"/> 
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glPushMatrix();</para>
        /// </summary>
        /// <seealso cref="Frustum"/>
        /// <seealso cref="LoadIdentity"/>
        /// <seealso cref="LoadMatrix"/>
        /// <seealso cref="LoadTransposeMatrix"/>
        /// <seealso cref="MatrixMode"/>
        /// <seealso cref="MultMatrix"/>
        /// <seealso cref="MultTransposeMatrix"/>
        /// <seealso cref="Ortho"/>
        /// <seealso cref="Rotate"/>
        /// <seealso cref="Scale"/>
        /// <seealso cref="Translate"/>
        /// <seealso cref="Viewport"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void PushMatrix() {
            GLNative.glPushMatrix();
        }

        /// <summary>
        /// multiply the current matrix by a rotation matrix
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// This rotation follows the right-hand rule, so
        /// if the vector 
        /// x 
        /// y 
        /// z 
        /// points toward the
        /// user, the rotation will be counterclockwise.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glRotate"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glRotated(GLdouble angle, GLdouble x, GLdouble y, GLdouble z);</para>
        /// </summary>
        /// <param name="angle">
        /// Specifies the angle of rotation, in degrees.
        /// </param>
        /// <param name="x">
        /// Specify the  x ,  y , and  z  coordinates of a vector, respectively.
        /// </param>
        /// <param name="y">
        /// Specify the  x ,  y , and  z  coordinates of a vector, respectively.
        /// </param>
        /// <param name="z">
        /// Specify the  x ,  y , and  z  coordinates of a vector, respectively.
        /// </param>
        /// <seealso cref="MatrixMode"/>
        /// <seealso cref="MultMatrix"/>
        /// <seealso cref="PushMatrix"/>
        /// <seealso cref="Scale"/>
        /// <seealso cref="Translate"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void Rotated(double angle, double x, double y, double z) {
            GLNative.glRotated(angle, x, y, z);
        }

        /// <summary>
        /// multiply the current matrix by a rotation matrix
        /// <para>Require:</para> <para>GL_VERSION_1_0, GL_VERSION_ES_CM_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// This rotation follows the right-hand rule, so
        /// if the vector 
        /// x 
        /// y 
        /// z 
        /// points toward the
        /// user, the rotation will be counterclockwise.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glRotate"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glRotatef(GLfloat angle, GLfloat x, GLfloat y, GLfloat z);</para>
        /// </summary>
        /// <param name="angle">
        /// Specifies the angle of rotation, in degrees.
        /// </param>
        /// <param name="x">
        /// Specify the  x ,  y , and  z  coordinates of a vector, respectively.
        /// </param>
        /// <param name="y">
        /// Specify the  x ,  y , and  z  coordinates of a vector, respectively.
        /// </param>
        /// <param name="z">
        /// Specify the  x ,  y , and  z  coordinates of a vector, respectively.
        /// </param>
        /// <seealso cref="MatrixMode"/>
        /// <seealso cref="MultMatrix"/>
        /// <seealso cref="PushMatrix"/>
        /// <seealso cref="Scale"/>
        /// <seealso cref="Translate"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void Rotatef(float angle, float x, float y, float z) {
            GLNative.glRotatef(angle, x, y, z);
        }

        /// <summary>
        /// multiply the current matrix by a general scaling matrix
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// If scale factors other than 1 are applied to the modelview matrix
        /// and lighting is enabled, lighting often appears wrong.
        /// In that case, enable automatic normalization of normals by
        /// calling  <see cref="glEnable"/>  with the argument <code>GL_NORMALIZE</code>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glScale"/>
        /// is executed between the execution of
        /// <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glScaled(GLdouble x, GLdouble y, GLdouble z);</para>
        /// </summary>
        /// <param name="x">
        /// Specify scale factors along the  x ,  y , and  z  axes, respectively.
        /// </param>
        /// <param name="y">
        /// Specify scale factors along the  x ,  y , and  z  axes, respectively.
        /// </param>
        /// <param name="z">
        /// Specify scale factors along the  x ,  y , and  z  axes, respectively.
        /// </param>
        /// <seealso cref="MatrixMode"/>
        /// <seealso cref="MultMatrix"/>
        /// <seealso cref="PushMatrix"/>
        /// <seealso cref="Rotate"/>
        /// <seealso cref="Translate"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void Scaled(double x, double y, double z) {
            GLNative.glScaled(x, y, z);
        }

        /// <summary>
        /// multiply the current matrix by a general scaling matrix
        /// <para>Require:</para> <para>GL_VERSION_1_0, GL_VERSION_ES_CM_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// If scale factors other than 1 are applied to the modelview matrix
        /// and lighting is enabled, lighting often appears wrong.
        /// In that case, enable automatic normalization of normals by
        /// calling  <see cref="glEnable"/>  with the argument <code>GL_NORMALIZE</code>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glScale"/>
        /// is executed between the execution of
        /// <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glScalef(GLfloat x, GLfloat y, GLfloat z);</para>
        /// </summary>
        /// <param name="x">
        /// Specify scale factors along the  x ,  y , and  z  axes, respectively.
        /// </param>
        /// <param name="y">
        /// Specify scale factors along the  x ,  y , and  z  axes, respectively.
        /// </param>
        /// <param name="z">
        /// Specify scale factors along the  x ,  y , and  z  axes, respectively.
        /// </param>
        /// <seealso cref="MatrixMode"/>
        /// <seealso cref="MultMatrix"/>
        /// <seealso cref="PushMatrix"/>
        /// <seealso cref="Rotate"/>
        /// <seealso cref="Translate"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void Scalef(float x, float y, float z) {
            GLNative.glScalef(x, y, z);
        }

        /// <summary>
        /// multiply the current matrix by a translation matrix
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glTranslate"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glTranslated(GLdouble x, GLdouble y, GLdouble z);</para>
        /// </summary>
        /// <param name="x">
        /// Specify the  x ,  y , and  z  coordinates of a translation vector.
        /// </param>
        /// <param name="y">
        /// Specify the  x ,  y , and  z  coordinates of a translation vector.
        /// </param>
        /// <param name="z">
        /// Specify the  x ,  y , and  z  coordinates of a translation vector.
        /// </param>
        /// <seealso cref="MatrixMode"/>
        /// <seealso cref="MultMatrix"/>
        /// <seealso cref="PushMatrix"/>
        /// <seealso cref="Rotate"/>
        /// <seealso cref="Scale"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void Translated(double x, double y, double z) {
            GLNative.glTranslated(x, y, z);
        }

        /// <summary>
        /// multiply the current matrix by a translation matrix
        /// <para>Require:</para> <para>GL_VERSION_1_0, GL_VERSION_ES_CM_1_0</para>
        /// Supported: <para>GL</para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glTranslate"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glTranslatef(GLfloat x, GLfloat y, GLfloat z);</para>
        /// </summary>
        /// <param name="x">
        /// Specify the  x ,  y , and  z  coordinates of a translation vector.
        /// </param>
        /// <param name="y">
        /// Specify the  x ,  y , and  z  coordinates of a translation vector.
        /// </param>
        /// <param name="z">
        /// Specify the  x ,  y , and  z  coordinates of a translation vector.
        /// </param>
        /// <seealso cref="MatrixMode"/>
        /// <seealso cref="MultMatrix"/>
        /// <seealso cref="PushMatrix"/>
        /// <seealso cref="Rotate"/>
        /// <seealso cref="Scale"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void Translatef(float x, float y, float z) {
            GLNative.glTranslatef(x, y, z);
        }


        #endregion GL_VERSION_1_0

        #region GL_VERSION_1_1

        /// <summary>
        /// render primitives from array data
        /// <para>Require:</para> <para>GL_VERSION_1_1, GL_VERSION_ES_CM_1_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glDrawArrays"/> is available only if the GL version is 1.1 or greater.
        /// <see cref="glDrawArrays"/> is included in display lists. If <see cref="glDrawArrays"/> is entered into a
        /// display list,
        /// the necessary array data (determined by the array pointers and
        /// enables) is also
        /// entered into the display list. Because the array pointers and
        /// enables are client-side state, their values affect display lists
        /// when the lists are created, not when the lists are executed.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="mode"/> is not an accepted value.
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="count"/> is negative.
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to an
        /// enabled array and the buffer object's data store is currently mapped.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glDrawArrays"/> is executed between
        /// the execution of  <see cref="glBegin"/>  and the corresponding  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glDrawArrays(GLenum mode, GLint first, GLsizei count);</para>
        /// </summary>
        /// <param name="mode">
        /// <para>
        /// Specifies what kind of primitives to render.
        /// Symbolic constants
        /// <code>GL_POINTS</code>,
        /// <code>GL_LINE_STRIP</code>,
        /// <code>GL_LINE_LOOP</code>,
        /// <code>GL_LINES</code>,
        /// <code>GL_TRIANGLE_STRIP</code>,
        /// <code>GL_TRIANGLE_FAN</code>,
        /// <code>GL_TRIANGLES</code>,
        /// <code>GL_QUAD_STRIP</code>,
        /// <code>GL_QUADS</code>,
        /// and <code>GL_POLYGON</code> are accepted.
        /// </para>
        /// </param>
        /// <param name="first">
        /// Specifies the starting index in the enabled arrays.
        /// </param>
        /// <param name="count">
        /// Specifies the number of indices to be rendered.
        /// </param>
        /// <seealso cref="ArrayElement"/>
        /// <seealso cref="ColorPointer"/>
        /// <seealso cref="DrawElements"/>
        /// <seealso cref="DrawRangeElements"/>
        /// <seealso cref="EdgeFlagPointer"/>
        /// <seealso cref="FogCoordPointer"/>
        /// <seealso cref="GetPointerv"/>
        /// <seealso cref="IndexPointer"/>
        /// <seealso cref="InterleavedArrays"/>
        /// <seealso cref="NormalPointer"/>
        /// <seealso cref="SecondaryColorPointer"/>
        /// <seealso cref="TexCoordPointer"/>
        /// <seealso cref="VertexPointer"/>
        public static void DrawArrays(uint mode, int first, int count) {
            GLNative.glDrawArrays(mode, first, count);
        }

        /// <summary>
        /// set the scale and units used to calculate depth values
        /// <para>Require:</para> <para>GL_VERSION_1_1, GL_VERSION_ES_CM_1_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glPolygonOffset"/> is available only if the GL version is 1.1 or greater.
        /// <see cref="glPolygonOffset"/> has no effect on depth coordinates placed in the
        /// feedback buffer.
        /// <see cref="glPolygonOffset"/> has no effect on selection.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glPolygonOffset"/> is executed
        /// between the execution of  <see cref="glBegin"/>  and the corresponding
        /// execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glPolygonOffset(GLfloat factor, GLfloat units);</para>
        /// </summary>
        /// <param name="factor">
        /// <para>
        /// Specifies a scale factor that is used to create a variable
        /// depth offset for each polygon. The initial value is 0.
        /// </para>
        /// </param>
        /// <param name="units">
        /// <para>
        /// Is multiplied by an implementation-specific value to
        /// create a constant depth offset. The initial value is 0.
        /// </para>
        /// </param>
        /// <seealso cref="DepthFunc"/>
        /// <seealso cref="Enable"/>
        /// <seealso cref="Get"/>
        /// <seealso cref="IsEnabled"/>
        public static void PolygonOffset(float factor, float units) {
            GLNative.glPolygonOffset(factor, units);
        }

        /// <summary>
        /// copy pixels into a 1D texture image
        /// <para>Require:</para> <para>GL_VERSION_1_1</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glCopyTexImage1D"/> is available only if the GL version is 1.1 or greater.
        /// Texturing has no effect in color index mode.
        /// 1, 2, 3, and 4 are not accepted values for <paramref name="internalformat"/>.
        /// An image with 0 width indicates a NULL texture.
        /// When the <code>ARB_imaging</code> extension is supported, the RGBA components copied from the framebuffer may be processed by the imaging pipeline.  See  <see cref="glTexImage1D"/>  for specific details.
        /// <code>GL_DEPTH_COMPONENT</code>, <code>GL_DEPTH_COMPONENT16</code>,
        /// <code>GL_DEPTH_COMPONENT24</code>, and <code>GL_DEPTH_COMPONENT32</code> are available only
        /// if the GL version is 1.4 or greater.
        /// Non-power-of-two textures are supported if the GL version is 2.0 or greater, or if the implementation exports the <code>GL_ARB_texture_non_power_of_two</code> extension.
        /// The 
        /// <code>GL_SRGB</code>,
        /// <code>GL_SRGB8</code>,
        /// <code>GL_SRGB_ALPHA</code>,
        /// <code>GL_SRGB8_ALPHA8</code>,
        /// <code>GL_SLUMINANCE</code>,
        /// <code>GL_SLUMINANCE8</code>,
        /// <code>GL_SLUMINANCE_ALPHA</code>, and
        /// <code>GL_SLUMINANCE8_ALPHA8</code>
        /// internal formats are only available if the GL version is 2.1 or greater.  See  <see cref="glTexImage1D"/>  for specific details about sRGB conversion.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="target"/> is not one of the allowable values.
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="level"/> is less than 0.
        /// <code>GL_INVALID_VALUE</code> may be generated if <paramref name="level"/> is greater
        /// than 
        /// log 
        /// 2 
        /// &it; 
        /// max 
        /// ,
        /// where
        /// max   
        /// is the returned value of <code>GL_MAX_TEXTURE_SIZE</code>.
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="internalformat"/> is not an allowable value.
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="width"/> is less than 0 or greater than
        /// 2 + <code>GL_MAX_TEXTURE_SIZE</code>.
        /// <code>GL_INVALID_VALUE</code> is generated if non-power-of-two textures are not supported and the <paramref name="width"/> cannot be represented as 
        /// 2 
        /// n 
        /// + 
        /// 2 
        /// &af; 
        /// border 
        /// for some integer value of  n .
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="border"/> is not 0 or 1.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glCopyTexImage1D"/> is executed between the execution of  <see cref="glBegin"/>  and the corresponding execution of  <see cref="glEnd"/> .
        /// <code>GL_INVALID_OPERATION</code> is generated if <paramref name="internalformat"/> is
        /// <code>GL_DEPTH_COMPONENT</code>, <code>GL_DEPTH_COMPONENT16</code>,
        /// <code>GL_DEPTH_COMPONENT24</code>, or <code>GL_DEPTH_COMPONENT32</code> and there is no depth
        /// buffer.
        /// </para>
        /// Original: <para>void glCopyTexImage1D(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target texture.
        /// Must be <code>GL_TEXTURE_1D</code>.
        /// </para>
        /// </param>
        /// <param name="level">
        /// <para>
        /// Specifies the level-of-detail number.
        /// Level 0 is the base image level.
        /// Level  n  is the  n th mipmap reduction image.
        /// </para>
        /// </param>
        /// <param name="internalformat">
        /// <para>
        /// Specifies the internal format of the texture.
        /// Must be one of the following symbolic constants:
        /// <code>GL_ALPHA</code>,
        /// <code>GL_ALPHA4</code>,
        /// <code>GL_ALPHA8</code>,
        /// <code>GL_ALPHA12</code>,
        /// <code>GL_ALPHA16</code>,
        /// <code>GL_COMPRESSED_ALPHA</code>,
        /// <code>GL_COMPRESSED_LUMINANCE</code>,
        /// <code>GL_COMPRESSED_LUMINANCE_ALPHA</code>,
        /// <code>GL_COMPRESSED_INTENSITY</code>,
        /// <code>GL_COMPRESSED_RGB</code>,
        /// <code>GL_COMPRESSED_RGBA</code>,
        /// <code>GL_DEPTH_COMPONENT</code>,
        /// <code>GL_DEPTH_COMPONENT16</code>,
        /// <code>GL_DEPTH_COMPONENT24</code>,
        /// <code>GL_DEPTH_COMPONENT32</code>,
        /// <code>GL_LUMINANCE</code>,
        /// <code>GL_LUMINANCE4</code>,
        /// <code>GL_LUMINANCE8</code>,
        /// <code>GL_LUMINANCE12</code>,
        /// <code>GL_LUMINANCE16</code>,
        /// <code>GL_LUMINANCE_ALPHA</code>,
        /// <code>GL_LUMINANCE4_ALPHA4</code>,
        /// <code>GL_LUMINANCE6_ALPHA2</code>,
        /// <code>GL_LUMINANCE8_ALPHA8</code>,
        /// <code>GL_LUMINANCE12_ALPHA4</code>,
        /// <code>GL_LUMINANCE12_ALPHA12</code>,
        /// <code>GL_LUMINANCE16_ALPHA16</code>,
        /// <code>GL_INTENSITY</code>,
        /// <code>GL_INTENSITY4</code>,
        /// <code>GL_INTENSITY8</code>,
        /// <code>GL_INTENSITY12</code>,
        /// <code>GL_INTENSITY16</code>,
        /// <code>GL_RGB</code>,
        /// <code>GL_R3_G3_B2</code>,
        /// <code>GL_RGB4</code>,
        /// <code>GL_RGB5</code>,
        /// <code>GL_RGB8</code>,
        /// <code>GL_RGB10</code>,
        /// <code>GL_RGB12</code>,
        /// <code>GL_RGB16</code>,
        /// <code>GL_RGBA</code>,
        /// <code>GL_RGBA2</code>,
        /// <code>GL_RGBA4</code>,
        /// <code>GL_RGB5_A1</code>,
        /// <code>GL_RGBA8</code>,
        /// <code>GL_RGB10_A2</code>,
        /// <code>GL_RGBA12</code>,
        /// <code>GL_RGBA16</code>,
        /// <code>GL_SLUMINANCE</code>,
        /// <code>GL_SLUMINANCE8</code>,
        /// <code>GL_SLUMINANCE_ALPHA</code>,
        /// <code>GL_SLUMINANCE8_ALPHA8</code>,
        /// <code>GL_SRGB</code>,
        /// <code>GL_SRGB8</code>,
        /// <code>GL_SRGB_ALPHA</code>, or 
        /// <code>GL_SRGB8_ALPHA8</code>.
        /// </para>
        /// </param>
        /// <param name="x">
        /// <para>
        /// Specify the window coordinates of the left corner
        /// of the row of pixels to be copied.
        /// </para>
        /// </param>
        /// <param name="y">
        /// <para>
        /// Specify the window coordinates of the left corner
        /// of the row of pixels to be copied.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// Specifies the width of the texture image.
        /// Must be 0 or 
        /// 2 
        /// n 
        /// + 
        /// 2 
        /// &af; 
        /// border 
        /// for some integer 
        /// n   .
        /// The height of the texture image is 1.
        /// </para>
        /// </param>
        /// <param name="border">
        /// <para>
        /// Specifies the width of the border.
        /// Must be either 0 or 1.
        /// </para>
        /// </param>
        /// <seealso cref="CopyPixels"/>
        /// <seealso cref="CopyTexImage2D"/>
        /// <seealso cref="CopyTexSubImage1D"/>
        /// <seealso cref="CopyTexSubImage2D"/>
        /// <seealso cref="PixelStore"/>
        /// <seealso cref="PixelTransfer"/>
        /// <seealso cref="TexEnv"/>
        /// <seealso cref="TexGen"/>
        /// <seealso cref="TexImage1D"/>
        /// <seealso cref="TexImage2D"/>
        /// <seealso cref="TexSubImage1D"/>
        /// <seealso cref="TexSubImage2D"/>
        /// <seealso cref="TexParameter"/>
        public static void CopyTexImage1D(uint target, int level, uint internalformat, int x, int y, int width, int border) {
            GLNative.glCopyTexImage1D(target, level, internalformat, x, y, width, border);
        }

        /// <summary>
        /// copy pixels into a 2D texture image
        /// <para>Require:</para> <para>GL_VERSION_1_1, GL_VERSION_ES_CM_1_0, GL_ES_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glCopyTexImage2D"/> is available only if the GL version is 1.1 or greater.
        /// Texturing has no effect in color index mode.
        /// 1, 2, 3, and 4 are not accepted values for <paramref name="internalformat"/>.
        /// An image with height or width of 0 indicates a NULL texture.
        /// When the <code>ARB_imaging</code> extension is supported, the RGBA components read from the framebuffer may be processed by the imaging pipeline.  See  <see cref="glTexImage1D"/>  for specific details.
        /// <code>GL_TEXTURE_CUBE_MAP_POSITIVE_X</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_NEGATIVE_X</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_POSITIVE_Y</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_NEGATIVE_Y</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_POSITIVE_Z</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_NEGATIVE_Z</code>, or
        /// <code>GL_PROXY_TEXTURE_CUBE_MAP</code> are available only if the GL version is 1.3
        /// or greater.
        /// <code>GL_DEPTH_COMPONENT</code>, <code>GL_DEPTH_COMPONENT16</code>, <code>GL_DEPTH_COMPONENT24</code>,
        /// and <code>GL_DEPTH_COMPONENT32</code> are available only if the GL version is 1.4
        /// or greater.
        /// The 
        /// <code>GL_SRGB</code>,
        /// <code>GL_SRGB8</code>,
        /// <code>GL_SRGB_ALPHA</code>,
        /// <code>GL_SRGB8_ALPHA8</code>,
        /// <code>GL_SLUMINANCE</code>,
        /// <code>GL_SLUMINANCE8</code>,
        /// <code>GL_SLUMINANCE_ALPHA</code>, and
        /// <code>GL_SLUMINANCE8_ALPHA8</code>
        /// internal formats are only available if the GL version is 2.1 or greater.  See  <see cref="glTexImage2D"/>  for specific details about sRGB conversion.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="target"/> is not <code>GL_TEXTURE_2D</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_POSITIVE_X</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_NEGATIVE_X</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_POSITIVE_Y</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_NEGATIVE_Y</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_POSITIVE_Z</code>, or
        /// <code>GL_TEXTURE_CUBE_MAP_NEGATIVE_Z</code>.
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="level"/> is less than 0.
        /// <code>GL_INVALID_VALUE</code> may be generated if <paramref name="level"/> is greater
        /// than 
        /// log 
        /// 2 
        /// &it; 
        /// max 
        /// ,
        /// where 
        /// max   
        /// is the returned value of <code>GL_MAX_TEXTURE_SIZE</code>.
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="width"/> is less than 0
        /// or greater than
        /// 2 + <code>GL_MAX_TEXTURE_SIZE</code>.
        /// <code>GL_INVALID_VALUE</code> is generated if non-power-of-two textures are not supported and the <paramref name="width"/> or <paramref name="depth"/> cannot be represented as  
        /// 2 
        /// k 
        /// + 
        /// 2 
        /// &af; 
        /// border 
        /// for some integer 
        /// k   .
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="border"/> is not 0 or 1.
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="internalformat"/> is not an
        /// accepted format.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glCopyTexImage2D"/> is executed
        /// between the execution of  <see cref="glBegin"/>  and the corresponding
        /// execution of  <see cref="glEnd"/> .
        /// <code>GL_INVALID_OPERATION</code> is generated if <paramref name="internalformat"/> is
        /// <code>GL_DEPTH_COMPONENT</code>, <code>GL_DEPTH_COMPONENT16</code>,
        /// <code>GL_DEPTH_COMPONENT24</code>, or <code>GL_DEPTH_COMPONENT32</code> and there is no depth
        /// buffer.
        /// </para>
        /// Original: <para>void glCopyTexImage2D(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target texture.
        /// Must be <code>GL_TEXTURE_2D</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_POSITIVE_X</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_NEGATIVE_X</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_POSITIVE_Y</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_NEGATIVE_Y</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_POSITIVE_Z</code>, or
        /// <code>GL_TEXTURE_CUBE_MAP_NEGATIVE_Z</code>.
        /// </para>
        /// </param>
        /// <param name="level">
        /// <para>
        /// Specifies the level-of-detail number.
        /// Level 0 is the base image level.
        /// Level  n  is the  n th mipmap reduction image.
        /// </para>
        /// </param>
        /// <param name="internalformat">
        /// <para>
        /// Specifies the internal format of the texture.
        /// Must be one of the following symbolic constants:
        /// <code>GL_ALPHA</code>,
        /// <code>GL_ALPHA4</code>,
        /// <code>GL_ALPHA8</code>,
        /// <code>GL_ALPHA12</code>,
        /// <code>GL_ALPHA16</code>,
        /// <code>GL_COMPRESSED_ALPHA</code>,
        /// <code>GL_COMPRESSED_LUMINANCE</code>,
        /// <code>GL_COMPRESSED_LUMINANCE_ALPHA</code>,
        /// <code>GL_COMPRESSED_INTENSITY</code>,
        /// <code>GL_COMPRESSED_RGB</code>,
        /// <code>GL_COMPRESSED_RGBA</code>,
        /// <code>GL_DEPTH_COMPONENT</code>,
        /// <code>GL_DEPTH_COMPONENT16</code>,
        /// <code>GL_DEPTH_COMPONENT24</code>,
        /// <code>GL_DEPTH_COMPONENT32</code>,
        /// <code>GL_LUMINANCE</code>,
        /// <code>GL_LUMINANCE4</code>,
        /// <code>GL_LUMINANCE8</code>,
        /// <code>GL_LUMINANCE12</code>,
        /// <code>GL_LUMINANCE16</code>,
        /// <code>GL_LUMINANCE_ALPHA</code>,
        /// <code>GL_LUMINANCE4_ALPHA4</code>,
        /// <code>GL_LUMINANCE6_ALPHA2</code>,
        /// <code>GL_LUMINANCE8_ALPHA8</code>,
        /// <code>GL_LUMINANCE12_ALPHA4</code>,
        /// <code>GL_LUMINANCE12_ALPHA12</code>,
        /// <code>GL_LUMINANCE16_ALPHA16</code>,
        /// <code>GL_INTENSITY</code>,
        /// <code>GL_INTENSITY4</code>,
        /// <code>GL_INTENSITY8</code>,
        /// <code>GL_INTENSITY12</code>,
        /// <code>GL_INTENSITY16</code>,
        /// <code>GL_RGB</code>,
        /// <code>GL_R3_G3_B2</code>,
        /// <code>GL_RGB4</code>,
        /// <code>GL_RGB5</code>,
        /// <code>GL_RGB8</code>,
        /// <code>GL_RGB10</code>,
        /// <code>GL_RGB12</code>,
        /// <code>GL_RGB16</code>,
        /// <code>GL_RGBA</code>,
        /// <code>GL_RGBA2</code>,
        /// <code>GL_RGBA4</code>,
        /// <code>GL_RGB5_A1</code>,
        /// <code>GL_RGBA8</code>,
        /// <code>GL_RGB10_A2</code>,
        /// <code>GL_RGBA12</code>,
        /// <code>GL_RGBA16</code>,
        /// <code>GL_SLUMINANCE</code>,
        /// <code>GL_SLUMINANCE8</code>,
        /// <code>GL_SLUMINANCE_ALPHA</code>,
        /// <code>GL_SLUMINANCE8_ALPHA8</code>,
        /// <code>GL_SRGB</code>,
        /// <code>GL_SRGB8</code>,
        /// <code>GL_SRGB_ALPHA</code>, or 
        /// <code>GL_SRGB8_ALPHA8</code>.
        /// </para>
        /// </param>
        /// <param name="x">
        /// <para>
        /// Specify the window coordinates of the lower left corner
        /// of the rectangular region of pixels to be copied.
        /// </para>
        /// </param>
        /// <param name="y">
        /// <para>
        /// Specify the window coordinates of the lower left corner
        /// of the rectangular region of pixels to be copied.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// Specifies the width of the texture image.
        /// Must be 0 or 
        /// 2 
        /// n 
        /// + 
        /// 2 
        /// &af; 
        /// border 
        /// for some integer 
        /// n   .
        /// </para>
        /// </param>
        /// <param name="height">
        /// <para>
        /// Specifies the height of the texture image.
        /// Must be 0 or 
        /// 2 
        /// m 
        /// + 
        /// 2 
        /// &af; 
        /// border 
        /// for some integer 
        /// m   .
        /// </para>
        /// </param>
        /// <param name="border">
        /// <para>
        /// Specifies the width of the border.
        /// Must be either 0 or 1.
        /// </para>
        /// </param>
        /// <seealso cref="CopyPixels"/>
        /// <seealso cref="CopyTexImage1D"/>
        /// <seealso cref="CopyTexSubImage1D"/>
        /// <seealso cref="CopyTexSubImage2D"/>
        /// <seealso cref="PixelStore"/>
        /// <seealso cref="PixelTransfer"/>
        /// <seealso cref="TexEnv"/>
        /// <seealso cref="TexGen"/>
        /// <seealso cref="TexImage1D"/>
        /// <seealso cref="TexImage2D"/>
        /// <seealso cref="TexSubImage1D"/>
        /// <seealso cref="TexSubImage2D"/>
        /// <seealso cref="TexParameter"/>
        public static void CopyTexImage2D(uint target, int level, uint internalformat, int x, int y, int width, int height, int border) {
            GLNative.glCopyTexImage2D(target, level, internalformat, x, y, width, height, border);
        }

        /// <summary>
        /// copy a one-dimensional texture subimage
        /// <para>Require:</para> <para>GL_VERSION_1_1</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glCopyTexSubImage1D"/> is available only if the GL version is 1.1 or greater.
        /// Texturing has no effect in color index mode.
        /// <see cref="glPixelStore"/>  and  <see cref="glPixelTransfer"/>  modes affect texture images
        /// in exactly the way they affect  <see cref="glDrawPixels"/> .
        /// When the <code>ARB_imaging</code> extension is supported, the RGBA components
        /// copied from the framebuffer may be processed by the imaging pipeline.  See
        /// <see cref="glTexImage1D"/>  for specific details.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if /<paramref name="target"/> is not <code>GL_TEXTURE_1D</code>.
        /// <code>GL_INVALID_OPERATION</code> is generated if the texture array has not
        /// been defined by a previous  <see cref="glTexImage1D"/>  or  <see cref="glCopyTexImage1D"/>  operation.
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="level"/> is less than 0.
        /// <code>GL_INVALID_VALUE</code> may be generated if 
        /// log sub 2(max):-->
        /// level 
        /// &gt; 
        /// log 
        /// 2 
        /// &af; 
        /// max 
        /// ,
        /// where  max  is the returned value of <code>GL_MAX_TEXTURE_SIZE</code>.
        /// <code>GL_INVALID_VALUE</code> is generated if 
        /// xoffset 
        /// &lt; 
        /// - 
        /// b 
        /// ,
        /// or
        /// (w-b):-->
        /// xoffset 
        /// + 
        /// width 
        /// &gt; 
        /// w 
        /// - 
        /// b 
        /// ,
        /// where 
        /// w   
        /// is the <code>GL_TEXTURE_WIDTH</code> and 
        /// b   
        /// is the <code>GL_TEXTURE_BORDER</code>
        /// of the texture image being modified.
        /// Note that 
        /// w   
        /// includes twice the border width.
        /// </para>
        /// Original: <para>void glCopyTexSubImage1D(GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target texture.
        /// Must be <code>GL_TEXTURE_1D</code>.
        /// </para>
        /// </param>
        /// <param name="level">
        /// <para>
        /// Specifies the level-of-detail number.
        /// Level 0 is the base image level.
        /// Level  n  is the  n th mipmap reduction image.
        /// </para>
        /// </param>
        /// <param name="xoffset">
        /// Specifies the texel offset within the texture array.
        /// </param>
        /// <param name="x">
        /// <para>
        /// Specify the window coordinates of the left corner
        /// of the row of pixels to be copied.
        /// </para>
        /// </param>
        /// <param name="y">
        /// <para>
        /// Specify the window coordinates of the left corner
        /// of the row of pixels to be copied.
        /// </para>
        /// </param>
        /// <param name="width">
        /// Specifies the width of the texture subimage.
        /// </param>
        /// <seealso cref="CopyPixels"/>
        /// <seealso cref="CopyTexImage1D"/>
        /// <seealso cref="CopyTexImage2D"/>
        /// <seealso cref="CopyTexSubImage2D"/>
        /// <seealso cref="CopyTexSubImage3D"/>
        /// <seealso cref="PixelStore"/>
        /// <seealso cref="PixelTransfer"/>
        /// <seealso cref="ReadBuffer"/>
        /// <seealso cref="TexEnv"/>
        /// <seealso cref="TexGen"/>
        /// <seealso cref="TexImage1D"/>
        /// <seealso cref="TexImage2D"/>
        /// <seealso cref="TexImage3D"/>
        /// <seealso cref="TexParameter"/>
        /// <seealso cref="TexSubImage1D"/>
        /// <seealso cref="TexSubImage2D"/>
        /// <seealso cref="TexSubImage3D"/>
        public static void CopyTexSubImage1D(uint target, int level, int xoffset, int x, int y, int width) {
            GLNative.glCopyTexSubImage1D(target, level, xoffset, x, y, width);
        }

        /// <summary>
        /// copy a two-dimensional texture subimage
        /// <para>Require:</para> <para>GL_VERSION_1_1, GL_VERSION_ES_CM_1_0, GL_ES_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glCopyTexSubImage2D"/> is available only if the GL version is 1.1 or greater.
        /// <code>GL_TEXTURE_CUBE_MAP_POSITIVE_X</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_NEGATIVE_X</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_POSITIVE_Y</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_NEGATIVE_Y</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_POSITIVE_Z</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_NEGATIVE_Z</code>, or
        /// <code>GL_PROXY_TEXTURE_CUBE_MAP</code> are available only if the GL version is 1.3
        /// or greater.
        /// Texturing has no effect in color index mode.
        /// <see cref="glPixelStore"/>  and  <see cref="glPixelTransfer"/>  modes affect texture images
        /// in exactly the way they affect  <see cref="glDrawPixels"/> .
        /// When the <code>ARB_imaging</code> extension is supported, the RGBA components
        /// read from the framebuffer may be processed by the imaging pipeline.  See
        /// <see cref="glTexImage1D"/>  for specific details.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="target"/> is not <code>GL_TEXTURE_2D</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_POSITIVE_X</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_NEGATIVE_X</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_POSITIVE_Y</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_NEGATIVE_Y</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_POSITIVE_Z</code>, or
        /// <code>GL_TEXTURE_CUBE_MAP_NEGATIVE_Z</code>.
        /// <code>GL_INVALID_OPERATION</code> is generated if the texture array has not been
        /// defined by a previous  <see cref="glTexImage2D"/>  or  <see cref="glCopyTexImage2D"/>  operation.
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="level"/> is less than 0.
        /// <code>GL_INVALID_VALUE</code> may be generated if 
        /// log sub 2(max):-->
        /// level 
        /// &gt; 
        /// log 
        /// 2 
        /// &af; 
        /// max 
        /// ,
        /// where 
        /// max   
        /// is the returned value of <code>GL_MAX_TEXTURE_SIZE</code>.
        /// <code>GL_INVALID_VALUE</code> is generated if 
        /// xoffset 
        /// &lt; 
        /// - 
        /// b 
        /// ,
        /// (w  -  b):-->
        /// xoffset 
        /// + 
        /// width 
        /// &gt; 
        /// w 
        /// - 
        /// b 
        /// ,
        /// yoffset 
        /// &lt; 
        /// - 
        /// b 
        /// ,
        /// or
        /// (h  - b):-->
        /// yoffset 
        /// + 
        /// height 
        /// &gt; 
        /// h 
        /// - 
        /// b 
        /// ,
        /// where 
        /// w   
        /// is the <code>GL_TEXTURE_WIDTH</code>,
        /// h   
        /// is the <code>GL_TEXTURE_HEIGHT</code>,
        /// and 
        /// b   
        /// is the <code>GL_TEXTURE_BORDER</code>
        /// of the texture image being modified.
        /// Note that 
        /// w   
        /// and 
        /// h   
        /// include twice the border width.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glCopyTexSubImage2D"/> is executed
        /// between the execution of  <see cref="glBegin"/>  and the corresponding
        /// execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glCopyTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target texture.
        /// Must be <code>GL_TEXTURE_2D</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_POSITIVE_X</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_NEGATIVE_X</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_POSITIVE_Y</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_NEGATIVE_Y</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_POSITIVE_Z</code>, or
        /// <code>GL_TEXTURE_CUBE_MAP_NEGATIVE_Z</code>.
        /// </para>
        /// </param>
        /// <param name="level">
        /// <para>
        /// Specifies the level-of-detail number.
        /// Level 0 is the base image level.
        /// Level  n  is the  n th mipmap reduction image.
        /// </para>
        /// </param>
        /// <param name="xoffset">
        /// Specifies a texel offset in the x direction within the texture array.
        /// </param>
        /// <param name="yoffset">
        /// Specifies a texel offset in the y direction within the texture array.
        /// </param>
        /// <param name="x">
        /// <para>
        /// Specify the window coordinates of the lower left corner
        /// of the rectangular region of pixels to be copied.
        /// </para>
        /// </param>
        /// <param name="y">
        /// <para>
        /// Specify the window coordinates of the lower left corner
        /// of the rectangular region of pixels to be copied.
        /// </para>
        /// </param>
        /// <param name="width">
        /// Specifies the width of the texture subimage.
        /// </param>
        /// <param name="height">
        /// Specifies the height of the texture subimage.
        /// </param>
        /// <seealso cref="CopyPixels"/>
        /// <seealso cref="CopyTexImage1D"/>
        /// <seealso cref="CopyTexImage2D"/>
        /// <seealso cref="CopyTexSubImage1D"/>
        /// <seealso cref="CopyTexSubImage3D"/>
        /// <seealso cref="PixelStore"/>
        /// <seealso cref="PixelTransfer"/>
        /// <seealso cref="ReadBuffer"/>
        /// <seealso cref="TexEnv"/>
        /// <seealso cref="TexGen"/>
        /// <seealso cref="TexImage1D"/>
        /// <seealso cref="TexImage2D"/>
        /// <seealso cref="TexImage3D"/>
        /// <seealso cref="TexParameter"/>
        /// <seealso cref="TexSubImage1D"/>
        /// <seealso cref="TexSubImage2D"/>
        /// <seealso cref="TexSubImage3D"/>
        public static void CopyTexSubImage2D(uint target, int level, int xoffset, int yoffset, int x, int y, int width, int height) {
            GLNative.glCopyTexSubImage2D(target, level, xoffset, yoffset, x, y, width, height);
        }

        /// <summary>
        /// bind a named texture to a texturing target
        /// <para>Require:</para> <para>GL_VERSION_1_1, GL_VERSION_ES_CM_1_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glBindTexture"/> is available only if the GL version is 1.1 or greater.
        /// <code>GL_TEXTURE_CUBE_MAP</code> is available only if the GL version is 1.3 or greater.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="target"/> is not one of the allowable
        /// values.
        /// <code>GL_INVALID_OPERATION</code> is generated if <paramref name="texture"/> was previously created with a target
        /// that doesn't match that of <paramref name="target"/>.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glBindTexture"/> is executed
        /// between the execution of  <see cref="glBegin"/>  and the corresponding
        /// execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glBindTexture(GLenum target, GLuint texture);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target to which the texture is bound.
        /// Must be either
        /// <code>GL_TEXTURE_1D</code>,
        /// <code>GL_TEXTURE_2D</code>,
        /// <code>GL_TEXTURE_3D</code>, or
        /// <code>GL_TEXTURE_CUBE_MAP</code>.
        /// </para>
        /// </param>
        /// <param name="texture">
        /// Specifies the name of a texture.
        /// </param>
        /// <seealso cref="AreTexturesResident"/>
        /// <seealso cref="DeleteTextures"/>
        /// <seealso cref="GenTextures"/>
        /// <seealso cref="Get"/>
        /// <seealso cref="GetTexParameter"/>
        /// <seealso cref="IsTexture"/>
        /// <seealso cref="PrioritizeTextures"/>
        /// <seealso cref="TexImage1D"/>
        /// <seealso cref="TexImage2D"/>
        /// <seealso cref="TexParameter"/>
        public static void BindTexture(uint target, uint texture) {
            GLNative.glBindTexture(target, texture);
        }

        /// <summary>
        /// determine if a name corresponds to a texture
        /// <para>Require:</para> <para>GL_VERSION_1_1, GL_VERSION_ES_CM_1_0, GL_ES_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <see cref="glIsTexture"/> is available only if the GL version is 1.1 or greater.
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glIsTexture"/> is executed
        /// between the execution of  <see cref="glBegin"/>  and the corresponding
        /// execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>GLboolean glIsTexture(GLuint texture);</para>
        /// </summary>
        /// <param name="texture">
        /// Specifies a value that may be the name of a texture.
        /// </param>
        /// <seealso cref="BindTexture"/>
        /// <seealso cref="CopyTexImage1D"/>
        /// <seealso cref="CopyTexImage2D"/>
        /// <seealso cref="DeleteTextures"/>
        /// <seealso cref="GenTextures"/>
        /// <seealso cref="Get"/>
        /// <seealso cref="GetTexParameter"/>
        /// <seealso cref="TexImage1D"/>
        /// <seealso cref="TexImage2D"/>
        /// <seealso cref="TexImage3D"/>
        /// <seealso cref="TexParameter"/>
        public static bool IsTexture(uint texture) {
            return GLNative.glIsTexture(texture);
        }

        /// <summary>
        /// render a vertex using the specified vertex array element
        /// <para>Require:</para> <para>GL_VERSION_1_1</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glArrayElement"/> is available only if the GL version is 1.1 or greater.
        /// <see cref="glArrayElement"/> is included in display lists. If <see cref="glArrayElement"/> is entered into a
        /// display list, the necessary array data (determined by the array
        /// pointers and enables) is also entered into the display list. Because
        /// the array pointers and enables are client-side state, their values
        /// affect display lists when the lists are created, not when the lists
        /// are executed.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> may be generated if <paramref name="i"/> is negative.
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to an
        /// enabled array and the buffer object's data store is currently mapped.
        /// </para>
        /// Original: <para>void glArrayElement(GLint i);</para>
        /// </summary>
        /// <param name="i">
        /// Specifies an index into the enabled vertex data arrays.
        /// </param>
        /// <seealso cref="ClientActiveTexture"/>
        /// <seealso cref="ColorPointer"/>
        /// <seealso cref="DrawArrays"/>
        /// <seealso cref="EdgeFlagPointer"/>
        /// <seealso cref="FogCoordPointer"/>
        /// <seealso cref="GetPointerv"/>
        /// <seealso cref="IndexPointer"/>
        /// <seealso cref="InterleavedArrays"/>
        /// <seealso cref="NormalPointer"/>
        /// <seealso cref="SecondaryColorPointer"/>
        /// <seealso cref="TexCoordPointer"/>
        /// <seealso cref="VertexPointer"/>
        [Obsolete("Compatibility-only GL 1.1 features removed from GL 3.2")]
        public static void ArrayElement(int i) {
            GLNative.glArrayElement(i);
        }

        /// <summary>
        /// enable or disable client-side capability
        /// <para>Require:</para> <para>GL_VERSION_1_1, GL_VERSION_ES_CM_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glEnableClientState"/> is available only if the GL version is 1.1 or greater.
        /// <code>GL_FOG_COORD_ARRAY</code> and <code>GL_SECONDARY_COLOR_ARRAY</code> are available only if the GL version is 1.4 or
        /// greater.
        /// For OpenGL versions 1.3 and greater, or when <code>ARB_multitexture</code> is supported, enabling and disabling
        /// <code>GL_TEXTURE_COORD_ARRAY</code> affects the active client texture unit.
        /// The active client texture unit is controlled with
        /// <see cref="glClientActiveTexture"/> .
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="cap"/> is not an accepted value.
        /// <see cref="glEnableClientState"/> is not allowed between the execution of  <see cref="glBegin"/>  and the
        /// corresponding  <see cref="glEnd"/> , but an error may or may not be generated. If
        /// no error is generated, the behavior is undefined.
        /// </para>
        /// Original: <para>void glDisableClientState(GLenum cap);</para>
        /// </summary>
        /// <param name="cap">
        /// Specifies the capability to disable.
        /// </param>
        /// <seealso cref="ArrayElement"/>
        /// <seealso cref="ClientActiveTexture"/>
        /// <seealso cref="ColorPointer"/>
        /// <seealso cref="DrawArrays"/>
        /// <seealso cref="DrawElements"/>
        /// <seealso cref="EdgeFlagPointer"/>
        /// <seealso cref="FogCoordPointer"/>
        /// <seealso cref="Enable"/>
        /// <seealso cref="GetPointerv"/>
        /// <seealso cref="IndexPointer"/>
        /// <seealso cref="InterleavedArrays"/>
        /// <seealso cref="NormalPointer"/>
        /// <seealso cref="SecondaryColorPointer"/>
        /// <seealso cref="TexCoordPointer"/>
        /// <seealso cref="VertexPointer"/>
        [Obsolete("Compatibility-only GL 1.1 features removed from GL 3.2")]
        public static void DisableClientState(uint cap) {
            GLNative.glDisableClientState(cap);
        }

        /// <summary>
        /// enable or disable client-side capability
        /// <para>Require:</para> <para>GL_VERSION_1_1, GL_VERSION_ES_CM_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glEnableClientState"/> is available only if the GL version is 1.1 or greater.
        /// <code>GL_FOG_COORD_ARRAY</code> and <code>GL_SECONDARY_COLOR_ARRAY</code> are available only if the GL version is 1.4 or
        /// greater.
        /// For OpenGL versions 1.3 and greater, or when <code>ARB_multitexture</code> is supported, enabling and disabling
        /// <code>GL_TEXTURE_COORD_ARRAY</code> affects the active client texture unit.
        /// The active client texture unit is controlled with
        /// <see cref="glClientActiveTexture"/> .
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="cap"/> is not an accepted value.
        /// <see cref="glEnableClientState"/> is not allowed between the execution of  <see cref="glBegin"/>  and the
        /// corresponding  <see cref="glEnd"/> , but an error may or may not be generated. If
        /// no error is generated, the behavior is undefined.
        /// </para>
        /// Original: <para>void glEnableClientState(GLenum cap);</para>
        /// </summary>
        /// <param name="cap">
        /// <para>
        /// Specifies the capability to enable.
        /// Symbolic constants
        /// <code>GL_COLOR_ARRAY</code>,
        /// <code>GL_EDGE_FLAG_ARRAY</code>,
        /// <code>GL_FOG_COORD_ARRAY</code>,
        /// <code>GL_INDEX_ARRAY</code>,
        /// <code>GL_NORMAL_ARRAY</code>,
        /// <code>GL_SECONDARY_COLOR_ARRAY</code>,
        /// <code>GL_TEXTURE_COORD_ARRAY</code>, and
        /// <code>GL_VERTEX_ARRAY</code>
        /// are accepted.
        /// </para>
        /// </param>
        /// <seealso cref="ArrayElement"/>
        /// <seealso cref="ClientActiveTexture"/>
        /// <seealso cref="ColorPointer"/>
        /// <seealso cref="DrawArrays"/>
        /// <seealso cref="DrawElements"/>
        /// <seealso cref="EdgeFlagPointer"/>
        /// <seealso cref="FogCoordPointer"/>
        /// <seealso cref="Enable"/>
        /// <seealso cref="GetPointerv"/>
        /// <seealso cref="IndexPointer"/>
        /// <seealso cref="InterleavedArrays"/>
        /// <seealso cref="NormalPointer"/>
        /// <seealso cref="SecondaryColorPointer"/>
        /// <seealso cref="TexCoordPointer"/>
        /// <seealso cref="VertexPointer"/>
        [Obsolete("Compatibility-only GL 1.1 features removed from GL 3.2")]
        public static void EnableClientState(uint cap) {
            GLNative.glEnableClientState(cap);
        }

        /// <summary>
        /// set the current color index
        /// <para>Require:</para> <para>GL_VERSION_1_1</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glIndexub"/> and <see cref="glIndexubv"/> are available only if the GL version is
        /// 1.1 or greater.
        /// The current index can be updated at any time.
        /// In particular,
        /// <see cref="glIndex"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glIndexub(GLubyte c);</para>
        /// </summary>
        /// <param name="c">
        /// Specifies the new value for the current color index.
        /// </param>
        /// <seealso cref="Color"/>
        /// <seealso cref="IndexPointer"/>
        [Obsolete("Compatibility-only GL 1.1 features removed from GL 3.2")]
        public static void Indexub(byte c) {
            GLNative.glIndexub(c);
        }

        /// <summary>
        /// push and pop the client attribute stack
        /// <para>Require:</para> <para>GL_VERSION_1_1</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glPushClientAttrib"/> is available only if the GL version is 1.1 or greater.
        /// Not all values for GL client state can be saved on the attribute stack.
        /// For example, select and feedback state cannot be saved.
        /// The depth of the attribute stack depends on the implementation,
        /// but it must be at least 16.
        /// Use  <see cref="glPushAttrib"/>  and  <see cref="glPopAttrib"/>  to push and restore
        /// state that is kept on the server. Only pixel storage modes and
        /// vertex array state may be pushed and popped with
        /// <see cref="glPushClientAttrib"/> and  <see cref="glPopClientAttrib"/> .
        /// For OpenGL versions 1.3 and greater, or when the <code>ARB_multitexture</code> extension is supported, pushing and
        /// popping client vertex array state applies to all supported texture units,
        /// and the active client texture state.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_STACK_OVERFLOW</code> is generated if <see cref="glPushClientAttrib"/> is called while
        /// the attribute stack is full.
        /// <code>GL_STACK_UNDERFLOW</code> is generated if  <see cref="glPopClientAttrib"/>  is called while
        /// the attribute stack is empty.
        /// </para>
        /// Original: <para>void glPopClientAttrib();</para>
        /// </summary>
        /// <seealso cref="ColorPointer"/>
        /// <seealso cref="DisableClientState"/>
        /// <seealso cref="EdgeFlagPointer"/>
        /// <seealso cref="EnableClientState"/>
        /// <seealso cref="FogCoordPointer"/>
        /// <seealso cref="Get"/>
        /// <seealso cref="GetError"/>
        /// <seealso cref="IndexPointer"/>
        /// <seealso cref="NormalPointer"/>
        /// <seealso cref="NewList"/>
        /// <seealso cref="PixelStore"/>
        /// <seealso cref="PushAttrib"/>
        /// <seealso cref="TexCoordPointer"/>
        /// <seealso cref="VertexPointer"/>
        [Obsolete("Compatibility-only GL 1.1 features removed from GL 3.2")]
        public static void PopClientAttrib() {
            GLNative.glPopClientAttrib();
        }

        /// <summary>
        /// push and pop the client attribute stack
        /// <para>Require:</para> <para>GL_VERSION_1_1</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glPushClientAttrib"/> is available only if the GL version is 1.1 or greater.
        /// Not all values for GL client state can be saved on the attribute stack.
        /// For example, select and feedback state cannot be saved.
        /// The depth of the attribute stack depends on the implementation,
        /// but it must be at least 16.
        /// Use  <see cref="glPushAttrib"/>  and  <see cref="glPopAttrib"/>  to push and restore
        /// state that is kept on the server. Only pixel storage modes and
        /// vertex array state may be pushed and popped with
        /// <see cref="glPushClientAttrib"/> and  <see cref="glPopClientAttrib"/> .
        /// For OpenGL versions 1.3 and greater, or when the <code>ARB_multitexture</code> extension is supported, pushing and
        /// popping client vertex array state applies to all supported texture units,
        /// and the active client texture state.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_STACK_OVERFLOW</code> is generated if <see cref="glPushClientAttrib"/> is called while
        /// the attribute stack is full.
        /// <code>GL_STACK_UNDERFLOW</code> is generated if  <see cref="glPopClientAttrib"/>  is called while
        /// the attribute stack is empty.
        /// </para>
        /// Original: <para>void glPushClientAttrib(GLbitfield mask);</para>
        /// </summary>
        /// <param name="mask">
        /// <para>
        /// Specifies a mask that indicates which attributes to save.  Values for
        /// <paramref name="mask"/> are listed below.
        /// </para>
        /// </param>
        /// <seealso cref="ColorPointer"/>
        /// <seealso cref="DisableClientState"/>
        /// <seealso cref="EdgeFlagPointer"/>
        /// <seealso cref="EnableClientState"/>
        /// <seealso cref="FogCoordPointer"/>
        /// <seealso cref="Get"/>
        /// <seealso cref="GetError"/>
        /// <seealso cref="IndexPointer"/>
        /// <seealso cref="NormalPointer"/>
        /// <seealso cref="NewList"/>
        /// <seealso cref="PixelStore"/>
        /// <seealso cref="PushAttrib"/>
        /// <seealso cref="TexCoordPointer"/>
        /// <seealso cref="VertexPointer"/>
        [Obsolete("Compatibility-only GL 1.1 features removed from GL 3.2")]
        public static void PushClientAttrib(uint mask) {
            GLNative.glPushClientAttrib(mask);
        }


        #endregion GL_VERSION_1_1

        #region GL_VERSION_1_2

        /// <summary>
        /// copy a three-dimensional texture subimage
        /// <para>Require:</para> <para>GL_VERSION_1_2, GL_ES_VERSION_3_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glCopyTexSubImage3D"/> is available only if the GL version is 1.2 or greater.
        /// Texturing has no effect in color index mode.
        /// <see cref="glPixelStore"/>  and  <see cref="glPixelTransfer"/>  modes affect texture images
        /// in exactly the way they affect  <see cref="glDrawPixels"/> .
        /// When the <code>ARB_imaging</code> extension is supported, the RGBA components
        /// copied from the framebuffer may be processed by the imaging pipeline, as
        /// if they were a two-dimensional texture.  See  <see cref="glTexImage2D"/>  for
        /// specific details.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if /<paramref name="target"/> is not <code>GL_TEXTURE_3D</code>.
        /// <code>GL_INVALID_OPERATION</code> is generated if the texture array has not
        /// been defined by a previous  <see cref="glTexImage3D"/>  operation.
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="level"/> is less than 0.
        /// <code>GL_INVALID_VALUE</code> may be generated if 
        /// log sub 2(max):-->
        /// level 
        /// &gt; 
        /// log 
        /// 2 
        /// &af; 
        /// max 
        /// ,
        /// where 
        /// max   
        /// is the returned value of <code>GL_MAX_3D_TEXTURE_SIZE</code>.
        /// <code>GL_INVALID_VALUE</code> is generated if 
        /// xoffset 
        /// &lt; 
        /// - 
        /// b 
        /// ,
        /// (w  - b):-->
        /// xoffset 
        /// + 
        /// width 
        /// &gt; 
        /// w 
        /// - 
        /// b 
        /// ,
        /// yoffset 
        /// &lt; 
        /// - 
        /// b 
        /// ,
        /// (h  - b):-->
        /// yoffset 
        /// + 
        /// height 
        /// &gt; 
        /// h 
        /// - 
        /// b 
        /// ,
        /// zoffset 
        /// &lt; 
        /// - 
        /// b 
        /// ,
        /// or 
        /// (d  - b):-->
        /// zoffset 
        /// + 
        /// 1 
        /// &gt; 
        /// d 
        /// - 
        /// b 
        /// ,
        /// where 
        /// w   
        /// is the <code>GL_TEXTURE_WIDTH</code>,
        /// h   
        /// is the <code>GL_TEXTURE_HEIGHT</code>,
        /// d   
        /// is the <code>GL_TEXTURE_DEPTH</code>,
        /// and 
        /// b   
        /// is the <code>GL_TEXTURE_BORDER</code>
        /// of the texture image being modified.
        /// Note that 
        /// w   , 
        /// h   ,
        /// and 
        /// d   
        /// include twice the border width.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glCopyTexSubImage3D"/> is executed
        /// between the execution of  <see cref="glBegin"/>  and the corresponding
        /// execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glCopyTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target texture.
        /// Must be <code>GL_TEXTURE_3D</code>
        /// </para>
        /// </param>
        /// <param name="level">
        /// <para>
        /// Specifies the level-of-detail number.
        /// Level 0 is the base image level.
        /// Level  n  is the  n th mipmap reduction image.
        /// </para>
        /// </param>
        /// <param name="xoffset">
        /// Specifies a texel offset in the x direction within the texture array.
        /// </param>
        /// <param name="yoffset">
        /// Specifies a texel offset in the y direction within the texture array.
        /// </param>
        /// <param name="zoffset">
        /// Specifies a texel offset in the z direction within the texture array.
        /// </param>
        /// <param name="x">
        /// <para>
        /// Specify the window coordinates of the lower left corner
        /// of the rectangular region of pixels to be copied.
        /// </para>
        /// </param>
        /// <param name="y">
        /// <para>
        /// Specify the window coordinates of the lower left corner
        /// of the rectangular region of pixels to be copied.
        /// </para>
        /// </param>
        /// <param name="width">
        /// Specifies the width of the texture subimage.
        /// </param>
        /// <param name="height">
        /// Specifies the height of the texture subimage.
        /// </param>
        /// <seealso cref="CopyPixels"/>
        /// <seealso cref="CopyTexImage1D"/>
        /// <seealso cref="CopyTexImage2D"/>
        /// <seealso cref="CopyTexSubImage1D"/>
        /// <seealso cref="CopyTexSubImage2D"/>
        /// <seealso cref="PixelStore"/>
        /// <seealso cref="PixelTransfer"/>
        /// <seealso cref="ReadBuffer"/>
        /// <seealso cref="TexEnv"/>
        /// <seealso cref="TexGen"/>
        /// <seealso cref="TexImage1D"/>
        /// <seealso cref="TexImage2D"/>
        /// <seealso cref="TexImage3D"/>
        /// <seealso cref="TexParameter"/>
        /// <seealso cref="TexSubImage1D"/>
        /// <seealso cref="TexSubImage2D"/>
        /// <seealso cref="TexSubImage3D"/>
        public static void CopyTexSubImage3D(uint target, int level, int xoffset, int yoffset, int zoffset, int x, int y, int width, int height) {
            GLNative.glCopyTexSubImage3D(target, level, xoffset, yoffset, zoffset, x, y, width, height);
        }


        #endregion GL_VERSION_1_2

        #region GL_VERSION_1_3

        /// <summary>
        /// select active texture unit
        /// <para>Require:</para> <para>GL_VERSION_1_3, GL_VERSION_ES_CM_1_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glActiveTexture"/> is only supported if the GL version is 1.3 or greater, or if
        /// <code>ARB_multitexture</code> is included in the string returned by
        /// <see cref="glGetString"/>  when called with the argument <code>GL_EXTENSIONS</code>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="texture"/> is not one of
        /// <code>GL_TEXTURE</code>   i   ,
        /// where i ranges from 0 to the larger of (<code>GL_MAX_TEXTURE_COORDS</code> - 1)
        /// and (<code>GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS</code> - 1).
        /// </para>
        /// Original: <para>void glActiveTexture(GLenum texture);</para>
        /// </summary>
        /// <param name="texture">
        /// <para>
        /// Specifies which texture unit to make active. The number
        /// of texture units is implementation dependent, but must be at least
        /// two. <paramref name="texture"/> must be one of 
        /// <code>GL_TEXTURE</code>   i   ,
        /// where
        /// i ranges from 0 to the larger of (<code>GL_MAX_TEXTURE_COORDS</code> - 1)
        /// and (<code>GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS</code> - 1). 
        /// The initial value is <code>GL_TEXTURE0</code>.
        /// </para>
        /// </param>
        /// <seealso cref="ClientActiveTexture"/>
        /// <seealso cref="MultiTexCoord"/>
        /// <seealso cref="TexParameter"/>
        public static void ActiveTexture(uint texture) {
            GLNative.glActiveTexture(texture);
        }

        /// <summary>
        /// specify multisample coverage parameters
        /// <para>Require:</para> <para>GL_VERSION_1_3, GL_VERSION_ES_CM_1_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <see cref="glSampleCoverage"/> is available only if the GL version is 1.3 or greater.
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glSampleCoverage"/> is executed between the
        /// execution of  <see cref="glBegin"/>  and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glSampleCoverage(GLclampf value, GLboolean invert);</para>
        /// </summary>
        /// <param name="value">
        /// <para>
        /// Specify a single floating-point sample coverage value.  The value is
        /// clamped to the range 
        /// 0 
        /// 1 
        /// .
        /// The initial value is 1.0.
        /// </para>
        /// </param>
        /// <param name="invert">
        /// <para>
        /// Specify a single boolean value representing if the coverage masks should be
        /// inverted.  <code>GL_TRUE</code> and <code>GL_FALSE</code> are accepted.  The initial value
        /// is <code>GL_FALSE</code>.
        /// </para>
        /// </param>
        /// <seealso cref="Enable"/>
        /// <seealso cref="PushAttrib"/>
        public static void SampleCoverage(float value, bool invert) {
            GLNative.glSampleCoverage(value, invert);
        }

        /// <summary>
        /// select active texture unit
        /// <para>Require:</para> <para>GL_VERSION_1_3, GL_VERSION_ES_CM_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glClientActiveTexture"/> is supported only if the GL version is 1.3 or greater, or
        /// <code>ARB_multitexture</code> is included in the string returned by
        /// <see cref="glGetString"/>  when called with the argument <code>GL_EXTENSIONS</code>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="texture"/> is not one of
        /// <code>GL_TEXTURE</code>   i   ,
        /// where
        /// i ranges from 0 to the value of <code>GL_MAX_TEXTURE_COORDS</code> - 1.
        /// </para>
        /// Original: <para>void glClientActiveTexture(GLenum texture);</para>
        /// </summary>
        /// <param name="texture">
        /// <para>
        /// Specifies which texture unit to make active. The number
        /// of texture units is implementation dependent, but must be at least
        /// two. <paramref name="texture"/> must be one of 
        /// <code>GL_TEXTURE</code>   i   ,
        /// where i ranges from 0 to the value of <code>GL_MAX_TEXTURE_COORDS</code> - 1, which is an
        /// implementation-dependent value.  The initial value is
        /// <code>GL_TEXTURE0</code>.
        /// </para>
        /// </param>
        /// <seealso cref="ActiveTexture"/>
        /// <seealso cref="DisableClientState"/>
        /// <seealso cref="EnableClientState"/>
        /// <seealso cref="MultiTexCoord"/>
        /// <seealso cref="TexCoordPointer"/>
        [Obsolete("Compatibility-only GL 1.3 features removed from GL 3.2")]
        public static void ClientActiveTexture(uint texture) {
            GLNative.glClientActiveTexture(texture);
        }

        /// <summary>
        /// set the current texture coordinates
        /// <para>Require:</para> <para>GL_VERSION_1_3</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glMultiTexCoord"/> is only supported if the GL version is 1.3 or greater, or if
        /// <code>ARB_multitexture</code> is included in the string returned by
        /// <see cref="glGetString"/>  when called with the argument <code>GL_EXTENSIONS</code>.
        /// The current texture coordinates can be updated at any time.
        /// In particular,
        /// <see cref="glMultiTexCoord"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// It is always the case that <code>GL_TEXTURE</code>
        /// i   
        /// = <code>GL_TEXTURE0</code> + 
        /// i   .
        /// </para>
        /// Original: <para>void glMultiTexCoord1d(GLenum target, GLdouble s);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the texture unit whose coordinates should be modified. The number
        /// of texture units is implementation dependent, but must be at least
        /// two. Symbolic constant must be one of 
        /// <code>GL_TEXTURE</code>   i   ,
        /// where i ranges from 0 to <code>GL_MAX_TEXTURE_COORDS</code> - 1,
        /// which is an implementation-dependent value.
        /// </para>
        /// </param>
        /// <param name="s">
        /// <para>
        /// Specify <paramref name="s"/>, <paramref name="t"/>, <paramref name="r"/>, and <paramref name="q"/> texture coordinates for
        /// <paramref name="target"/> texture unit. Not all parameters are present in all forms
        /// of the command.
        /// </para>
        /// </param>
        /// <seealso cref="ActiveTexture"/>
        /// <seealso cref="ClientActiveTexture"/>
        /// <seealso cref="TexCoord"/>
        /// <seealso cref="TexCoordPointer"/>
        /// <seealso cref="Vertex"/>
        [Obsolete("Compatibility-only GL 1.3 features removed from GL 3.2")]
        public static void MultiTexCoord1d(uint target, double s) {
            GLNative.glMultiTexCoord1d(target, s);
        }

        /// <summary>
        /// set the current texture coordinates
        /// <para>Require:</para> <para>GL_VERSION_1_3</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glMultiTexCoord"/> is only supported if the GL version is 1.3 or greater, or if
        /// <code>ARB_multitexture</code> is included in the string returned by
        /// <see cref="glGetString"/>  when called with the argument <code>GL_EXTENSIONS</code>.
        /// The current texture coordinates can be updated at any time.
        /// In particular,
        /// <see cref="glMultiTexCoord"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// It is always the case that <code>GL_TEXTURE</code>
        /// i   
        /// = <code>GL_TEXTURE0</code> + 
        /// i   .
        /// </para>
        /// Original: <para>void glMultiTexCoord1f(GLenum target, GLfloat s);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the texture unit whose coordinates should be modified. The number
        /// of texture units is implementation dependent, but must be at least
        /// two. Symbolic constant must be one of 
        /// <code>GL_TEXTURE</code>   i   ,
        /// where i ranges from 0 to <code>GL_MAX_TEXTURE_COORDS</code> - 1,
        /// which is an implementation-dependent value.
        /// </para>
        /// </param>
        /// <param name="s">
        /// <para>
        /// Specify <paramref name="s"/>, <paramref name="t"/>, <paramref name="r"/>, and <paramref name="q"/> texture coordinates for
        /// <paramref name="target"/> texture unit. Not all parameters are present in all forms
        /// of the command.
        /// </para>
        /// </param>
        /// <seealso cref="ActiveTexture"/>
        /// <seealso cref="ClientActiveTexture"/>
        /// <seealso cref="TexCoord"/>
        /// <seealso cref="TexCoordPointer"/>
        /// <seealso cref="Vertex"/>
        [Obsolete("Compatibility-only GL 1.3 features removed from GL 3.2")]
        public static void MultiTexCoord1f(uint target, float s) {
            GLNative.glMultiTexCoord1f(target, s);
        }

        /// <summary>
        /// set the current texture coordinates
        /// <para>Require:</para> <para>GL_VERSION_1_3</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glMultiTexCoord"/> is only supported if the GL version is 1.3 or greater, or if
        /// <code>ARB_multitexture</code> is included in the string returned by
        /// <see cref="glGetString"/>  when called with the argument <code>GL_EXTENSIONS</code>.
        /// The current texture coordinates can be updated at any time.
        /// In particular,
        /// <see cref="glMultiTexCoord"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// It is always the case that <code>GL_TEXTURE</code>
        /// i   
        /// = <code>GL_TEXTURE0</code> + 
        /// i   .
        /// </para>
        /// Original: <para>void glMultiTexCoord1i(GLenum target, GLint s);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the texture unit whose coordinates should be modified. The number
        /// of texture units is implementation dependent, but must be at least
        /// two. Symbolic constant must be one of 
        /// <code>GL_TEXTURE</code>   i   ,
        /// where i ranges from 0 to <code>GL_MAX_TEXTURE_COORDS</code> - 1,
        /// which is an implementation-dependent value.
        /// </para>
        /// </param>
        /// <param name="s">
        /// <para>
        /// Specify <paramref name="s"/>, <paramref name="t"/>, <paramref name="r"/>, and <paramref name="q"/> texture coordinates for
        /// <paramref name="target"/> texture unit. Not all parameters are present in all forms
        /// of the command.
        /// </para>
        /// </param>
        /// <seealso cref="ActiveTexture"/>
        /// <seealso cref="ClientActiveTexture"/>
        /// <seealso cref="TexCoord"/>
        /// <seealso cref="TexCoordPointer"/>
        /// <seealso cref="Vertex"/>
        [Obsolete("Compatibility-only GL 1.3 features removed from GL 3.2")]
        public static void MultiTexCoord1i(uint target, int s) {
            GLNative.glMultiTexCoord1i(target, s);
        }

        /// <summary>
        /// set the current texture coordinates
        /// <para>Require:</para> <para>GL_VERSION_1_3</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glMultiTexCoord"/> is only supported if the GL version is 1.3 or greater, or if
        /// <code>ARB_multitexture</code> is included in the string returned by
        /// <see cref="glGetString"/>  when called with the argument <code>GL_EXTENSIONS</code>.
        /// The current texture coordinates can be updated at any time.
        /// In particular,
        /// <see cref="glMultiTexCoord"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// It is always the case that <code>GL_TEXTURE</code>
        /// i   
        /// = <code>GL_TEXTURE0</code> + 
        /// i   .
        /// </para>
        /// Original: <para>void glMultiTexCoord1s(GLenum target, GLshort s);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the texture unit whose coordinates should be modified. The number
        /// of texture units is implementation dependent, but must be at least
        /// two. Symbolic constant must be one of 
        /// <code>GL_TEXTURE</code>   i   ,
        /// where i ranges from 0 to <code>GL_MAX_TEXTURE_COORDS</code> - 1,
        /// which is an implementation-dependent value.
        /// </para>
        /// </param>
        /// <param name="s">
        /// <para>
        /// Specify <paramref name="s"/>, <paramref name="t"/>, <paramref name="r"/>, and <paramref name="q"/> texture coordinates for
        /// <paramref name="target"/> texture unit. Not all parameters are present in all forms
        /// of the command.
        /// </para>
        /// </param>
        /// <seealso cref="ActiveTexture"/>
        /// <seealso cref="ClientActiveTexture"/>
        /// <seealso cref="TexCoord"/>
        /// <seealso cref="TexCoordPointer"/>
        /// <seealso cref="Vertex"/>
        [Obsolete("Compatibility-only GL 1.3 features removed from GL 3.2")]
        public static void MultiTexCoord1s(uint target, short s) {
            GLNative.glMultiTexCoord1s(target, s);
        }

        /// <summary>
        /// set the current texture coordinates
        /// <para>Require:</para> <para>GL_VERSION_1_3</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glMultiTexCoord"/> is only supported if the GL version is 1.3 or greater, or if
        /// <code>ARB_multitexture</code> is included in the string returned by
        /// <see cref="glGetString"/>  when called with the argument <code>GL_EXTENSIONS</code>.
        /// The current texture coordinates can be updated at any time.
        /// In particular,
        /// <see cref="glMultiTexCoord"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// It is always the case that <code>GL_TEXTURE</code>
        /// i   
        /// = <code>GL_TEXTURE0</code> + 
        /// i   .
        /// </para>
        /// Original: <para>void glMultiTexCoord2d(GLenum target, GLdouble s, GLdouble t);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the texture unit whose coordinates should be modified. The number
        /// of texture units is implementation dependent, but must be at least
        /// two. Symbolic constant must be one of 
        /// <code>GL_TEXTURE</code>   i   ,
        /// where i ranges from 0 to <code>GL_MAX_TEXTURE_COORDS</code> - 1,
        /// which is an implementation-dependent value.
        /// </para>
        /// </param>
        /// <param name="s">
        /// <para>
        /// Specify <paramref name="s"/>, <paramref name="t"/>, <paramref name="r"/>, and <paramref name="q"/> texture coordinates for
        /// <paramref name="target"/> texture unit. Not all parameters are present in all forms
        /// of the command.
        /// </para>
        /// </param>
        /// <param name="t">
        /// <para>
        /// Specify <paramref name="s"/>, <paramref name="t"/>, <paramref name="r"/>, and <paramref name="q"/> texture coordinates for
        /// <paramref name="target"/> texture unit. Not all parameters are present in all forms
        /// of the command.
        /// </para>
        /// </param>
        /// <seealso cref="ActiveTexture"/>
        /// <seealso cref="ClientActiveTexture"/>
        /// <seealso cref="TexCoord"/>
        /// <seealso cref="TexCoordPointer"/>
        /// <seealso cref="Vertex"/>
        [Obsolete("Compatibility-only GL 1.3 features removed from GL 3.2")]
        public static void MultiTexCoord2d(uint target, double s, double t) {
            GLNative.glMultiTexCoord2d(target, s, t);
        }

        /// <summary>
        /// set the current texture coordinates
        /// <para>Require:</para> <para>GL_VERSION_1_3</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glMultiTexCoord"/> is only supported if the GL version is 1.3 or greater, or if
        /// <code>ARB_multitexture</code> is included in the string returned by
        /// <see cref="glGetString"/>  when called with the argument <code>GL_EXTENSIONS</code>.
        /// The current texture coordinates can be updated at any time.
        /// In particular,
        /// <see cref="glMultiTexCoord"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// It is always the case that <code>GL_TEXTURE</code>
        /// i   
        /// = <code>GL_TEXTURE0</code> + 
        /// i   .
        /// </para>
        /// Original: <para>void glMultiTexCoord2f(GLenum target, GLfloat s, GLfloat t);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the texture unit whose coordinates should be modified. The number
        /// of texture units is implementation dependent, but must be at least
        /// two. Symbolic constant must be one of 
        /// <code>GL_TEXTURE</code>   i   ,
        /// where i ranges from 0 to <code>GL_MAX_TEXTURE_COORDS</code> - 1,
        /// which is an implementation-dependent value.
        /// </para>
        /// </param>
        /// <param name="s">
        /// <para>
        /// Specify <paramref name="s"/>, <paramref name="t"/>, <paramref name="r"/>, and <paramref name="q"/> texture coordinates for
        /// <paramref name="target"/> texture unit. Not all parameters are present in all forms
        /// of the command.
        /// </para>
        /// </param>
        /// <param name="t">
        /// <para>
        /// Specify <paramref name="s"/>, <paramref name="t"/>, <paramref name="r"/>, and <paramref name="q"/> texture coordinates for
        /// <paramref name="target"/> texture unit. Not all parameters are present in all forms
        /// of the command.
        /// </para>
        /// </param>
        /// <seealso cref="ActiveTexture"/>
        /// <seealso cref="ClientActiveTexture"/>
        /// <seealso cref="TexCoord"/>
        /// <seealso cref="TexCoordPointer"/>
        /// <seealso cref="Vertex"/>
        [Obsolete("Compatibility-only GL 1.3 features removed from GL 3.2")]
        public static void MultiTexCoord2f(uint target, float s, float t) {
            GLNative.glMultiTexCoord2f(target, s, t);
        }

        /// <summary>
        /// set the current texture coordinates
        /// <para>Require:</para> <para>GL_VERSION_1_3</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glMultiTexCoord"/> is only supported if the GL version is 1.3 or greater, or if
        /// <code>ARB_multitexture</code> is included in the string returned by
        /// <see cref="glGetString"/>  when called with the argument <code>GL_EXTENSIONS</code>.
        /// The current texture coordinates can be updated at any time.
        /// In particular,
        /// <see cref="glMultiTexCoord"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// It is always the case that <code>GL_TEXTURE</code>
        /// i   
        /// = <code>GL_TEXTURE0</code> + 
        /// i   .
        /// </para>
        /// Original: <para>void glMultiTexCoord2i(GLenum target, GLint s, GLint t);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the texture unit whose coordinates should be modified. The number
        /// of texture units is implementation dependent, but must be at least
        /// two. Symbolic constant must be one of 
        /// <code>GL_TEXTURE</code>   i   ,
        /// where i ranges from 0 to <code>GL_MAX_TEXTURE_COORDS</code> - 1,
        /// which is an implementation-dependent value.
        /// </para>
        /// </param>
        /// <param name="s">
        /// <para>
        /// Specify <paramref name="s"/>, <paramref name="t"/>, <paramref name="r"/>, and <paramref name="q"/> texture coordinates for
        /// <paramref name="target"/> texture unit. Not all parameters are present in all forms
        /// of the command.
        /// </para>
        /// </param>
        /// <param name="t">
        /// <para>
        /// Specify <paramref name="s"/>, <paramref name="t"/>, <paramref name="r"/>, and <paramref name="q"/> texture coordinates for
        /// <paramref name="target"/> texture unit. Not all parameters are present in all forms
        /// of the command.
        /// </para>
        /// </param>
        /// <seealso cref="ActiveTexture"/>
        /// <seealso cref="ClientActiveTexture"/>
        /// <seealso cref="TexCoord"/>
        /// <seealso cref="TexCoordPointer"/>
        /// <seealso cref="Vertex"/>
        [Obsolete("Compatibility-only GL 1.3 features removed from GL 3.2")]
        public static void MultiTexCoord2i(uint target, int s, int t) {
            GLNative.glMultiTexCoord2i(target, s, t);
        }

        /// <summary>
        /// set the current texture coordinates
        /// <para>Require:</para> <para>GL_VERSION_1_3</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glMultiTexCoord"/> is only supported if the GL version is 1.3 or greater, or if
        /// <code>ARB_multitexture</code> is included in the string returned by
        /// <see cref="glGetString"/>  when called with the argument <code>GL_EXTENSIONS</code>.
        /// The current texture coordinates can be updated at any time.
        /// In particular,
        /// <see cref="glMultiTexCoord"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// It is always the case that <code>GL_TEXTURE</code>
        /// i   
        /// = <code>GL_TEXTURE0</code> + 
        /// i   .
        /// </para>
        /// Original: <para>void glMultiTexCoord2s(GLenum target, GLshort s, GLshort t);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the texture unit whose coordinates should be modified. The number
        /// of texture units is implementation dependent, but must be at least
        /// two. Symbolic constant must be one of 
        /// <code>GL_TEXTURE</code>   i   ,
        /// where i ranges from 0 to <code>GL_MAX_TEXTURE_COORDS</code> - 1,
        /// which is an implementation-dependent value.
        /// </para>
        /// </param>
        /// <param name="s">
        /// <para>
        /// Specify <paramref name="s"/>, <paramref name="t"/>, <paramref name="r"/>, and <paramref name="q"/> texture coordinates for
        /// <paramref name="target"/> texture unit. Not all parameters are present in all forms
        /// of the command.
        /// </para>
        /// </param>
        /// <param name="t">
        /// <para>
        /// Specify <paramref name="s"/>, <paramref name="t"/>, <paramref name="r"/>, and <paramref name="q"/> texture coordinates for
        /// <paramref name="target"/> texture unit. Not all parameters are present in all forms
        /// of the command.
        /// </para>
        /// </param>
        /// <seealso cref="ActiveTexture"/>
        /// <seealso cref="ClientActiveTexture"/>
        /// <seealso cref="TexCoord"/>
        /// <seealso cref="TexCoordPointer"/>
        /// <seealso cref="Vertex"/>
        [Obsolete("Compatibility-only GL 1.3 features removed from GL 3.2")]
        public static void MultiTexCoord2s(uint target, short s, short t) {
            GLNative.glMultiTexCoord2s(target, s, t);
        }

        /// <summary>
        /// set the current texture coordinates
        /// <para>Require:</para> <para>GL_VERSION_1_3</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glMultiTexCoord"/> is only supported if the GL version is 1.3 or greater, or if
        /// <code>ARB_multitexture</code> is included in the string returned by
        /// <see cref="glGetString"/>  when called with the argument <code>GL_EXTENSIONS</code>.
        /// The current texture coordinates can be updated at any time.
        /// In particular,
        /// <see cref="glMultiTexCoord"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// It is always the case that <code>GL_TEXTURE</code>
        /// i   
        /// = <code>GL_TEXTURE0</code> + 
        /// i   .
        /// </para>
        /// Original: <para>void glMultiTexCoord3d(GLenum target, GLdouble s, GLdouble t, GLdouble r);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the texture unit whose coordinates should be modified. The number
        /// of texture units is implementation dependent, but must be at least
        /// two. Symbolic constant must be one of 
        /// <code>GL_TEXTURE</code>   i   ,
        /// where i ranges from 0 to <code>GL_MAX_TEXTURE_COORDS</code> - 1,
        /// which is an implementation-dependent value.
        /// </para>
        /// </param>
        /// <param name="s">
        /// <para>
        /// Specify <paramref name="s"/>, <paramref name="t"/>, <paramref name="r"/>, and <paramref name="q"/> texture coordinates for
        /// <paramref name="target"/> texture unit. Not all parameters are present in all forms
        /// of the command.
        /// </para>
        /// </param>
        /// <param name="t">
        /// <para>
        /// Specify <paramref name="s"/>, <paramref name="t"/>, <paramref name="r"/>, and <paramref name="q"/> texture coordinates for
        /// <paramref name="target"/> texture unit. Not all parameters are present in all forms
        /// of the command.
        /// </para>
        /// </param>
        /// <param name="r">
        /// <para>
        /// Specify <paramref name="s"/>, <paramref name="t"/>, <paramref name="r"/>, and <paramref name="q"/> texture coordinates for
        /// <paramref name="target"/> texture unit. Not all parameters are present in all forms
        /// of the command.
        /// </para>
        /// </param>
        /// <seealso cref="ActiveTexture"/>
        /// <seealso cref="ClientActiveTexture"/>
        /// <seealso cref="TexCoord"/>
        /// <seealso cref="TexCoordPointer"/>
        /// <seealso cref="Vertex"/>
        [Obsolete("Compatibility-only GL 1.3 features removed from GL 3.2")]
        public static void MultiTexCoord3d(uint target, double s, double t, double r) {
            GLNative.glMultiTexCoord3d(target, s, t, r);
        }

        /// <summary>
        /// set the current texture coordinates
        /// <para>Require:</para> <para>GL_VERSION_1_3</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glMultiTexCoord"/> is only supported if the GL version is 1.3 or greater, or if
        /// <code>ARB_multitexture</code> is included in the string returned by
        /// <see cref="glGetString"/>  when called with the argument <code>GL_EXTENSIONS</code>.
        /// The current texture coordinates can be updated at any time.
        /// In particular,
        /// <see cref="glMultiTexCoord"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// It is always the case that <code>GL_TEXTURE</code>
        /// i   
        /// = <code>GL_TEXTURE0</code> + 
        /// i   .
        /// </para>
        /// Original: <para>void glMultiTexCoord3f(GLenum target, GLfloat s, GLfloat t, GLfloat r);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the texture unit whose coordinates should be modified. The number
        /// of texture units is implementation dependent, but must be at least
        /// two. Symbolic constant must be one of 
        /// <code>GL_TEXTURE</code>   i   ,
        /// where i ranges from 0 to <code>GL_MAX_TEXTURE_COORDS</code> - 1,
        /// which is an implementation-dependent value.
        /// </para>
        /// </param>
        /// <param name="s">
        /// <para>
        /// Specify <paramref name="s"/>, <paramref name="t"/>, <paramref name="r"/>, and <paramref name="q"/> texture coordinates for
        /// <paramref name="target"/> texture unit. Not all parameters are present in all forms
        /// of the command.
        /// </para>
        /// </param>
        /// <param name="t">
        /// <para>
        /// Specify <paramref name="s"/>, <paramref name="t"/>, <paramref name="r"/>, and <paramref name="q"/> texture coordinates for
        /// <paramref name="target"/> texture unit. Not all parameters are present in all forms
        /// of the command.
        /// </para>
        /// </param>
        /// <param name="r">
        /// <para>
        /// Specify <paramref name="s"/>, <paramref name="t"/>, <paramref name="r"/>, and <paramref name="q"/> texture coordinates for
        /// <paramref name="target"/> texture unit. Not all parameters are present in all forms
        /// of the command.
        /// </para>
        /// </param>
        /// <seealso cref="ActiveTexture"/>
        /// <seealso cref="ClientActiveTexture"/>
        /// <seealso cref="TexCoord"/>
        /// <seealso cref="TexCoordPointer"/>
        /// <seealso cref="Vertex"/>
        [Obsolete("Compatibility-only GL 1.3 features removed from GL 3.2")]
        public static void MultiTexCoord3f(uint target, float s, float t, float r) {
            GLNative.glMultiTexCoord3f(target, s, t, r);
        }

        /// <summary>
        /// set the current texture coordinates
        /// <para>Require:</para> <para>GL_VERSION_1_3</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glMultiTexCoord"/> is only supported if the GL version is 1.3 or greater, or if
        /// <code>ARB_multitexture</code> is included in the string returned by
        /// <see cref="glGetString"/>  when called with the argument <code>GL_EXTENSIONS</code>.
        /// The current texture coordinates can be updated at any time.
        /// In particular,
        /// <see cref="glMultiTexCoord"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// It is always the case that <code>GL_TEXTURE</code>
        /// i   
        /// = <code>GL_TEXTURE0</code> + 
        /// i   .
        /// </para>
        /// Original: <para>void glMultiTexCoord3i(GLenum target, GLint s, GLint t, GLint r);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the texture unit whose coordinates should be modified. The number
        /// of texture units is implementation dependent, but must be at least
        /// two. Symbolic constant must be one of 
        /// <code>GL_TEXTURE</code>   i   ,
        /// where i ranges from 0 to <code>GL_MAX_TEXTURE_COORDS</code> - 1,
        /// which is an implementation-dependent value.
        /// </para>
        /// </param>
        /// <param name="s">
        /// <para>
        /// Specify <paramref name="s"/>, <paramref name="t"/>, <paramref name="r"/>, and <paramref name="q"/> texture coordinates for
        /// <paramref name="target"/> texture unit. Not all parameters are present in all forms
        /// of the command.
        /// </para>
        /// </param>
        /// <param name="t">
        /// <para>
        /// Specify <paramref name="s"/>, <paramref name="t"/>, <paramref name="r"/>, and <paramref name="q"/> texture coordinates for
        /// <paramref name="target"/> texture unit. Not all parameters are present in all forms
        /// of the command.
        /// </para>
        /// </param>
        /// <param name="r">
        /// <para>
        /// Specify <paramref name="s"/>, <paramref name="t"/>, <paramref name="r"/>, and <paramref name="q"/> texture coordinates for
        /// <paramref name="target"/> texture unit. Not all parameters are present in all forms
        /// of the command.
        /// </para>
        /// </param>
        /// <seealso cref="ActiveTexture"/>
        /// <seealso cref="ClientActiveTexture"/>
        /// <seealso cref="TexCoord"/>
        /// <seealso cref="TexCoordPointer"/>
        /// <seealso cref="Vertex"/>
        [Obsolete("Compatibility-only GL 1.3 features removed from GL 3.2")]
        public static void MultiTexCoord3i(uint target, int s, int t, int r) {
            GLNative.glMultiTexCoord3i(target, s, t, r);
        }

        /// <summary>
        /// set the current texture coordinates
        /// <para>Require:</para> <para>GL_VERSION_1_3</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glMultiTexCoord"/> is only supported if the GL version is 1.3 or greater, or if
        /// <code>ARB_multitexture</code> is included in the string returned by
        /// <see cref="glGetString"/>  when called with the argument <code>GL_EXTENSIONS</code>.
        /// The current texture coordinates can be updated at any time.
        /// In particular,
        /// <see cref="glMultiTexCoord"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// It is always the case that <code>GL_TEXTURE</code>
        /// i   
        /// = <code>GL_TEXTURE0</code> + 
        /// i   .
        /// </para>
        /// Original: <para>void glMultiTexCoord3s(GLenum target, GLshort s, GLshort t, GLshort r);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the texture unit whose coordinates should be modified. The number
        /// of texture units is implementation dependent, but must be at least
        /// two. Symbolic constant must be one of 
        /// <code>GL_TEXTURE</code>   i   ,
        /// where i ranges from 0 to <code>GL_MAX_TEXTURE_COORDS</code> - 1,
        /// which is an implementation-dependent value.
        /// </para>
        /// </param>
        /// <param name="s">
        /// <para>
        /// Specify <paramref name="s"/>, <paramref name="t"/>, <paramref name="r"/>, and <paramref name="q"/> texture coordinates for
        /// <paramref name="target"/> texture unit. Not all parameters are present in all forms
        /// of the command.
        /// </para>
        /// </param>
        /// <param name="t">
        /// <para>
        /// Specify <paramref name="s"/>, <paramref name="t"/>, <paramref name="r"/>, and <paramref name="q"/> texture coordinates for
        /// <paramref name="target"/> texture unit. Not all parameters are present in all forms
        /// of the command.
        /// </para>
        /// </param>
        /// <param name="r">
        /// <para>
        /// Specify <paramref name="s"/>, <paramref name="t"/>, <paramref name="r"/>, and <paramref name="q"/> texture coordinates for
        /// <paramref name="target"/> texture unit. Not all parameters are present in all forms
        /// of the command.
        /// </para>
        /// </param>
        /// <seealso cref="ActiveTexture"/>
        /// <seealso cref="ClientActiveTexture"/>
        /// <seealso cref="TexCoord"/>
        /// <seealso cref="TexCoordPointer"/>
        /// <seealso cref="Vertex"/>
        [Obsolete("Compatibility-only GL 1.3 features removed from GL 3.2")]
        public static void MultiTexCoord3s(uint target, short s, short t, short r) {
            GLNative.glMultiTexCoord3s(target, s, t, r);
        }

        /// <summary>
        /// set the current texture coordinates
        /// <para>Require:</para> <para>GL_VERSION_1_3</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glMultiTexCoord"/> is only supported if the GL version is 1.3 or greater, or if
        /// <code>ARB_multitexture</code> is included in the string returned by
        /// <see cref="glGetString"/>  when called with the argument <code>GL_EXTENSIONS</code>.
        /// The current texture coordinates can be updated at any time.
        /// In particular,
        /// <see cref="glMultiTexCoord"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// It is always the case that <code>GL_TEXTURE</code>
        /// i   
        /// = <code>GL_TEXTURE0</code> + 
        /// i   .
        /// </para>
        /// Original: <para>void glMultiTexCoord4d(GLenum target, GLdouble s, GLdouble t, GLdouble r, GLdouble q);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the texture unit whose coordinates should be modified. The number
        /// of texture units is implementation dependent, but must be at least
        /// two. Symbolic constant must be one of 
        /// <code>GL_TEXTURE</code>   i   ,
        /// where i ranges from 0 to <code>GL_MAX_TEXTURE_COORDS</code> - 1,
        /// which is an implementation-dependent value.
        /// </para>
        /// </param>
        /// <param name="s">
        /// <para>
        /// Specify <paramref name="s"/>, <paramref name="t"/>, <paramref name="r"/>, and <paramref name="q"/> texture coordinates for
        /// <paramref name="target"/> texture unit. Not all parameters are present in all forms
        /// of the command.
        /// </para>
        /// </param>
        /// <param name="t">
        /// <para>
        /// Specify <paramref name="s"/>, <paramref name="t"/>, <paramref name="r"/>, and <paramref name="q"/> texture coordinates for
        /// <paramref name="target"/> texture unit. Not all parameters are present in all forms
        /// of the command.
        /// </para>
        /// </param>
        /// <param name="r">
        /// <para>
        /// Specify <paramref name="s"/>, <paramref name="t"/>, <paramref name="r"/>, and <paramref name="q"/> texture coordinates for
        /// <paramref name="target"/> texture unit. Not all parameters are present in all forms
        /// of the command.
        /// </para>
        /// </param>
        /// <param name="q">
        /// <para>
        /// Specify <paramref name="s"/>, <paramref name="t"/>, <paramref name="r"/>, and <paramref name="q"/> texture coordinates for
        /// <paramref name="target"/> texture unit. Not all parameters are present in all forms
        /// of the command.
        /// </para>
        /// </param>
        /// <seealso cref="ActiveTexture"/>
        /// <seealso cref="ClientActiveTexture"/>
        /// <seealso cref="TexCoord"/>
        /// <seealso cref="TexCoordPointer"/>
        /// <seealso cref="Vertex"/>
        [Obsolete("Compatibility-only GL 1.3 features removed from GL 3.2")]
        public static void MultiTexCoord4d(uint target, double s, double t, double r, double q) {
            GLNative.glMultiTexCoord4d(target, s, t, r, q);
        }

        /// <summary>
        /// set the current texture coordinates
        /// <para>Require:</para> <para>GL_VERSION_1_3, GL_VERSION_ES_CM_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glMultiTexCoord"/> is only supported if the GL version is 1.3 or greater, or if
        /// <code>ARB_multitexture</code> is included in the string returned by
        /// <see cref="glGetString"/>  when called with the argument <code>GL_EXTENSIONS</code>.
        /// The current texture coordinates can be updated at any time.
        /// In particular,
        /// <see cref="glMultiTexCoord"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// It is always the case that <code>GL_TEXTURE</code>
        /// i   
        /// = <code>GL_TEXTURE0</code> + 
        /// i   .
        /// </para>
        /// Original: <para>void glMultiTexCoord4f(GLenum target, GLfloat s, GLfloat t, GLfloat r, GLfloat q);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the texture unit whose coordinates should be modified. The number
        /// of texture units is implementation dependent, but must be at least
        /// two. Symbolic constant must be one of 
        /// <code>GL_TEXTURE</code>   i   ,
        /// where i ranges from 0 to <code>GL_MAX_TEXTURE_COORDS</code> - 1,
        /// which is an implementation-dependent value.
        /// </para>
        /// </param>
        /// <param name="s">
        /// <para>
        /// Specify <paramref name="s"/>, <paramref name="t"/>, <paramref name="r"/>, and <paramref name="q"/> texture coordinates for
        /// <paramref name="target"/> texture unit. Not all parameters are present in all forms
        /// of the command.
        /// </para>
        /// </param>
        /// <param name="t">
        /// <para>
        /// Specify <paramref name="s"/>, <paramref name="t"/>, <paramref name="r"/>, and <paramref name="q"/> texture coordinates for
        /// <paramref name="target"/> texture unit. Not all parameters are present in all forms
        /// of the command.
        /// </para>
        /// </param>
        /// <param name="r">
        /// <para>
        /// Specify <paramref name="s"/>, <paramref name="t"/>, <paramref name="r"/>, and <paramref name="q"/> texture coordinates for
        /// <paramref name="target"/> texture unit. Not all parameters are present in all forms
        /// of the command.
        /// </para>
        /// </param>
        /// <param name="q">
        /// <para>
        /// Specify <paramref name="s"/>, <paramref name="t"/>, <paramref name="r"/>, and <paramref name="q"/> texture coordinates for
        /// <paramref name="target"/> texture unit. Not all parameters are present in all forms
        /// of the command.
        /// </para>
        /// </param>
        /// <seealso cref="ActiveTexture"/>
        /// <seealso cref="ClientActiveTexture"/>
        /// <seealso cref="TexCoord"/>
        /// <seealso cref="TexCoordPointer"/>
        /// <seealso cref="Vertex"/>
        [Obsolete("Compatibility-only GL 1.3 features removed from GL 3.2")]
        public static void MultiTexCoord4f(uint target, float s, float t, float r, float q) {
            GLNative.glMultiTexCoord4f(target, s, t, r, q);
        }

        /// <summary>
        /// set the current texture coordinates
        /// <para>Require:</para> <para>GL_VERSION_1_3</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glMultiTexCoord"/> is only supported if the GL version is 1.3 or greater, or if
        /// <code>ARB_multitexture</code> is included in the string returned by
        /// <see cref="glGetString"/>  when called with the argument <code>GL_EXTENSIONS</code>.
        /// The current texture coordinates can be updated at any time.
        /// In particular,
        /// <see cref="glMultiTexCoord"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// It is always the case that <code>GL_TEXTURE</code>
        /// i   
        /// = <code>GL_TEXTURE0</code> + 
        /// i   .
        /// </para>
        /// Original: <para>void glMultiTexCoord4i(GLenum target, GLint s, GLint t, GLint r, GLint q);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the texture unit whose coordinates should be modified. The number
        /// of texture units is implementation dependent, but must be at least
        /// two. Symbolic constant must be one of 
        /// <code>GL_TEXTURE</code>   i   ,
        /// where i ranges from 0 to <code>GL_MAX_TEXTURE_COORDS</code> - 1,
        /// which is an implementation-dependent value.
        /// </para>
        /// </param>
        /// <param name="s">
        /// <para>
        /// Specify <paramref name="s"/>, <paramref name="t"/>, <paramref name="r"/>, and <paramref name="q"/> texture coordinates for
        /// <paramref name="target"/> texture unit. Not all parameters are present in all forms
        /// of the command.
        /// </para>
        /// </param>
        /// <param name="t">
        /// <para>
        /// Specify <paramref name="s"/>, <paramref name="t"/>, <paramref name="r"/>, and <paramref name="q"/> texture coordinates for
        /// <paramref name="target"/> texture unit. Not all parameters are present in all forms
        /// of the command.
        /// </para>
        /// </param>
        /// <param name="r">
        /// <para>
        /// Specify <paramref name="s"/>, <paramref name="t"/>, <paramref name="r"/>, and <paramref name="q"/> texture coordinates for
        /// <paramref name="target"/> texture unit. Not all parameters are present in all forms
        /// of the command.
        /// </para>
        /// </param>
        /// <param name="q">
        /// <para>
        /// Specify <paramref name="s"/>, <paramref name="t"/>, <paramref name="r"/>, and <paramref name="q"/> texture coordinates for
        /// <paramref name="target"/> texture unit. Not all parameters are present in all forms
        /// of the command.
        /// </para>
        /// </param>
        /// <seealso cref="ActiveTexture"/>
        /// <seealso cref="ClientActiveTexture"/>
        /// <seealso cref="TexCoord"/>
        /// <seealso cref="TexCoordPointer"/>
        /// <seealso cref="Vertex"/>
        [Obsolete("Compatibility-only GL 1.3 features removed from GL 3.2")]
        public static void MultiTexCoord4i(uint target, int s, int t, int r, int q) {
            GLNative.glMultiTexCoord4i(target, s, t, r, q);
        }

        /// <summary>
        /// set the current texture coordinates
        /// <para>Require:</para> <para>GL_VERSION_1_3</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glMultiTexCoord"/> is only supported if the GL version is 1.3 or greater, or if
        /// <code>ARB_multitexture</code> is included in the string returned by
        /// <see cref="glGetString"/>  when called with the argument <code>GL_EXTENSIONS</code>.
        /// The current texture coordinates can be updated at any time.
        /// In particular,
        /// <see cref="glMultiTexCoord"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// It is always the case that <code>GL_TEXTURE</code>
        /// i   
        /// = <code>GL_TEXTURE0</code> + 
        /// i   .
        /// </para>
        /// Original: <para>void glMultiTexCoord4s(GLenum target, GLshort s, GLshort t, GLshort r, GLshort q);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the texture unit whose coordinates should be modified. The number
        /// of texture units is implementation dependent, but must be at least
        /// two. Symbolic constant must be one of 
        /// <code>GL_TEXTURE</code>   i   ,
        /// where i ranges from 0 to <code>GL_MAX_TEXTURE_COORDS</code> - 1,
        /// which is an implementation-dependent value.
        /// </para>
        /// </param>
        /// <param name="s">
        /// <para>
        /// Specify <paramref name="s"/>, <paramref name="t"/>, <paramref name="r"/>, and <paramref name="q"/> texture coordinates for
        /// <paramref name="target"/> texture unit. Not all parameters are present in all forms
        /// of the command.
        /// </para>
        /// </param>
        /// <param name="t">
        /// <para>
        /// Specify <paramref name="s"/>, <paramref name="t"/>, <paramref name="r"/>, and <paramref name="q"/> texture coordinates for
        /// <paramref name="target"/> texture unit. Not all parameters are present in all forms
        /// of the command.
        /// </para>
        /// </param>
        /// <param name="r">
        /// <para>
        /// Specify <paramref name="s"/>, <paramref name="t"/>, <paramref name="r"/>, and <paramref name="q"/> texture coordinates for
        /// <paramref name="target"/> texture unit. Not all parameters are present in all forms
        /// of the command.
        /// </para>
        /// </param>
        /// <param name="q">
        /// <para>
        /// Specify <paramref name="s"/>, <paramref name="t"/>, <paramref name="r"/>, and <paramref name="q"/> texture coordinates for
        /// <paramref name="target"/> texture unit. Not all parameters are present in all forms
        /// of the command.
        /// </para>
        /// </param>
        /// <seealso cref="ActiveTexture"/>
        /// <seealso cref="ClientActiveTexture"/>
        /// <seealso cref="TexCoord"/>
        /// <seealso cref="TexCoordPointer"/>
        /// <seealso cref="Vertex"/>
        [Obsolete("Compatibility-only GL 1.3 features removed from GL 3.2")]
        public static void MultiTexCoord4s(uint target, short s, short t, short r, short q) {
            GLNative.glMultiTexCoord4s(target, s, t, r, q);
        }


        #endregion GL_VERSION_1_3

        #region GL_VERSION_1_4

        /// <summary>
        /// specify pixel arithmetic for RGB and alpha components separately
        /// <para>Require:</para> <para>GL_VERSION_1_4, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glBlendFuncSeparate"/> is available only if the GL version is 1.4 or greater.
        /// Incoming (source) alpha is correctly thought of as a material opacity,
        /// ranging from 1.0 
        /// (  
        /// K 
        /// A 
        /// ),
        /// representing complete opacity,
        /// to 0.0 (0), representing complete
        /// transparency.
        /// When more than one color buffer is enabled for drawing,
        /// the GL performs blending separately for each enabled buffer,
        /// using the contents of that buffer for destination color.
        /// (See  <see cref="glDrawBuffer"/> .)
        /// Blending affects only RGBA rendering.
        /// It is ignored by color index renderers.
        /// <code>GL_CONSTANT_COLOR</code>, <code>GL_ONE_MINUS_CONSTANT_COLOR</code>,
        /// <code>GL_CONSTANT_ALPHA</code>, <code>GL_ONE_MINUS_CONSTANT_ALPHA</code> are available only
        /// if the GL version is 1.4 or greater or if the <code>ARB_imaging</code> is
        /// supported by your implementation.
        /// <code>GL_SRC_COLOR</code> and <code>GL_ONE_MINUS_SRC_COLOR</code> are valid only for
        /// <paramref name="srcRGB"/> if the GL version is 1.4 or greater.
        /// <code>GL_DST_COLOR</code> and <code>GL_ONE_MINUS_DST_COLOR</code> are valid only for
        /// <paramref name="dstRGB"/> if the GL version is 1.4 or greater.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if either <paramref name="srcRGB"/> or <paramref name="dstRGB"/> is not an
        /// accepted value.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glBlendFuncSeparate"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glBlendFuncSeparate(GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha);</para>
        /// </summary>
        /// <param name="srcRGB">
        /// <para>
        /// Specifies how the red, green, and blue blending factors are computed.
        /// The following symbolic constants are accepted:
        /// <code>GL_ZERO</code>,
        /// <code>GL_ONE</code>,
        /// <code>GL_SRC_COLOR</code>,
        /// <code>GL_ONE_MINUS_SRC_COLOR</code>,
        /// <code>GL_DST_COLOR</code>,
        /// <code>GL_ONE_MINUS_DST_COLOR</code>,
        /// <code>GL_SRC_ALPHA</code>,
        /// <code>GL_ONE_MINUS_SRC_ALPHA</code>,
        /// <code>GL_DST_ALPHA</code>,
        /// <code>GL_ONE_MINUS_DST_ALPHA</code>,
        /// <code>GL_CONSTANT_COLOR</code>,
        /// <code>GL_ONE_MINUS_CONSTANT_COLOR</code>,
        /// <code>GL_CONSTANT_ALPHA</code>,
        /// <code>GL_ONE_MINUS_CONSTANT_ALPHA</code>, and
        /// <code>GL_SRC_ALPHA_SATURATE</code>.
        /// The initial value is <code>GL_ONE</code>.
        /// </para>
        /// </param>
        /// <param name="dstRGB">
        /// <para>
        /// Specifies how the red, green, and blue destination blending factors are
        /// computed. The following symbolic constants are accepted:
        /// <code>GL_ZERO</code>,
        /// <code>GL_ONE</code>,
        /// <code>GL_SRC_COLOR</code>,
        /// <code>GL_ONE_MINUS_SRC_COLOR</code>,
        /// <code>GL_DST_COLOR</code>,
        /// <code>GL_ONE_MINUS_DST_COLOR</code>,
        /// <code>GL_SRC_ALPHA</code>,
        /// <code>GL_ONE_MINUS_SRC_ALPHA</code>,
        /// <code>GL_DST_ALPHA</code>,
        /// <code>GL_ONE_MINUS_DST_ALPHA</code>.
        /// <code>GL_CONSTANT_COLOR</code>,
        /// <code>GL_ONE_MINUS_CONSTANT_COLOR</code>,
        /// <code>GL_CONSTANT_ALPHA</code>, and
        /// <code>GL_ONE_MINUS_CONSTANT_ALPHA</code>.
        /// The initial value is <code>GL_ZERO</code>.
        /// </para>
        /// </param>
        /// <param name="srcAlpha">
        /// <para>
        /// Specified how the alpha source blending factor is computed.  The same
        /// symbolic constants are accepted as for <paramref name="srcRGB"/>.
        /// The initial value is <code>GL_ONE</code>.
        /// </para>
        /// </param>
        /// <param name="dstAlpha">
        /// <para>
        /// Specified how the alpha destination blending factor is computed.  The same
        /// symbolic constants are accepted as for <paramref name="dstRGB"/>.
        /// The initial value is <code>GL_ZERO</code>.
        /// </para>
        /// </param>
        /// <seealso cref="AlphaFunc"/>
        /// <seealso cref="BlendColor"/>
        /// <seealso cref="BlendFunc"/>
        /// <seealso cref="BlendEquation"/>
        /// <seealso cref="Clear"/>
        /// <seealso cref="DrawBuffer"/>
        /// <seealso cref="Enable"/>
        /// <seealso cref="LogicOp"/>
        /// <seealso cref="StencilFunc"/>
        public static void BlendFuncSeparate(uint srcRGB, uint dstRGB, uint srcAlpha, uint dstAlpha) {
            GLNative.glBlendFuncSeparate(srcRGB, dstRGB, srcAlpha, dstAlpha);
        }

        /// <summary>
        /// specify point parameters
        /// <para>Require:</para> <para>GL_VERSION_1_4, GL_VERSION_ES_CM_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glPointParameter"/> is available only if the GL version is 1.4 or greater.
        /// <code>GL_POINT_SPRITE_COORD_ORIGIN</code> is available only if the GL version is 2.0 or greater.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated If the value specified for
        /// <code>GL_POINT_SIZE_MIN</code>, <code>GL_POINT_SIZE_MAX</code>, or
        /// <code>GL_POINT_FADE_THRESHOLD_SIZE</code> is less than zero.
        /// <code>GL_INVALID_ENUM</code> is generated If the value specified for
        /// <code>GL_POINT_SPRITE_COORD_ORIGIN</code> is not <code>GL_LOWER_LEFT</code> or <code>GL_UPPER_LEFT</code>.
        /// If the value for <code>GL_POINT_SIZE_MIN</code> is greater than
        /// <code>GL_POINT_SIZE_MAX</code>, the point size after clamping is undefined, but no
        /// error is generated.
        /// </para>
        /// Original: <para>void glPointParameterf(GLenum pname, GLfloat param);</para>
        /// </summary>
        /// <param name="pname">
        /// <para>
        /// Specifies a single-valued point parameter.
        /// <code>GL_POINT_SIZE_MIN</code>,
        /// <code>GL_POINT_SIZE_MAX</code>,
        /// <code>GL_POINT_FADE_THRESHOLD_SIZE</code>, and
        /// <code>GL_POINT_SPRITE_COORD_ORIGIN</code>
        /// are accepted.
        /// </para>
        /// </param>
        /// <param name="param">
        /// Specifies the value that <paramref name="pname"/> will be set to.
        /// </param>
        /// <seealso cref="PointSize"/>
        public static void PointParameterf(uint pname, float param) {
            GLNative.glPointParameterf(pname, param);
        }

        /// <summary>
        /// specify point parameters
        /// <para>Require:</para> <para>GL_VERSION_1_4</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glPointParameter"/> is available only if the GL version is 1.4 or greater.
        /// <code>GL_POINT_SPRITE_COORD_ORIGIN</code> is available only if the GL version is 2.0 or greater.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated If the value specified for
        /// <code>GL_POINT_SIZE_MIN</code>, <code>GL_POINT_SIZE_MAX</code>, or
        /// <code>GL_POINT_FADE_THRESHOLD_SIZE</code> is less than zero.
        /// <code>GL_INVALID_ENUM</code> is generated If the value specified for
        /// <code>GL_POINT_SPRITE_COORD_ORIGIN</code> is not <code>GL_LOWER_LEFT</code> or <code>GL_UPPER_LEFT</code>.
        /// If the value for <code>GL_POINT_SIZE_MIN</code> is greater than
        /// <code>GL_POINT_SIZE_MAX</code>, the point size after clamping is undefined, but no
        /// error is generated.
        /// </para>
        /// Original: <para>void glPointParameteri(GLenum pname, GLint param);</para>
        /// </summary>
        /// <param name="pname">
        /// <para>
        /// Specifies a single-valued point parameter.
        /// <code>GL_POINT_SIZE_MIN</code>,
        /// <code>GL_POINT_SIZE_MAX</code>,
        /// <code>GL_POINT_FADE_THRESHOLD_SIZE</code>, and
        /// <code>GL_POINT_SPRITE_COORD_ORIGIN</code>
        /// are accepted.
        /// </para>
        /// </param>
        /// <param name="param">
        /// Specifies the value that <paramref name="pname"/> will be set to.
        /// </param>
        /// <seealso cref="PointSize"/>
        public static void PointParameteri(uint pname, int param) {
            GLNative.glPointParameteri(pname, param);
        }

        /// <summary>
        /// set the current fog coordinates
        /// <para>Require:</para> <para>GL_VERSION_1_4</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glFogCoord"/> is available only if the GL version is 1.4 or greater.
        /// The current fog coordinate can be updated at any time.  In particular,
        /// <see cref="glFogCoord"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glFogCoordf(GLfloat coord);</para>
        /// </summary>
        /// <param name="coord">
        /// Specify the fog distance.
        /// </param>
        /// <seealso cref="Fog"/>
        /// <seealso cref="FogCoordPointer"/>
        /// <seealso cref="Vertex"/>
        [Obsolete("Compatibility-only GL 1.4 features removed from GL 3.2")]
        public static void FogCoordf(float coord) {
            GLNative.glFogCoordf(coord);
        }

        /// <summary>
        /// set the current fog coordinates
        /// <para>Require:</para> <para>GL_VERSION_1_4</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glFogCoord"/> is available only if the GL version is 1.4 or greater.
        /// The current fog coordinate can be updated at any time.  In particular,
        /// <see cref="glFogCoord"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glFogCoordd(GLdouble coord);</para>
        /// </summary>
        /// <param name="coord">
        /// Specify the fog distance.
        /// </param>
        /// <seealso cref="Fog"/>
        /// <seealso cref="FogCoordPointer"/>
        /// <seealso cref="Vertex"/>
        [Obsolete("Compatibility-only GL 1.4 features removed from GL 3.2")]
        public static void FogCoordd(double coord) {
            GLNative.glFogCoordd(coord);
        }

        /// <summary>
        /// set the current secondary color
        /// <para>Require:</para> <para>GL_VERSION_1_4</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glSecondaryColor"/> is available only if the GL version is 1.4 or greater.
        /// The initial value for the secondary color is (0, 0, 0, 0).
        /// The secondary color can be updated at any time.  In particular, <see cref="glSecondaryColor"/> can
        /// be called between a call to  <see cref="glBegin"/>  and the corresponding call to
        /// <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glSecondaryColor3b(GLbyte red, GLbyte green, GLbyte blue);</para>
        /// </summary>
        /// <param name="red">
        /// Specify new red, green, and blue values for the current secondary color.
        /// </param>
        /// <param name="green">
        /// Specify new red, green, and blue values for the current secondary color.
        /// </param>
        /// <param name="blue">
        /// Specify new red, green, and blue values for the current secondary color.
        /// </param>
        /// <seealso cref="Color"/>
        /// <seealso cref="Index"/>
        /// <seealso cref="IsEnabled"/>
        /// <seealso cref="LightModel"/>
        /// <seealso cref="SecondaryColorPointer"/>
        [Obsolete("Compatibility-only GL 1.4 features removed from GL 3.2")]
        public static void SecondaryColor3b(byte red, byte green, byte blue) {
            GLNative.glSecondaryColor3b(red, green, blue);
        }

        /// <summary>
        /// set the current secondary color
        /// <para>Require:</para> <para>GL_VERSION_1_4</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glSecondaryColor"/> is available only if the GL version is 1.4 or greater.
        /// The initial value for the secondary color is (0, 0, 0, 0).
        /// The secondary color can be updated at any time.  In particular, <see cref="glSecondaryColor"/> can
        /// be called between a call to  <see cref="glBegin"/>  and the corresponding call to
        /// <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glSecondaryColor3d(GLdouble red, GLdouble green, GLdouble blue);</para>
        /// </summary>
        /// <param name="red">
        /// Specify new red, green, and blue values for the current secondary color.
        /// </param>
        /// <param name="green">
        /// Specify new red, green, and blue values for the current secondary color.
        /// </param>
        /// <param name="blue">
        /// Specify new red, green, and blue values for the current secondary color.
        /// </param>
        /// <seealso cref="Color"/>
        /// <seealso cref="Index"/>
        /// <seealso cref="IsEnabled"/>
        /// <seealso cref="LightModel"/>
        /// <seealso cref="SecondaryColorPointer"/>
        [Obsolete("Compatibility-only GL 1.4 features removed from GL 3.2")]
        public static void SecondaryColor3d(double red, double green, double blue) {
            GLNative.glSecondaryColor3d(red, green, blue);
        }

        /// <summary>
        /// set the current secondary color
        /// <para>Require:</para> <para>GL_VERSION_1_4</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glSecondaryColor"/> is available only if the GL version is 1.4 or greater.
        /// The initial value for the secondary color is (0, 0, 0, 0).
        /// The secondary color can be updated at any time.  In particular, <see cref="glSecondaryColor"/> can
        /// be called between a call to  <see cref="glBegin"/>  and the corresponding call to
        /// <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glSecondaryColor3f(GLfloat red, GLfloat green, GLfloat blue);</para>
        /// </summary>
        /// <param name="red">
        /// Specify new red, green, and blue values for the current secondary color.
        /// </param>
        /// <param name="green">
        /// Specify new red, green, and blue values for the current secondary color.
        /// </param>
        /// <param name="blue">
        /// Specify new red, green, and blue values for the current secondary color.
        /// </param>
        /// <seealso cref="Color"/>
        /// <seealso cref="Index"/>
        /// <seealso cref="IsEnabled"/>
        /// <seealso cref="LightModel"/>
        /// <seealso cref="SecondaryColorPointer"/>
        [Obsolete("Compatibility-only GL 1.4 features removed from GL 3.2")]
        public static void SecondaryColor3f(float red, float green, float blue) {
            GLNative.glSecondaryColor3f(red, green, blue);
        }

        /// <summary>
        /// set the current secondary color
        /// <para>Require:</para> <para>GL_VERSION_1_4</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glSecondaryColor"/> is available only if the GL version is 1.4 or greater.
        /// The initial value for the secondary color is (0, 0, 0, 0).
        /// The secondary color can be updated at any time.  In particular, <see cref="glSecondaryColor"/> can
        /// be called between a call to  <see cref="glBegin"/>  and the corresponding call to
        /// <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glSecondaryColor3i(GLint red, GLint green, GLint blue);</para>
        /// </summary>
        /// <param name="red">
        /// Specify new red, green, and blue values for the current secondary color.
        /// </param>
        /// <param name="green">
        /// Specify new red, green, and blue values for the current secondary color.
        /// </param>
        /// <param name="blue">
        /// Specify new red, green, and blue values for the current secondary color.
        /// </param>
        /// <seealso cref="Color"/>
        /// <seealso cref="Index"/>
        /// <seealso cref="IsEnabled"/>
        /// <seealso cref="LightModel"/>
        /// <seealso cref="SecondaryColorPointer"/>
        [Obsolete("Compatibility-only GL 1.4 features removed from GL 3.2")]
        public static void SecondaryColor3i(int red, int green, int blue) {
            GLNative.glSecondaryColor3i(red, green, blue);
        }

        /// <summary>
        /// set the current secondary color
        /// <para>Require:</para> <para>GL_VERSION_1_4</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glSecondaryColor"/> is available only if the GL version is 1.4 or greater.
        /// The initial value for the secondary color is (0, 0, 0, 0).
        /// The secondary color can be updated at any time.  In particular, <see cref="glSecondaryColor"/> can
        /// be called between a call to  <see cref="glBegin"/>  and the corresponding call to
        /// <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glSecondaryColor3s(GLshort red, GLshort green, GLshort blue);</para>
        /// </summary>
        /// <param name="red">
        /// Specify new red, green, and blue values for the current secondary color.
        /// </param>
        /// <param name="green">
        /// Specify new red, green, and blue values for the current secondary color.
        /// </param>
        /// <param name="blue">
        /// Specify new red, green, and blue values for the current secondary color.
        /// </param>
        /// <seealso cref="Color"/>
        /// <seealso cref="Index"/>
        /// <seealso cref="IsEnabled"/>
        /// <seealso cref="LightModel"/>
        /// <seealso cref="SecondaryColorPointer"/>
        [Obsolete("Compatibility-only GL 1.4 features removed from GL 3.2")]
        public static void SecondaryColor3s(short red, short green, short blue) {
            GLNative.glSecondaryColor3s(red, green, blue);
        }

        /// <summary>
        /// set the current secondary color
        /// <para>Require:</para> <para>GL_VERSION_1_4</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glSecondaryColor"/> is available only if the GL version is 1.4 or greater.
        /// The initial value for the secondary color is (0, 0, 0, 0).
        /// The secondary color can be updated at any time.  In particular, <see cref="glSecondaryColor"/> can
        /// be called between a call to  <see cref="glBegin"/>  and the corresponding call to
        /// <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glSecondaryColor3ub(GLubyte red, GLubyte green, GLubyte blue);</para>
        /// </summary>
        /// <param name="red">
        /// Specify new red, green, and blue values for the current secondary color.
        /// </param>
        /// <param name="green">
        /// Specify new red, green, and blue values for the current secondary color.
        /// </param>
        /// <param name="blue">
        /// Specify new red, green, and blue values for the current secondary color.
        /// </param>
        /// <seealso cref="Color"/>
        /// <seealso cref="Index"/>
        /// <seealso cref="IsEnabled"/>
        /// <seealso cref="LightModel"/>
        /// <seealso cref="SecondaryColorPointer"/>
        [Obsolete("Compatibility-only GL 1.4 features removed from GL 3.2")]
        public static void SecondaryColor3ub(byte red, byte green, byte blue) {
            GLNative.glSecondaryColor3ub(red, green, blue);
        }

        /// <summary>
        /// set the current secondary color
        /// <para>Require:</para> <para>GL_VERSION_1_4</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glSecondaryColor"/> is available only if the GL version is 1.4 or greater.
        /// The initial value for the secondary color is (0, 0, 0, 0).
        /// The secondary color can be updated at any time.  In particular, <see cref="glSecondaryColor"/> can
        /// be called between a call to  <see cref="glBegin"/>  and the corresponding call to
        /// <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glSecondaryColor3ui(GLuint red, GLuint green, GLuint blue);</para>
        /// </summary>
        /// <param name="red">
        /// Specify new red, green, and blue values for the current secondary color.
        /// </param>
        /// <param name="green">
        /// Specify new red, green, and blue values for the current secondary color.
        /// </param>
        /// <param name="blue">
        /// Specify new red, green, and blue values for the current secondary color.
        /// </param>
        /// <seealso cref="Color"/>
        /// <seealso cref="Index"/>
        /// <seealso cref="IsEnabled"/>
        /// <seealso cref="LightModel"/>
        /// <seealso cref="SecondaryColorPointer"/>
        [Obsolete("Compatibility-only GL 1.4 features removed from GL 3.2")]
        public static void SecondaryColor3ui(uint red, uint green, uint blue) {
            GLNative.glSecondaryColor3ui(red, green, blue);
        }

        /// <summary>
        /// set the current secondary color
        /// <para>Require:</para> <para>GL_VERSION_1_4</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glSecondaryColor"/> is available only if the GL version is 1.4 or greater.
        /// The initial value for the secondary color is (0, 0, 0, 0).
        /// The secondary color can be updated at any time.  In particular, <see cref="glSecondaryColor"/> can
        /// be called between a call to  <see cref="glBegin"/>  and the corresponding call to
        /// <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glSecondaryColor3us(GLushort red, GLushort green, GLushort blue);</para>
        /// </summary>
        /// <param name="red">
        /// Specify new red, green, and blue values for the current secondary color.
        /// </param>
        /// <param name="green">
        /// Specify new red, green, and blue values for the current secondary color.
        /// </param>
        /// <param name="blue">
        /// Specify new red, green, and blue values for the current secondary color.
        /// </param>
        /// <seealso cref="Color"/>
        /// <seealso cref="Index"/>
        /// <seealso cref="IsEnabled"/>
        /// <seealso cref="LightModel"/>
        /// <seealso cref="SecondaryColorPointer"/>
        [Obsolete("Compatibility-only GL 1.4 features removed from GL 3.2")]
        public static void SecondaryColor3us(ushort red, ushort green, ushort blue) {
            GLNative.glSecondaryColor3us(red, green, blue);
        }

        /// <summary>
        /// specify the raster position in window coordinates for pixel operations
        /// <para>Require:</para> <para>GL_VERSION_1_4</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glWindowPos"/> is available only if the GL version is 1.4 or greater.
        /// The raster position is modified by  <see cref="glRasterPos"/> ,  <see cref="glBitmap"/> , and
        /// <see cref="glWindowPos"/>.
        /// Calling  <see cref="glDrawElements"/> , or  <see cref="glDrawRangeElements"/>  may leave the
        /// current color or index indeterminate.
        /// If <see cref="glWindowPos"/> is executed while the current color or index is indeterminate, the
        /// current raster color or current raster index remains indeterminate.
        /// There are distinct raster texture coordinates for each texture unit. Each
        /// texture unit's current raster texture coordinates are updated by <see cref="glWindowPos"/>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glWindowPos"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glWindowPos2d(GLdouble x, GLdouble y);</para>
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify the 
        /// x   ,
        /// y   ,
        /// z   
        /// coordinates for the raster position.
        /// </para>
        /// </param>
        /// <param name="y">
        /// <para>
        /// Specify the 
        /// x   ,
        /// y   ,
        /// z   
        /// coordinates for the raster position.
        /// </para>
        /// </param>
        /// <seealso cref="Bitmap"/>
        /// <seealso cref="CopyPixels"/>
        /// <seealso cref="DrawArrays"/>
        /// <seealso cref="DrawElements"/>
        /// <seealso cref="DrawRangeElements"/>
        /// <seealso cref="DrawPixels"/>
        /// <seealso cref="MultiTexCoord"/>
        /// <seealso cref="RasterPos"/>
        /// <seealso cref="TexCoord"/>
        /// <seealso cref="TexGen"/>
        /// <seealso cref="Vertex"/>
        [Obsolete("Compatibility-only GL 1.4 features removed from GL 3.2")]
        public static void WindowPos2d(double x, double y) {
            GLNative.glWindowPos2d(x, y);
        }

        /// <summary>
        /// specify the raster position in window coordinates for pixel operations
        /// <para>Require:</para> <para>GL_VERSION_1_4</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glWindowPos"/> is available only if the GL version is 1.4 or greater.
        /// The raster position is modified by  <see cref="glRasterPos"/> ,  <see cref="glBitmap"/> , and
        /// <see cref="glWindowPos"/>.
        /// Calling  <see cref="glDrawElements"/> , or  <see cref="glDrawRangeElements"/>  may leave the
        /// current color or index indeterminate.
        /// If <see cref="glWindowPos"/> is executed while the current color or index is indeterminate, the
        /// current raster color or current raster index remains indeterminate.
        /// There are distinct raster texture coordinates for each texture unit. Each
        /// texture unit's current raster texture coordinates are updated by <see cref="glWindowPos"/>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glWindowPos"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glWindowPos2f(GLfloat x, GLfloat y);</para>
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify the 
        /// x   ,
        /// y   ,
        /// z   
        /// coordinates for the raster position.
        /// </para>
        /// </param>
        /// <param name="y">
        /// <para>
        /// Specify the 
        /// x   ,
        /// y   ,
        /// z   
        /// coordinates for the raster position.
        /// </para>
        /// </param>
        /// <seealso cref="Bitmap"/>
        /// <seealso cref="CopyPixels"/>
        /// <seealso cref="DrawArrays"/>
        /// <seealso cref="DrawElements"/>
        /// <seealso cref="DrawRangeElements"/>
        /// <seealso cref="DrawPixels"/>
        /// <seealso cref="MultiTexCoord"/>
        /// <seealso cref="RasterPos"/>
        /// <seealso cref="TexCoord"/>
        /// <seealso cref="TexGen"/>
        /// <seealso cref="Vertex"/>
        [Obsolete("Compatibility-only GL 1.4 features removed from GL 3.2")]
        public static void WindowPos2f(float x, float y) {
            GLNative.glWindowPos2f(x, y);
        }

        /// <summary>
        /// specify the raster position in window coordinates for pixel operations
        /// <para>Require:</para> <para>GL_VERSION_1_4</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glWindowPos"/> is available only if the GL version is 1.4 or greater.
        /// The raster position is modified by  <see cref="glRasterPos"/> ,  <see cref="glBitmap"/> , and
        /// <see cref="glWindowPos"/>.
        /// Calling  <see cref="glDrawElements"/> , or  <see cref="glDrawRangeElements"/>  may leave the
        /// current color or index indeterminate.
        /// If <see cref="glWindowPos"/> is executed while the current color or index is indeterminate, the
        /// current raster color or current raster index remains indeterminate.
        /// There are distinct raster texture coordinates for each texture unit. Each
        /// texture unit's current raster texture coordinates are updated by <see cref="glWindowPos"/>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glWindowPos"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glWindowPos2i(GLint x, GLint y);</para>
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify the 
        /// x   ,
        /// y   ,
        /// z   
        /// coordinates for the raster position.
        /// </para>
        /// </param>
        /// <param name="y">
        /// <para>
        /// Specify the 
        /// x   ,
        /// y   ,
        /// z   
        /// coordinates for the raster position.
        /// </para>
        /// </param>
        /// <seealso cref="Bitmap"/>
        /// <seealso cref="CopyPixels"/>
        /// <seealso cref="DrawArrays"/>
        /// <seealso cref="DrawElements"/>
        /// <seealso cref="DrawRangeElements"/>
        /// <seealso cref="DrawPixels"/>
        /// <seealso cref="MultiTexCoord"/>
        /// <seealso cref="RasterPos"/>
        /// <seealso cref="TexCoord"/>
        /// <seealso cref="TexGen"/>
        /// <seealso cref="Vertex"/>
        [Obsolete("Compatibility-only GL 1.4 features removed from GL 3.2")]
        public static void WindowPos2i(int x, int y) {
            GLNative.glWindowPos2i(x, y);
        }

        /// <summary>
        /// specify the raster position in window coordinates for pixel operations
        /// <para>Require:</para> <para>GL_VERSION_1_4</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glWindowPos"/> is available only if the GL version is 1.4 or greater.
        /// The raster position is modified by  <see cref="glRasterPos"/> ,  <see cref="glBitmap"/> , and
        /// <see cref="glWindowPos"/>.
        /// Calling  <see cref="glDrawElements"/> , or  <see cref="glDrawRangeElements"/>  may leave the
        /// current color or index indeterminate.
        /// If <see cref="glWindowPos"/> is executed while the current color or index is indeterminate, the
        /// current raster color or current raster index remains indeterminate.
        /// There are distinct raster texture coordinates for each texture unit. Each
        /// texture unit's current raster texture coordinates are updated by <see cref="glWindowPos"/>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glWindowPos"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glWindowPos2s(GLshort x, GLshort y);</para>
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify the 
        /// x   ,
        /// y   ,
        /// z   
        /// coordinates for the raster position.
        /// </para>
        /// </param>
        /// <param name="y">
        /// <para>
        /// Specify the 
        /// x   ,
        /// y   ,
        /// z   
        /// coordinates for the raster position.
        /// </para>
        /// </param>
        /// <seealso cref="Bitmap"/>
        /// <seealso cref="CopyPixels"/>
        /// <seealso cref="DrawArrays"/>
        /// <seealso cref="DrawElements"/>
        /// <seealso cref="DrawRangeElements"/>
        /// <seealso cref="DrawPixels"/>
        /// <seealso cref="MultiTexCoord"/>
        /// <seealso cref="RasterPos"/>
        /// <seealso cref="TexCoord"/>
        /// <seealso cref="TexGen"/>
        /// <seealso cref="Vertex"/>
        [Obsolete("Compatibility-only GL 1.4 features removed from GL 3.2")]
        public static void WindowPos2s(short x, short y) {
            GLNative.glWindowPos2s(x, y);
        }

        /// <summary>
        /// specify the raster position in window coordinates for pixel operations
        /// <para>Require:</para> <para>GL_VERSION_1_4</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glWindowPos"/> is available only if the GL version is 1.4 or greater.
        /// The raster position is modified by  <see cref="glRasterPos"/> ,  <see cref="glBitmap"/> , and
        /// <see cref="glWindowPos"/>.
        /// Calling  <see cref="glDrawElements"/> , or  <see cref="glDrawRangeElements"/>  may leave the
        /// current color or index indeterminate.
        /// If <see cref="glWindowPos"/> is executed while the current color or index is indeterminate, the
        /// current raster color or current raster index remains indeterminate.
        /// There are distinct raster texture coordinates for each texture unit. Each
        /// texture unit's current raster texture coordinates are updated by <see cref="glWindowPos"/>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glWindowPos"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glWindowPos3d(GLdouble x, GLdouble y, GLdouble z);</para>
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify the 
        /// x   ,
        /// y   ,
        /// z   
        /// coordinates for the raster position.
        /// </para>
        /// </param>
        /// <param name="y">
        /// <para>
        /// Specify the 
        /// x   ,
        /// y   ,
        /// z   
        /// coordinates for the raster position.
        /// </para>
        /// </param>
        /// <param name="z">
        /// <para>
        /// Specify the 
        /// x   ,
        /// y   ,
        /// z   
        /// coordinates for the raster position.
        /// </para>
        /// </param>
        /// <seealso cref="Bitmap"/>
        /// <seealso cref="CopyPixels"/>
        /// <seealso cref="DrawArrays"/>
        /// <seealso cref="DrawElements"/>
        /// <seealso cref="DrawRangeElements"/>
        /// <seealso cref="DrawPixels"/>
        /// <seealso cref="MultiTexCoord"/>
        /// <seealso cref="RasterPos"/>
        /// <seealso cref="TexCoord"/>
        /// <seealso cref="TexGen"/>
        /// <seealso cref="Vertex"/>
        [Obsolete("Compatibility-only GL 1.4 features removed from GL 3.2")]
        public static void WindowPos3d(double x, double y, double z) {
            GLNative.glWindowPos3d(x, y, z);
        }

        /// <summary>
        /// specify the raster position in window coordinates for pixel operations
        /// <para>Require:</para> <para>GL_VERSION_1_4</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glWindowPos"/> is available only if the GL version is 1.4 or greater.
        /// The raster position is modified by  <see cref="glRasterPos"/> ,  <see cref="glBitmap"/> , and
        /// <see cref="glWindowPos"/>.
        /// Calling  <see cref="glDrawElements"/> , or  <see cref="glDrawRangeElements"/>  may leave the
        /// current color or index indeterminate.
        /// If <see cref="glWindowPos"/> is executed while the current color or index is indeterminate, the
        /// current raster color or current raster index remains indeterminate.
        /// There are distinct raster texture coordinates for each texture unit. Each
        /// texture unit's current raster texture coordinates are updated by <see cref="glWindowPos"/>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glWindowPos"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glWindowPos3f(GLfloat x, GLfloat y, GLfloat z);</para>
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify the 
        /// x   ,
        /// y   ,
        /// z   
        /// coordinates for the raster position.
        /// </para>
        /// </param>
        /// <param name="y">
        /// <para>
        /// Specify the 
        /// x   ,
        /// y   ,
        /// z   
        /// coordinates for the raster position.
        /// </para>
        /// </param>
        /// <param name="z">
        /// <para>
        /// Specify the 
        /// x   ,
        /// y   ,
        /// z   
        /// coordinates for the raster position.
        /// </para>
        /// </param>
        /// <seealso cref="Bitmap"/>
        /// <seealso cref="CopyPixels"/>
        /// <seealso cref="DrawArrays"/>
        /// <seealso cref="DrawElements"/>
        /// <seealso cref="DrawRangeElements"/>
        /// <seealso cref="DrawPixels"/>
        /// <seealso cref="MultiTexCoord"/>
        /// <seealso cref="RasterPos"/>
        /// <seealso cref="TexCoord"/>
        /// <seealso cref="TexGen"/>
        /// <seealso cref="Vertex"/>
        [Obsolete("Compatibility-only GL 1.4 features removed from GL 3.2")]
        public static void WindowPos3f(float x, float y, float z) {
            GLNative.glWindowPos3f(x, y, z);
        }

        /// <summary>
        /// specify the raster position in window coordinates for pixel operations
        /// <para>Require:</para> <para>GL_VERSION_1_4</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glWindowPos"/> is available only if the GL version is 1.4 or greater.
        /// The raster position is modified by  <see cref="glRasterPos"/> ,  <see cref="glBitmap"/> , and
        /// <see cref="glWindowPos"/>.
        /// Calling  <see cref="glDrawElements"/> , or  <see cref="glDrawRangeElements"/>  may leave the
        /// current color or index indeterminate.
        /// If <see cref="glWindowPos"/> is executed while the current color or index is indeterminate, the
        /// current raster color or current raster index remains indeterminate.
        /// There are distinct raster texture coordinates for each texture unit. Each
        /// texture unit's current raster texture coordinates are updated by <see cref="glWindowPos"/>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glWindowPos"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glWindowPos3i(GLint x, GLint y, GLint z);</para>
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify the 
        /// x   ,
        /// y   ,
        /// z   
        /// coordinates for the raster position.
        /// </para>
        /// </param>
        /// <param name="y">
        /// <para>
        /// Specify the 
        /// x   ,
        /// y   ,
        /// z   
        /// coordinates for the raster position.
        /// </para>
        /// </param>
        /// <param name="z">
        /// <para>
        /// Specify the 
        /// x   ,
        /// y   ,
        /// z   
        /// coordinates for the raster position.
        /// </para>
        /// </param>
        /// <seealso cref="Bitmap"/>
        /// <seealso cref="CopyPixels"/>
        /// <seealso cref="DrawArrays"/>
        /// <seealso cref="DrawElements"/>
        /// <seealso cref="DrawRangeElements"/>
        /// <seealso cref="DrawPixels"/>
        /// <seealso cref="MultiTexCoord"/>
        /// <seealso cref="RasterPos"/>
        /// <seealso cref="TexCoord"/>
        /// <seealso cref="TexGen"/>
        /// <seealso cref="Vertex"/>
        [Obsolete("Compatibility-only GL 1.4 features removed from GL 3.2")]
        public static void WindowPos3i(int x, int y, int z) {
            GLNative.glWindowPos3i(x, y, z);
        }

        /// <summary>
        /// specify the raster position in window coordinates for pixel operations
        /// <para>Require:</para> <para>GL_VERSION_1_4</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glWindowPos"/> is available only if the GL version is 1.4 or greater.
        /// The raster position is modified by  <see cref="glRasterPos"/> ,  <see cref="glBitmap"/> , and
        /// <see cref="glWindowPos"/>.
        /// Calling  <see cref="glDrawElements"/> , or  <see cref="glDrawRangeElements"/>  may leave the
        /// current color or index indeterminate.
        /// If <see cref="glWindowPos"/> is executed while the current color or index is indeterminate, the
        /// current raster color or current raster index remains indeterminate.
        /// There are distinct raster texture coordinates for each texture unit. Each
        /// texture unit's current raster texture coordinates are updated by <see cref="glWindowPos"/>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glWindowPos"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glWindowPos3s(GLshort x, GLshort y, GLshort z);</para>
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify the 
        /// x   ,
        /// y   ,
        /// z   
        /// coordinates for the raster position.
        /// </para>
        /// </param>
        /// <param name="y">
        /// <para>
        /// Specify the 
        /// x   ,
        /// y   ,
        /// z   
        /// coordinates for the raster position.
        /// </para>
        /// </param>
        /// <param name="z">
        /// <para>
        /// Specify the 
        /// x   ,
        /// y   ,
        /// z   
        /// coordinates for the raster position.
        /// </para>
        /// </param>
        /// <seealso cref="Bitmap"/>
        /// <seealso cref="CopyPixels"/>
        /// <seealso cref="DrawArrays"/>
        /// <seealso cref="DrawElements"/>
        /// <seealso cref="DrawRangeElements"/>
        /// <seealso cref="DrawPixels"/>
        /// <seealso cref="MultiTexCoord"/>
        /// <seealso cref="RasterPos"/>
        /// <seealso cref="TexCoord"/>
        /// <seealso cref="TexGen"/>
        /// <seealso cref="Vertex"/>
        [Obsolete("Compatibility-only GL 1.4 features removed from GL 3.2")]
        public static void WindowPos3s(short x, short y, short z) {
            GLNative.glWindowPos3s(x, y, z);
        }


        #region Promoted from ARB_imaging subset to core

        /// <summary>
        /// set the blend color
        /// <para>Require:</para> <para>GL_VERSION_1_4, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0, GL_ARB_imaging</para>
        /// Supported: <para>gl, glcore</para>
        /// Notes: 
        /// <para>
        /// <see cref="glBlendColor"/> is part of the <code>ARB_imaging</code> subset. <see cref="glBlendColor"/> is present only
        /// if <code>ARB_imaging</code> is returned when  <see cref="glGetString"/>  is called with
        /// <code>GL_EXTENSIONS</code> as its argument.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glBlendColor"/> is executed
        /// between the execution of  <see cref="glBegin"/>  and the corresponding
        /// execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glBlendColor(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha);</para>
        /// </summary>
        /// <param name="red">
        /// specify the components of <code>GL_BLEND_COLOR</code>
        /// </param>
        /// <param name="green">
        /// specify the components of <code>GL_BLEND_COLOR</code>
        /// </param>
        /// <param name="blue">
        /// specify the components of <code>GL_BLEND_COLOR</code>
        /// </param>
        /// <param name="alpha">
        /// specify the components of <code>GL_BLEND_COLOR</code>
        /// </param>
        /// <seealso cref="BlendEquation"/>
        /// <seealso cref="BlendFunc"/>
        /// <seealso cref="GetString"/>
        public static void BlendColor(float red, float green, float blue, float alpha) {
            GLNative.glBlendColor(red, green, blue, alpha);
        }

        /// <summary>
        /// specify the equation used for both the RGB blend equation and the Alpha blend equation
        /// <para>Require:</para> <para>GL_VERSION_1_4, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0, GL_ARB_imaging</para>
        /// Supported: <para>gl, glcore</para>
        /// Notes: 
        /// <para>
        /// The <code>GL_MIN</code>, and <code>GL_MAX</code> equations do not use
        /// the source or destination factors, only the source and destination colors.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="mode"/> is not one of
        /// <code>GL_FUNC_ADD</code>, <code>GL_FUNC_SUBTRACT</code>, <code>GL_FUNC_REVERSE_SUBTRACT</code>,
        /// <code>GL_MAX</code>, or <code>GL_MIN</code>.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glBlendEquation"/> is executed
        /// between the execution of  <see cref="glBegin"/>  and the corresponding
        /// execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glBlendEquation(GLenum mode);</para>
        /// </summary>
        /// <param name="mode">
        /// <para>
        /// specifies how source and destination colors are combined.
        /// It must be <code>GL_FUNC_ADD</code>, <code>GL_FUNC_SUBTRACT</code>,
        /// <code>GL_FUNC_REVERSE_SUBTRACT</code>, <code>GL_MIN</code>, <code>GL_MAX</code>.
        /// </para>
        /// </param>
        /// <seealso cref="GetString"/>
        /// <seealso cref="BlendColor"/>
        /// <seealso cref="BlendFunc"/>
        /// <seealso cref="BlendFuncSeparate"/>
        public static void BlendEquation(uint mode) {
            GLNative.glBlendEquation(mode);
        }


        #endregion Promoted from ARB_imaging subset to core

        #endregion GL_VERSION_1_4

        #region GL_VERSION_1_5

        /// <summary>
        /// determine if a name corresponds to a query object
        /// <para>Require:</para> <para>GL_VERSION_1_5, GL_ES_VERSION_3_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <see cref="glIsQuery"/> is available only if the GL version is 1.5 or greater.
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glIsQuery"/> is executed
        /// between the execution of  <see cref="glBegin"/>  and the corresponding
        /// execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>GLboolean glIsQuery(GLuint id);</para>
        /// </summary>
        /// <param name="id">
        /// Specifies a value that may be the name of a query object.
        /// </param>
        /// <seealso cref="BeginQuery"/>
        /// <seealso cref="DeleteQueries"/>
        /// <seealso cref="EndQuery"/>
        /// <seealso cref="GenQueries"/>
        public static bool IsQuery(uint id) {
            return GLNative.glIsQuery(id);
        }

        /// <summary>
        /// delimit the boundaries of a query object
        /// <para>Require:</para> <para>GL_VERSION_1_5, GL_ES_VERSION_3_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// If the samples-passed count exceeds the maximum value representable in the number of available bits, as reported by
        /// <see cref="glGetQueryiv"/>  with <paramref name="pname"/>
        /// <code>GL_QUERY_COUNTER_BITS</code>, the count becomes undefined.
        /// An implementation may support 0 bits in its samples-passed counter, in which case query results are always undefined
        /// and essentially useless.
        /// When <code>GL_SAMPLE_BUFFERS</code> is 0, the samples-passed counter will increment once for each fragment that passes
        /// the depth test.  When <code>GL_SAMPLE_BUFFERS</code> is 1, an implementation may either increment the samples-passed
        /// counter individually for each sample of a fragment that passes the depth test, or it may choose to increment the counter for
        /// all samples of a fragment if any one of them passes the depth test.
        /// <see cref="glBeginQuery"/> and  <see cref="glEndQuery"/> 
        /// are available only if the GL version is 1.5 or greater.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="target"/> is not <code>GL_SAMPLES_PASSED</code>.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glBeginQuery"/> is executed while
        /// a query object of the same <paramref name="target"/> is already active.
        /// <code>GL_INVALID_OPERATION</code> is generated if  <see cref="glEndQuery"/> 
        /// is executed when a query object of the same <paramref name="target"/> is not active.
        /// <code>GL_INVALID_OPERATION</code> is generated if <paramref name="id"/> is 0.
        /// <code>GL_INVALID_OPERATION</code> is generated if <paramref name="id"/> is the name of an already active query object.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glBeginQuery"/> or
        /// <see cref="glEndQuery"/>  is executed between the execution of
        /// <see cref="glBegin"/>  and the corresponding execution of
        /// <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glBeginQuery(GLenum target, GLuint id);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target type of query object established between
        /// <see cref="glBeginQuery"/> and the subsequent  <see cref="glEndQuery"/> .
        /// The symbolic constant must be <code>GL_SAMPLES_PASSED</code>.
        /// </para>
        /// </param>
        /// <param name="id">
        /// Specifies the name of a query object.
        /// </param>
        /// <seealso cref="DeleteQueries"/>
        /// <seealso cref="GenQueries"/>
        /// <seealso cref="GetQueryiv"/>
        /// <seealso cref="GetQueryObject"/>
        /// <seealso cref="IsQuery"/>
        public static void BeginQuery(uint target, uint id) {
            GLNative.glBeginQuery(target, id);
        }

        /// <summary>
        /// delimit the boundaries of a query object
        /// <para>Require:</para> <para>GL_VERSION_1_5, GL_ES_VERSION_3_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// If the samples-passed count exceeds the maximum value representable in the number of available bits, as reported by
        /// <see cref="glGetQueryiv"/>  with <paramref name="pname"/>
        /// <code>GL_QUERY_COUNTER_BITS</code>, the count becomes undefined.
        /// An implementation may support 0 bits in its samples-passed counter, in which case query results are always undefined
        /// and essentially useless.
        /// When <code>GL_SAMPLE_BUFFERS</code> is 0, the samples-passed counter will increment once for each fragment that passes
        /// the depth test.  When <code>GL_SAMPLE_BUFFERS</code> is 1, an implementation may either increment the samples-passed
        /// counter individually for each sample of a fragment that passes the depth test, or it may choose to increment the counter for
        /// all samples of a fragment if any one of them passes the depth test.
        /// <see cref="glBeginQuery"/> and  <see cref="glEndQuery"/> 
        /// are available only if the GL version is 1.5 or greater.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="target"/> is not <code>GL_SAMPLES_PASSED</code>.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glBeginQuery"/> is executed while
        /// a query object of the same <paramref name="target"/> is already active.
        /// <code>GL_INVALID_OPERATION</code> is generated if  <see cref="glEndQuery"/> 
        /// is executed when a query object of the same <paramref name="target"/> is not active.
        /// <code>GL_INVALID_OPERATION</code> is generated if <paramref name="id"/> is 0.
        /// <code>GL_INVALID_OPERATION</code> is generated if <paramref name="id"/> is the name of an already active query object.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glBeginQuery"/> or
        /// <see cref="glEndQuery"/>  is executed between the execution of
        /// <see cref="glBegin"/>  and the corresponding execution of
        /// <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glEndQuery(GLenum target);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target type of query object to be concluded.
        /// The symbolic constant must be <code>GL_SAMPLES_PASSED</code>.
        /// </para>
        /// </param>
        /// <seealso cref="DeleteQueries"/>
        /// <seealso cref="GenQueries"/>
        /// <seealso cref="GetQueryiv"/>
        /// <seealso cref="GetQueryObject"/>
        /// <seealso cref="IsQuery"/>
        public static void EndQuery(uint target) {
            GLNative.glEndQuery(target);
        }

        /// <summary>
        /// bind a named buffer object
        /// <para>Require:</para> <para>GL_VERSION_1_5, GL_VERSION_ES_CM_1_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glBindBuffer"/> is available only if the GL version is 1.5 or greater.
        /// <code>GL_PIXEL_PACK_BUFFER</code> and <code>GL_PIXEL_UNPACK_BUFFER</code> are 
        /// available only if the GL version is 2.1 or greater.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="target"/> is not one of the allowable
        /// values.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glBindBuffer"/> is executed
        /// between the execution of  <see cref="glBegin"/>  and the corresponding
        /// execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glBindBuffer(GLenum target, GLuint buffer);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target to which the buffer object is bound.
        /// The symbolic constant must be
        /// <code>GL_ARRAY_BUFFER</code>,
        /// <code>GL_ELEMENT_ARRAY_BUFFER</code>,
        /// <code>GL_PIXEL_PACK_BUFFER</code>, or
        /// <code>GL_PIXEL_UNPACK_BUFFER</code>.
        /// </para>
        /// </param>
        /// <param name="buffer">
        /// Specifies the name of a buffer object.
        /// </param>
        /// <seealso cref="DeleteBuffers"/>
        /// <seealso cref="GenBuffers"/>
        /// <seealso cref="Get"/>
        /// <seealso cref="IsBuffer"/>
        public static void BindBuffer(uint target, uint buffer) {
            GLNative.glBindBuffer(target, buffer);
        }

        /// <summary>
        /// determine if a name corresponds to a buffer object
        /// <para>Require:</para> <para>GL_VERSION_1_5, GL_VERSION_ES_CM_1_0, GL_ES_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <see cref="glIsBuffer"/> is available only if the GL version is 1.5 or greater.
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glIsBuffer"/> is executed
        /// between the execution of  <see cref="glBegin"/>  and the corresponding
        /// execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>GLboolean glIsBuffer(GLuint buffer);</para>
        /// </summary>
        /// <param name="buffer">
        /// Specifies a value that may be the name of a buffer object.
        /// </param>
        /// <seealso cref="BindBuffer"/>
        /// <seealso cref="DeleteBuffers"/>
        /// <seealso cref="GenBuffers"/>
        /// <seealso cref="Get"/>
        public static bool IsBuffer(uint buffer) {
            return GLNative.glIsBuffer(buffer);
        }

        /// <summary>
        /// map a buffer object's data store
        /// <para>Require:</para> <para>GL_VERSION_1_5, GL_ES_VERSION_3_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// If an error is generated, <see cref="glMapBuffer"/> returns <code>NULL</code>, and
        /// <see cref="glUnmapBuffer"/> returns <code>GL_FALSE</code>.
        /// <see cref="glMapBuffer"/> and <see cref="glUnmapBuffer"/> are available only if the GL version is 1.5 or greater.
        /// <code>GL_PIXEL_PACK_BUFFER</code> and <code>GL_PIXEL_UNPACK_BUFFER</code> are 
        /// available only if the GL version is 2.1 or greater.
        /// Parameter values passed to GL commands may not be sourced from the returned pointer. No error will be generated,
        /// but results will be undefined and will likely vary across GL implementations.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="target"/> is not 
        /// <code>GL_ARRAY_BUFFER</code>, <code>GL_ELEMENT_ARRAY_BUFFER</code>, 
        /// <code>GL_PIXEL_PACK_BUFFER</code>, or <code>GL_PIXEL_UNPACK_BUFFER</code>.
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="access"/> is not 
        /// <code>GL_READ_ONLY</code>, <code>GL_WRITE_ONLY</code>, or <code>GL_READ_WRITE</code>.
        /// <code>GL_OUT_OF_MEMORY</code> is generated when <see cref="glMapBuffer"/> is executed
        /// if the GL is unable to map the buffer object's data store. This may occur for a variety of system-specific 
        /// reasons, such as the absence of sufficient remaining virtual memory.
        /// <code>GL_INVALID_OPERATION</code> is generated if the reserved buffer object name 0 is bound to <paramref name="target"/>.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glMapBuffer"/> is executed for
        /// a buffer object whose data store is already mapped.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glUnmapBuffer"/> is executed for
        /// a buffer object whose data store is not currently mapped.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glMapBuffer"/> or <see cref="glUnmapBuffer"/> is executed
        /// between the execution of  <see cref="glBegin"/>  and the corresponding
        /// execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>GLboolean glUnmapBuffer(GLenum target);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target buffer object being unmapped.
        /// The symbolic constant must be
        /// <code>GL_ARRAY_BUFFER</code>,
        /// <code>GL_ELEMENT_ARRAY_BUFFER</code>,
        /// <code>GL_PIXEL_PACK_BUFFER</code>, or
        /// <code>GL_PIXEL_UNPACK_BUFFER</code>.
        /// </para>
        /// </param>
        /// <seealso cref="BindBuffer"/>
        /// <seealso cref="BufferData"/>
        /// <seealso cref="BufferSubData"/>
        /// <seealso cref="DeleteBuffers"/>
        public static bool UnmapBuffer(uint target) {
            return GLNative.glUnmapBuffer(target);
        }


        #endregion GL_VERSION_1_5

        #region GL_VERSION_2_0

        /// <summary>
        /// set the RGB blend equation and the alpha blend equation separately
        /// <para>Require:</para> <para>GL_VERSION_2_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glBlendEquationSeparate"/> is available only if the GL version is 2.0 or greater.
        /// The <code>GL_MIN</code>, and <code>GL_MAX</code> equations do not use
        /// the source or destination factors, only the source and destination colors.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if either <paramref name="modeRGB"/> or <paramref name="modeAlpha"/> is not one of
        /// <code>GL_FUNC_ADD</code>, <code>GL_FUNC_SUBTRACT</code>, <code>GL_FUNC_REVERSE_SUBTRACT</code>,
        /// <code>GL_MAX</code>, or <code>GL_MIN</code>.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glBlendEquationSeparate"/> is executed
        /// between the execution of  <see cref="glBegin"/>  and the corresponding
        /// execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glBlendEquationSeparate(GLenum modeRGB, GLenum modeAlpha);</para>
        /// </summary>
        /// <param name="modeRGB">
        /// <para>
        /// specifies the RGB blend equation, how the red, green, and blue components of the source and destination colors are combined.
        /// It must be <code>GL_FUNC_ADD</code>, <code>GL_FUNC_SUBTRACT</code>,
        /// <code>GL_FUNC_REVERSE_SUBTRACT</code>, <code>GL_MIN</code>, <code>GL_MAX</code>.
        /// </para>
        /// </param>
        /// <param name="modeAlpha">
        /// <para>
        /// specifies the alpha blend equation, how the alpha component of the source and destination colors are combined.
        /// It must be <code>GL_FUNC_ADD</code>, <code>GL_FUNC_SUBTRACT</code>,
        /// <code>GL_FUNC_REVERSE_SUBTRACT</code>, <code>GL_MIN</code>, <code>GL_MAX</code>.
        /// </para>
        /// </param>
        /// <seealso cref="GetString"/>
        /// <seealso cref="BlendColor"/>
        /// <seealso cref="BlendFunc"/>
        /// <seealso cref="BlendFuncSeparate"/>
        public static void BlendEquationSeparate(uint modeRGB, uint modeAlpha) {
            GLNative.glBlendEquationSeparate(modeRGB, modeAlpha);
        }

        /// <summary>
        /// set front and/or back stencil test actions
        /// <para>Require:</para> <para>GL_VERSION_2_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glStencilOpSeparate"/> is available only if
        /// the GL version is 2.0 or greater.
        /// Initially the stencil test is disabled.
        /// If there is no stencil buffer,
        /// no stencil modification can occur
        /// and it is as if the stencil test always passes.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="face"/> is any value 
        /// other than <code>GL_FRONT</code>, <code>GL_BACK</code>, or <code>GL_FRONT_AND_BACK</code>.
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="sfail"/>,
        /// <paramref name="dpfail"/>, or <paramref name="dppass"/> is any value other than the eight defined constant values.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glStencilOpSeparate"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glStencilOpSeparate(GLenum face, GLenum sfail, GLenum dpfail, GLenum dppass);</para>
        /// </summary>
        /// <param name="face">
        /// <para>
        /// Specifies whether front and/or back stencil state is updated.
        /// Three symbolic constants are valid:
        /// <code>GL_FRONT</code>,
        /// <code>GL_BACK</code>, and
        /// <code>GL_FRONT_AND_BACK</code>.
        /// </para>
        /// </param>
        /// <param name="sfail">
        /// <para>
        /// Specifies the action to take when the stencil test fails.
        /// Eight symbolic constants are accepted:
        /// <code>GL_KEEP</code>,
        /// <code>GL_ZERO</code>,
        /// <code>GL_REPLACE</code>,
        /// <code>GL_INCR</code>,
        /// <code>GL_INCR_WRAP</code>,
        /// <code>GL_DECR</code>,
        /// <code>GL_DECR_WRAP</code>, and
        /// <code>GL_INVERT</code>. The initial value is <code>GL_KEEP</code>.
        /// </para>
        /// </param>
        /// <param name="dpfail">
        /// <para>
        /// Specifies the stencil action when the stencil test passes,
        /// but the depth test fails.
        /// <paramref name="dpfail"/> accepts the same symbolic constants as <paramref name="sfail"/>. The initial value
        /// is <code>GL_KEEP</code>.
        /// </para>
        /// </param>
        /// <param name="dppass">
        /// <para>
        /// Specifies the stencil action when both the stencil test and the depth
        /// test pass, or when the stencil test passes and either there is no
        /// depth buffer or depth testing is not enabled.
        /// <paramref name="dppass"/> accepts the same symbolic constants as <paramref name="sfail"/>. The initial value
        /// is <code>GL_KEEP</code>.
        /// </para>
        /// </param>
        /// <seealso cref="AlphaFunc"/>
        /// <seealso cref="BlendFunc"/>
        /// <seealso cref="DepthFunc"/>
        /// <seealso cref="Enable"/>
        /// <seealso cref="LogicOp"/>
        /// <seealso cref="StencilFunc"/>
        /// <seealso cref="StencilFuncSeparate"/>
        /// <seealso cref="StencilMask"/>
        /// <seealso cref="StencilMaskSeparate"/>
        /// <seealso cref="StencilOp"/>
        public static void StencilOpSeparate(uint face, uint sfail, uint dpfail, uint dppass) {
            GLNative.glStencilOpSeparate(face, sfail, dpfail, dppass);
        }

        /// <summary>
        /// set front and/or back function and reference value for stencil testing
        /// <para>Require:</para> <para>GL_VERSION_2_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glStencilFuncSeparate"/> is available only if
        /// the GL version is 2.0 or greater.
        /// Initially, the stencil test is disabled.
        /// If there is no stencil buffer,
        /// no stencil modification can occur and it is as if
        /// the stencil test always passes.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="func"/> is not one of the eight
        /// accepted values.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glStencilFuncSeparate"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glStencilFuncSeparate(GLenum face, GLenum func, GLint ref, GLuint mask);</para>
        /// </summary>
        /// <param name="face">
        /// <para>
        /// Specifies whether front and/or back stencil state is updated.
        /// Three symbolic constants are valid:
        /// <code>GL_FRONT</code>,
        /// <code>GL_BACK</code>, and
        /// <code>GL_FRONT_AND_BACK</code>.
        /// </para>
        /// </param>
        /// <param name="func">
        /// <para>
        /// Specifies the test function.
        /// Eight symbolic constants are valid:
        /// <code>GL_NEVER</code>,
        /// <code>GL_LESS</code>,
        /// <code>GL_LEQUAL</code>,
        /// <code>GL_GREATER</code>,
        /// <code>GL_GEQUAL</code>,
        /// <code>GL_EQUAL</code>,
        /// <code>GL_NOTEQUAL</code>, and
        /// <code>GL_ALWAYS</code>. The initial value is <code>GL_ALWAYS</code>.
        /// </para>
        /// </param>
        /// <param name="r">
        /// <para>
        /// Specifies the reference value for the stencil test.
        /// <paramref name="r"/> is clamped to the range 
        /// 0 
        /// 2 
        /// n 
        /// - 
        /// 1 
        /// ,
        /// where 
        /// n   
        /// is the number of bitplanes in the stencil buffer. The
        /// initial value is 0.
        /// </para>
        /// </param>
        /// <param name="mask">
        /// <para>
        /// Specifies a mask that is ANDed with both the reference value
        /// and the stored stencil value when the test is done. The initial value
        /// is all 1's.
        /// </para>
        /// </param>
        /// <seealso cref="AlphaFunc"/>
        /// <seealso cref="BlendFunc"/>
        /// <seealso cref="DepthFunc"/>
        /// <seealso cref="Enable"/>
        /// <seealso cref="LogicOp"/>
        /// <seealso cref="StencilFunc"/>
        /// <seealso cref="StencilMask"/>
        /// <seealso cref="StencilMaskSeparate"/>
        /// <seealso cref="StencilOp"/>
        /// <seealso cref="StencilOpSeparate"/>
        public static void StencilFuncSeparate(uint face, uint func, int r, uint mask) {
            GLNative.glStencilFuncSeparate(face, func, r, mask);
        }

        /// <summary>
        /// control the front and/or back writing of individual bits in the stencil planes
        /// <para>Require:</para> <para>GL_VERSION_2_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glStencilMaskSeparate"/> is available only if
        /// the GL version is 2.0 or greater.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glStencilMaskSeparate"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glStencilMaskSeparate(GLenum face, GLuint mask);</para>
        /// </summary>
        /// <param name="face">
        /// <para>
        /// Specifies whether the front and/or back stencil writemask is updated.
        /// Three symbolic constants are valid:
        /// <code>GL_FRONT</code>,
        /// <code>GL_BACK</code>, and
        /// <code>GL_FRONT_AND_BACK</code>.
        /// </para>
        /// </param>
        /// <param name="mask">
        /// <para>
        /// Specifies a bit mask to enable and disable writing of individual bits
        /// in the stencil planes.
        /// Initially, the mask is all 1's.
        /// </para>
        /// </param>
        /// <seealso cref="ColorMask"/>
        /// <seealso cref="DepthMask"/>
        /// <seealso cref="IndexMask"/>
        /// <seealso cref="StencilFunc"/>
        /// <seealso cref="StencilFuncSeparate"/>
        /// <seealso cref="StencilMask"/>
        /// <seealso cref="StencilOp"/>
        /// <seealso cref="StencilOpSeparate"/>
        public static void StencilMaskSeparate(uint face, uint mask) {
            GLNative.glStencilMaskSeparate(face, mask);
        }

        /// <summary>
        /// Attaches a shader object to a program object
        /// <para>Require:</para> <para>GL_VERSION_2_0, GL_ES_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glAttachShader"/>
        /// is available only if the GL version is 2.0 or greater.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if either
        /// <paramref name="program"/> or <paramref name="shader"/>
        /// is not a value generated by OpenGL. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <paramref name="program"/> is not a program object. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <paramref name="shader"/> is not a shader object. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <paramref name="shader"/> is already attached to
        /// <paramref name="program"/>. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <see cref="glAttachShader"/> is executed between the
        /// execution of
        /// <see cref="glBegin"/> 
        /// and the corresponding execution of
        /// <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glAttachShader(GLuint program, GLuint shader);</para>
        /// </summary>
        /// <param name="program">
        /// <para>
        /// Specifies the program object to which a shader
        /// object will be attached.
        /// </para>
        /// </param>
        /// <param name="shader">
        /// Specifies the shader object that is to be attached.
        /// </param>
        /// <seealso cref="CompileShader"/>
        /// <seealso cref="DetachShader"/>
        /// <seealso cref="LinkProgram"/>
        /// <seealso cref="ShaderSource"/>
        public static void AttachShader(uint program, uint shader) {
            GLNative.glAttachShader(program, shader);
        }

        /// <summary>
        /// Compiles a shader object
        /// <para>Require:</para> <para>GL_VERSION_2_0, GL_ES_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glCompileShader"/>
        /// is available only if the GL version is 2.0 or greater.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="shader"/> is not a value generated by
        /// OpenGL. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <paramref name="shader"/> is not a shader object. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <see cref="glCompileShader"/> is executed between the
        /// execution of
        /// <see cref="glBegin"/> 
        /// and the corresponding execution of
        /// <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glCompileShader(GLuint shader);</para>
        /// </summary>
        /// <param name="shader">
        /// <para>
        /// Specifies the shader object to be
        /// compiled.
        /// </para>
        /// </param>
        /// <seealso cref="CreateShader"/>
        /// <seealso cref="LinkProgram"/>
        /// <seealso cref="ShaderSource"/>
        public static void CompileShader(uint shader) {
            GLNative.glCompileShader(shader);
        }

        /// <summary>
        /// Creates a program object
        /// <para>Require:</para> <para>GL_VERSION_2_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glCreateProgram"/> is available only if
        /// the GL version is 2.0 or greater. 
        /// Like display lists and texture objects, the name space for
        /// program objects may be shared across a set of contexts, as long
        /// as the server sides of the contexts share the same address
        /// space. If the name space is shared across contexts, any attached
        /// objects and the data associated with those attached objects are
        /// shared as well. 
        /// Applications are responsible for providing the
        /// synchronization across API calls when objects are accessed from
        /// different execution threads.
        /// </para>
        /// Errors: 
        /// <para>
        /// This function returns 0 if an error occurs creating the program object. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <see cref="glCreateProgram"/> is executed between the
        /// execution of
        /// <see cref="glBegin"/> 
        /// and the corresponding execution of
        /// <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>GLuint glCreateProgram();</para>
        /// </summary>
        /// <seealso cref="AttachShader"/>
        /// <seealso cref="BindAttribLocation"/>
        /// <seealso cref="CreateShader"/>
        /// <seealso cref="DeleteProgram"/>
        /// <seealso cref="DetachShader"/>
        /// <seealso cref="LinkProgram"/>
        /// <seealso cref="Uniform"/>
        /// <seealso cref="UseProgram"/>
        /// <seealso cref="ValidateProgram"/>
        public static uint CreateProgram() {
            return GLNative.glCreateProgram();
        }

        /// <summary>
        /// Creates a shader object
        /// <para>Require:</para> <para>GL_VERSION_2_0, GL_ES_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glCreateShader"/> is available only if
        /// the GL version is 2.0 or greater. 
        /// Like display lists and texture objects, the name space for
        /// shader objects may be shared across a set of contexts, as long
        /// as the server sides of the contexts share the same address
        /// space. If the name space is shared across contexts, any attached
        /// objects and the data associated with those attached objects are
        /// shared as well. 
        /// Applications are responsible for providing the
        /// synchronization across API calls when objects are accessed from
        /// different execution threads.
        /// </para>
        /// Errors: 
        /// <para>
        /// This function returns 0 if an error occurs creating the
        /// shader object. 
        /// <code>GL_INVALID_ENUM</code> is generated if
        /// <paramref name="shaderType"/> is not an accepted value. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <see cref="glCreateShader"/> is executed between the
        /// execution of
        /// <see cref="glBegin"/> 
        /// and the corresponding execution of
        /// <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>GLuint glCreateShader(GLenum shaderType);</para>
        /// </summary>
        /// <param name="shaderType">
        /// <para>
        /// Specifies the type of shader to be created.
        /// Must be either <code>GL_VERTEX_SHADER</code>
        /// or <code>GL_FRAGMENT_SHADER</code>.
        /// </para>
        /// </param>
        /// <seealso cref="AttachShader"/>
        /// <seealso cref="CompileShader"/>
        /// <seealso cref="DeleteShader"/>
        /// <seealso cref="DetachShader"/>
        /// <seealso cref="ShaderSource"/>
        public static uint CreateShader(uint shaderType) {
            return GLNative.glCreateShader(shaderType);
        }

        /// <summary>
        /// Deletes a program object
        /// <para>Require:</para> <para>GL_VERSION_2_0, GL_ES_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glDeleteProgram"/> is available only if
        /// the GL version is 2.0 or greater.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="program"/> is not a value generated by
        /// OpenGL. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <see cref="glDeleteProgram"/> is executed between the
        /// execution of
        /// <see cref="glBegin"/> 
        /// and the corresponding execution of
        /// <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glDeleteProgram(GLuint program);</para>
        /// </summary>
        /// <param name="program">
        /// <para>
        /// Specifies the program object to be
        /// deleted.
        /// </para>
        /// </param>
        /// <seealso cref="CreateShader"/>
        /// <seealso cref="DetachShader"/>
        /// <seealso cref="UseProgram"/>
        public static void DeleteProgram(uint program) {
            GLNative.glDeleteProgram(program);
        }

        /// <summary>
        /// Deletes a shader object
        /// <para>Require:</para> <para>GL_VERSION_2_0, GL_ES_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glDeleteShader"/> is available only if
        /// the GL version is 2.0 or greater.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="shader"/> is not a value generated by
        /// OpenGL. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <see cref="glDeleteShader"/> is executed between the
        /// execution of
        /// <see cref="glBegin"/> 
        /// and the corresponding execution of
        /// <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glDeleteShader(GLuint shader);</para>
        /// </summary>
        /// <param name="shader">
        /// Specifies the shader object to be deleted.
        /// </param>
        /// <seealso cref="CreateProgram"/>
        /// <seealso cref="CreateShader"/>
        /// <seealso cref="DetachShader"/>
        /// <seealso cref="UseProgram"/>
        public static void DeleteShader(uint shader) {
            GLNative.glDeleteShader(shader);
        }

        /// <summary>
        /// Detaches a shader object from a program object to which it is attached
        /// <para>Require:</para> <para>GL_VERSION_2_0, GL_ES_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glDetachShader"/> is available only if
        /// the GL version is 2.0 or greater.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if either
        /// <paramref name="program"/> or <paramref name="shader"/>
        /// is a value that was not generated by OpenGL. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <paramref name="program"/> is not a program object. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <paramref name="shader"/> is not a shader object. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <paramref name="shader"/> is not attached to
        /// <paramref name="program"/>. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <see cref="glDetachShader"/> is executed between the
        /// execution of
        /// <see cref="glBegin"/> 
        /// and the corresponding execution of
        /// <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glDetachShader(GLuint program, GLuint shader);</para>
        /// </summary>
        /// <param name="program">
        /// <para>
        /// Specifies the program object from which to
        /// detach the shader object.
        /// </para>
        /// </param>
        /// <param name="shader">
        /// <para>
        /// Specifies the shader object to be
        /// detached.
        /// </para>
        /// </param>
        /// <seealso cref="AttachShader"/>
        public static void DetachShader(uint program, uint shader) {
            GLNative.glDetachShader(program, shader);
        }

        /// <summary>
        /// Enable or disable a generic vertex attribute array
        /// <para>Require:</para> <para>GL_VERSION_2_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glEnableVertexAttribArray"/> and
        /// <see cref="glDisableVertexAttribArray "/> are available
        /// only if the GL version is 2.0 or greater.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="index"/> is greater than or equal to
        /// <code>GL_MAX_VERTEX_ATTRIBS</code>. 
        /// <code>GL_INVALID_OPERATION</code> is generated if either
        /// <see cref="glEnableVertexAttribArray "/> or
        /// <see cref="glDisableVertexAttribArray "/> is executed
        /// between the execution of
        /// <see cref="glBegin"/> 
        /// and the corresponding execution of
        /// <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glDisableVertexAttribArray(GLuint index);</para>
        /// </summary>
        /// <param name="index">
        /// <para>
        /// Specifies the index of the generic vertex
        /// attribute to be enabled or disabled.
        /// </para>
        /// </param>
        /// <seealso cref="ArrayElement"/>
        /// <seealso cref="BindAttribLocation"/>
        /// <seealso cref="DrawArrays"/>
        /// <seealso cref="DrawElements"/>
        /// <seealso cref="DrawRangeElements"/>
        /// <seealso cref="MultiDrawElements"/>
        /// <seealso cref="PopClientAttrib"/>
        /// <seealso cref="PushClientAttrib"/>
        /// <seealso cref="VertexAttrib"/>
        /// <seealso cref="VertexAttribPointer"/>
        public static void DisableVertexAttribArray(uint index) {
            GLNative.glDisableVertexAttribArray(index);
        }

        /// <summary>
        /// Enable or disable a generic vertex attribute array
        /// <para>Require:</para> <para>GL_VERSION_2_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glEnableVertexAttribArray"/> and
        /// <see cref="glDisableVertexAttribArray "/> are available
        /// only if the GL version is 2.0 or greater.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="index"/> is greater than or equal to
        /// <code>GL_MAX_VERTEX_ATTRIBS</code>. 
        /// <code>GL_INVALID_OPERATION</code> is generated if either
        /// <see cref="glEnableVertexAttribArray "/> or
        /// <see cref="glDisableVertexAttribArray "/> is executed
        /// between the execution of
        /// <see cref="glBegin"/> 
        /// and the corresponding execution of
        /// <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glEnableVertexAttribArray(GLuint index);</para>
        /// </summary>
        /// <param name="index">
        /// <para>
        /// Specifies the index of the generic vertex
        /// attribute to be enabled or disabled.
        /// </para>
        /// </param>
        /// <seealso cref="ArrayElement"/>
        /// <seealso cref="BindAttribLocation"/>
        /// <seealso cref="DrawArrays"/>
        /// <seealso cref="DrawElements"/>
        /// <seealso cref="DrawRangeElements"/>
        /// <seealso cref="MultiDrawElements"/>
        /// <seealso cref="PopClientAttrib"/>
        /// <seealso cref="PushClientAttrib"/>
        /// <seealso cref="VertexAttrib"/>
        /// <seealso cref="VertexAttribPointer"/>
        public static void EnableVertexAttribArray(uint index) {
            GLNative.glEnableVertexAttribArray(index);
        }

        /// <summary>
        /// Determines if a name corresponds to a program object
        /// <para>Require:</para> <para>GL_VERSION_2_0, GL_ES_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glIsProgram"/> is available only if the
        /// GL version is 2.0 or greater. 
        /// No error is generated if <paramref name="program"/> is
        /// not a valid program object name. 
        /// A program object marked for deletion with  <see cref="glDeleteProgram"/> 
        /// but still in use as part of current rendering state is still considered 
        /// a program object and <see cref="glIsProgram"/> will return <code>GL_TRUE</code>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <see cref="glIsProgram"/> is executed between the
        /// execution of
        /// <see cref="glBegin"/> 
        /// and the corresponding execution of
        /// <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>GLboolean glIsProgram(GLuint program);</para>
        /// </summary>
        /// <param name="program">
        /// Specifies a potential program object.
        /// </param>
        /// <seealso cref="AttachShader"/>
        /// <seealso cref="BindAttribLocation"/>
        /// <seealso cref="CreateProgram"/>
        /// <seealso cref="DeleteProgram"/>
        /// <seealso cref="DetachShader"/>
        /// <seealso cref="LinkProgram"/>
        /// <seealso cref="Uniform"/>
        /// <seealso cref="UseProgram"/>
        /// <seealso cref="ValidateProgram"/>
        public static bool IsProgram(uint program) {
            return GLNative.glIsProgram(program);
        }

        /// <summary>
        /// Determines if a name corresponds to a shader object
        /// <para>Require:</para> <para>GL_VERSION_2_0, GL_ES_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glIsShader"/> is available only if the
        /// GL version is 2.0 or greater. 
        /// No error is generated if <paramref name="shader"/> is
        /// not a valid shader object name. 
        /// A shader object marked for deletion with  <see cref="glDeleteShader"/> 
        /// but still attached to a program object is still considered 
        /// a shader object and <see cref="glIsShader"/> will return <code>GL_TRUE</code>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <see cref="glIsShader"/> is executed between the
        /// execution of
        /// <see cref="glBegin"/> 
        /// and the corresponding execution of
        /// <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>GLboolean glIsShader(GLuint shader);</para>
        /// </summary>
        /// <param name="shader">
        /// Specifies a potential shader object.
        /// </param>
        /// <seealso cref="AttachShader"/>
        /// <seealso cref="CompileShader"/>
        /// <seealso cref="CreateShader"/>
        /// <seealso cref="DeleteShader"/>
        /// <seealso cref="DetachShader"/>
        /// <seealso cref="LinkProgram"/>
        /// <seealso cref="ShaderSource"/>
        public static bool IsShader(uint shader) {
            return GLNative.glIsShader(shader);
        }

        /// <summary>
        /// Links a program object
        /// <para>Require:</para> <para>GL_VERSION_2_0, GL_ES_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glLinkProgram"/>
        /// is available only if the GL version is 2.0 or greater. 
        /// If the link operation is unsuccessful, any information about a previous link operation on <paramref name="program"/>
        /// is lost (i.e., a failed link does not restore the old state of <paramref name="program"/>
        /// ). Certain information can still be retrieved from <paramref name="program"/>
        /// even after an unsuccessful link operation. See for instance  <see cref="glGetActiveAttrib"/> 
        /// and  <see cref="glGetActiveUniform"/> .
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code>
        /// is generated if <paramref name="program"/>
        /// is not a value generated by OpenGL. 
        /// <code>GL_INVALID_OPERATION</code>
        /// is generated if <paramref name="program"/>
        /// is not a program object. 
        /// <code>GL_INVALID_OPERATION</code>
        /// is generated if <see cref="glLinkProgram"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glLinkProgram(GLuint program);</para>
        /// </summary>
        /// <param name="program">
        /// Specifies the handle of the program object to be linked.
        /// </param>
        /// <seealso cref="AttachShader"/>
        /// <seealso cref="BindAttribLocation"/>
        /// <seealso cref="CompileShader"/>
        /// <seealso cref="CreateProgram"/>
        /// <seealso cref="DeleteProgram"/>
        /// <seealso cref="DetachShader"/>
        /// <seealso cref="Uniform"/>
        /// <seealso cref="UseProgram"/>
        /// <seealso cref="ValidateProgram"/>
        public static void LinkProgram(uint program) {
            GLNative.glLinkProgram(program);
        }

        /// <summary>
        /// Installs a program object as part of current rendering state
        /// <para>Require:</para> <para>GL_VERSION_2_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glUseProgram"/> is available only if the
        /// GL version is 2.0 or greater. 
        /// While a program object is in use, the state that controls
        /// the disabled fixed functionality may also be updated using the
        /// normal OpenGL calls. 
        /// Like display lists and texture objects, the name space for
        /// program objects may be shared across a set of contexts, as long
        /// as the server sides of the contexts share the same address
        /// space. If the name space is shared across contexts, any attached
        /// objects and the data associated with those attached objects are
        /// shared as well. 
        /// Applications are responsible for providing the
        /// synchronization across API calls when objects are accessed from
        /// different execution threads.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="program"/> is neither 0 nor a value
        /// generated by OpenGL. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <paramref name="program"/> is not a program object. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <paramref name="program"/> could not be made part of current
        /// state. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <see cref="glUseProgram"/> is executed between the
        /// execution of
        /// <see cref="glBegin"/> 
        /// and the corresponding execution of
        /// <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glUseProgram(GLuint program);</para>
        /// </summary>
        /// <param name="program">
        /// <para>
        /// Specifies the handle of the program object
        /// whose executables are to be used as part of current
        /// rendering state.
        /// </para>
        /// </param>
        /// <seealso cref="lAttachShader"/>
        /// <seealso cref="BindAttribLocation"/>
        /// <seealso cref="CompileShader"/>
        /// <seealso cref="CreateProgram"/>
        /// <seealso cref="DeleteProgram"/>
        /// <seealso cref="DetachShader"/>
        /// <seealso cref="LinkProgram"/>
        /// <seealso cref="Uniform"/>
        /// <seealso cref="ValidateProgram"/>
        /// <seealso cref="VertexAttrib"/>
        public static void UseProgram(uint program) {
            GLNative.glUseProgram(program);
        }

        /// <summary>
        /// Specify the value of a uniform variable for the current program object
        /// <para>Require:</para> <para>GL_VERSION_2_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glUniform"/> is available only if the GL
        /// version is 2.0 or greater. 
        /// <see cref="glUniformMatrix{2x3|3x2|2x4|4x2|3x4|4x3}fv"/> 
        /// is available only if the GL version is 2.1 or greater. 
        /// <see cref="glUniform1i"/> and
        /// <see cref="glUniform1iv"/> are the only two functions
        /// that may be used to load uniform variables defined as sampler
        /// types. Loading samplers with any other function will result in a
        /// <code>GL_INVALID_OPERATION</code> error. 
        /// If <paramref name="count"/> is greater than 1 and the
        /// indicated uniform variable is not an array, a
        /// <code>GL_INVALID_OPERATION</code> error is generated and the
        /// specified uniform variable will remain unchanged. 
        /// Other than the preceding exceptions, if the type and size
        /// of the uniform variable as defined in the shader do not match
        /// the type and size specified in the name of the command used to
        /// load its value, a <code>GL_INVALID_OPERATION</code> error will
        /// be generated and the specified uniform variable will remain
        /// unchanged. 
        /// If <paramref name="location"/> is a value other than
        /// -1 and it does not represent a valid uniform variable location
        /// in the current program object, an error will be generated, and
        /// no changes will be made to the uniform variable storage of the
        /// current program object. If <paramref name="location"/> is
        /// equal to -1, the data passed in will be silently ignored and the
        /// specified uniform variable will not be changed.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if there
        /// is no current program object. 
        /// <code>GL_INVALID_OPERATION</code> is generated if the
        /// size of the uniform variable declared in the shader does not
        /// match the size indicated by the <see cref="glUniform"/>
        /// command. 
        /// <code>GL_INVALID_OPERATION</code> is generated if one of
        /// the integer variants of this function is used to load a uniform
        /// variable of type float, vec2, vec3, vec4, or an array of these,
        /// or if one of the floating-point variants of this function is
        /// used to load a uniform variable of type int, ivec2, ivec3, or
        /// ivec4, or an array of these. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <paramref name="location"/> is an invalid uniform location
        /// for the current program object and
        /// <paramref name="location"/> is not equal to -1. 
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="count"/> is less than 0. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <paramref name="count"/> is greater than 1 and the indicated
        /// uniform variable is not an array variable. 
        /// <code>GL_INVALID_OPERATION</code> is generated if a
        /// sampler is loaded using a command other than
        /// <see cref="glUniform1i"/> and
        /// <see cref="glUniform1iv"/>. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <see cref="glUniform"/> is executed between the execution
        /// of
        /// <see cref="glBegin"/> 
        /// and the corresponding execution of
        /// <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glUniform1f(GLint location, GLfloat v0);</para>
        /// </summary>
        /// <param name="location">
        /// <para>
        /// Specifies the location of the uniform variable
        /// to be modified.
        /// </para>
        /// </param>
        /// <seealso cref="LinkProgram"/>
        /// <seealso cref="UseProgram"/>
        public static void Uniform1f(int location, float v0) {
            GLNative.glUniform1f(location, v0);
        }

        /// <summary>
        /// Specify the value of a uniform variable for the current program object
        /// <para>Require:</para> <para>GL_VERSION_2_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glUniform"/> is available only if the GL
        /// version is 2.0 or greater. 
        /// <see cref="glUniformMatrix{2x3|3x2|2x4|4x2|3x4|4x3}fv"/> 
        /// is available only if the GL version is 2.1 or greater. 
        /// <see cref="glUniform1i"/> and
        /// <see cref="glUniform1iv"/> are the only two functions
        /// that may be used to load uniform variables defined as sampler
        /// types. Loading samplers with any other function will result in a
        /// <code>GL_INVALID_OPERATION</code> error. 
        /// If <paramref name="count"/> is greater than 1 and the
        /// indicated uniform variable is not an array, a
        /// <code>GL_INVALID_OPERATION</code> error is generated and the
        /// specified uniform variable will remain unchanged. 
        /// Other than the preceding exceptions, if the type and size
        /// of the uniform variable as defined in the shader do not match
        /// the type and size specified in the name of the command used to
        /// load its value, a <code>GL_INVALID_OPERATION</code> error will
        /// be generated and the specified uniform variable will remain
        /// unchanged. 
        /// If <paramref name="location"/> is a value other than
        /// -1 and it does not represent a valid uniform variable location
        /// in the current program object, an error will be generated, and
        /// no changes will be made to the uniform variable storage of the
        /// current program object. If <paramref name="location"/> is
        /// equal to -1, the data passed in will be silently ignored and the
        /// specified uniform variable will not be changed.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if there
        /// is no current program object. 
        /// <code>GL_INVALID_OPERATION</code> is generated if the
        /// size of the uniform variable declared in the shader does not
        /// match the size indicated by the <see cref="glUniform"/>
        /// command. 
        /// <code>GL_INVALID_OPERATION</code> is generated if one of
        /// the integer variants of this function is used to load a uniform
        /// variable of type float, vec2, vec3, vec4, or an array of these,
        /// or if one of the floating-point variants of this function is
        /// used to load a uniform variable of type int, ivec2, ivec3, or
        /// ivec4, or an array of these. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <paramref name="location"/> is an invalid uniform location
        /// for the current program object and
        /// <paramref name="location"/> is not equal to -1. 
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="count"/> is less than 0. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <paramref name="count"/> is greater than 1 and the indicated
        /// uniform variable is not an array variable. 
        /// <code>GL_INVALID_OPERATION</code> is generated if a
        /// sampler is loaded using a command other than
        /// <see cref="glUniform1i"/> and
        /// <see cref="glUniform1iv"/>. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <see cref="glUniform"/> is executed between the execution
        /// of
        /// <see cref="glBegin"/> 
        /// and the corresponding execution of
        /// <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glUniform2f(GLint location, GLfloat v0, GLfloat v1);</para>
        /// </summary>
        /// <param name="location">
        /// <para>
        /// Specifies the location of the uniform variable
        /// to be modified.
        /// </para>
        /// </param>
        /// <seealso cref="LinkProgram"/>
        /// <seealso cref="UseProgram"/>
        public static void Uniform2f(int location, float v0, float v1) {
            GLNative.glUniform2f(location, v0, v1);
        }

        /// <summary>
        /// Specify the value of a uniform variable for the current program object
        /// <para>Require:</para> <para>GL_VERSION_2_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glUniform"/> is available only if the GL
        /// version is 2.0 or greater. 
        /// <see cref="glUniformMatrix{2x3|3x2|2x4|4x2|3x4|4x3}fv"/> 
        /// is available only if the GL version is 2.1 or greater. 
        /// <see cref="glUniform1i"/> and
        /// <see cref="glUniform1iv"/> are the only two functions
        /// that may be used to load uniform variables defined as sampler
        /// types. Loading samplers with any other function will result in a
        /// <code>GL_INVALID_OPERATION</code> error. 
        /// If <paramref name="count"/> is greater than 1 and the
        /// indicated uniform variable is not an array, a
        /// <code>GL_INVALID_OPERATION</code> error is generated and the
        /// specified uniform variable will remain unchanged. 
        /// Other than the preceding exceptions, if the type and size
        /// of the uniform variable as defined in the shader do not match
        /// the type and size specified in the name of the command used to
        /// load its value, a <code>GL_INVALID_OPERATION</code> error will
        /// be generated and the specified uniform variable will remain
        /// unchanged. 
        /// If <paramref name="location"/> is a value other than
        /// -1 and it does not represent a valid uniform variable location
        /// in the current program object, an error will be generated, and
        /// no changes will be made to the uniform variable storage of the
        /// current program object. If <paramref name="location"/> is
        /// equal to -1, the data passed in will be silently ignored and the
        /// specified uniform variable will not be changed.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if there
        /// is no current program object. 
        /// <code>GL_INVALID_OPERATION</code> is generated if the
        /// size of the uniform variable declared in the shader does not
        /// match the size indicated by the <see cref="glUniform"/>
        /// command. 
        /// <code>GL_INVALID_OPERATION</code> is generated if one of
        /// the integer variants of this function is used to load a uniform
        /// variable of type float, vec2, vec3, vec4, or an array of these,
        /// or if one of the floating-point variants of this function is
        /// used to load a uniform variable of type int, ivec2, ivec3, or
        /// ivec4, or an array of these. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <paramref name="location"/> is an invalid uniform location
        /// for the current program object and
        /// <paramref name="location"/> is not equal to -1. 
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="count"/> is less than 0. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <paramref name="count"/> is greater than 1 and the indicated
        /// uniform variable is not an array variable. 
        /// <code>GL_INVALID_OPERATION</code> is generated if a
        /// sampler is loaded using a command other than
        /// <see cref="glUniform1i"/> and
        /// <see cref="glUniform1iv"/>. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <see cref="glUniform"/> is executed between the execution
        /// of
        /// <see cref="glBegin"/> 
        /// and the corresponding execution of
        /// <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glUniform3f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2);</para>
        /// </summary>
        /// <param name="location">
        /// <para>
        /// Specifies the location of the uniform variable
        /// to be modified.
        /// </para>
        /// </param>
        /// <seealso cref="LinkProgram"/>
        /// <seealso cref="UseProgram"/>
        public static void Uniform3f(int location, float v0, float v1, float v2) {
            GLNative.glUniform3f(location, v0, v1, v2);
        }

        /// <summary>
        /// Specify the value of a uniform variable for the current program object
        /// <para>Require:</para> <para>GL_VERSION_2_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glUniform"/> is available only if the GL
        /// version is 2.0 or greater. 
        /// <see cref="glUniformMatrix{2x3|3x2|2x4|4x2|3x4|4x3}fv"/> 
        /// is available only if the GL version is 2.1 or greater. 
        /// <see cref="glUniform1i"/> and
        /// <see cref="glUniform1iv"/> are the only two functions
        /// that may be used to load uniform variables defined as sampler
        /// types. Loading samplers with any other function will result in a
        /// <code>GL_INVALID_OPERATION</code> error. 
        /// If <paramref name="count"/> is greater than 1 and the
        /// indicated uniform variable is not an array, a
        /// <code>GL_INVALID_OPERATION</code> error is generated and the
        /// specified uniform variable will remain unchanged. 
        /// Other than the preceding exceptions, if the type and size
        /// of the uniform variable as defined in the shader do not match
        /// the type and size specified in the name of the command used to
        /// load its value, a <code>GL_INVALID_OPERATION</code> error will
        /// be generated and the specified uniform variable will remain
        /// unchanged. 
        /// If <paramref name="location"/> is a value other than
        /// -1 and it does not represent a valid uniform variable location
        /// in the current program object, an error will be generated, and
        /// no changes will be made to the uniform variable storage of the
        /// current program object. If <paramref name="location"/> is
        /// equal to -1, the data passed in will be silently ignored and the
        /// specified uniform variable will not be changed.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if there
        /// is no current program object. 
        /// <code>GL_INVALID_OPERATION</code> is generated if the
        /// size of the uniform variable declared in the shader does not
        /// match the size indicated by the <see cref="glUniform"/>
        /// command. 
        /// <code>GL_INVALID_OPERATION</code> is generated if one of
        /// the integer variants of this function is used to load a uniform
        /// variable of type float, vec2, vec3, vec4, or an array of these,
        /// or if one of the floating-point variants of this function is
        /// used to load a uniform variable of type int, ivec2, ivec3, or
        /// ivec4, or an array of these. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <paramref name="location"/> is an invalid uniform location
        /// for the current program object and
        /// <paramref name="location"/> is not equal to -1. 
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="count"/> is less than 0. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <paramref name="count"/> is greater than 1 and the indicated
        /// uniform variable is not an array variable. 
        /// <code>GL_INVALID_OPERATION</code> is generated if a
        /// sampler is loaded using a command other than
        /// <see cref="glUniform1i"/> and
        /// <see cref="glUniform1iv"/>. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <see cref="glUniform"/> is executed between the execution
        /// of
        /// <see cref="glBegin"/> 
        /// and the corresponding execution of
        /// <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glUniform4f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3);</para>
        /// </summary>
        /// <param name="location">
        /// <para>
        /// Specifies the location of the uniform variable
        /// to be modified.
        /// </para>
        /// </param>
        /// <seealso cref="LinkProgram"/>
        /// <seealso cref="UseProgram"/>
        public static void Uniform4f(int location, float v0, float v1, float v2, float v3) {
            GLNative.glUniform4f(location, v0, v1, v2, v3);
        }

        /// <summary>
        /// Specify the value of a uniform variable for the current program object
        /// <para>Require:</para> <para>GL_VERSION_2_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glUniform"/> is available only if the GL
        /// version is 2.0 or greater. 
        /// <see cref="glUniformMatrix{2x3|3x2|2x4|4x2|3x4|4x3}fv"/> 
        /// is available only if the GL version is 2.1 or greater. 
        /// <see cref="glUniform1i"/> and
        /// <see cref="glUniform1iv"/> are the only two functions
        /// that may be used to load uniform variables defined as sampler
        /// types. Loading samplers with any other function will result in a
        /// <code>GL_INVALID_OPERATION</code> error. 
        /// If <paramref name="count"/> is greater than 1 and the
        /// indicated uniform variable is not an array, a
        /// <code>GL_INVALID_OPERATION</code> error is generated and the
        /// specified uniform variable will remain unchanged. 
        /// Other than the preceding exceptions, if the type and size
        /// of the uniform variable as defined in the shader do not match
        /// the type and size specified in the name of the command used to
        /// load its value, a <code>GL_INVALID_OPERATION</code> error will
        /// be generated and the specified uniform variable will remain
        /// unchanged. 
        /// If <paramref name="location"/> is a value other than
        /// -1 and it does not represent a valid uniform variable location
        /// in the current program object, an error will be generated, and
        /// no changes will be made to the uniform variable storage of the
        /// current program object. If <paramref name="location"/> is
        /// equal to -1, the data passed in will be silently ignored and the
        /// specified uniform variable will not be changed.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if there
        /// is no current program object. 
        /// <code>GL_INVALID_OPERATION</code> is generated if the
        /// size of the uniform variable declared in the shader does not
        /// match the size indicated by the <see cref="glUniform"/>
        /// command. 
        /// <code>GL_INVALID_OPERATION</code> is generated if one of
        /// the integer variants of this function is used to load a uniform
        /// variable of type float, vec2, vec3, vec4, or an array of these,
        /// or if one of the floating-point variants of this function is
        /// used to load a uniform variable of type int, ivec2, ivec3, or
        /// ivec4, or an array of these. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <paramref name="location"/> is an invalid uniform location
        /// for the current program object and
        /// <paramref name="location"/> is not equal to -1. 
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="count"/> is less than 0. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <paramref name="count"/> is greater than 1 and the indicated
        /// uniform variable is not an array variable. 
        /// <code>GL_INVALID_OPERATION</code> is generated if a
        /// sampler is loaded using a command other than
        /// <see cref="glUniform1i"/> and
        /// <see cref="glUniform1iv"/>. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <see cref="glUniform"/> is executed between the execution
        /// of
        /// <see cref="glBegin"/> 
        /// and the corresponding execution of
        /// <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glUniform1i(GLint location, GLint v0);</para>
        /// </summary>
        /// <param name="location">
        /// <para>
        /// Specifies the location of the uniform variable
        /// to be modified.
        /// </para>
        /// </param>
        /// <seealso cref="LinkProgram"/>
        /// <seealso cref="UseProgram"/>
        public static void Uniform1i(int location, int v0) {
            GLNative.glUniform1i(location, v0);
        }

        /// <summary>
        /// Specify the value of a uniform variable for the current program object
        /// <para>Require:</para> <para>GL_VERSION_2_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glUniform"/> is available only if the GL
        /// version is 2.0 or greater. 
        /// <see cref="glUniformMatrix{2x3|3x2|2x4|4x2|3x4|4x3}fv"/> 
        /// is available only if the GL version is 2.1 or greater. 
        /// <see cref="glUniform1i"/> and
        /// <see cref="glUniform1iv"/> are the only two functions
        /// that may be used to load uniform variables defined as sampler
        /// types. Loading samplers with any other function will result in a
        /// <code>GL_INVALID_OPERATION</code> error. 
        /// If <paramref name="count"/> is greater than 1 and the
        /// indicated uniform variable is not an array, a
        /// <code>GL_INVALID_OPERATION</code> error is generated and the
        /// specified uniform variable will remain unchanged. 
        /// Other than the preceding exceptions, if the type and size
        /// of the uniform variable as defined in the shader do not match
        /// the type and size specified in the name of the command used to
        /// load its value, a <code>GL_INVALID_OPERATION</code> error will
        /// be generated and the specified uniform variable will remain
        /// unchanged. 
        /// If <paramref name="location"/> is a value other than
        /// -1 and it does not represent a valid uniform variable location
        /// in the current program object, an error will be generated, and
        /// no changes will be made to the uniform variable storage of the
        /// current program object. If <paramref name="location"/> is
        /// equal to -1, the data passed in will be silently ignored and the
        /// specified uniform variable will not be changed.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if there
        /// is no current program object. 
        /// <code>GL_INVALID_OPERATION</code> is generated if the
        /// size of the uniform variable declared in the shader does not
        /// match the size indicated by the <see cref="glUniform"/>
        /// command. 
        /// <code>GL_INVALID_OPERATION</code> is generated if one of
        /// the integer variants of this function is used to load a uniform
        /// variable of type float, vec2, vec3, vec4, or an array of these,
        /// or if one of the floating-point variants of this function is
        /// used to load a uniform variable of type int, ivec2, ivec3, or
        /// ivec4, or an array of these. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <paramref name="location"/> is an invalid uniform location
        /// for the current program object and
        /// <paramref name="location"/> is not equal to -1. 
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="count"/> is less than 0. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <paramref name="count"/> is greater than 1 and the indicated
        /// uniform variable is not an array variable. 
        /// <code>GL_INVALID_OPERATION</code> is generated if a
        /// sampler is loaded using a command other than
        /// <see cref="glUniform1i"/> and
        /// <see cref="glUniform1iv"/>. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <see cref="glUniform"/> is executed between the execution
        /// of
        /// <see cref="glBegin"/> 
        /// and the corresponding execution of
        /// <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glUniform2i(GLint location, GLint v0, GLint v1);</para>
        /// </summary>
        /// <param name="location">
        /// <para>
        /// Specifies the location of the uniform variable
        /// to be modified.
        /// </para>
        /// </param>
        /// <seealso cref="LinkProgram"/>
        /// <seealso cref="UseProgram"/>
        public static void Uniform2i(int location, int v0, int v1) {
            GLNative.glUniform2i(location, v0, v1);
        }

        /// <summary>
        /// Specify the value of a uniform variable for the current program object
        /// <para>Require:</para> <para>GL_VERSION_2_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glUniform"/> is available only if the GL
        /// version is 2.0 or greater. 
        /// <see cref="glUniformMatrix{2x3|3x2|2x4|4x2|3x4|4x3}fv"/> 
        /// is available only if the GL version is 2.1 or greater. 
        /// <see cref="glUniform1i"/> and
        /// <see cref="glUniform1iv"/> are the only two functions
        /// that may be used to load uniform variables defined as sampler
        /// types. Loading samplers with any other function will result in a
        /// <code>GL_INVALID_OPERATION</code> error. 
        /// If <paramref name="count"/> is greater than 1 and the
        /// indicated uniform variable is not an array, a
        /// <code>GL_INVALID_OPERATION</code> error is generated and the
        /// specified uniform variable will remain unchanged. 
        /// Other than the preceding exceptions, if the type and size
        /// of the uniform variable as defined in the shader do not match
        /// the type and size specified in the name of the command used to
        /// load its value, a <code>GL_INVALID_OPERATION</code> error will
        /// be generated and the specified uniform variable will remain
        /// unchanged. 
        /// If <paramref name="location"/> is a value other than
        /// -1 and it does not represent a valid uniform variable location
        /// in the current program object, an error will be generated, and
        /// no changes will be made to the uniform variable storage of the
        /// current program object. If <paramref name="location"/> is
        /// equal to -1, the data passed in will be silently ignored and the
        /// specified uniform variable will not be changed.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if there
        /// is no current program object. 
        /// <code>GL_INVALID_OPERATION</code> is generated if the
        /// size of the uniform variable declared in the shader does not
        /// match the size indicated by the <see cref="glUniform"/>
        /// command. 
        /// <code>GL_INVALID_OPERATION</code> is generated if one of
        /// the integer variants of this function is used to load a uniform
        /// variable of type float, vec2, vec3, vec4, or an array of these,
        /// or if one of the floating-point variants of this function is
        /// used to load a uniform variable of type int, ivec2, ivec3, or
        /// ivec4, or an array of these. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <paramref name="location"/> is an invalid uniform location
        /// for the current program object and
        /// <paramref name="location"/> is not equal to -1. 
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="count"/> is less than 0. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <paramref name="count"/> is greater than 1 and the indicated
        /// uniform variable is not an array variable. 
        /// <code>GL_INVALID_OPERATION</code> is generated if a
        /// sampler is loaded using a command other than
        /// <see cref="glUniform1i"/> and
        /// <see cref="glUniform1iv"/>. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <see cref="glUniform"/> is executed between the execution
        /// of
        /// <see cref="glBegin"/> 
        /// and the corresponding execution of
        /// <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glUniform3i(GLint location, GLint v0, GLint v1, GLint v2);</para>
        /// </summary>
        /// <param name="location">
        /// <para>
        /// Specifies the location of the uniform variable
        /// to be modified.
        /// </para>
        /// </param>
        /// <seealso cref="LinkProgram"/>
        /// <seealso cref="UseProgram"/>
        public static void Uniform3i(int location, int v0, int v1, int v2) {
            GLNative.glUniform3i(location, v0, v1, v2);
        }

        /// <summary>
        /// Specify the value of a uniform variable for the current program object
        /// <para>Require:</para> <para>GL_VERSION_2_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glUniform"/> is available only if the GL
        /// version is 2.0 or greater. 
        /// <see cref="glUniformMatrix{2x3|3x2|2x4|4x2|3x4|4x3}fv"/> 
        /// is available only if the GL version is 2.1 or greater. 
        /// <see cref="glUniform1i"/> and
        /// <see cref="glUniform1iv"/> are the only two functions
        /// that may be used to load uniform variables defined as sampler
        /// types. Loading samplers with any other function will result in a
        /// <code>GL_INVALID_OPERATION</code> error. 
        /// If <paramref name="count"/> is greater than 1 and the
        /// indicated uniform variable is not an array, a
        /// <code>GL_INVALID_OPERATION</code> error is generated and the
        /// specified uniform variable will remain unchanged. 
        /// Other than the preceding exceptions, if the type and size
        /// of the uniform variable as defined in the shader do not match
        /// the type and size specified in the name of the command used to
        /// load its value, a <code>GL_INVALID_OPERATION</code> error will
        /// be generated and the specified uniform variable will remain
        /// unchanged. 
        /// If <paramref name="location"/> is a value other than
        /// -1 and it does not represent a valid uniform variable location
        /// in the current program object, an error will be generated, and
        /// no changes will be made to the uniform variable storage of the
        /// current program object. If <paramref name="location"/> is
        /// equal to -1, the data passed in will be silently ignored and the
        /// specified uniform variable will not be changed.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if there
        /// is no current program object. 
        /// <code>GL_INVALID_OPERATION</code> is generated if the
        /// size of the uniform variable declared in the shader does not
        /// match the size indicated by the <see cref="glUniform"/>
        /// command. 
        /// <code>GL_INVALID_OPERATION</code> is generated if one of
        /// the integer variants of this function is used to load a uniform
        /// variable of type float, vec2, vec3, vec4, or an array of these,
        /// or if one of the floating-point variants of this function is
        /// used to load a uniform variable of type int, ivec2, ivec3, or
        /// ivec4, or an array of these. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <paramref name="location"/> is an invalid uniform location
        /// for the current program object and
        /// <paramref name="location"/> is not equal to -1. 
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="count"/> is less than 0. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <paramref name="count"/> is greater than 1 and the indicated
        /// uniform variable is not an array variable. 
        /// <code>GL_INVALID_OPERATION</code> is generated if a
        /// sampler is loaded using a command other than
        /// <see cref="glUniform1i"/> and
        /// <see cref="glUniform1iv"/>. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <see cref="glUniform"/> is executed between the execution
        /// of
        /// <see cref="glBegin"/> 
        /// and the corresponding execution of
        /// <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glUniform4i(GLint location, GLint v0, GLint v1, GLint v2, GLint v3);</para>
        /// </summary>
        /// <param name="location">
        /// <para>
        /// Specifies the location of the uniform variable
        /// to be modified.
        /// </para>
        /// </param>
        /// <seealso cref="LinkProgram"/>
        /// <seealso cref="UseProgram"/>
        public static void Uniform4i(int location, int v0, int v1, int v2, int v3) {
            GLNative.glUniform4i(location, v0, v1, v2, v3);
        }

        /// <summary>
        /// Validates a program object
        /// <para>Require:</para> <para>GL_VERSION_2_0, GL_ES_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glValidateProgram"/> is available only
        /// if the GL version is 2.0 or greater. 
        /// This function mimics the validation operation that OpenGL
        /// implementations must perform when rendering commands are issued
        /// while programmable shaders are part of current state. The error
        /// <code>GL_INVALID_OPERATION</code> will be generated by
        /// <see cref="glBegin"/> ,
        /// <see cref="glRasterPos"/> ,
        /// or any command that performs an implicit call to
        /// <see cref="glBegin"/> 
        /// if: 
        /// any two active samplers in the current program
        /// object are of different types, but refer to the same
        /// texture image unit, 
        /// any active sampler in the current program object
        /// refers to a texture image unit where fixed-function
        /// fragment processing accesses a texture target that does
        /// not match the sampler type, or 
        /// the sum of the number of active samplers in the
        /// program and the number of texture image units enabled
        /// for fixed-function fragment processing exceeds the
        /// combined limit on the total number of texture image
        /// units allowed. 
        /// It may be difficult or cause a performance degradation for
        /// applications to catch these errors when rendering commands are
        /// issued. Therefore, applications are advised to make calls to
        /// <see cref="glValidateProgram"/> to detect these issues
        /// during application development.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="program"/> is not a value generated by
        /// OpenGL. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <paramref name="program"/> is not a program object. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <see cref="glValidateProgram"/> is executed between the
        /// execution of
        /// <see cref="glBegin"/> 
        /// and the corresponding execution of
        /// <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glValidateProgram(GLuint program);</para>
        /// </summary>
        /// <param name="program">
        /// <para>
        /// Specifies the handle of the program object to
        /// be validated.
        /// </para>
        /// </param>
        /// <seealso cref="LinkProgram"/>
        /// <seealso cref="UseProgram"/>
        public static void ValidateProgram(uint program) {
            GLNative.glValidateProgram(program);
        }

        /// <summary>
        /// Specifies the value of a generic vertex attribute
        /// <para>Require:</para> <para>GL_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glVertexAttrib"/> is available only if
        /// the GL version is 2.0 or greater. 
        /// Generic vertex attributes can be updated at any time. In
        /// particular, <see cref="glVertexAttrib"/> can be called
        /// between a call to
        /// <see cref="glBegin"/> 
        /// and the corresponding call to
        /// <see cref="glEnd"/> . 
        /// It is possible for an application to bind more than one
        /// attribute name to the same generic vertex attribute index. This
        /// is referred to as aliasing, and it is allowed only if just one
        /// of the aliased attribute variables is active in the vertex
        /// shader, or if no path through the vertex shader consumes more
        /// than one of the attributes aliased to the same location. OpenGL
        /// implementations are not required to do error checking to detect
        /// aliasing, they are allowed to assume that aliasing will not
        /// occur, and they are allowed to employ optimizations that work
        /// only in the absence of aliasing. 
        /// There is no provision for binding standard vertex
        /// attributes; therefore, it is not possible to alias generic
        /// attributes with standard attributes.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="index"/> is greater than or equal to
        /// <code>GL_MAX_VERTEX_ATTRIBS</code>.
        /// </para>
        /// Original: <para>void glVertexAttrib1d(GLuint index, GLdouble v0);</para>
        /// </summary>
        /// <param name="index">
        /// <para>
        /// Specifies the index of the generic vertex
        /// attribute to be modified.
        /// </para>
        /// </param>
        /// <seealso cref="BindAttribLocation"/>
        /// <seealso cref="Vertex"/>
        /// <seealso cref="VertexAttribPointer"/>
        public static void VertexAttrib1d(uint index, double v0) {
            GLNative.glVertexAttrib1d(index, v0);
        }

        /// <summary>
        /// Specifies the value of a generic vertex attribute
        /// <para>Require:</para> <para>GL_VERSION_2_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glVertexAttrib"/> is available only if
        /// the GL version is 2.0 or greater. 
        /// Generic vertex attributes can be updated at any time. In
        /// particular, <see cref="glVertexAttrib"/> can be called
        /// between a call to
        /// <see cref="glBegin"/> 
        /// and the corresponding call to
        /// <see cref="glEnd"/> . 
        /// It is possible for an application to bind more than one
        /// attribute name to the same generic vertex attribute index. This
        /// is referred to as aliasing, and it is allowed only if just one
        /// of the aliased attribute variables is active in the vertex
        /// shader, or if no path through the vertex shader consumes more
        /// than one of the attributes aliased to the same location. OpenGL
        /// implementations are not required to do error checking to detect
        /// aliasing, they are allowed to assume that aliasing will not
        /// occur, and they are allowed to employ optimizations that work
        /// only in the absence of aliasing. 
        /// There is no provision for binding standard vertex
        /// attributes; therefore, it is not possible to alias generic
        /// attributes with standard attributes.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="index"/> is greater than or equal to
        /// <code>GL_MAX_VERTEX_ATTRIBS</code>.
        /// </para>
        /// Original: <para>void glVertexAttrib1f(GLuint index, GLfloat v0);</para>
        /// </summary>
        /// <param name="index">
        /// <para>
        /// Specifies the index of the generic vertex
        /// attribute to be modified.
        /// </para>
        /// </param>
        /// <seealso cref="BindAttribLocation"/>
        /// <seealso cref="Vertex"/>
        /// <seealso cref="VertexAttribPointer"/>
        public static void VertexAttrib1f(uint index, float v0) {
            GLNative.glVertexAttrib1f(index, v0);
        }

        /// <summary>
        /// Specifies the value of a generic vertex attribute
        /// <para>Require:</para> <para>GL_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glVertexAttrib"/> is available only if
        /// the GL version is 2.0 or greater. 
        /// Generic vertex attributes can be updated at any time. In
        /// particular, <see cref="glVertexAttrib"/> can be called
        /// between a call to
        /// <see cref="glBegin"/> 
        /// and the corresponding call to
        /// <see cref="glEnd"/> . 
        /// It is possible for an application to bind more than one
        /// attribute name to the same generic vertex attribute index. This
        /// is referred to as aliasing, and it is allowed only if just one
        /// of the aliased attribute variables is active in the vertex
        /// shader, or if no path through the vertex shader consumes more
        /// than one of the attributes aliased to the same location. OpenGL
        /// implementations are not required to do error checking to detect
        /// aliasing, they are allowed to assume that aliasing will not
        /// occur, and they are allowed to employ optimizations that work
        /// only in the absence of aliasing. 
        /// There is no provision for binding standard vertex
        /// attributes; therefore, it is not possible to alias generic
        /// attributes with standard attributes.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="index"/> is greater than or equal to
        /// <code>GL_MAX_VERTEX_ATTRIBS</code>.
        /// </para>
        /// Original: <para>void glVertexAttrib1s(GLuint index, GLshort v0);</para>
        /// </summary>
        /// <param name="index">
        /// <para>
        /// Specifies the index of the generic vertex
        /// attribute to be modified.
        /// </para>
        /// </param>
        /// <seealso cref="BindAttribLocation"/>
        /// <seealso cref="Vertex"/>
        /// <seealso cref="VertexAttribPointer"/>
        public static void VertexAttrib1s(uint index, short v0) {
            GLNative.glVertexAttrib1s(index, v0);
        }

        /// <summary>
        /// Specifies the value of a generic vertex attribute
        /// <para>Require:</para> <para>GL_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glVertexAttrib"/> is available only if
        /// the GL version is 2.0 or greater. 
        /// Generic vertex attributes can be updated at any time. In
        /// particular, <see cref="glVertexAttrib"/> can be called
        /// between a call to
        /// <see cref="glBegin"/> 
        /// and the corresponding call to
        /// <see cref="glEnd"/> . 
        /// It is possible for an application to bind more than one
        /// attribute name to the same generic vertex attribute index. This
        /// is referred to as aliasing, and it is allowed only if just one
        /// of the aliased attribute variables is active in the vertex
        /// shader, or if no path through the vertex shader consumes more
        /// than one of the attributes aliased to the same location. OpenGL
        /// implementations are not required to do error checking to detect
        /// aliasing, they are allowed to assume that aliasing will not
        /// occur, and they are allowed to employ optimizations that work
        /// only in the absence of aliasing. 
        /// There is no provision for binding standard vertex
        /// attributes; therefore, it is not possible to alias generic
        /// attributes with standard attributes.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="index"/> is greater than or equal to
        /// <code>GL_MAX_VERTEX_ATTRIBS</code>.
        /// </para>
        /// Original: <para>void glVertexAttrib2d(GLuint index, GLdouble v0, GLdouble v1);</para>
        /// </summary>
        /// <param name="index">
        /// <para>
        /// Specifies the index of the generic vertex
        /// attribute to be modified.
        /// </para>
        /// </param>
        /// <seealso cref="BindAttribLocation"/>
        /// <seealso cref="Vertex"/>
        /// <seealso cref="VertexAttribPointer"/>
        public static void VertexAttrib2d(uint index, double v0, double v1) {
            GLNative.glVertexAttrib2d(index, v0, v1);
        }

        /// <summary>
        /// Specifies the value of a generic vertex attribute
        /// <para>Require:</para> <para>GL_VERSION_2_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glVertexAttrib"/> is available only if
        /// the GL version is 2.0 or greater. 
        /// Generic vertex attributes can be updated at any time. In
        /// particular, <see cref="glVertexAttrib"/> can be called
        /// between a call to
        /// <see cref="glBegin"/> 
        /// and the corresponding call to
        /// <see cref="glEnd"/> . 
        /// It is possible for an application to bind more than one
        /// attribute name to the same generic vertex attribute index. This
        /// is referred to as aliasing, and it is allowed only if just one
        /// of the aliased attribute variables is active in the vertex
        /// shader, or if no path through the vertex shader consumes more
        /// than one of the attributes aliased to the same location. OpenGL
        /// implementations are not required to do error checking to detect
        /// aliasing, they are allowed to assume that aliasing will not
        /// occur, and they are allowed to employ optimizations that work
        /// only in the absence of aliasing. 
        /// There is no provision for binding standard vertex
        /// attributes; therefore, it is not possible to alias generic
        /// attributes with standard attributes.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="index"/> is greater than or equal to
        /// <code>GL_MAX_VERTEX_ATTRIBS</code>.
        /// </para>
        /// Original: <para>void glVertexAttrib2f(GLuint index, GLfloat v0, GLfloat v1);</para>
        /// </summary>
        /// <param name="index">
        /// <para>
        /// Specifies the index of the generic vertex
        /// attribute to be modified.
        /// </para>
        /// </param>
        /// <seealso cref="BindAttribLocation"/>
        /// <seealso cref="Vertex"/>
        /// <seealso cref="VertexAttribPointer"/>
        public static void VertexAttrib2f(uint index, float v0, float v1) {
            GLNative.glVertexAttrib2f(index, v0, v1);
        }

        /// <summary>
        /// Specifies the value of a generic vertex attribute
        /// <para>Require:</para> <para>GL_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glVertexAttrib"/> is available only if
        /// the GL version is 2.0 or greater. 
        /// Generic vertex attributes can be updated at any time. In
        /// particular, <see cref="glVertexAttrib"/> can be called
        /// between a call to
        /// <see cref="glBegin"/> 
        /// and the corresponding call to
        /// <see cref="glEnd"/> . 
        /// It is possible for an application to bind more than one
        /// attribute name to the same generic vertex attribute index. This
        /// is referred to as aliasing, and it is allowed only if just one
        /// of the aliased attribute variables is active in the vertex
        /// shader, or if no path through the vertex shader consumes more
        /// than one of the attributes aliased to the same location. OpenGL
        /// implementations are not required to do error checking to detect
        /// aliasing, they are allowed to assume that aliasing will not
        /// occur, and they are allowed to employ optimizations that work
        /// only in the absence of aliasing. 
        /// There is no provision for binding standard vertex
        /// attributes; therefore, it is not possible to alias generic
        /// attributes with standard attributes.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="index"/> is greater than or equal to
        /// <code>GL_MAX_VERTEX_ATTRIBS</code>.
        /// </para>
        /// Original: <para>void glVertexAttrib2s(GLuint index, GLshort v0, GLshort v1);</para>
        /// </summary>
        /// <param name="index">
        /// <para>
        /// Specifies the index of the generic vertex
        /// attribute to be modified.
        /// </para>
        /// </param>
        /// <seealso cref="BindAttribLocation"/>
        /// <seealso cref="Vertex"/>
        /// <seealso cref="VertexAttribPointer"/>
        public static void VertexAttrib2s(uint index, short v0, short v1) {
            GLNative.glVertexAttrib2s(index, v0, v1);
        }

        /// <summary>
        /// Specifies the value of a generic vertex attribute
        /// <para>Require:</para> <para>GL_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glVertexAttrib"/> is available only if
        /// the GL version is 2.0 or greater. 
        /// Generic vertex attributes can be updated at any time. In
        /// particular, <see cref="glVertexAttrib"/> can be called
        /// between a call to
        /// <see cref="glBegin"/> 
        /// and the corresponding call to
        /// <see cref="glEnd"/> . 
        /// It is possible for an application to bind more than one
        /// attribute name to the same generic vertex attribute index. This
        /// is referred to as aliasing, and it is allowed only if just one
        /// of the aliased attribute variables is active in the vertex
        /// shader, or if no path through the vertex shader consumes more
        /// than one of the attributes aliased to the same location. OpenGL
        /// implementations are not required to do error checking to detect
        /// aliasing, they are allowed to assume that aliasing will not
        /// occur, and they are allowed to employ optimizations that work
        /// only in the absence of aliasing. 
        /// There is no provision for binding standard vertex
        /// attributes; therefore, it is not possible to alias generic
        /// attributes with standard attributes.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="index"/> is greater than or equal to
        /// <code>GL_MAX_VERTEX_ATTRIBS</code>.
        /// </para>
        /// Original: <para>void glVertexAttrib3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2);</para>
        /// </summary>
        /// <param name="index">
        /// <para>
        /// Specifies the index of the generic vertex
        /// attribute to be modified.
        /// </para>
        /// </param>
        /// <seealso cref="BindAttribLocation"/>
        /// <seealso cref="Vertex"/>
        /// <seealso cref="VertexAttribPointer"/>
        public static void VertexAttrib3d(uint index, double v0, double v1, double v2) {
            GLNative.glVertexAttrib3d(index, v0, v1, v2);
        }

        /// <summary>
        /// Specifies the value of a generic vertex attribute
        /// <para>Require:</para> <para>GL_VERSION_2_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glVertexAttrib"/> is available only if
        /// the GL version is 2.0 or greater. 
        /// Generic vertex attributes can be updated at any time. In
        /// particular, <see cref="glVertexAttrib"/> can be called
        /// between a call to
        /// <see cref="glBegin"/> 
        /// and the corresponding call to
        /// <see cref="glEnd"/> . 
        /// It is possible for an application to bind more than one
        /// attribute name to the same generic vertex attribute index. This
        /// is referred to as aliasing, and it is allowed only if just one
        /// of the aliased attribute variables is active in the vertex
        /// shader, or if no path through the vertex shader consumes more
        /// than one of the attributes aliased to the same location. OpenGL
        /// implementations are not required to do error checking to detect
        /// aliasing, they are allowed to assume that aliasing will not
        /// occur, and they are allowed to employ optimizations that work
        /// only in the absence of aliasing. 
        /// There is no provision for binding standard vertex
        /// attributes; therefore, it is not possible to alias generic
        /// attributes with standard attributes.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="index"/> is greater than or equal to
        /// <code>GL_MAX_VERTEX_ATTRIBS</code>.
        /// </para>
        /// Original: <para>void glVertexAttrib3f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2);</para>
        /// </summary>
        /// <param name="index">
        /// <para>
        /// Specifies the index of the generic vertex
        /// attribute to be modified.
        /// </para>
        /// </param>
        /// <seealso cref="BindAttribLocation"/>
        /// <seealso cref="Vertex"/>
        /// <seealso cref="VertexAttribPointer"/>
        public static void VertexAttrib3f(uint index, float v0, float v1, float v2) {
            GLNative.glVertexAttrib3f(index, v0, v1, v2);
        }

        /// <summary>
        /// Specifies the value of a generic vertex attribute
        /// <para>Require:</para> <para>GL_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glVertexAttrib"/> is available only if
        /// the GL version is 2.0 or greater. 
        /// Generic vertex attributes can be updated at any time. In
        /// particular, <see cref="glVertexAttrib"/> can be called
        /// between a call to
        /// <see cref="glBegin"/> 
        /// and the corresponding call to
        /// <see cref="glEnd"/> . 
        /// It is possible for an application to bind more than one
        /// attribute name to the same generic vertex attribute index. This
        /// is referred to as aliasing, and it is allowed only if just one
        /// of the aliased attribute variables is active in the vertex
        /// shader, or if no path through the vertex shader consumes more
        /// than one of the attributes aliased to the same location. OpenGL
        /// implementations are not required to do error checking to detect
        /// aliasing, they are allowed to assume that aliasing will not
        /// occur, and they are allowed to employ optimizations that work
        /// only in the absence of aliasing. 
        /// There is no provision for binding standard vertex
        /// attributes; therefore, it is not possible to alias generic
        /// attributes with standard attributes.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="index"/> is greater than or equal to
        /// <code>GL_MAX_VERTEX_ATTRIBS</code>.
        /// </para>
        /// Original: <para>void glVertexAttrib3s(GLuint index, GLshort v0, GLshort v1, GLshort v2);</para>
        /// </summary>
        /// <param name="index">
        /// <para>
        /// Specifies the index of the generic vertex
        /// attribute to be modified.
        /// </para>
        /// </param>
        /// <seealso cref="BindAttribLocation"/>
        /// <seealso cref="Vertex"/>
        /// <seealso cref="VertexAttribPointer"/>
        public static void VertexAttrib3s(uint index, short v0, short v1, short v2) {
            GLNative.glVertexAttrib3s(index, v0, v1, v2);
        }

        /// <summary>
        /// Specifies the value of a generic vertex attribute
        /// <para>Require:</para> <para>GL_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glVertexAttrib"/> is available only if
        /// the GL version is 2.0 or greater. 
        /// Generic vertex attributes can be updated at any time. In
        /// particular, <see cref="glVertexAttrib"/> can be called
        /// between a call to
        /// <see cref="glBegin"/> 
        /// and the corresponding call to
        /// <see cref="glEnd"/> . 
        /// It is possible for an application to bind more than one
        /// attribute name to the same generic vertex attribute index. This
        /// is referred to as aliasing, and it is allowed only if just one
        /// of the aliased attribute variables is active in the vertex
        /// shader, or if no path through the vertex shader consumes more
        /// than one of the attributes aliased to the same location. OpenGL
        /// implementations are not required to do error checking to detect
        /// aliasing, they are allowed to assume that aliasing will not
        /// occur, and they are allowed to employ optimizations that work
        /// only in the absence of aliasing. 
        /// There is no provision for binding standard vertex
        /// attributes; therefore, it is not possible to alias generic
        /// attributes with standard attributes.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="index"/> is greater than or equal to
        /// <code>GL_MAX_VERTEX_ATTRIBS</code>.
        /// </para>
        /// Original: <para>void glVertexAttrib4Nub(GLuint index, GLubyte v0, GLubyte v1, GLubyte v2, GLubyte v3);</para>
        /// </summary>
        /// <param name="index">
        /// <para>
        /// Specifies the index of the generic vertex
        /// attribute to be modified.
        /// </para>
        /// </param>
        /// <seealso cref="BindAttribLocation"/>
        /// <seealso cref="Vertex"/>
        /// <seealso cref="VertexAttribPointer"/>
        public static void VertexAttrib4Nub(uint index, byte v0, byte v1, byte v2, byte v3) {
            GLNative.glVertexAttrib4Nub(index, v0, v1, v2, v3);
        }

        /// <summary>
        /// Specifies the value of a generic vertex attribute
        /// <para>Require:</para> <para>GL_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glVertexAttrib"/> is available only if
        /// the GL version is 2.0 or greater. 
        /// Generic vertex attributes can be updated at any time. In
        /// particular, <see cref="glVertexAttrib"/> can be called
        /// between a call to
        /// <see cref="glBegin"/> 
        /// and the corresponding call to
        /// <see cref="glEnd"/> . 
        /// It is possible for an application to bind more than one
        /// attribute name to the same generic vertex attribute index. This
        /// is referred to as aliasing, and it is allowed only if just one
        /// of the aliased attribute variables is active in the vertex
        /// shader, or if no path through the vertex shader consumes more
        /// than one of the attributes aliased to the same location. OpenGL
        /// implementations are not required to do error checking to detect
        /// aliasing, they are allowed to assume that aliasing will not
        /// occur, and they are allowed to employ optimizations that work
        /// only in the absence of aliasing. 
        /// There is no provision for binding standard vertex
        /// attributes; therefore, it is not possible to alias generic
        /// attributes with standard attributes.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="index"/> is greater than or equal to
        /// <code>GL_MAX_VERTEX_ATTRIBS</code>.
        /// </para>
        /// Original: <para>void glVertexAttrib4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3);</para>
        /// </summary>
        /// <param name="index">
        /// <para>
        /// Specifies the index of the generic vertex
        /// attribute to be modified.
        /// </para>
        /// </param>
        /// <seealso cref="BindAttribLocation"/>
        /// <seealso cref="Vertex"/>
        /// <seealso cref="VertexAttribPointer"/>
        public static void VertexAttrib4d(uint index, double v0, double v1, double v2, double v3) {
            GLNative.glVertexAttrib4d(index, v0, v1, v2, v3);
        }

        /// <summary>
        /// Specifies the value of a generic vertex attribute
        /// <para>Require:</para> <para>GL_VERSION_2_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glVertexAttrib"/> is available only if
        /// the GL version is 2.0 or greater. 
        /// Generic vertex attributes can be updated at any time. In
        /// particular, <see cref="glVertexAttrib"/> can be called
        /// between a call to
        /// <see cref="glBegin"/> 
        /// and the corresponding call to
        /// <see cref="glEnd"/> . 
        /// It is possible for an application to bind more than one
        /// attribute name to the same generic vertex attribute index. This
        /// is referred to as aliasing, and it is allowed only if just one
        /// of the aliased attribute variables is active in the vertex
        /// shader, or if no path through the vertex shader consumes more
        /// than one of the attributes aliased to the same location. OpenGL
        /// implementations are not required to do error checking to detect
        /// aliasing, they are allowed to assume that aliasing will not
        /// occur, and they are allowed to employ optimizations that work
        /// only in the absence of aliasing. 
        /// There is no provision for binding standard vertex
        /// attributes; therefore, it is not possible to alias generic
        /// attributes with standard attributes.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="index"/> is greater than or equal to
        /// <code>GL_MAX_VERTEX_ATTRIBS</code>.
        /// </para>
        /// Original: <para>void glVertexAttrib4f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3);</para>
        /// </summary>
        /// <param name="index">
        /// <para>
        /// Specifies the index of the generic vertex
        /// attribute to be modified.
        /// </para>
        /// </param>
        /// <seealso cref="BindAttribLocation"/>
        /// <seealso cref="Vertex"/>
        /// <seealso cref="VertexAttribPointer"/>
        public static void VertexAttrib4f(uint index, float v0, float v1, float v2, float v3) {
            GLNative.glVertexAttrib4f(index, v0, v1, v2, v3);
        }

        /// <summary>
        /// Specifies the value of a generic vertex attribute
        /// <para>Require:</para> <para>GL_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glVertexAttrib"/> is available only if
        /// the GL version is 2.0 or greater. 
        /// Generic vertex attributes can be updated at any time. In
        /// particular, <see cref="glVertexAttrib"/> can be called
        /// between a call to
        /// <see cref="glBegin"/> 
        /// and the corresponding call to
        /// <see cref="glEnd"/> . 
        /// It is possible for an application to bind more than one
        /// attribute name to the same generic vertex attribute index. This
        /// is referred to as aliasing, and it is allowed only if just one
        /// of the aliased attribute variables is active in the vertex
        /// shader, or if no path through the vertex shader consumes more
        /// than one of the attributes aliased to the same location. OpenGL
        /// implementations are not required to do error checking to detect
        /// aliasing, they are allowed to assume that aliasing will not
        /// occur, and they are allowed to employ optimizations that work
        /// only in the absence of aliasing. 
        /// There is no provision for binding standard vertex
        /// attributes; therefore, it is not possible to alias generic
        /// attributes with standard attributes.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="index"/> is greater than or equal to
        /// <code>GL_MAX_VERTEX_ATTRIBS</code>.
        /// </para>
        /// Original: <para>void glVertexAttrib4s(GLuint index, GLshort v0, GLshort v1, GLshort v2, GLshort v3);</para>
        /// </summary>
        /// <param name="index">
        /// <para>
        /// Specifies the index of the generic vertex
        /// attribute to be modified.
        /// </para>
        /// </param>
        /// <seealso cref="BindAttribLocation"/>
        /// <seealso cref="Vertex"/>
        /// <seealso cref="VertexAttribPointer"/>
        public static void VertexAttrib4s(uint index, short v0, short v1, short v2, short v3) {
            GLNative.glVertexAttrib4s(index, v0, v1, v2, v3);
        }


        #endregion GL_VERSION_2_0

        #region GL_VERSION_2_1


        #endregion GL_VERSION_2_1

        #region GL_VERSION_3_0

        /// <summary>
        /// enable and disable writing of frame buffer color components
        /// <para>Require:</para> <para>GL_VERSION_3_0, GL_ES_VERSION_3_2</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glColorMaski(GLuint buf, GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha);</para>
        /// </summary>
        public static void ColorMaski(uint buf, bool red, bool green, bool blue, bool alpha) {
            GLNative.glColorMaski(buf, red, green, blue, alpha);
        }

        /// <summary>
        /// enable or disable server-side GL capabilities
        /// <para>Require:</para> <para>GL_VERSION_3_0, GL_ES_VERSION_3_2</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glEnablei(GLenum cap, GLuint index);</para>
        /// </summary>
        public static void Enablei(uint cap, uint index) {
            GLNative.glEnablei(cap, index);
        }

        /// <summary>
        /// enable or disable server-side GL capabilities
        /// <para>Require:</para> <para>GL_VERSION_3_0, GL_ES_VERSION_3_2</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glDisablei(GLenum cap, GLuint index);</para>
        /// </summary>
        public static void Disablei(uint cap, uint index) {
            GLNative.glDisablei(cap, index);
        }

        /// <summary>
        /// test whether a capability is enabled
        /// <para>Require:</para> <para>GL_VERSION_3_0, GL_ES_VERSION_3_2</para>
        /// Supported: <para>GL</para>
        /// Original: <para>GLboolean glIsEnabledi(GLenum cap, GLuint index);</para>
        /// </summary>
        public static bool IsEnabledi(uint cap, uint index) {
            return GLNative.glIsEnabledi(cap, index);
        }

        /// <summary>
        /// start transform feedback operation
        /// <para>Require:</para> <para>GL_VERSION_3_0, GL_ES_VERSION_3_0</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glBeginTransformFeedback(GLenum primitiveMode);</para>
        /// </summary>
        public static void BeginTransformFeedback(uint primitiveMode) {
            GLNative.glBeginTransformFeedback(primitiveMode);
        }

        /// <summary>
        /// start transform feedback operation
        /// <para>Require:</para> <para>GL_VERSION_3_0, GL_ES_VERSION_3_0</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glEndTransformFeedback();</para>
        /// </summary>
        public static void EndTransformFeedback() {
            GLNative.glEndTransformFeedback();
        }

        /// <summary>
        /// bind a range within a buffer object to an indexed buffer target
        /// <para>Require:</para> <para>GL_VERSION_3_0, GL_VERSION_3_1, GL_ES_VERSION_3_0, GL_ARB_uniform_buffer_object</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glBindBufferRange(GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size);</para>
        /// </summary>
        public static void BindBufferRange(uint target, uint index, uint buffer, IntPtr offset, IntPtr size) {
            GLNative.glBindBufferRange(target, index, buffer, offset, size);
        }

        /// <summary>
        /// bind a buffer object to an indexed buffer target
        /// <para>Require:</para> <para>GL_VERSION_3_0, GL_VERSION_3_1, GL_ES_VERSION_3_0, GL_ARB_uniform_buffer_object</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glBindBufferBase(GLenum target, GLuint index, GLuint buffer);</para>
        /// </summary>
        public static void BindBufferBase(uint target, uint index, uint buffer) {
            GLNative.glBindBufferBase(target, index, buffer);
        }

        /// <summary>
        /// specify whether data read via  <see cref="glReadPixels"/>  should be clamped
        /// <para>Require:</para> <para>GL_VERSION_3_0</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glClampColor(GLenum target, GLenum clamp);</para>
        /// </summary>
        public static void ClampColor(uint target, uint clamp) {
            GLNative.glClampColor(target, clamp);
        }

        /// <summary>
        /// start conditional rendering
        /// <para>Require:</para> <para>GL_VERSION_3_0</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glBeginConditionalRender(GLuint id, GLenum mode);</para>
        /// </summary>
        public static void BeginConditionalRender(uint id, uint mode) {
            GLNative.glBeginConditionalRender(id, mode);
        }

        /// <summary>
        /// start conditional rendering
        /// <para>Require:</para> <para>GL_VERSION_3_0</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glEndConditionalRender();</para>
        /// </summary>
        public static void EndConditionalRender() {
            GLNative.glEndConditionalRender();
        }

        /// <summary>
        /// Specifies the value of a generic vertex attribute
        /// <para>Require:</para> <para>GL_VERSION_3_0</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glVertexAttribI1i(GLuint index, GLint v0);</para>
        /// </summary>
        public static void VertexAttribI1i(uint index, int v0) {
            GLNative.glVertexAttribI1i(index, v0);
        }

        /// <summary>
        /// Specifies the value of a generic vertex attribute
        /// <para>Require:</para> <para>GL_VERSION_3_0</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glVertexAttribI2i(GLuint index, GLint v0, GLint v1);</para>
        /// </summary>
        public static void VertexAttribI2i(uint index, int v0, int v1) {
            GLNative.glVertexAttribI2i(index, v0, v1);
        }

        /// <summary>
        /// Specifies the value of a generic vertex attribute
        /// <para>Require:</para> <para>GL_VERSION_3_0</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glVertexAttribI3i(GLuint index, GLint v0, GLint v1, GLint v2);</para>
        /// </summary>
        public static void VertexAttribI3i(uint index, int v0, int v1, int v2) {
            GLNative.glVertexAttribI3i(index, v0, v1, v2);
        }

        /// <summary>
        /// Specifies the value of a generic vertex attribute
        /// <para>Require:</para> <para>GL_VERSION_3_0, GL_ES_VERSION_3_0</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glVertexAttribI4i(GLuint index, GLint v0, GLint v1, GLint v2, GLint v3);</para>
        /// </summary>
        public static void VertexAttribI4i(uint index, int v0, int v1, int v2, int v3) {
            GLNative.glVertexAttribI4i(index, v0, v1, v2, v3);
        }

        /// <summary>
        /// Specifies the value of a generic vertex attribute
        /// <para>Require:</para> <para>GL_VERSION_3_0</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glVertexAttribI1ui(GLuint index, GLuint v0);</para>
        /// </summary>
        public static void VertexAttribI1ui(uint index, uint v0) {
            GLNative.glVertexAttribI1ui(index, v0);
        }

        /// <summary>
        /// Specifies the value of a generic vertex attribute
        /// <para>Require:</para> <para>GL_VERSION_3_0</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glVertexAttribI2ui(GLuint index, GLuint v0, GLuint v1);</para>
        /// </summary>
        public static void VertexAttribI2ui(uint index, uint v0, uint v1) {
            GLNative.glVertexAttribI2ui(index, v0, v1);
        }

        /// <summary>
        /// Specifies the value of a generic vertex attribute
        /// <para>Require:</para> <para>GL_VERSION_3_0</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glVertexAttribI3ui(GLuint index, GLuint v0, GLuint v1, GLuint v2);</para>
        /// </summary>
        public static void VertexAttribI3ui(uint index, uint v0, uint v1, uint v2) {
            GLNative.glVertexAttribI3ui(index, v0, v1, v2);
        }

        /// <summary>
        /// Specifies the value of a generic vertex attribute
        /// <para>Require:</para> <para>GL_VERSION_3_0, GL_ES_VERSION_3_0</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glVertexAttribI4ui(GLuint index, GLuint v0, GLuint v1, GLuint v2, GLuint v3);</para>
        /// </summary>
        public static void VertexAttribI4ui(uint index, uint v0, uint v1, uint v2, uint v3) {
            GLNative.glVertexAttribI4ui(index, v0, v1, v2, v3);
        }

        /// <summary>
        /// Specify the value of a uniform variable for the current program object
        /// <para>Require:</para> <para>GL_VERSION_3_0, GL_ES_VERSION_3_0</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glUniform1ui(GLint location, GLuint v0);</para>
        /// </summary>
        public static void Uniform1ui(int location, uint v0) {
            GLNative.glUniform1ui(location, v0);
        }

        /// <summary>
        /// Specify the value of a uniform variable for the current program object
        /// <para>Require:</para> <para>GL_VERSION_3_0, GL_ES_VERSION_3_0</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glUniform2ui(GLint location, GLuint v0, GLuint v1);</para>
        /// </summary>
        public static void Uniform2ui(int location, uint v0, uint v1) {
            GLNative.glUniform2ui(location, v0, v1);
        }

        /// <summary>
        /// Specify the value of a uniform variable for the current program object
        /// <para>Require:</para> <para>GL_VERSION_3_0, GL_ES_VERSION_3_0</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glUniform3ui(GLint location, GLuint v0, GLuint v1, GLuint v2);</para>
        /// </summary>
        public static void Uniform3ui(int location, uint v0, uint v1, uint v2) {
            GLNative.glUniform3ui(location, v0, v1, v2);
        }

        /// <summary>
        /// Specify the value of a uniform variable for the current program object
        /// <para>Require:</para> <para>GL_VERSION_3_0, GL_ES_VERSION_3_0</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glUniform4ui(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3);</para>
        /// </summary>
        public static void Uniform4ui(int location, uint v0, uint v1, uint v2, uint v3) {
            GLNative.glUniform4ui(location, v0, v1, v2, v3);
        }

        /// <summary>
        /// clear individual buffers of a framebuffer
        /// <para>Require:</para> <para>GL_VERSION_3_0, GL_ES_VERSION_3_0</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glClearBufferfi(GLenum buffer, GLint drawbuffer, GLfloat depth, GLint stencil);</para>
        /// </summary>
        public static void ClearBufferfi(uint buffer, int drawbuffer, float depth, int stencil) {
            GLNative.glClearBufferfi(buffer, drawbuffer, depth, stencil);
        }


        #region Reuse ARB_framebuffer_object

        /// <summary>
        /// determine if a name corresponds to a renderbuffer object
        /// <para>Require:</para> <para>GL_VERSION_3_0, GL_ES_VERSION_2_0, GL_ARB_framebuffer_object</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>GLboolean glIsRenderbuffer(GLuint renderbuffer);</para>
        /// </summary>
        public static bool IsRenderbuffer(uint renderbuffer) {
            return GLNative.glIsRenderbuffer(renderbuffer);
        }

        /// <summary>
        /// bind a renderbuffer to a renderbuffer target
        /// <para>Require:</para> <para>GL_VERSION_3_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0, GL_ARB_framebuffer_object</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glBindRenderbuffer(GLenum target, GLuint renderbuffer);</para>
        /// </summary>
        public static void BindRenderbuffer(uint target, uint renderbuffer) {
            GLNative.glBindRenderbuffer(target, renderbuffer);
        }

        /// <summary>
        /// <para>
        /// establish data storage, format and dimensions of a
        /// renderbuffer object's image
        /// </para>
        /// <para>Require:</para> <para>GL_VERSION_3_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0, GL_ARB_framebuffer_object</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glRenderbufferStorage(GLenum target, GLenum internalformat, GLsizei width, GLsizei height);</para>
        /// </summary>
        public static void RenderbufferStorage(uint target, uint internalformat, int width, int height) {
            GLNative.glRenderbufferStorage(target, internalformat, width, height);
        }

        /// <summary>
        /// determine if a name corresponds to a framebuffer object
        /// <para>Require:</para> <para>GL_VERSION_3_0, GL_ES_VERSION_2_0, GL_ARB_framebuffer_object</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>GLboolean glIsFramebuffer(GLuint framebuffer);</para>
        /// </summary>
        public static bool IsFramebuffer(uint framebuffer) {
            return GLNative.glIsFramebuffer(framebuffer);
        }

        /// <summary>
        /// bind a framebuffer to a framebuffer target
        /// <para>Require:</para> <para>GL_VERSION_3_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0, GL_ARB_framebuffer_object</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glBindFramebuffer(GLenum target, GLuint framebuffer);</para>
        /// </summary>
        public static void BindFramebuffer(uint target, uint framebuffer) {
            GLNative.glBindFramebuffer(target, framebuffer);
        }

        /// <summary>
        /// check the completeness status of a framebuffer
        /// <para>Require:</para> <para>GL_VERSION_3_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0, GL_ARB_framebuffer_object</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>GLenum glCheckFramebufferStatus(GLenum target);</para>
        /// </summary>
        public static uint CheckFramebufferStatus(uint target) {
            return GLNative.glCheckFramebufferStatus(target);
        }

        /// <summary>
        /// attach a level of a texture object as a logical buffer of a framebuffer object
        /// <para>Require:</para> <para>GL_VERSION_3_0, GL_ARB_framebuffer_object</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glFramebufferTexture1D(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level);</para>
        /// </summary>
        public static void FramebufferTexture1D(uint target, uint attachment, uint textarget, uint texture, int level) {
            GLNative.glFramebufferTexture1D(target, attachment, textarget, texture, level);
        }

        /// <summary>
        /// attach a level of a texture object as a logical buffer of a framebuffer object
        /// <para>Require:</para> <para>GL_VERSION_3_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0, GL_ARB_framebuffer_object</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glFramebufferTexture2D(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level);</para>
        /// </summary>
        public static void FramebufferTexture2D(uint target, uint attachment, uint textarget, uint texture, int level) {
            GLNative.glFramebufferTexture2D(target, attachment, textarget, texture, level);
        }

        /// <summary>
        /// attach a level of a texture object as a logical buffer of a framebuffer object
        /// <para>Require:</para> <para>GL_VERSION_3_0, GL_ARB_framebuffer_object</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glFramebufferTexture3D(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint layer);</para>
        /// </summary>
        public static void FramebufferTexture3D(uint target, uint attachment, uint textarget, uint texture, int level, int layer) {
            GLNative.glFramebufferTexture3D(target, attachment, textarget, texture, level, layer);
        }

        /// <summary>
        /// attach a renderbuffer as a logical buffer of a framebuffer object
        /// <para>Require:</para> <para>GL_VERSION_3_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0, GL_ARB_framebuffer_object</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glFramebufferRenderbuffer(GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer);</para>
        /// </summary>
        public static void FramebufferRenderbuffer(uint target, uint attachment, uint renderbuffertarget, uint renderbuffer) {
            GLNative.glFramebufferRenderbuffer(target, attachment, renderbuffertarget, renderbuffer);
        }

        /// <summary>
        /// generate mipmaps for a specified texture object
        /// <para>Require:</para> <para>GL_VERSION_3_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0, GL_ARB_framebuffer_object</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGenerateMipmap(GLenum target);</para>
        /// </summary>
        public static void GenerateMipmap(uint target) {
            GLNative.glGenerateMipmap(target);
        }

        /// <summary>
        /// copy a block of pixels from one framebuffer object to another
        /// <para>Require:</para> <para>GL_VERSION_3_0, GL_ES_VERSION_3_0, GL_ARB_framebuffer_object</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glBlitFramebuffer(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter);</para>
        /// </summary>
        public static void BlitFramebuffer(int srcX0, int srcY0, int srcX1, int srcY1, int dstX0, int dstY0, int dstX1, int dstY1, uint mask, uint filter) {
            GLNative.glBlitFramebuffer(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
        }

        /// <summary>
        /// <para>
        /// establish data storage, format, dimensions and sample count of
        /// a renderbuffer object's image
        /// </para>
        /// <para>Require:</para> <para>GL_VERSION_3_0, GL_ES_VERSION_3_0, GL_ARB_framebuffer_object</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glRenderbufferStorageMultisample(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height);</para>
        /// </summary>
        public static void RenderbufferStorageMultisample(uint target, int samples, uint internalformat, int width, int height) {
            GLNative.glRenderbufferStorageMultisample(target, samples, internalformat, width, height);
        }

        /// <summary>
        /// attach a single layer of a texture object as a logical buffer of a framebuffer object
        /// <para>Require:</para> <para>GL_VERSION_3_0, GL_ES_VERSION_3_0, GL_ARB_framebuffer_object</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glFramebufferTextureLayer(GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer);</para>
        /// </summary>
        public static void FramebufferTextureLayer(uint target, uint attachment, uint texture, int level, int layer) {
            GLNative.glFramebufferTextureLayer(target, attachment, texture, level, layer);
        }


        #endregion Reuse ARB_framebuffer_object

        #region Reuse ARB_map_buffer_range

        /// <summary>
        /// indicate modifications to a range of a mapped buffer
        /// <para>Require:</para> <para>GL_VERSION_3_0, GL_ES_VERSION_3_0, GL_ARB_map_buffer_range</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glFlushMappedBufferRange(GLenum target, GLintptr offset, GLsizeiptr length);</para>
        /// </summary>
        public static void FlushMappedBufferRange(uint target, IntPtr offset, IntPtr length) {
            GLNative.glFlushMappedBufferRange(target, offset, length);
        }


        #endregion Reuse ARB_map_buffer_range

        #region Reuse ARB_vertex_array_object

        /// <summary>
        /// bind a vertex array object
        /// <para>Require:</para> <para>GL_VERSION_3_0, GL_ES_VERSION_3_0, GL_ARB_vertex_array_object</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glBindVertexArray(GLuint array);</para>
        /// </summary>
        public static void BindVertexArray(uint array) {
            GLNative.glBindVertexArray(array);
        }

        /// <summary>
        /// determine if a name corresponds to a vertex array object
        /// <para>Require:</para> <para>GL_VERSION_3_0, GL_ES_VERSION_3_0, GL_ARB_vertex_array_object</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>GLboolean glIsVertexArray(GLuint array);</para>
        /// </summary>
        public static bool IsVertexArray(uint array) {
            return GLNative.glIsVertexArray(array);
        }


        #endregion Reuse ARB_vertex_array_object

        #endregion GL_VERSION_3_0

        #region GL_VERSION_3_1

        /// <summary>
        /// draw multiple instances of a range of elements
        /// <para>Require:</para> <para>GL_VERSION_3_1, GL_ES_VERSION_3_0</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glDrawArraysInstanced(GLenum mode, GLint first, GLsizei count, GLsizei instancecount);</para>
        /// </summary>
        public static void DrawArraysInstanced(uint mode, int first, int count, int instancecount) {
            GLNative.glDrawArraysInstanced(mode, first, count, instancecount);
        }

        /// <summary>
        /// attach a buffer object's data store to a buffer texture object
        /// <para>Require:</para> <para>GL_VERSION_3_1, GL_ES_VERSION_3_2</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glTexBuffer(GLenum target, GLenum internalformat, GLuint buffer);</para>
        /// </summary>
        public static void TexBuffer(uint target, uint internalformat, uint buffer) {
            GLNative.glTexBuffer(target, internalformat, buffer);
        }

        /// <summary>
        /// specify the primitive restart index
        /// <para>Require:</para> <para>GL_VERSION_3_1</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glPrimitiveRestartIndex(GLuint index);</para>
        /// </summary>
        public static void PrimitiveRestartIndex(uint index) {
            GLNative.glPrimitiveRestartIndex(index);
        }


        #region Reuse ARB_copy_buffer

        /// <summary>
        /// copy all or part of the data store of a buffer object to the data store of another buffer object
        /// <para>Require:</para> <para>GL_VERSION_3_1, GL_ES_VERSION_3_0, GL_ARB_copy_buffer</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glCopyBufferSubData(GLenum readTarget, GLenum writeTarget, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size);</para>
        /// </summary>
        public static void CopyBufferSubData(uint readTarget, uint writeTarget, IntPtr readOffset, IntPtr writeOffset, IntPtr size) {
            GLNative.glCopyBufferSubData(readTarget, writeTarget, readOffset, writeOffset, size);
        }


        #endregion Reuse ARB_copy_buffer

        #region Reuse ARB_uniform_buffer_object

        /// <summary>
        /// assign a binding point to an active uniform block
        /// <para>Require:</para> <para>GL_VERSION_3_1, GL_ES_VERSION_3_0, GL_ARB_uniform_buffer_object</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glUniformBlockBinding(GLuint program, GLuint uniformBlockIndex, GLuint uniformBlockBinding);</para>
        /// </summary>
        public static void UniformBlockBinding(uint program, uint uniformBlockIndex, uint uniformBlockBinding) {
            GLNative.glUniformBlockBinding(program, uniformBlockIndex, uniformBlockBinding);
        }

        // void glBindBufferRange(GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size);
        // void glBindBufferBase(GLenum target, GLuint index, GLuint buffer);

        #endregion Reuse ARB_uniform_buffer_object

        #endregion GL_VERSION_3_1

        #region GL_VERSION_3_2


        #region Reuse ARB_draw_elements_base_vertex


        #endregion Reuse ARB_draw_elements_base_vertex

        #region Reuse ARB_provoking_vertex

        /// <summary>
        /// specifiy the vertex to be used as the source of data for flat shaded varyings
        /// <para>Require:</para> <para>GL_VERSION_3_2, GL_ARB_provoking_vertex</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glProvokingVertex(GLenum provokeMode);</para>
        /// </summary>
        public static void ProvokingVertex(uint provokeMode) {
            GLNative.glProvokingVertex(provokeMode);
        }


        #endregion Reuse ARB_provoking_vertex

        #region Reuse ARB_sync

        /// <summary>
        /// create a new sync object and insert it into the GL command stream
        /// <para>Require:</para> <para>GL_VERSION_3_2, GL_ES_VERSION_3_0, GL_ARB_sync</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>GLsync glFenceSync(GLenum condition, GLbitfield flags);</para>
        /// </summary>
        public static IntPtr FenceSync(uint condition, uint flags) {
            return GLNative.glFenceSync(condition, flags);
        }

        /// <summary>
        /// determine if a name corresponds to a sync object
        /// <para>Require:</para> <para>GL_VERSION_3_2, GL_ES_VERSION_3_0, GL_ARB_sync</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>GLboolean glIsSync(GLsync sync);</para>
        /// </summary>
        public static bool IsSync(IntPtr sync) {
            return GLNative.glIsSync(sync);
        }

        /// <summary>
        /// delete a sync object
        /// <para>Require:</para> <para>GL_VERSION_3_2, GL_ES_VERSION_3_0, GL_ARB_sync</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glDeleteSync(GLsync sync);</para>
        /// </summary>
        public static void DeleteSync(IntPtr sync) {
            GLNative.glDeleteSync(sync);
        }

        /// <summary>
        /// block and wait for a sync object to become signaled
        /// <para>Require:</para> <para>GL_VERSION_3_2, GL_ES_VERSION_3_0, GL_ARB_sync</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>GLenum glClientWaitSync(GLsync sync, GLbitfield flags, GLuint64 timeout);</para>
        /// </summary>
        public static uint ClientWaitSync(IntPtr sync, uint flags, UInt64 timeout) {
            return GLNative.glClientWaitSync(sync, flags, timeout);
        }

        /// <summary>
        /// instruct the GL server to block until the specified sync object becomes signaled
        /// <para>Require:</para> <para>GL_VERSION_3_2, GL_ES_VERSION_3_0, GL_ARB_sync</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glWaitSync(GLsync sync, GLbitfield flags, GLuint64 timeout);</para>
        /// </summary>
        public static void WaitSync(IntPtr sync, uint flags, UInt64 timeout) {
            GLNative.glWaitSync(sync, flags, timeout);
        }


        #endregion Reuse ARB_sync

        #region Reuse ARB_texture_multisample

        /// <summary>
        /// attach a level of a texture object as a logical buffer of a framebuffer object
        /// <para>Require:</para> <para>GL_VERSION_3_2, GL_ES_VERSION_3_2</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glFramebufferTexture(GLenum target, GLenum attachment, GLuint texture, GLint level);</para>
        /// </summary>
        public static void FramebufferTexture(uint target, uint attachment, uint texture, int level) {
            GLNative.glFramebufferTexture(target, attachment, texture, level);
        }

        /// <summary>
        /// establish the data storage, format, dimensions, and number of samples of a multisample texture's image
        /// <para>Require:</para> <para>GL_VERSION_3_2, GL_ARB_texture_multisample</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glTexImage2DMultisample(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations);</para>
        /// </summary>
        public static void TexImage2DMultisample(uint target, int samples, uint internalformat, int width, int height, bool fixedsamplelocations) {
            GLNative.glTexImage2DMultisample(target, samples, internalformat, width, height, fixedsamplelocations);
        }

        /// <summary>
        /// establish the data storage, format, dimensions, and number of samples of a multisample texture's image
        /// <para>Require:</para> <para>GL_VERSION_3_2, GL_ARB_texture_multisample</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glTexImage3DMultisample(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations);</para>
        /// </summary>
        public static void TexImage3DMultisample(uint target, int samples, uint internalformat, int width, int height, int depth, bool fixedsamplelocations) {
            GLNative.glTexImage3DMultisample(target, samples, internalformat, width, height, depth, fixedsamplelocations);
        }

        /// <summary>
        /// set the value of a sub-word of the sample mask
        /// <para>Require:</para> <para>GL_VERSION_3_2, GL_ES_VERSION_3_1, GL_ARB_texture_multisample</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glSampleMaski(GLuint maskNumber, GLbitfield mask);</para>
        /// </summary>
        public static void SampleMaski(uint maskNumber, uint mask) {
            GLNative.glSampleMaski(maskNumber, mask);
        }


        #endregion Reuse ARB_texture_multisample

        #region Compatibility-only GL 1.0 features removed from GL 3.2

        // void glNewList(GLuint list, GLenum mode);
        // void glEndList();
        // void glCallList(GLuint list);
        // void glDeleteLists(GLuint list, GLsizei range);
        // GLuint glGenLists(GLsizei range);
        // void glListBase(GLuint b);
        // void glBegin(GLenum mode);
        // void glColor3b(GLbyte red, GLbyte green, GLbyte blue);
        // void glColor3d(GLdouble red, GLdouble green, GLdouble blue);
        // void glColor3f(GLfloat red, GLfloat green, GLfloat blue);
        // void glColor3i(GLint red, GLint green, GLint blue);
        // void glColor3s(GLshort red, GLshort green, GLshort blue);
        // void glColor3ub(GLubyte red, GLubyte green, GLubyte blue);
        // void glColor3ui(GLuint red, GLuint green, GLuint blue);
        // void glColor3us(GLushort red, GLushort green, GLushort blue);
        // void glColor4b(GLbyte red, GLbyte green, GLbyte blue, GLbyte alpha);
        // void glColor4d(GLdouble red, GLdouble green, GLdouble blue, GLdouble alpha);
        // void glColor4f(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha);
        // void glColor4i(GLint red, GLint green, GLint blue, GLint alpha);
        // void glColor4s(GLshort red, GLshort green, GLshort blue, GLshort alpha);
        // void glColor4ub(GLubyte red, GLubyte green, GLubyte blue, GLubyte alpha);
        // void glColor4ui(GLuint red, GLuint green, GLuint blue, GLuint alpha);
        // void glColor4us(GLushort red, GLushort green, GLushort blue, GLushort alpha);
        // void glEdgeFlag(GLboolean flag);
        // void glEnd();
        // void glIndexd(GLdouble c);
        // void glIndexf(GLfloat c);
        // void glIndexi(GLint c);
        // void glIndexs(GLshort c);
        // void glNormal3b(GLbyte nx, GLbyte ny, GLbyte nz);
        // void glNormal3d(GLdouble nx, GLdouble ny, GLdouble nz);
        // void glNormal3f(GLfloat nx, GLfloat ny, GLfloat nz);
        // void glNormal3i(GLint nx, GLint ny, GLint nz);
        // void glNormal3s(GLshort nx, GLshort ny, GLshort nz);
        // void glRasterPos2d(GLdouble x, GLdouble y);
        // void glRasterPos2f(GLfloat x, GLfloat y);
        // void glRasterPos2i(GLint x, GLint y);
        // void glRasterPos2s(GLshort x, GLshort y);
        // void glRasterPos3d(GLdouble x, GLdouble y, GLdouble z);
        // void glRasterPos3f(GLfloat x, GLfloat y, GLfloat z);
        // void glRasterPos3i(GLint x, GLint y, GLint z);
        // void glRasterPos3s(GLshort x, GLshort y, GLshort z);
        // void glRasterPos4d(GLdouble x, GLdouble y, GLdouble z, GLdouble w);
        // void glRasterPos4f(GLfloat x, GLfloat y, GLfloat z, GLfloat w);
        // void glRasterPos4i(GLint x, GLint y, GLint z, GLint w);
        // void glRasterPos4s(GLshort x, GLshort y, GLshort z, GLshort w);
        // void glRectd(GLdouble x1, GLdouble y1, GLdouble x2, GLdouble y2);
        // void glRectf(GLfloat x1, GLfloat y1, GLfloat x2, GLfloat y2);
        // void glRecti(GLint x1, GLint y1, GLint x2, GLint y2);
        // void glRects(GLshort x1, GLshort y1, GLshort x2, GLshort y2);
        // void glTexCoord1d(GLdouble s);
        // void glTexCoord1f(GLfloat s);
        // void glTexCoord1i(GLint s);
        // void glTexCoord1s(GLshort s);
        // void glTexCoord2d(GLdouble s, GLdouble t);
        // void glTexCoord2f(GLfloat s, GLfloat t);
        // void glTexCoord2i(GLint s, GLint t);
        // void glTexCoord2s(GLshort s, GLshort t);
        // void glTexCoord3d(GLdouble s, GLdouble t, GLdouble r);
        // void glTexCoord3f(GLfloat s, GLfloat t, GLfloat r);
        // void glTexCoord3i(GLint s, GLint t, GLint r);
        // void glTexCoord3s(GLshort s, GLshort t, GLshort r);
        // void glTexCoord4d(GLdouble s, GLdouble t, GLdouble r, GLdouble q);
        // void glTexCoord4f(GLfloat s, GLfloat t, GLfloat r, GLfloat q);
        // void glTexCoord4i(GLint s, GLint t, GLint r, GLint q);
        // void glTexCoord4s(GLshort s, GLshort t, GLshort r, GLshort q);
        // void glVertex2d(GLdouble x, GLdouble y);
        // void glVertex2f(GLfloat x, GLfloat y);
        // void glVertex2i(GLint x, GLint y);
        // void glVertex2s(GLshort x, GLshort y);
        // void glVertex3d(GLdouble x, GLdouble y, GLdouble z);
        // void glVertex3f(GLfloat x, GLfloat y, GLfloat z);
        // void glVertex3i(GLint x, GLint y, GLint z);
        // void glVertex3s(GLshort x, GLshort y, GLshort z);
        // void glVertex4d(GLdouble x, GLdouble y, GLdouble z, GLdouble w);
        // void glVertex4f(GLfloat x, GLfloat y, GLfloat z, GLfloat w);
        // void glVertex4i(GLint x, GLint y, GLint z, GLint w);
        // void glVertex4s(GLshort x, GLshort y, GLshort z, GLshort w);
        // void glColorMaterial(GLenum face, GLenum mode);
        // void glFogf(GLenum pname, GLfloat param);
        // void glFogi(GLenum pname, GLint param);
        // void glLightf(GLenum light, GLenum pname, GLfloat param);
        // void glLighti(GLenum light, GLenum pname, GLint param);
        // void glLightModelf(GLenum pname, GLfloat param);
        // void glLightModeli(GLenum pname, GLint param);
        // void glLineStipple(GLint factor, GLushort pattern);
        // void glMaterialf(GLenum face, GLenum pname, GLfloat param);
        // void glMateriali(GLenum face, GLenum pname, GLint param);
        // void glShadeModel(GLenum mode);
        // void glTexEnvf(GLenum target, GLenum pname, GLfloat param);
        // void glTexEnvi(GLenum target, GLenum pname, GLint param);
        // void glTexGend(GLenum coord, GLenum pname, GLdouble param);
        // void glTexGenf(GLenum coord, GLenum pname, GLfloat param);
        // void glTexGeni(GLenum coord, GLenum pname, GLint param);
        // GLint glRenderMode(GLenum mode);
        // void glInitNames();
        // void glLoadName(GLuint name);
        // void glPassThrough(GLfloat token);
        // void glPopName();
        // void glPushName(GLuint name);
        // void glClearAccum(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha);
        // void glClearIndex(GLfloat c);
        // void glIndexMask(GLuint mask);
        // void glAccum(GLenum op, GLfloat value);
        // void glPopAttrib();
        // void glPushAttrib(GLbitfield mask);
        // void glMapGrid1d(GLint un, GLdouble u1, GLdouble u2);
        // void glMapGrid1f(GLint un, GLfloat u1, GLfloat u2);
        // void glMapGrid2d(GLint un, GLdouble u1, GLdouble u2, GLint vn, GLdouble v1, GLdouble v2);
        // void glMapGrid2f(GLint un, GLfloat u1, GLfloat u2, GLint vn, GLfloat v1, GLfloat v2);
        // void glEvalCoord1d(GLdouble u);
        // void glEvalCoord1f(GLfloat u);
        // void glEvalCoord2d(GLdouble u, GLdouble v);
        // void glEvalCoord2f(GLfloat u, GLfloat v);
        // void glEvalMesh1(GLenum mode, GLint i1, GLint i2);
        // void glEvalPoint1(GLint i);
        // void glEvalMesh2(GLenum mode, GLint i1, GLint i2, GLint j1, GLint j2);
        // void glEvalPoint2(GLint i, GLint j);
        // void glAlphaFunc(GLenum func, GLclampf r);
        // void glPixelZoom(GLfloat xfactor, GLfloat yfactor);
        // void glPixelTransferf(GLenum pname, GLfloat param);
        // void glPixelTransferi(GLenum pname, GLint param);
        // void glCopyPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum type);
        // GLboolean glIsList(GLuint list);
        // void glFrustum(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble nearVal, GLdouble farVal);
        // void glLoadIdentity();
        // void glMatrixMode(GLenum mode);
        // void glOrtho(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble nearVal, GLdouble farVal);
        // void glPopMatrix();
        // void glPushMatrix();
        // void glRotated(GLdouble angle, GLdouble x, GLdouble y, GLdouble z);
        // void glRotatef(GLfloat angle, GLfloat x, GLfloat y, GLfloat z);
        // void glScaled(GLdouble x, GLdouble y, GLdouble z);
        // void glScalef(GLfloat x, GLfloat y, GLfloat z);
        // void glTranslated(GLdouble x, GLdouble y, GLdouble z);
        // void glTranslatef(GLfloat x, GLfloat y, GLfloat z);

        #endregion Compatibility-only GL 1.0 features removed from GL 3.2

        #region Compatibility-only GL 1.1 features removed from GL 3.2

        // void glArrayElement(GLint i);
        // void glDisableClientState(GLenum cap);
        // void glEnableClientState(GLenum cap);
        // void glIndexub(GLubyte c);
        // void glPopClientAttrib();
        // void glPushClientAttrib(GLbitfield mask);

        #endregion Compatibility-only GL 1.1 features removed from GL 3.2

        #region Compatibility-only GL 1.2 features removed from GL 3.2


        #endregion Compatibility-only GL 1.2 features removed from GL 3.2

        #region Compatibility-only GL 1.3 features removed from GL 3.2

        // void glClientActiveTexture(GLenum texture);
        // void glMultiTexCoord1d(GLenum target, GLdouble s);
        // void glMultiTexCoord1f(GLenum target, GLfloat s);
        // void glMultiTexCoord1i(GLenum target, GLint s);
        // void glMultiTexCoord1s(GLenum target, GLshort s);
        // void glMultiTexCoord2d(GLenum target, GLdouble s, GLdouble t);
        // void glMultiTexCoord2f(GLenum target, GLfloat s, GLfloat t);
        // void glMultiTexCoord2i(GLenum target, GLint s, GLint t);
        // void glMultiTexCoord2s(GLenum target, GLshort s, GLshort t);
        // void glMultiTexCoord3d(GLenum target, GLdouble s, GLdouble t, GLdouble r);
        // void glMultiTexCoord3f(GLenum target, GLfloat s, GLfloat t, GLfloat r);
        // void glMultiTexCoord3i(GLenum target, GLint s, GLint t, GLint r);
        // void glMultiTexCoord3s(GLenum target, GLshort s, GLshort t, GLshort r);
        // void glMultiTexCoord4d(GLenum target, GLdouble s, GLdouble t, GLdouble r, GLdouble q);
        // void glMultiTexCoord4f(GLenum target, GLfloat s, GLfloat t, GLfloat r, GLfloat q);
        // void glMultiTexCoord4i(GLenum target, GLint s, GLint t, GLint r, GLint q);
        // void glMultiTexCoord4s(GLenum target, GLshort s, GLshort t, GLshort r, GLshort q);

        #endregion Compatibility-only GL 1.3 features removed from GL 3.2

        #region Compatibility-only GL 1.4 features removed from GL 3.2

        // void glFogCoordf(GLfloat coord);
        // void glFogCoordd(GLdouble coord);
        // void glSecondaryColor3b(GLbyte red, GLbyte green, GLbyte blue);
        // void glSecondaryColor3d(GLdouble red, GLdouble green, GLdouble blue);
        // void glSecondaryColor3f(GLfloat red, GLfloat green, GLfloat blue);
        // void glSecondaryColor3i(GLint red, GLint green, GLint blue);
        // void glSecondaryColor3s(GLshort red, GLshort green, GLshort blue);
        // void glSecondaryColor3ub(GLubyte red, GLubyte green, GLubyte blue);
        // void glSecondaryColor3ui(GLuint red, GLuint green, GLuint blue);
        // void glSecondaryColor3us(GLushort red, GLushort green, GLushort blue);
        // void glWindowPos2d(GLdouble x, GLdouble y);
        // void glWindowPos2f(GLfloat x, GLfloat y);
        // void glWindowPos2i(GLint x, GLint y);
        // void glWindowPos2s(GLshort x, GLshort y);
        // void glWindowPos3d(GLdouble x, GLdouble y, GLdouble z);
        // void glWindowPos3f(GLfloat x, GLfloat y, GLfloat z);
        // void glWindowPos3i(GLint x, GLint y, GLint z);
        // void glWindowPos3s(GLshort x, GLshort y, GLshort z);

        #endregion Compatibility-only GL 1.4 features removed from GL 3.2

        #region Compatibility-only GL 1.5 features removed from GL 3.2


        #endregion Compatibility-only GL 1.5 features removed from GL 3.2

        #region Compatibility-only GL 2.0 features removed from GL 3.2


        #endregion Compatibility-only GL 2.0 features removed from GL 3.2

        #region Compatibility-only GL 2.1 features removed from GL 3.2


        #endregion Compatibility-only GL 2.1 features removed from GL 3.2

        #region Compatibility-only GL 3.0 features removed from GL 3.2


        #endregion Compatibility-only GL 3.0 features removed from GL 3.2

        #endregion GL_VERSION_3_2

        #region GL_VERSION_3_3


        #region Reuse ARB_blend_func_extended


        #endregion Reuse ARB_blend_func_extended

        #region Reuse ARB_sampler_objects

        /// <summary>
        /// determine if a name corresponds to a sampler object
        /// <para>Require:</para> <para>GL_VERSION_3_3, GL_ES_VERSION_3_0, GL_ARB_sampler_objects</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>GLboolean glIsSampler(GLuint id);</para>
        /// </summary>
        public static bool IsSampler(uint id) {
            return GLNative.glIsSampler(id);
        }

        /// <summary>
        /// bind a named sampler to a texturing target
        /// <para>Require:</para> <para>GL_VERSION_3_3, GL_ES_VERSION_3_0, GL_ARB_sampler_objects</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glBindSampler(GLuint unit, GLuint sampler);</para>
        /// </summary>
        public static void BindSampler(uint unit, uint sampler) {
            GLNative.glBindSampler(unit, sampler);
        }

        /// <summary>
        /// set sampler parameters
        /// <para>Require:</para> <para>GL_VERSION_3_3, GL_ES_VERSION_3_0, GL_ARB_sampler_objects</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glSamplerParameteri(GLuint sampler, GLenum pname, GLint param);</para>
        /// </summary>
        public static void SamplerParameteri(uint sampler, uint pname, int param) {
            GLNative.glSamplerParameteri(sampler, pname, param);
        }

        /// <summary>
        /// set sampler parameters
        /// <para>Require:</para> <para>GL_VERSION_3_3, GL_ES_VERSION_3_0, GL_ARB_sampler_objects</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glSamplerParameterf(GLuint sampler, GLenum pname, GLfloat param);</para>
        /// </summary>
        public static void SamplerParameterf(uint sampler, uint pname, float param) {
            GLNative.glSamplerParameterf(sampler, pname, param);
        }


        #endregion Reuse ARB_sampler_objects

        #region Reuse ARB_timer_query

        /// <summary>
        /// record the GL time into a query object after all previous commands have reached the GL server but have not yet necessarily executed.
        /// <para>Require:</para> <para>GL_VERSION_3_3, GL_ARB_timer_query</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glQueryCounter(GLuint id, GLenum target);</para>
        /// </summary>
        public static void QueryCounter(uint id, uint target) {
            GLNative.glQueryCounter(id, target);
        }


        #endregion Reuse ARB_timer_query

        #region Reuse ARB_vertex_type_2_10_10_10_rev

        /// <summary>
        /// modify the rate at which generic vertex attributes advance during instanced rendering
        /// <para>Require:</para> <para>GL_VERSION_3_3, GL_ES_VERSION_3_0</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glVertexAttribDivisor(GLuint index, GLuint divisor);</para>
        /// </summary>
        public static void VertexAttribDivisor(uint index, uint divisor) {
            GLNative.glVertexAttribDivisor(index, divisor);
        }

        /// <summary>
        /// Specifies the value of a generic vertex attribute
        /// <para>Require:</para> <para>GL_VERSION_3_3, GL_ARB_vertex_type_2_10_10_10_rev</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glVertexAttribP1ui(GLuint index, GLenum type, GLboolean normalized, GLuint value);</para>
        /// </summary>
        public static void VertexAttribP1ui(uint index, uint type, bool normalized, uint value) {
            GLNative.glVertexAttribP1ui(index, type, normalized, value);
        }

        /// <summary>
        /// Specifies the value of a generic vertex attribute
        /// <para>Require:</para> <para>GL_VERSION_3_3, GL_ARB_vertex_type_2_10_10_10_rev</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glVertexAttribP2ui(GLuint index, GLenum type, GLboolean normalized, GLuint value);</para>
        /// </summary>
        public static void VertexAttribP2ui(uint index, uint type, bool normalized, uint value) {
            GLNative.glVertexAttribP2ui(index, type, normalized, value);
        }

        /// <summary>
        /// Specifies the value of a generic vertex attribute
        /// <para>Require:</para> <para>GL_VERSION_3_3, GL_ARB_vertex_type_2_10_10_10_rev</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glVertexAttribP3ui(GLuint index, GLenum type, GLboolean normalized, GLuint value);</para>
        /// </summary>
        public static void VertexAttribP3ui(uint index, uint type, bool normalized, uint value) {
            GLNative.glVertexAttribP3ui(index, type, normalized, value);
        }

        /// <summary>
        /// Specifies the value of a generic vertex attribute
        /// <para>Require:</para> <para>GL_VERSION_3_3, GL_ARB_vertex_type_2_10_10_10_rev</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glVertexAttribP4ui(GLuint index, GLenum type, GLboolean normalized, GLuint value);</para>
        /// </summary>
        public static void VertexAttribP4ui(uint index, uint type, bool normalized, uint value) {
            GLNative.glVertexAttribP4ui(index, type, normalized, value);
        }


        #endregion Reuse ARB_vertex_type_2_10_10_10_rev

        #region Reuse ARB_vertex_type_2_10_10_10_rev compatibility profile

        /// <summary>
        /// <para>Require:</para> <para>GL_VERSION_3_3, GL_ARB_vertex_type_2_10_10_10_rev</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glVertexP2ui(GLenum type, GLuint value);</para>
        /// </summary>
        public static void VertexP2ui(uint type, uint value) {
            GLNative.glVertexP2ui(type, value);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_VERSION_3_3, GL_ARB_vertex_type_2_10_10_10_rev</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glVertexP3ui(GLenum type, GLuint value);</para>
        /// </summary>
        public static void VertexP3ui(uint type, uint value) {
            GLNative.glVertexP3ui(type, value);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_VERSION_3_3, GL_ARB_vertex_type_2_10_10_10_rev</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glVertexP4ui(GLenum type, GLuint value);</para>
        /// </summary>
        public static void VertexP4ui(uint type, uint value) {
            GLNative.glVertexP4ui(type, value);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_VERSION_3_3, GL_ARB_vertex_type_2_10_10_10_rev</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glTexCoordP1ui(GLenum type, GLuint coords);</para>
        /// </summary>
        public static void TexCoordP1ui(uint type, uint coords) {
            GLNative.glTexCoordP1ui(type, coords);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_VERSION_3_3, GL_ARB_vertex_type_2_10_10_10_rev</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glTexCoordP2ui(GLenum type, GLuint coords);</para>
        /// </summary>
        public static void TexCoordP2ui(uint type, uint coords) {
            GLNative.glTexCoordP2ui(type, coords);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_VERSION_3_3, GL_ARB_vertex_type_2_10_10_10_rev</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glTexCoordP3ui(GLenum type, GLuint coords);</para>
        /// </summary>
        public static void TexCoordP3ui(uint type, uint coords) {
            GLNative.glTexCoordP3ui(type, coords);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_VERSION_3_3, GL_ARB_vertex_type_2_10_10_10_rev</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glTexCoordP4ui(GLenum type, GLuint coords);</para>
        /// </summary>
        public static void TexCoordP4ui(uint type, uint coords) {
            GLNative.glTexCoordP4ui(type, coords);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_VERSION_3_3, GL_ARB_vertex_type_2_10_10_10_rev</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glMultiTexCoordP1ui(GLenum texture, GLenum type, GLuint coords);</para>
        /// </summary>
        public static void MultiTexCoordP1ui(uint texture, uint type, uint coords) {
            GLNative.glMultiTexCoordP1ui(texture, type, coords);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_VERSION_3_3, GL_ARB_vertex_type_2_10_10_10_rev</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glMultiTexCoordP2ui(GLenum texture, GLenum type, GLuint coords);</para>
        /// </summary>
        public static void MultiTexCoordP2ui(uint texture, uint type, uint coords) {
            GLNative.glMultiTexCoordP2ui(texture, type, coords);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_VERSION_3_3, GL_ARB_vertex_type_2_10_10_10_rev</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glMultiTexCoordP3ui(GLenum texture, GLenum type, GLuint coords);</para>
        /// </summary>
        public static void MultiTexCoordP3ui(uint texture, uint type, uint coords) {
            GLNative.glMultiTexCoordP3ui(texture, type, coords);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_VERSION_3_3, GL_ARB_vertex_type_2_10_10_10_rev</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glMultiTexCoordP4ui(GLenum texture, GLenum type, GLuint coords);</para>
        /// </summary>
        public static void MultiTexCoordP4ui(uint texture, uint type, uint coords) {
            GLNative.glMultiTexCoordP4ui(texture, type, coords);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_VERSION_3_3, GL_ARB_vertex_type_2_10_10_10_rev</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glNormalP3ui(GLenum type, GLuint coords);</para>
        /// </summary>
        public static void NormalP3ui(uint type, uint coords) {
            GLNative.glNormalP3ui(type, coords);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_VERSION_3_3, GL_ARB_vertex_type_2_10_10_10_rev</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glColorP3ui(GLenum type, GLuint color);</para>
        /// </summary>
        public static void ColorP3ui(uint type, uint color) {
            GLNative.glColorP3ui(type, color);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_VERSION_3_3, GL_ARB_vertex_type_2_10_10_10_rev</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glColorP4ui(GLenum type, GLuint color);</para>
        /// </summary>
        public static void ColorP4ui(uint type, uint color) {
            GLNative.glColorP4ui(type, color);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_VERSION_3_3, GL_ARB_vertex_type_2_10_10_10_rev</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glSecondaryColorP3ui(GLenum type, GLuint color);</para>
        /// </summary>
        public static void SecondaryColorP3ui(uint type, uint color) {
            GLNative.glSecondaryColorP3ui(type, color);
        }


        #endregion Reuse ARB_vertex_type_2_10_10_10_rev compatibility profile

        #endregion GL_VERSION_3_3

        #region GL_VERSION_4_0

        /// <summary>
        /// specifies minimum rate at which sample shading takes place
        /// <para>Require:</para> <para>GL_VERSION_4_0, GL_ES_VERSION_3_2</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glMinSampleShading(GLfloat value);</para>
        /// </summary>
        public static void MinSampleShading(float value) {
            GLNative.glMinSampleShading(value);
        }

        /// <summary>
        /// specify the equation used for both the RGB blend equation and the Alpha blend equation
        /// <para>Require:</para> <para>GL_VERSION_4_0, GL_ES_VERSION_3_2</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glBlendEquationi(GLuint buf, GLenum mode);</para>
        /// </summary>
        public static void BlendEquationi(uint buf, uint mode) {
            GLNative.glBlendEquationi(buf, mode);
        }

        /// <summary>
        /// set the RGB blend equation and the alpha blend equation separately
        /// <para>Require:</para> <para>GL_VERSION_4_0, GL_ES_VERSION_3_2</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glBlendEquationSeparatei(GLuint buf, GLenum modeRGB, GLenum modeAlpha);</para>
        /// </summary>
        public static void BlendEquationSeparatei(uint buf, uint modeRGB, uint modeAlpha) {
            GLNative.glBlendEquationSeparatei(buf, modeRGB, modeAlpha);
        }

        /// <summary>
        /// specify pixel arithmetic
        /// <para>Require:</para> <para>GL_VERSION_4_0, GL_ES_VERSION_3_2</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glBlendFunci(GLuint buf, GLenum sfactor, GLenum dfactor);</para>
        /// </summary>
        public static void BlendFunci(uint buf, uint sfactor, uint dfactor) {
            GLNative.glBlendFunci(buf, sfactor, dfactor);
        }

        /// <summary>
        /// specify pixel arithmetic for RGB and alpha components separately
        /// <para>Require:</para> <para>GL_VERSION_4_0, GL_ES_VERSION_3_2</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glBlendFuncSeparatei(GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha);</para>
        /// </summary>
        public static void BlendFuncSeparatei(uint buf, uint srcRGB, uint dstRGB, uint srcAlpha, uint dstAlpha) {
            GLNative.glBlendFuncSeparatei(buf, srcRGB, dstRGB, srcAlpha, dstAlpha);
        }


        #region Reuse ARB_draw_indirect


        #endregion Reuse ARB_draw_indirect

        #region Reuse ARB_gpu_shader_fp64

        /// <summary>
        /// <para>Require:</para> <para>GL_VERSION_4_0, GL_ARB_gpu_shader_fp64</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glUniform1d(GLint location, GLdouble x);</para>
        /// </summary>
        public static void Uniform1d(int location, double x) {
            GLNative.glUniform1d(location, x);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_VERSION_4_0, GL_ARB_gpu_shader_fp64</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glUniform2d(GLint location, GLdouble x, GLdouble y);</para>
        /// </summary>
        public static void Uniform2d(int location, double x, double y) {
            GLNative.glUniform2d(location, x, y);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_VERSION_4_0, GL_ARB_gpu_shader_fp64</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glUniform3d(GLint location, GLdouble x, GLdouble y, GLdouble z);</para>
        /// </summary>
        public static void Uniform3d(int location, double x, double y, double z) {
            GLNative.glUniform3d(location, x, y, z);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_VERSION_4_0, GL_ARB_gpu_shader_fp64</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glUniform4d(GLint location, GLdouble x, GLdouble y, GLdouble z, GLdouble w);</para>
        /// </summary>
        public static void Uniform4d(int location, double x, double y, double z, double w) {
            GLNative.glUniform4d(location, x, y, z, w);
        }


        #endregion Reuse ARB_gpu_shader_fp64

        #region Reuse ARB_shader_subroutine


        #endregion Reuse ARB_shader_subroutine

        #region Reuse ARB_tessellation_shader

        /// <summary>
        /// specifies the parameters for patch primitives
        /// <para>Require:</para> <para>GL_VERSION_4_0, GL_ES_VERSION_3_2, GL_ARB_tessellation_shader</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glPatchParameteri(GLenum pname, GLint value);</para>
        /// </summary>
        public static void PatchParameteri(uint pname, int value) {
            GLNative.glPatchParameteri(pname, value);
        }


        #endregion Reuse ARB_tessellation_shader

        #region Reuse ARB_transform_feedback2

        /// <summary>
        /// bind a transform feedback object
        /// <para>Require:</para> <para>GL_VERSION_4_0, GL_ES_VERSION_3_0, GL_ARB_transform_feedback2</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glBindTransformFeedback(GLenum target, GLuint id);</para>
        /// </summary>
        public static void BindTransformFeedback(uint target, uint id) {
            GLNative.glBindTransformFeedback(target, id);
        }

        /// <summary>
        /// determine if a name corresponds to a transform feedback object
        /// <para>Require:</para> <para>GL_VERSION_4_0, GL_ES_VERSION_3_0, GL_ARB_transform_feedback2</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>GLboolean glIsTransformFeedback(GLuint id);</para>
        /// </summary>
        public static bool IsTransformFeedback(uint id) {
            return GLNative.glIsTransformFeedback(id);
        }

        /// <summary>
        /// pause transform feedback operations
        /// <para>Require:</para> <para>GL_VERSION_4_0, GL_ES_VERSION_3_0, GL_ARB_transform_feedback2</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glPauseTransformFeedback();</para>
        /// </summary>
        public static void PauseTransformFeedback() {
            GLNative.glPauseTransformFeedback();
        }

        /// <summary>
        /// resume transform feedback operations
        /// <para>Require:</para> <para>GL_VERSION_4_0, GL_ES_VERSION_3_0, GL_ARB_transform_feedback2</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glResumeTransformFeedback();</para>
        /// </summary>
        public static void ResumeTransformFeedback() {
            GLNative.glResumeTransformFeedback();
        }

        /// <summary>
        /// render primitives using a count derived from a transform feedback object
        /// <para>Require:</para> <para>GL_VERSION_4_0, GL_ARB_transform_feedback2</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glDrawTransformFeedback(GLenum mode, GLuint id);</para>
        /// </summary>
        public static void DrawTransformFeedback(uint mode, uint id) {
            GLNative.glDrawTransformFeedback(mode, id);
        }


        #endregion Reuse ARB_transform_feedback2

        #region Reuse ARB_transform_feedback3

        /// <summary>
        /// render primitives using a count derived from a specifed stream of a transform feedback object
        /// <para>Require:</para> <para>GL_VERSION_4_0, GL_ARB_transform_feedback3</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glDrawTransformFeedbackStream(GLenum mode, GLuint id, GLuint stream);</para>
        /// </summary>
        public static void DrawTransformFeedbackStream(uint mode, uint id, uint stream) {
            GLNative.glDrawTransformFeedbackStream(mode, id, stream);
        }

        /// <summary>
        /// delimit the boundaries of a query object on an indexed target
        /// <para>Require:</para> <para>GL_VERSION_4_0, GL_ARB_transform_feedback3</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glBeginQueryIndexed(GLenum target, GLuint index, GLuint id);</para>
        /// </summary>
        public static void BeginQueryIndexed(uint target, uint index, uint id) {
            GLNative.glBeginQueryIndexed(target, index, id);
        }

        /// <summary>
        /// delimit the boundaries of a query object on an indexed target
        /// <para>Require:</para> <para>GL_VERSION_4_0, GL_ARB_transform_feedback3</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glEndQueryIndexed(GLenum target, GLuint index);</para>
        /// </summary>
        public static void EndQueryIndexed(uint target, uint index) {
            GLNative.glEndQueryIndexed(target, index);
        }


        #endregion Reuse ARB_transform_feedback3

        #endregion GL_VERSION_4_0

        #region GL_VERSION_4_1


        #region Reuse commands from ARB_ES2_compatibility

        /// <summary>
        /// release resources consumed by the implementation's shader compiler
        /// <para>Require:</para> <para>GL_VERSION_4_1, GL_ES_VERSION_2_0, GL_ARB_ES2_compatibility</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glReleaseShaderCompiler();</para>
        /// </summary>
        public static void ReleaseShaderCompiler() {
            GLNative.glReleaseShaderCompiler();
        }

        /// <summary>
        /// specify mapping of depth values from normalized device coordinates to window coordinates
        /// <para>Require:</para> <para>GL_VERSION_4_1, GL_VERSION_ES_CM_1_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0, GL_ARB_ES2_compatibility</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glDepthRangef(GLfloat nearVal, GLfloat farVal);</para>
        /// </summary>
        public static void DepthRangef(float nearVal, float farVal) {
            GLNative.glDepthRangef(nearVal, farVal);
        }

        /// <summary>
        /// specify the clear value for the depth buffer
        /// <para>Require:</para> <para>GL_VERSION_4_1, GL_VERSION_ES_CM_1_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0, GL_ARB_ES2_compatibility</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glClearDepthf(GLfloat depth);</para>
        /// </summary>
        public static void ClearDepthf(float depth) {
            GLNative.glClearDepthf(depth);
        }


        #endregion Reuse commands from ARB_ES2_compatibility

        #region Reuse commands from ARB_get_program_binary

        /// <summary>
        /// specify a parameter for a program object
        /// <para>Require:</para> <para>GL_VERSION_4_1, GL_VERSION_4_1, GL_ES_VERSION_3_0, GL_ARB_get_program_binary, GL_ARB_separate_shader_objects</para>
        /// Supported: <para>gl, glcore, gl, glcore</para>
        /// Original: <para>void glProgramParameteri(GLuint program, GLenum pname, GLint value);</para>
        /// </summary>
        public static void ProgramParameteri(uint program, uint pname, int value) {
            GLNative.glProgramParameteri(program, pname, value);
        }


        #endregion Reuse commands from ARB_get_program_binary

        #region Reuse commands from ARB_separate_shader_objects

        /// <summary>
        /// bind stages of a program object to a program pipeline
        /// <para>Require:</para> <para>GL_VERSION_4_1, GL_ES_VERSION_3_1, GL_ARB_separate_shader_objects</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glUseProgramStages(GLuint pipeline, GLbitfield stages, GLuint program);</para>
        /// </summary>
        public static void UseProgramStages(uint pipeline, uint stages, uint program) {
            GLNative.glUseProgramStages(pipeline, stages, program);
        }

        /// <summary>
        /// set the active program object for a program pipeline object
        /// <para>Require:</para> <para>GL_VERSION_4_1, GL_ES_VERSION_3_1, GL_ARB_separate_shader_objects</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glActiveShaderProgram(GLuint pipeline, GLuint program);</para>
        /// </summary>
        public static void ActiveShaderProgram(uint pipeline, uint program) {
            GLNative.glActiveShaderProgram(pipeline, program);
        }

        /// <summary>
        /// bind a program pipeline to the current context
        /// <para>Require:</para> <para>GL_VERSION_4_1, GL_ES_VERSION_3_1, GL_ARB_separate_shader_objects</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glBindProgramPipeline(GLuint pipeline);</para>
        /// </summary>
        public static void BindProgramPipeline(uint pipeline) {
            GLNative.glBindProgramPipeline(pipeline);
        }

        /// <summary>
        /// determine if a name corresponds to a program pipeline object
        /// <para>Require:</para> <para>GL_VERSION_4_1, GL_ES_VERSION_3_1, GL_ARB_separate_shader_objects</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>GLboolean glIsProgramPipeline(GLuint pipeline);</para>
        /// </summary>
        public static bool IsProgramPipeline(uint pipeline) {
            return GLNative.glIsProgramPipeline(pipeline);
        }

        // void glProgramParameteri(GLuint program, GLenum pname, GLint value);
        /// <summary>
        /// Specify the value of a uniform variable for a specified program object
        /// <para>Require:</para> <para>GL_VERSION_4_1, GL_ES_VERSION_3_1, GL_ARB_separate_shader_objects</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glProgramUniform1i(GLuint program, GLint location, GLint v0);</para>
        /// </summary>
        public static void ProgramUniform1i(uint program, int location, int v0) {
            GLNative.glProgramUniform1i(program, location, v0);
        }

        /// <summary>
        /// Specify the value of a uniform variable for a specified program object
        /// <para>Require:</para> <para>GL_VERSION_4_1, GL_ES_VERSION_3_1, GL_ARB_separate_shader_objects</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glProgramUniform1f(GLuint program, GLint location, GLfloat v0);</para>
        /// </summary>
        public static void ProgramUniform1f(uint program, int location, float v0) {
            GLNative.glProgramUniform1f(program, location, v0);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_VERSION_4_1, GL_ARB_separate_shader_objects</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glProgramUniform1d(GLuint program, GLint location, GLdouble v0);</para>
        /// </summary>
        public static void ProgramUniform1d(uint program, int location, double v0) {
            GLNative.glProgramUniform1d(program, location, v0);
        }

        /// <summary>
        /// Specify the value of a uniform variable for a specified program object
        /// <para>Require:</para> <para>GL_VERSION_4_1, GL_ES_VERSION_3_1, GL_ARB_separate_shader_objects</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glProgramUniform1ui(GLuint program, GLint location, GLuint v0);</para>
        /// </summary>
        public static void ProgramUniform1ui(uint program, int location, uint v0) {
            GLNative.glProgramUniform1ui(program, location, v0);
        }

        /// <summary>
        /// Specify the value of a uniform variable for a specified program object
        /// <para>Require:</para> <para>GL_VERSION_4_1, GL_ES_VERSION_3_1, GL_ARB_separate_shader_objects</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glProgramUniform2i(GLuint program, GLint location, GLint v0, GLint v1);</para>
        /// </summary>
        public static void ProgramUniform2i(uint program, int location, int v0, int v1) {
            GLNative.glProgramUniform2i(program, location, v0, v1);
        }

        /// <summary>
        /// Specify the value of a uniform variable for a specified program object
        /// <para>Require:</para> <para>GL_VERSION_4_1, GL_ES_VERSION_3_1, GL_ARB_separate_shader_objects</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glProgramUniform2f(GLuint program, GLint location, GLfloat v0, GLfloat v1);</para>
        /// </summary>
        public static void ProgramUniform2f(uint program, int location, float v0, float v1) {
            GLNative.glProgramUniform2f(program, location, v0, v1);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_VERSION_4_1, GL_ARB_separate_shader_objects</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glProgramUniform2d(GLuint program, GLint location, GLdouble v0, GLdouble v1);</para>
        /// </summary>
        public static void ProgramUniform2d(uint program, int location, double v0, double v1) {
            GLNative.glProgramUniform2d(program, location, v0, v1);
        }

        /// <summary>
        /// Specify the value of a uniform variable for a specified program object
        /// <para>Require:</para> <para>GL_VERSION_4_1, GL_ES_VERSION_3_1, GL_ARB_separate_shader_objects</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glProgramUniform2ui(GLuint program, GLint location, GLuint v0, GLuint v1);</para>
        /// </summary>
        public static void ProgramUniform2ui(uint program, int location, uint v0, uint v1) {
            GLNative.glProgramUniform2ui(program, location, v0, v1);
        }

        /// <summary>
        /// Specify the value of a uniform variable for a specified program object
        /// <para>Require:</para> <para>GL_VERSION_4_1, GL_ES_VERSION_3_1, GL_ARB_separate_shader_objects</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glProgramUniform3i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2);</para>
        /// </summary>
        public static void ProgramUniform3i(uint program, int location, int v0, int v1, int v2) {
            GLNative.glProgramUniform3i(program, location, v0, v1, v2);
        }

        /// <summary>
        /// Specify the value of a uniform variable for a specified program object
        /// <para>Require:</para> <para>GL_VERSION_4_1, GL_ES_VERSION_3_1, GL_ARB_separate_shader_objects</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glProgramUniform3f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2);</para>
        /// </summary>
        public static void ProgramUniform3f(uint program, int location, float v0, float v1, float v2) {
            GLNative.glProgramUniform3f(program, location, v0, v1, v2);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_VERSION_4_1, GL_ARB_separate_shader_objects</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glProgramUniform3d(GLuint program, GLint location, GLdouble v0, GLdouble v1, GLdouble v2);</para>
        /// </summary>
        public static void ProgramUniform3d(uint program, int location, double v0, double v1, double v2) {
            GLNative.glProgramUniform3d(program, location, v0, v1, v2);
        }

        /// <summary>
        /// Specify the value of a uniform variable for a specified program object
        /// <para>Require:</para> <para>GL_VERSION_4_1, GL_ES_VERSION_3_1, GL_ARB_separate_shader_objects</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glProgramUniform3ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2);</para>
        /// </summary>
        public static void ProgramUniform3ui(uint program, int location, uint v0, uint v1, uint v2) {
            GLNative.glProgramUniform3ui(program, location, v0, v1, v2);
        }

        /// <summary>
        /// Specify the value of a uniform variable for a specified program object
        /// <para>Require:</para> <para>GL_VERSION_4_1, GL_ES_VERSION_3_1, GL_ARB_separate_shader_objects</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glProgramUniform4i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3);</para>
        /// </summary>
        public static void ProgramUniform4i(uint program, int location, int v0, int v1, int v2, int v3) {
            GLNative.glProgramUniform4i(program, location, v0, v1, v2, v3);
        }

        /// <summary>
        /// Specify the value of a uniform variable for a specified program object
        /// <para>Require:</para> <para>GL_VERSION_4_1, GL_ES_VERSION_3_1, GL_ARB_separate_shader_objects</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glProgramUniform4f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3);</para>
        /// </summary>
        public static void ProgramUniform4f(uint program, int location, float v0, float v1, float v2, float v3) {
            GLNative.glProgramUniform4f(program, location, v0, v1, v2, v3);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_VERSION_4_1, GL_ARB_separate_shader_objects</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glProgramUniform4d(GLuint program, GLint location, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3);</para>
        /// </summary>
        public static void ProgramUniform4d(uint program, int location, double v0, double v1, double v2, double v3) {
            GLNative.glProgramUniform4d(program, location, v0, v1, v2, v3);
        }

        /// <summary>
        /// Specify the value of a uniform variable for a specified program object
        /// <para>Require:</para> <para>GL_VERSION_4_1, GL_ES_VERSION_3_1, GL_ARB_separate_shader_objects</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glProgramUniform4ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3);</para>
        /// </summary>
        public static void ProgramUniform4ui(uint program, int location, uint v0, uint v1, uint v2, uint v3) {
            GLNative.glProgramUniform4ui(program, location, v0, v1, v2, v3);
        }

        /// <summary>
        /// validate a program pipeline object against current GL state
        /// <para>Require:</para> <para>GL_VERSION_4_1, GL_ES_VERSION_3_1, GL_ARB_separate_shader_objects</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glValidateProgramPipeline(GLuint pipeline);</para>
        /// </summary>
        public static void ValidateProgramPipeline(uint pipeline) {
            GLNative.glValidateProgramPipeline(pipeline);
        }


        #endregion Reuse commands from ARB_separate_shader_objects

        #region Reuse commands from ARB_vertex_attrib_64bit

        /// <summary>
        /// Specifies the value of a generic vertex attribute
        /// <para>Require:</para> <para>GL_VERSION_4_1, GL_ARB_vertex_attrib_64bit</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glVertexAttribL1d(GLuint index, GLdouble v0);</para>
        /// </summary>
        public static void VertexAttribL1d(uint index, double v0) {
            GLNative.glVertexAttribL1d(index, v0);
        }

        /// <summary>
        /// Specifies the value of a generic vertex attribute
        /// <para>Require:</para> <para>GL_VERSION_4_1, GL_ARB_vertex_attrib_64bit</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glVertexAttribL2d(GLuint index, GLdouble v0, GLdouble v1);</para>
        /// </summary>
        public static void VertexAttribL2d(uint index, double v0, double v1) {
            GLNative.glVertexAttribL2d(index, v0, v1);
        }

        /// <summary>
        /// Specifies the value of a generic vertex attribute
        /// <para>Require:</para> <para>GL_VERSION_4_1, GL_ARB_vertex_attrib_64bit</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glVertexAttribL3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2);</para>
        /// </summary>
        public static void VertexAttribL3d(uint index, double v0, double v1, double v2) {
            GLNative.glVertexAttribL3d(index, v0, v1, v2);
        }

        /// <summary>
        /// Specifies the value of a generic vertex attribute
        /// <para>Require:</para> <para>GL_VERSION_4_1, GL_ARB_vertex_attrib_64bit</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glVertexAttribL4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3);</para>
        /// </summary>
        public static void VertexAttribL4d(uint index, double v0, double v1, double v2, double v3) {
            GLNative.glVertexAttribL4d(index, v0, v1, v2, v3);
        }


        #endregion Reuse commands from ARB_vertex_attrib_64bit

        #region Reuse commands from ARB_viewport_array

        /// <summary>
        /// set a specified viewport
        /// <para>Require:</para> <para>GL_VERSION_4_1, GL_ARB_viewport_array</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glViewportIndexedf(GLuint index, GLfloat x, GLfloat y, GLfloat w, GLfloat h);</para>
        /// </summary>
        public static void ViewportIndexedf(uint index, float x, float y, float w, float h) {
            GLNative.glViewportIndexedf(index, x, y, w, h);
        }

        /// <summary>
        /// define the scissor box for a specific viewport
        /// <para>Require:</para> <para>GL_VERSION_4_1, GL_ARB_viewport_array</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glScissorIndexed(GLuint index, GLint left, GLint bottom, GLsizei width, GLsizei height);</para>
        /// </summary>
        public static void ScissorIndexed(uint index, int left, int bottom, int width, int height) {
            GLNative.glScissorIndexed(index, left, bottom, width, height);
        }

        /// <summary>
        /// specify mapping of depth values from normalized device coordinates to window coordinates for a specified viewport
        /// <para>Require:</para> <para>GL_VERSION_4_1, GL_ARB_viewport_array</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glDepthRangeIndexed(GLuint index, GLdouble nearVal, GLdouble farVal);</para>
        /// </summary>
        public static void DepthRangeIndexed(uint index, double nearVal, double farVal) {
            GLNative.glDepthRangeIndexed(index, nearVal, farVal);
        }


        #endregion Reuse commands from ARB_viewport_array

        #endregion GL_VERSION_4_1

        #region GL_VERSION_4_2


        #region Reuse commands from ARB_base_instance

        /// <summary>
        /// draw multiple instances of a range of elements with offset applied to instanced attributes
        /// <para>Require:</para> <para>GL_VERSION_4_2, GL_ARB_base_instance</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glDrawArraysInstancedBaseInstance(GLenum mode, GLint first, GLsizei count, GLsizei instancecount, GLuint baseinstance);</para>
        /// </summary>
        public static void DrawArraysInstancedBaseInstance(uint mode, int first, int count, int instancecount, uint baseinstance) {
            GLNative.glDrawArraysInstancedBaseInstance(mode, first, count, instancecount, baseinstance);
        }


        #endregion Reuse commands from ARB_base_instance

        #region Reuse commands from ARB_internalformat_query


        #endregion Reuse commands from ARB_internalformat_query

        #region Reuse commands from ARB_shader_atomic_counters


        #endregion Reuse commands from ARB_shader_atomic_counters

        #region Reuse commands from ARB_shader_image_load_store

        /// <summary>
        /// bind a level of a texture to an image unit
        /// <para>Require:</para> <para>GL_VERSION_4_2, GL_ES_VERSION_3_1, GL_ARB_shader_image_load_store</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glBindImageTexture(GLuint unit, GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum access, GLenum format);</para>
        /// </summary>
        public static void BindImageTexture(uint unit, uint texture, int level, bool layered, int layer, uint access, uint format) {
            GLNative.glBindImageTexture(unit, texture, level, layered, layer, access, format);
        }

        /// <summary>
        /// defines a barrier ordering memory transactions
        /// <para>Require:</para> <para>GL_VERSION_4_2, GL_ES_VERSION_3_1, GL_ARB_shader_image_load_store</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glMemoryBarrier(GLbitfield barriers);</para>
        /// </summary>
        public static void MemoryBarrier(uint barriers) {
            GLNative.glMemoryBarrier(barriers);
        }


        #endregion Reuse commands from ARB_shader_image_load_store

        #region Reuse commands from ARB_texture_storage

        /// <summary>
        /// simultaneously specify storage for all levels of a one-dimensional texture
        /// <para>Require:</para> <para>GL_VERSION_4_2, GL_ARB_texture_storage</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glTexStorage1D(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width);</para>
        /// </summary>
        public static void TexStorage1D(uint target, int levels, uint internalformat, int width) {
            GLNative.glTexStorage1D(target, levels, internalformat, width);
        }

        /// <summary>
        /// simultaneously specify storage for all levels of a two-dimensional or one-dimensional array texture
        /// <para>Require:</para> <para>GL_VERSION_4_2, GL_ES_VERSION_3_0, GL_SC_VERSION_2_0, GL_ARB_texture_storage</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glTexStorage2D(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height);</para>
        /// </summary>
        public static void TexStorage2D(uint target, int levels, uint internalformat, int width, int height) {
            GLNative.glTexStorage2D(target, levels, internalformat, width, height);
        }

        /// <summary>
        /// simultaneously specify storage for all levels of a three-dimensional, two-dimensional array or cube-map array texture
        /// <para>Require:</para> <para>GL_VERSION_4_2, GL_ES_VERSION_3_0, GL_ARB_texture_storage</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glTexStorage3D(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth);</para>
        /// </summary>
        public static void TexStorage3D(uint target, int levels, uint internalformat, int width, int height, int depth) {
            GLNative.glTexStorage3D(target, levels, internalformat, width, height, depth);
        }


        #endregion Reuse commands from ARB_texture_storage

        #region Reuse commands from ARB_transform_feedback_instanced

        /// <summary>
        /// render multiple instances of primitives using a count derived from a transform feedback object
        /// <para>Require:</para> <para>GL_VERSION_4_2, GL_ARB_transform_feedback_instanced</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glDrawTransformFeedbackInstanced(GLenum mode, GLuint id, GLsizei instancecount);</para>
        /// </summary>
        public static void DrawTransformFeedbackInstanced(uint mode, uint id, int instancecount) {
            GLNative.glDrawTransformFeedbackInstanced(mode, id, instancecount);
        }

        /// <summary>
        /// render multiple instances of primitives using a count derived from a specifed stream of a transform feedback object
        /// <para>Require:</para> <para>GL_VERSION_4_2, GL_ARB_transform_feedback_instanced</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glDrawTransformFeedbackStreamInstanced(GLenum mode, GLuint id, GLuint stream, GLsizei instancecount);</para>
        /// </summary>
        public static void DrawTransformFeedbackStreamInstanced(uint mode, uint id, uint stream, int instancecount) {
            GLNative.glDrawTransformFeedbackStreamInstanced(mode, id, stream, instancecount);
        }


        #endregion Reuse commands from ARB_transform_feedback_instanced

        #endregion GL_VERSION_4_2

        #region GL_VERSION_4_3


        #region Reuse commands from ARB_clear_buffer_object


        #endregion Reuse commands from ARB_clear_buffer_object

        #region Reuse commands from ARB_compute_shader

        /// <summary>
        /// launch one or more compute work groups
        /// <para>Require:</para> <para>GL_VERSION_4_3, GL_ES_VERSION_3_1, GL_ARB_compute_shader</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glDispatchCompute(GLuint num_groups_x, GLuint num_groups_y, GLuint num_groups_z);</para>
        /// </summary>
        public static void DispatchCompute(uint num_groups_x, uint num_groups_y, uint num_groups_z) {
            GLNative.glDispatchCompute(num_groups_x, num_groups_y, num_groups_z);
        }

        /// <summary>
        /// launch one or more compute work groups using parameters stored in a buffer
        /// <para>Require:</para> <para>GL_VERSION_4_3, GL_ES_VERSION_3_1, GL_ARB_compute_shader</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glDispatchComputeIndirect(GLintptr indirect);</para>
        /// </summary>
        public static void DispatchComputeIndirect(IntPtr indirect) {
            GLNative.glDispatchComputeIndirect(indirect);
        }


        #endregion Reuse commands from ARB_compute_shader

        #region Reuse commands from ARB_copy_image

        /// <summary>
        /// perform a raw data copy between two images
        /// <para>Require:</para> <para>GL_VERSION_4_3, GL_ES_VERSION_3_2, GL_ARB_copy_image</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glCopyImageSubData(GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei srcWidth, GLsizei srcHeight, GLsizei srcDepth);</para>
        /// </summary>
        public static void CopyImageSubData(uint srcName, uint srcTarget, int srcLevel, int srcX, int srcY, int srcZ, uint dstName, uint dstTarget, int dstLevel, int dstX, int dstY, int dstZ, int srcWidth, int srcHeight, int srcDepth) {
            GLNative.glCopyImageSubData(srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth);
        }


        #endregion Reuse commands from ARB_copy_image

        #region Reuse commands from ARB_framebuffer_no_attachments

        /// <summary>
        /// set a named parameter of a framebuffer object
        /// <para>Require:</para> <para>GL_VERSION_4_3, GL_ES_VERSION_3_1, GL_ARB_framebuffer_no_attachments</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glFramebufferParameteri(GLenum target, GLenum pname, GLint param);</para>
        /// </summary>
        public static void FramebufferParameteri(uint target, uint pname, int param) {
            GLNative.glFramebufferParameteri(target, pname, param);
        }


        #endregion Reuse commands from ARB_framebuffer_no_attachments

        #region Reuse commands from ARB_internalformat_query2


        #endregion Reuse commands from ARB_internalformat_query2

        #region Reuse commands from ARB_invalidate_subdata

        /// <summary>
        /// invalidate a region of a texture image
        /// <para>Require:</para> <para>GL_VERSION_4_3, GL_ARB_invalidate_subdata</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glInvalidateTexSubImage(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth);</para>
        /// </summary>
        public static void InvalidateTexSubImage(uint texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth) {
            GLNative.glInvalidateTexSubImage(texture, level, xoffset, yoffset, zoffset, width, height, depth);
        }

        /// <summary>
        /// invalidate the entirety a texture image
        /// <para>Require:</para> <para>GL_VERSION_4_3, GL_ARB_invalidate_subdata</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glInvalidateTexImage(GLuint texture, GLint level);</para>
        /// </summary>
        public static void InvalidateTexImage(uint texture, int level) {
            GLNative.glInvalidateTexImage(texture, level);
        }

        /// <summary>
        /// invalidate a region of a buffer object's data store
        /// <para>Require:</para> <para>GL_VERSION_4_3, GL_ARB_invalidate_subdata</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glInvalidateBufferSubData(GLuint buffer, GLintptr offset, GLsizeiptr length);</para>
        /// </summary>
        public static void InvalidateBufferSubData(uint buffer, IntPtr offset, IntPtr length) {
            GLNative.glInvalidateBufferSubData(buffer, offset, length);
        }

        /// <summary>
        /// invalidate the content of a buffer object's data store
        /// <para>Require:</para> <para>GL_VERSION_4_3, GL_ARB_invalidate_subdata</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glInvalidateBufferData(GLuint buffer);</para>
        /// </summary>
        public static void InvalidateBufferData(uint buffer) {
            GLNative.glInvalidateBufferData(buffer);
        }


        #endregion Reuse commands from ARB_invalidate_subdata

        #region Reuse commands from ARB_multi_draw_indirect


        #endregion Reuse commands from ARB_multi_draw_indirect

        #region Reuse commands from ARB_program_interface_query


        #endregion Reuse commands from ARB_program_interface_query

        #region Reuse commands from ARB_shader_storage_buffer_object

        /// <summary>
        /// change an active shader storage block binding
        /// <para>Require:</para> <para>GL_VERSION_4_3, GL_ARB_shader_storage_buffer_object</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glShaderStorageBlockBinding(GLuint program, GLuint storageBlockIndex, GLuint storageBlockBinding);</para>
        /// </summary>
        public static void ShaderStorageBlockBinding(uint program, uint storageBlockIndex, uint storageBlockBinding) {
            GLNative.glShaderStorageBlockBinding(program, storageBlockIndex, storageBlockBinding);
        }


        #endregion Reuse commands from ARB_shader_storage_buffer_object

        #region Reuse commands from ARB_texture_buffer_range

        /// <summary>
        /// attach a range of a buffer object's data store to a buffer texture object
        /// <para>Require:</para> <para>GL_VERSION_4_3, GL_ES_VERSION_3_2, GL_ARB_texture_buffer_range</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glTexBufferRange(GLenum target, GLenum internalformat, GLuint buffer, GLintptr offset, GLsizeiptr size);</para>
        /// </summary>
        public static void TexBufferRange(uint target, uint internalformat, uint buffer, IntPtr offset, IntPtr size) {
            GLNative.glTexBufferRange(target, internalformat, buffer, offset, size);
        }


        #endregion Reuse commands from ARB_texture_buffer_range

        #region Reuse commands from ARB_texture_storage_multisample

        /// <summary>
        /// specify storage for a two-dimensional multisample texture
        /// <para>Require:</para> <para>GL_VERSION_4_3, GL_ES_VERSION_3_1, GL_ARB_texture_storage_multisample</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glTexStorage2DMultisample(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations);</para>
        /// </summary>
        public static void TexStorage2DMultisample(uint target, int samples, uint internalformat, int width, int height, bool fixedsamplelocations) {
            GLNative.glTexStorage2DMultisample(target, samples, internalformat, width, height, fixedsamplelocations);
        }

        /// <summary>
        /// specify storage for a two-dimensional multisample array texture
        /// <para>Require:</para> <para>GL_VERSION_4_3, GL_ES_VERSION_3_2, GL_ARB_texture_storage_multisample</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glTexStorage3DMultisample(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations);</para>
        /// </summary>
        public static void TexStorage3DMultisample(uint target, int samples, uint internalformat, int width, int height, int depth, bool fixedsamplelocations) {
            GLNative.glTexStorage3DMultisample(target, samples, internalformat, width, height, depth, fixedsamplelocations);
        }


        #endregion Reuse commands from ARB_texture_storage_multisample

        #region Reuse commands from ARB_texture_view

        /// <summary>
        /// initialize a texture as a data alias of another texture's data store
        /// <para>Require:</para> <para>GL_VERSION_4_3, GL_ARB_texture_view</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glTextureView(GLuint texture, GLenum target, GLuint origtexture, GLenum internalformat, GLuint minlevel, GLuint numlevels, GLuint minlayer, GLuint numlayers);</para>
        /// </summary>
        public static void TextureView(uint texture, uint target, uint origtexture, uint internalformat, uint minlevel, uint numlevels, uint minlayer, uint numlayers) {
            GLNative.glTextureView(texture, target, origtexture, internalformat, minlevel, numlevels, minlayer, numlayers);
        }


        #endregion Reuse commands from ARB_texture_view

        #region Reuse commands from ARB_vertex_attrib_binding

        /// <summary>
        /// bind a buffer to a vertex buffer bind point
        /// <para>Require:</para> <para>GL_VERSION_4_3, GL_ES_VERSION_3_1, GL_ARB_vertex_attrib_binding</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glBindVertexBuffer(GLuint bindingindex, GLuint buffer, GLintptr offset, GLsizei stride);</para>
        /// </summary>
        public static void BindVertexBuffer(uint bindingindex, uint buffer, IntPtr offset, int stride) {
            GLNative.glBindVertexBuffer(bindingindex, buffer, offset, stride);
        }

        /// <summary>
        /// specify the organization of vertex arrays
        /// <para>Require:</para> <para>GL_VERSION_4_3, GL_ES_VERSION_3_1, GL_ARB_vertex_attrib_binding</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glVertexAttribFormat(GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset);</para>
        /// </summary>
        public static void VertexAttribFormat(uint attribindex, int size, uint type, bool normalized, uint relativeoffset) {
            GLNative.glVertexAttribFormat(attribindex, size, type, normalized, relativeoffset);
        }

        /// <summary>
        /// specify the organization of vertex arrays
        /// <para>Require:</para> <para>GL_VERSION_4_3, GL_ES_VERSION_3_1, GL_ARB_vertex_attrib_binding</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glVertexAttribIFormat(GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset);</para>
        /// </summary>
        public static void VertexAttribIFormat(uint attribindex, int size, uint type, uint relativeoffset) {
            GLNative.glVertexAttribIFormat(attribindex, size, type, relativeoffset);
        }

        /// <summary>
        /// specify the organization of vertex arrays
        /// <para>Require:</para> <para>GL_VERSION_4_3, GL_ARB_vertex_attrib_binding</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glVertexAttribLFormat(GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset);</para>
        /// </summary>
        public static void VertexAttribLFormat(uint attribindex, int size, uint type, uint relativeoffset) {
            GLNative.glVertexAttribLFormat(attribindex, size, type, relativeoffset);
        }

        /// <summary>
        /// associate a vertex attribute and a vertex buffer binding for a vertex array object
        /// <para>Require:</para> <para>GL_VERSION_4_3, GL_ES_VERSION_3_1, GL_ARB_vertex_attrib_binding</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glVertexAttribBinding(GLuint attribindex, GLuint bindingindex);</para>
        /// </summary>
        public static void VertexAttribBinding(uint attribindex, uint bindingindex) {
            GLNative.glVertexAttribBinding(attribindex, bindingindex);
        }

        /// <summary>
        /// <para>
        /// modify the rate at which generic vertex attributes
        /// advance
        /// </para>
        /// <para>Require:</para> <para>GL_VERSION_4_3, GL_ES_VERSION_3_1, GL_ARB_vertex_attrib_binding</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glVertexBindingDivisor(GLuint bindingindex, GLuint divisor);</para>
        /// </summary>
        public static void VertexBindingDivisor(uint bindingindex, uint divisor) {
            GLNative.glVertexBindingDivisor(bindingindex, divisor);
        }


        #endregion Reuse commands from ARB_vertex_attrib_binding

        #region Reuse commands from KHR_debug (includes ARB_debug_output commands promoted to KHR without suffixes)

        /// <summary>
        /// pop the active debug group
        /// <para>Require:</para> <para>GL_VERSION_4_3, GL_ES_VERSION_3_2, GL_KHR_debug</para>
        /// Supported: <para>gl, glcore, gles1, gles2</para>
        /// Original: <para>void glPopDebugGroup();</para>
        /// </summary>
        public static void PopDebugGroup() {
            GLNative.glPopDebugGroup();
        }


        #endregion Reuse commands from KHR_debug (includes ARB_debug_output commands promoted to KHR without suffixes)

        #endregion GL_VERSION_4_3

        #region GL_VERSION_4_4


        #region Reuse GL_ARB_buffer_storage


        #endregion Reuse GL_ARB_buffer_storage

        #region Reuse GL_ARB_clear_texture


        #endregion Reuse GL_ARB_clear_texture

        #region Reuse GL_ARB_multi_bind (none)


        #endregion Reuse GL_ARB_multi_bind (none)

        #endregion GL_VERSION_4_4

        #region GL_VERSION_4_5


        #region Reuse GL_ARB_clip_control

        /// <summary>
        /// control clip coordinate to window coordinate behavior
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_clip_control</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glClipControl(GLenum origin, GLenum depth);</para>
        /// </summary>
        public static void ClipControl(uint origin, uint depth) {
            GLNative.glClipControl(origin, depth);
        }


        #endregion Reuse GL_ARB_clip_control

        #region Reuse GL_ARB_direct_state_access

        /// <summary>
        /// bind a buffer object to a transform feedback buffer object
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glTransformFeedbackBufferBase(GLuint xfb, GLuint index, GLuint buffer);</para>
        /// </summary>
        public static void TransformFeedbackBufferBase(uint xfb, uint index, uint buffer) {
            GLNative.glTransformFeedbackBufferBase(xfb, index, buffer);
        }

        /// <summary>
        /// bind a range within a buffer object to a transform feedback buffer object
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glTransformFeedbackBufferRange(GLuint xfb, GLuint index, GLuint buffer, GLintptr offset, GLsizei size);</para>
        /// </summary>
        public static void TransformFeedbackBufferRange(uint xfb, uint index, uint buffer, IntPtr offset, int size) {
            GLNative.glTransformFeedbackBufferRange(xfb, index, buffer, offset, size);
        }

        /// <summary>
        /// copy all or part of the data store of a buffer object to the data store of another buffer object
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glCopyNamedBufferSubData(GLuint readBuffer, GLuint writeBuffer, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size);</para>
        /// </summary>
        public static void CopyNamedBufferSubData(uint readBuffer, uint writeBuffer, IntPtr readOffset, IntPtr writeOffset, IntPtr size) {
            GLNative.glCopyNamedBufferSubData(readBuffer, writeBuffer, readOffset, writeOffset, size);
        }

        /// <summary>
        /// release the mapping of a buffer object's data store into the client's address space
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>GLboolean glUnmapNamedBuffer(GLuint buffer);</para>
        /// </summary>
        public static bool UnmapNamedBuffer(uint buffer) {
            return GLNative.glUnmapNamedBuffer(buffer);
        }

        /// <summary>
        /// indicate modifications to a range of a mapped buffer
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glFlushMappedNamedBufferRange(GLuint buffer, GLintptr offset, GLsizeiptr length);</para>
        /// </summary>
        public static void FlushMappedNamedBufferRange(uint buffer, IntPtr offset, IntPtr length) {
            GLNative.glFlushMappedNamedBufferRange(buffer, offset, length);
        }

        /// <summary>
        /// attach a renderbuffer as a logical buffer of a framebuffer object
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glNamedFramebufferRenderbuffer(GLuint framebuffer, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer);</para>
        /// </summary>
        public static void NamedFramebufferRenderbuffer(uint framebuffer, uint attachment, uint renderbuffertarget, uint renderbuffer) {
            GLNative.glNamedFramebufferRenderbuffer(framebuffer, attachment, renderbuffertarget, renderbuffer);
        }

        /// <summary>
        /// set a named parameter of a framebuffer object
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glNamedFramebufferParameteri(GLuint framebuffer, GLenum pname, GLint param);</para>
        /// </summary>
        public static void NamedFramebufferParameteri(uint framebuffer, uint pname, int param) {
            GLNative.glNamedFramebufferParameteri(framebuffer, pname, param);
        }

        /// <summary>
        /// attach a level of a texture object as a logical buffer of a framebuffer object
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glNamedFramebufferTexture(GLuint framebuffer, GLenum attachment, GLuint texture, GLint level);</para>
        /// </summary>
        public static void NamedFramebufferTexture(uint framebuffer, uint attachment, uint texture, int level) {
            GLNative.glNamedFramebufferTexture(framebuffer, attachment, texture, level);
        }

        /// <summary>
        /// attach a single layer of a texture object as a logical buffer of a framebuffer object
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glNamedFramebufferTextureLayer(GLuint framebuffer, GLenum attachment, GLuint texture, GLint level, GLint layer);</para>
        /// </summary>
        public static void NamedFramebufferTextureLayer(uint framebuffer, uint attachment, uint texture, int level, int layer) {
            GLNative.glNamedFramebufferTextureLayer(framebuffer, attachment, texture, level, layer);
        }

        /// <summary>
        /// specify which color buffers are to be drawn into
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glNamedFramebufferDrawBuffer(GLuint framebuffer, GLenum buf);</para>
        /// </summary>
        public static void NamedFramebufferDrawBuffer(uint framebuffer, uint buf) {
            GLNative.glNamedFramebufferDrawBuffer(framebuffer, buf);
        }

        /// <summary>
        /// select a color buffer source for pixels
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glNamedFramebufferReadBuffer(GLuint framebuffer, GLenum mode);</para>
        /// </summary>
        public static void NamedFramebufferReadBuffer(uint framebuffer, uint mode) {
            GLNative.glNamedFramebufferReadBuffer(framebuffer, mode);
        }

        /// <summary>
        /// clear individual buffers of a framebuffer
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glClearNamedFramebufferfi(GLuint framebuffer, GLenum buffer, GLint drawbuffer, GLfloat depth, GLint stencil);</para>
        /// </summary>
        public static void ClearNamedFramebufferfi(uint framebuffer, uint buffer, int drawbuffer, float depth, int stencil) {
            GLNative.glClearNamedFramebufferfi(framebuffer, buffer, drawbuffer, depth, stencil);
        }

        /// <summary>
        /// copy a block of pixels from one framebuffer object to another
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glBlitNamedFramebuffer(GLuint readFramebuffer, GLuint drawFramebuffer, GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter);</para>
        /// </summary>
        public static void BlitNamedFramebuffer(uint readFramebuffer, uint drawFramebuffer, int srcX0, int srcY0, int srcX1, int srcY1, int dstX0, int dstY0, int dstX1, int dstY1, uint mask, uint filter) {
            GLNative.glBlitNamedFramebuffer(readFramebuffer, drawFramebuffer, srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
        }

        /// <summary>
        /// check the completeness status of a framebuffer
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>GLenum glCheckNamedFramebufferStatus(GLuint framebuffer, GLenum target);</para>
        /// </summary>
        public static uint CheckNamedFramebufferStatus(uint framebuffer, uint target) {
            return GLNative.glCheckNamedFramebufferStatus(framebuffer, target);
        }

        /// <summary>
        /// <para>
        /// establish data storage, format and dimensions of a
        /// renderbuffer object's image
        /// </para>
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glNamedRenderbufferStorage(GLuint renderbuffer, GLenum internalformat, GLsizei width, GLsizei height);</para>
        /// </summary>
        public static void NamedRenderbufferStorage(uint renderbuffer, uint internalformat, int width, int height) {
            GLNative.glNamedRenderbufferStorage(renderbuffer, internalformat, width, height);
        }

        /// <summary>
        /// <para>
        /// establish data storage, format, dimensions and sample count of
        /// a renderbuffer object's image
        /// </para>
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glNamedRenderbufferStorageMultisample(GLuint renderbuffer, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height);</para>
        /// </summary>
        public static void NamedRenderbufferStorageMultisample(uint renderbuffer, int samples, uint internalformat, int width, int height) {
            GLNative.glNamedRenderbufferStorageMultisample(renderbuffer, samples, internalformat, width, height);
        }

        /// <summary>
        /// attach a buffer object's data store to a buffer texture object
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glTextureBuffer(GLuint texture, GLenum internalformat, GLuint buffer);</para>
        /// </summary>
        public static void TextureBuffer(uint texture, uint internalformat, uint buffer) {
            GLNative.glTextureBuffer(texture, internalformat, buffer);
        }

        /// <summary>
        /// attach a range of a buffer object's data store to a buffer texture object
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glTextureBufferRange(GLuint texture, GLenum internalformat, GLuint buffer, GLintptr offset, GLsizei size);</para>
        /// </summary>
        public static void TextureBufferRange(uint texture, uint internalformat, uint buffer, IntPtr offset, int size) {
            GLNative.glTextureBufferRange(texture, internalformat, buffer, offset, size);
        }

        /// <summary>
        /// simultaneously specify storage for all levels of a one-dimensional texture
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glTextureStorage1D(GLuint texture, GLsizei levels, GLenum internalformat, GLsizei width);</para>
        /// </summary>
        public static void TextureStorage1D(uint texture, int levels, uint internalformat, int width) {
            GLNative.glTextureStorage1D(texture, levels, internalformat, width);
        }

        /// <summary>
        /// simultaneously specify storage for all levels of a two-dimensional or one-dimensional array texture
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glTextureStorage2D(GLuint texture, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height);</para>
        /// </summary>
        public static void TextureStorage2D(uint texture, int levels, uint internalformat, int width, int height) {
            GLNative.glTextureStorage2D(texture, levels, internalformat, width, height);
        }

        /// <summary>
        /// simultaneously specify storage for all levels of a three-dimensional, two-dimensional array or cube-map array texture
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glTextureStorage3D(GLuint texture, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth);</para>
        /// </summary>
        public static void TextureStorage3D(uint texture, int levels, uint internalformat, int width, int height, int depth) {
            GLNative.glTextureStorage3D(texture, levels, internalformat, width, height, depth);
        }

        /// <summary>
        /// specify storage for a two-dimensional multisample texture
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glTextureStorage2DMultisample(GLuint texture, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations);</para>
        /// </summary>
        public static void TextureStorage2DMultisample(uint texture, int samples, uint internalformat, int width, int height, bool fixedsamplelocations) {
            GLNative.glTextureStorage2DMultisample(texture, samples, internalformat, width, height, fixedsamplelocations);
        }

        /// <summary>
        /// specify storage for a two-dimensional multisample array texture
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glTextureStorage3DMultisample(GLuint texture, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations);</para>
        /// </summary>
        public static void TextureStorage3DMultisample(uint texture, int samples, uint internalformat, int width, int height, int depth, bool fixedsamplelocations) {
            GLNative.glTextureStorage3DMultisample(texture, samples, internalformat, width, height, depth, fixedsamplelocations);
        }

        /// <summary>
        /// copy a one-dimensional texture subimage
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glCopyTextureSubImage1D(GLuint texture, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width);</para>
        /// </summary>
        public static void CopyTextureSubImage1D(uint texture, int level, int xoffset, int x, int y, int width) {
            GLNative.glCopyTextureSubImage1D(texture, level, xoffset, x, y, width);
        }

        /// <summary>
        /// copy a two-dimensional texture subimage
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glCopyTextureSubImage2D(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height);</para>
        /// </summary>
        public static void CopyTextureSubImage2D(uint texture, int level, int xoffset, int yoffset, int x, int y, int width, int height) {
            GLNative.glCopyTextureSubImage2D(texture, level, xoffset, yoffset, x, y, width, height);
        }

        /// <summary>
        /// copy a three-dimensional texture subimage
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glCopyTextureSubImage3D(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height);</para>
        /// </summary>
        public static void CopyTextureSubImage3D(uint texture, int level, int xoffset, int yoffset, int zoffset, int x, int y, int width, int height) {
            GLNative.glCopyTextureSubImage3D(texture, level, xoffset, yoffset, zoffset, x, y, width, height);
        }

        /// <summary>
        /// set texture parameters
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glTextureParameterf(GLuint texture, GLenum pname, GLfloat param);</para>
        /// </summary>
        public static void TextureParameterf(uint texture, uint pname, float param) {
            GLNative.glTextureParameterf(texture, pname, param);
        }

        /// <summary>
        /// set texture parameters
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glTextureParameteri(GLuint texture, GLenum pname, GLint param);</para>
        /// </summary>
        public static void TextureParameteri(uint texture, uint pname, int param) {
            GLNative.glTextureParameteri(texture, pname, param);
        }

        /// <summary>
        /// generate mipmaps for a specified texture object
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGenerateTextureMipmap(GLuint texture);</para>
        /// </summary>
        public static void GenerateTextureMipmap(uint texture) {
            GLNative.glGenerateTextureMipmap(texture);
        }

        /// <summary>
        /// bind an existing texture object to the specified texture unit
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glBindTextureUnit(GLuint unit, GLuint texture);</para>
        /// </summary>
        public static void BindTextureUnit(uint unit, uint texture) {
            GLNative.glBindTextureUnit(unit, texture);
        }

        /// <summary>
        /// <para>
        /// Enable or disable a generic vertex attribute
        /// array
        /// </para>
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glDisableVertexArrayAttrib(GLuint vaobj, GLuint index);</para>
        /// </summary>
        public static void DisableVertexArrayAttrib(uint vaobj, uint index) {
            GLNative.glDisableVertexArrayAttrib(vaobj, index);
        }

        /// <summary>
        /// <para>
        /// Enable or disable a generic vertex attribute
        /// array
        /// </para>
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glEnableVertexArrayAttrib(GLuint vaobj, GLuint index);</para>
        /// </summary>
        public static void EnableVertexArrayAttrib(uint vaobj, uint index) {
            GLNative.glEnableVertexArrayAttrib(vaobj, index);
        }

        /// <summary>
        /// configures element array buffer binding of a vertex array object
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glVertexArrayElementBuffer(GLuint vaobj, GLuint buffer);</para>
        /// </summary>
        public static void VertexArrayElementBuffer(uint vaobj, uint buffer) {
            GLNative.glVertexArrayElementBuffer(vaobj, buffer);
        }

        /// <summary>
        /// bind a buffer to a vertex buffer bind point
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glVertexArrayVertexBuffer(GLuint vaobj, GLuint bindingindex, GLuint buffer, GLintptr offset, GLsizei stride);</para>
        /// </summary>
        public static void VertexArrayVertexBuffer(uint vaobj, uint bindingindex, uint buffer, IntPtr offset, int stride) {
            GLNative.glVertexArrayVertexBuffer(vaobj, bindingindex, buffer, offset, stride);
        }

        /// <summary>
        /// associate a vertex attribute and a vertex buffer binding for a vertex array object
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glVertexArrayAttribBinding(GLuint vaobj, GLuint attribindex, GLuint bindingindex);</para>
        /// </summary>
        public static void VertexArrayAttribBinding(uint vaobj, uint attribindex, uint bindingindex) {
            GLNative.glVertexArrayAttribBinding(vaobj, attribindex, bindingindex);
        }

        /// <summary>
        /// specify the organization of vertex arrays
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glVertexArrayAttribFormat(GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset);</para>
        /// </summary>
        public static void VertexArrayAttribFormat(uint vaobj, uint attribindex, int size, uint type, bool normalized, uint relativeoffset) {
            GLNative.glVertexArrayAttribFormat(vaobj, attribindex, size, type, normalized, relativeoffset);
        }

        /// <summary>
        /// specify the organization of vertex arrays
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glVertexArrayAttribIFormat(GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset);</para>
        /// </summary>
        public static void VertexArrayAttribIFormat(uint vaobj, uint attribindex, int size, uint type, uint relativeoffset) {
            GLNative.glVertexArrayAttribIFormat(vaobj, attribindex, size, type, relativeoffset);
        }

        /// <summary>
        /// specify the organization of vertex arrays
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glVertexArrayAttribLFormat(GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset);</para>
        /// </summary>
        public static void VertexArrayAttribLFormat(uint vaobj, uint attribindex, int size, uint type, uint relativeoffset) {
            GLNative.glVertexArrayAttribLFormat(vaobj, attribindex, size, type, relativeoffset);
        }

        /// <summary>
        /// <para>
        /// modify the rate at which generic vertex attributes
        /// advance
        /// </para>
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glVertexArrayBindingDivisor(GLuint vaobj, GLuint bindingindex, GLuint divisor);</para>
        /// </summary>
        public static void VertexArrayBindingDivisor(uint vaobj, uint bindingindex, uint divisor) {
            GLNative.glVertexArrayBindingDivisor(vaobj, bindingindex, divisor);
        }

        /// <summary>
        /// return parameters of a query object
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetQueryBufferObjecti64v(GLuint id, GLuint buffer, GLenum pname, GLintptr offset);</para>
        /// </summary>
        public static void GetQueryBufferObjecti64v(uint id, uint buffer, uint pname, IntPtr offset) {
            GLNative.glGetQueryBufferObjecti64v(id, buffer, pname, offset);
        }

        /// <summary>
        /// return parameters of a query object
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetQueryBufferObjectiv(GLuint id, GLuint buffer, GLenum pname, GLintptr offset);</para>
        /// </summary>
        public static void GetQueryBufferObjectiv(uint id, uint buffer, uint pname, IntPtr offset) {
            GLNative.glGetQueryBufferObjectiv(id, buffer, pname, offset);
        }

        /// <summary>
        /// return parameters of a query object
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetQueryBufferObjectui64v(GLuint id, GLuint buffer, GLenum pname, GLintptr offset);</para>
        /// </summary>
        public static void GetQueryBufferObjectui64v(uint id, uint buffer, uint pname, IntPtr offset) {
            GLNative.glGetQueryBufferObjectui64v(id, buffer, pname, offset);
        }

        /// <summary>
        /// return parameters of a query object
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetQueryBufferObjectuiv(GLuint id, GLuint buffer, GLenum pname, GLintptr offset);</para>
        /// </summary>
        public static void GetQueryBufferObjectuiv(uint id, uint buffer, uint pname, IntPtr offset) {
            GLNative.glGetQueryBufferObjectuiv(id, buffer, pname, offset);
        }


        #endregion Reuse GL_ARB_direct_state_access

        #region Reuse GL_ARB_ES3_1_compatibility

        /// <summary>
        /// defines a barrier ordering memory transactions
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ES_VERSION_3_1, GL_ARB_ES3_1_compatibility</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glMemoryBarrierByRegion(GLbitfield barriers);</para>
        /// </summary>
        public static void MemoryBarrierByRegion(uint barriers) {
            GLNative.glMemoryBarrierByRegion(barriers);
        }


        #endregion Reuse GL_ARB_ES3_1_compatibility

        #region Reuse GL_ARB_get_texture_sub_image


        #endregion Reuse GL_ARB_get_texture_sub_image

        #region Reuse GL_ARB_robustness

        /// <summary>
        /// check if the rendering context has not been lost due to software or hardware issues
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ES_VERSION_3_2, GL_SC_VERSION_2_0, GL_KHR_robustness</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>GLenum glGetGraphicsResetStatus();</para>
        /// </summary>
        public static uint GetGraphicsResetStatus() {
            return GLNative.glGetGraphicsResetStatus();
        }


        #endregion Reuse GL_ARB_robustness

        #region Reuse GL_ARB_robustness


        #endregion Reuse GL_ARB_robustness

        #region Reuse GL_ARB_texture_barrier

        /// <summary>
        /// controls the ordering of reads and writes to rendered fragments across drawing commands
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_texture_barrier</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glTextureBarrier();</para>
        /// </summary>
        public static void TextureBarrier() {
            GLNative.glTextureBarrier();
        }


        #endregion Reuse GL_ARB_texture_barrier

        #endregion GL_VERSION_4_5

        #region GL_VERSION_4_6


        #region Reuse GL_ARB_gl_spirv


        #endregion Reuse GL_ARB_gl_spirv

        #region Reuse GL_ARB_indirect_parameters


        #endregion Reuse GL_ARB_indirect_parameters

        #region Reuse GL_ARB_polygon_offset_clamp

        /// <summary>
        /// <para>Require:</para> <para>GL_VERSION_4_6, GL_ARB_polygon_offset_clamp</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glPolygonOffsetClamp(GLfloat factor, GLfloat units, GLfloat clamp);</para>
        /// </summary>
        public static void PolygonOffsetClamp(float factor, float units, float clamp) {
            GLNative.glPolygonOffsetClamp(factor, units, clamp);
        }


        #endregion Reuse GL_ARB_polygon_offset_clamp

        #endregion GL_VERSION_4_6

        #region GL_3DFX_tbuffer

        /// <summary>
        /// <para>Require:</para> <para>GL_3DFX_tbuffer</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glTbufferMask3DFX(GLuint mask);</para>
        /// </summary>
        public static void TbufferMask3DFX(uint mask) {
            GLNative.glTbufferMask3DFX(mask);
        }


        #endregion GL_3DFX_tbuffer

        #region GL_AMD_debug_output


        #endregion GL_AMD_debug_output

        #region GL_AMD_draw_buffers_blend

        /// <summary>
        /// <para>Require:</para> <para>GL_AMD_draw_buffers_blend</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glBlendFuncIndexedAMD(GLuint buf, GLenum src, GLenum dst);</para>
        /// </summary>
        public static void BlendFuncIndexedAMD(uint buf, uint src, uint dst) {
            GLNative.glBlendFuncIndexedAMD(buf, src, dst);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_AMD_draw_buffers_blend</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glBlendFuncSeparateIndexedAMD(GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha);</para>
        /// </summary>
        public static void BlendFuncSeparateIndexedAMD(uint buf, uint srcRGB, uint dstRGB, uint srcAlpha, uint dstAlpha) {
            GLNative.glBlendFuncSeparateIndexedAMD(buf, srcRGB, dstRGB, srcAlpha, dstAlpha);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_AMD_draw_buffers_blend</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glBlendEquationIndexedAMD(GLuint buf, GLenum mode);</para>
        /// </summary>
        public static void BlendEquationIndexedAMD(uint buf, uint mode) {
            GLNative.glBlendEquationIndexedAMD(buf, mode);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_AMD_draw_buffers_blend</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glBlendEquationSeparateIndexedAMD(GLuint buf, GLenum modeRGB, GLenum modeAlpha);</para>
        /// </summary>
        public static void BlendEquationSeparateIndexedAMD(uint buf, uint modeRGB, uint modeAlpha) {
            GLNative.glBlendEquationSeparateIndexedAMD(buf, modeRGB, modeAlpha);
        }


        #endregion GL_AMD_draw_buffers_blend

        #region GL_AMD_framebuffer_multisample_advanced

        /// <summary>
        /// <para>Require:</para> <para>GL_AMD_framebuffer_multisample_advanced</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glRenderbufferStorageMultisampleAdvancedAMD(GLenum target, GLsizei samples, GLsizei storageSamples, GLenum internalformat, GLsizei width, GLsizei height);</para>
        /// </summary>
        public static void RenderbufferStorageMultisampleAdvancedAMD(uint target, int samples, int storageSamples, uint internalformat, int width, int height) {
            GLNative.glRenderbufferStorageMultisampleAdvancedAMD(target, samples, storageSamples, internalformat, width, height);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_AMD_framebuffer_multisample_advanced</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glNamedRenderbufferStorageMultisampleAdvancedAMD(GLuint renderbuffer, GLsizei samples, GLsizei storageSamples, GLenum internalformat, GLsizei width, GLsizei height);</para>
        /// </summary>
        public static void NamedRenderbufferStorageMultisampleAdvancedAMD(uint renderbuffer, int samples, int storageSamples, uint internalformat, int width, int height) {
            GLNative.glNamedRenderbufferStorageMultisampleAdvancedAMD(renderbuffer, samples, storageSamples, internalformat, width, height);
        }


        #endregion GL_AMD_framebuffer_multisample_advanced

        #region GL_AMD_framebuffer_sample_positions


        #endregion GL_AMD_framebuffer_sample_positions

        #region GL_AMD_gpu_shader_int64

        /// <summary>
        /// <para>Require:</para> <para>GL_AMD_gpu_shader_int64, GL_NV_gpu_shader5</para>
        /// Supported: <para>gl, gl, glcore, gles2</para>
        /// Original: <para>void glUniform1i64NV(GLint location, GLint64EXT x);</para>
        /// </summary>
        public static void Uniform1i64NV(int location, Int64 x) {
            GLNative.glUniform1i64NV(location, x);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_AMD_gpu_shader_int64, GL_NV_gpu_shader5</para>
        /// Supported: <para>gl, gl, glcore, gles2</para>
        /// Original: <para>void glUniform2i64NV(GLint location, GLint64EXT x, GLint64EXT y);</para>
        /// </summary>
        public static void Uniform2i64NV(int location, Int64 x, Int64 y) {
            GLNative.glUniform2i64NV(location, x, y);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_AMD_gpu_shader_int64, GL_NV_gpu_shader5</para>
        /// Supported: <para>gl, gl, glcore, gles2</para>
        /// Original: <para>void glUniform3i64NV(GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z);</para>
        /// </summary>
        public static void Uniform3i64NV(int location, Int64 x, Int64 y, Int64 z) {
            GLNative.glUniform3i64NV(location, x, y, z);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_AMD_gpu_shader_int64, GL_NV_gpu_shader5</para>
        /// Supported: <para>gl, gl, glcore, gles2</para>
        /// Original: <para>void glUniform4i64NV(GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z, GLint64EXT w);</para>
        /// </summary>
        public static void Uniform4i64NV(int location, Int64 x, Int64 y, Int64 z, Int64 w) {
            GLNative.glUniform4i64NV(location, x, y, z, w);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_AMD_gpu_shader_int64, GL_NV_gpu_shader5</para>
        /// Supported: <para>gl, gl, glcore, gles2</para>
        /// Original: <para>void glUniform1ui64NV(GLint location, GLuint64EXT x);</para>
        /// </summary>
        public static void Uniform1ui64NV(int location, UInt64 x) {
            GLNative.glUniform1ui64NV(location, x);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_AMD_gpu_shader_int64, GL_NV_gpu_shader5</para>
        /// Supported: <para>gl, gl, glcore, gles2</para>
        /// Original: <para>void glUniform2ui64NV(GLint location, GLuint64EXT x, GLuint64EXT y);</para>
        /// </summary>
        public static void Uniform2ui64NV(int location, UInt64 x, UInt64 y) {
            GLNative.glUniform2ui64NV(location, x, y);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_AMD_gpu_shader_int64, GL_NV_gpu_shader5</para>
        /// Supported: <para>gl, gl, glcore, gles2</para>
        /// Original: <para>void glUniform3ui64NV(GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z);</para>
        /// </summary>
        public static void Uniform3ui64NV(int location, UInt64 x, UInt64 y, UInt64 z) {
            GLNative.glUniform3ui64NV(location, x, y, z);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_AMD_gpu_shader_int64, GL_NV_gpu_shader5</para>
        /// Supported: <para>gl, gl, glcore, gles2</para>
        /// Original: <para>void glUniform4ui64NV(GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z, GLuint64EXT w);</para>
        /// </summary>
        public static void Uniform4ui64NV(int location, UInt64 x, UInt64 y, UInt64 z, UInt64 w) {
            GLNative.glUniform4ui64NV(location, x, y, z, w);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_AMD_gpu_shader_int64, GL_NV_gpu_shader5</para>
        /// Supported: <para>gl, gl, glcore, gles2</para>
        /// Original: <para>void glProgramUniform1i64NV(GLuint program, GLint location, GLint64EXT x);</para>
        /// </summary>
        public static void ProgramUniform1i64NV(uint program, int location, Int64 x) {
            GLNative.glProgramUniform1i64NV(program, location, x);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_AMD_gpu_shader_int64, GL_NV_gpu_shader5</para>
        /// Supported: <para>gl, gl, glcore, gles2</para>
        /// Original: <para>void glProgramUniform2i64NV(GLuint program, GLint location, GLint64EXT x, GLint64EXT y);</para>
        /// </summary>
        public static void ProgramUniform2i64NV(uint program, int location, Int64 x, Int64 y) {
            GLNative.glProgramUniform2i64NV(program, location, x, y);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_AMD_gpu_shader_int64, GL_NV_gpu_shader5</para>
        /// Supported: <para>gl, gl, glcore, gles2</para>
        /// Original: <para>void glProgramUniform3i64NV(GLuint program, GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z);</para>
        /// </summary>
        public static void ProgramUniform3i64NV(uint program, int location, Int64 x, Int64 y, Int64 z) {
            GLNative.glProgramUniform3i64NV(program, location, x, y, z);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_AMD_gpu_shader_int64, GL_NV_gpu_shader5</para>
        /// Supported: <para>gl, gl, glcore, gles2</para>
        /// Original: <para>void glProgramUniform4i64NV(GLuint program, GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z, GLint64EXT w);</para>
        /// </summary>
        public static void ProgramUniform4i64NV(uint program, int location, Int64 x, Int64 y, Int64 z, Int64 w) {
            GLNative.glProgramUniform4i64NV(program, location, x, y, z, w);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_AMD_gpu_shader_int64, GL_NV_gpu_shader5</para>
        /// Supported: <para>gl, gl, glcore, gles2</para>
        /// Original: <para>void glProgramUniform1ui64NV(GLuint program, GLint location, GLuint64EXT x);</para>
        /// </summary>
        public static void ProgramUniform1ui64NV(uint program, int location, UInt64 x) {
            GLNative.glProgramUniform1ui64NV(program, location, x);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_AMD_gpu_shader_int64, GL_NV_gpu_shader5</para>
        /// Supported: <para>gl, gl, glcore, gles2</para>
        /// Original: <para>void glProgramUniform2ui64NV(GLuint program, GLint location, GLuint64EXT x, GLuint64EXT y);</para>
        /// </summary>
        public static void ProgramUniform2ui64NV(uint program, int location, UInt64 x, UInt64 y) {
            GLNative.glProgramUniform2ui64NV(program, location, x, y);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_AMD_gpu_shader_int64, GL_NV_gpu_shader5</para>
        /// Supported: <para>gl, gl, glcore, gles2</para>
        /// Original: <para>void glProgramUniform3ui64NV(GLuint program, GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z);</para>
        /// </summary>
        public static void ProgramUniform3ui64NV(uint program, int location, UInt64 x, UInt64 y, UInt64 z) {
            GLNative.glProgramUniform3ui64NV(program, location, x, y, z);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_AMD_gpu_shader_int64, GL_NV_gpu_shader5</para>
        /// Supported: <para>gl, gl, glcore, gles2</para>
        /// Original: <para>void glProgramUniform4ui64NV(GLuint program, GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z, GLuint64EXT w);</para>
        /// </summary>
        public static void ProgramUniform4ui64NV(uint program, int location, UInt64 x, UInt64 y, UInt64 z, UInt64 w) {
            GLNative.glProgramUniform4ui64NV(program, location, x, y, z, w);
        }


        #endregion GL_AMD_gpu_shader_int64

        #region GL_AMD_interleaved_elements

        /// <summary>
        /// <para>Require:</para> <para>GL_AMD_interleaved_elements</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexAttribParameteriAMD(GLuint index, GLenum pname, GLint param);</para>
        /// </summary>
        public static void VertexAttribParameteriAMD(uint index, uint pname, int param) {
            GLNative.glVertexAttribParameteriAMD(index, pname, param);
        }


        #endregion GL_AMD_interleaved_elements

        #region GL_AMD_multi_draw_indirect


        #endregion GL_AMD_multi_draw_indirect

        #region GL_AMD_name_gen_delete

        /// <summary>
        /// <para>Require:</para> <para>GL_AMD_name_gen_delete</para>
        /// Supported: <para>gl</para>
        /// Original: <para>GLboolean glIsNameAMD(GLenum identifier, GLuint name);</para>
        /// </summary>
        public static bool IsNameAMD(uint identifier, uint name) {
            return GLNative.glIsNameAMD(identifier, name);
        }


        #endregion GL_AMD_name_gen_delete

        #region GL_AMD_occlusion_query_event

        /// <summary>
        /// <para>Require:</para> <para>GL_AMD_occlusion_query_event</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glQueryObjectParameteruiAMD(GLenum target, GLuint id, GLenum pname, GLuint param);</para>
        /// </summary>
        public static void QueryObjectParameteruiAMD(uint target, uint id, uint pname, uint param) {
            GLNative.glQueryObjectParameteruiAMD(target, id, pname, param);
        }


        #endregion GL_AMD_occlusion_query_event

        #region GL_AMD_performance_monitor

        /// <summary>
        /// <para>Require:</para> <para>GL_AMD_performance_monitor</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glBeginPerfMonitorAMD(GLuint monitor);</para>
        /// </summary>
        public static void BeginPerfMonitorAMD(uint monitor) {
            GLNative.glBeginPerfMonitorAMD(monitor);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_AMD_performance_monitor</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glEndPerfMonitorAMD(GLuint monitor);</para>
        /// </summary>
        public static void EndPerfMonitorAMD(uint monitor) {
            GLNative.glEndPerfMonitorAMD(monitor);
        }


        #endregion GL_AMD_performance_monitor

        #region GL_AMD_sample_positions


        #endregion GL_AMD_sample_positions

        #region GL_AMD_sparse_texture

        /// <summary>
        /// <para>Require:</para> <para>GL_AMD_sparse_texture</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glTexStorageSparseAMD(GLenum target, GLenum internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLsizei layers, GLbitfield flags);</para>
        /// </summary>
        public static void TexStorageSparseAMD(uint target, uint internalFormat, int width, int height, int depth, int layers, uint flags) {
            GLNative.glTexStorageSparseAMD(target, internalFormat, width, height, depth, layers, flags);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_AMD_sparse_texture</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glTextureStorageSparseAMD(GLuint texture, GLenum target, GLenum internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLsizei layers, GLbitfield flags);</para>
        /// </summary>
        public static void TextureStorageSparseAMD(uint texture, uint target, uint internalFormat, int width, int height, int depth, int layers, uint flags) {
            GLNative.glTextureStorageSparseAMD(texture, target, internalFormat, width, height, depth, layers, flags);
        }


        #endregion GL_AMD_sparse_texture

        #region GL_AMD_stencil_operation_extended

        /// <summary>
        /// <para>Require:</para> <para>GL_AMD_stencil_operation_extended</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glStencilOpValueAMD(GLenum face, GLuint value);</para>
        /// </summary>
        public static void StencilOpValueAMD(uint face, uint value) {
            GLNative.glStencilOpValueAMD(face, value);
        }


        #endregion GL_AMD_stencil_operation_extended

        #region GL_AMD_vertex_shader_tessellator

        /// <summary>
        /// <para>Require:</para> <para>GL_AMD_vertex_shader_tessellator</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glTessellationFactorAMD(GLfloat factor);</para>
        /// </summary>
        public static void TessellationFactorAMD(float factor) {
            GLNative.glTessellationFactorAMD(factor);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_AMD_vertex_shader_tessellator</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glTessellationModeAMD(GLenum mode);</para>
        /// </summary>
        public static void TessellationModeAMD(uint mode) {
            GLNative.glTessellationModeAMD(mode);
        }


        #endregion GL_AMD_vertex_shader_tessellator

        #region GL_APPLE_element_array

        /// <summary>
        /// <para>Require:</para> <para>GL_APPLE_element_array</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glDrawElementArrayAPPLE(GLenum mode, GLint first, GLsizei count);</para>
        /// </summary>
        public static void DrawElementArrayAPPLE(uint mode, int first, int count) {
            GLNative.glDrawElementArrayAPPLE(mode, first, count);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_APPLE_element_array</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glDrawRangeElementArrayAPPLE(GLenum mode, GLuint start, GLuint end, GLint first, GLsizei count);</para>
        /// </summary>
        public static void DrawRangeElementArrayAPPLE(uint mode, uint start, uint end, int first, int count) {
            GLNative.glDrawRangeElementArrayAPPLE(mode, start, end, first, count);
        }


        #endregion GL_APPLE_element_array

        #region GL_APPLE_fence

        /// <summary>
        /// <para>Require:</para> <para>GL_APPLE_fence</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glSetFenceAPPLE(GLuint fence);</para>
        /// </summary>
        public static void SetFenceAPPLE(uint fence) {
            GLNative.glSetFenceAPPLE(fence);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_APPLE_fence</para>
        /// Supported: <para>gl</para>
        /// Original: <para>GLboolean glIsFenceAPPLE(GLuint fence);</para>
        /// </summary>
        public static bool IsFenceAPPLE(uint fence) {
            return GLNative.glIsFenceAPPLE(fence);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_APPLE_fence</para>
        /// Supported: <para>gl</para>
        /// Original: <para>GLboolean glTestFenceAPPLE(GLuint fence);</para>
        /// </summary>
        public static bool TestFenceAPPLE(uint fence) {
            return GLNative.glTestFenceAPPLE(fence);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_APPLE_fence</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glFinishFenceAPPLE(GLuint fence);</para>
        /// </summary>
        public static void FinishFenceAPPLE(uint fence) {
            GLNative.glFinishFenceAPPLE(fence);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_APPLE_fence</para>
        /// Supported: <para>gl</para>
        /// Original: <para>GLboolean glTestObjectAPPLE(GLenum object, GLuint name);</para>
        /// </summary>
        public static bool TestObjectAPPLE(uint obj, uint name) {
            return GLNative.glTestObjectAPPLE(obj, name);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_APPLE_fence</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glFinishObjectAPPLE(GLenum object, GLint name);</para>
        /// </summary>
        public static void FinishObjectAPPLE(uint obj, int name) {
            GLNative.glFinishObjectAPPLE(obj, name);
        }


        #endregion GL_APPLE_fence

        #region GL_APPLE_flush_buffer_range

        /// <summary>
        /// <para>Require:</para> <para>GL_APPLE_flush_buffer_range</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glBufferParameteriAPPLE(GLenum target, GLenum pname, GLint param);</para>
        /// </summary>
        public static void BufferParameteriAPPLE(uint target, uint pname, int param) {
            GLNative.glBufferParameteriAPPLE(target, pname, param);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_APPLE_flush_buffer_range</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glFlushMappedBufferRangeAPPLE(GLenum target, GLintptr offset, GLsizeiptr size);</para>
        /// </summary>
        public static void FlushMappedBufferRangeAPPLE(uint target, IntPtr offset, IntPtr size) {
            GLNative.glFlushMappedBufferRangeAPPLE(target, offset, size);
        }


        #endregion GL_APPLE_flush_buffer_range

        #region GL_APPLE_object_purgeable

        /// <summary>
        /// <para>Require:</para> <para>GL_APPLE_object_purgeable</para>
        /// Supported: <para>gl</para>
        /// Original: <para>GLenum glObjectPurgeableAPPLE(GLenum objectType, GLuint name, GLenum option);</para>
        /// </summary>
        public static uint ObjectPurgeableAPPLE(uint objectType, uint name, uint option) {
            return GLNative.glObjectPurgeableAPPLE(objectType, name, option);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_APPLE_object_purgeable</para>
        /// Supported: <para>gl</para>
        /// Original: <para>GLenum glObjectUnpurgeableAPPLE(GLenum objectType, GLuint name, GLenum option);</para>
        /// </summary>
        public static uint ObjectUnpurgeableAPPLE(uint objectType, uint name, uint option) {
            return GLNative.glObjectUnpurgeableAPPLE(objectType, name, option);
        }


        #endregion GL_APPLE_object_purgeable

        #region GL_APPLE_texture_range


        #endregion GL_APPLE_texture_range

        #region GL_APPLE_vertex_array_object

        /// <summary>
        /// <para>Require:</para> <para>GL_APPLE_vertex_array_object</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glBindVertexArrayAPPLE(GLuint array);</para>
        /// </summary>
        public static void BindVertexArrayAPPLE(uint array) {
            GLNative.glBindVertexArrayAPPLE(array);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_APPLE_vertex_array_object</para>
        /// Supported: <para>gl</para>
        /// Original: <para>GLboolean glIsVertexArrayAPPLE(GLuint array);</para>
        /// </summary>
        public static bool IsVertexArrayAPPLE(uint array) {
            return GLNative.glIsVertexArrayAPPLE(array);
        }


        #endregion GL_APPLE_vertex_array_object

        #region GL_APPLE_vertex_array_range

        /// <summary>
        /// <para>Require:</para> <para>GL_APPLE_vertex_array_range</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexArrayParameteriAPPLE(GLenum pname, GLint param);</para>
        /// </summary>
        public static void VertexArrayParameteriAPPLE(uint pname, int param) {
            GLNative.glVertexArrayParameteriAPPLE(pname, param);
        }


        #endregion GL_APPLE_vertex_array_range

        #region GL_APPLE_vertex_program_evaluators

        /// <summary>
        /// <para>Require:</para> <para>GL_APPLE_vertex_program_evaluators</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glEnableVertexAttribAPPLE(GLuint index, GLenum pname);</para>
        /// </summary>
        public static void EnableVertexAttribAPPLE(uint index, uint pname) {
            GLNative.glEnableVertexAttribAPPLE(index, pname);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_APPLE_vertex_program_evaluators</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glDisableVertexAttribAPPLE(GLuint index, GLenum pname);</para>
        /// </summary>
        public static void DisableVertexAttribAPPLE(uint index, uint pname) {
            GLNative.glDisableVertexAttribAPPLE(index, pname);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_APPLE_vertex_program_evaluators</para>
        /// Supported: <para>gl</para>
        /// Original: <para>GLboolean glIsVertexAttribEnabledAPPLE(GLuint index, GLenum pname);</para>
        /// </summary>
        public static bool IsVertexAttribEnabledAPPLE(uint index, uint pname) {
            return GLNative.glIsVertexAttribEnabledAPPLE(index, pname);
        }


        #endregion GL_APPLE_vertex_program_evaluators

        #region GL_ARB_ES2_compatibility

        // void glReleaseShaderCompiler();
        // void glDepthRangef(GLfloat nearVal, GLfloat farVal);
        // void glClearDepthf(GLfloat depth);

        #endregion GL_ARB_ES2_compatibility

        #region GL_ARB_ES3_1_compatibility

        // void glMemoryBarrierByRegion(GLbitfield barriers);

        #endregion GL_ARB_ES3_1_compatibility

        #region GL_ARB_ES3_2_compatibility

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_ES3_2_compatibility</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glPrimitiveBoundingBoxARB(GLfloat minX, GLfloat minY, GLfloat minZ, GLfloat minW, GLfloat maxX, GLfloat maxY, GLfloat maxZ, GLfloat maxW);</para>
        /// </summary>
        public static void PrimitiveBoundingBoxARB(float minX, float minY, float minZ, float minW, float maxX, float maxY, float maxZ, float maxW) {
            GLNative.glPrimitiveBoundingBoxARB(minX, minY, minZ, minW, maxX, maxY, maxZ, maxW);
        }


        #endregion GL_ARB_ES3_2_compatibility

        #region GL_ARB_base_instance

        // void glDrawArraysInstancedBaseInstance(GLenum mode, GLint first, GLsizei count, GLsizei instancecount, GLuint baseinstance);

        #endregion GL_ARB_base_instance

        #region GL_ARB_bindless_texture

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_bindless_texture</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>GLuint64 glGetTextureHandleARB(GLuint texture);</para>
        /// </summary>
        public static UInt64 GetTextureHandleARB(uint texture) {
            return GLNative.glGetTextureHandleARB(texture);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_bindless_texture</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>GLuint64 glGetTextureSamplerHandleARB(GLuint texture, GLuint sampler);</para>
        /// </summary>
        public static UInt64 GetTextureSamplerHandleARB(uint texture, uint sampler) {
            return GLNative.glGetTextureSamplerHandleARB(texture, sampler);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_bindless_texture</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glMakeTextureHandleResidentARB(GLuint64 handle);</para>
        /// </summary>
        public static void MakeTextureHandleResidentARB(UInt64 handle) {
            GLNative.glMakeTextureHandleResidentARB(handle);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_bindless_texture</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glMakeTextureHandleNonResidentARB(GLuint64 handle);</para>
        /// </summary>
        public static void MakeTextureHandleNonResidentARB(UInt64 handle) {
            GLNative.glMakeTextureHandleNonResidentARB(handle);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_bindless_texture</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>GLuint64 glGetImageHandleARB(GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum format);</para>
        /// </summary>
        public static UInt64 GetImageHandleARB(uint texture, int level, bool layered, int layer, uint format) {
            return GLNative.glGetImageHandleARB(texture, level, layered, layer, format);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_bindless_texture</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glMakeImageHandleResidentARB(GLuint64 handle, GLenum access);</para>
        /// </summary>
        public static void MakeImageHandleResidentARB(UInt64 handle, uint access) {
            GLNative.glMakeImageHandleResidentARB(handle, access);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_bindless_texture</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glMakeImageHandleNonResidentARB(GLuint64 handle);</para>
        /// </summary>
        public static void MakeImageHandleNonResidentARB(UInt64 handle) {
            GLNative.glMakeImageHandleNonResidentARB(handle);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_bindless_texture</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glUniformHandleui64ARB(GLint location, GLuint64 value);</para>
        /// </summary>
        public static void UniformHandleui64ARB(int location, UInt64 value) {
            GLNative.glUniformHandleui64ARB(location, value);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_bindless_texture</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glProgramUniformHandleui64ARB(GLuint program, GLint location, GLuint64 value);</para>
        /// </summary>
        public static void ProgramUniformHandleui64ARB(uint program, int location, UInt64 value) {
            GLNative.glProgramUniformHandleui64ARB(program, location, value);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_bindless_texture</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>GLboolean glIsTextureHandleResidentARB(GLuint64 handle);</para>
        /// </summary>
        public static bool IsTextureHandleResidentARB(UInt64 handle) {
            return GLNative.glIsTextureHandleResidentARB(handle);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_bindless_texture</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>GLboolean glIsImageHandleResidentARB(GLuint64 handle);</para>
        /// </summary>
        public static bool IsImageHandleResidentARB(UInt64 handle) {
            return GLNative.glIsImageHandleResidentARB(handle);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_bindless_texture</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glVertexAttribL1ui64ARB(GLuint index, GLuint64EXT x);</para>
        /// </summary>
        public static void VertexAttribL1ui64ARB(uint index, UInt64 x) {
            GLNative.glVertexAttribL1ui64ARB(index, x);
        }


        #endregion GL_ARB_bindless_texture

        #region GL_ARB_blend_func_extended


        #endregion GL_ARB_blend_func_extended

        #region GL_ARB_buffer_storage


        #endregion GL_ARB_buffer_storage

        #region GL_ARB_cl_event


        #endregion GL_ARB_cl_event

        #region GL_ARB_clear_buffer_object


        #endregion GL_ARB_clear_buffer_object

        #region GL_ARB_clear_texture


        #endregion GL_ARB_clear_texture

        #region GL_ARB_clip_control

        // void glClipControl(GLenum origin, GLenum depth);

        #endregion GL_ARB_clip_control

        #region GL_ARB_color_buffer_float

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_color_buffer_float</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glClampColorARB(GLenum target, GLenum clamp);</para>
        /// </summary>
        public static void ClampColorARB(uint target, uint clamp) {
            GLNative.glClampColorARB(target, clamp);
        }


        #endregion GL_ARB_color_buffer_float

        #region GL_ARB_compute_shader

        // void glDispatchCompute(GLuint num_groups_x, GLuint num_groups_y, GLuint num_groups_z);
        // void glDispatchComputeIndirect(GLintptr indirect);

        #endregion GL_ARB_compute_shader

        #region GL_ARB_compute_variable_group_size

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_compute_variable_group_size</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glDispatchComputeGroupSizeARB(GLuint num_groups_x, GLuint num_groups_y, GLuint num_groups_z, GLuint group_size_x, GLuint group_size_y, GLuint group_size_z);</para>
        /// </summary>
        public static void DispatchComputeGroupSizeARB(uint num_groups_x, uint num_groups_y, uint num_groups_z, uint group_size_x, uint group_size_y, uint group_size_z) {
            GLNative.glDispatchComputeGroupSizeARB(num_groups_x, num_groups_y, num_groups_z, group_size_x, group_size_y, group_size_z);
        }


        #endregion GL_ARB_compute_variable_group_size

        #region GL_ARB_copy_buffer

        // void glCopyBufferSubData(GLenum readTarget, GLenum writeTarget, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size);

        #endregion GL_ARB_copy_buffer

        #region GL_ARB_copy_image

        // void glCopyImageSubData(GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei srcWidth, GLsizei srcHeight, GLsizei srcDepth);

        #endregion GL_ARB_copy_image

        #region GL_ARB_debug_output


        #endregion GL_ARB_debug_output

        #region GL_ARB_draw_buffers


        #endregion GL_ARB_draw_buffers

        #region GL_ARB_draw_buffers_blend

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_draw_buffers_blend</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glBlendEquationiARB(GLuint buf, GLenum mode);</para>
        /// </summary>
        public static void BlendEquationiARB(uint buf, uint mode) {
            GLNative.glBlendEquationiARB(buf, mode);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_draw_buffers_blend</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glBlendEquationSeparateiARB(GLuint buf, GLenum modeRGB, GLenum modeAlpha);</para>
        /// </summary>
        public static void BlendEquationSeparateiARB(uint buf, uint modeRGB, uint modeAlpha) {
            GLNative.glBlendEquationSeparateiARB(buf, modeRGB, modeAlpha);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_draw_buffers_blend</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glBlendFunciARB(GLuint buf, GLenum src, GLenum dst);</para>
        /// </summary>
        public static void BlendFunciARB(uint buf, uint src, uint dst) {
            GLNative.glBlendFunciARB(buf, src, dst);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_draw_buffers_blend</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glBlendFuncSeparateiARB(GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha);</para>
        /// </summary>
        public static void BlendFuncSeparateiARB(uint buf, uint srcRGB, uint dstRGB, uint srcAlpha, uint dstAlpha) {
            GLNative.glBlendFuncSeparateiARB(buf, srcRGB, dstRGB, srcAlpha, dstAlpha);
        }


        #endregion GL_ARB_draw_buffers_blend

        #region GL_ARB_draw_elements_base_vertex


        #endregion GL_ARB_draw_elements_base_vertex

        #region GL_ARB_draw_indirect


        #endregion GL_ARB_draw_indirect

        #region GL_ARB_draw_instanced

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_draw_instanced</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glDrawArraysInstancedARB(GLenum mode, GLint first, GLsizei count, GLsizei primcount);</para>
        /// </summary>
        public static void DrawArraysInstancedARB(uint mode, int first, int count, int primcount) {
            GLNative.glDrawArraysInstancedARB(mode, first, count, primcount);
        }


        #endregion GL_ARB_draw_instanced

        #region GL_ARB_framebuffer_no_attachments

        // void glFramebufferParameteri(GLenum target, GLenum pname, GLint param);

        #endregion GL_ARB_framebuffer_no_attachments

        #region GL_ARB_framebuffer_object

        // GLboolean glIsRenderbuffer(GLuint renderbuffer);
        // void glBindRenderbuffer(GLenum target, GLuint renderbuffer);
        // void glRenderbufferStorage(GLenum target, GLenum internalformat, GLsizei width, GLsizei height);
        // GLboolean glIsFramebuffer(GLuint framebuffer);
        // void glBindFramebuffer(GLenum target, GLuint framebuffer);
        // GLenum glCheckFramebufferStatus(GLenum target);
        // void glFramebufferTexture1D(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
        // void glFramebufferTexture2D(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
        // void glFramebufferTexture3D(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint layer);
        // void glFramebufferRenderbuffer(GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer);
        // void glGenerateMipmap(GLenum target);
        // void glBlitFramebuffer(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter);
        // void glRenderbufferStorageMultisample(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height);
        // void glFramebufferTextureLayer(GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer);

        #endregion GL_ARB_framebuffer_object

        #region GL_ARB_geometry_shader4

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_geometry_shader4</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glProgramParameteriARB(GLuint program, GLenum pname, GLint value);</para>
        /// </summary>
        public static void ProgramParameteriARB(uint program, uint pname, int value) {
            GLNative.glProgramParameteriARB(program, pname, value);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_geometry_shader4</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glFramebufferTextureARB(GLenum target, GLenum attachment, GLuint texture, GLint level);</para>
        /// </summary>
        public static void FramebufferTextureARB(uint target, uint attachment, uint texture, int level) {
            GLNative.glFramebufferTextureARB(target, attachment, texture, level);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_geometry_shader4</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glFramebufferTextureLayerARB(GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer);</para>
        /// </summary>
        public static void FramebufferTextureLayerARB(uint target, uint attachment, uint texture, int level, int layer) {
            GLNative.glFramebufferTextureLayerARB(target, attachment, texture, level, layer);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_geometry_shader4</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glFramebufferTextureFaceARB(GLenum target, GLenum attachment, GLuint texture, GLint level, GLenum face);</para>
        /// </summary>
        public static void FramebufferTextureFaceARB(uint target, uint attachment, uint texture, int level, uint face) {
            GLNative.glFramebufferTextureFaceARB(target, attachment, texture, level, face);
        }


        #endregion GL_ARB_geometry_shader4

        #region GL_ARB_get_program_binary

        // void glProgramParameteri(GLuint program, GLenum pname, GLint value);

        #endregion GL_ARB_get_program_binary

        #region GL_ARB_get_texture_sub_image


        #endregion GL_ARB_get_texture_sub_image

        #region GL_ARB_gl_spirv


        #endregion GL_ARB_gl_spirv

        #region GL_ARB_gpu_shader_fp64

        // void glUniform1d(GLint location, GLdouble x);
        // void glUniform2d(GLint location, GLdouble x, GLdouble y);
        // void glUniform3d(GLint location, GLdouble x, GLdouble y, GLdouble z);
        // void glUniform4d(GLint location, GLdouble x, GLdouble y, GLdouble z, GLdouble w);

        #endregion GL_ARB_gpu_shader_fp64

        #region GL_ARB_gpu_shader_int64

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_gpu_shader_int64</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glUniform1i64ARB(GLint location, GLint64 x);</para>
        /// </summary>
        public static void Uniform1i64ARB(int location, Int64 x) {
            GLNative.glUniform1i64ARB(location, x);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_gpu_shader_int64</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glUniform2i64ARB(GLint location, GLint64 x, GLint64 y);</para>
        /// </summary>
        public static void Uniform2i64ARB(int location, Int64 x, Int64 y) {
            GLNative.glUniform2i64ARB(location, x, y);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_gpu_shader_int64</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glUniform3i64ARB(GLint location, GLint64 x, GLint64 y, GLint64 z);</para>
        /// </summary>
        public static void Uniform3i64ARB(int location, Int64 x, Int64 y, Int64 z) {
            GLNative.glUniform3i64ARB(location, x, y, z);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_gpu_shader_int64</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glUniform4i64ARB(GLint location, GLint64 x, GLint64 y, GLint64 z, GLint64 w);</para>
        /// </summary>
        public static void Uniform4i64ARB(int location, Int64 x, Int64 y, Int64 z, Int64 w) {
            GLNative.glUniform4i64ARB(location, x, y, z, w);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_gpu_shader_int64</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glUniform1ui64ARB(GLint location, GLuint64 x);</para>
        /// </summary>
        public static void Uniform1ui64ARB(int location, UInt64 x) {
            GLNative.glUniform1ui64ARB(location, x);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_gpu_shader_int64</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glUniform2ui64ARB(GLint location, GLuint64 x, GLuint64 y);</para>
        /// </summary>
        public static void Uniform2ui64ARB(int location, UInt64 x, UInt64 y) {
            GLNative.glUniform2ui64ARB(location, x, y);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_gpu_shader_int64</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glUniform3ui64ARB(GLint location, GLuint64 x, GLuint64 y, GLuint64 z);</para>
        /// </summary>
        public static void Uniform3ui64ARB(int location, UInt64 x, UInt64 y, UInt64 z) {
            GLNative.glUniform3ui64ARB(location, x, y, z);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_gpu_shader_int64</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glUniform4ui64ARB(GLint location, GLuint64 x, GLuint64 y, GLuint64 z, GLuint64 w);</para>
        /// </summary>
        public static void Uniform4ui64ARB(int location, UInt64 x, UInt64 y, UInt64 z, UInt64 w) {
            GLNative.glUniform4ui64ARB(location, x, y, z, w);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_gpu_shader_int64</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glProgramUniform1i64ARB(GLuint program, GLint location, GLint64 x);</para>
        /// </summary>
        public static void ProgramUniform1i64ARB(uint program, int location, Int64 x) {
            GLNative.glProgramUniform1i64ARB(program, location, x);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_gpu_shader_int64</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glProgramUniform2i64ARB(GLuint program, GLint location, GLint64 x, GLint64 y);</para>
        /// </summary>
        public static void ProgramUniform2i64ARB(uint program, int location, Int64 x, Int64 y) {
            GLNative.glProgramUniform2i64ARB(program, location, x, y);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_gpu_shader_int64</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glProgramUniform3i64ARB(GLuint program, GLint location, GLint64 x, GLint64 y, GLint64 z);</para>
        /// </summary>
        public static void ProgramUniform3i64ARB(uint program, int location, Int64 x, Int64 y, Int64 z) {
            GLNative.glProgramUniform3i64ARB(program, location, x, y, z);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_gpu_shader_int64</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glProgramUniform4i64ARB(GLuint program, GLint location, GLint64 x, GLint64 y, GLint64 z, GLint64 w);</para>
        /// </summary>
        public static void ProgramUniform4i64ARB(uint program, int location, Int64 x, Int64 y, Int64 z, Int64 w) {
            GLNative.glProgramUniform4i64ARB(program, location, x, y, z, w);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_gpu_shader_int64</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glProgramUniform1ui64ARB(GLuint program, GLint location, GLuint64 x);</para>
        /// </summary>
        public static void ProgramUniform1ui64ARB(uint program, int location, UInt64 x) {
            GLNative.glProgramUniform1ui64ARB(program, location, x);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_gpu_shader_int64</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glProgramUniform2ui64ARB(GLuint program, GLint location, GLuint64 x, GLuint64 y);</para>
        /// </summary>
        public static void ProgramUniform2ui64ARB(uint program, int location, UInt64 x, UInt64 y) {
            GLNative.glProgramUniform2ui64ARB(program, location, x, y);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_gpu_shader_int64</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glProgramUniform3ui64ARB(GLuint program, GLint location, GLuint64 x, GLuint64 y, GLuint64 z);</para>
        /// </summary>
        public static void ProgramUniform3ui64ARB(uint program, int location, UInt64 x, UInt64 y, UInt64 z) {
            GLNative.glProgramUniform3ui64ARB(program, location, x, y, z);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_gpu_shader_int64</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glProgramUniform4ui64ARB(GLuint program, GLint location, GLuint64 x, GLuint64 y, GLuint64 z, GLuint64 w);</para>
        /// </summary>
        public static void ProgramUniform4ui64ARB(uint program, int location, UInt64 x, UInt64 y, UInt64 z, UInt64 w) {
            GLNative.glProgramUniform4ui64ARB(program, location, x, y, z, w);
        }


        #endregion GL_ARB_gpu_shader_int64

        #region GL_ARB_imaging

        // void glBlendColor(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha);
        // void glBlendEquation(GLenum mode);
        /// <summary>
        /// copy pixels into a color table
        /// <para>Require:</para> <para>GL_ARB_imaging</para>
        /// Supported: <para>gl, glcore</para>
        /// Notes: 
        /// <para>
        /// <see cref="glCopyColorTable"/> is available only if <code>ARB_imaging</code> is returned from calling
        /// <see cref="glGetString"/>  with an argument of <code>GL_EXTENSIONS</code>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated when <paramref name="target"/> is not one of the
        /// allowable values.
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="width"/> is less than zero.
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="internalformat"/> is not one of the
        /// allowable values.
        /// <code>GL_TABLE_TOO_LARGE</code> is generated if the requested color table
        /// is too large to be supported by the implementation.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glCopyColorTable"/> is executed
        /// between the execution of  <see cref="glBegin"/>  and the corresponding
        /// execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glCopyColorTable(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// The color table target. Must be
        /// <code>GL_COLOR_TABLE</code>,
        /// <code>GL_POST_CONVOLUTION_COLOR_TABLE</code>,
        /// or <code>GL_POST_COLOR_MATRIX_COLOR_TABLE</code>.
        /// </para>
        /// </param>
        /// <param name="internalformat">
        /// <para>
        /// The internal storage format of the texture image.
        /// Must be one of the following symbolic constants:
        /// <code>GL_ALPHA</code>,
        /// <code>GL_ALPHA4</code>,
        /// <code>GL_ALPHA8</code>,
        /// <code>GL_ALPHA12</code>,
        /// <code>GL_ALPHA16</code>,
        /// <code>GL_LUMINANCE</code>,
        /// <code>GL_LUMINANCE4</code>,
        /// <code>GL_LUMINANCE8</code>,
        /// <code>GL_LUMINANCE12</code>,
        /// <code>GL_LUMINANCE16</code>,
        /// <code>GL_LUMINANCE_ALPHA</code>,
        /// <code>GL_LUMINANCE4_ALPHA4</code>,
        /// <code>GL_LUMINANCE6_ALPHA2</code>,
        /// <code>GL_LUMINANCE8_ALPHA8</code>,
        /// <code>GL_LUMINANCE12_ALPHA4</code>,
        /// <code>GL_LUMINANCE12_ALPHA12</code>,
        /// <code>GL_LUMINANCE16_ALPHA16</code>,
        /// <code>GL_INTENSITY</code>,
        /// <code>GL_INTENSITY4</code>,
        /// <code>GL_INTENSITY8</code>,
        /// <code>GL_INTENSITY12</code>,
        /// <code>GL_INTENSITY16</code>,
        /// <code>GL_R3_G3_B2</code>,
        /// <code>GL_RGB</code>,
        /// <code>GL_RGB4</code>,
        /// <code>GL_RGB5</code>,
        /// <code>GL_RGB8</code>,
        /// <code>GL_RGB10</code>,
        /// <code>GL_RGB12</code>,
        /// <code>GL_RGB16</code>,
        /// <code>GL_RGBA</code>,
        /// <code>GL_RGBA2</code>,
        /// <code>GL_RGBA4</code>,
        /// <code>GL_RGB5_A1</code>,
        /// <code>GL_RGBA8</code>,
        /// <code>GL_RGB10_A2</code>,
        /// <code>GL_RGBA12</code>, or
        /// <code>GL_RGBA16</code>.
        /// </para>
        /// </param>
        /// <param name="x">
        /// <para>
        /// The x coordinate of the lower-left corner of the pixel rectangle
        /// to be transferred to the color table.
        /// </para>
        /// </param>
        /// <param name="y">
        /// <para>
        /// The y coordinate of the lower-left corner of the pixel rectangle
        /// to be transferred to the color table.
        /// </para>
        /// </param>
        /// <param name="width">
        /// The width of the pixel rectangle.
        /// </param>
        /// <seealso cref="ColorTable"/>
        /// <seealso cref="ColorTableParameter"/>
        /// <seealso cref="ReadPixels"/>
        public static void CopyColorTable(uint target, uint internalformat, int x, int y, int width) {
            GLNative.glCopyColorTable(target, internalformat, x, y, width);
        }

        /// <summary>
        /// respecify a portion of a color table
        /// <para>Require:</para> <para>GL_ARB_imaging</para>
        /// Supported: <para>gl, glcore</para>
        /// Notes: 
        /// <para>
        /// <see cref="glCopyColorSubTable"/> is present only if <code>ARB_imaging</code> is returned when  <see cref="glGetString"/> 
        /// is called with an argument of <code>GL_EXTENSIONS</code>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="target"/> is not a previously defined
        /// color table.
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="target"/> is not one of the allowable
        /// values.
        /// <code>GL_INVALID_VALUE</code> is generated if 
        /// width:-->
        /// start 
        /// + 
        /// x 
        /// &gt; 
        /// width 
        /// .
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glCopyColorSubTable"/> is executed
        /// between the execution of  <see cref="glBegin"/>  and the corresponding
        /// execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glCopyColorSubTable(GLenum target, GLsizei start, GLint x, GLint y, GLsizei width);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Must be one of
        /// <code>GL_COLOR_TABLE</code>,
        /// <code>GL_POST_CONVOLUTION_COLOR_TABLE</code>, or
        /// <code>GL_POST_COLOR_MATRIX_COLOR_TABLE</code>.
        /// </para>
        /// </param>
        /// <param name="start">
        /// The starting index of the portion of the color table to be replaced.
        /// </param>
        /// <param name="x">
        /// <para>
        /// The window coordinates of the left corner of the row of pixels to be
        /// copied.
        /// </para>
        /// </param>
        /// <param name="y">
        /// <para>
        /// The window coordinates of the left corner of the row of pixels to be
        /// copied.
        /// </para>
        /// </param>
        /// <param name="width">
        /// The number of table entries to replace.
        /// </param>
        /// <seealso cref="ColorSubTable"/>
        /// <seealso cref="ColorTableParameter"/>
        /// <seealso cref="CopyColorTable"/>
        /// <seealso cref="CopyColorSubTable"/>
        /// <seealso cref="GetColorTable"/>
        public static void CopyColorSubTable(uint target, int start, int x, int y, int width) {
            GLNative.glCopyColorSubTable(target, start, x, y, width);
        }

        /// <summary>
        /// set convolution parameters
        /// <para>Require:</para> <para>GL_ARB_imaging</para>
        /// Supported: <para>gl, glcore</para>
        /// Notes: 
        /// <para>
        /// <see cref="glConvolutionParameter"/> is present only if <code>ARB_imaging</code> is returned when  <see cref="glGetString"/> 
        /// is called with an argument of <code>GL_EXTENSIONS</code>.
        /// In cases where errors can result from the specification of invalid
        /// image dimensions, it is the dimensions after convolution that are
        /// tested, not the dimensions of the source image.
        /// For example,  <see cref="glTexImage1D"/>  requires power-of-two image size.
        /// When <code>GL_REDUCE</code> border mode is in effect,
        /// the source image must be larger than the final power-of-two size
        /// by one less than the size of the 1D filter kernel.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="target"/> is not one of the allowable
        /// values.
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="pname"/> is not one of the allowable
        /// values.
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="pname"/> is
        /// <code>GL_CONVOLUTION_BORDER_MODE</code> and <paramref name="ps"/> is not one of
        /// <code>GL_REDUCE</code>, <code>GL_CONSTANT_BORDER</code>, or <code>GL_REPLICATE_BORDER</code>.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glConvolutionParameter"/> is executed
        /// between the execution of  <see cref="glBegin"/>  and the corresponding
        /// execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glConvolutionParameterf(GLenum target, GLenum pname, GLfloat params);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// The target for the convolution parameter.
        /// Must be one of
        /// <code>GL_CONVOLUTION_1D</code>,
        /// <code>GL_CONVOLUTION_2D</code>, or
        /// <code>GL_SEPARABLE_2D</code>.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// The parameter to be set.
        /// Must be
        /// <code>GL_CONVOLUTION_BORDER_MODE</code>.
        /// </para>
        /// </param>
        /// <param name="ps">
        /// <para>
        /// The parameter value.
        /// Must be one of
        /// <code>GL_REDUCE</code>, <code>GL_CONSTANT_BORDER</code>, <code>GL_REPLICATE_BORDER</code>.
        /// </para>
        /// </param>
        /// <seealso cref="ConvolutionFilter1D"/>
        /// <seealso cref="ConvolutionFilter2D"/>
        /// <seealso cref="SeparableFilter2D"/>
        /// <seealso cref="GetConvolutionParameter"/>
        public static void ConvolutionParameterf(uint target, uint pname, float ps) {
            GLNative.glConvolutionParameterf(target, pname, ps);
        }

        /// <summary>
        /// set convolution parameters
        /// <para>Require:</para> <para>GL_ARB_imaging</para>
        /// Supported: <para>gl, glcore</para>
        /// Notes: 
        /// <para>
        /// <see cref="glConvolutionParameter"/> is present only if <code>ARB_imaging</code> is returned when  <see cref="glGetString"/> 
        /// is called with an argument of <code>GL_EXTENSIONS</code>.
        /// In cases where errors can result from the specification of invalid
        /// image dimensions, it is the dimensions after convolution that are
        /// tested, not the dimensions of the source image.
        /// For example,  <see cref="glTexImage1D"/>  requires power-of-two image size.
        /// When <code>GL_REDUCE</code> border mode is in effect,
        /// the source image must be larger than the final power-of-two size
        /// by one less than the size of the 1D filter kernel.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="target"/> is not one of the allowable
        /// values.
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="pname"/> is not one of the allowable
        /// values.
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="pname"/> is
        /// <code>GL_CONVOLUTION_BORDER_MODE</code> and <paramref name="ps"/> is not one of
        /// <code>GL_REDUCE</code>, <code>GL_CONSTANT_BORDER</code>, or <code>GL_REPLICATE_BORDER</code>.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glConvolutionParameter"/> is executed
        /// between the execution of  <see cref="glBegin"/>  and the corresponding
        /// execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glConvolutionParameteri(GLenum target, GLenum pname, GLint params);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// The target for the convolution parameter.
        /// Must be one of
        /// <code>GL_CONVOLUTION_1D</code>,
        /// <code>GL_CONVOLUTION_2D</code>, or
        /// <code>GL_SEPARABLE_2D</code>.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// The parameter to be set.
        /// Must be
        /// <code>GL_CONVOLUTION_BORDER_MODE</code>.
        /// </para>
        /// </param>
        /// <param name="ps">
        /// <para>
        /// The parameter value.
        /// Must be one of
        /// <code>GL_REDUCE</code>, <code>GL_CONSTANT_BORDER</code>, <code>GL_REPLICATE_BORDER</code>.
        /// </para>
        /// </param>
        /// <seealso cref="ConvolutionFilter1D"/>
        /// <seealso cref="ConvolutionFilter2D"/>
        /// <seealso cref="SeparableFilter2D"/>
        /// <seealso cref="GetConvolutionParameter"/>
        public static void ConvolutionParameteri(uint target, uint pname, int ps) {
            GLNative.glConvolutionParameteri(target, pname, ps);
        }

        /// <summary>
        /// copy pixels into a one-dimensional convolution filter
        /// <para>Require:</para> <para>GL_ARB_imaging</para>
        /// Supported: <para>gl, glcore</para>
        /// Notes: 
        /// <para>
        /// <see cref="glCopyConvolutionFilter1D"/> is present only if <code>ARB_imaging</code> is returned when  <see cref="glGetString"/> 
        /// is called with an argument of <code>GL_EXTENSIONS</code>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="target"/> is not
        /// <code>GL_CONVOLUTION_1D</code>.
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="internalformat"/> is not one of the
        /// allowable values.
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="width"/> is less than zero or greater
        /// than the maximum supported value.
        /// This value may be queried with  <see cref="glGetConvolutionParameter"/> 
        /// using target <code>GL_CONVOLUTION_1D</code> and name
        /// <code>GL_MAX_CONVOLUTION_WIDTH</code>.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glCopyConvolutionFilter1D"/> is executed
        /// between the execution of  <see cref="glBegin"/>  and the corresponding
        /// execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glCopyConvolutionFilter1D(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width);</para>
        /// </summary>
        /// <param name="target">
        /// Must be <code>GL_CONVOLUTION_1D</code>.
        /// </param>
        /// <param name="internalformat">
        /// <para>
        /// The internal format of the convolution filter kernel.
        /// The allowable values are
        /// <code>GL_ALPHA</code>,
        /// <code>GL_ALPHA4</code>,
        /// <code>GL_ALPHA8</code>,
        /// <code>GL_ALPHA12</code>,
        /// <code>GL_ALPHA16</code>,
        /// <code>GL_LUMINANCE</code>,
        /// <code>GL_LUMINANCE4</code>,
        /// <code>GL_LUMINANCE8</code>,
        /// <code>GL_LUMINANCE12</code>,
        /// <code>GL_LUMINANCE16</code>,
        /// <code>GL_LUMINANCE_ALPHA</code>,
        /// <code>GL_LUMINANCE4_ALPHA4</code>,
        /// <code>GL_LUMINANCE6_ALPHA2</code>,
        /// <code>GL_LUMINANCE8_ALPHA8</code>,
        /// <code>GL_LUMINANCE12_ALPHA4</code>,
        /// <code>GL_LUMINANCE12_ALPHA12</code>,
        /// <code>GL_LUMINANCE16_ALPHA16</code>,
        /// <code>GL_INTENSITY</code>,
        /// <code>GL_INTENSITY4</code>,
        /// <code>GL_INTENSITY8</code>,
        /// <code>GL_INTENSITY12</code>,
        /// <code>GL_INTENSITY16</code>,
        /// <code>GL_R3_G3_B2</code>,
        /// <code>GL_RGB</code>,
        /// <code>GL_RGB4</code>,
        /// <code>GL_RGB5</code>,
        /// <code>GL_RGB8</code>,
        /// <code>GL_RGB10</code>,
        /// <code>GL_RGB12</code>,
        /// <code>GL_RGB16</code>,
        /// <code>GL_RGBA</code>,
        /// <code>GL_RGBA2</code>,
        /// <code>GL_RGBA4</code>,
        /// <code>GL_RGB5_A1</code>,
        /// <code>GL_RGBA8</code>,
        /// <code>GL_RGB10_A2</code>,
        /// <code>GL_RGBA12</code>, or
        /// <code>GL_RGBA16</code>.
        /// </para>
        /// </param>
        /// <param name="x">
        /// <para>
        /// The window space coordinates of the lower-left coordinate of the
        /// pixel array to copy.
        /// </para>
        /// </param>
        /// <param name="y">
        /// <para>
        /// The window space coordinates of the lower-left coordinate of the
        /// pixel array to copy.
        /// </para>
        /// </param>
        /// <param name="width">
        /// The width of the pixel array to copy.
        /// </param>
        /// <seealso cref="ConvolutionFilter1D"/>
        /// <seealso cref="ConvolutionParameter"/>
        /// <seealso cref="PixelTransfer"/>
        public static void CopyConvolutionFilter1D(uint target, uint internalformat, int x, int y, int width) {
            GLNative.glCopyConvolutionFilter1D(target, internalformat, x, y, width);
        }

        /// <summary>
        /// copy pixels into a two-dimensional convolution filter
        /// <para>Require:</para> <para>GL_ARB_imaging</para>
        /// Supported: <para>gl, glcore</para>
        /// Notes: 
        /// <para>
        /// <see cref="glCopyConvolutionFilter2D"/> is present only if <code>ARB_imaging</code> is returned when  <see cref="glGetString"/> 
        /// is called with an argument of <code>GL_EXTENSIONS</code>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="target"/> is not
        /// <code>GL_CONVOLUTION_2D</code>.
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="internalformat"/> is not one of the
        /// allowable values.
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="width"/> is less than zero or greater
        /// than the maximum supported value.
        /// This value may be queried with  <see cref="glGetConvolutionParameter"/> 
        /// using target <code>GL_CONVOLUTION_2D</code> and name
        /// <code>GL_MAX_CONVOLUTION_WIDTH</code>.
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="height"/> is less than zero or greater
        /// than the maximum supported value.
        /// This value may be queried with  <see cref="glGetConvolutionParameter"/> 
        /// using target <code>GL_CONVOLUTION_2D</code> and name
        /// <code>GL_MAX_CONVOLUTION_HEIGHT</code>.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glCopyConvolutionFilter2D"/> is executed
        /// between the execution of  <see cref="glBegin"/>  and the corresponding
        /// execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glCopyConvolutionFilter2D(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height);</para>
        /// </summary>
        /// <param name="target">
        /// Must be <code>GL_CONVOLUTION_2D</code>.
        /// </param>
        /// <param name="internalformat">
        /// <para>
        /// The internal format of the convolution filter kernel.
        /// The allowable values are
        /// <code>GL_ALPHA</code>,
        /// <code>GL_ALPHA4</code>,
        /// <code>GL_ALPHA8</code>,
        /// <code>GL_ALPHA12</code>,
        /// <code>GL_ALPHA16</code>,
        /// <code>GL_LUMINANCE</code>,
        /// <code>GL_LUMINANCE4</code>,
        /// <code>GL_LUMINANCE8</code>,
        /// <code>GL_LUMINANCE12</code>,
        /// <code>GL_LUMINANCE16</code>,
        /// <code>GL_LUMINANCE_ALPHA</code>,
        /// <code>GL_LUMINANCE4_ALPHA4</code>,
        /// <code>GL_LUMINANCE6_ALPHA2</code>,
        /// <code>GL_LUMINANCE8_ALPHA8</code>,
        /// <code>GL_LUMINANCE12_ALPHA4</code>,
        /// <code>GL_LUMINANCE12_ALPHA12</code>,
        /// <code>GL_LUMINANCE16_ALPHA16</code>,
        /// <code>GL_INTENSITY</code>,
        /// <code>GL_INTENSITY4</code>,
        /// <code>GL_INTENSITY8</code>,
        /// <code>GL_INTENSITY12</code>,
        /// <code>GL_INTENSITY16</code>,
        /// <code>GL_R3_G3_B2</code>,
        /// <code>GL_RGB</code>,
        /// <code>GL_RGB4</code>,
        /// <code>GL_RGB5</code>,
        /// <code>GL_RGB8</code>,
        /// <code>GL_RGB10</code>,
        /// <code>GL_RGB12</code>,
        /// <code>GL_RGB16</code>,
        /// <code>GL_RGBA</code>,
        /// <code>GL_RGBA2</code>,
        /// <code>GL_RGBA4</code>,
        /// <code>GL_RGB5_A1</code>,
        /// <code>GL_RGBA8</code>,
        /// <code>GL_RGB10_A2</code>,
        /// <code>GL_RGBA12</code>, or
        /// <code>GL_RGBA16</code>.
        /// </para>
        /// </param>
        /// <param name="x">
        /// <para>
        /// The window space coordinates of the lower-left coordinate of the
        /// pixel array to copy.
        /// </para>
        /// </param>
        /// <param name="y">
        /// <para>
        /// The window space coordinates of the lower-left coordinate of the
        /// pixel array to copy.
        /// </para>
        /// </param>
        /// <param name="width">
        /// The width of the pixel array to copy.
        /// </param>
        /// <param name="height">
        /// The height of the pixel array to copy.
        /// </param>
        /// <seealso cref="ConvolutionFilter2D"/>
        /// <seealso cref="ConvolutionParameter"/>
        /// <seealso cref="PixelTransfer"/>
        public static void CopyConvolutionFilter2D(uint target, uint internalformat, int x, int y, int width, int height) {
            GLNative.glCopyConvolutionFilter2D(target, internalformat, x, y, width, height);
        }

        /// <summary>
        /// define histogram table
        /// <para>Require:</para> <para>GL_ARB_imaging</para>
        /// Supported: <para>gl, glcore</para>
        /// Notes: 
        /// <para>
        /// <see cref="glHistogram"/> is present only if <code>ARB_imaging</code> is returned when  <see cref="glGetString"/> 
        /// is called with an argument of <code>GL_EXTENSIONS</code>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="target"/> is not one of the allowable
        /// values.
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="width"/> is less than zero or is
        /// not a power of 2.
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="internalformat"/> is not one of the
        /// allowable values.
        /// <code>GL_TABLE_TOO_LARGE</code> is generated if <paramref name="target"/> is <code>GL_HISTOGRAM</code>
        /// and the histogram table specified is too large for the implementation.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glHistogram"/> is executed
        /// between the execution of  <see cref="glBegin"/>  and the corresponding
        /// execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glHistogram(GLenum target, GLsizei width, GLenum internalformat, GLboolean sink);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// The histogram whose parameters are to be set.
        /// Must be one of
        /// <code>GL_HISTOGRAM</code> or
        /// <code>GL_PROXY_HISTOGRAM</code>.
        /// </para>
        /// </param>
        /// <param name="width">
        /// The number of entries in the histogram table.  Must be a power of 2.
        /// </param>
        /// <param name="internalformat">
        /// <para>
        /// The format of entries in the histogram table.
        /// Must be one of
        /// <code>GL_ALPHA</code>,
        /// <code>GL_ALPHA4</code>,
        /// <code>GL_ALPHA8</code>,
        /// <code>GL_ALPHA12</code>,
        /// <code>GL_ALPHA16</code>,
        /// <code>GL_LUMINANCE</code>,
        /// <code>GL_LUMINANCE4</code>,
        /// <code>GL_LUMINANCE8</code>,
        /// <code>GL_LUMINANCE12</code>,
        /// <code>GL_LUMINANCE16</code>,
        /// <code>GL_LUMINANCE_ALPHA</code>,
        /// <code>GL_LUMINANCE4_ALPHA4</code>,
        /// <code>GL_LUMINANCE6_ALPHA2</code>,
        /// <code>GL_LUMINANCE8_ALPHA8</code>,
        /// <code>GL_LUMINANCE12_ALPHA4</code>,
        /// <code>GL_LUMINANCE12_ALPHA12</code>,
        /// <code>GL_LUMINANCE16_ALPHA16</code>,
        /// <code>GL_R3_G3_B2</code>,
        /// <code>GL_RGB</code>,
        /// <code>GL_RGB4</code>,
        /// <code>GL_RGB5</code>,
        /// <code>GL_RGB8</code>,
        /// <code>GL_RGB10</code>,
        /// <code>GL_RGB12</code>,
        /// <code>GL_RGB16</code>,
        /// <code>GL_RGBA</code>,
        /// <code>GL_RGBA2</code>,
        /// <code>GL_RGBA4</code>,
        /// <code>GL_RGB5_A1</code>,
        /// <code>GL_RGBA8</code>,
        /// <code>GL_RGB10_A2</code>,
        /// <code>GL_RGBA12</code>, or
        /// <code>GL_RGBA16</code>.
        /// </para>
        /// </param>
        /// <param name="sink">
        /// <para>
        /// If <code>GL_TRUE</code>, pixels will be consumed by the histogramming
        /// process and no drawing or texture loading will take place.
        /// If <code>GL_FALSE</code>, pixels will proceed to the minmax process after
        /// histogramming.
        /// </para>
        /// </param>
        /// <seealso cref="GetHistogram"/>
        /// <seealso cref="ResetHistogram"/>
        public static void Histogram(uint target, int width, uint internalformat, bool sink) {
            GLNative.glHistogram(target, width, internalformat, sink);
        }

        /// <summary>
        /// define minmax table
        /// <para>Require:</para> <para>GL_ARB_imaging</para>
        /// Supported: <para>gl, glcore</para>
        /// Notes: 
        /// <para>
        /// <see cref="glMinmax"/> is present only if <code>ARB_imaging</code> is returned when  <see cref="glGetString"/> 
        /// is called with an argument of <code>GL_EXTENSIONS</code>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="target"/> is not one of the allowable
        /// values.
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="internalformat"/> is not one of the
        /// allowable values.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glMinmax"/> is executed
        /// between the execution of  <see cref="glBegin"/>  and the corresponding
        /// execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glMinmax(GLenum target, GLenum internalformat, GLboolean sink);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// The minmax table whose parameters are to be set.
        /// Must be
        /// <code>GL_MINMAX</code>.
        /// </para>
        /// </param>
        /// <param name="internalformat">
        /// <para>
        /// The format of entries in the minmax table.
        /// Must be one of
        /// <code>GL_ALPHA</code>,
        /// <code>GL_ALPHA4</code>,
        /// <code>GL_ALPHA8</code>,
        /// <code>GL_ALPHA12</code>,
        /// <code>GL_ALPHA16</code>,
        /// <code>GL_LUMINANCE</code>,
        /// <code>GL_LUMINANCE4</code>,
        /// <code>GL_LUMINANCE8</code>,
        /// <code>GL_LUMINANCE12</code>,
        /// <code>GL_LUMINANCE16</code>,
        /// <code>GL_LUMINANCE_ALPHA</code>,
        /// <code>GL_LUMINANCE4_ALPHA4</code>,
        /// <code>GL_LUMINANCE6_ALPHA2</code>,
        /// <code>GL_LUMINANCE8_ALPHA8</code>,
        /// <code>GL_LUMINANCE12_ALPHA4</code>,
        /// <code>GL_LUMINANCE12_ALPHA12</code>,
        /// <code>GL_LUMINANCE16_ALPHA16</code>,
        /// <code>GL_R3_G3_B2</code>,
        /// <code>GL_RGB</code>,
        /// <code>GL_RGB4</code>,
        /// <code>GL_RGB5</code>,
        /// <code>GL_RGB8</code>,
        /// <code>GL_RGB10</code>,
        /// <code>GL_RGB12</code>,
        /// <code>GL_RGB16</code>,
        /// <code>GL_RGBA</code>,
        /// <code>GL_RGBA2</code>,
        /// <code>GL_RGBA4</code>,
        /// <code>GL_RGB5_A1</code>,
        /// <code>GL_RGBA8</code>,
        /// <code>GL_RGB10_A2</code>,
        /// <code>GL_RGBA12</code>, or
        /// <code>GL_RGBA16</code>.
        /// </para>
        /// </param>
        /// <param name="sink">
        /// <para>
        /// If <code>GL_TRUE</code>, pixels will be consumed by the minmax
        /// process and no drawing or texture loading will take place.
        /// If <code>GL_FALSE</code>, pixels will proceed to the final conversion process after
        /// minmax.
        /// </para>
        /// </param>
        /// <seealso cref="GetMinmax"/>
        /// <seealso cref="ResetMinmax"/>
        public static void Minmax(uint target, uint internalformat, bool sink) {
            GLNative.glMinmax(target, internalformat, sink);
        }

        /// <summary>
        /// reset histogram table entries to zero
        /// <para>Require:</para> <para>GL_ARB_imaging</para>
        /// Supported: <para>gl, glcore</para>
        /// Notes: 
        /// <para>
        /// <see cref="glResetHistogram"/> is present only if <code>ARB_imaging</code> is returned when  <see cref="glGetString"/> 
        /// is called with an argument of <code>GL_EXTENSIONS</code>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="target"/> is not <code>GL_HISTOGRAM</code>.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glResetHistogram"/> is executed
        /// between the execution of  <see cref="glBegin"/>  and the corresponding
        /// execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glResetHistogram(GLenum target);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Must be
        /// <code>GL_HISTOGRAM</code>.
        /// </para>
        /// </param>
        /// <seealso cref="Histogram"/>
        public static void ResetHistogram(uint target) {
            GLNative.glResetHistogram(target);
        }

        /// <summary>
        /// reset minmax table entries to initial values
        /// <para>Require:</para> <para>GL_ARB_imaging</para>
        /// Supported: <para>gl, glcore</para>
        /// Notes: 
        /// <para>
        /// <see cref="glResetMinmax"/> is present only if <code>ARB_imaging</code> is returned when  <see cref="glGetString"/> 
        /// is called with an argument of <code>GL_EXTENSIONS</code>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="target"/> is not <code>GL_MINMAX</code>.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glResetMinmax"/> is executed
        /// between the execution of  <see cref="glBegin"/>  and the corresponding
        /// execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glResetMinmax(GLenum target);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Must be
        /// <code>GL_MINMAX</code>.
        /// </para>
        /// </param>
        /// <seealso cref="Minmax"/>
        public static void ResetMinmax(uint target) {
            GLNative.glResetMinmax(target);
        }


        #endregion GL_ARB_imaging

        #region GL_ARB_indirect_parameters


        #endregion GL_ARB_indirect_parameters

        #region GL_ARB_instanced_arrays

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_instanced_arrays</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glVertexAttribDivisorARB(GLuint index, GLuint divisor);</para>
        /// </summary>
        public static void VertexAttribDivisorARB(uint index, uint divisor) {
            GLNative.glVertexAttribDivisorARB(index, divisor);
        }


        #endregion GL_ARB_instanced_arrays

        #region GL_ARB_internalformat_query


        #endregion GL_ARB_internalformat_query

        #region GL_ARB_invalidate_subdata

        // void glInvalidateTexSubImage(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth);
        // void glInvalidateTexImage(GLuint texture, GLint level);
        // void glInvalidateBufferSubData(GLuint buffer, GLintptr offset, GLsizeiptr length);
        // void glInvalidateBufferData(GLuint buffer);

        #endregion GL_ARB_invalidate_subdata

        #region GL_ARB_map_buffer_range

        // void glFlushMappedBufferRange(GLenum target, GLintptr offset, GLsizeiptr length);

        #endregion GL_ARB_map_buffer_range

        #region GL_ARB_matrix_palette

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_matrix_palette</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glCurrentPaletteMatrixARB(GLint index);</para>
        /// </summary>
        public static void CurrentPaletteMatrixARB(int index) {
            GLNative.glCurrentPaletteMatrixARB(index);
        }


        #endregion GL_ARB_matrix_palette

        #region GL_ARB_multi_bind


        #endregion GL_ARB_multi_bind

        #region GL_ARB_multi_draw_indirect


        #endregion GL_ARB_multi_draw_indirect

        #region GL_ARB_multisample

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_multisample</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glSampleCoverageARB(GLfloat value, GLboolean invert);</para>
        /// </summary>
        public static void SampleCoverageARB(float value, bool invert) {
            GLNative.glSampleCoverageARB(value, invert);
        }


        #endregion GL_ARB_multisample

        #region GL_ARB_multitexture

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_multitexture</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glActiveTextureARB(GLenum texture);</para>
        /// </summary>
        public static void ActiveTextureARB(uint texture) {
            GLNative.glActiveTextureARB(texture);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_multitexture</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glClientActiveTextureARB(GLenum texture);</para>
        /// </summary>
        public static void ClientActiveTextureARB(uint texture) {
            GLNative.glClientActiveTextureARB(texture);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_multitexture</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glMultiTexCoord1dARB(GLenum target, GLdouble s);</para>
        /// </summary>
        public static void MultiTexCoord1dARB(uint target, double s) {
            GLNative.glMultiTexCoord1dARB(target, s);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_multitexture</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glMultiTexCoord1fARB(GLenum target, GLfloat s);</para>
        /// </summary>
        public static void MultiTexCoord1fARB(uint target, float s) {
            GLNative.glMultiTexCoord1fARB(target, s);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_multitexture</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glMultiTexCoord1iARB(GLenum target, GLint s);</para>
        /// </summary>
        public static void MultiTexCoord1iARB(uint target, int s) {
            GLNative.glMultiTexCoord1iARB(target, s);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_multitexture</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glMultiTexCoord1sARB(GLenum target, GLshort s);</para>
        /// </summary>
        public static void MultiTexCoord1sARB(uint target, short s) {
            GLNative.glMultiTexCoord1sARB(target, s);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_multitexture</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glMultiTexCoord2dARB(GLenum target, GLdouble s, GLdouble t);</para>
        /// </summary>
        public static void MultiTexCoord2dARB(uint target, double s, double t) {
            GLNative.glMultiTexCoord2dARB(target, s, t);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_multitexture</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glMultiTexCoord2fARB(GLenum target, GLfloat s, GLfloat t);</para>
        /// </summary>
        public static void MultiTexCoord2fARB(uint target, float s, float t) {
            GLNative.glMultiTexCoord2fARB(target, s, t);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_multitexture</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glMultiTexCoord2iARB(GLenum target, GLint s, GLint t);</para>
        /// </summary>
        public static void MultiTexCoord2iARB(uint target, int s, int t) {
            GLNative.glMultiTexCoord2iARB(target, s, t);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_multitexture</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glMultiTexCoord2sARB(GLenum target, GLshort s, GLshort t);</para>
        /// </summary>
        public static void MultiTexCoord2sARB(uint target, short s, short t) {
            GLNative.glMultiTexCoord2sARB(target, s, t);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_multitexture</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glMultiTexCoord3dARB(GLenum target, GLdouble s, GLdouble t, GLdouble r);</para>
        /// </summary>
        public static void MultiTexCoord3dARB(uint target, double s, double t, double r) {
            GLNative.glMultiTexCoord3dARB(target, s, t, r);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_multitexture</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glMultiTexCoord3fARB(GLenum target, GLfloat s, GLfloat t, GLfloat r);</para>
        /// </summary>
        public static void MultiTexCoord3fARB(uint target, float s, float t, float r) {
            GLNative.glMultiTexCoord3fARB(target, s, t, r);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_multitexture</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glMultiTexCoord3iARB(GLenum target, GLint s, GLint t, GLint r);</para>
        /// </summary>
        public static void MultiTexCoord3iARB(uint target, int s, int t, int r) {
            GLNative.glMultiTexCoord3iARB(target, s, t, r);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_multitexture</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glMultiTexCoord3sARB(GLenum target, GLshort s, GLshort t, GLshort r);</para>
        /// </summary>
        public static void MultiTexCoord3sARB(uint target, short s, short t, short r) {
            GLNative.glMultiTexCoord3sARB(target, s, t, r);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_multitexture</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glMultiTexCoord4dARB(GLenum target, GLdouble s, GLdouble t, GLdouble r, GLdouble q);</para>
        /// </summary>
        public static void MultiTexCoord4dARB(uint target, double s, double t, double r, double q) {
            GLNative.glMultiTexCoord4dARB(target, s, t, r, q);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_multitexture</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glMultiTexCoord4fARB(GLenum target, GLfloat s, GLfloat t, GLfloat r, GLfloat q);</para>
        /// </summary>
        public static void MultiTexCoord4fARB(uint target, float s, float t, float r, float q) {
            GLNative.glMultiTexCoord4fARB(target, s, t, r, q);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_multitexture</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glMultiTexCoord4iARB(GLenum target, GLint s, GLint t, GLint r, GLint q);</para>
        /// </summary>
        public static void MultiTexCoord4iARB(uint target, int s, int t, int r, int q) {
            GLNative.glMultiTexCoord4iARB(target, s, t, r, q);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_multitexture</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glMultiTexCoord4sARB(GLenum target, GLshort s, GLshort t, GLshort r, GLshort q);</para>
        /// </summary>
        public static void MultiTexCoord4sARB(uint target, short s, short t, short r, short q) {
            GLNative.glMultiTexCoord4sARB(target, s, t, r, q);
        }


        #endregion GL_ARB_multitexture

        #region GL_ARB_occlusion_query

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_occlusion_query</para>
        /// Supported: <para>gl</para>
        /// Original: <para>GLboolean glIsQueryARB(GLuint id);</para>
        /// </summary>
        public static bool IsQueryARB(uint id) {
            return GLNative.glIsQueryARB(id);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_occlusion_query</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glBeginQueryARB(GLenum target, GLuint id);</para>
        /// </summary>
        public static void BeginQueryARB(uint target, uint id) {
            GLNative.glBeginQueryARB(target, id);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_occlusion_query</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glEndQueryARB(GLenum target);</para>
        /// </summary>
        public static void EndQueryARB(uint target) {
            GLNative.glEndQueryARB(target);
        }


        #endregion GL_ARB_occlusion_query

        #region GL_ARB_parallel_shader_compile

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_parallel_shader_compile</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glMaxShaderCompilerThreadsARB(GLuint count);</para>
        /// </summary>
        public static void MaxShaderCompilerThreadsARB(uint count) {
            GLNative.glMaxShaderCompilerThreadsARB(count);
        }


        #endregion GL_ARB_parallel_shader_compile

        #region GL_ARB_point_parameters

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_point_parameters</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glPointParameterfARB(GLenum pname, GLfloat param);</para>
        /// </summary>
        public static void PointParameterfARB(uint pname, float param) {
            GLNative.glPointParameterfARB(pname, param);
        }


        #endregion GL_ARB_point_parameters

        #region GL_ARB_polygon_offset_clamp

        // void glPolygonOffsetClamp(GLfloat factor, GLfloat units, GLfloat clamp);

        #endregion GL_ARB_polygon_offset_clamp

        #region GL_ARB_program_interface_query


        #endregion GL_ARB_program_interface_query

        #region GL_ARB_provoking_vertex

        // void glProvokingVertex(GLenum provokeMode);

        #endregion GL_ARB_provoking_vertex

        #region GL_ARB_robustness

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_robustness</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>GLenum glGetGraphicsResetStatusARB();</para>
        /// </summary>
        public static uint GetGraphicsResetStatusARB() {
            return GLNative.glGetGraphicsResetStatusARB();
        }


        #endregion GL_ARB_robustness

        #region GL_ARB_sample_locations

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_sample_locations</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glEvaluateDepthValuesARB();</para>
        /// </summary>
        public static void EvaluateDepthValuesARB() {
            GLNative.glEvaluateDepthValuesARB();
        }


        #endregion GL_ARB_sample_locations

        #region GL_ARB_sample_shading

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_sample_shading</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glMinSampleShadingARB(GLfloat value);</para>
        /// </summary>
        public static void MinSampleShadingARB(float value) {
            GLNative.glMinSampleShadingARB(value);
        }


        #endregion GL_ARB_sample_shading

        #region GL_ARB_sampler_objects

        // GLboolean glIsSampler(GLuint id);
        // void glBindSampler(GLuint unit, GLuint sampler);
        // void glSamplerParameteri(GLuint sampler, GLenum pname, GLint param);
        // void glSamplerParameterf(GLuint sampler, GLenum pname, GLfloat param);

        #endregion GL_ARB_sampler_objects

        #region GL_ARB_separate_shader_objects

        // void glUseProgramStages(GLuint pipeline, GLbitfield stages, GLuint program);
        // void glActiveShaderProgram(GLuint pipeline, GLuint program);
        // void glBindProgramPipeline(GLuint pipeline);
        // GLboolean glIsProgramPipeline(GLuint pipeline);
        // void glProgramParameteri(GLuint program, GLenum pname, GLint value);
        // void glProgramUniform1i(GLuint program, GLint location, GLint v0);
        // void glProgramUniform1f(GLuint program, GLint location, GLfloat v0);
        // void glProgramUniform1d(GLuint program, GLint location, GLdouble v0);
        // void glProgramUniform1ui(GLuint program, GLint location, GLuint v0);
        // void glProgramUniform2i(GLuint program, GLint location, GLint v0, GLint v1);
        // void glProgramUniform2f(GLuint program, GLint location, GLfloat v0, GLfloat v1);
        // void glProgramUniform2d(GLuint program, GLint location, GLdouble v0, GLdouble v1);
        // void glProgramUniform2ui(GLuint program, GLint location, GLuint v0, GLuint v1);
        // void glProgramUniform3i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2);
        // void glProgramUniform3f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2);
        // void glProgramUniform3d(GLuint program, GLint location, GLdouble v0, GLdouble v1, GLdouble v2);
        // void glProgramUniform3ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2);
        // void glProgramUniform4i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3);
        // void glProgramUniform4f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3);
        // void glProgramUniform4d(GLuint program, GLint location, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3);
        // void glProgramUniform4ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3);
        // void glValidateProgramPipeline(GLuint pipeline);

        #endregion GL_ARB_separate_shader_objects

        #region GL_ARB_shader_atomic_counters


        #endregion GL_ARB_shader_atomic_counters

        #region GL_ARB_shader_image_load_store

        // void glBindImageTexture(GLuint unit, GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum access, GLenum format);
        // void glMemoryBarrier(GLbitfield barriers);

        #endregion GL_ARB_shader_image_load_store

        #region GL_ARB_shader_objects

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_shader_objects</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glDeleteObjectARB(GLhandleARB obj);</para>
        /// </summary>
        public static void DeleteObjectARB(uint obj) {
            GLNative.glDeleteObjectARB(obj);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_shader_objects</para>
        /// Supported: <para>gl</para>
        /// Original: <para>GLhandleARB glGetHandleARB(GLenum pname);</para>
        /// </summary>
        public static uint GetHandleARB(uint pname) {
            return GLNative.glGetHandleARB(pname);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_shader_objects</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glDetachObjectARB(GLhandleARB containerObj, GLhandleARB attachedObj);</para>
        /// </summary>
        public static void DetachObjectARB(uint containerObj, uint attachedObj) {
            GLNative.glDetachObjectARB(containerObj, attachedObj);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_shader_objects</para>
        /// Supported: <para>gl</para>
        /// Original: <para>GLhandleARB glCreateShaderObjectARB(GLenum shaderType);</para>
        /// </summary>
        public static uint CreateShaderObjectARB(uint shaderType) {
            return GLNative.glCreateShaderObjectARB(shaderType);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_shader_objects</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glCompileShaderARB(GLhandleARB shaderObj);</para>
        /// </summary>
        public static void CompileShaderARB(uint shaderObj) {
            GLNative.glCompileShaderARB(shaderObj);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_shader_objects</para>
        /// Supported: <para>gl</para>
        /// Original: <para>GLhandleARB glCreateProgramObjectARB();</para>
        /// </summary>
        public static uint CreateProgramObjectARB() {
            return GLNative.glCreateProgramObjectARB();
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_shader_objects</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glAttachObjectARB(GLhandleARB containerObj, GLhandleARB obj);</para>
        /// </summary>
        public static void AttachObjectARB(uint containerObj, uint obj) {
            GLNative.glAttachObjectARB(containerObj, obj);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_shader_objects</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glLinkProgramARB(GLhandleARB programObj);</para>
        /// </summary>
        public static void LinkProgramARB(uint programObj) {
            GLNative.glLinkProgramARB(programObj);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_shader_objects</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glUseProgramObjectARB(GLhandleARB programObj);</para>
        /// </summary>
        public static void UseProgramObjectARB(uint programObj) {
            GLNative.glUseProgramObjectARB(programObj);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_shader_objects</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glValidateProgramARB(GLhandleARB programObj);</para>
        /// </summary>
        public static void ValidateProgramARB(uint programObj) {
            GLNative.glValidateProgramARB(programObj);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_shader_objects</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glUniform1fARB(GLint location, GLfloat v0);</para>
        /// </summary>
        public static void Uniform1fARB(int location, float v0) {
            GLNative.glUniform1fARB(location, v0);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_shader_objects</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glUniform2fARB(GLint location, GLfloat v0, GLfloat v1);</para>
        /// </summary>
        public static void Uniform2fARB(int location, float v0, float v1) {
            GLNative.glUniform2fARB(location, v0, v1);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_shader_objects</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glUniform3fARB(GLint location, GLfloat v0, GLfloat v1, GLfloat v2);</para>
        /// </summary>
        public static void Uniform3fARB(int location, float v0, float v1, float v2) {
            GLNative.glUniform3fARB(location, v0, v1, v2);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_shader_objects</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glUniform4fARB(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3);</para>
        /// </summary>
        public static void Uniform4fARB(int location, float v0, float v1, float v2, float v3) {
            GLNative.glUniform4fARB(location, v0, v1, v2, v3);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_shader_objects</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glUniform1iARB(GLint location, GLint v0);</para>
        /// </summary>
        public static void Uniform1iARB(int location, int v0) {
            GLNative.glUniform1iARB(location, v0);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_shader_objects</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glUniform2iARB(GLint location, GLint v0, GLint v1);</para>
        /// </summary>
        public static void Uniform2iARB(int location, int v0, int v1) {
            GLNative.glUniform2iARB(location, v0, v1);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_shader_objects</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glUniform3iARB(GLint location, GLint v0, GLint v1, GLint v2);</para>
        /// </summary>
        public static void Uniform3iARB(int location, int v0, int v1, int v2) {
            GLNative.glUniform3iARB(location, v0, v1, v2);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_shader_objects</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glUniform4iARB(GLint location, GLint v0, GLint v1, GLint v2, GLint v3);</para>
        /// </summary>
        public static void Uniform4iARB(int location, int v0, int v1, int v2, int v3) {
            GLNative.glUniform4iARB(location, v0, v1, v2, v3);
        }


        #endregion GL_ARB_shader_objects

        #region GL_ARB_shader_storage_buffer_object

        // void glShaderStorageBlockBinding(GLuint program, GLuint storageBlockIndex, GLuint storageBlockBinding);

        #endregion GL_ARB_shader_storage_buffer_object

        #region GL_ARB_shader_subroutine


        #endregion GL_ARB_shader_subroutine

        #region GL_ARB_shading_language_include


        #endregion GL_ARB_shading_language_include

        #region GL_ARB_sparse_buffer

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_sparse_buffer</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glBufferPageCommitmentARB(GLenum target, GLintptr offset, GLsizeiptr size, GLboolean commit);</para>
        /// </summary>
        public static void BufferPageCommitmentARB(uint target, IntPtr offset, IntPtr size, bool commit) {
            GLNative.glBufferPageCommitmentARB(target, offset, size, commit);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_sparse_buffer</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glNamedBufferPageCommitmentEXT(GLuint buffer, GLintptr offset, GLsizeiptr size, GLboolean commit);</para>
        /// </summary>
        public static void NamedBufferPageCommitmentEXT(uint buffer, IntPtr offset, IntPtr size, bool commit) {
            GLNative.glNamedBufferPageCommitmentEXT(buffer, offset, size, commit);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_sparse_buffer</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glNamedBufferPageCommitmentARB(GLuint buffer, GLintptr offset, GLsizeiptr size, GLboolean commit);</para>
        /// </summary>
        public static void NamedBufferPageCommitmentARB(uint buffer, IntPtr offset, IntPtr size, bool commit) {
            GLNative.glNamedBufferPageCommitmentARB(buffer, offset, size, commit);
        }


        #endregion GL_ARB_sparse_buffer

        #region GL_ARB_sparse_texture

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_sparse_texture</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glTexPageCommitmentARB(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLboolean commit);</para>
        /// </summary>
        public static void TexPageCommitmentARB(uint target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, bool commit) {
            GLNative.glTexPageCommitmentARB(target, level, xoffset, yoffset, zoffset, width, height, depth, commit);
        }


        #endregion GL_ARB_sparse_texture

        #region GL_ARB_sync

        // GLsync glFenceSync(GLenum condition, GLbitfield flags);
        // GLboolean glIsSync(GLsync sync);
        // void glDeleteSync(GLsync sync);
        // GLenum glClientWaitSync(GLsync sync, GLbitfield flags, GLuint64 timeout);
        // void glWaitSync(GLsync sync, GLbitfield flags, GLuint64 timeout);

        #endregion GL_ARB_sync

        #region GL_ARB_tessellation_shader

        // void glPatchParameteri(GLenum pname, GLint value);

        #endregion GL_ARB_tessellation_shader

        #region GL_ARB_texture_barrier

        // void glTextureBarrier();

        #endregion GL_ARB_texture_barrier

        #region GL_ARB_texture_buffer_object

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_texture_buffer_object</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glTexBufferARB(GLenum target, GLenum internalformat, GLuint buffer);</para>
        /// </summary>
        public static void TexBufferARB(uint target, uint internalformat, uint buffer) {
            GLNative.glTexBufferARB(target, internalformat, buffer);
        }


        #endregion GL_ARB_texture_buffer_object

        #region GL_ARB_texture_buffer_range

        // void glTexBufferRange(GLenum target, GLenum internalformat, GLuint buffer, GLintptr offset, GLsizeiptr size);

        #endregion GL_ARB_texture_buffer_range

        #region GL_ARB_texture_compression


        #endregion GL_ARB_texture_compression

        #region GL_ARB_texture_multisample

        // void glTexImage2DMultisample(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations);
        // void glTexImage3DMultisample(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations);
        // void glSampleMaski(GLuint maskNumber, GLbitfield mask);

        #endregion GL_ARB_texture_multisample

        #region GL_ARB_texture_storage

        // void glTexStorage1D(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width);
        // void glTexStorage2D(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height);
        // void glTexStorage3D(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth);

        #endregion GL_ARB_texture_storage

        #region GL_ARB_texture_storage_multisample

        // void glTexStorage2DMultisample(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations);
        // void glTexStorage3DMultisample(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations);

        #endregion GL_ARB_texture_storage_multisample

        #region GL_ARB_texture_view

        // void glTextureView(GLuint texture, GLenum target, GLuint origtexture, GLenum internalformat, GLuint minlevel, GLuint numlevels, GLuint minlayer, GLuint numlayers);

        #endregion GL_ARB_texture_view

        #region GL_ARB_timer_query

        // void glQueryCounter(GLuint id, GLenum target);

        #endregion GL_ARB_timer_query

        #region GL_ARB_transform_feedback2

        // void glBindTransformFeedback(GLenum target, GLuint id);
        // GLboolean glIsTransformFeedback(GLuint id);
        // void glPauseTransformFeedback();
        // void glResumeTransformFeedback();
        // void glDrawTransformFeedback(GLenum mode, GLuint id);

        #endregion GL_ARB_transform_feedback2

        #region GL_ARB_transform_feedback3

        // void glDrawTransformFeedbackStream(GLenum mode, GLuint id, GLuint stream);
        // void glBeginQueryIndexed(GLenum target, GLuint index, GLuint id);
        // void glEndQueryIndexed(GLenum target, GLuint index);

        #endregion GL_ARB_transform_feedback3

        #region GL_ARB_transform_feedback_instanced

        // void glDrawTransformFeedbackInstanced(GLenum mode, GLuint id, GLsizei instancecount);
        // void glDrawTransformFeedbackStreamInstanced(GLenum mode, GLuint id, GLuint stream, GLsizei instancecount);

        #endregion GL_ARB_transform_feedback_instanced

        #region GL_ARB_transpose_matrix


        #endregion GL_ARB_transpose_matrix

        #region GL_ARB_uniform_buffer_object

        // void glUniformBlockBinding(GLuint program, GLuint uniformBlockIndex, GLuint uniformBlockBinding);
        // void glBindBufferRange(GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size);
        // void glBindBufferBase(GLenum target, GLuint index, GLuint buffer);

        #endregion GL_ARB_uniform_buffer_object

        #region GL_ARB_vertex_array_object

        // void glBindVertexArray(GLuint array);
        // GLboolean glIsVertexArray(GLuint array);

        #endregion GL_ARB_vertex_array_object

        #region GL_ARB_vertex_attrib_64bit

        // void glVertexAttribL1d(GLuint index, GLdouble v0);
        // void glVertexAttribL2d(GLuint index, GLdouble v0, GLdouble v1);
        // void glVertexAttribL3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2);
        // void glVertexAttribL4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3);

        #endregion GL_ARB_vertex_attrib_64bit

        #region GL_ARB_vertex_attrib_binding

        // void glBindVertexBuffer(GLuint bindingindex, GLuint buffer, GLintptr offset, GLsizei stride);
        // void glVertexAttribFormat(GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset);
        // void glVertexAttribIFormat(GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset);
        // void glVertexAttribLFormat(GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset);
        // void glVertexAttribBinding(GLuint attribindex, GLuint bindingindex);
        // void glVertexBindingDivisor(GLuint bindingindex, GLuint divisor);

        #endregion GL_ARB_vertex_attrib_binding

        #region GL_ARB_vertex_blend

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_vertex_blend</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexBlendARB(GLint count);</para>
        /// </summary>
        public static void VertexBlendARB(int count) {
            GLNative.glVertexBlendARB(count);
        }


        #endregion GL_ARB_vertex_blend

        #region GL_ARB_vertex_buffer_object

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_vertex_buffer_object</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glBindBufferARB(GLenum target, GLuint buffer);</para>
        /// </summary>
        public static void BindBufferARB(uint target, uint buffer) {
            GLNative.glBindBufferARB(target, buffer);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_vertex_buffer_object</para>
        /// Supported: <para>gl</para>
        /// Original: <para>GLboolean glIsBufferARB(GLuint buffer);</para>
        /// </summary>
        public static bool IsBufferARB(uint buffer) {
            return GLNative.glIsBufferARB(buffer);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_vertex_buffer_object</para>
        /// Supported: <para>gl</para>
        /// Original: <para>GLboolean glUnmapBufferARB(GLenum target);</para>
        /// </summary>
        public static bool UnmapBufferARB(uint target) {
            return GLNative.glUnmapBufferARB(target);
        }


        #endregion GL_ARB_vertex_buffer_object

        #region GL_ARB_vertex_program

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_vertex_program, GL_ARB_vertex_shader</para>
        /// Supported: <para>gl, gl</para>
        /// Original: <para>void glVertexAttrib1dARB(GLuint index, GLdouble x);</para>
        /// </summary>
        public static void VertexAttrib1dARB(uint index, double x) {
            GLNative.glVertexAttrib1dARB(index, x);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_vertex_program, GL_ARB_vertex_shader</para>
        /// Supported: <para>gl, gl</para>
        /// Original: <para>void glVertexAttrib1fARB(GLuint index, GLfloat x);</para>
        /// </summary>
        public static void VertexAttrib1fARB(uint index, float x) {
            GLNative.glVertexAttrib1fARB(index, x);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_vertex_program, GL_ARB_vertex_shader</para>
        /// Supported: <para>gl, gl</para>
        /// Original: <para>void glVertexAttrib1sARB(GLuint index, GLshort x);</para>
        /// </summary>
        public static void VertexAttrib1sARB(uint index, short x) {
            GLNative.glVertexAttrib1sARB(index, x);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_vertex_program, GL_ARB_vertex_shader</para>
        /// Supported: <para>gl, gl</para>
        /// Original: <para>void glVertexAttrib2dARB(GLuint index, GLdouble x, GLdouble y);</para>
        /// </summary>
        public static void VertexAttrib2dARB(uint index, double x, double y) {
            GLNative.glVertexAttrib2dARB(index, x, y);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_vertex_program, GL_ARB_vertex_shader</para>
        /// Supported: <para>gl, gl</para>
        /// Original: <para>void glVertexAttrib2fARB(GLuint index, GLfloat x, GLfloat y);</para>
        /// </summary>
        public static void VertexAttrib2fARB(uint index, float x, float y) {
            GLNative.glVertexAttrib2fARB(index, x, y);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_vertex_program, GL_ARB_vertex_shader</para>
        /// Supported: <para>gl, gl</para>
        /// Original: <para>void glVertexAttrib2sARB(GLuint index, GLshort x, GLshort y);</para>
        /// </summary>
        public static void VertexAttrib2sARB(uint index, short x, short y) {
            GLNative.glVertexAttrib2sARB(index, x, y);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_vertex_program, GL_ARB_vertex_shader</para>
        /// Supported: <para>gl, gl</para>
        /// Original: <para>void glVertexAttrib3dARB(GLuint index, GLdouble x, GLdouble y, GLdouble z);</para>
        /// </summary>
        public static void VertexAttrib3dARB(uint index, double x, double y, double z) {
            GLNative.glVertexAttrib3dARB(index, x, y, z);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_vertex_program, GL_ARB_vertex_shader</para>
        /// Supported: <para>gl, gl</para>
        /// Original: <para>void glVertexAttrib3fARB(GLuint index, GLfloat x, GLfloat y, GLfloat z);</para>
        /// </summary>
        public static void VertexAttrib3fARB(uint index, float x, float y, float z) {
            GLNative.glVertexAttrib3fARB(index, x, y, z);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_vertex_program, GL_ARB_vertex_shader</para>
        /// Supported: <para>gl, gl</para>
        /// Original: <para>void glVertexAttrib3sARB(GLuint index, GLshort x, GLshort y, GLshort z);</para>
        /// </summary>
        public static void VertexAttrib3sARB(uint index, short x, short y, short z) {
            GLNative.glVertexAttrib3sARB(index, x, y, z);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_vertex_program, GL_ARB_vertex_shader</para>
        /// Supported: <para>gl, gl</para>
        /// Original: <para>void glVertexAttrib4NubARB(GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w);</para>
        /// </summary>
        public static void VertexAttrib4NubARB(uint index, byte x, byte y, byte z, byte w) {
            GLNative.glVertexAttrib4NubARB(index, x, y, z, w);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_vertex_program, GL_ARB_vertex_shader</para>
        /// Supported: <para>gl, gl</para>
        /// Original: <para>void glVertexAttrib4dARB(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);</para>
        /// </summary>
        public static void VertexAttrib4dARB(uint index, double x, double y, double z, double w) {
            GLNative.glVertexAttrib4dARB(index, x, y, z, w);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_vertex_program, GL_ARB_vertex_shader</para>
        /// Supported: <para>gl, gl</para>
        /// Original: <para>void glVertexAttrib4fARB(GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);</para>
        /// </summary>
        public static void VertexAttrib4fARB(uint index, float x, float y, float z, float w) {
            GLNative.glVertexAttrib4fARB(index, x, y, z, w);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_vertex_program, GL_ARB_vertex_shader</para>
        /// Supported: <para>gl, gl</para>
        /// Original: <para>void glVertexAttrib4sARB(GLuint index, GLshort x, GLshort y, GLshort z, GLshort w);</para>
        /// </summary>
        public static void VertexAttrib4sARB(uint index, short x, short y, short z, short w) {
            GLNative.glVertexAttrib4sARB(index, x, y, z, w);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_vertex_program, GL_ARB_vertex_shader</para>
        /// Supported: <para>gl, gl</para>
        /// Original: <para>void glEnableVertexAttribArrayARB(GLuint index);</para>
        /// </summary>
        public static void EnableVertexAttribArrayARB(uint index) {
            GLNative.glEnableVertexAttribArrayARB(index);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_vertex_program, GL_ARB_vertex_shader</para>
        /// Supported: <para>gl, gl</para>
        /// Original: <para>void glDisableVertexAttribArrayARB(GLuint index);</para>
        /// </summary>
        public static void DisableVertexAttribArrayARB(uint index) {
            GLNative.glDisableVertexAttribArrayARB(index);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_fragment_program, GL_ARB_vertex_program</para>
        /// Supported: <para>gl, gl</para>
        /// Original: <para>void glBindProgramARB(GLenum target, GLuint program);</para>
        /// </summary>
        public static void BindProgramARB(uint target, uint program) {
            GLNative.glBindProgramARB(target, program);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_fragment_program, GL_ARB_vertex_program</para>
        /// Supported: <para>gl, gl</para>
        /// Original: <para>void glProgramEnvParameter4dARB(GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);</para>
        /// </summary>
        public static void ProgramEnvParameter4dARB(uint target, uint index, double x, double y, double z, double w) {
            GLNative.glProgramEnvParameter4dARB(target, index, x, y, z, w);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_fragment_program, GL_ARB_vertex_program</para>
        /// Supported: <para>gl, gl</para>
        /// Original: <para>void glProgramEnvParameter4fARB(GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);</para>
        /// </summary>
        public static void ProgramEnvParameter4fARB(uint target, uint index, float x, float y, float z, float w) {
            GLNative.glProgramEnvParameter4fARB(target, index, x, y, z, w);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_fragment_program, GL_ARB_vertex_program</para>
        /// Supported: <para>gl, gl</para>
        /// Original: <para>void glProgramLocalParameter4dARB(GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);</para>
        /// </summary>
        public static void ProgramLocalParameter4dARB(uint target, uint index, double x, double y, double z, double w) {
            GLNative.glProgramLocalParameter4dARB(target, index, x, y, z, w);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_fragment_program, GL_ARB_vertex_program</para>
        /// Supported: <para>gl, gl</para>
        /// Original: <para>void glProgramLocalParameter4fARB(GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);</para>
        /// </summary>
        public static void ProgramLocalParameter4fARB(uint target, uint index, float x, float y, float z, float w) {
            GLNative.glProgramLocalParameter4fARB(target, index, x, y, z, w);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_fragment_program, GL_ARB_vertex_program</para>
        /// Supported: <para>gl, gl</para>
        /// Original: <para>GLboolean glIsProgramARB(GLuint program);</para>
        /// </summary>
        public static bool IsProgramARB(uint program) {
            return GLNative.glIsProgramARB(program);
        }


        #endregion GL_ARB_vertex_program

        #region GL_ARB_vertex_shader

        // void glVertexAttrib1fARB(GLuint index, GLfloat x);
        // void glVertexAttrib1sARB(GLuint index, GLshort x);
        // void glVertexAttrib1dARB(GLuint index, GLdouble x);
        // void glVertexAttrib2fARB(GLuint index, GLfloat x, GLfloat y);
        // void glVertexAttrib2sARB(GLuint index, GLshort x, GLshort y);
        // void glVertexAttrib2dARB(GLuint index, GLdouble x, GLdouble y);
        // void glVertexAttrib3fARB(GLuint index, GLfloat x, GLfloat y, GLfloat z);
        // void glVertexAttrib3sARB(GLuint index, GLshort x, GLshort y, GLshort z);
        // void glVertexAttrib3dARB(GLuint index, GLdouble x, GLdouble y, GLdouble z);
        // void glVertexAttrib4fARB(GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
        // void glVertexAttrib4sARB(GLuint index, GLshort x, GLshort y, GLshort z, GLshort w);
        // void glVertexAttrib4dARB(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
        // void glVertexAttrib4NubARB(GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w);
        // void glEnableVertexAttribArrayARB(GLuint index);
        // void glDisableVertexAttribArrayARB(GLuint index);

        #endregion GL_ARB_vertex_shader

        #region GL_ARB_vertex_type_2_10_10_10_rev

        // void glVertexAttribP1ui(GLuint index, GLenum type, GLboolean normalized, GLuint value);
        // void glVertexAttribP2ui(GLuint index, GLenum type, GLboolean normalized, GLuint value);
        // void glVertexAttribP3ui(GLuint index, GLenum type, GLboolean normalized, GLuint value);
        // void glVertexAttribP4ui(GLuint index, GLenum type, GLboolean normalized, GLuint value);
        // void glVertexP2ui(GLenum type, GLuint value);
        // void glVertexP3ui(GLenum type, GLuint value);
        // void glVertexP4ui(GLenum type, GLuint value);
        // void glTexCoordP1ui(GLenum type, GLuint coords);
        // void glTexCoordP2ui(GLenum type, GLuint coords);
        // void glTexCoordP3ui(GLenum type, GLuint coords);
        // void glTexCoordP4ui(GLenum type, GLuint coords);
        // void glMultiTexCoordP1ui(GLenum texture, GLenum type, GLuint coords);
        // void glMultiTexCoordP2ui(GLenum texture, GLenum type, GLuint coords);
        // void glMultiTexCoordP3ui(GLenum texture, GLenum type, GLuint coords);
        // void glMultiTexCoordP4ui(GLenum texture, GLenum type, GLuint coords);
        // void glNormalP3ui(GLenum type, GLuint coords);
        // void glColorP3ui(GLenum type, GLuint color);
        // void glColorP4ui(GLenum type, GLuint color);
        // void glSecondaryColorP3ui(GLenum type, GLuint color);

        #endregion GL_ARB_vertex_type_2_10_10_10_rev

        #region GL_ARB_viewport_array

        // void glViewportIndexedf(GLuint index, GLfloat x, GLfloat y, GLfloat w, GLfloat h);
        // void glScissorIndexed(GLuint index, GLint left, GLint bottom, GLsizei width, GLsizei height);
        // void glDepthRangeIndexed(GLuint index, GLdouble nearVal, GLdouble farVal);
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_viewport_array</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glDepthRangeIndexeddNV(GLuint index, GLdouble n, GLdouble f);</para>
        /// </summary>
        public static void DepthRangeIndexeddNV(uint index, double n, double f) {
            GLNative.glDepthRangeIndexeddNV(index, n, f);
        }


        #endregion GL_ARB_viewport_array

        #region GL_ARB_window_pos

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_window_pos</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glWindowPos2dARB(GLdouble x, GLdouble y);</para>
        /// </summary>
        public static void WindowPos2dARB(double x, double y) {
            GLNative.glWindowPos2dARB(x, y);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_window_pos</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glWindowPos2fARB(GLfloat x, GLfloat y);</para>
        /// </summary>
        public static void WindowPos2fARB(float x, float y) {
            GLNative.glWindowPos2fARB(x, y);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_window_pos</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glWindowPos2iARB(GLint x, GLint y);</para>
        /// </summary>
        public static void WindowPos2iARB(int x, int y) {
            GLNative.glWindowPos2iARB(x, y);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_window_pos</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glWindowPos2sARB(GLshort x, GLshort y);</para>
        /// </summary>
        public static void WindowPos2sARB(short x, short y) {
            GLNative.glWindowPos2sARB(x, y);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_window_pos</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glWindowPos3dARB(GLdouble x, GLdouble y, GLdouble z);</para>
        /// </summary>
        public static void WindowPos3dARB(double x, double y, double z) {
            GLNative.glWindowPos3dARB(x, y, z);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_window_pos</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glWindowPos3fARB(GLfloat x, GLfloat y, GLfloat z);</para>
        /// </summary>
        public static void WindowPos3fARB(float x, float y, float z) {
            GLNative.glWindowPos3fARB(x, y, z);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_window_pos</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glWindowPos3iARB(GLint x, GLint y, GLint z);</para>
        /// </summary>
        public static void WindowPos3iARB(int x, int y, int z) {
            GLNative.glWindowPos3iARB(x, y, z);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_window_pos</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glWindowPos3sARB(GLshort x, GLshort y, GLshort z);</para>
        /// </summary>
        public static void WindowPos3sARB(short x, short y, short z) {
            GLNative.glWindowPos3sARB(x, y, z);
        }


        #endregion GL_ARB_window_pos

        #region GL_ATI_draw_buffers


        #endregion GL_ATI_draw_buffers

        #region GL_ATI_element_array

        /// <summary>
        /// <para>Require:</para> <para>GL_ATI_element_array</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glDrawElementArrayATI(GLenum mode, GLsizei count);</para>
        /// </summary>
        public static void DrawElementArrayATI(uint mode, int count) {
            GLNative.glDrawElementArrayATI(mode, count);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ATI_element_array</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glDrawRangeElementArrayATI(GLenum mode, GLuint start, GLuint end, GLsizei count);</para>
        /// </summary>
        public static void DrawRangeElementArrayATI(uint mode, uint start, uint end, int count) {
            GLNative.glDrawRangeElementArrayATI(mode, start, end, count);
        }


        #endregion GL_ATI_element_array

        #region GL_ATI_envmap_bumpmap


        #endregion GL_ATI_envmap_bumpmap

        #region GL_ATI_fragment_shader

        /// <summary>
        /// <para>Require:</para> <para>GL_ATI_fragment_shader</para>
        /// Supported: <para>gl</para>
        /// Original: <para>GLuint glGenFragmentShadersATI(GLuint range);</para>
        /// </summary>
        public static uint GenFragmentShadersATI(uint range) {
            return GLNative.glGenFragmentShadersATI(range);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ATI_fragment_shader</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glBindFragmentShaderATI(GLuint id);</para>
        /// </summary>
        public static void BindFragmentShaderATI(uint id) {
            GLNative.glBindFragmentShaderATI(id);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ATI_fragment_shader</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glDeleteFragmentShaderATI(GLuint id);</para>
        /// </summary>
        public static void DeleteFragmentShaderATI(uint id) {
            GLNative.glDeleteFragmentShaderATI(id);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ATI_fragment_shader</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glBeginFragmentShaderATI();</para>
        /// </summary>
        public static void BeginFragmentShaderATI() {
            GLNative.glBeginFragmentShaderATI();
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ATI_fragment_shader</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glEndFragmentShaderATI();</para>
        /// </summary>
        public static void EndFragmentShaderATI() {
            GLNative.glEndFragmentShaderATI();
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ATI_fragment_shader</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glPassTexCoordATI(GLuint dst, GLuint coord, GLenum swizzle);</para>
        /// </summary>
        public static void PassTexCoordATI(uint dst, uint coord, uint swizzle) {
            GLNative.glPassTexCoordATI(dst, coord, swizzle);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ATI_fragment_shader</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glSampleMapATI(GLuint dst, GLuint interp, GLenum swizzle);</para>
        /// </summary>
        public static void SampleMapATI(uint dst, uint interp, uint swizzle) {
            GLNative.glSampleMapATI(dst, interp, swizzle);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ATI_fragment_shader</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glColorFragmentOp1ATI(GLenum op, GLuint dst, GLuint dstMask, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod);</para>
        /// </summary>
        public static void ColorFragmentOp1ATI(uint op, uint dst, uint dstMask, uint dstMod, uint arg1, uint arg1Rep, uint arg1Mod) {
            GLNative.glColorFragmentOp1ATI(op, dst, dstMask, dstMod, arg1, arg1Rep, arg1Mod);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ATI_fragment_shader</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glColorFragmentOp2ATI(GLenum op, GLuint dst, GLuint dstMask, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod);</para>
        /// </summary>
        public static void ColorFragmentOp2ATI(uint op, uint dst, uint dstMask, uint dstMod, uint arg1, uint arg1Rep, uint arg1Mod, uint arg2, uint arg2Rep, uint arg2Mod) {
            GLNative.glColorFragmentOp2ATI(op, dst, dstMask, dstMod, arg1, arg1Rep, arg1Mod, arg2, arg2Rep, arg2Mod);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ATI_fragment_shader</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glColorFragmentOp3ATI(GLenum op, GLuint dst, GLuint dstMask, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod, GLuint arg3, GLuint arg3Rep, GLuint arg3Mod);</para>
        /// </summary>
        public static void ColorFragmentOp3ATI(uint op, uint dst, uint dstMask, uint dstMod, uint arg1, uint arg1Rep, uint arg1Mod, uint arg2, uint arg2Rep, uint arg2Mod, uint arg3, uint arg3Rep, uint arg3Mod) {
            GLNative.glColorFragmentOp3ATI(op, dst, dstMask, dstMod, arg1, arg1Rep, arg1Mod, arg2, arg2Rep, arg2Mod, arg3, arg3Rep, arg3Mod);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ATI_fragment_shader</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glAlphaFragmentOp1ATI(GLenum op, GLuint dst, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod);</para>
        /// </summary>
        public static void AlphaFragmentOp1ATI(uint op, uint dst, uint dstMod, uint arg1, uint arg1Rep, uint arg1Mod) {
            GLNative.glAlphaFragmentOp1ATI(op, dst, dstMod, arg1, arg1Rep, arg1Mod);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ATI_fragment_shader</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glAlphaFragmentOp2ATI(GLenum op, GLuint dst, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod);</para>
        /// </summary>
        public static void AlphaFragmentOp2ATI(uint op, uint dst, uint dstMod, uint arg1, uint arg1Rep, uint arg1Mod, uint arg2, uint arg2Rep, uint arg2Mod) {
            GLNative.glAlphaFragmentOp2ATI(op, dst, dstMod, arg1, arg1Rep, arg1Mod, arg2, arg2Rep, arg2Mod);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ATI_fragment_shader</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glAlphaFragmentOp3ATI(GLenum op, GLuint dst, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod, GLuint arg3, GLuint arg3Rep, GLuint arg3Mod);</para>
        /// </summary>
        public static void AlphaFragmentOp3ATI(uint op, uint dst, uint dstMod, uint arg1, uint arg1Rep, uint arg1Mod, uint arg2, uint arg2Rep, uint arg2Mod, uint arg3, uint arg3Rep, uint arg3Mod) {
            GLNative.glAlphaFragmentOp3ATI(op, dst, dstMod, arg1, arg1Rep, arg1Mod, arg2, arg2Rep, arg2Mod, arg3, arg3Rep, arg3Mod);
        }


        #endregion GL_ATI_fragment_shader

        #region GL_ATI_map_object_buffer

        /// <summary>
        /// <para>Require:</para> <para>GL_ATI_map_object_buffer</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glUnmapObjectBufferATI(GLuint buffer);</para>
        /// </summary>
        public static void UnmapObjectBufferATI(uint buffer) {
            GLNative.glUnmapObjectBufferATI(buffer);
        }


        #endregion GL_ATI_map_object_buffer

        #region GL_ATI_pn_triangles

        /// <summary>
        /// <para>Require:</para> <para>GL_ATI_pn_triangles</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glPNTrianglesiATI(GLenum pname, GLint param);</para>
        /// </summary>
        public static void PNTrianglesiATI(uint pname, int param) {
            GLNative.glPNTrianglesiATI(pname, param);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ATI_pn_triangles</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glPNTrianglesfATI(GLenum pname, GLfloat param);</para>
        /// </summary>
        public static void PNTrianglesfATI(uint pname, float param) {
            GLNative.glPNTrianglesfATI(pname, param);
        }


        #endregion GL_ATI_pn_triangles

        #region GL_ATI_separate_stencil

        /// <summary>
        /// <para>Require:</para> <para>GL_ATI_separate_stencil</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glStencilOpSeparateATI(GLenum face, GLenum sfail, GLenum dpfail, GLenum dppass);</para>
        /// </summary>
        public static void StencilOpSeparateATI(uint face, uint sfail, uint dpfail, uint dppass) {
            GLNative.glStencilOpSeparateATI(face, sfail, dpfail, dppass);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ATI_separate_stencil</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glStencilFuncSeparateATI(GLenum frontfunc, GLenum backfunc, GLint ref, GLuint mask);</para>
        /// </summary>
        public static void StencilFuncSeparateATI(uint frontfunc, uint backfunc, int r, uint mask) {
            GLNative.glStencilFuncSeparateATI(frontfunc, backfunc, r, mask);
        }


        #endregion GL_ATI_separate_stencil

        #region GL_ATI_vertex_array_object

        /// <summary>
        /// <para>Require:</para> <para>GL_ATI_vertex_array_object</para>
        /// Supported: <para>gl</para>
        /// Original: <para>GLboolean glIsObjectBufferATI(GLuint buffer);</para>
        /// </summary>
        public static bool IsObjectBufferATI(uint buffer) {
            return GLNative.glIsObjectBufferATI(buffer);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ATI_vertex_array_object</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glFreeObjectBufferATI(GLuint buffer);</para>
        /// </summary>
        public static void FreeObjectBufferATI(uint buffer) {
            GLNative.glFreeObjectBufferATI(buffer);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ATI_vertex_array_object</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glArrayObjectATI(GLenum array, GLint size, GLenum type, GLsizei stride, GLuint buffer, GLuint offset);</para>
        /// </summary>
        public static void ArrayObjectATI(uint array, int size, uint type, int stride, uint buffer, uint offset) {
            GLNative.glArrayObjectATI(array, size, type, stride, buffer, offset);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ATI_vertex_array_object</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVariantArrayObjectATI(GLuint id, GLenum type, GLsizei stride, GLuint buffer, GLuint offset);</para>
        /// </summary>
        public static void VariantArrayObjectATI(uint id, uint type, int stride, uint buffer, uint offset) {
            GLNative.glVariantArrayObjectATI(id, type, stride, buffer, offset);
        }


        #endregion GL_ATI_vertex_array_object

        #region GL_ATI_vertex_attrib_array_object

        /// <summary>
        /// <para>Require:</para> <para>GL_ATI_vertex_attrib_array_object</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexAttribArrayObjectATI(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, GLuint buffer, GLuint offset);</para>
        /// </summary>
        public static void VertexAttribArrayObjectATI(uint index, int size, uint type, bool normalized, int stride, uint buffer, uint offset) {
            GLNative.glVertexAttribArrayObjectATI(index, size, type, normalized, stride, buffer, offset);
        }


        #endregion GL_ATI_vertex_attrib_array_object

        #region GL_ATI_vertex_streams

        /// <summary>
        /// <para>Require:</para> <para>GL_ATI_vertex_streams</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexStream1sATI(GLenum stream, GLshort x);</para>
        /// </summary>
        public static void VertexStream1sATI(uint stream, short x) {
            GLNative.glVertexStream1sATI(stream, x);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ATI_vertex_streams</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexStream1iATI(GLenum stream, GLint x);</para>
        /// </summary>
        public static void VertexStream1iATI(uint stream, int x) {
            GLNative.glVertexStream1iATI(stream, x);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ATI_vertex_streams</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexStream1fATI(GLenum stream, GLfloat x);</para>
        /// </summary>
        public static void VertexStream1fATI(uint stream, float x) {
            GLNative.glVertexStream1fATI(stream, x);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ATI_vertex_streams</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexStream1dATI(GLenum stream, GLdouble x);</para>
        /// </summary>
        public static void VertexStream1dATI(uint stream, double x) {
            GLNative.glVertexStream1dATI(stream, x);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ATI_vertex_streams</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexStream2sATI(GLenum stream, GLshort x, GLshort y);</para>
        /// </summary>
        public static void VertexStream2sATI(uint stream, short x, short y) {
            GLNative.glVertexStream2sATI(stream, x, y);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ATI_vertex_streams</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexStream2iATI(GLenum stream, GLint x, GLint y);</para>
        /// </summary>
        public static void VertexStream2iATI(uint stream, int x, int y) {
            GLNative.glVertexStream2iATI(stream, x, y);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ATI_vertex_streams</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexStream2fATI(GLenum stream, GLfloat x, GLfloat y);</para>
        /// </summary>
        public static void VertexStream2fATI(uint stream, float x, float y) {
            GLNative.glVertexStream2fATI(stream, x, y);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ATI_vertex_streams</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexStream2dATI(GLenum stream, GLdouble x, GLdouble y);</para>
        /// </summary>
        public static void VertexStream2dATI(uint stream, double x, double y) {
            GLNative.glVertexStream2dATI(stream, x, y);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ATI_vertex_streams</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexStream3sATI(GLenum stream, GLshort x, GLshort y, GLshort z);</para>
        /// </summary>
        public static void VertexStream3sATI(uint stream, short x, short y, short z) {
            GLNative.glVertexStream3sATI(stream, x, y, z);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ATI_vertex_streams</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexStream3iATI(GLenum stream, GLint x, GLint y, GLint z);</para>
        /// </summary>
        public static void VertexStream3iATI(uint stream, int x, int y, int z) {
            GLNative.glVertexStream3iATI(stream, x, y, z);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ATI_vertex_streams</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexStream3fATI(GLenum stream, GLfloat x, GLfloat y, GLfloat z);</para>
        /// </summary>
        public static void VertexStream3fATI(uint stream, float x, float y, float z) {
            GLNative.glVertexStream3fATI(stream, x, y, z);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ATI_vertex_streams</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexStream3dATI(GLenum stream, GLdouble x, GLdouble y, GLdouble z);</para>
        /// </summary>
        public static void VertexStream3dATI(uint stream, double x, double y, double z) {
            GLNative.glVertexStream3dATI(stream, x, y, z);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ATI_vertex_streams</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexStream4sATI(GLenum stream, GLshort x, GLshort y, GLshort z, GLshort w);</para>
        /// </summary>
        public static void VertexStream4sATI(uint stream, short x, short y, short z, short w) {
            GLNative.glVertexStream4sATI(stream, x, y, z, w);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ATI_vertex_streams</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexStream4iATI(GLenum stream, GLint x, GLint y, GLint z, GLint w);</para>
        /// </summary>
        public static void VertexStream4iATI(uint stream, int x, int y, int z, int w) {
            GLNative.glVertexStream4iATI(stream, x, y, z, w);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ATI_vertex_streams</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexStream4fATI(GLenum stream, GLfloat x, GLfloat y, GLfloat z, GLfloat w);</para>
        /// </summary>
        public static void VertexStream4fATI(uint stream, float x, float y, float z, float w) {
            GLNative.glVertexStream4fATI(stream, x, y, z, w);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ATI_vertex_streams</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexStream4dATI(GLenum stream, GLdouble x, GLdouble y, GLdouble z, GLdouble w);</para>
        /// </summary>
        public static void VertexStream4dATI(uint stream, double x, double y, double z, double w) {
            GLNative.glVertexStream4dATI(stream, x, y, z, w);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ATI_vertex_streams</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glNormalStream3bATI(GLenum stream, GLbyte nx, GLbyte ny, GLbyte nz);</para>
        /// </summary>
        public static void NormalStream3bATI(uint stream, byte nx, byte ny, byte nz) {
            GLNative.glNormalStream3bATI(stream, nx, ny, nz);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ATI_vertex_streams</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glNormalStream3sATI(GLenum stream, GLshort nx, GLshort ny, GLshort nz);</para>
        /// </summary>
        public static void NormalStream3sATI(uint stream, short nx, short ny, short nz) {
            GLNative.glNormalStream3sATI(stream, nx, ny, nz);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ATI_vertex_streams</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glNormalStream3iATI(GLenum stream, GLint nx, GLint ny, GLint nz);</para>
        /// </summary>
        public static void NormalStream3iATI(uint stream, int nx, int ny, int nz) {
            GLNative.glNormalStream3iATI(stream, nx, ny, nz);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ATI_vertex_streams</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glNormalStream3fATI(GLenum stream, GLfloat nx, GLfloat ny, GLfloat nz);</para>
        /// </summary>
        public static void NormalStream3fATI(uint stream, float nx, float ny, float nz) {
            GLNative.glNormalStream3fATI(stream, nx, ny, nz);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ATI_vertex_streams</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glNormalStream3dATI(GLenum stream, GLdouble nx, GLdouble ny, GLdouble nz);</para>
        /// </summary>
        public static void NormalStream3dATI(uint stream, double nx, double ny, double nz) {
            GLNative.glNormalStream3dATI(stream, nx, ny, nz);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ATI_vertex_streams</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glClientActiveVertexStreamATI(GLenum stream);</para>
        /// </summary>
        public static void ClientActiveVertexStreamATI(uint stream) {
            GLNative.glClientActiveVertexStreamATI(stream);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ATI_vertex_streams</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexBlendEnviATI(GLenum pname, GLint param);</para>
        /// </summary>
        public static void VertexBlendEnviATI(uint pname, int param) {
            GLNative.glVertexBlendEnviATI(pname, param);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_ATI_vertex_streams</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexBlendEnvfATI(GLenum pname, GLfloat param);</para>
        /// </summary>
        public static void VertexBlendEnvfATI(uint pname, float param) {
            GLNative.glVertexBlendEnvfATI(pname, param);
        }


        #endregion GL_ATI_vertex_streams

        #region GL_EXT_EGL_image_storage


        #endregion GL_EXT_EGL_image_storage

        #region GL_EXT_bindable_uniform

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_bindable_uniform</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glUniformBufferEXT(GLuint program, GLint location, GLuint buffer);</para>
        /// </summary>
        public static void UniformBufferEXT(uint program, int location, uint buffer) {
            GLNative.glUniformBufferEXT(program, location, buffer);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_bindable_uniform</para>
        /// Supported: <para>gl</para>
        /// Original: <para>GLint glGetUniformBufferSizeEXT(GLuint program, GLint location);</para>
        /// </summary>
        public static int GetUniformBufferSizeEXT(uint program, int location) {
            return GLNative.glGetUniformBufferSizeEXT(program, location);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_bindable_uniform</para>
        /// Supported: <para>gl</para>
        /// Original: <para>GLintptr glGetUniformOffsetEXT(GLuint program, GLint location);</para>
        /// </summary>
        public static IntPtr GetUniformOffsetEXT(uint program, int location) {
            return GLNative.glGetUniformOffsetEXT(program, location);
        }


        #endregion GL_EXT_bindable_uniform

        #region GL_EXT_blend_color

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_blend_color</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glBlendColorEXT(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha);</para>
        /// </summary>
        public static void BlendColorEXT(float red, float green, float blue, float alpha) {
            GLNative.glBlendColorEXT(red, green, blue, alpha);
        }


        #endregion GL_EXT_blend_color

        #region GL_EXT_blend_equation_separate

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_blend_equation_separate</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glBlendEquationSeparateEXT(GLenum modeRGB, GLenum modeAlpha);</para>
        /// </summary>
        public static void BlendEquationSeparateEXT(uint modeRGB, uint modeAlpha) {
            GLNative.glBlendEquationSeparateEXT(modeRGB, modeAlpha);
        }


        #endregion GL_EXT_blend_equation_separate

        #region GL_EXT_blend_func_separate

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_blend_func_separate</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glBlendFuncSeparateEXT(GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha);</para>
        /// </summary>
        public static void BlendFuncSeparateEXT(uint sfactorRGB, uint dfactorRGB, uint sfactorAlpha, uint dfactorAlpha) {
            GLNative.glBlendFuncSeparateEXT(sfactorRGB, dfactorRGB, sfactorAlpha, dfactorAlpha);
        }


        #endregion GL_EXT_blend_func_separate

        #region GL_EXT_color_subtable

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_color_subtable</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glCopyColorSubTableEXT(GLenum target, GLsizei start, GLint x, GLint y, GLsizei width);</para>
        /// </summary>
        public static void CopyColorSubTableEXT(uint target, int start, int x, int y, int width) {
            GLNative.glCopyColorSubTableEXT(target, start, x, y, width);
        }


        #endregion GL_EXT_color_subtable

        #region GL_EXT_compiled_vertex_array

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_compiled_vertex_array</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glLockArraysEXT(GLint first, GLsizei count);</para>
        /// </summary>
        public static void LockArraysEXT(int first, int count) {
            GLNative.glLockArraysEXT(first, count);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_compiled_vertex_array</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glUnlockArraysEXT();</para>
        /// </summary>
        public static void UnlockArraysEXT() {
            GLNative.glUnlockArraysEXT();
        }


        #endregion GL_EXT_compiled_vertex_array

        #region GL_EXT_convolution

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_convolution</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glConvolutionParameterfEXT(GLenum target, GLenum pname, GLfloat params);</para>
        /// </summary>
        public static void ConvolutionParameterfEXT(uint target, uint pname, float ps) {
            GLNative.glConvolutionParameterfEXT(target, pname, ps);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_convolution</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glConvolutionParameteriEXT(GLenum target, GLenum pname, GLint params);</para>
        /// </summary>
        public static void ConvolutionParameteriEXT(uint target, uint pname, int ps) {
            GLNative.glConvolutionParameteriEXT(target, pname, ps);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_convolution</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glCopyConvolutionFilter1DEXT(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width);</para>
        /// </summary>
        public static void CopyConvolutionFilter1DEXT(uint target, uint internalformat, int x, int y, int width) {
            GLNative.glCopyConvolutionFilter1DEXT(target, internalformat, x, y, width);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_convolution</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glCopyConvolutionFilter2DEXT(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height);</para>
        /// </summary>
        public static void CopyConvolutionFilter2DEXT(uint target, uint internalformat, int x, int y, int width, int height) {
            GLNative.glCopyConvolutionFilter2DEXT(target, internalformat, x, y, width, height);
        }


        #endregion GL_EXT_convolution

        #region GL_EXT_coordinate_frame

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_coordinate_frame</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glTangent3bEXT(GLbyte tx, GLbyte ty, GLbyte tz);</para>
        /// </summary>
        public static void Tangent3bEXT(byte tx, byte ty, byte tz) {
            GLNative.glTangent3bEXT(tx, ty, tz);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_coordinate_frame</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glTangent3dEXT(GLdouble tx, GLdouble ty, GLdouble tz);</para>
        /// </summary>
        public static void Tangent3dEXT(double tx, double ty, double tz) {
            GLNative.glTangent3dEXT(tx, ty, tz);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_coordinate_frame</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glTangent3fEXT(GLfloat tx, GLfloat ty, GLfloat tz);</para>
        /// </summary>
        public static void Tangent3fEXT(float tx, float ty, float tz) {
            GLNative.glTangent3fEXT(tx, ty, tz);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_coordinate_frame</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glTangent3iEXT(GLint tx, GLint ty, GLint tz);</para>
        /// </summary>
        public static void Tangent3iEXT(int tx, int ty, int tz) {
            GLNative.glTangent3iEXT(tx, ty, tz);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_coordinate_frame</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glTangent3sEXT(GLshort tx, GLshort ty, GLshort tz);</para>
        /// </summary>
        public static void Tangent3sEXT(short tx, short ty, short tz) {
            GLNative.glTangent3sEXT(tx, ty, tz);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_coordinate_frame</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glBinormal3bEXT(GLbyte bx, GLbyte by, GLbyte bz);</para>
        /// </summary>
        public static void Binormal3bEXT(byte bx, byte by, byte bz) {
            GLNative.glBinormal3bEXT(bx, by, bz);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_coordinate_frame</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glBinormal3dEXT(GLdouble bx, GLdouble by, GLdouble bz);</para>
        /// </summary>
        public static void Binormal3dEXT(double bx, double by, double bz) {
            GLNative.glBinormal3dEXT(bx, by, bz);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_coordinate_frame</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glBinormal3fEXT(GLfloat bx, GLfloat by, GLfloat bz);</para>
        /// </summary>
        public static void Binormal3fEXT(float bx, float by, float bz) {
            GLNative.glBinormal3fEXT(bx, by, bz);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_coordinate_frame</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glBinormal3iEXT(GLint bx, GLint by, GLint bz);</para>
        /// </summary>
        public static void Binormal3iEXT(int bx, int by, int bz) {
            GLNative.glBinormal3iEXT(bx, by, bz);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_coordinate_frame</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glBinormal3sEXT(GLshort bx, GLshort by, GLshort bz);</para>
        /// </summary>
        public static void Binormal3sEXT(short bx, short by, short bz) {
            GLNative.glBinormal3sEXT(bx, by, bz);
        }


        #endregion GL_EXT_coordinate_frame

        #region GL_EXT_copy_texture

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_copy_texture</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glCopyTexImage1DEXT(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border);</para>
        /// </summary>
        public static void CopyTexImage1DEXT(uint target, int level, uint internalformat, int x, int y, int width, int border) {
            GLNative.glCopyTexImage1DEXT(target, level, internalformat, x, y, width, border);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_copy_texture</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glCopyTexImage2DEXT(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border);</para>
        /// </summary>
        public static void CopyTexImage2DEXT(uint target, int level, uint internalformat, int x, int y, int width, int height, int border) {
            GLNative.glCopyTexImage2DEXT(target, level, internalformat, x, y, width, height, border);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_copy_texture</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glCopyTexSubImage1DEXT(GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width);</para>
        /// </summary>
        public static void CopyTexSubImage1DEXT(uint target, int level, int xoffset, int x, int y, int width) {
            GLNative.glCopyTexSubImage1DEXT(target, level, xoffset, x, y, width);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_copy_texture</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glCopyTexSubImage2DEXT(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height);</para>
        /// </summary>
        public static void CopyTexSubImage2DEXT(uint target, int level, int xoffset, int yoffset, int x, int y, int width, int height) {
            GLNative.glCopyTexSubImage2DEXT(target, level, xoffset, yoffset, x, y, width, height);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_copy_texture</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glCopyTexSubImage3DEXT(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height);</para>
        /// </summary>
        public static void CopyTexSubImage3DEXT(uint target, int level, int xoffset, int yoffset, int zoffset, int x, int y, int width, int height) {
            GLNative.glCopyTexSubImage3DEXT(target, level, xoffset, yoffset, zoffset, x, y, width, height);
        }


        #endregion GL_EXT_copy_texture

        #region GL_EXT_cull_vertex


        #endregion GL_EXT_cull_vertex

        #region GL_EXT_debug_label


        #endregion GL_EXT_debug_label

        #region GL_EXT_debug_marker

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_debug_marker</para>
        /// Supported: <para>gl, glcore, gles1, gles2</para>
        /// Original: <para>void glPopGroupMarkerEXT();</para>
        /// </summary>
        public static void PopGroupMarkerEXT() {
            GLNative.glPopGroupMarkerEXT();
        }


        #endregion GL_EXT_debug_marker

        #region GL_EXT_depth_bounds_test

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_depth_bounds_test</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glDepthBoundsEXT(GLclampd zmin, GLclampd zmax);</para>
        /// </summary>
        public static void DepthBoundsEXT(double zmin, double zmax) {
            GLNative.glDepthBoundsEXT(zmin, zmax);
        }


        #endregion GL_EXT_depth_bounds_test

        #region GL_EXT_draw_buffers2

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_draw_buffers2</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glColorMaskIndexedEXT(GLuint index, GLboolean r, GLboolean g, GLboolean b, GLboolean a);</para>
        /// </summary>
        public static void ColorMaskIndexedEXT(uint index, bool r, bool g, bool b, bool a) {
            GLNative.glColorMaskIndexedEXT(index, r, g, b, a);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_direct_state_access, GL_EXT_draw_buffers2</para>
        /// Supported: <para>gl, glcore, gl</para>
        /// Original: <para>void glEnableIndexedEXT(GLenum target, GLuint index);</para>
        /// </summary>
        public static void EnableIndexedEXT(uint target, uint index) {
            GLNative.glEnableIndexedEXT(target, index);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_direct_state_access, GL_EXT_draw_buffers2</para>
        /// Supported: <para>gl, glcore, gl</para>
        /// Original: <para>void glDisableIndexedEXT(GLenum target, GLuint index);</para>
        /// </summary>
        public static void DisableIndexedEXT(uint target, uint index) {
            GLNative.glDisableIndexedEXT(target, index);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_direct_state_access, GL_EXT_draw_buffers2</para>
        /// Supported: <para>gl, glcore, gl</para>
        /// Original: <para>GLboolean glIsEnabledIndexedEXT(GLenum target, GLuint index);</para>
        /// </summary>
        public static bool IsEnabledIndexedEXT(uint target, uint index) {
            return GLNative.glIsEnabledIndexedEXT(target, index);
        }


        #endregion GL_EXT_draw_buffers2

        #region GL_EXT_draw_instanced

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_draw_instanced, GL_EXT_instanced_arrays</para>
        /// Supported: <para>gl, glcore, gles2, gles2</para>
        /// Original: <para>void glDrawArraysInstancedEXT(GLenum mode, GLint start, GLsizei count, GLsizei primcount);</para>
        /// </summary>
        public static void DrawArraysInstancedEXT(uint mode, int start, int count, int primcount) {
            GLNative.glDrawArraysInstancedEXT(mode, start, count, primcount);
        }


        #endregion GL_EXT_draw_instanced

        #region GL_EXT_draw_range_elements


        #endregion GL_EXT_draw_range_elements

        #region GL_EXT_external_buffer

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_external_buffer</para>
        /// Supported: <para>gl, gles2</para>
        /// Original: <para>void glBufferStorageExternalEXT(GLenum target, GLintptr offset, GLsizeiptr size, GLeglClientBufferEXT clientBuffer, GLbitfield flags);</para>
        /// </summary>
        public static void BufferStorageExternalEXT(uint target, IntPtr offset, IntPtr size, IntPtr clientBuffer, uint flags) {
            GLNative.glBufferStorageExternalEXT(target, offset, size, clientBuffer, flags);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_external_buffer</para>
        /// Supported: <para>gl, gles2</para>
        /// Original: <para>void glNamedBufferStorageExternalEXT(GLuint buffer, GLintptr offset, GLsizeiptr size, GLeglClientBufferEXT clientBuffer, GLbitfield flags);</para>
        /// </summary>
        public static void NamedBufferStorageExternalEXT(uint buffer, IntPtr offset, IntPtr size, IntPtr clientBuffer, uint flags) {
            GLNative.glNamedBufferStorageExternalEXT(buffer, offset, size, clientBuffer, flags);
        }


        #endregion GL_EXT_external_buffer

        #region GL_EXT_fog_coord

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_fog_coord</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glFogCoordfEXT(GLfloat coord);</para>
        /// </summary>
        public static void FogCoordfEXT(float coord) {
            GLNative.glFogCoordfEXT(coord);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_fog_coord</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glFogCoorddEXT(GLdouble coord);</para>
        /// </summary>
        public static void FogCoorddEXT(double coord) {
            GLNative.glFogCoorddEXT(coord);
        }


        #endregion GL_EXT_fog_coord

        #region GL_EXT_framebuffer_blit

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_framebuffer_blit</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glBlitFramebufferEXT(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter);</para>
        /// </summary>
        public static void BlitFramebufferEXT(int srcX0, int srcY0, int srcX1, int srcY1, int dstX0, int dstY0, int dstX1, int dstY1, uint mask, uint filter) {
            GLNative.glBlitFramebufferEXT(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
        }


        #endregion GL_EXT_framebuffer_blit

        #region GL_EXT_framebuffer_multisample

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_framebuffer_multisample, GL_EXT_multisampled_render_to_texture</para>
        /// Supported: <para>gl, gles1, gles2</para>
        /// Original: <para>void glRenderbufferStorageMultisampleEXT(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height);</para>
        /// </summary>
        public static void RenderbufferStorageMultisampleEXT(uint target, int samples, uint internalformat, int width, int height) {
            GLNative.glRenderbufferStorageMultisampleEXT(target, samples, internalformat, width, height);
        }


        #endregion GL_EXT_framebuffer_multisample

        #region GL_EXT_framebuffer_object

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_framebuffer_object</para>
        /// Supported: <para>gl</para>
        /// Original: <para>GLboolean glIsRenderbufferEXT(GLuint renderbuffer);</para>
        /// </summary>
        public static bool IsRenderbufferEXT(uint renderbuffer) {
            return GLNative.glIsRenderbufferEXT(renderbuffer);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_framebuffer_object</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glBindRenderbufferEXT(GLenum target, GLuint renderbuffer);</para>
        /// </summary>
        public static void BindRenderbufferEXT(uint target, uint renderbuffer) {
            GLNative.glBindRenderbufferEXT(target, renderbuffer);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_framebuffer_object</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glRenderbufferStorageEXT(GLenum target, GLenum internalformat, GLsizei width, GLsizei height);</para>
        /// </summary>
        public static void RenderbufferStorageEXT(uint target, uint internalformat, int width, int height) {
            GLNative.glRenderbufferStorageEXT(target, internalformat, width, height);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_framebuffer_object</para>
        /// Supported: <para>gl</para>
        /// Original: <para>GLboolean glIsFramebufferEXT(GLuint framebuffer);</para>
        /// </summary>
        public static bool IsFramebufferEXT(uint framebuffer) {
            return GLNative.glIsFramebufferEXT(framebuffer);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_framebuffer_object</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glBindFramebufferEXT(GLenum target, GLuint framebuffer);</para>
        /// </summary>
        public static void BindFramebufferEXT(uint target, uint framebuffer) {
            GLNative.glBindFramebufferEXT(target, framebuffer);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_framebuffer_object</para>
        /// Supported: <para>gl</para>
        /// Original: <para>GLenum glCheckFramebufferStatusEXT(GLenum target);</para>
        /// </summary>
        public static uint CheckFramebufferStatusEXT(uint target) {
            return GLNative.glCheckFramebufferStatusEXT(target);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_framebuffer_object</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glFramebufferTexture1DEXT(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level);</para>
        /// </summary>
        public static void FramebufferTexture1DEXT(uint target, uint attachment, uint textarget, uint texture, int level) {
            GLNative.glFramebufferTexture1DEXT(target, attachment, textarget, texture, level);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_framebuffer_object</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glFramebufferTexture2DEXT(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level);</para>
        /// </summary>
        public static void FramebufferTexture2DEXT(uint target, uint attachment, uint textarget, uint texture, int level) {
            GLNative.glFramebufferTexture2DEXT(target, attachment, textarget, texture, level);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_framebuffer_object</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glFramebufferTexture3DEXT(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset);</para>
        /// </summary>
        public static void FramebufferTexture3DEXT(uint target, uint attachment, uint textarget, uint texture, int level, int zoffset) {
            GLNative.glFramebufferTexture3DEXT(target, attachment, textarget, texture, level, zoffset);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_framebuffer_object</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glFramebufferRenderbufferEXT(GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer);</para>
        /// </summary>
        public static void FramebufferRenderbufferEXT(uint target, uint attachment, uint renderbuffertarget, uint renderbuffer) {
            GLNative.glFramebufferRenderbufferEXT(target, attachment, renderbuffertarget, renderbuffer);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_framebuffer_object</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGenerateMipmapEXT(GLenum target);</para>
        /// </summary>
        public static void GenerateMipmapEXT(uint target) {
            GLNative.glGenerateMipmapEXT(target);
        }


        #endregion GL_EXT_framebuffer_object

        #region GL_EXT_geometry_shader4

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_geometry_shader4, GL_EXT_separate_shader_objects</para>
        /// Supported: <para>gl, gl, glcore, gles2</para>
        /// Original: <para>void glProgramParameteriEXT(GLuint program, GLenum pname, GLint value);</para>
        /// </summary>
        public static void ProgramParameteriEXT(uint program, uint pname, int value) {
            GLNative.glProgramParameteriEXT(program, pname, value);
        }


        #endregion GL_EXT_geometry_shader4

        #region GL_EXT_gpu_program_parameters


        #endregion GL_EXT_gpu_program_parameters

        #region GL_EXT_gpu_shader4

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_gpu_shader4</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glUniform1uiEXT(GLint location, GLuint v0);</para>
        /// </summary>
        public static void Uniform1uiEXT(int location, uint v0) {
            GLNative.glUniform1uiEXT(location, v0);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_gpu_shader4</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glUniform2uiEXT(GLint location, GLuint v0, GLuint v1);</para>
        /// </summary>
        public static void Uniform2uiEXT(int location, uint v0, uint v1) {
            GLNative.glUniform2uiEXT(location, v0, v1);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_gpu_shader4</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glUniform3uiEXT(GLint location, GLuint v0, GLuint v1, GLuint v2);</para>
        /// </summary>
        public static void Uniform3uiEXT(int location, uint v0, uint v1, uint v2) {
            GLNative.glUniform3uiEXT(location, v0, v1, v2);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_gpu_shader4</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glUniform4uiEXT(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3);</para>
        /// </summary>
        public static void Uniform4uiEXT(int location, uint v0, uint v1, uint v2, uint v3) {
            GLNative.glUniform4uiEXT(location, v0, v1, v2, v3);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_gpu_shader4, GL_NV_vertex_program4</para>
        /// Supported: <para>gl, gl</para>
        /// Original: <para>void glVertexAttribI1iEXT(GLuint index, GLint x);</para>
        /// </summary>
        public static void VertexAttribI1iEXT(uint index, int x) {
            GLNative.glVertexAttribI1iEXT(index, x);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_gpu_shader4, GL_NV_vertex_program4</para>
        /// Supported: <para>gl, gl</para>
        /// Original: <para>void glVertexAttribI2iEXT(GLuint index, GLint x, GLint y);</para>
        /// </summary>
        public static void VertexAttribI2iEXT(uint index, int x, int y) {
            GLNative.glVertexAttribI2iEXT(index, x, y);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_gpu_shader4, GL_NV_vertex_program4</para>
        /// Supported: <para>gl, gl</para>
        /// Original: <para>void glVertexAttribI3iEXT(GLuint index, GLint x, GLint y, GLint z);</para>
        /// </summary>
        public static void VertexAttribI3iEXT(uint index, int x, int y, int z) {
            GLNative.glVertexAttribI3iEXT(index, x, y, z);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_gpu_shader4, GL_NV_vertex_program4</para>
        /// Supported: <para>gl, gl</para>
        /// Original: <para>void glVertexAttribI4iEXT(GLuint index, GLint x, GLint y, GLint z, GLint w);</para>
        /// </summary>
        public static void VertexAttribI4iEXT(uint index, int x, int y, int z, int w) {
            GLNative.glVertexAttribI4iEXT(index, x, y, z, w);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_gpu_shader4, GL_NV_vertex_program4</para>
        /// Supported: <para>gl, gl</para>
        /// Original: <para>void glVertexAttribI1uiEXT(GLuint index, GLuint x);</para>
        /// </summary>
        public static void VertexAttribI1uiEXT(uint index, uint x) {
            GLNative.glVertexAttribI1uiEXT(index, x);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_gpu_shader4, GL_NV_vertex_program4</para>
        /// Supported: <para>gl, gl</para>
        /// Original: <para>void glVertexAttribI2uiEXT(GLuint index, GLuint x, GLuint y);</para>
        /// </summary>
        public static void VertexAttribI2uiEXT(uint index, uint x, uint y) {
            GLNative.glVertexAttribI2uiEXT(index, x, y);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_gpu_shader4, GL_NV_vertex_program4</para>
        /// Supported: <para>gl, gl</para>
        /// Original: <para>void glVertexAttribI3uiEXT(GLuint index, GLuint x, GLuint y, GLuint z);</para>
        /// </summary>
        public static void VertexAttribI3uiEXT(uint index, uint x, uint y, uint z) {
            GLNative.glVertexAttribI3uiEXT(index, x, y, z);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_gpu_shader4, GL_NV_vertex_program4</para>
        /// Supported: <para>gl, gl</para>
        /// Original: <para>void glVertexAttribI4uiEXT(GLuint index, GLuint x, GLuint y, GLuint z, GLuint w);</para>
        /// </summary>
        public static void VertexAttribI4uiEXT(uint index, uint x, uint y, uint z, uint w) {
            GLNative.glVertexAttribI4uiEXT(index, x, y, z, w);
        }


        #endregion GL_EXT_gpu_shader4

        #region GL_EXT_histogram

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_histogram</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glHistogramEXT(GLenum target, GLsizei width, GLenum internalformat, GLboolean sink);</para>
        /// </summary>
        public static void HistogramEXT(uint target, int width, uint internalformat, bool sink) {
            GLNative.glHistogramEXT(target, width, internalformat, sink);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_histogram</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glMinmaxEXT(GLenum target, GLenum internalformat, GLboolean sink);</para>
        /// </summary>
        public static void MinmaxEXT(uint target, uint internalformat, bool sink) {
            GLNative.glMinmaxEXT(target, internalformat, sink);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_histogram</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glResetHistogramEXT(GLenum target);</para>
        /// </summary>
        public static void ResetHistogramEXT(uint target) {
            GLNative.glResetHistogramEXT(target);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_histogram</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glResetMinmaxEXT(GLenum target);</para>
        /// </summary>
        public static void ResetMinmaxEXT(uint target) {
            GLNative.glResetMinmaxEXT(target);
        }


        #endregion GL_EXT_histogram

        #region GL_EXT_index_func

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_index_func</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glIndexFuncEXT(GLenum func, GLclampf ref);</para>
        /// </summary>
        public static void IndexFuncEXT(uint func, float r) {
            GLNative.glIndexFuncEXT(func, r);
        }


        #endregion GL_EXT_index_func

        #region GL_EXT_index_material

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_index_material</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glIndexMaterialEXT(GLenum face, GLenum mode);</para>
        /// </summary>
        public static void IndexMaterialEXT(uint face, uint mode) {
            GLNative.glIndexMaterialEXT(face, mode);
        }


        #endregion GL_EXT_index_material

        #region GL_EXT_light_texture

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_light_texture</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glApplyTextureEXT(GLenum mode);</para>
        /// </summary>
        public static void ApplyTextureEXT(uint mode) {
            GLNative.glApplyTextureEXT(mode);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_light_texture</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glTextureLightEXT(GLenum pname);</para>
        /// </summary>
        public static void TextureLightEXT(uint pname) {
            GLNative.glTextureLightEXT(pname);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_light_texture</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glTextureMaterialEXT(GLenum face, GLenum mode);</para>
        /// </summary>
        public static void TextureMaterialEXT(uint face, uint mode) {
            GLNative.glTextureMaterialEXT(face, mode);
        }


        #endregion GL_EXT_light_texture

        #region GL_EXT_memory_object

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_memory_object</para>
        /// Supported: <para>gl, gles2</para>
        /// Original: <para>GLboolean glIsMemoryObjectEXT(GLuint memoryObject);</para>
        /// </summary>
        public static bool IsMemoryObjectEXT(uint memoryObject) {
            return GLNative.glIsMemoryObjectEXT(memoryObject);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_memory_object</para>
        /// Supported: <para>gl, gles2</para>
        /// Original: <para>void glTexStorageMem2DEXT(GLenum target, GLsizei levels, GLenum internalFormat, GLsizei width, GLsizei height, GLuint memory, GLuint64 offset);</para>
        /// </summary>
        public static void TexStorageMem2DEXT(uint target, int levels, uint internalFormat, int width, int height, uint memory, UInt64 offset) {
            GLNative.glTexStorageMem2DEXT(target, levels, internalFormat, width, height, memory, offset);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_memory_object</para>
        /// Supported: <para>gl, gles2</para>
        /// Original: <para>void glTexStorageMem2DMultisampleEXT(GLenum target, GLsizei samples, GLenum internalFormat, GLsizei width, GLsizei height, GLboolean fixedSampleLocations, GLuint memory, GLuint64 offset);</para>
        /// </summary>
        public static void TexStorageMem2DMultisampleEXT(uint target, int samples, uint internalFormat, int width, int height, bool fixedSampleLocations, uint memory, UInt64 offset) {
            GLNative.glTexStorageMem2DMultisampleEXT(target, samples, internalFormat, width, height, fixedSampleLocations, memory, offset);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_memory_object</para>
        /// Supported: <para>gl, gles2</para>
        /// Original: <para>void glTexStorageMem3DEXT(GLenum target, GLsizei levels, GLenum internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLuint memory, GLuint64 offset);</para>
        /// </summary>
        public static void TexStorageMem3DEXT(uint target, int levels, uint internalFormat, int width, int height, int depth, uint memory, UInt64 offset) {
            GLNative.glTexStorageMem3DEXT(target, levels, internalFormat, width, height, depth, memory, offset);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_memory_object</para>
        /// Supported: <para>gl, gles2</para>
        /// Original: <para>void glTexStorageMem3DMultisampleEXT(GLenum target, GLsizei samples, GLenum internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedSampleLocations, GLuint memory, GLuint64 offset);</para>
        /// </summary>
        public static void TexStorageMem3DMultisampleEXT(uint target, int samples, uint internalFormat, int width, int height, int depth, bool fixedSampleLocations, uint memory, UInt64 offset) {
            GLNative.glTexStorageMem3DMultisampleEXT(target, samples, internalFormat, width, height, depth, fixedSampleLocations, memory, offset);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_memory_object</para>
        /// Supported: <para>gl, gles2</para>
        /// Original: <para>void glBufferStorageMemEXT(GLenum target, GLsizeiptr size, GLuint memory, GLuint64 offset);</para>
        /// </summary>
        public static void BufferStorageMemEXT(uint target, IntPtr size, uint memory, UInt64 offset) {
            GLNative.glBufferStorageMemEXT(target, size, memory, offset);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_memory_object</para>
        /// Supported: <para>gl, gles2</para>
        /// Original: <para>void glTextureStorageMem2DEXT(GLuint texture, GLsizei levels, GLenum internalFormat, GLsizei width, GLsizei height, GLuint memory, GLuint64 offset);</para>
        /// </summary>
        public static void TextureStorageMem2DEXT(uint texture, int levels, uint internalFormat, int width, int height, uint memory, UInt64 offset) {
            GLNative.glTextureStorageMem2DEXT(texture, levels, internalFormat, width, height, memory, offset);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_memory_object</para>
        /// Supported: <para>gl, gles2</para>
        /// Original: <para>void glTextureStorageMem2DMultisampleEXT(GLuint texture, GLsizei samples, GLenum internalFormat, GLsizei width, GLsizei height, GLboolean fixedSampleLocations, GLuint memory, GLuint64 offset);</para>
        /// </summary>
        public static void TextureStorageMem2DMultisampleEXT(uint texture, int samples, uint internalFormat, int width, int height, bool fixedSampleLocations, uint memory, UInt64 offset) {
            GLNative.glTextureStorageMem2DMultisampleEXT(texture, samples, internalFormat, width, height, fixedSampleLocations, memory, offset);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_memory_object</para>
        /// Supported: <para>gl, gles2</para>
        /// Original: <para>void glTextureStorageMem3DEXT(GLuint texture, GLsizei levels, GLenum internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLuint memory, GLuint64 offset);</para>
        /// </summary>
        public static void TextureStorageMem3DEXT(uint texture, int levels, uint internalFormat, int width, int height, int depth, uint memory, UInt64 offset) {
            GLNative.glTextureStorageMem3DEXT(texture, levels, internalFormat, width, height, depth, memory, offset);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_memory_object</para>
        /// Supported: <para>gl, gles2</para>
        /// Original: <para>void glTextureStorageMem3DMultisampleEXT(GLuint texture, GLsizei samples, GLenum internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedSampleLocations, GLuint memory, GLuint64 offset);</para>
        /// </summary>
        public static void TextureStorageMem3DMultisampleEXT(uint texture, int samples, uint internalFormat, int width, int height, int depth, bool fixedSampleLocations, uint memory, UInt64 offset) {
            GLNative.glTextureStorageMem3DMultisampleEXT(texture, samples, internalFormat, width, height, depth, fixedSampleLocations, memory, offset);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_memory_object</para>
        /// Supported: <para>gl, gles2</para>
        /// Original: <para>void glNamedBufferStorageMemEXT(GLuint buffer, GLsizeiptr size, GLuint memory, GLuint64 offset);</para>
        /// </summary>
        public static void NamedBufferStorageMemEXT(uint buffer, IntPtr size, uint memory, UInt64 offset) {
            GLNative.glNamedBufferStorageMemEXT(buffer, size, memory, offset);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_memory_object</para>
        /// Supported: <para>gl, gles2</para>
        /// Original: <para>void glTexStorageMem1DEXT(GLenum target, GLsizei levels, GLenum internalFormat, GLsizei width, GLuint memory, GLuint64 offset);</para>
        /// </summary>
        public static void TexStorageMem1DEXT(uint target, int levels, uint internalFormat, int width, uint memory, UInt64 offset) {
            GLNative.glTexStorageMem1DEXT(target, levels, internalFormat, width, memory, offset);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_memory_object</para>
        /// Supported: <para>gl, gles2</para>
        /// Original: <para>void glTextureStorageMem1DEXT(GLuint texture, GLsizei levels, GLenum internalFormat, GLsizei width, GLuint memory, GLuint64 offset);</para>
        /// </summary>
        public static void TextureStorageMem1DEXT(uint texture, int levels, uint internalFormat, int width, uint memory, UInt64 offset) {
            GLNative.glTextureStorageMem1DEXT(texture, levels, internalFormat, width, memory, offset);
        }


        #endregion GL_EXT_memory_object

        #region GL_EXT_memory_object_fd

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_memory_object_fd</para>
        /// Supported: <para>gl, gles2</para>
        /// Original: <para>void glImportMemoryFdEXT(GLuint memory, GLuint64 size, GLenum handleType, GLint fd);</para>
        /// </summary>
        public static void ImportMemoryFdEXT(uint memory, UInt64 size, uint handleType, int fd) {
            GLNative.glImportMemoryFdEXT(memory, size, handleType, fd);
        }


        #endregion GL_EXT_memory_object_fd

        #region GL_EXT_memory_object_win32


        #endregion GL_EXT_memory_object_win32

        #region GL_EXT_multi_draw_arrays


        #endregion GL_EXT_multi_draw_arrays

        #region GL_EXT_multisample

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_multisample</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glSampleMaskEXT(GLclampf value, GLboolean invert);</para>
        /// </summary>
        public static void SampleMaskEXT(float value, bool invert) {
            GLNative.glSampleMaskEXT(value, invert);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_multisample</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glSamplePatternEXT(GLenum pattern);</para>
        /// </summary>
        public static void SamplePatternEXT(uint pattern) {
            GLNative.glSamplePatternEXT(pattern);
        }


        #endregion GL_EXT_multisample

        #region GL_EXT_paletted_texture


        #endregion GL_EXT_paletted_texture

        #region GL_EXT_pixel_transform

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_pixel_transform</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glPixelTransformParameteriEXT(GLenum target, GLenum pname, GLint param);</para>
        /// </summary>
        public static void PixelTransformParameteriEXT(uint target, uint pname, int param) {
            GLNative.glPixelTransformParameteriEXT(target, pname, param);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_pixel_transform</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glPixelTransformParameterfEXT(GLenum target, GLenum pname, GLfloat param);</para>
        /// </summary>
        public static void PixelTransformParameterfEXT(uint target, uint pname, float param) {
            GLNative.glPixelTransformParameterfEXT(target, pname, param);
        }


        #endregion GL_EXT_pixel_transform

        #region GL_EXT_point_parameters

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_point_parameters</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glPointParameterfEXT(GLenum pname, GLfloat param);</para>
        /// </summary>
        public static void PointParameterfEXT(uint pname, float param) {
            GLNative.glPointParameterfEXT(pname, param);
        }


        #endregion GL_EXT_point_parameters

        #region GL_EXT_polygon_offset

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_polygon_offset</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glPolygonOffsetEXT(GLfloat factor, GLfloat bias);</para>
        /// </summary>
        public static void PolygonOffsetEXT(float factor, float bias) {
            GLNative.glPolygonOffsetEXT(factor, bias);
        }


        #endregion GL_EXT_polygon_offset

        #region GL_EXT_polygon_offset_clamp

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_polygon_offset_clamp</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glPolygonOffsetClampEXT(GLfloat factor, GLfloat units, GLfloat clamp);</para>
        /// </summary>
        public static void PolygonOffsetClampEXT(float factor, float units, float clamp) {
            GLNative.glPolygonOffsetClampEXT(factor, units, clamp);
        }


        #endregion GL_EXT_polygon_offset_clamp

        #region GL_EXT_provoking_vertex

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_provoking_vertex</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glProvokingVertexEXT(GLenum mode);</para>
        /// </summary>
        public static void ProvokingVertexEXT(uint mode) {
            GLNative.glProvokingVertexEXT(mode);
        }


        #endregion GL_EXT_provoking_vertex

        #region GL_EXT_raster_multisample

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_raster_multisample, GL_NV_framebuffer_mixed_samples</para>
        /// Supported: <para>gl, glcore, gles2, gl, glcore, gles2</para>
        /// Original: <para>void glRasterSamplesEXT(GLuint samples, GLboolean fixedsamplelocations);</para>
        /// </summary>
        public static void RasterSamplesEXT(uint samples, bool fixedsamplelocations) {
            GLNative.glRasterSamplesEXT(samples, fixedsamplelocations);
        }


        #endregion GL_EXT_raster_multisample

        #region GL_EXT_semaphore

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_semaphore</para>
        /// Supported: <para>gl, gles2</para>
        /// Original: <para>GLboolean glIsSemaphoreEXT(GLuint semaphore);</para>
        /// </summary>
        public static bool IsSemaphoreEXT(uint semaphore) {
            return GLNative.glIsSemaphoreEXT(semaphore);
        }


        #endregion GL_EXT_semaphore

        #region GL_EXT_semaphore_fd

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_semaphore_fd</para>
        /// Supported: <para>gl, gles2</para>
        /// Original: <para>void glImportSemaphoreFdEXT(GLuint semaphore, GLenum handleType, GLint fd);</para>
        /// </summary>
        public static void ImportSemaphoreFdEXT(uint semaphore, uint handleType, int fd) {
            GLNative.glImportSemaphoreFdEXT(semaphore, handleType, fd);
        }


        #endregion GL_EXT_semaphore_fd

        #region GL_EXT_semaphore_win32


        #endregion GL_EXT_semaphore_win32

        #region GL_EXT_secondary_color

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_secondary_color</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glSecondaryColor3bEXT(GLbyte red, GLbyte green, GLbyte blue);</para>
        /// </summary>
        public static void SecondaryColor3bEXT(byte red, byte green, byte blue) {
            GLNative.glSecondaryColor3bEXT(red, green, blue);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_secondary_color</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glSecondaryColor3dEXT(GLdouble red, GLdouble green, GLdouble blue);</para>
        /// </summary>
        public static void SecondaryColor3dEXT(double red, double green, double blue) {
            GLNative.glSecondaryColor3dEXT(red, green, blue);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_secondary_color</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glSecondaryColor3fEXT(GLfloat red, GLfloat green, GLfloat blue);</para>
        /// </summary>
        public static void SecondaryColor3fEXT(float red, float green, float blue) {
            GLNative.glSecondaryColor3fEXT(red, green, blue);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_secondary_color</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glSecondaryColor3iEXT(GLint red, GLint green, GLint blue);</para>
        /// </summary>
        public static void SecondaryColor3iEXT(int red, int green, int blue) {
            GLNative.glSecondaryColor3iEXT(red, green, blue);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_secondary_color</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glSecondaryColor3sEXT(GLshort red, GLshort green, GLshort blue);</para>
        /// </summary>
        public static void SecondaryColor3sEXT(short red, short green, short blue) {
            GLNative.glSecondaryColor3sEXT(red, green, blue);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_secondary_color</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glSecondaryColor3ubEXT(GLubyte red, GLubyte green, GLubyte blue);</para>
        /// </summary>
        public static void SecondaryColor3ubEXT(byte red, byte green, byte blue) {
            GLNative.glSecondaryColor3ubEXT(red, green, blue);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_secondary_color</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glSecondaryColor3uiEXT(GLuint red, GLuint green, GLuint blue);</para>
        /// </summary>
        public static void SecondaryColor3uiEXT(uint red, uint green, uint blue) {
            GLNative.glSecondaryColor3uiEXT(red, green, blue);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_secondary_color</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glSecondaryColor3usEXT(GLushort red, GLushort green, GLushort blue);</para>
        /// </summary>
        public static void SecondaryColor3usEXT(ushort red, ushort green, ushort blue) {
            GLNative.glSecondaryColor3usEXT(red, green, blue);
        }


        #endregion GL_EXT_secondary_color

        #region GL_EXT_separate_shader_objects

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_separate_shader_objects</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glUseShaderProgramEXT(GLenum type, GLuint program);</para>
        /// </summary>
        public static void UseShaderProgramEXT(uint type, uint program) {
            GLNative.glUseShaderProgramEXT(type, program);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_separate_shader_objects</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glActiveProgramEXT(GLuint program);</para>
        /// </summary>
        public static void ActiveProgramEXT(uint program) {
            GLNative.glActiveProgramEXT(program);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_separate_shader_objects</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glActiveShaderProgramEXT(GLuint pipeline, GLuint program);</para>
        /// </summary>
        public static void ActiveShaderProgramEXT(uint pipeline, uint program) {
            GLNative.glActiveShaderProgramEXT(pipeline, program);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_separate_shader_objects</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glBindProgramPipelineEXT(GLuint pipeline);</para>
        /// </summary>
        public static void BindProgramPipelineEXT(uint pipeline) {
            GLNative.glBindProgramPipelineEXT(pipeline);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_separate_shader_objects</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>GLboolean glIsProgramPipelineEXT(GLuint pipeline);</para>
        /// </summary>
        public static bool IsProgramPipelineEXT(uint pipeline) {
            return GLNative.glIsProgramPipelineEXT(pipeline);
        }

        // void glProgramParameteriEXT(GLuint program, GLenum pname, GLint value);
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_direct_state_access, GL_EXT_separate_shader_objects</para>
        /// Supported: <para>gl, glcore, gl, glcore, gles2</para>
        /// Original: <para>void glProgramUniform1fEXT(GLuint program, GLint location, GLfloat v0);</para>
        /// </summary>
        public static void ProgramUniform1fEXT(uint program, int location, float v0) {
            GLNative.glProgramUniform1fEXT(program, location, v0);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_direct_state_access, GL_EXT_separate_shader_objects</para>
        /// Supported: <para>gl, glcore, gl, glcore, gles2</para>
        /// Original: <para>void glProgramUniform1iEXT(GLuint program, GLint location, GLint v0);</para>
        /// </summary>
        public static void ProgramUniform1iEXT(uint program, int location, int v0) {
            GLNative.glProgramUniform1iEXT(program, location, v0);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_direct_state_access, GL_EXT_separate_shader_objects</para>
        /// Supported: <para>gl, glcore, gl, glcore, gles2</para>
        /// Original: <para>void glProgramUniform2fEXT(GLuint program, GLint location, GLfloat v0, GLfloat v1);</para>
        /// </summary>
        public static void ProgramUniform2fEXT(uint program, int location, float v0, float v1) {
            GLNative.glProgramUniform2fEXT(program, location, v0, v1);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_direct_state_access, GL_EXT_separate_shader_objects</para>
        /// Supported: <para>gl, glcore, gl, glcore, gles2</para>
        /// Original: <para>void glProgramUniform2iEXT(GLuint program, GLint location, GLint v0, GLint v1);</para>
        /// </summary>
        public static void ProgramUniform2iEXT(uint program, int location, int v0, int v1) {
            GLNative.glProgramUniform2iEXT(program, location, v0, v1);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_direct_state_access, GL_EXT_separate_shader_objects</para>
        /// Supported: <para>gl, glcore, gl, glcore, gles2</para>
        /// Original: <para>void glProgramUniform3fEXT(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2);</para>
        /// </summary>
        public static void ProgramUniform3fEXT(uint program, int location, float v0, float v1, float v2) {
            GLNative.glProgramUniform3fEXT(program, location, v0, v1, v2);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_direct_state_access, GL_EXT_separate_shader_objects</para>
        /// Supported: <para>gl, glcore, gl, glcore, gles2</para>
        /// Original: <para>void glProgramUniform3iEXT(GLuint program, GLint location, GLint v0, GLint v1, GLint v2);</para>
        /// </summary>
        public static void ProgramUniform3iEXT(uint program, int location, int v0, int v1, int v2) {
            GLNative.glProgramUniform3iEXT(program, location, v0, v1, v2);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_direct_state_access, GL_EXT_separate_shader_objects</para>
        /// Supported: <para>gl, glcore, gl, glcore, gles2</para>
        /// Original: <para>void glProgramUniform4fEXT(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3);</para>
        /// </summary>
        public static void ProgramUniform4fEXT(uint program, int location, float v0, float v1, float v2, float v3) {
            GLNative.glProgramUniform4fEXT(program, location, v0, v1, v2, v3);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_direct_state_access, GL_EXT_separate_shader_objects</para>
        /// Supported: <para>gl, glcore, gl, glcore, gles2</para>
        /// Original: <para>void glProgramUniform4iEXT(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3);</para>
        /// </summary>
        public static void ProgramUniform4iEXT(uint program, int location, int v0, int v1, int v2, int v3) {
            GLNative.glProgramUniform4iEXT(program, location, v0, v1, v2, v3);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_separate_shader_objects</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glUseProgramStagesEXT(GLuint pipeline, GLbitfield stages, GLuint program);</para>
        /// </summary>
        public static void UseProgramStagesEXT(uint pipeline, uint stages, uint program) {
            GLNative.glUseProgramStagesEXT(pipeline, stages, program);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_separate_shader_objects</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glValidateProgramPipelineEXT(GLuint pipeline);</para>
        /// </summary>
        public static void ValidateProgramPipelineEXT(uint pipeline) {
            GLNative.glValidateProgramPipelineEXT(pipeline);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_direct_state_access, GL_EXT_separate_shader_objects</para>
        /// Supported: <para>gl, glcore, gl, glcore, gles2</para>
        /// Original: <para>void glProgramUniform1uiEXT(GLuint program, GLint location, GLuint v0);</para>
        /// </summary>
        public static void ProgramUniform1uiEXT(uint program, int location, uint v0) {
            GLNative.glProgramUniform1uiEXT(program, location, v0);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_direct_state_access, GL_EXT_separate_shader_objects</para>
        /// Supported: <para>gl, glcore, gl, glcore, gles2</para>
        /// Original: <para>void glProgramUniform2uiEXT(GLuint program, GLint location, GLuint v0, GLuint v1);</para>
        /// </summary>
        public static void ProgramUniform2uiEXT(uint program, int location, uint v0, uint v1) {
            GLNative.glProgramUniform2uiEXT(program, location, v0, v1);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_direct_state_access, GL_EXT_separate_shader_objects</para>
        /// Supported: <para>gl, glcore, gl, glcore, gles2</para>
        /// Original: <para>void glProgramUniform3uiEXT(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2);</para>
        /// </summary>
        public static void ProgramUniform3uiEXT(uint program, int location, uint v0, uint v1, uint v2) {
            GLNative.glProgramUniform3uiEXT(program, location, v0, v1, v2);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_direct_state_access, GL_EXT_separate_shader_objects</para>
        /// Supported: <para>gl, glcore, gl, glcore, gles2</para>
        /// Original: <para>void glProgramUniform4uiEXT(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3);</para>
        /// </summary>
        public static void ProgramUniform4uiEXT(uint program, int location, uint v0, uint v1, uint v2, uint v3) {
            GLNative.glProgramUniform4uiEXT(program, location, v0, v1, v2, v3);
        }


        #endregion GL_EXT_separate_shader_objects

        #region GL_EXT_shader_framebuffer_fetch_non_coherent

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_shader_framebuffer_fetch_non_coherent</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glFramebufferFetchBarrierEXT();</para>
        /// </summary>
        public static void FramebufferFetchBarrierEXT() {
            GLNative.glFramebufferFetchBarrierEXT();
        }


        #endregion GL_EXT_shader_framebuffer_fetch_non_coherent

        #region GL_EXT_shader_image_load_store

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_shader_image_load_store</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glBindImageTextureEXT(GLuint index, GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum access, GLint format);</para>
        /// </summary>
        public static void BindImageTextureEXT(uint index, uint texture, int level, bool layered, int layer, uint access, int format) {
            GLNative.glBindImageTextureEXT(index, texture, level, layered, layer, access, format);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_shader_image_load_store</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glMemoryBarrierEXT(GLbitfield barriers);</para>
        /// </summary>
        public static void MemoryBarrierEXT(uint barriers) {
            GLNative.glMemoryBarrierEXT(barriers);
        }


        #endregion GL_EXT_shader_image_load_store

        #region GL_EXT_stencil_clear_tag

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_stencil_clear_tag</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glStencilClearTagEXT(GLsizei stencilTagBits, GLuint stencilClearTag);</para>
        /// </summary>
        public static void StencilClearTagEXT(int stencilTagBits, uint stencilClearTag) {
            GLNative.glStencilClearTagEXT(stencilTagBits, stencilClearTag);
        }


        #endregion GL_EXT_stencil_clear_tag

        #region GL_EXT_stencil_two_side

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_stencil_two_side</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glActiveStencilFaceEXT(GLenum face);</para>
        /// </summary>
        public static void ActiveStencilFaceEXT(uint face) {
            GLNative.glActiveStencilFaceEXT(face);
        }


        #endregion GL_EXT_stencil_two_side

        #region GL_EXT_subtexture


        #endregion GL_EXT_subtexture

        #region GL_EXT_texture3D


        #endregion GL_EXT_texture3D

        #region GL_EXT_texture_array

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_texture_array, GL_NV_geometry_program4</para>
        /// Supported: <para>gl, gl</para>
        /// Original: <para>void glFramebufferTextureLayerEXT(GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer);</para>
        /// </summary>
        public static void FramebufferTextureLayerEXT(uint target, uint attachment, uint texture, int level, int layer) {
            GLNative.glFramebufferTextureLayerEXT(target, attachment, texture, level, layer);
        }


        #endregion GL_EXT_texture_array

        #region GL_EXT_texture_buffer_object

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_texture_buffer, GL_EXT_texture_buffer_object</para>
        /// Supported: <para>gles2, gl</para>
        /// Original: <para>void glTexBufferEXT(GLenum target, GLenum internalformat, GLuint buffer);</para>
        /// </summary>
        public static void TexBufferEXT(uint target, uint internalformat, uint buffer) {
            GLNative.glTexBufferEXT(target, internalformat, buffer);
        }


        #endregion GL_EXT_texture_buffer_object

        #region GL_EXT_texture_integer

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_texture_integer</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glClearColorIiEXT(GLint red, GLint green, GLint blue, GLint alpha);</para>
        /// </summary>
        public static void ClearColorIiEXT(int red, int green, int blue, int alpha) {
            GLNative.glClearColorIiEXT(red, green, blue, alpha);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_texture_integer</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glClearColorIuiEXT(GLuint red, GLuint green, GLuint blue, GLuint alpha);</para>
        /// </summary>
        public static void ClearColorIuiEXT(uint red, uint green, uint blue, uint alpha) {
            GLNative.glClearColorIuiEXT(red, green, blue, alpha);
        }


        #endregion GL_EXT_texture_integer

        #region GL_EXT_texture_object

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_texture_object</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glBindTextureEXT(GLenum target, GLuint texture);</para>
        /// </summary>
        public static void BindTextureEXT(uint target, uint texture) {
            GLNative.glBindTextureEXT(target, texture);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_texture_object</para>
        /// Supported: <para>gl</para>
        /// Original: <para>GLboolean glIsTextureEXT(GLuint texture);</para>
        /// </summary>
        public static bool IsTextureEXT(uint texture) {
            return GLNative.glIsTextureEXT(texture);
        }


        #endregion GL_EXT_texture_object

        #region GL_EXT_texture_perturb_normal

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_texture_perturb_normal</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glTextureNormalEXT(GLenum mode);</para>
        /// </summary>
        public static void TextureNormalEXT(uint mode) {
            GLNative.glTextureNormalEXT(mode);
        }


        #endregion GL_EXT_texture_perturb_normal

        #region GL_EXT_texture_storage

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_texture_storage</para>
        /// Supported: <para>gles1, gles2, gl, glcore</para>
        /// Original: <para>void glTexStorage1DEXT(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width);</para>
        /// </summary>
        public static void TexStorage1DEXT(uint target, int levels, uint internalformat, int width) {
            GLNative.glTexStorage1DEXT(target, levels, internalformat, width);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_texture_storage</para>
        /// Supported: <para>gles1, gles2, gl, glcore</para>
        /// Original: <para>void glTexStorage2DEXT(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height);</para>
        /// </summary>
        public static void TexStorage2DEXT(uint target, int levels, uint internalformat, int width, int height) {
            GLNative.glTexStorage2DEXT(target, levels, internalformat, width, height);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_texture_storage</para>
        /// Supported: <para>gles1, gles2, gl, glcore</para>
        /// Original: <para>void glTexStorage3DEXT(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth);</para>
        /// </summary>
        public static void TexStorage3DEXT(uint target, int levels, uint internalformat, int width, int height, int depth) {
            GLNative.glTexStorage3DEXT(target, levels, internalformat, width, height, depth);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_direct_state_access, GL_EXT_texture_storage</para>
        /// Supported: <para>gl, glcore, gles1, gles2, gl, glcore</para>
        /// Original: <para>void glTextureStorage1DEXT(GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width);</para>
        /// </summary>
        public static void TextureStorage1DEXT(uint texture, uint target, int levels, uint internalformat, int width) {
            GLNative.glTextureStorage1DEXT(texture, target, levels, internalformat, width);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_direct_state_access, GL_EXT_texture_storage</para>
        /// Supported: <para>gl, glcore, gles1, gles2, gl, glcore</para>
        /// Original: <para>void glTextureStorage2DEXT(GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height);</para>
        /// </summary>
        public static void TextureStorage2DEXT(uint texture, uint target, int levels, uint internalformat, int width, int height) {
            GLNative.glTextureStorage2DEXT(texture, target, levels, internalformat, width, height);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_direct_state_access, GL_EXT_texture_storage</para>
        /// Supported: <para>gl, glcore, gles1, gles2, gl, glcore</para>
        /// Original: <para>void glTextureStorage3DEXT(GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth);</para>
        /// </summary>
        public static void TextureStorage3DEXT(uint texture, uint target, int levels, uint internalformat, int width, int height, int depth) {
            GLNative.glTextureStorage3DEXT(texture, target, levels, internalformat, width, height, depth);
        }


        #endregion GL_EXT_texture_storage

        #region GL_NV_timeline_semaphore


        #endregion GL_NV_timeline_semaphore

        #region GL_EXT_timer_query


        #endregion GL_EXT_timer_query

        #region GL_EXT_transform_feedback

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_transform_feedback</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glBeginTransformFeedbackEXT(GLenum primitiveMode);</para>
        /// </summary>
        public static void BeginTransformFeedbackEXT(uint primitiveMode) {
            GLNative.glBeginTransformFeedbackEXT(primitiveMode);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_transform_feedback</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glEndTransformFeedbackEXT();</para>
        /// </summary>
        public static void EndTransformFeedbackEXT() {
            GLNative.glEndTransformFeedbackEXT();
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_transform_feedback</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glBindBufferRangeEXT(GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size);</para>
        /// </summary>
        public static void BindBufferRangeEXT(uint target, uint index, uint buffer, IntPtr offset, IntPtr size) {
            GLNative.glBindBufferRangeEXT(target, index, buffer, offset, size);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_transform_feedback</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glBindBufferOffsetEXT(GLenum target, GLuint index, GLuint buffer, GLintptr offset);</para>
        /// </summary>
        public static void BindBufferOffsetEXT(uint target, uint index, uint buffer, IntPtr offset) {
            GLNative.glBindBufferOffsetEXT(target, index, buffer, offset);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_transform_feedback</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glBindBufferBaseEXT(GLenum target, GLuint index, GLuint buffer);</para>
        /// </summary>
        public static void BindBufferBaseEXT(uint target, uint index, uint buffer) {
            GLNative.glBindBufferBaseEXT(target, index, buffer);
        }


        #endregion GL_EXT_transform_feedback

        #region GL_EXT_vertex_array

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_vertex_array</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glArrayElementEXT(GLint i);</para>
        /// </summary>
        public static void ArrayElementEXT(int i) {
            GLNative.glArrayElementEXT(i);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_vertex_array</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glDrawArraysEXT(GLenum mode, GLint first, GLsizei count);</para>
        /// </summary>
        public static void DrawArraysEXT(uint mode, int first, int count) {
            GLNative.glDrawArraysEXT(mode, first, count);
        }


        #endregion GL_EXT_vertex_array

        #region GL_EXT_vertex_attrib_64bit

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_vertex_attrib_64bit</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexAttribL1dEXT(GLuint index, GLdouble x);</para>
        /// </summary>
        public static void VertexAttribL1dEXT(uint index, double x) {
            GLNative.glVertexAttribL1dEXT(index, x);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_vertex_attrib_64bit</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexAttribL2dEXT(GLuint index, GLdouble x, GLdouble y);</para>
        /// </summary>
        public static void VertexAttribL2dEXT(uint index, double x, double y) {
            GLNative.glVertexAttribL2dEXT(index, x, y);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_vertex_attrib_64bit</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexAttribL3dEXT(GLuint index, GLdouble x, GLdouble y, GLdouble z);</para>
        /// </summary>
        public static void VertexAttribL3dEXT(uint index, double x, double y, double z) {
            GLNative.glVertexAttribL3dEXT(index, x, y, z);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_vertex_attrib_64bit</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexAttribL4dEXT(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);</para>
        /// </summary>
        public static void VertexAttribL4dEXT(uint index, double x, double y, double z, double w) {
            GLNative.glVertexAttribL4dEXT(index, x, y, z, w);
        }


        #endregion GL_EXT_vertex_attrib_64bit

        #region GL_EXT_vertex_shader

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_vertex_shader</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glBeginVertexShaderEXT();</para>
        /// </summary>
        public static void BeginVertexShaderEXT() {
            GLNative.glBeginVertexShaderEXT();
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_vertex_shader</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glEndVertexShaderEXT();</para>
        /// </summary>
        public static void EndVertexShaderEXT() {
            GLNative.glEndVertexShaderEXT();
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_vertex_shader</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glBindVertexShaderEXT(GLuint id);</para>
        /// </summary>
        public static void BindVertexShaderEXT(uint id) {
            GLNative.glBindVertexShaderEXT(id);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_vertex_shader</para>
        /// Supported: <para>gl</para>
        /// Original: <para>GLuint glGenVertexShadersEXT(GLuint range);</para>
        /// </summary>
        public static uint GenVertexShadersEXT(uint range) {
            return GLNative.glGenVertexShadersEXT(range);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_vertex_shader</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glDeleteVertexShaderEXT(GLuint id);</para>
        /// </summary>
        public static void DeleteVertexShaderEXT(uint id) {
            GLNative.glDeleteVertexShaderEXT(id);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_vertex_shader</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glShaderOp1EXT(GLenum op, GLuint res, GLuint arg1);</para>
        /// </summary>
        public static void ShaderOp1EXT(uint op, uint res, uint arg1) {
            GLNative.glShaderOp1EXT(op, res, arg1);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_vertex_shader</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glShaderOp2EXT(GLenum op, GLuint res, GLuint arg1, GLuint arg2);</para>
        /// </summary>
        public static void ShaderOp2EXT(uint op, uint res, uint arg1, uint arg2) {
            GLNative.glShaderOp2EXT(op, res, arg1, arg2);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_vertex_shader</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glShaderOp3EXT(GLenum op, GLuint res, GLuint arg1, GLuint arg2, GLuint arg3);</para>
        /// </summary>
        public static void ShaderOp3EXT(uint op, uint res, uint arg1, uint arg2, uint arg3) {
            GLNative.glShaderOp3EXT(op, res, arg1, arg2, arg3);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_vertex_shader</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glSwizzleEXT(GLuint res, GLuint in, GLenum outX, GLenum outY, GLenum outZ, GLenum outW);</para>
        /// </summary>
        public static void SwizzleEXT(uint res, uint i, uint outX, uint outY, uint outZ, uint outW) {
            GLNative.glSwizzleEXT(res, i, outX, outY, outZ, outW);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_vertex_shader</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glWriteMaskEXT(GLuint res, GLuint in, GLenum outX, GLenum outY, GLenum outZ, GLenum outW);</para>
        /// </summary>
        public static void WriteMaskEXT(uint res, uint i, uint outX, uint outY, uint outZ, uint outW) {
            GLNative.glWriteMaskEXT(res, i, outX, outY, outZ, outW);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_vertex_shader</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glInsertComponentEXT(GLuint res, GLuint src, GLuint num);</para>
        /// </summary>
        public static void InsertComponentEXT(uint res, uint src, uint num) {
            GLNative.glInsertComponentEXT(res, src, num);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_vertex_shader</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glExtractComponentEXT(GLuint res, GLuint src, GLuint num);</para>
        /// </summary>
        public static void ExtractComponentEXT(uint res, uint src, uint num) {
            GLNative.glExtractComponentEXT(res, src, num);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_vertex_shader</para>
        /// Supported: <para>gl</para>
        /// Original: <para>GLuint glGenSymbolsEXT(GLenum datatype, GLenum storagetype, GLenum range, GLuint components);</para>
        /// </summary>
        public static uint GenSymbolsEXT(uint datatype, uint storagetype, uint range, uint components) {
            return GLNative.glGenSymbolsEXT(datatype, storagetype, range, components);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_vertex_shader</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glEnableVariantClientStateEXT(GLuint id);</para>
        /// </summary>
        public static void EnableVariantClientStateEXT(uint id) {
            GLNative.glEnableVariantClientStateEXT(id);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_vertex_shader</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glDisableVariantClientStateEXT(GLuint id);</para>
        /// </summary>
        public static void DisableVariantClientStateEXT(uint id) {
            GLNative.glDisableVariantClientStateEXT(id);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_vertex_shader</para>
        /// Supported: <para>gl</para>
        /// Original: <para>GLuint glBindLightParameterEXT(GLenum light, GLenum value);</para>
        /// </summary>
        public static uint BindLightParameterEXT(uint light, uint value) {
            return GLNative.glBindLightParameterEXT(light, value);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_vertex_shader</para>
        /// Supported: <para>gl</para>
        /// Original: <para>GLuint glBindMaterialParameterEXT(GLenum face, GLenum value);</para>
        /// </summary>
        public static uint BindMaterialParameterEXT(uint face, uint value) {
            return GLNative.glBindMaterialParameterEXT(face, value);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_vertex_shader</para>
        /// Supported: <para>gl</para>
        /// Original: <para>GLuint glBindTexGenParameterEXT(GLenum unit, GLenum coord, GLenum value);</para>
        /// </summary>
        public static uint BindTexGenParameterEXT(uint unit, uint coord, uint value) {
            return GLNative.glBindTexGenParameterEXT(unit, coord, value);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_vertex_shader</para>
        /// Supported: <para>gl</para>
        /// Original: <para>GLuint glBindTextureUnitParameterEXT(GLenum unit, GLenum value);</para>
        /// </summary>
        public static uint BindTextureUnitParameterEXT(uint unit, uint value) {
            return GLNative.glBindTextureUnitParameterEXT(unit, value);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_vertex_shader</para>
        /// Supported: <para>gl</para>
        /// Original: <para>GLuint glBindParameterEXT(GLenum value);</para>
        /// </summary>
        public static uint BindParameterEXT(uint value) {
            return GLNative.glBindParameterEXT(value);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_vertex_shader</para>
        /// Supported: <para>gl</para>
        /// Original: <para>GLboolean glIsVariantEnabledEXT(GLuint id, GLenum cap);</para>
        /// </summary>
        public static bool IsVariantEnabledEXT(uint id, uint cap) {
            return GLNative.glIsVariantEnabledEXT(id, cap);
        }


        #endregion GL_EXT_vertex_shader

        #region GL_EXT_vertex_weighting

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_vertex_weighting</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexWeightfEXT(GLfloat weight);</para>
        /// </summary>
        public static void VertexWeightfEXT(float weight) {
            GLNative.glVertexWeightfEXT(weight);
        }


        #endregion GL_EXT_vertex_weighting

        #region GL_EXT_win32_keyed_mutex

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_win32_keyed_mutex</para>
        /// Supported: <para>gl, gles2</para>
        /// Original: <para>GLboolean glAcquireKeyedMutexWin32EXT(GLuint memory, GLuint64 key, GLuint timeout);</para>
        /// </summary>
        public static bool AcquireKeyedMutexWin32EXT(uint memory, UInt64 key, uint timeout) {
            return GLNative.glAcquireKeyedMutexWin32EXT(memory, key, timeout);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_win32_keyed_mutex</para>
        /// Supported: <para>gl, gles2</para>
        /// Original: <para>GLboolean glReleaseKeyedMutexWin32EXT(GLuint memory, GLuint64 key);</para>
        /// </summary>
        public static bool ReleaseKeyedMutexWin32EXT(uint memory, UInt64 key) {
            return GLNative.glReleaseKeyedMutexWin32EXT(memory, key);
        }


        #endregion GL_EXT_win32_keyed_mutex

        #region GL_EXT_window_rectangles


        #endregion GL_EXT_window_rectangles

        #region GL_EXT_x11_sync_object

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_x11_sync_object</para>
        /// Supported: <para>gl</para>
        /// Original: <para>GLsync glImportSyncEXT(GLenum external_sync_type, GLintptr external_sync, GLbitfield flags);</para>
        /// </summary>
        public static IntPtr ImportSyncEXT(uint external_sync_type, IntPtr external_sync, uint flags) {
            return GLNative.glImportSyncEXT(external_sync_type, external_sync, flags);
        }


        #endregion GL_EXT_x11_sync_object

        #region GL_GREMEDY_frame_terminator

        /// <summary>
        /// <para>Require:</para> <para>GL_GREMEDY_frame_terminator</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glFrameTerminatorGREMEDY();</para>
        /// </summary>
        public static void FrameTerminatorGREMEDY() {
            GLNative.glFrameTerminatorGREMEDY();
        }


        #endregion GL_GREMEDY_frame_terminator

        #region GL_GREMEDY_string_marker


        #endregion GL_GREMEDY_string_marker

        #region GL_HP_image_transform

        /// <summary>
        /// <para>Require:</para> <para>GL_HP_image_transform</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glImageTransformParameteriHP(GLenum target, GLenum pname, GLint param);</para>
        /// </summary>
        public static void ImageTransformParameteriHP(uint target, uint pname, int param) {
            GLNative.glImageTransformParameteriHP(target, pname, param);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_HP_image_transform</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glImageTransformParameterfHP(GLenum target, GLenum pname, GLfloat param);</para>
        /// </summary>
        public static void ImageTransformParameterfHP(uint target, uint pname, float param) {
            GLNative.glImageTransformParameterfHP(target, pname, param);
        }


        #endregion GL_HP_image_transform

        #region GL_IBM_multimode_draw_arrays


        #endregion GL_IBM_multimode_draw_arrays

        #region GL_IBM_static_data

        /// <summary>
        /// <para>Require:</para> <para>GL_IBM_static_data</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glFlushStaticDataIBM(GLenum target);</para>
        /// </summary>
        public static void FlushStaticDataIBM(uint target) {
            GLNative.glFlushStaticDataIBM(target);
        }


        #endregion GL_IBM_static_data

        #region GL_IBM_vertex_array_lists


        #endregion GL_IBM_vertex_array_lists

        #region GL_INGR_blend_func_separate

        /// <summary>
        /// <para>Require:</para> <para>GL_INGR_blend_func_separate</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glBlendFuncSeparateINGR(GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha);</para>
        /// </summary>
        public static void BlendFuncSeparateINGR(uint sfactorRGB, uint dfactorRGB, uint sfactorAlpha, uint dfactorAlpha) {
            GLNative.glBlendFuncSeparateINGR(sfactorRGB, dfactorRGB, sfactorAlpha, dfactorAlpha);
        }


        #endregion GL_INGR_blend_func_separate

        #region GL_INTEL_framebuffer_CMAA

        /// <summary>
        /// <para>Require:</para> <para>GL_INTEL_framebuffer_CMAA</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glApplyFramebufferAttachmentCMAAINTEL();</para>
        /// </summary>
        public static void ApplyFramebufferAttachmentCMAAINTEL() {
            GLNative.glApplyFramebufferAttachmentCMAAINTEL();
        }


        #endregion GL_INTEL_framebuffer_CMAA

        #region GL_INTEL_map_texture

        /// <summary>
        /// <para>Require:</para> <para>GL_INTEL_map_texture</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glSyncTextureINTEL(GLuint texture);</para>
        /// </summary>
        public static void SyncTextureINTEL(uint texture) {
            GLNative.glSyncTextureINTEL(texture);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_INTEL_map_texture</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glUnmapTexture2DINTEL(GLuint texture, GLint level);</para>
        /// </summary>
        public static void UnmapTexture2DINTEL(uint texture, int level) {
            GLNative.glUnmapTexture2DINTEL(texture, level);
        }


        #endregion GL_INTEL_map_texture

        #region GL_INTEL_parallel_arrays


        #endregion GL_INTEL_parallel_arrays

        #region GL_INTEL_performance_query

        /// <summary>
        /// <para>Require:</para> <para>GL_INTEL_performance_query</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glBeginPerfQueryINTEL(GLuint queryHandle);</para>
        /// </summary>
        public static void BeginPerfQueryINTEL(uint queryHandle) {
            GLNative.glBeginPerfQueryINTEL(queryHandle);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_INTEL_performance_query</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glDeletePerfQueryINTEL(GLuint queryHandle);</para>
        /// </summary>
        public static void DeletePerfQueryINTEL(uint queryHandle) {
            GLNative.glDeletePerfQueryINTEL(queryHandle);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_INTEL_performance_query</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glEndPerfQueryINTEL(GLuint queryHandle);</para>
        /// </summary>
        public static void EndPerfQueryINTEL(uint queryHandle) {
            GLNative.glEndPerfQueryINTEL(queryHandle);
        }


        #endregion GL_INTEL_performance_query

        #region GL_KHR_blend_equation_advanced

        /// <summary>
        /// <para>Require:</para> <para>GL_KHR_blend_equation_advanced</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glBlendBarrierKHR();</para>
        /// </summary>
        public static void BlendBarrierKHR() {
            GLNative.glBlendBarrierKHR();
        }


        #endregion GL_KHR_blend_equation_advanced

        #region GL_KHR_debug

        // void glPopDebugGroup();
        /// <summary>
        /// <para>Require:</para> <para>GL_KHR_debug</para>
        /// Supported: <para>gl, glcore, gles1, gles2</para>
        /// Original: <para>void glPopDebugGroupKHR();</para>
        /// </summary>
        public static void PopDebugGroupKHR() {
            GLNative.glPopDebugGroupKHR();
        }


        #endregion GL_KHR_debug

        #region GL_KHR_robustness

        // GLenum glGetGraphicsResetStatus();
        /// <summary>
        /// <para>Require:</para> <para>GL_KHR_robustness</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>GLenum glGetGraphicsResetStatusKHR();</para>
        /// </summary>
        public static uint GetGraphicsResetStatusKHR() {
            return GLNative.glGetGraphicsResetStatusKHR();
        }


        #endregion GL_KHR_robustness

        #region GL_KHR_parallel_shader_compile

        /// <summary>
        /// <para>Require:</para> <para>GL_KHR_parallel_shader_compile</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glMaxShaderCompilerThreadsKHR(GLuint count);</para>
        /// </summary>
        public static void MaxShaderCompilerThreadsKHR(uint count) {
            GLNative.glMaxShaderCompilerThreadsKHR(count);
        }


        #endregion GL_KHR_parallel_shader_compile

        #region GL_MESA_framebuffer_flip_y

        /// <summary>
        /// <para>Require:</para> <para>GL_MESA_framebuffer_flip_y</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glFramebufferParameteriMESA(GLenum target, GLenum pname, GLint param);</para>
        /// </summary>
        public static void FramebufferParameteriMESA(uint target, uint pname, int param) {
            GLNative.glFramebufferParameteriMESA(target, pname, param);
        }


        #endregion GL_MESA_framebuffer_flip_y

        #region GL_MESA_resize_buffers

        /// <summary>
        /// <para>Require:</para> <para>GL_MESA_resize_buffers</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glResizeBuffersMESA();</para>
        /// </summary>
        public static void ResizeBuffersMESA() {
            GLNative.glResizeBuffersMESA();
        }


        #endregion GL_MESA_resize_buffers

        #region GL_MESA_window_pos

        /// <summary>
        /// <para>Require:</para> <para>GL_MESA_window_pos</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glWindowPos2dMESA(GLdouble x, GLdouble y);</para>
        /// </summary>
        public static void WindowPos2dMESA(double x, double y) {
            GLNative.glWindowPos2dMESA(x, y);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_MESA_window_pos</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glWindowPos2fMESA(GLfloat x, GLfloat y);</para>
        /// </summary>
        public static void WindowPos2fMESA(float x, float y) {
            GLNative.glWindowPos2fMESA(x, y);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_MESA_window_pos</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glWindowPos2iMESA(GLint x, GLint y);</para>
        /// </summary>
        public static void WindowPos2iMESA(int x, int y) {
            GLNative.glWindowPos2iMESA(x, y);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_MESA_window_pos</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glWindowPos2sMESA(GLshort x, GLshort y);</para>
        /// </summary>
        public static void WindowPos2sMESA(short x, short y) {
            GLNative.glWindowPos2sMESA(x, y);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_MESA_window_pos</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glWindowPos3dMESA(GLdouble x, GLdouble y, GLdouble z);</para>
        /// </summary>
        public static void WindowPos3dMESA(double x, double y, double z) {
            GLNative.glWindowPos3dMESA(x, y, z);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_MESA_window_pos</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glWindowPos3fMESA(GLfloat x, GLfloat y, GLfloat z);</para>
        /// </summary>
        public static void WindowPos3fMESA(float x, float y, float z) {
            GLNative.glWindowPos3fMESA(x, y, z);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_MESA_window_pos</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glWindowPos3iMESA(GLint x, GLint y, GLint z);</para>
        /// </summary>
        public static void WindowPos3iMESA(int x, int y, int z) {
            GLNative.glWindowPos3iMESA(x, y, z);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_MESA_window_pos</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glWindowPos3sMESA(GLshort x, GLshort y, GLshort z);</para>
        /// </summary>
        public static void WindowPos3sMESA(short x, short y, short z) {
            GLNative.glWindowPos3sMESA(x, y, z);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_MESA_window_pos</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glWindowPos4dMESA(GLdouble x, GLdouble y, GLdouble z, GLdouble w);</para>
        /// </summary>
        public static void WindowPos4dMESA(double x, double y, double z, double w) {
            GLNative.glWindowPos4dMESA(x, y, z, w);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_MESA_window_pos</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glWindowPos4fMESA(GLfloat x, GLfloat y, GLfloat z, GLfloat w);</para>
        /// </summary>
        public static void WindowPos4fMESA(float x, float y, float z, float w) {
            GLNative.glWindowPos4fMESA(x, y, z, w);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_MESA_window_pos</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glWindowPos4iMESA(GLint x, GLint y, GLint z, GLint w);</para>
        /// </summary>
        public static void WindowPos4iMESA(int x, int y, int z, int w) {
            GLNative.glWindowPos4iMESA(x, y, z, w);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_MESA_window_pos</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glWindowPos4sMESA(GLshort x, GLshort y, GLshort z, GLshort w);</para>
        /// </summary>
        public static void WindowPos4sMESA(short x, short y, short z, short w) {
            GLNative.glWindowPos4sMESA(x, y, z, w);
        }


        #endregion GL_MESA_window_pos

        #region GL_NVX_conditional_render

        /// <summary>
        /// <para>Require:</para> <para>GL_NVX_conditional_render</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glBeginConditionalRenderNVX(GLuint id);</para>
        /// </summary>
        public static void BeginConditionalRenderNVX(uint id) {
            GLNative.glBeginConditionalRenderNVX(id);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NVX_conditional_render</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glEndConditionalRenderNVX();</para>
        /// </summary>
        public static void EndConditionalRenderNVX() {
            GLNative.glEndConditionalRenderNVX();
        }


        #endregion GL_NVX_conditional_render

        #region GL_NVX_linked_gpu_multicast

        /// <summary>
        /// <para>Require:</para> <para>GL_NVX_linked_gpu_multicast</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glLGPUCopyImageSubDataNVX(GLuint sourceGpu, GLbitfield destinationGpuMask, GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srxY, GLint srcZ, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei width, GLsizei height, GLsizei depth);</para>
        /// </summary>
        public static void LGPUCopyImageSubDataNVX(uint sourceGpu, uint destinationGpuMask, uint srcName, uint srcTarget, int srcLevel, int srcX, int srxY, int srcZ, uint dstName, uint dstTarget, int dstLevel, int dstX, int dstY, int dstZ, int width, int height, int depth) {
            GLNative.glLGPUCopyImageSubDataNVX(sourceGpu, destinationGpuMask, srcName, srcTarget, srcLevel, srcX, srxY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, width, height, depth);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NVX_linked_gpu_multicast</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glLGPUInterlockNVX();</para>
        /// </summary>
        public static void LGPUInterlockNVX() {
            GLNative.glLGPUInterlockNVX();
        }


        #endregion GL_NVX_linked_gpu_multicast

        #region GL_NV_alpha_to_coverage_dither_control

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_alpha_to_coverage_dither_control</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glAlphaToCoverageDitherControlNV(GLenum mode);</para>
        /// </summary>
        public static void AlphaToCoverageDitherControlNV(uint mode) {
            GLNative.glAlphaToCoverageDitherControlNV(mode);
        }


        #endregion GL_NV_alpha_to_coverage_dither_control

        #region GL_NV_bindless_multi_draw_indirect


        #endregion GL_NV_bindless_multi_draw_indirect

        #region GL_NV_bindless_multi_draw_indirect_count


        #endregion GL_NV_bindless_multi_draw_indirect_count

        #region GL_NV_bindless_texture

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_bindless_texture</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>GLuint64 glGetTextureHandleNV(GLuint texture);</para>
        /// </summary>
        public static UInt64 GetTextureHandleNV(uint texture) {
            return GLNative.glGetTextureHandleNV(texture);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_bindless_texture</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>GLuint64 glGetTextureSamplerHandleNV(GLuint texture, GLuint sampler);</para>
        /// </summary>
        public static UInt64 GetTextureSamplerHandleNV(uint texture, uint sampler) {
            return GLNative.glGetTextureSamplerHandleNV(texture, sampler);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_bindless_texture</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glMakeTextureHandleResidentNV(GLuint64 handle);</para>
        /// </summary>
        public static void MakeTextureHandleResidentNV(UInt64 handle) {
            GLNative.glMakeTextureHandleResidentNV(handle);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_bindless_texture</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glMakeTextureHandleNonResidentNV(GLuint64 handle);</para>
        /// </summary>
        public static void MakeTextureHandleNonResidentNV(UInt64 handle) {
            GLNative.glMakeTextureHandleNonResidentNV(handle);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_bindless_texture</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>GLuint64 glGetImageHandleNV(GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum format);</para>
        /// </summary>
        public static UInt64 GetImageHandleNV(uint texture, int level, bool layered, int layer, uint format) {
            return GLNative.glGetImageHandleNV(texture, level, layered, layer, format);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_bindless_texture</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glMakeImageHandleResidentNV(GLuint64 handle, GLenum access);</para>
        /// </summary>
        public static void MakeImageHandleResidentNV(UInt64 handle, uint access) {
            GLNative.glMakeImageHandleResidentNV(handle, access);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_bindless_texture</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glMakeImageHandleNonResidentNV(GLuint64 handle);</para>
        /// </summary>
        public static void MakeImageHandleNonResidentNV(UInt64 handle) {
            GLNative.glMakeImageHandleNonResidentNV(handle);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_bindless_texture</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glUniformHandleui64NV(GLint location, GLuint64 value);</para>
        /// </summary>
        public static void UniformHandleui64NV(int location, UInt64 value) {
            GLNative.glUniformHandleui64NV(location, value);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_bindless_texture</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glProgramUniformHandleui64NV(GLuint program, GLint location, GLuint64 value);</para>
        /// </summary>
        public static void ProgramUniformHandleui64NV(uint program, int location, UInt64 value) {
            GLNative.glProgramUniformHandleui64NV(program, location, value);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_bindless_texture</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>GLboolean glIsTextureHandleResidentNV(GLuint64 handle);</para>
        /// </summary>
        public static bool IsTextureHandleResidentNV(UInt64 handle) {
            return GLNative.glIsTextureHandleResidentNV(handle);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_bindless_texture</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>GLboolean glIsImageHandleResidentNV(GLuint64 handle);</para>
        /// </summary>
        public static bool IsImageHandleResidentNV(UInt64 handle) {
            return GLNative.glIsImageHandleResidentNV(handle);
        }


        #endregion GL_NV_bindless_texture

        #region GL_NV_blend_equation_advanced

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_blend_equation_advanced</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glBlendParameteriNV(GLenum pname, GLint value);</para>
        /// </summary>
        public static void BlendParameteriNV(uint pname, int value) {
            GLNative.glBlendParameteriNV(pname, value);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_blend_equation_advanced</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glBlendBarrierNV();</para>
        /// </summary>
        public static void BlendBarrierNV() {
            GLNative.glBlendBarrierNV();
        }


        #endregion GL_NV_blend_equation_advanced

        #region GL_NV_clip_space_w_scaling

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_clip_space_w_scaling</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glViewportPositionWScaleNV(GLuint index, GLfloat xcoeff, GLfloat ycoeff);</para>
        /// </summary>
        public static void ViewportPositionWScaleNV(uint index, float xcoeff, float ycoeff) {
            GLNative.glViewportPositionWScaleNV(index, xcoeff, ycoeff);
        }


        #endregion GL_NV_clip_space_w_scaling

        #region GL_NV_command_list

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_command_list</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>GLboolean glIsStateNV(GLuint state);</para>
        /// </summary>
        public static bool IsStateNV(uint state) {
            return GLNative.glIsStateNV(state);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_command_list</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glStateCaptureNV(GLuint state, GLenum mode);</para>
        /// </summary>
        public static void StateCaptureNV(uint state, uint mode) {
            GLNative.glStateCaptureNV(state, mode);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_command_list</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>GLuint glGetCommandHeaderNV(GLenum tokenID, GLuint size);</para>
        /// </summary>
        public static uint GetCommandHeaderNV(uint tokenID, uint size) {
            return GLNative.glGetCommandHeaderNV(tokenID, size);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_command_list</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>GLushort glGetStageIndexNV(GLenum shadertype);</para>
        /// </summary>
        public static ushort GetStageIndexNV(uint shadertype) {
            return GLNative.glGetStageIndexNV(shadertype);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_command_list</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>GLboolean glIsCommandListNV(GLuint list);</para>
        /// </summary>
        public static bool IsCommandListNV(uint list) {
            return GLNative.glIsCommandListNV(list);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_command_list</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glCommandListSegmentsNV(GLuint list, GLuint segments);</para>
        /// </summary>
        public static void CommandListSegmentsNV(uint list, uint segments) {
            GLNative.glCommandListSegmentsNV(list, segments);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_command_list</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glCompileCommandListNV(GLuint list);</para>
        /// </summary>
        public static void CompileCommandListNV(uint list) {
            GLNative.glCompileCommandListNV(list);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_command_list</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glCallCommandListNV(GLuint list);</para>
        /// </summary>
        public static void CallCommandListNV(uint list) {
            GLNative.glCallCommandListNV(list);
        }


        #endregion GL_NV_command_list

        #region GL_NV_conditional_render

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_conditional_render</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glBeginConditionalRenderNV(GLuint id, GLenum mode);</para>
        /// </summary>
        public static void BeginConditionalRenderNV(uint id, uint mode) {
            GLNative.glBeginConditionalRenderNV(id, mode);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_conditional_render</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glEndConditionalRenderNV();</para>
        /// </summary>
        public static void EndConditionalRenderNV() {
            GLNative.glEndConditionalRenderNV();
        }


        #endregion GL_NV_conditional_render

        #region GL_NV_conservative_raster

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_conservative_raster</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glSubpixelPrecisionBiasNV(GLuint xbits, GLuint ybits);</para>
        /// </summary>
        public static void SubpixelPrecisionBiasNV(uint xbits, uint ybits) {
            GLNative.glSubpixelPrecisionBiasNV(xbits, ybits);
        }


        #endregion GL_NV_conservative_raster

        #region GL_NV_conservative_raster_dilate

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_conservative_raster_dilate</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glConservativeRasterParameterfNV(GLenum pname, GLfloat value);</para>
        /// </summary>
        public static void ConservativeRasterParameterfNV(uint pname, float value) {
            GLNative.glConservativeRasterParameterfNV(pname, value);
        }


        #endregion GL_NV_conservative_raster_dilate

        #region GL_NV_conservative_raster_pre_snap_triangles

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_conservative_raster_pre_snap_triangles</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glConservativeRasterParameteriNV(GLenum pname, GLint param);</para>
        /// </summary>
        public static void ConservativeRasterParameteriNV(uint pname, int param) {
            GLNative.glConservativeRasterParameteriNV(pname, param);
        }


        #endregion GL_NV_conservative_raster_pre_snap_triangles

        #region GL_NV_copy_image

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_copy_image</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glCopyImageSubDataNV(GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei width, GLsizei height, GLsizei depth);</para>
        /// </summary>
        public static void CopyImageSubDataNV(uint srcName, uint srcTarget, int srcLevel, int srcX, int srcY, int srcZ, uint dstName, uint dstTarget, int dstLevel, int dstX, int dstY, int dstZ, int width, int height, int depth) {
            GLNative.glCopyImageSubDataNV(srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, width, height, depth);
        }


        #endregion GL_NV_copy_image

        #region GL_NV_depth_buffer_float

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_depth_buffer_float</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glDepthRangedNV(GLdouble zNear, GLdouble zFar);</para>
        /// </summary>
        public static void DepthRangedNV(double zNear, double zFar) {
            GLNative.glDepthRangedNV(zNear, zFar);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_depth_buffer_float</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glClearDepthdNV(GLdouble depth);</para>
        /// </summary>
        public static void ClearDepthdNV(double depth) {
            GLNative.glClearDepthdNV(depth);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_depth_buffer_float</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glDepthBoundsdNV(GLdouble zmin, GLdouble zmax);</para>
        /// </summary>
        public static void DepthBoundsdNV(double zmin, double zmax) {
            GLNative.glDepthBoundsdNV(zmin, zmax);
        }


        #endregion GL_NV_depth_buffer_float

        #region GL_NV_draw_texture

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_draw_texture</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glDrawTextureNV(GLuint texture, GLuint sampler, GLfloat x0, GLfloat y0, GLfloat x1, GLfloat y1, GLfloat z, GLfloat s0, GLfloat t0, GLfloat s1, GLfloat t1);</para>
        /// </summary>
        public static void DrawTextureNV(uint texture, uint sampler, float x0, float y0, float x1, float y1, float z, float s0, float t0, float s1, float t1) {
            GLNative.glDrawTextureNV(texture, sampler, x0, y0, x1, y1, z, s0, t0, s1, t1);
        }


        #endregion GL_NV_draw_texture

        #region GL_NV_draw_vulkan_image

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_draw_vulkan_image</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glDrawVkImageNV(GLuint64 vkImage, GLuint sampler, GLfloat x0, GLfloat y0, GLfloat x1, GLfloat y1, GLfloat z, GLfloat s0, GLfloat t0, GLfloat s1, GLfloat t1);</para>
        /// </summary>
        public static void DrawVkImageNV(UInt64 vkImage, uint sampler, float x0, float y0, float x1, float y1, float z, float s0, float t0, float s1, float t1) {
            GLNative.glDrawVkImageNV(vkImage, sampler, x0, y0, x1, y1, z, s0, t0, s1, t1);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_draw_vulkan_image</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glWaitVkSemaphoreNV(GLuint64 vkSemaphore);</para>
        /// </summary>
        public static void WaitVkSemaphoreNV(UInt64 vkSemaphore) {
            GLNative.glWaitVkSemaphoreNV(vkSemaphore);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_draw_vulkan_image</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glSignalVkSemaphoreNV(GLuint64 vkSemaphore);</para>
        /// </summary>
        public static void SignalVkSemaphoreNV(UInt64 vkSemaphore) {
            GLNative.glSignalVkSemaphoreNV(vkSemaphore);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_draw_vulkan_image</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glSignalVkFenceNV(GLuint64 vkFence);</para>
        /// </summary>
        public static void SignalVkFenceNV(UInt64 vkFence) {
            GLNative.glSignalVkFenceNV(vkFence);
        }


        #endregion GL_NV_draw_vulkan_image

        #region GL_NV_evaluators

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_evaluators</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glEvalMapsNV(GLenum target, GLenum mode);</para>
        /// </summary>
        public static void EvalMapsNV(uint target, uint mode) {
            GLNative.glEvalMapsNV(target, mode);
        }


        #endregion GL_NV_evaluators

        #region GL_NV_explicit_multisample

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_explicit_multisample</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glSampleMaskIndexedNV(GLuint index, GLbitfield mask);</para>
        /// </summary>
        public static void SampleMaskIndexedNV(uint index, uint mask) {
            GLNative.glSampleMaskIndexedNV(index, mask);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_explicit_multisample</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glTexRenderbufferNV(GLenum target, GLuint renderbuffer);</para>
        /// </summary>
        public static void TexRenderbufferNV(uint target, uint renderbuffer) {
            GLNative.glTexRenderbufferNV(target, renderbuffer);
        }


        #endregion GL_NV_explicit_multisample

        #region GL_NV_fence

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_fence</para>
        /// Supported: <para>gl, gles1, gles2</para>
        /// Original: <para>GLboolean glIsFenceNV(GLuint fence);</para>
        /// </summary>
        public static bool IsFenceNV(uint fence) {
            return GLNative.glIsFenceNV(fence);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_fence</para>
        /// Supported: <para>gl, gles1, gles2</para>
        /// Original: <para>GLboolean glTestFenceNV(GLuint fence);</para>
        /// </summary>
        public static bool TestFenceNV(uint fence) {
            return GLNative.glTestFenceNV(fence);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_fence</para>
        /// Supported: <para>gl, gles1, gles2</para>
        /// Original: <para>void glFinishFenceNV(GLuint fence);</para>
        /// </summary>
        public static void FinishFenceNV(uint fence) {
            GLNative.glFinishFenceNV(fence);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_fence</para>
        /// Supported: <para>gl, gles1, gles2</para>
        /// Original: <para>void glSetFenceNV(GLuint fence, GLenum condition);</para>
        /// </summary>
        public static void SetFenceNV(uint fence, uint condition) {
            GLNative.glSetFenceNV(fence, condition);
        }


        #endregion GL_NV_fence

        #region GL_NV_fragment_coverage_to_color

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_fragment_coverage_to_color</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glFragmentCoverageColorNV(GLuint color);</para>
        /// </summary>
        public static void FragmentCoverageColorNV(uint color) {
            GLNative.glFragmentCoverageColorNV(color);
        }


        #endregion GL_NV_fragment_coverage_to_color

        #region GL_NV_framebuffer_mixed_samples

        // void glRasterSamplesEXT(GLuint samples, GLboolean fixedsamplelocations);
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_framebuffer_mixed_samples</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glCoverageModulationNV(GLenum components);</para>
        /// </summary>
        public static void CoverageModulationNV(uint components) {
            GLNative.glCoverageModulationNV(components);
        }


        #endregion GL_NV_framebuffer_mixed_samples

        #region GL_NV_framebuffer_multisample_coverage

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_framebuffer_multisample_coverage</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glRenderbufferStorageMultisampleCoverageNV(GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLenum internalformat, GLsizei width, GLsizei height);</para>
        /// </summary>
        public static void RenderbufferStorageMultisampleCoverageNV(uint target, int coverageSamples, int colorSamples, uint internalformat, int width, int height) {
            GLNative.glRenderbufferStorageMultisampleCoverageNV(target, coverageSamples, colorSamples, internalformat, width, height);
        }


        #endregion GL_NV_framebuffer_multisample_coverage

        #region GL_NV_geometry_program4

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_geometry_program4</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glProgramVertexLimitNV(GLenum target, GLint limit);</para>
        /// </summary>
        public static void ProgramVertexLimitNV(uint target, int limit) {
            GLNative.glProgramVertexLimitNV(target, limit);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_geometry_shader, GL_NV_geometry_program4</para>
        /// Supported: <para>gles2, gl</para>
        /// Original: <para>void glFramebufferTextureEXT(GLenum target, GLenum attachment, GLuint texture, GLint level);</para>
        /// </summary>
        public static void FramebufferTextureEXT(uint target, uint attachment, uint texture, int level) {
            GLNative.glFramebufferTextureEXT(target, attachment, texture, level);
        }

        // void glFramebufferTextureLayerEXT(GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer);
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_geometry_program4</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glFramebufferTextureFaceEXT(GLenum target, GLenum attachment, GLuint texture, GLint level, GLenum face);</para>
        /// </summary>
        public static void FramebufferTextureFaceEXT(uint target, uint attachment, uint texture, int level, uint face) {
            GLNative.glFramebufferTextureFaceEXT(target, attachment, texture, level, face);
        }


        #endregion GL_NV_geometry_program4

        #region GL_NV_gpu_program4

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_gpu_program4</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glProgramLocalParameterI4iNV(GLenum target, GLuint index, GLint x, GLint y, GLint z, GLint w);</para>
        /// </summary>
        public static void ProgramLocalParameterI4iNV(uint target, uint index, int x, int y, int z, int w) {
            GLNative.glProgramLocalParameterI4iNV(target, index, x, y, z, w);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_gpu_program4</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glProgramLocalParameterI4uiNV(GLenum target, GLuint index, GLuint x, GLuint y, GLuint z, GLuint w);</para>
        /// </summary>
        public static void ProgramLocalParameterI4uiNV(uint target, uint index, uint x, uint y, uint z, uint w) {
            GLNative.glProgramLocalParameterI4uiNV(target, index, x, y, z, w);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_gpu_program4</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glProgramEnvParameterI4iNV(GLenum target, GLuint index, GLint x, GLint y, GLint z, GLint w);</para>
        /// </summary>
        public static void ProgramEnvParameterI4iNV(uint target, uint index, int x, int y, int z, int w) {
            GLNative.glProgramEnvParameterI4iNV(target, index, x, y, z, w);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_gpu_program4</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glProgramEnvParameterI4uiNV(GLenum target, GLuint index, GLuint x, GLuint y, GLuint z, GLuint w);</para>
        /// </summary>
        public static void ProgramEnvParameterI4uiNV(uint target, uint index, uint x, uint y, uint z, uint w) {
            GLNative.glProgramEnvParameterI4uiNV(target, index, x, y, z, w);
        }


        #endregion GL_NV_gpu_program4

        #region GL_NV_gpu_program5


        #endregion GL_NV_gpu_program5

        #region GL_NV_gpu_shader5

        // void glUniform1i64NV(GLint location, GLint64EXT x);
        // void glUniform2i64NV(GLint location, GLint64EXT x, GLint64EXT y);
        // void glUniform3i64NV(GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z);
        // void glUniform4i64NV(GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z, GLint64EXT w);
        // void glUniform1ui64NV(GLint location, GLuint64EXT x);
        // void glUniform2ui64NV(GLint location, GLuint64EXT x, GLuint64EXT y);
        // void glUniform3ui64NV(GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z);
        // void glUniform4ui64NV(GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z, GLuint64EXT w);
        // void glProgramUniform1i64NV(GLuint program, GLint location, GLint64EXT x);
        // void glProgramUniform2i64NV(GLuint program, GLint location, GLint64EXT x, GLint64EXT y);
        // void glProgramUniform3i64NV(GLuint program, GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z);
        // void glProgramUniform4i64NV(GLuint program, GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z, GLint64EXT w);
        // void glProgramUniform1ui64NV(GLuint program, GLint location, GLuint64EXT x);
        // void glProgramUniform2ui64NV(GLuint program, GLint location, GLuint64EXT x, GLuint64EXT y);
        // void glProgramUniform3ui64NV(GLuint program, GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z);
        // void glProgramUniform4ui64NV(GLuint program, GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z, GLuint64EXT w);

        #endregion GL_NV_gpu_shader5

        #region GL_NV_half_float

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_half_float</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertex2hNV(GLhalfNV x, GLhalfNV y);</para>
        /// </summary>
        public static void Vertex2hNV(ushort x, ushort y) {
            GLNative.glVertex2hNV(x, y);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_half_float</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertex3hNV(GLhalfNV x, GLhalfNV y, GLhalfNV z);</para>
        /// </summary>
        public static void Vertex3hNV(ushort x, ushort y, ushort z) {
            GLNative.glVertex3hNV(x, y, z);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_half_float</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertex4hNV(GLhalfNV x, GLhalfNV y, GLhalfNV z, GLhalfNV w);</para>
        /// </summary>
        public static void Vertex4hNV(ushort x, ushort y, ushort z, ushort w) {
            GLNative.glVertex4hNV(x, y, z, w);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_half_float</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glNormal3hNV(GLhalfNV nx, GLhalfNV ny, GLhalfNV nz);</para>
        /// </summary>
        public static void Normal3hNV(ushort nx, ushort ny, ushort nz) {
            GLNative.glNormal3hNV(nx, ny, nz);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_half_float</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glColor3hNV(GLhalfNV red, GLhalfNV green, GLhalfNV blue);</para>
        /// </summary>
        public static void Color3hNV(ushort red, ushort green, ushort blue) {
            GLNative.glColor3hNV(red, green, blue);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_half_float</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glColor4hNV(GLhalfNV red, GLhalfNV green, GLhalfNV blue, GLhalfNV alpha);</para>
        /// </summary>
        public static void Color4hNV(ushort red, ushort green, ushort blue, ushort alpha) {
            GLNative.glColor4hNV(red, green, blue, alpha);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_half_float</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glTexCoord1hNV(GLhalfNV s);</para>
        /// </summary>
        public static void TexCoord1hNV(ushort s) {
            GLNative.glTexCoord1hNV(s);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_half_float</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glTexCoord2hNV(GLhalfNV s, GLhalfNV t);</para>
        /// </summary>
        public static void TexCoord2hNV(ushort s, ushort t) {
            GLNative.glTexCoord2hNV(s, t);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_half_float</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glTexCoord3hNV(GLhalfNV s, GLhalfNV t, GLhalfNV r);</para>
        /// </summary>
        public static void TexCoord3hNV(ushort s, ushort t, ushort r) {
            GLNative.glTexCoord3hNV(s, t, r);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_half_float</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glTexCoord4hNV(GLhalfNV s, GLhalfNV t, GLhalfNV r, GLhalfNV q);</para>
        /// </summary>
        public static void TexCoord4hNV(ushort s, ushort t, ushort r, ushort q) {
            GLNative.glTexCoord4hNV(s, t, r, q);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_half_float</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glMultiTexCoord1hNV(GLenum target, GLhalfNV s);</para>
        /// </summary>
        public static void MultiTexCoord1hNV(uint target, ushort s) {
            GLNative.glMultiTexCoord1hNV(target, s);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_half_float</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glMultiTexCoord2hNV(GLenum target, GLhalfNV s, GLhalfNV t);</para>
        /// </summary>
        public static void MultiTexCoord2hNV(uint target, ushort s, ushort t) {
            GLNative.glMultiTexCoord2hNV(target, s, t);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_half_float</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glMultiTexCoord3hNV(GLenum target, GLhalfNV s, GLhalfNV t, GLhalfNV r);</para>
        /// </summary>
        public static void MultiTexCoord3hNV(uint target, ushort s, ushort t, ushort r) {
            GLNative.glMultiTexCoord3hNV(target, s, t, r);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_half_float</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glMultiTexCoord4hNV(GLenum target, GLhalfNV s, GLhalfNV t, GLhalfNV r, GLhalfNV q);</para>
        /// </summary>
        public static void MultiTexCoord4hNV(uint target, ushort s, ushort t, ushort r, ushort q) {
            GLNative.glMultiTexCoord4hNV(target, s, t, r, q);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_half_float</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glFogCoordhNV(GLhalfNV fog);</para>
        /// </summary>
        public static void FogCoordhNV(ushort fog) {
            GLNative.glFogCoordhNV(fog);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_half_float</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glSecondaryColor3hNV(GLhalfNV red, GLhalfNV green, GLhalfNV blue);</para>
        /// </summary>
        public static void SecondaryColor3hNV(ushort red, ushort green, ushort blue) {
            GLNative.glSecondaryColor3hNV(red, green, blue);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_half_float</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexWeighthNV(GLhalfNV weight);</para>
        /// </summary>
        public static void VertexWeighthNV(ushort weight) {
            GLNative.glVertexWeighthNV(weight);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_half_float</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexAttrib1hNV(GLuint index, GLhalfNV x);</para>
        /// </summary>
        public static void VertexAttrib1hNV(uint index, ushort x) {
            GLNative.glVertexAttrib1hNV(index, x);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_half_float</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexAttrib2hNV(GLuint index, GLhalfNV x, GLhalfNV y);</para>
        /// </summary>
        public static void VertexAttrib2hNV(uint index, ushort x, ushort y) {
            GLNative.glVertexAttrib2hNV(index, x, y);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_half_float</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexAttrib3hNV(GLuint index, GLhalfNV x, GLhalfNV y, GLhalfNV z);</para>
        /// </summary>
        public static void VertexAttrib3hNV(uint index, ushort x, ushort y, ushort z) {
            GLNative.glVertexAttrib3hNV(index, x, y, z);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_half_float</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexAttrib4hNV(GLuint index, GLhalfNV x, GLhalfNV y, GLhalfNV z, GLhalfNV w);</para>
        /// </summary>
        public static void VertexAttrib4hNV(uint index, ushort x, ushort y, ushort z, ushort w) {
            GLNative.glVertexAttrib4hNV(index, x, y, z, w);
        }


        #endregion GL_NV_half_float

        #region GL_NV_internalformat_sample_query


        #endregion GL_NV_internalformat_sample_query

        #region GL_NV_gpu_multicast

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_gpu_multicast</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glRenderGpuMaskNV(GLbitfield mask);</para>
        /// </summary>
        public static void RenderGpuMaskNV(uint mask) {
            GLNative.glRenderGpuMaskNV(mask);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_gpu_multicast</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glMulticastCopyBufferSubDataNV(GLuint readGpu, GLbitfield writeGpuMask, GLuint readBuffer, GLuint writeBuffer, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size);</para>
        /// </summary>
        public static void MulticastCopyBufferSubDataNV(uint readGpu, uint writeGpuMask, uint readBuffer, uint writeBuffer, IntPtr readOffset, IntPtr writeOffset, IntPtr size) {
            GLNative.glMulticastCopyBufferSubDataNV(readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_gpu_multicast</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glMulticastCopyImageSubDataNV(GLuint srcGpu, GLbitfield dstGpuMask, GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei srcWidth, GLsizei srcHeight, GLsizei srcDepth);</para>
        /// </summary>
        public static void MulticastCopyImageSubDataNV(uint srcGpu, uint dstGpuMask, uint srcName, uint srcTarget, int srcLevel, int srcX, int srcY, int srcZ, uint dstName, uint dstTarget, int dstLevel, int dstX, int dstY, int dstZ, int srcWidth, int srcHeight, int srcDepth) {
            GLNative.glMulticastCopyImageSubDataNV(srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_gpu_multicast</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glMulticastBlitFramebufferNV(GLuint srcGpu, GLuint dstGpu, GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter);</para>
        /// </summary>
        public static void MulticastBlitFramebufferNV(uint srcGpu, uint dstGpu, int srcX0, int srcY0, int srcX1, int srcY1, int dstX0, int dstY0, int dstX1, int dstY1, uint mask, uint filter) {
            GLNative.glMulticastBlitFramebufferNV(srcGpu, dstGpu, srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_gpu_multicast</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glMulticastBarrierNV();</para>
        /// </summary>
        public static void MulticastBarrierNV() {
            GLNative.glMulticastBarrierNV();
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_gpu_multicast</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glMulticastWaitSyncNV(GLuint signalGpu, GLbitfield waitGpuMask);</para>
        /// </summary>
        public static void MulticastWaitSyncNV(uint signalGpu, uint waitGpuMask) {
            GLNative.glMulticastWaitSyncNV(signalGpu, waitGpuMask);
        }


        #endregion GL_NV_gpu_multicast

        #region GL_NVX_gpu_multicast2

        /// <summary>
        /// <para>Require:</para> <para>GL_NVX_gpu_multicast2</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glUploadGpuMaskNVX(GLbitfield mask);</para>
        /// </summary>
        public static void UploadGpuMaskNVX(uint mask) {
            GLNative.glUploadGpuMaskNVX(mask);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NVX_gpu_multicast2</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glMulticastViewportPositionWScaleNVX(GLuint gpu, GLuint index, GLfloat xcoeff, GLfloat ycoeff);</para>
        /// </summary>
        public static void MulticastViewportPositionWScaleNVX(uint gpu, uint index, float xcoeff, float ycoeff) {
            GLNative.glMulticastViewportPositionWScaleNVX(gpu, index, xcoeff, ycoeff);
        }


        #endregion GL_NVX_gpu_multicast2

        #region GL_NVX_progress_fence

        /// <summary>
        /// <para>Require:</para> <para>GL_NVX_progress_fence</para>
        /// Supported: <para>gl</para>
        /// Original: <para>GLuint glCreateProgressFenceNVX();</para>
        /// </summary>
        public static uint CreateProgressFenceNVX() {
            return GLNative.glCreateProgressFenceNVX();
        }


        #endregion GL_NVX_progress_fence

        #region GL_NV_memory_attachment

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_memory_attachment</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glResetMemoryObjectParameterNV(GLuint memory, GLenum pname);</para>
        /// </summary>
        public static void ResetMemoryObjectParameterNV(uint memory, uint pname) {
            GLNative.glResetMemoryObjectParameterNV(memory, pname);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_memory_attachment</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glTexAttachMemoryNV(GLenum target, GLuint memory, GLuint64 offset);</para>
        /// </summary>
        public static void TexAttachMemoryNV(uint target, uint memory, UInt64 offset) {
            GLNative.glTexAttachMemoryNV(target, memory, offset);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_memory_attachment</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glBufferAttachMemoryNV(GLenum target, GLuint memory, GLuint64 offset);</para>
        /// </summary>
        public static void BufferAttachMemoryNV(uint target, uint memory, UInt64 offset) {
            GLNative.glBufferAttachMemoryNV(target, memory, offset);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_memory_attachment</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glTextureAttachMemoryNV(GLuint texture, GLuint memory, GLuint64 offset);</para>
        /// </summary>
        public static void TextureAttachMemoryNV(uint texture, uint memory, UInt64 offset) {
            GLNative.glTextureAttachMemoryNV(texture, memory, offset);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_memory_attachment</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glNamedBufferAttachMemoryNV(GLuint buffer, GLuint memory, GLuint64 offset);</para>
        /// </summary>
        public static void NamedBufferAttachMemoryNV(uint buffer, uint memory, UInt64 offset) {
            GLNative.glNamedBufferAttachMemoryNV(buffer, memory, offset);
        }


        #endregion GL_NV_memory_attachment

        #region GL_NV_memory_object_sparse

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_memory_object_sparse</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glBufferPageCommitmentMemNV(GLenum target, GLintptr offset, GLsizeiptr size, GLuint memory, GLuint64 memOffset, GLboolean commit);</para>
        /// </summary>
        public static void BufferPageCommitmentMemNV(uint target, IntPtr offset, IntPtr size, uint memory, UInt64 memOffset, bool commit) {
            GLNative.glBufferPageCommitmentMemNV(target, offset, size, memory, memOffset, commit);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_memory_object_sparse</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glTexPageCommitmentMemNV(GLenum target, GLint layer, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLuint memory, GLuint64 offset, GLboolean commit);</para>
        /// </summary>
        public static void TexPageCommitmentMemNV(uint target, int layer, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, uint memory, UInt64 offset, bool commit) {
            GLNative.glTexPageCommitmentMemNV(target, layer, level, xoffset, yoffset, zoffset, width, height, depth, memory, offset, commit);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_memory_object_sparse</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glNamedBufferPageCommitmentMemNV(GLuint buffer, GLintptr offset, GLsizeiptr size, GLuint memory, GLuint64 memOffset, GLboolean commit);</para>
        /// </summary>
        public static void NamedBufferPageCommitmentMemNV(uint buffer, IntPtr offset, IntPtr size, uint memory, UInt64 memOffset, bool commit) {
            GLNative.glNamedBufferPageCommitmentMemNV(buffer, offset, size, memory, memOffset, commit);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_memory_object_sparse</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glTexturePageCommitmentMemNV(GLuint texture, GLint layer, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLuint memory, GLuint64 offset, GLboolean commit);</para>
        /// </summary>
        public static void TexturePageCommitmentMemNV(uint texture, int layer, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, uint memory, UInt64 offset, bool commit) {
            GLNative.glTexturePageCommitmentMemNV(texture, layer, level, xoffset, yoffset, zoffset, width, height, depth, memory, offset, commit);
        }


        #endregion GL_NV_memory_object_sparse

        #region GL_NV_mesh_shader

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_mesh_shader</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glDrawMeshTasksNV(GLuint first, GLuint count);</para>
        /// </summary>
        public static void DrawMeshTasksNV(uint first, uint count) {
            GLNative.glDrawMeshTasksNV(first, count);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_mesh_shader</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glDrawMeshTasksIndirectNV(GLintptr indirect);</para>
        /// </summary>
        public static void DrawMeshTasksIndirectNV(IntPtr indirect) {
            GLNative.glDrawMeshTasksIndirectNV(indirect);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_mesh_shader</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glMultiDrawMeshTasksIndirectNV(GLintptr indirect, GLsizei drawcount, GLsizei stride);</para>
        /// </summary>
        public static void MultiDrawMeshTasksIndirectNV(IntPtr indirect, int drawcount, int stride) {
            GLNative.glMultiDrawMeshTasksIndirectNV(indirect, drawcount, stride);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_mesh_shader</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glMultiDrawMeshTasksIndirectCountNV(GLintptr indirect, GLintptr drawcount, GLsizei maxdrawcount, GLsizei stride);</para>
        /// </summary>
        public static void MultiDrawMeshTasksIndirectCountNV(IntPtr indirect, IntPtr drawcount, int maxdrawcount, int stride) {
            GLNative.glMultiDrawMeshTasksIndirectCountNV(indirect, drawcount, maxdrawcount, stride);
        }


        #endregion GL_NV_mesh_shader

        #region GL_NV_occlusion_query

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_occlusion_query</para>
        /// Supported: <para>gl</para>
        /// Original: <para>GLboolean glIsOcclusionQueryNV(GLuint id);</para>
        /// </summary>
        public static bool IsOcclusionQueryNV(uint id) {
            return GLNative.glIsOcclusionQueryNV(id);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_occlusion_query</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glBeginOcclusionQueryNV(GLuint id);</para>
        /// </summary>
        public static void BeginOcclusionQueryNV(uint id) {
            GLNative.glBeginOcclusionQueryNV(id);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_occlusion_query</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glEndOcclusionQueryNV();</para>
        /// </summary>
        public static void EndOcclusionQueryNV() {
            GLNative.glEndOcclusionQueryNV();
        }


        #endregion GL_NV_occlusion_query

        #region GL_NV_parameter_buffer_object


        #endregion GL_NV_parameter_buffer_object

        #region GL_NV_path_rendering

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_path_rendering</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>GLuint glGenPathsNV(GLsizei range);</para>
        /// </summary>
        public static uint GenPathsNV(int range) {
            return GLNative.glGenPathsNV(range);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_path_rendering</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glDeletePathsNV(GLuint path, GLsizei range);</para>
        /// </summary>
        public static void DeletePathsNV(uint path, int range) {
            GLNative.glDeletePathsNV(path, range);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_path_rendering</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>GLboolean glIsPathNV(GLuint path);</para>
        /// </summary>
        public static bool IsPathNV(uint path) {
            return GLNative.glIsPathNV(path);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_path_rendering</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glCopyPathNV(GLuint resultPath, GLuint srcPath);</para>
        /// </summary>
        public static void CopyPathNV(uint resultPath, uint srcPath) {
            GLNative.glCopyPathNV(resultPath, srcPath);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_path_rendering</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glInterpolatePathsNV(GLuint resultPath, GLuint pathA, GLuint pathB, GLfloat weight);</para>
        /// </summary>
        public static void InterpolatePathsNV(uint resultPath, uint pathA, uint pathB, float weight) {
            GLNative.glInterpolatePathsNV(resultPath, pathA, pathB, weight);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_path_rendering</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glPathParameteriNV(GLuint path, GLenum pname, GLint value);</para>
        /// </summary>
        public static void PathParameteriNV(uint path, uint pname, int value) {
            GLNative.glPathParameteriNV(path, pname, value);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_path_rendering</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glPathParameterfNV(GLuint path, GLenum pname, GLfloat value);</para>
        /// </summary>
        public static void PathParameterfNV(uint path, uint pname, float value) {
            GLNative.glPathParameterfNV(path, pname, value);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_path_rendering</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glPathStencilFuncNV(GLenum func, GLint ref, GLuint mask);</para>
        /// </summary>
        public static void PathStencilFuncNV(uint func, int r, uint mask) {
            GLNative.glPathStencilFuncNV(func, r, mask);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_path_rendering</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glPathStencilDepthOffsetNV(GLfloat factor, GLfloat units);</para>
        /// </summary>
        public static void PathStencilDepthOffsetNV(float factor, float units) {
            GLNative.glPathStencilDepthOffsetNV(factor, units);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_path_rendering</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glStencilFillPathNV(GLuint path, GLenum fillMode, GLuint mask);</para>
        /// </summary>
        public static void StencilFillPathNV(uint path, uint fillMode, uint mask) {
            GLNative.glStencilFillPathNV(path, fillMode, mask);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_path_rendering</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glStencilStrokePathNV(GLuint path, GLint reference, GLuint mask);</para>
        /// </summary>
        public static void StencilStrokePathNV(uint path, int reference, uint mask) {
            GLNative.glStencilStrokePathNV(path, reference, mask);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_path_rendering</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glPathCoverDepthFuncNV(GLenum func);</para>
        /// </summary>
        public static void PathCoverDepthFuncNV(uint func) {
            GLNative.glPathCoverDepthFuncNV(func);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_path_rendering</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glCoverFillPathNV(GLuint path, GLenum coverMode);</para>
        /// </summary>
        public static void CoverFillPathNV(uint path, uint coverMode) {
            GLNative.glCoverFillPathNV(path, coverMode);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_path_rendering</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glCoverStrokePathNV(GLuint path, GLenum coverMode);</para>
        /// </summary>
        public static void CoverStrokePathNV(uint path, uint coverMode) {
            GLNative.glCoverStrokePathNV(path, coverMode);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_path_rendering</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>GLboolean glIsPointInFillPathNV(GLuint path, GLuint mask, GLfloat x, GLfloat y);</para>
        /// </summary>
        public static bool IsPointInFillPathNV(uint path, uint mask, float x, float y) {
            return GLNative.glIsPointInFillPathNV(path, mask, x, y);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_path_rendering</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>GLboolean glIsPointInStrokePathNV(GLuint path, GLfloat x, GLfloat y);</para>
        /// </summary>
        public static bool IsPointInStrokePathNV(uint path, float x, float y) {
            return GLNative.glIsPointInStrokePathNV(path, x, y);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_path_rendering</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>GLfloat glGetPathLengthNV(GLuint path, GLsizei startSegment, GLsizei numSegments);</para>
        /// </summary>
        public static float GetPathLengthNV(uint path, int startSegment, int numSegments) {
            return GLNative.glGetPathLengthNV(path, startSegment, numSegments);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_path_rendering</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glStencilThenCoverFillPathNV(GLuint path, GLenum fillMode, GLuint mask, GLenum coverMode);</para>
        /// </summary>
        public static void StencilThenCoverFillPathNV(uint path, uint fillMode, uint mask, uint coverMode) {
            GLNative.glStencilThenCoverFillPathNV(path, fillMode, mask, coverMode);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_path_rendering</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glStencilThenCoverStrokePathNV(GLuint path, GLint reference, GLuint mask, GLenum coverMode);</para>
        /// </summary>
        public static void StencilThenCoverStrokePathNV(uint path, int reference, uint mask, uint coverMode) {
            GLNative.glStencilThenCoverStrokePathNV(path, reference, mask, coverMode);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_path_rendering</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glPathFogGenNV(GLenum genMode);</para>
        /// </summary>
        public static void PathFogGenNV(uint genMode) {
            GLNative.glPathFogGenNV(genMode);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_direct_state_access, GL_NV_path_rendering</para>
        /// Supported: <para>gl, glcore, gl, glcore, gles2</para>
        /// Original: <para>void glMatrixFrustumEXT(GLenum mode, GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar);</para>
        /// </summary>
        public static void MatrixFrustumEXT(uint mode, double left, double right, double bottom, double top, double zNear, double zFar) {
            GLNative.glMatrixFrustumEXT(mode, left, right, bottom, top, zNear, zFar);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_direct_state_access, GL_NV_path_rendering</para>
        /// Supported: <para>gl, glcore, gl, glcore, gles2</para>
        /// Original: <para>void glMatrixLoadIdentityEXT(GLenum mode);</para>
        /// </summary>
        public static void MatrixLoadIdentityEXT(uint mode) {
            GLNative.glMatrixLoadIdentityEXT(mode);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_direct_state_access, GL_NV_path_rendering</para>
        /// Supported: <para>gl, glcore, gl, glcore, gles2</para>
        /// Original: <para>void glMatrixOrthoEXT(GLenum mode, GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar);</para>
        /// </summary>
        public static void MatrixOrthoEXT(uint mode, double left, double right, double bottom, double top, double zNear, double zFar) {
            GLNative.glMatrixOrthoEXT(mode, left, right, bottom, top, zNear, zFar);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_direct_state_access, GL_NV_path_rendering</para>
        /// Supported: <para>gl, glcore, gl, glcore, gles2</para>
        /// Original: <para>void glMatrixPopEXT(GLenum mode);</para>
        /// </summary>
        public static void MatrixPopEXT(uint mode) {
            GLNative.glMatrixPopEXT(mode);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_direct_state_access, GL_NV_path_rendering</para>
        /// Supported: <para>gl, glcore, gl, glcore, gles2</para>
        /// Original: <para>void glMatrixPushEXT(GLenum mode);</para>
        /// </summary>
        public static void MatrixPushEXT(uint mode) {
            GLNative.glMatrixPushEXT(mode);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_direct_state_access, GL_NV_path_rendering</para>
        /// Supported: <para>gl, glcore, gl, glcore, gles2</para>
        /// Original: <para>void glMatrixRotatefEXT(GLenum mode, GLfloat angle, GLfloat x, GLfloat y, GLfloat z);</para>
        /// </summary>
        public static void MatrixRotatefEXT(uint mode, float angle, float x, float y, float z) {
            GLNative.glMatrixRotatefEXT(mode, angle, x, y, z);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_direct_state_access, GL_NV_path_rendering</para>
        /// Supported: <para>gl, glcore, gl, glcore, gles2</para>
        /// Original: <para>void glMatrixRotatedEXT(GLenum mode, GLdouble angle, GLdouble x, GLdouble y, GLdouble z);</para>
        /// </summary>
        public static void MatrixRotatedEXT(uint mode, double angle, double x, double y, double z) {
            GLNative.glMatrixRotatedEXT(mode, angle, x, y, z);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_direct_state_access, GL_NV_path_rendering</para>
        /// Supported: <para>gl, glcore, gl, glcore, gles2</para>
        /// Original: <para>void glMatrixScalefEXT(GLenum mode, GLfloat x, GLfloat y, GLfloat z);</para>
        /// </summary>
        public static void MatrixScalefEXT(uint mode, float x, float y, float z) {
            GLNative.glMatrixScalefEXT(mode, x, y, z);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_direct_state_access, GL_NV_path_rendering</para>
        /// Supported: <para>gl, glcore, gl, glcore, gles2</para>
        /// Original: <para>void glMatrixScaledEXT(GLenum mode, GLdouble x, GLdouble y, GLdouble z);</para>
        /// </summary>
        public static void MatrixScaledEXT(uint mode, double x, double y, double z) {
            GLNative.glMatrixScaledEXT(mode, x, y, z);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_direct_state_access, GL_NV_path_rendering</para>
        /// Supported: <para>gl, glcore, gl, glcore, gles2</para>
        /// Original: <para>void glMatrixTranslatefEXT(GLenum mode, GLfloat x, GLfloat y, GLfloat z);</para>
        /// </summary>
        public static void MatrixTranslatefEXT(uint mode, float x, float y, float z) {
            GLNative.glMatrixTranslatefEXT(mode, x, y, z);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_direct_state_access, GL_NV_path_rendering</para>
        /// Supported: <para>gl, glcore, gl, glcore, gles2</para>
        /// Original: <para>void glMatrixTranslatedEXT(GLenum mode, GLdouble x, GLdouble y, GLdouble z);</para>
        /// </summary>
        public static void MatrixTranslatedEXT(uint mode, double x, double y, double z) {
            GLNative.glMatrixTranslatedEXT(mode, x, y, z);
        }


        #endregion GL_NV_path_rendering

        #region GL_NV_pixel_data_range

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_pixel_data_range</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glFlushPixelDataRangeNV(GLenum target);</para>
        /// </summary>
        public static void FlushPixelDataRangeNV(uint target) {
            GLNative.glFlushPixelDataRangeNV(target);
        }


        #endregion GL_NV_pixel_data_range

        #region GL_NV_point_sprite

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_point_sprite</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glPointParameteriNV(GLenum pname, GLint param);</para>
        /// </summary>
        public static void PointParameteriNV(uint pname, int param) {
            GLNative.glPointParameteriNV(pname, param);
        }


        #endregion GL_NV_point_sprite

        #region GL_NV_present_video

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_present_video</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glPresentFrameKeyedNV(GLuint video_slot, GLuint64EXT minPresentTime, GLuint beginPresentTimeId, GLuint presentDurationId, GLenum type, GLenum target0, GLuint fill0, GLuint key0, GLenum target1, GLuint fill1, GLuint key1);</para>
        /// </summary>
        public static void PresentFrameKeyedNV(uint video_slot, UInt64 minPresentTime, uint beginPresentTimeId, uint presentDurationId, uint type, uint target0, uint fill0, uint key0, uint target1, uint fill1, uint key1) {
            GLNative.glPresentFrameKeyedNV(video_slot, minPresentTime, beginPresentTimeId, presentDurationId, type, target0, fill0, key0, target1, fill1, key1);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_present_video</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glPresentFrameDualFillNV(GLuint video_slot, GLuint64EXT minPresentTime, GLuint beginPresentTimeId, GLuint presentDurationId, GLenum type, GLenum target0, GLuint fill0, GLenum target1, GLuint fill1, GLenum target2, GLuint fill2, GLenum target3, GLuint fill3);</para>
        /// </summary>
        public static void PresentFrameDualFillNV(uint video_slot, UInt64 minPresentTime, uint beginPresentTimeId, uint presentDurationId, uint type, uint target0, uint fill0, uint target1, uint fill1, uint target2, uint fill2, uint target3, uint fill3) {
            GLNative.glPresentFrameDualFillNV(video_slot, minPresentTime, beginPresentTimeId, presentDurationId, type, target0, fill0, target1, fill1, target2, fill2, target3, fill3);
        }


        #endregion GL_NV_present_video

        #region GL_NV_primitive_restart

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_primitive_restart</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glPrimitiveRestartNV();</para>
        /// </summary>
        public static void PrimitiveRestartNV() {
            GLNative.glPrimitiveRestartNV();
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_primitive_restart</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glPrimitiveRestartIndexNV(GLuint index);</para>
        /// </summary>
        public static void PrimitiveRestartIndexNV(uint index) {
            GLNative.glPrimitiveRestartIndexNV(index);
        }


        #endregion GL_NV_primitive_restart

        #region GL_NV_query_resource


        #endregion GL_NV_query_resource

        #region GL_NV_query_resource_tag


        #endregion GL_NV_query_resource_tag

        #region GL_NV_register_combiners

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_register_combiners</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glCombinerParameterfNV(GLenum pname, GLfloat param);</para>
        /// </summary>
        public static void CombinerParameterfNV(uint pname, float param) {
            GLNative.glCombinerParameterfNV(pname, param);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_register_combiners</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glCombinerParameteriNV(GLenum pname, GLint param);</para>
        /// </summary>
        public static void CombinerParameteriNV(uint pname, int param) {
            GLNative.glCombinerParameteriNV(pname, param);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_register_combiners</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glCombinerInputNV(GLenum stage, GLenum portion, GLenum variable, GLenum input, GLenum mapping, GLenum componentUsage);</para>
        /// </summary>
        public static void CombinerInputNV(uint stage, uint portion, uint variable, uint input, uint mapping, uint componentUsage) {
            GLNative.glCombinerInputNV(stage, portion, variable, input, mapping, componentUsage);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_register_combiners</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glCombinerOutputNV(GLenum stage, GLenum portion, GLenum abOutput, GLenum cdOutput, GLenum sumOutput, GLenum scale, GLenum bias, GLboolean abDotProduct, GLboolean cdDotProduct, GLboolean muxSum);</para>
        /// </summary>
        public static void CombinerOutputNV(uint stage, uint portion, uint abOutput, uint cdOutput, uint sumOutput, uint scale, uint bias, bool abDotProduct, bool cdDotProduct, bool muxSum) {
            GLNative.glCombinerOutputNV(stage, portion, abOutput, cdOutput, sumOutput, scale, bias, abDotProduct, cdDotProduct, muxSum);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_register_combiners</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glFinalCombinerInputNV(GLenum variable, GLenum input, GLenum mapping, GLenum componentUsage);</para>
        /// </summary>
        public static void FinalCombinerInputNV(uint variable, uint input, uint mapping, uint componentUsage) {
            GLNative.glFinalCombinerInputNV(variable, input, mapping, componentUsage);
        }


        #endregion GL_NV_register_combiners

        #region GL_NV_register_combiners2


        #endregion GL_NV_register_combiners2

        #region GL_NV_sample_locations

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_sample_locations</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glResolveDepthValuesNV();</para>
        /// </summary>
        public static void ResolveDepthValuesNV() {
            GLNative.glResolveDepthValuesNV();
        }


        #endregion GL_NV_sample_locations

        #region GL_NV_scissor_exclusive

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_scissor_exclusive</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glScissorExclusiveNV(GLint x, GLint y, GLsizei width, GLsizei height);</para>
        /// </summary>
        public static void ScissorExclusiveNV(int x, int y, int width, int height) {
            GLNative.glScissorExclusiveNV(x, y, width, height);
        }


        #endregion GL_NV_scissor_exclusive

        #region GL_NV_shader_buffer_load

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_shader_buffer_load</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glMakeBufferResidentNV(GLenum target, GLenum access);</para>
        /// </summary>
        public static void MakeBufferResidentNV(uint target, uint access) {
            GLNative.glMakeBufferResidentNV(target, access);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_shader_buffer_load</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glMakeBufferNonResidentNV(GLenum target);</para>
        /// </summary>
        public static void MakeBufferNonResidentNV(uint target) {
            GLNative.glMakeBufferNonResidentNV(target);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_shader_buffer_load</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>GLboolean glIsBufferResidentNV(GLenum target);</para>
        /// </summary>
        public static bool IsBufferResidentNV(uint target) {
            return GLNative.glIsBufferResidentNV(target);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_shader_buffer_load</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glMakeNamedBufferResidentNV(GLuint buffer, GLenum access);</para>
        /// </summary>
        public static void MakeNamedBufferResidentNV(uint buffer, uint access) {
            GLNative.glMakeNamedBufferResidentNV(buffer, access);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_shader_buffer_load</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glMakeNamedBufferNonResidentNV(GLuint buffer);</para>
        /// </summary>
        public static void MakeNamedBufferNonResidentNV(uint buffer) {
            GLNative.glMakeNamedBufferNonResidentNV(buffer);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_shader_buffer_load</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>GLboolean glIsNamedBufferResidentNV(GLuint buffer);</para>
        /// </summary>
        public static bool IsNamedBufferResidentNV(uint buffer) {
            return GLNative.glIsNamedBufferResidentNV(buffer);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_shader_buffer_load</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glUniformui64NV(GLint location, GLuint64EXT value);</para>
        /// </summary>
        public static void Uniformui64NV(int location, UInt64 value) {
            GLNative.glUniformui64NV(location, value);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_shader_buffer_load</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glProgramUniformui64NV(GLuint program, GLint location, GLuint64EXT value);</para>
        /// </summary>
        public static void ProgramUniformui64NV(uint program, int location, UInt64 value) {
            GLNative.glProgramUniformui64NV(program, location, value);
        }


        #endregion GL_NV_shader_buffer_load

        #region GL_NV_shading_rate_image

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_shading_rate_image</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glBindShadingRateImageNV(GLuint texture);</para>
        /// </summary>
        public static void BindShadingRateImageNV(uint texture) {
            GLNative.glBindShadingRateImageNV(texture);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_shading_rate_image</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glShadingRateImageBarrierNV(GLboolean synchronize);</para>
        /// </summary>
        public static void ShadingRateImageBarrierNV(bool synchronize) {
            GLNative.glShadingRateImageBarrierNV(synchronize);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_shading_rate_image</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glShadingRateSampleOrderNV(GLenum order);</para>
        /// </summary>
        public static void ShadingRateSampleOrderNV(uint order) {
            GLNative.glShadingRateSampleOrderNV(order);
        }


        #endregion GL_NV_shading_rate_image

        #region GL_NV_texture_barrier

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_texture_barrier</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glTextureBarrierNV();</para>
        /// </summary>
        public static void TextureBarrierNV() {
            GLNative.glTextureBarrierNV();
        }


        #endregion GL_NV_texture_barrier

        #region GL_NV_texture_multisample

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_texture_multisample</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glTexImage2DMultisampleCoverageNV(GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLboolean fixedSampleLocations);</para>
        /// </summary>
        public static void TexImage2DMultisampleCoverageNV(uint target, int coverageSamples, int colorSamples, int internalFormat, int width, int height, bool fixedSampleLocations) {
            GLNative.glTexImage2DMultisampleCoverageNV(target, coverageSamples, colorSamples, internalFormat, width, height, fixedSampleLocations);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_texture_multisample</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glTexImage3DMultisampleCoverageNV(GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedSampleLocations);</para>
        /// </summary>
        public static void TexImage3DMultisampleCoverageNV(uint target, int coverageSamples, int colorSamples, int internalFormat, int width, int height, int depth, bool fixedSampleLocations) {
            GLNative.glTexImage3DMultisampleCoverageNV(target, coverageSamples, colorSamples, internalFormat, width, height, depth, fixedSampleLocations);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_texture_multisample</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glTextureImage2DMultisampleNV(GLuint texture, GLenum target, GLsizei samples, GLint internalFormat, GLsizei width, GLsizei height, GLboolean fixedSampleLocations);</para>
        /// </summary>
        public static void TextureImage2DMultisampleNV(uint texture, uint target, int samples, int internalFormat, int width, int height, bool fixedSampleLocations) {
            GLNative.glTextureImage2DMultisampleNV(texture, target, samples, internalFormat, width, height, fixedSampleLocations);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_texture_multisample</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glTextureImage3DMultisampleNV(GLuint texture, GLenum target, GLsizei samples, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedSampleLocations);</para>
        /// </summary>
        public static void TextureImage3DMultisampleNV(uint texture, uint target, int samples, int internalFormat, int width, int height, int depth, bool fixedSampleLocations) {
            GLNative.glTextureImage3DMultisampleNV(texture, target, samples, internalFormat, width, height, depth, fixedSampleLocations);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_texture_multisample</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glTextureImage2DMultisampleCoverageNV(GLuint texture, GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLboolean fixedSampleLocations);</para>
        /// </summary>
        public static void TextureImage2DMultisampleCoverageNV(uint texture, uint target, int coverageSamples, int colorSamples, int internalFormat, int width, int height, bool fixedSampleLocations) {
            GLNative.glTextureImage2DMultisampleCoverageNV(texture, target, coverageSamples, colorSamples, internalFormat, width, height, fixedSampleLocations);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_texture_multisample</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glTextureImage3DMultisampleCoverageNV(GLuint texture, GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedSampleLocations);</para>
        /// </summary>
        public static void TextureImage3DMultisampleCoverageNV(uint texture, uint target, int coverageSamples, int colorSamples, int internalFormat, int width, int height, int depth, bool fixedSampleLocations) {
            GLNative.glTextureImage3DMultisampleCoverageNV(texture, target, coverageSamples, colorSamples, internalFormat, width, height, depth, fixedSampleLocations);
        }


        #endregion GL_NV_texture_multisample

        #region GL_NV_transform_feedback

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_transform_feedback</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glBeginTransformFeedbackNV(GLenum primitiveMode);</para>
        /// </summary>
        public static void BeginTransformFeedbackNV(uint primitiveMode) {
            GLNative.glBeginTransformFeedbackNV(primitiveMode);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_transform_feedback</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glEndTransformFeedbackNV();</para>
        /// </summary>
        public static void EndTransformFeedbackNV() {
            GLNative.glEndTransformFeedbackNV();
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_transform_feedback</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glBindBufferRangeNV(GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size);</para>
        /// </summary>
        public static void BindBufferRangeNV(uint target, uint index, uint buffer, IntPtr offset, IntPtr size) {
            GLNative.glBindBufferRangeNV(target, index, buffer, offset, size);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_transform_feedback</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glBindBufferOffsetNV(GLenum target, GLuint index, GLuint buffer, GLintptr offset);</para>
        /// </summary>
        public static void BindBufferOffsetNV(uint target, uint index, uint buffer, IntPtr offset) {
            GLNative.glBindBufferOffsetNV(target, index, buffer, offset);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_transform_feedback</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glBindBufferBaseNV(GLenum target, GLuint index, GLuint buffer);</para>
        /// </summary>
        public static void BindBufferBaseNV(uint target, uint index, uint buffer) {
            GLNative.glBindBufferBaseNV(target, index, buffer);
        }


        #endregion GL_NV_transform_feedback

        #region GL_NV_transform_feedback2

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_transform_feedback2</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glBindTransformFeedbackNV(GLenum target, GLuint id);</para>
        /// </summary>
        public static void BindTransformFeedbackNV(uint target, uint id) {
            GLNative.glBindTransformFeedbackNV(target, id);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_transform_feedback2</para>
        /// Supported: <para>gl</para>
        /// Original: <para>GLboolean glIsTransformFeedbackNV(GLuint id);</para>
        /// </summary>
        public static bool IsTransformFeedbackNV(uint id) {
            return GLNative.glIsTransformFeedbackNV(id);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_transform_feedback2</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glPauseTransformFeedbackNV();</para>
        /// </summary>
        public static void PauseTransformFeedbackNV() {
            GLNative.glPauseTransformFeedbackNV();
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_transform_feedback2</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glResumeTransformFeedbackNV();</para>
        /// </summary>
        public static void ResumeTransformFeedbackNV() {
            GLNative.glResumeTransformFeedbackNV();
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_transform_feedback2</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glDrawTransformFeedbackNV(GLenum mode, GLuint id);</para>
        /// </summary>
        public static void DrawTransformFeedbackNV(uint mode, uint id) {
            GLNative.glDrawTransformFeedbackNV(mode, id);
        }


        #endregion GL_NV_transform_feedback2

        #region GL_NV_vdpau_interop

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vdpau_interop</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVDPAUFiniNV();</para>
        /// </summary>
        public static void VDPAUFiniNV() {
            GLNative.glVDPAUFiniNV();
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vdpau_interop</para>
        /// Supported: <para>gl</para>
        /// Original: <para>GLboolean glVDPAUIsSurfaceNV(GLvdpauSurfaceNV surface);</para>
        /// </summary>
        public static bool VDPAUIsSurfaceNV(IntPtr surface) {
            return GLNative.glVDPAUIsSurfaceNV(surface);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vdpau_interop</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVDPAUUnregisterSurfaceNV(GLvdpauSurfaceNV surface);</para>
        /// </summary>
        public static void VDPAUUnregisterSurfaceNV(IntPtr surface) {
            GLNative.glVDPAUUnregisterSurfaceNV(surface);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vdpau_interop</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVDPAUSurfaceAccessNV(GLvdpauSurfaceNV surface, GLenum access);</para>
        /// </summary>
        public static void VDPAUSurfaceAccessNV(IntPtr surface, uint access) {
            GLNative.glVDPAUSurfaceAccessNV(surface, access);
        }


        #endregion GL_NV_vdpau_interop

        #region GL_NV_vdpau_interop2


        #endregion GL_NV_vdpau_interop2

        #region GL_NV_vertex_array_range

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_array_range</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glFlushVertexArrayRangeNV();</para>
        /// </summary>
        public static void FlushVertexArrayRangeNV() {
            GLNative.glFlushVertexArrayRangeNV();
        }


        #endregion GL_NV_vertex_array_range

        #region GL_NV_vertex_attrib_integer_64bit

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_attrib_integer_64bit</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glVertexAttribL1i64NV(GLuint index, GLint64EXT x);</para>
        /// </summary>
        public static void VertexAttribL1i64NV(uint index, Int64 x) {
            GLNative.glVertexAttribL1i64NV(index, x);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_attrib_integer_64bit</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glVertexAttribL2i64NV(GLuint index, GLint64EXT x, GLint64EXT y);</para>
        /// </summary>
        public static void VertexAttribL2i64NV(uint index, Int64 x, Int64 y) {
            GLNative.glVertexAttribL2i64NV(index, x, y);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_attrib_integer_64bit</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glVertexAttribL3i64NV(GLuint index, GLint64EXT x, GLint64EXT y, GLint64EXT z);</para>
        /// </summary>
        public static void VertexAttribL3i64NV(uint index, Int64 x, Int64 y, Int64 z) {
            GLNative.glVertexAttribL3i64NV(index, x, y, z);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_attrib_integer_64bit</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glVertexAttribL4i64NV(GLuint index, GLint64EXT x, GLint64EXT y, GLint64EXT z, GLint64EXT w);</para>
        /// </summary>
        public static void VertexAttribL4i64NV(uint index, Int64 x, Int64 y, Int64 z, Int64 w) {
            GLNative.glVertexAttribL4i64NV(index, x, y, z, w);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_attrib_integer_64bit</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glVertexAttribL1ui64NV(GLuint index, GLuint64EXT x);</para>
        /// </summary>
        public static void VertexAttribL1ui64NV(uint index, UInt64 x) {
            GLNative.glVertexAttribL1ui64NV(index, x);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_attrib_integer_64bit</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glVertexAttribL2ui64NV(GLuint index, GLuint64EXT x, GLuint64EXT y);</para>
        /// </summary>
        public static void VertexAttribL2ui64NV(uint index, UInt64 x, UInt64 y) {
            GLNative.glVertexAttribL2ui64NV(index, x, y);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_attrib_integer_64bit</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glVertexAttribL3ui64NV(GLuint index, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z);</para>
        /// </summary>
        public static void VertexAttribL3ui64NV(uint index, UInt64 x, UInt64 y, UInt64 z) {
            GLNative.glVertexAttribL3ui64NV(index, x, y, z);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_attrib_integer_64bit</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glVertexAttribL4ui64NV(GLuint index, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z, GLuint64EXT w);</para>
        /// </summary>
        public static void VertexAttribL4ui64NV(uint index, UInt64 x, UInt64 y, UInt64 z, UInt64 w) {
            GLNative.glVertexAttribL4ui64NV(index, x, y, z, w);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_attrib_integer_64bit</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glVertexAttribLFormatNV(GLuint index, GLint size, GLenum type, GLsizei stride);</para>
        /// </summary>
        public static void VertexAttribLFormatNV(uint index, int size, uint type, int stride) {
            GLNative.glVertexAttribLFormatNV(index, size, type, stride);
        }


        #endregion GL_NV_vertex_attrib_integer_64bit

        #region GL_NV_vertex_buffer_unified_memory

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_buffer_unified_memory</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glBufferAddressRangeNV(GLenum pname, GLuint index, GLuint64EXT address, GLsizeiptr length);</para>
        /// </summary>
        public static void BufferAddressRangeNV(uint pname, uint index, UInt64 address, IntPtr length) {
            GLNative.glBufferAddressRangeNV(pname, index, address, length);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_buffer_unified_memory</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glVertexFormatNV(GLint size, GLenum type, GLsizei stride);</para>
        /// </summary>
        public static void VertexFormatNV(int size, uint type, int stride) {
            GLNative.glVertexFormatNV(size, type, stride);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_buffer_unified_memory</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glNormalFormatNV(GLenum type, GLsizei stride);</para>
        /// </summary>
        public static void NormalFormatNV(uint type, int stride) {
            GLNative.glNormalFormatNV(type, stride);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_buffer_unified_memory</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glColorFormatNV(GLint size, GLenum type, GLsizei stride);</para>
        /// </summary>
        public static void ColorFormatNV(int size, uint type, int stride) {
            GLNative.glColorFormatNV(size, type, stride);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_buffer_unified_memory</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glIndexFormatNV(GLenum type, GLsizei stride);</para>
        /// </summary>
        public static void IndexFormatNV(uint type, int stride) {
            GLNative.glIndexFormatNV(type, stride);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_buffer_unified_memory</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glTexCoordFormatNV(GLint size, GLenum type, GLsizei stride);</para>
        /// </summary>
        public static void TexCoordFormatNV(int size, uint type, int stride) {
            GLNative.glTexCoordFormatNV(size, type, stride);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_buffer_unified_memory</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glEdgeFlagFormatNV(GLsizei stride);</para>
        /// </summary>
        public static void EdgeFlagFormatNV(int stride) {
            GLNative.glEdgeFlagFormatNV(stride);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_buffer_unified_memory</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glSecondaryColorFormatNV(GLint size, GLenum type, GLsizei stride);</para>
        /// </summary>
        public static void SecondaryColorFormatNV(int size, uint type, int stride) {
            GLNative.glSecondaryColorFormatNV(size, type, stride);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_buffer_unified_memory</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glFogCoordFormatNV(GLenum type, GLsizei stride);</para>
        /// </summary>
        public static void FogCoordFormatNV(uint type, int stride) {
            GLNative.glFogCoordFormatNV(type, stride);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_buffer_unified_memory</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glVertexAttribFormatNV(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride);</para>
        /// </summary>
        public static void VertexAttribFormatNV(uint index, int size, uint type, bool normalized, int stride) {
            GLNative.glVertexAttribFormatNV(index, size, type, normalized, stride);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_buffer_unified_memory</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glVertexAttribIFormatNV(GLuint index, GLint size, GLenum type, GLsizei stride);</para>
        /// </summary>
        public static void VertexAttribIFormatNV(uint index, int size, uint type, int stride) {
            GLNative.glVertexAttribIFormatNV(index, size, type, stride);
        }


        #endregion GL_NV_vertex_buffer_unified_memory

        #region GL_NV_vertex_program

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_program</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glBindProgramNV(GLenum target, GLuint id);</para>
        /// </summary>
        public static void BindProgramNV(uint target, uint id) {
            GLNative.glBindProgramNV(target, id);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_program</para>
        /// Supported: <para>gl</para>
        /// Original: <para>GLboolean glIsProgramNV(GLuint id);</para>
        /// </summary>
        public static bool IsProgramNV(uint id) {
            return GLNative.glIsProgramNV(id);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_program</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glProgramParameter4dNV(GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);</para>
        /// </summary>
        public static void ProgramParameter4dNV(uint target, uint index, double x, double y, double z, double w) {
            GLNative.glProgramParameter4dNV(target, index, x, y, z, w);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_program</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glProgramParameter4fNV(GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);</para>
        /// </summary>
        public static void ProgramParameter4fNV(uint target, uint index, float x, float y, float z, float w) {
            GLNative.glProgramParameter4fNV(target, index, x, y, z, w);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_program</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glTrackMatrixNV(GLenum target, GLuint address, GLenum matrix, GLenum transform);</para>
        /// </summary>
        public static void TrackMatrixNV(uint target, uint address, uint matrix, uint transform) {
            GLNative.glTrackMatrixNV(target, address, matrix, transform);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_program</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexAttrib1dNV(GLuint index, GLdouble x);</para>
        /// </summary>
        public static void VertexAttrib1dNV(uint index, double x) {
            GLNative.glVertexAttrib1dNV(index, x);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_program</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexAttrib1fNV(GLuint index, GLfloat x);</para>
        /// </summary>
        public static void VertexAttrib1fNV(uint index, float x) {
            GLNative.glVertexAttrib1fNV(index, x);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_program</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexAttrib1sNV(GLuint index, GLshort x);</para>
        /// </summary>
        public static void VertexAttrib1sNV(uint index, short x) {
            GLNative.glVertexAttrib1sNV(index, x);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_program</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexAttrib2dNV(GLuint index, GLdouble x, GLdouble y);</para>
        /// </summary>
        public static void VertexAttrib2dNV(uint index, double x, double y) {
            GLNative.glVertexAttrib2dNV(index, x, y);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_program</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexAttrib2fNV(GLuint index, GLfloat x, GLfloat y);</para>
        /// </summary>
        public static void VertexAttrib2fNV(uint index, float x, float y) {
            GLNative.glVertexAttrib2fNV(index, x, y);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_program</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexAttrib2sNV(GLuint index, GLshort x, GLshort y);</para>
        /// </summary>
        public static void VertexAttrib2sNV(uint index, short x, short y) {
            GLNative.glVertexAttrib2sNV(index, x, y);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_program</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexAttrib3dNV(GLuint index, GLdouble x, GLdouble y, GLdouble z);</para>
        /// </summary>
        public static void VertexAttrib3dNV(uint index, double x, double y, double z) {
            GLNative.glVertexAttrib3dNV(index, x, y, z);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_program</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexAttrib3fNV(GLuint index, GLfloat x, GLfloat y, GLfloat z);</para>
        /// </summary>
        public static void VertexAttrib3fNV(uint index, float x, float y, float z) {
            GLNative.glVertexAttrib3fNV(index, x, y, z);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_program</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexAttrib3sNV(GLuint index, GLshort x, GLshort y, GLshort z);</para>
        /// </summary>
        public static void VertexAttrib3sNV(uint index, short x, short y, short z) {
            GLNative.glVertexAttrib3sNV(index, x, y, z);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_program</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexAttrib4dNV(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);</para>
        /// </summary>
        public static void VertexAttrib4dNV(uint index, double x, double y, double z, double w) {
            GLNative.glVertexAttrib4dNV(index, x, y, z, w);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_program</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexAttrib4fNV(GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);</para>
        /// </summary>
        public static void VertexAttrib4fNV(uint index, float x, float y, float z, float w) {
            GLNative.glVertexAttrib4fNV(index, x, y, z, w);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_program</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexAttrib4sNV(GLuint index, GLshort x, GLshort y, GLshort z, GLshort w);</para>
        /// </summary>
        public static void VertexAttrib4sNV(uint index, short x, short y, short z, short w) {
            GLNative.glVertexAttrib4sNV(index, x, y, z, w);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_program</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexAttrib4ubNV(GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w);</para>
        /// </summary>
        public static void VertexAttrib4ubNV(uint index, byte x, byte y, byte z, byte w) {
            GLNative.glVertexAttrib4ubNV(index, x, y, z, w);
        }


        #endregion GL_NV_vertex_program

        #region GL_NV_vertex_program4

        // void glVertexAttribI1iEXT(GLuint index, GLint x);
        // void glVertexAttribI2iEXT(GLuint index, GLint x, GLint y);
        // void glVertexAttribI3iEXT(GLuint index, GLint x, GLint y, GLint z);
        // void glVertexAttribI4iEXT(GLuint index, GLint x, GLint y, GLint z, GLint w);
        // void glVertexAttribI1uiEXT(GLuint index, GLuint x);
        // void glVertexAttribI2uiEXT(GLuint index, GLuint x, GLuint y);
        // void glVertexAttribI3uiEXT(GLuint index, GLuint x, GLuint y, GLuint z);
        // void glVertexAttribI4uiEXT(GLuint index, GLuint x, GLuint y, GLuint z, GLuint w);

        #endregion GL_NV_vertex_program4

        #region GL_NV_video_capture

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_video_capture</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glBeginVideoCaptureNV(GLuint video_capture_slot);</para>
        /// </summary>
        public static void BeginVideoCaptureNV(uint video_capture_slot) {
            GLNative.glBeginVideoCaptureNV(video_capture_slot);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_video_capture</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glBindVideoCaptureStreamBufferNV(GLuint video_capture_slot, GLuint stream, GLenum frame_region, GLintptrARB offset);</para>
        /// </summary>
        public static void BindVideoCaptureStreamBufferNV(uint video_capture_slot, uint stream, uint frame_region, IntPtr offset) {
            GLNative.glBindVideoCaptureStreamBufferNV(video_capture_slot, stream, frame_region, offset);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_video_capture</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glBindVideoCaptureStreamTextureNV(GLuint video_capture_slot, GLuint stream, GLenum frame_region, GLenum target, GLuint texture);</para>
        /// </summary>
        public static void BindVideoCaptureStreamTextureNV(uint video_capture_slot, uint stream, uint frame_region, uint target, uint texture) {
            GLNative.glBindVideoCaptureStreamTextureNV(video_capture_slot, stream, frame_region, target, texture);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_video_capture</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glEndVideoCaptureNV(GLuint video_capture_slot);</para>
        /// </summary>
        public static void EndVideoCaptureNV(uint video_capture_slot) {
            GLNative.glEndVideoCaptureNV(video_capture_slot);
        }


        #endregion GL_NV_video_capture

        #region GL_NV_viewport_swizzle

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_viewport_swizzle</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glViewportSwizzleNV(GLuint index, GLenum swizzlex, GLenum swizzley, GLenum swizzlez, GLenum swizzlew);</para>
        /// </summary>
        public static void ViewportSwizzleNV(uint index, uint swizzlex, uint swizzley, uint swizzlez, uint swizzlew) {
            GLNative.glViewportSwizzleNV(index, swizzlex, swizzley, swizzlez, swizzlew);
        }


        #endregion GL_NV_viewport_swizzle

        #region GL_OES_fixed_point

        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glAlphaFuncxOES(GLenum func, GLfixed ref);</para>
        /// </summary>
        public static void AlphaFuncxOES(uint func, int r) {
            GLNative.glAlphaFuncxOES(func, r);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glClearColorxOES(GLfixed red, GLfixed green, GLfixed blue, GLfixed alpha);</para>
        /// </summary>
        public static void ClearColorxOES(int red, int green, int blue, int alpha) {
            GLNative.glClearColorxOES(red, green, blue, alpha);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glClearDepthxOES(GLfixed depth);</para>
        /// </summary>
        public static void ClearDepthxOES(int depth) {
            GLNative.glClearDepthxOES(depth);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glColor4xOES(GLfixed red, GLfixed green, GLfixed blue, GLfixed alpha);</para>
        /// </summary>
        public static void Color4xOES(int red, int green, int blue, int alpha) {
            GLNative.glColor4xOES(red, green, blue, alpha);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glDepthRangexOES(GLfixed n, GLfixed f);</para>
        /// </summary>
        public static void DepthRangexOES(int n, int f) {
            GLNative.glDepthRangexOES(n, f);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glFogxOES(GLenum pname, GLfixed param);</para>
        /// </summary>
        public static void FogxOES(uint pname, int param) {
            GLNative.glFogxOES(pname, param);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glFrustumxOES(GLfixed l, GLfixed r, GLfixed b, GLfixed t, GLfixed n, GLfixed f);</para>
        /// </summary>
        public static void FrustumxOES(int l, int r, int b, int t, int n, int f) {
            GLNative.glFrustumxOES(l, r, b, t, n, f);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glLightModelxOES(GLenum pname, GLfixed param);</para>
        /// </summary>
        public static void LightModelxOES(uint pname, int param) {
            GLNative.glLightModelxOES(pname, param);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glLightxOES(GLenum light, GLenum pname, GLfixed param);</para>
        /// </summary>
        public static void LightxOES(uint light, uint pname, int param) {
            GLNative.glLightxOES(light, pname, param);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glLineWidthxOES(GLfixed width);</para>
        /// </summary>
        public static void LineWidthxOES(int width) {
            GLNative.glLineWidthxOES(width);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glMaterialxOES(GLenum face, GLenum pname, GLfixed param);</para>
        /// </summary>
        public static void MaterialxOES(uint face, uint pname, int param) {
            GLNative.glMaterialxOES(face, pname, param);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glMultiTexCoord4xOES(GLenum texture, GLfixed s, GLfixed t, GLfixed r, GLfixed q);</para>
        /// </summary>
        public static void MultiTexCoord4xOES(uint texture, int s, int t, int r, int q) {
            GLNative.glMultiTexCoord4xOES(texture, s, t, r, q);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glNormal3xOES(GLfixed nx, GLfixed ny, GLfixed nz);</para>
        /// </summary>
        public static void Normal3xOES(int nx, int ny, int nz) {
            GLNative.glNormal3xOES(nx, ny, nz);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glOrthoxOES(GLfixed l, GLfixed r, GLfixed b, GLfixed t, GLfixed n, GLfixed f);</para>
        /// </summary>
        public static void OrthoxOES(int l, int r, int b, int t, int n, int f) {
            GLNative.glOrthoxOES(l, r, b, t, n, f);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glPointSizexOES(GLfixed size);</para>
        /// </summary>
        public static void PointSizexOES(int size) {
            GLNative.glPointSizexOES(size);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glPolygonOffsetxOES(GLfixed factor, GLfixed units);</para>
        /// </summary>
        public static void PolygonOffsetxOES(int factor, int units) {
            GLNative.glPolygonOffsetxOES(factor, units);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glRotatexOES(GLfixed angle, GLfixed x, GLfixed y, GLfixed z);</para>
        /// </summary>
        public static void RotatexOES(int angle, int x, int y, int z) {
            GLNative.glRotatexOES(angle, x, y, z);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glScalexOES(GLfixed x, GLfixed y, GLfixed z);</para>
        /// </summary>
        public static void ScalexOES(int x, int y, int z) {
            GLNative.glScalexOES(x, y, z);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glTexEnvxOES(GLenum target, GLenum pname, GLfixed param);</para>
        /// </summary>
        public static void TexEnvxOES(uint target, uint pname, int param) {
            GLNative.glTexEnvxOES(target, pname, param);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glTexParameterxOES(GLenum target, GLenum pname, GLfixed param);</para>
        /// </summary>
        public static void TexParameterxOES(uint target, uint pname, int param) {
            GLNative.glTexParameterxOES(target, pname, param);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glTranslatexOES(GLfixed x, GLfixed y, GLfixed z);</para>
        /// </summary>
        public static void TranslatexOES(int x, int y, int z) {
            GLNative.glTranslatexOES(x, y, z);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glPointParameterxOES(GLenum pname, GLfixed param);</para>
        /// </summary>
        public static void PointParameterxOES(uint pname, int param) {
            GLNative.glPointParameterxOES(pname, param);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glSampleCoveragexOES(GLclampx value, GLboolean invert);</para>
        /// </summary>
        public static void SampleCoveragexOES(Int32 value, bool invert) {
            GLNative.glSampleCoveragexOES(value, invert);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glAccumxOES(GLenum op, GLfixed value);</para>
        /// </summary>
        public static void AccumxOES(uint op, int value) {
            GLNative.glAccumxOES(op, value);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glBlendColorxOES(GLfixed red, GLfixed green, GLfixed blue, GLfixed alpha);</para>
        /// </summary>
        public static void BlendColorxOES(int red, int green, int blue, int alpha) {
            GLNative.glBlendColorxOES(red, green, blue, alpha);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glClearAccumxOES(GLfixed red, GLfixed green, GLfixed blue, GLfixed alpha);</para>
        /// </summary>
        public static void ClearAccumxOES(int red, int green, int blue, int alpha) {
            GLNative.glClearAccumxOES(red, green, blue, alpha);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glColor3xOES(GLfixed red, GLfixed green, GLfixed blue);</para>
        /// </summary>
        public static void Color3xOES(int red, int green, int blue) {
            GLNative.glColor3xOES(red, green, blue);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glConvolutionParameterxOES(GLenum target, GLenum pname, GLfixed param);</para>
        /// </summary>
        public static void ConvolutionParameterxOES(uint target, uint pname, int param) {
            GLNative.glConvolutionParameterxOES(target, pname, param);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glEvalCoord1xOES(GLfixed u);</para>
        /// </summary>
        public static void EvalCoord1xOES(int u) {
            GLNative.glEvalCoord1xOES(u);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glEvalCoord2xOES(GLfixed u, GLfixed v);</para>
        /// </summary>
        public static void EvalCoord2xOES(int u, int v) {
            GLNative.glEvalCoord2xOES(u, v);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glGetMaterialxOES(GLenum face, GLenum pname, GLfixed param);</para>
        /// </summary>
        public static void GetMaterialxOES(uint face, uint pname, int param) {
            GLNative.glGetMaterialxOES(face, pname, param);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glIndexxOES(GLfixed component);</para>
        /// </summary>
        public static void IndexxOES(int component) {
            GLNative.glIndexxOES(component);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glMap1xOES(GLenum target, GLfixed u1, GLfixed u2, GLint stride, GLint order, GLfixed points);</para>
        /// </summary>
        public static void Map1xOES(uint target, int u1, int u2, int stride, int order, int points) {
            GLNative.glMap1xOES(target, u1, u2, stride, order, points);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glMap2xOES(GLenum target, GLfixed u1, GLfixed u2, GLint ustride, GLint uorder, GLfixed v1, GLfixed v2, GLint vstride, GLint vorder, GLfixed points);</para>
        /// </summary>
        public static void Map2xOES(uint target, int u1, int u2, int ustride, int uorder, int v1, int v2, int vstride, int vorder, int points) {
            GLNative.glMap2xOES(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glMapGrid1xOES(GLint n, GLfixed u1, GLfixed u2);</para>
        /// </summary>
        public static void MapGrid1xOES(int n, int u1, int u2) {
            GLNative.glMapGrid1xOES(n, u1, u2);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glMapGrid2xOES(GLint n, GLfixed u1, GLfixed u2, GLfixed v1, GLfixed v2);</para>
        /// </summary>
        public static void MapGrid2xOES(int n, int u1, int u2, int v1, int v2) {
            GLNative.glMapGrid2xOES(n, u1, u2, v1, v2);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glMultiTexCoord1xOES(GLenum texture, GLfixed s);</para>
        /// </summary>
        public static void MultiTexCoord1xOES(uint texture, int s) {
            GLNative.glMultiTexCoord1xOES(texture, s);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glMultiTexCoord2xOES(GLenum texture, GLfixed s, GLfixed t);</para>
        /// </summary>
        public static void MultiTexCoord2xOES(uint texture, int s, int t) {
            GLNative.glMultiTexCoord2xOES(texture, s, t);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glMultiTexCoord3xOES(GLenum texture, GLfixed s, GLfixed t, GLfixed r);</para>
        /// </summary>
        public static void MultiTexCoord3xOES(uint texture, int s, int t, int r) {
            GLNative.glMultiTexCoord3xOES(texture, s, t, r);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glPassThroughxOES(GLfixed token);</para>
        /// </summary>
        public static void PassThroughxOES(int token) {
            GLNative.glPassThroughxOES(token);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glPixelStorex(GLenum pname, GLfixed param);</para>
        /// </summary>
        public static void PixelStorex(uint pname, int param) {
            GLNative.glPixelStorex(pname, param);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glPixelTransferxOES(GLenum pname, GLfixed param);</para>
        /// </summary>
        public static void PixelTransferxOES(uint pname, int param) {
            GLNative.glPixelTransferxOES(pname, param);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glPixelZoomxOES(GLfixed xfactor, GLfixed yfactor);</para>
        /// </summary>
        public static void PixelZoomxOES(int xfactor, int yfactor) {
            GLNative.glPixelZoomxOES(xfactor, yfactor);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glRasterPos2xOES(GLfixed x, GLfixed y);</para>
        /// </summary>
        public static void RasterPos2xOES(int x, int y) {
            GLNative.glRasterPos2xOES(x, y);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glRasterPos3xOES(GLfixed x, GLfixed y, GLfixed z);</para>
        /// </summary>
        public static void RasterPos3xOES(int x, int y, int z) {
            GLNative.glRasterPos3xOES(x, y, z);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glRasterPos4xOES(GLfixed x, GLfixed y, GLfixed z, GLfixed w);</para>
        /// </summary>
        public static void RasterPos4xOES(int x, int y, int z, int w) {
            GLNative.glRasterPos4xOES(x, y, z, w);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glRectxOES(GLfixed x1, GLfixed y1, GLfixed x2, GLfixed y2);</para>
        /// </summary>
        public static void RectxOES(int x1, int y1, int x2, int y2) {
            GLNative.glRectxOES(x1, y1, x2, y2);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glTexCoord1xOES(GLfixed s);</para>
        /// </summary>
        public static void TexCoord1xOES(int s) {
            GLNative.glTexCoord1xOES(s);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glTexCoord2xOES(GLfixed s, GLfixed t);</para>
        /// </summary>
        public static void TexCoord2xOES(int s, int t) {
            GLNative.glTexCoord2xOES(s, t);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glTexCoord3xOES(GLfixed s, GLfixed t, GLfixed r);</para>
        /// </summary>
        public static void TexCoord3xOES(int s, int t, int r) {
            GLNative.glTexCoord3xOES(s, t, r);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glTexCoord4xOES(GLfixed s, GLfixed t, GLfixed r, GLfixed q);</para>
        /// </summary>
        public static void TexCoord4xOES(int s, int t, int r, int q) {
            GLNative.glTexCoord4xOES(s, t, r, q);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point, GL_OES_texture_cube_map</para>
        /// Supported: <para>gl, gles1, gles1</para>
        /// Original: <para>void glTexGenxOES(GLenum coord, GLenum pname, GLfixed param);</para>
        /// </summary>
        public static void TexGenxOES(uint coord, uint pname, int param) {
            GLNative.glTexGenxOES(coord, pname, param);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glVertex2xOES(GLfixed x);</para>
        /// </summary>
        public static void Vertex2xOES(int x) {
            GLNative.glVertex2xOES(x);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glVertex3xOES(GLfixed x, GLfixed y);</para>
        /// </summary>
        public static void Vertex3xOES(int x, int y) {
            GLNative.glVertex3xOES(x, y);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glVertex4xOES(GLfixed x, GLfixed y, GLfixed z);</para>
        /// </summary>
        public static void Vertex4xOES(int x, int y, int z) {
            GLNative.glVertex4xOES(x, y, z);
        }


        #endregion GL_OES_fixed_point

        #region GL_OES_query_matrix


        #endregion GL_OES_query_matrix

        #region GL_OES_single_precision

        /// <summary>
        /// <para>Require:</para> <para>GL_OES_single_precision</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glClearDepthfOES(GLclampf depth);</para>
        /// </summary>
        public static void ClearDepthfOES(float depth) {
            GLNative.glClearDepthfOES(depth);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_OES_single_precision</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glDepthRangefOES(GLclampf n, GLclampf f);</para>
        /// </summary>
        public static void DepthRangefOES(float n, float f) {
            GLNative.glDepthRangefOES(n, f);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_OES_single_precision</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glFrustumfOES(GLfloat l, GLfloat r, GLfloat b, GLfloat t, GLfloat n, GLfloat f);</para>
        /// </summary>
        public static void FrustumfOES(float l, float r, float b, float t, float n, float f) {
            GLNative.glFrustumfOES(l, r, b, t, n, f);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_OES_single_precision</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glOrthofOES(GLfloat l, GLfloat r, GLfloat b, GLfloat t, GLfloat n, GLfloat f);</para>
        /// </summary>
        public static void OrthofOES(float l, float r, float b, float t, float n, float f) {
            GLNative.glOrthofOES(l, r, b, t, n, f);
        }


        #endregion GL_OES_single_precision

        #region GL_OVR_multiview

        /// <summary>
        /// <para>Require:</para> <para>GL_OVR_multiview</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glFramebufferTextureMultiviewOVR(GLenum target, GLenum attachment, GLuint texture, GLint level, GLint baseViewIndex, GLsizei numViews);</para>
        /// </summary>
        public static void FramebufferTextureMultiviewOVR(uint target, uint attachment, uint texture, int level, int baseViewIndex, int numViews) {
            GLNative.glFramebufferTextureMultiviewOVR(target, attachment, texture, level, baseViewIndex, numViews);
        }


        #endregion GL_OVR_multiview

        #region GL_PGI_misc_hints

        /// <summary>
        /// <para>Require:</para> <para>GL_PGI_misc_hints</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glHintPGI(GLenum target, GLint mode);</para>
        /// </summary>
        public static void HintPGI(uint target, int mode) {
            GLNative.glHintPGI(target, mode);
        }


        #endregion GL_PGI_misc_hints

        #region GL_SGIS_detail_texture


        #endregion GL_SGIS_detail_texture

        #region GL_SGIS_fog_function


        #endregion GL_SGIS_fog_function

        #region GL_SGIS_multisample

        /// <summary>
        /// <para>Require:</para> <para>GL_SGIS_multisample</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glSampleMaskSGIS(GLclampf value, GLboolean invert);</para>
        /// </summary>
        public static void SampleMaskSGIS(float value, bool invert) {
            GLNative.glSampleMaskSGIS(value, invert);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_SGIS_multisample</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glSamplePatternSGIS(GLenum pattern);</para>
        /// </summary>
        public static void SamplePatternSGIS(uint pattern) {
            GLNative.glSamplePatternSGIS(pattern);
        }


        #endregion GL_SGIS_multisample

        #region GL_SGIS_pixel_texture

        /// <summary>
        /// <para>Require:</para> <para>GL_SGIS_pixel_texture</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glPixelTexGenParameteriSGIS(GLenum pname, GLint param);</para>
        /// </summary>
        public static void PixelTexGenParameteriSGIS(uint pname, int param) {
            GLNative.glPixelTexGenParameteriSGIS(pname, param);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_SGIS_pixel_texture</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glPixelTexGenParameterfSGIS(GLenum pname, GLfloat param);</para>
        /// </summary>
        public static void PixelTexGenParameterfSGIS(uint pname, float param) {
            GLNative.glPixelTexGenParameterfSGIS(pname, param);
        }


        #endregion GL_SGIS_pixel_texture

        #region GL_SGIS_point_parameters

        /// <summary>
        /// <para>Require:</para> <para>GL_SGIS_point_parameters</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glPointParameterfSGIS(GLenum pname, GLfloat param);</para>
        /// </summary>
        public static void PointParameterfSGIS(uint pname, float param) {
            GLNative.glPointParameterfSGIS(pname, param);
        }


        #endregion GL_SGIS_point_parameters

        #region GL_SGIS_sharpen_texture


        #endregion GL_SGIS_sharpen_texture

        #region GL_SGIS_texture4D


        #endregion GL_SGIS_texture4D

        #region GL_SGIS_texture_color_mask

        /// <summary>
        /// <para>Require:</para> <para>GL_SGIS_texture_color_mask</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glTextureColorMaskSGIS(GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha);</para>
        /// </summary>
        public static void TextureColorMaskSGIS(bool red, bool green, bool blue, bool alpha) {
            GLNative.glTextureColorMaskSGIS(red, green, blue, alpha);
        }


        #endregion GL_SGIS_texture_color_mask

        #region GL_SGIS_texture_filter4


        #endregion GL_SGIS_texture_filter4

        #region GL_SGIX_async

        /// <summary>
        /// <para>Require:</para> <para>GL_SGIX_async</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glAsyncMarkerSGIX(GLuint marker);</para>
        /// </summary>
        public static void AsyncMarkerSGIX(uint marker) {
            GLNative.glAsyncMarkerSGIX(marker);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_SGIX_async</para>
        /// Supported: <para>gl</para>
        /// Original: <para>GLuint glGenAsyncMarkersSGIX(GLsizei range);</para>
        /// </summary>
        public static uint GenAsyncMarkersSGIX(int range) {
            return GLNative.glGenAsyncMarkersSGIX(range);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_SGIX_async</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glDeleteAsyncMarkersSGIX(GLuint marker, GLsizei range);</para>
        /// </summary>
        public static void DeleteAsyncMarkersSGIX(uint marker, int range) {
            GLNative.glDeleteAsyncMarkersSGIX(marker, range);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_SGIX_async</para>
        /// Supported: <para>gl</para>
        /// Original: <para>GLboolean glIsAsyncMarkerSGIX(GLuint marker);</para>
        /// </summary>
        public static bool IsAsyncMarkerSGIX(uint marker) {
            return GLNative.glIsAsyncMarkerSGIX(marker);
        }


        #endregion GL_SGIX_async

        #region GL_SGIX_flush_raster

        /// <summary>
        /// <para>Require:</para> <para>GL_SGIX_flush_raster</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glFlushRasterSGIX();</para>
        /// </summary>
        public static void FlushRasterSGIX() {
            GLNative.glFlushRasterSGIX();
        }


        #endregion GL_SGIX_flush_raster

        #region GL_SGIX_fragment_lighting

        /// <summary>
        /// <para>Require:</para> <para>GL_SGIX_fragment_lighting</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glFragmentColorMaterialSGIX(GLenum face, GLenum mode);</para>
        /// </summary>
        public static void FragmentColorMaterialSGIX(uint face, uint mode) {
            GLNative.glFragmentColorMaterialSGIX(face, mode);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_SGIX_fragment_lighting</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glFragmentLightfSGIX(GLenum light, GLenum pname, GLfloat param);</para>
        /// </summary>
        public static void FragmentLightfSGIX(uint light, uint pname, float param) {
            GLNative.glFragmentLightfSGIX(light, pname, param);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_SGIX_fragment_lighting</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glFragmentLightiSGIX(GLenum light, GLenum pname, GLint param);</para>
        /// </summary>
        public static void FragmentLightiSGIX(uint light, uint pname, int param) {
            GLNative.glFragmentLightiSGIX(light, pname, param);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_SGIX_fragment_lighting</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glFragmentLightModelfSGIX(GLenum pname, GLfloat param);</para>
        /// </summary>
        public static void FragmentLightModelfSGIX(uint pname, float param) {
            GLNative.glFragmentLightModelfSGIX(pname, param);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_SGIX_fragment_lighting</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glFragmentLightModeliSGIX(GLenum pname, GLint param);</para>
        /// </summary>
        public static void FragmentLightModeliSGIX(uint pname, int param) {
            GLNative.glFragmentLightModeliSGIX(pname, param);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_SGIX_fragment_lighting</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glFragmentMaterialfSGIX(GLenum face, GLenum pname, GLfloat param);</para>
        /// </summary>
        public static void FragmentMaterialfSGIX(uint face, uint pname, float param) {
            GLNative.glFragmentMaterialfSGIX(face, pname, param);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_SGIX_fragment_lighting</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glFragmentMaterialiSGIX(GLenum face, GLenum pname, GLint param);</para>
        /// </summary>
        public static void FragmentMaterialiSGIX(uint face, uint pname, int param) {
            GLNative.glFragmentMaterialiSGIX(face, pname, param);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_SGIX_fragment_lighting</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glLightEnviSGIX(GLenum pname, GLint param);</para>
        /// </summary>
        public static void LightEnviSGIX(uint pname, int param) {
            GLNative.glLightEnviSGIX(pname, param);
        }


        #endregion GL_SGIX_fragment_lighting

        #region GL_SGIX_framezoom

        /// <summary>
        /// <para>Require:</para> <para>GL_SGIX_framezoom</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glFrameZoomSGIX(GLint factor);</para>
        /// </summary>
        public static void FrameZoomSGIX(int factor) {
            GLNative.glFrameZoomSGIX(factor);
        }


        #endregion GL_SGIX_framezoom

        #region GL_SGIX_igloo_interface


        #endregion GL_SGIX_igloo_interface

        #region GL_SGIX_instruments

        /// <summary>
        /// <para>Require:</para> <para>GL_SGIX_instruments</para>
        /// Supported: <para>gl</para>
        /// Original: <para>GLint glGetInstrumentsSGIX();</para>
        /// </summary>
        public static int GetInstrumentsSGIX() {
            return GLNative.glGetInstrumentsSGIX();
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_SGIX_instruments</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glReadInstrumentsSGIX(GLint marker);</para>
        /// </summary>
        public static void ReadInstrumentsSGIX(int marker) {
            GLNative.glReadInstrumentsSGIX(marker);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_SGIX_instruments</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glStartInstrumentsSGIX();</para>
        /// </summary>
        public static void StartInstrumentsSGIX() {
            GLNative.glStartInstrumentsSGIX();
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_SGIX_instruments</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glStopInstrumentsSGIX(GLint marker);</para>
        /// </summary>
        public static void StopInstrumentsSGIX(int marker) {
            GLNative.glStopInstrumentsSGIX(marker);
        }


        #endregion GL_SGIX_instruments

        #region GL_SGIX_list_priority

        /// <summary>
        /// <para>Require:</para> <para>GL_SGIX_list_priority</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glListParameterfSGIX(GLuint list, GLenum pname, GLfloat param);</para>
        /// </summary>
        public static void ListParameterfSGIX(uint list, uint pname, float param) {
            GLNative.glListParameterfSGIX(list, pname, param);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_SGIX_list_priority</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glListParameteriSGIX(GLuint list, GLenum pname, GLint param);</para>
        /// </summary>
        public static void ListParameteriSGIX(uint list, uint pname, int param) {
            GLNative.glListParameteriSGIX(list, pname, param);
        }


        #endregion GL_SGIX_list_priority

        #region GL_SGIX_pixel_texture

        /// <summary>
        /// <para>Require:</para> <para>GL_SGIX_pixel_texture</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glPixelTexGenSGIX(GLenum mode);</para>
        /// </summary>
        public static void PixelTexGenSGIX(uint mode) {
            GLNative.glPixelTexGenSGIX(mode);
        }


        #endregion GL_SGIX_pixel_texture

        #region GL_SGIX_polynomial_ffd

        /// <summary>
        /// <para>Require:</para> <para>GL_SGIX_polynomial_ffd</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glDeformSGIX(GLbitfield mask);</para>
        /// </summary>
        public static void DeformSGIX(uint mask) {
            GLNative.glDeformSGIX(mask);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_SGIX_polynomial_ffd</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glLoadIdentityDeformationMapSGIX(GLbitfield mask);</para>
        /// </summary>
        public static void LoadIdentityDeformationMapSGIX(uint mask) {
            GLNative.glLoadIdentityDeformationMapSGIX(mask);
        }


        #endregion GL_SGIX_polynomial_ffd

        #region GL_SGIX_reference_plane


        #endregion GL_SGIX_reference_plane

        #region GL_SGIX_sprite

        /// <summary>
        /// <para>Require:</para> <para>GL_SGIX_sprite</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glSpriteParameterfSGIX(GLenum pname, GLfloat param);</para>
        /// </summary>
        public static void SpriteParameterfSGIX(uint pname, float param) {
            GLNative.glSpriteParameterfSGIX(pname, param);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_SGIX_sprite</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glSpriteParameteriSGIX(GLenum pname, GLint param);</para>
        /// </summary>
        public static void SpriteParameteriSGIX(uint pname, int param) {
            GLNative.glSpriteParameteriSGIX(pname, param);
        }


        #endregion GL_SGIX_sprite

        #region GL_SGIX_tag_sample_buffer

        /// <summary>
        /// <para>Require:</para> <para>GL_SGIX_tag_sample_buffer</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glTagSampleBufferSGIX();</para>
        /// </summary>
        public static void TagSampleBufferSGIX() {
            GLNative.glTagSampleBufferSGIX();
        }


        #endregion GL_SGIX_tag_sample_buffer

        #region GL_SGI_color_table

        /// <summary>
        /// <para>Require:</para> <para>GL_SGI_color_table</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glCopyColorTableSGI(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width);</para>
        /// </summary>
        public static void CopyColorTableSGI(uint target, uint internalformat, int x, int y, int width) {
            GLNative.glCopyColorTableSGI(target, internalformat, x, y, width);
        }


        #endregion GL_SGI_color_table

        #region GL_SUNX_constant_data

        /// <summary>
        /// <para>Require:</para> <para>GL_SUNX_constant_data</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glFinishTextureSUNX();</para>
        /// </summary>
        public static void FinishTextureSUNX() {
            GLNative.glFinishTextureSUNX();
        }


        #endregion GL_SUNX_constant_data

        #region GL_SUN_global_alpha

        /// <summary>
        /// <para>Require:</para> <para>GL_SUN_global_alpha</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGlobalAlphaFactorbSUN(GLbyte factor);</para>
        /// </summary>
        public static void GlobalAlphaFactorbSUN(byte factor) {
            GLNative.glGlobalAlphaFactorbSUN(factor);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_SUN_global_alpha</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGlobalAlphaFactorsSUN(GLshort factor);</para>
        /// </summary>
        public static void GlobalAlphaFactorsSUN(short factor) {
            GLNative.glGlobalAlphaFactorsSUN(factor);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_SUN_global_alpha</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGlobalAlphaFactoriSUN(GLint factor);</para>
        /// </summary>
        public static void GlobalAlphaFactoriSUN(int factor) {
            GLNative.glGlobalAlphaFactoriSUN(factor);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_SUN_global_alpha</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGlobalAlphaFactorfSUN(GLfloat factor);</para>
        /// </summary>
        public static void GlobalAlphaFactorfSUN(float factor) {
            GLNative.glGlobalAlphaFactorfSUN(factor);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_SUN_global_alpha</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGlobalAlphaFactordSUN(GLdouble factor);</para>
        /// </summary>
        public static void GlobalAlphaFactordSUN(double factor) {
            GLNative.glGlobalAlphaFactordSUN(factor);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_SUN_global_alpha</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGlobalAlphaFactorubSUN(GLubyte factor);</para>
        /// </summary>
        public static void GlobalAlphaFactorubSUN(byte factor) {
            GLNative.glGlobalAlphaFactorubSUN(factor);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_SUN_global_alpha</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGlobalAlphaFactorusSUN(GLushort factor);</para>
        /// </summary>
        public static void GlobalAlphaFactorusSUN(ushort factor) {
            GLNative.glGlobalAlphaFactorusSUN(factor);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_SUN_global_alpha</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGlobalAlphaFactoruiSUN(GLuint factor);</para>
        /// </summary>
        public static void GlobalAlphaFactoruiSUN(uint factor) {
            GLNative.glGlobalAlphaFactoruiSUN(factor);
        }


        #endregion GL_SUN_global_alpha

        #region GL_SUN_mesh_array

        /// <summary>
        /// <para>Require:</para> <para>GL_SUN_mesh_array</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glDrawMeshArraysSUN(GLenum mode, GLint first, GLsizei count, GLsizei width);</para>
        /// </summary>
        public static void DrawMeshArraysSUN(uint mode, int first, int count, int width) {
            GLNative.glDrawMeshArraysSUN(mode, first, count, width);
        }


        #endregion GL_SUN_mesh_array

        #region GL_SUN_triangle_list

        /// <summary>
        /// <para>Require:</para> <para>GL_SUN_triangle_list</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glReplacementCodeuiSUN(GLuint code);</para>
        /// </summary>
        public static void ReplacementCodeuiSUN(uint code) {
            GLNative.glReplacementCodeuiSUN(code);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_SUN_triangle_list</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glReplacementCodeusSUN(GLushort code);</para>
        /// </summary>
        public static void ReplacementCodeusSUN(ushort code) {
            GLNative.glReplacementCodeusSUN(code);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_SUN_triangle_list</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glReplacementCodeubSUN(GLubyte code);</para>
        /// </summary>
        public static void ReplacementCodeubSUN(byte code) {
            GLNative.glReplacementCodeubSUN(code);
        }


        #endregion GL_SUN_triangle_list

        #region GL_SUN_vertex

        /// <summary>
        /// <para>Require:</para> <para>GL_SUN_vertex</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glColor4ubVertex2fSUN(GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y);</para>
        /// </summary>
        public static void Color4ubVertex2fSUN(byte r, byte g, byte b, byte a, float x, float y) {
            GLNative.glColor4ubVertex2fSUN(r, g, b, a, x, y);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_SUN_vertex</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glColor4ubVertex3fSUN(GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y, GLfloat z);</para>
        /// </summary>
        public static void Color4ubVertex3fSUN(byte r, byte g, byte b, byte a, float x, float y, float z) {
            GLNative.glColor4ubVertex3fSUN(r, g, b, a, x, y, z);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_SUN_vertex</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glColor3fVertex3fSUN(GLfloat r, GLfloat g, GLfloat b, GLfloat x, GLfloat y, GLfloat z);</para>
        /// </summary>
        public static void Color3fVertex3fSUN(float r, float g, float b, float x, float y, float z) {
            GLNative.glColor3fVertex3fSUN(r, g, b, x, y, z);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_SUN_vertex</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glNormal3fVertex3fSUN(GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z);</para>
        /// </summary>
        public static void Normal3fVertex3fSUN(float nx, float ny, float nz, float x, float y, float z) {
            GLNative.glNormal3fVertex3fSUN(nx, ny, nz, x, y, z);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_SUN_vertex</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glColor4fNormal3fVertex3fSUN(GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z);</para>
        /// </summary>
        public static void Color4fNormal3fVertex3fSUN(float r, float g, float b, float a, float nx, float ny, float nz, float x, float y, float z) {
            GLNative.glColor4fNormal3fVertex3fSUN(r, g, b, a, nx, ny, nz, x, y, z);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_SUN_vertex</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glTexCoord2fVertex3fSUN(GLfloat s, GLfloat t, GLfloat x, GLfloat y, GLfloat z);</para>
        /// </summary>
        public static void TexCoord2fVertex3fSUN(float s, float t, float x, float y, float z) {
            GLNative.glTexCoord2fVertex3fSUN(s, t, x, y, z);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_SUN_vertex</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glTexCoord4fVertex4fSUN(GLfloat s, GLfloat t, GLfloat p, GLfloat q, GLfloat x, GLfloat y, GLfloat z, GLfloat w);</para>
        /// </summary>
        public static void TexCoord4fVertex4fSUN(float s, float t, float p, float q, float x, float y, float z, float w) {
            GLNative.glTexCoord4fVertex4fSUN(s, t, p, q, x, y, z, w);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_SUN_vertex</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glTexCoord2fColor4ubVertex3fSUN(GLfloat s, GLfloat t, GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y, GLfloat z);</para>
        /// </summary>
        public static void TexCoord2fColor4ubVertex3fSUN(float s, float t, byte r, byte g, byte b, byte a, float x, float y, float z) {
            GLNative.glTexCoord2fColor4ubVertex3fSUN(s, t, r, g, b, a, x, y, z);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_SUN_vertex</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glTexCoord2fColor3fVertex3fSUN(GLfloat s, GLfloat t, GLfloat r, GLfloat g, GLfloat b, GLfloat x, GLfloat y, GLfloat z);</para>
        /// </summary>
        public static void TexCoord2fColor3fVertex3fSUN(float s, float t, float r, float g, float b, float x, float y, float z) {
            GLNative.glTexCoord2fColor3fVertex3fSUN(s, t, r, g, b, x, y, z);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_SUN_vertex</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glTexCoord2fNormal3fVertex3fSUN(GLfloat s, GLfloat t, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z);</para>
        /// </summary>
        public static void TexCoord2fNormal3fVertex3fSUN(float s, float t, float nx, float ny, float nz, float x, float y, float z) {
            GLNative.glTexCoord2fNormal3fVertex3fSUN(s, t, nx, ny, nz, x, y, z);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_SUN_vertex</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glTexCoord2fColor4fNormal3fVertex3fSUN(GLfloat s, GLfloat t, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z);</para>
        /// </summary>
        public static void TexCoord2fColor4fNormal3fVertex3fSUN(float s, float t, float r, float g, float b, float a, float nx, float ny, float nz, float x, float y, float z) {
            GLNative.glTexCoord2fColor4fNormal3fVertex3fSUN(s, t, r, g, b, a, nx, ny, nz, x, y, z);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_SUN_vertex</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glTexCoord4fColor4fNormal3fVertex4fSUN(GLfloat s, GLfloat t, GLfloat p, GLfloat q, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z, GLfloat w);</para>
        /// </summary>
        public static void TexCoord4fColor4fNormal3fVertex4fSUN(float s, float t, float p, float q, float r, float g, float b, float a, float nx, float ny, float nz, float x, float y, float z, float w) {
            GLNative.glTexCoord4fColor4fNormal3fVertex4fSUN(s, t, p, q, r, g, b, a, nx, ny, nz, x, y, z, w);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_SUN_vertex</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glReplacementCodeuiVertex3fSUN(GLuint rc, GLfloat x, GLfloat y, GLfloat z);</para>
        /// </summary>
        public static void ReplacementCodeuiVertex3fSUN(uint rc, float x, float y, float z) {
            GLNative.glReplacementCodeuiVertex3fSUN(rc, x, y, z);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_SUN_vertex</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glReplacementCodeuiColor4ubVertex3fSUN(GLuint rc, GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y, GLfloat z);</para>
        /// </summary>
        public static void ReplacementCodeuiColor4ubVertex3fSUN(uint rc, byte r, byte g, byte b, byte a, float x, float y, float z) {
            GLNative.glReplacementCodeuiColor4ubVertex3fSUN(rc, r, g, b, a, x, y, z);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_SUN_vertex</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glReplacementCodeuiColor3fVertex3fSUN(GLuint rc, GLfloat r, GLfloat g, GLfloat b, GLfloat x, GLfloat y, GLfloat z);</para>
        /// </summary>
        public static void ReplacementCodeuiColor3fVertex3fSUN(uint rc, float r, float g, float b, float x, float y, float z) {
            GLNative.glReplacementCodeuiColor3fVertex3fSUN(rc, r, g, b, x, y, z);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_SUN_vertex</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glReplacementCodeuiNormal3fVertex3fSUN(GLuint rc, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z);</para>
        /// </summary>
        public static void ReplacementCodeuiNormal3fVertex3fSUN(uint rc, float nx, float ny, float nz, float x, float y, float z) {
            GLNative.glReplacementCodeuiNormal3fVertex3fSUN(rc, nx, ny, nz, x, y, z);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_SUN_vertex</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glReplacementCodeuiColor4fNormal3fVertex3fSUN(GLuint rc, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z);</para>
        /// </summary>
        public static void ReplacementCodeuiColor4fNormal3fVertex3fSUN(uint rc, float r, float g, float b, float a, float nx, float ny, float nz, float x, float y, float z) {
            GLNative.glReplacementCodeuiColor4fNormal3fVertex3fSUN(rc, r, g, b, a, nx, ny, nz, x, y, z);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_SUN_vertex</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glReplacementCodeuiTexCoord2fVertex3fSUN(GLuint rc, GLfloat s, GLfloat t, GLfloat x, GLfloat y, GLfloat z);</para>
        /// </summary>
        public static void ReplacementCodeuiTexCoord2fVertex3fSUN(uint rc, float s, float t, float x, float y, float z) {
            GLNative.glReplacementCodeuiTexCoord2fVertex3fSUN(rc, s, t, x, y, z);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_SUN_vertex</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN(GLuint rc, GLfloat s, GLfloat t, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z);</para>
        /// </summary>
        public static void ReplacementCodeuiTexCoord2fNormal3fVertex3fSUN(uint rc, float s, float t, float nx, float ny, float nz, float x, float y, float z) {
            GLNative.glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN(rc, s, t, nx, ny, nz, x, y, z);
        }

        /// <summary>
        /// <para>Require:</para> <para>GL_SUN_vertex</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN(GLuint rc, GLfloat s, GLfloat t, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z);</para>
        /// </summary>
        public static void ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN(uint rc, float s, float t, float r, float g, float b, float a, float nx, float ny, float nz, float x, float y, float z) {
            GLNative.glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN(rc, s, t, r, g, b, a, nx, ny, nz, x, y, z);
        }


        #endregion GL_SUN_vertex
        
    }
}
