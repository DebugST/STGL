using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Runtime.InteropServices;

namespace STLib.OpenGL.GL
{
    partial class GLNative  // GLNative.Method.cs
    {
        /**********************************************************************************
         * Note: These codes are automatically created from OpenGL's documentation.
         *       If there is something wrong, it must be because the author is too stupid.
         * Link: https://github.com/KhronosGroup/OpenGL-Registry/xml/gl.xml
         *       https://github.com/KhronosGroup/OpenGL-Refpages/tree/main/gl2.1
         *       https://github.com/KhronosGroup/OpenGL-Refpages/tree/main/gl4
         **********************************************************************************/

        private static ProcAddressGetter m_getter = null;
        private static Dictionary<string, Delegate> m_dic_proc = new Dictionary<string, Delegate>();

        private static T _GetProc<T>(string strName) {
            if (!m_dic_proc.ContainsKey(strName)) {
                if (m_getter == null) {
                    throw new InvalidOperationException(
                        "GL is not initialized, please call [GL.Init()] or [GL.InitAll()] to initialize it first."
                    );
                }
                IntPtr ptr = m_getter(strName);
                if (ptr != IntPtr.Zero) {
                    var func = Marshal.GetDelegateForFunctionPointer(ptr, typeof(T));
                    m_dic_proc.Add(strName, func);
                    GLNative.InitedFunctions++;
                }
                // _GetProc will not write null to m_dic_proc when it cannot get Proc, but GL.InitAll will.
            }
            if (m_dic_proc.ContainsKey(strName)) {
                object obj = m_dic_proc[strName];
                if (obj != null) {
                    return (T)obj;
                }
            }
            throw new PlatformNotSupportedException(
                "The [" + strName + "] function cannot be initialized. " +
                "Or maybe the current OpenGL version [" + GLNative.Info.Version + "]  does not support this function, " +
                "Of course it is also possible that the stupid author wrote the bug."
            );
        }


        #region GL_VERSION_1_0

        /// <summary>
        /// specify whether front- or back-facing facets can be culled
        /// <para>Require:</para> <para>GL_VERSION_1_0, GL_VERSION_ES_CM_1_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// If <paramref name="mode"/> is <code>GL_FRONT_AND_BACK</code>, no facets are drawn, but other
        /// primitives such as points and lines are drawn.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="mode"/> is not an accepted value.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glCullFace"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glCullFace(GLenum mode);</para>
        /// </summary>
        /// <param name="mode">
        /// <para>
        /// Specifies whether front- or back-facing facets are candidates for culling.
        /// Symbolic constants
        /// <code>GL_FRONT</code>, <code>GL_BACK</code>, and <code>GL_FRONT_AND_BACK</code> are accepted.
        /// The initial value is <code>GL_BACK</code>.
        /// </para>
        /// </param>
        /// <seealso cref="glEnable"/>
        /// <seealso cref="glFrontFace"/>
        public static void glCullFace(uint mode) {
            var _F = _GetProc<GLNativeDelegate.FNglCullFace>("glCullFace");
            _F(mode);
        }
        /// <summary>
        /// define front- and back-facing polygons
        /// <para>Require:</para> <para>GL_VERSION_1_0, GL_VERSION_ES_CM_1_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="mode"/> is not an accepted value.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glFrontFace"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glFrontFace(GLenum mode);</para>
        /// </summary>
        /// <param name="mode">
        /// <para>
        /// Specifies the orientation of front-facing polygons.
        /// <code>GL_CW</code> and <code>GL_CCW</code> are accepted.
        /// The initial value is <code>GL_CCW</code>.
        /// </para>
        /// </param>
        /// <seealso cref="glCullFace"/>
        /// <seealso cref="glLightModel"/>
        public static void glFrontFace(uint mode) {
            var _F = _GetProc<GLNativeDelegate.FNglFrontFace>("glFrontFace");
            _F(mode);
        }
        /// <summary>
        /// specify implementation-specific hints
        /// <para>Require:</para> <para>GL_VERSION_1_0, GL_VERSION_ES_CM_1_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The interpretation of hints depends on the implementation.
        /// Some implementations ignore <see cref="glHint"/> settings.
        /// <code>GL_TEXTURE_COMPRESSION_HINT</code> is available only if the GL version is 1.3
        /// or greater.
        /// <code>GL_GENERATE_MIPMAP_HINT</code> is available only if the GL version is 1.4
        /// or greater.
        /// <code>GL_FRAGMENT_SHADER_DERIVATIVE_HINT</code> is available only if the GL version is 2.0
        /// or greater.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if either <paramref name="target"/> or <paramref name="mode"/> is not
        /// an accepted value.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glHint"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glHint(GLenum target, GLenum mode);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies a symbolic constant indicating the behavior to be controlled.
        /// <code>GL_FOG_HINT</code>,	
        /// <code>GL_GENERATE_MIPMAP_HINT</code>,
        /// <code>GL_LINE_SMOOTH_HINT</code>,
        /// <code>GL_PERSPECTIVE_CORRECTION_HINT</code>,
        /// <code>GL_POINT_SMOOTH_HINT</code>,
        /// <code>GL_POLYGON_SMOOTH_HINT</code>,
        /// <code>GL_TEXTURE_COMPRESSION_HINT</code>, and
        /// <code>GL_FRAGMENT_SHADER_DERIVATIVE_HINT</code>
        /// are accepted.
        /// </para>
        /// </param>
        /// <param name="mode">
        /// <para>
        /// Specifies a symbolic constant indicating the desired behavior.
        /// <code>GL_FASTEST</code>,
        /// <code>GL_NICEST</code>, and
        /// <code>GL_DONT_CARE</code> are accepted.
        /// </para>
        /// </param>
        public static void glHint(uint target, uint mode) {
            var _F = _GetProc<GLNativeDelegate.FNglHint>("glHint");
            _F(target, mode);
        }
        /// <summary>
        /// specify the width of rasterized lines
        /// <para>Require:</para> <para>GL_VERSION_1_0, GL_VERSION_ES_CM_1_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The line width specified by <see cref="glLineWidth"/> is always returned when <code>GL_LINE_WIDTH</code>
        /// is queried.
        /// Clamping and rounding for aliased and antialiased lines have no effect on the specified value.
        /// Nonantialiased line width may be clamped to an implementation-dependent maximum.  Call  <see cref="glGet"/>  with <code>GL_ALIASED_LINE_WIDTH_RANGE</code> to determine the maximum width.
        /// In OpenGL 1.2, the tokens <code>GL_LINE_WIDTH_RANGE</code> and <code>GL_LINE_WIDTH_GRANULARITY</code> were replaced by <code>GL_ALIASED_LINE_WIDTH_RANGE</code>,
        /// <code>GL_SMOOTH_LINE_WIDTH_RANGE</code>, and <code>GL_SMOOTH_LINE_WIDTH_GRANULARITY</code>.  The old names are retained for backward compatibility, but should not be used in new code.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="width"/> is less than or equal to 0.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glLineWidth"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glLineWidth(GLfloat width);</para>
        /// </summary>
        /// <param name="width">
        /// <para>
        /// Specifies the width of rasterized lines.
        /// The initial value is 1.
        /// </para>
        /// </param>
        /// <seealso cref="glEnable"/>
        public static void glLineWidth(float width) {
            var _F = _GetProc<GLNativeDelegate.FNglLineWidth>("glLineWidth");
            _F(width);
        }
        /// <summary>
        /// specify the diameter of rasterized points
        /// <para>Require:</para> <para>GL_VERSION_1_0, GL_VERSION_ES_CM_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The point size specified by <see cref="glPointSize"/> is always returned when
        /// <code>GL_POINT_SIZE</code> is queried.  Clamping and rounding for aliased and
        /// antialiased points have no effect on the specified value.
        /// A non-antialiased point size may be clamped to an implementation-dependent
        /// maximum.  Although this maximum cannot be queried, it must be no less than
        /// the maximum value for antialiased points, rounded to the nearest integer
        /// value.
        /// <code>GL_POINT_SIZE_RANGE</code> and <code>GL_POINT_SIZE_GRANULARITY</code> are
        /// deprecated in GL versions 1.2 and greater.  Their functionality has been
        /// replaced by <code>GL_SMOOTH_POINT_SIZE_RANGE</code> and
        /// <code>GL_SMOOTH_POINT_SIZE_GRANULARITY</code>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="size"/> is less than or equal to 0.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glPointSize"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glPointSize(GLfloat size);</para>
        /// </summary>
        /// <param name="size">
        /// <para>
        /// Specifies the diameter of rasterized points.
        /// The initial value is 1.
        /// </para>
        /// </param>
        /// <seealso cref="glEnable"/>
        /// <seealso cref="glPointParameter"/>
        public static void glPointSize(float size) {
            var _F = _GetProc<GLNativeDelegate.FNglPointSize>("glPointSize");
            _F(size);
        }
        /// <summary>
        /// select a polygon rasterization mode
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// Vertices are marked as boundary or nonboundary with an edge flag.
        /// Edge flags are generated internally by the GL when it decomposes
        /// polygons; they can be set explicitly using  <see cref="glEdgeFlag"/> .
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if either <paramref name="face"/> or <paramref name="mode"/> is not
        /// an accepted value.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glPolygonMode"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glPolygonMode(GLenum face, GLenum mode);</para>
        /// </summary>
        /// <param name="face">
        /// <para>
        /// Specifies the polygons that <paramref name="mode"/> applies to.
        /// Must be
        /// <code>GL_FRONT</code> for front-facing polygons,
        /// <code>GL_BACK</code> for back-facing polygons,
        /// or <code>GL_FRONT_AND_BACK</code> for front- and back-facing polygons.
        /// </para>
        /// </param>
        /// <param name="mode">
        /// <para>
        /// Specifies how polygons will be rasterized.
        /// Accepted values are
        /// <code>GL_POINT</code>,
        /// <code>GL_LINE</code>, and
        /// <code>GL_FILL</code>.
        /// The initial value is <code>GL_FILL</code> for both front- and back-facing polygons.
        /// </para>
        /// </param>
        /// <seealso cref="glBegin"/>
        /// <seealso cref="glEdgeFlag"/>
        /// <seealso cref="glLineStipple"/>
        /// <seealso cref="glLineWidth"/>
        /// <seealso cref="glPointSize"/>
        /// <seealso cref="glPolygonStipple"/>
        public static void glPolygonMode(uint face, uint mode) {
            var _F = _GetProc<GLNativeDelegate.FNglPolygonMode>("glPolygonMode");
            _F(face, mode);
        }
        /// <summary>
        /// define the scissor box
        /// <para>Require:</para> <para>GL_VERSION_1_0, GL_VERSION_ES_CM_1_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if either <paramref name="width"/> or <paramref name="height"/> is negative.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glScissor"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glScissor(GLint x, GLint y, GLsizei width, GLsizei height);</para>
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify the lower left corner of the scissor box.
        /// Initially (0, 0).
        /// </para>
        /// </param>
        /// <param name="y">
        /// <para>
        /// Specify the lower left corner of the scissor box.
        /// Initially (0, 0).
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// Specify the width and height of the scissor box.
        /// When a GL context is first attached to a window,
        /// <paramref name="width"/> and <paramref name="height"/> are set to the dimensions of that
        /// window.
        /// </para>
        /// </param>
        /// <param name="height">
        /// <para>
        /// Specify the width and height of the scissor box.
        /// When a GL context is first attached to a window,
        /// <paramref name="width"/> and <paramref name="height"/> are set to the dimensions of that
        /// window.
        /// </para>
        /// </param>
        /// <seealso cref="glEnable"/>
        /// <seealso cref="glViewport"/>
        public static void glScissor(int x, int y, int width, int height) {
            var _F = _GetProc<GLNativeDelegate.FNglScissor>("glScissor");
            _F(x, y, width, height);
        }
        /// <summary>
        /// set texture parameters
        /// <para>Require:</para> <para>GL_VERSION_1_0, GL_VERSION_ES_CM_1_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <code>GL_TEXTURE_3D</code>, <code>GL_TEXTURE_MIN_LOD</code>, <code>GL_TEXTURE_MAX_LOD</code>,
        /// <code>GL_CLAMP_TO_EDGE</code>, <code>GL_TEXTURE_BASE_LEVEL</code>, and <code>GL_TEXTURE_MAX_LEVEL</code> are
        /// available only if the GL version is 1.2 or greater.
        /// <code>GL_CLAMP_TO_BORDER</code> is available only if the GL version is 1.3 or greater.
        /// <code>GL_MIRRORED_REPEAT</code>, <code>GL_TEXTURE_COMPARE_MODE</code>,
        /// <code>GL_TEXTURE_COMPARE_FUNC</code>, <code>GL_DEPTH_TEXTURE_MODE</code>, and
        /// <code>GL_GENERATE_MIPMAP</code> are available only if the GL version is 1.4 or
        /// greater.
        /// <code>GL_TEXTURE_COMPARE_FUNC</code> allows the following additional comparison modes only
        /// if the GL version is 1.5 or greater:
        /// <code>GL_LESS</code>, <code>GL_GREATER</code>,
        /// <code>GL_EQUAL</code>, <code>GL_NOTEQUAL</code>,
        /// <code>GL_ALWAYS</code>, and <code>GL_NEVER</code>.
        /// Suppose that a program has enabled texturing (by calling  <see cref="glEnable"/>  with
        /// argument <code>GL_TEXTURE_1D</code>, <code>GL_TEXTURE_2D</code>, or <code>GL_TEXTURE_3D</code>) and
        /// has set <code>GL_TEXTURE_MIN_FILTER</code> to one of the functions that requires a
        /// mipmap.  If either the dimensions of the texture images currently defined
        /// (with previous calls to  <see cref="glTexImage1D"/> ,  <see cref="glTexImage2D"/> ,
        /// <see cref="glTexImage3D"/> ,  <see cref="glCopyTexImage1D"/> , or  <see cref="glCopyTexImage2D"/> ) do not
        /// follow the proper sequence for mipmaps (described above), or there are
        /// fewer texture images defined than are needed, or the set of texture images
        /// have differing numbers of texture components, then it is as if texture
        /// mapping were disabled.
        /// Linear filtering accesses the four nearest texture elements only in 2D
        /// textures.  In 1D textures, linear filtering accesses the two nearest
        /// texture elements.
        /// For OpenGL versions 1.3 and greater, or when the <code>ARB_multitexture</code> extension is supported, <see cref="glTexParameter"/>
        /// specifies the texture parameters for the active texture unit, specified
        /// by calling  <see cref="glActiveTexture"/> .
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="target"/> or <paramref name="pname"/> is not
        /// one of the accepted defined values.
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="ps"/> should have a defined
        /// constant value (based on the value of <paramref name="pname"/>) and does not.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glTexParameter"/> is executed between the
        /// execution of  <see cref="glBegin"/>  and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glTexParameterf(GLenum target, GLenum pname, GLfloat param);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target texture,
        /// which must be either <code>GL_TEXTURE_1D</code>, <code>GL_TEXTURE_2D</code>,
        /// <code>GL_TEXTURE_3D</code>, or <code>GL_TEXTURE_CUBE_MAP</code>.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of a single-valued texture parameter.
        /// <paramref name="pname"/> can be one of the following:
        /// <code>GL_TEXTURE_MIN_FILTER</code>,
        /// <code>GL_TEXTURE_MAG_FILTER</code>,
        /// <code>GL_TEXTURE_MIN_LOD</code>,
        /// <code>GL_TEXTURE_MAX_LOD</code>,
        /// <code>GL_TEXTURE_BASE_LEVEL</code>,
        /// <code>GL_TEXTURE_MAX_LEVEL</code>,
        /// <code>GL_TEXTURE_WRAP_S</code>,
        /// <code>GL_TEXTURE_WRAP_T</code>,
        /// <code>GL_TEXTURE_WRAP_R</code>,
        /// <code>GL_TEXTURE_PRIORITY</code>,
        /// <code>GL_TEXTURE_COMPARE_MODE</code>,
        /// <code>GL_TEXTURE_COMPARE_FUNC</code>,
        /// <code>GL_DEPTH_TEXTURE_MODE</code>, or
        /// <code>GL_GENERATE_MIPMAP</code>.
        /// </para>
        /// </param>
        /// <param name="param">
        /// Specifies the value of <paramref name="pname"/>.
        /// </param>
        /// <seealso cref="glActiveTexture"/>
        /// <seealso cref="glBindTexture"/>
        /// <seealso cref="glCopyPixels"/>
        /// <seealso cref="glCopyTexImage1D"/>
        /// <seealso cref="glCopyTexImage2D"/>
        /// <seealso cref="glCopyTexSubImage1D"/>
        /// <seealso cref="glCopyTexSubImage2D"/>
        /// <seealso cref="glCopyTexSubImage3D"/>
        /// <seealso cref="glDrawPixels"/>
        /// <seealso cref="glPixelStore"/>
        /// <seealso cref="glPixelTransfer"/>
        /// <seealso cref="glPrioritizeTextures"/>
        /// <seealso cref="glTexEnv"/>
        /// <seealso cref="glTexGen"/>
        /// <seealso cref="glTexImage1D"/>
        /// <seealso cref="glTexImage2D"/>
        /// <seealso cref="glTexImage3D"/>
        /// <seealso cref="glTexSubImage1D"/>
        /// <seealso cref="glTexSubImage2D"/>
        /// <seealso cref="glTexSubImage3D"/>
        public static void glTexParameterf(uint target, uint pname, float param) {
            var _F = _GetProc<GLNativeDelegate.FNglTexParameterf>("glTexParameterf");
            _F(target, pname, param);
        }
        /// <summary>
        /// set texture parameters
        /// <para>Require:</para> <para>GL_VERSION_1_0, GL_VERSION_ES_CM_1_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <code>GL_TEXTURE_3D</code>, <code>GL_TEXTURE_MIN_LOD</code>, <code>GL_TEXTURE_MAX_LOD</code>,
        /// <code>GL_CLAMP_TO_EDGE</code>, <code>GL_TEXTURE_BASE_LEVEL</code>, and <code>GL_TEXTURE_MAX_LEVEL</code> are
        /// available only if the GL version is 1.2 or greater.
        /// <code>GL_CLAMP_TO_BORDER</code> is available only if the GL version is 1.3 or greater.
        /// <code>GL_MIRRORED_REPEAT</code>, <code>GL_TEXTURE_COMPARE_MODE</code>,
        /// <code>GL_TEXTURE_COMPARE_FUNC</code>, <code>GL_DEPTH_TEXTURE_MODE</code>, and
        /// <code>GL_GENERATE_MIPMAP</code> are available only if the GL version is 1.4 or
        /// greater.
        /// <code>GL_TEXTURE_COMPARE_FUNC</code> allows the following additional comparison modes only
        /// if the GL version is 1.5 or greater:
        /// <code>GL_LESS</code>, <code>GL_GREATER</code>,
        /// <code>GL_EQUAL</code>, <code>GL_NOTEQUAL</code>,
        /// <code>GL_ALWAYS</code>, and <code>GL_NEVER</code>.
        /// Suppose that a program has enabled texturing (by calling  <see cref="glEnable"/>  with
        /// argument <code>GL_TEXTURE_1D</code>, <code>GL_TEXTURE_2D</code>, or <code>GL_TEXTURE_3D</code>) and
        /// has set <code>GL_TEXTURE_MIN_FILTER</code> to one of the functions that requires a
        /// mipmap.  If either the dimensions of the texture images currently defined
        /// (with previous calls to  <see cref="glTexImage1D"/> ,  <see cref="glTexImage2D"/> ,
        /// <see cref="glTexImage3D"/> ,  <see cref="glCopyTexImage1D"/> , or  <see cref="glCopyTexImage2D"/> ) do not
        /// follow the proper sequence for mipmaps (described above), or there are
        /// fewer texture images defined than are needed, or the set of texture images
        /// have differing numbers of texture components, then it is as if texture
        /// mapping were disabled.
        /// Linear filtering accesses the four nearest texture elements only in 2D
        /// textures.  In 1D textures, linear filtering accesses the two nearest
        /// texture elements.
        /// For OpenGL versions 1.3 and greater, or when the <code>ARB_multitexture</code> extension is supported, <see cref="glTexParameter"/>
        /// specifies the texture parameters for the active texture unit, specified
        /// by calling  <see cref="glActiveTexture"/> .
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="target"/> or <paramref name="pname"/> is not
        /// one of the accepted defined values.
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="ps"/> should have a defined
        /// constant value (based on the value of <paramref name="pname"/>) and does not.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glTexParameter"/> is executed between the
        /// execution of  <see cref="glBegin"/>  and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glTexParameterfv(GLenum target, GLenum pname, const GLfloat * params);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target texture,
        /// which must be either <code>GL_TEXTURE_1D</code>, <code>GL_TEXTURE_2D</code> or
        /// <code>GL_TEXTURE_3D</code>.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of a texture parameter.
        /// <paramref name="pname"/> can be one of the following:
        /// <code>GL_TEXTURE_MIN_FILTER</code>,
        /// <code>GL_TEXTURE_MAG_FILTER</code>,
        /// <code>GL_TEXTURE_MIN_LOD</code>,
        /// <code>GL_TEXTURE_MAX_LOD</code>,
        /// <code>GL_TEXTURE_BASE_LEVEL</code>,
        /// <code>GL_TEXTURE_MAX_LEVEL</code>,
        /// <code>GL_TEXTURE_WRAP_S</code>,
        /// <code>GL_TEXTURE_WRAP_T</code>,
        /// <code>GL_TEXTURE_WRAP_R</code>,
        /// <code>GL_TEXTURE_BORDER_COLOR</code>,
        /// <code>GL_TEXTURE_PRIORITY</code>,
        /// <code>GL_TEXTURE_COMPARE_MODE</code>,
        /// <code>GL_TEXTURE_COMPARE_FUNC</code>,
        /// <code>GL_DEPTH_TEXTURE_MODE</code>, or
        /// <code>GL_GENERATE_MIPMAP</code>.
        /// </para>
        /// </param>
        /// <param name="ps">
        /// <para>
        /// Specifies a pointer to an array where the value or values of <paramref name="pname"/>
        /// are stored.
        /// </para>
        /// </param>
        /// <seealso cref="glActiveTexture"/>
        /// <seealso cref="glBindTexture"/>
        /// <seealso cref="glCopyPixels"/>
        /// <seealso cref="glCopyTexImage1D"/>
        /// <seealso cref="glCopyTexImage2D"/>
        /// <seealso cref="glCopyTexSubImage1D"/>
        /// <seealso cref="glCopyTexSubImage2D"/>
        /// <seealso cref="glCopyTexSubImage3D"/>
        /// <seealso cref="glDrawPixels"/>
        /// <seealso cref="glPixelStore"/>
        /// <seealso cref="glPixelTransfer"/>
        /// <seealso cref="glPrioritizeTextures"/>
        /// <seealso cref="glTexEnv"/>
        /// <seealso cref="glTexGen"/>
        /// <seealso cref="glTexImage1D"/>
        /// <seealso cref="glTexImage2D"/>
        /// <seealso cref="glTexImage3D"/>
        /// <seealso cref="glTexSubImage1D"/>
        /// <seealso cref="glTexSubImage2D"/>
        /// <seealso cref="glTexSubImage3D"/>
        public unsafe static void glTexParameterfv(uint target, uint pname, float* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglTexParameterfv>("glTexParameterfv");
            _F(target, pname, ps);
        }
        /// <summary>
        /// set texture parameters
        /// <para>Require:</para> <para>GL_VERSION_1_0, GL_VERSION_ES_CM_1_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <code>GL_TEXTURE_3D</code>, <code>GL_TEXTURE_MIN_LOD</code>, <code>GL_TEXTURE_MAX_LOD</code>,
        /// <code>GL_CLAMP_TO_EDGE</code>, <code>GL_TEXTURE_BASE_LEVEL</code>, and <code>GL_TEXTURE_MAX_LEVEL</code> are
        /// available only if the GL version is 1.2 or greater.
        /// <code>GL_CLAMP_TO_BORDER</code> is available only if the GL version is 1.3 or greater.
        /// <code>GL_MIRRORED_REPEAT</code>, <code>GL_TEXTURE_COMPARE_MODE</code>,
        /// <code>GL_TEXTURE_COMPARE_FUNC</code>, <code>GL_DEPTH_TEXTURE_MODE</code>, and
        /// <code>GL_GENERATE_MIPMAP</code> are available only if the GL version is 1.4 or
        /// greater.
        /// <code>GL_TEXTURE_COMPARE_FUNC</code> allows the following additional comparison modes only
        /// if the GL version is 1.5 or greater:
        /// <code>GL_LESS</code>, <code>GL_GREATER</code>,
        /// <code>GL_EQUAL</code>, <code>GL_NOTEQUAL</code>,
        /// <code>GL_ALWAYS</code>, and <code>GL_NEVER</code>.
        /// Suppose that a program has enabled texturing (by calling  <see cref="glEnable"/>  with
        /// argument <code>GL_TEXTURE_1D</code>, <code>GL_TEXTURE_2D</code>, or <code>GL_TEXTURE_3D</code>) and
        /// has set <code>GL_TEXTURE_MIN_FILTER</code> to one of the functions that requires a
        /// mipmap.  If either the dimensions of the texture images currently defined
        /// (with previous calls to  <see cref="glTexImage1D"/> ,  <see cref="glTexImage2D"/> ,
        /// <see cref="glTexImage3D"/> ,  <see cref="glCopyTexImage1D"/> , or  <see cref="glCopyTexImage2D"/> ) do not
        /// follow the proper sequence for mipmaps (described above), or there are
        /// fewer texture images defined than are needed, or the set of texture images
        /// have differing numbers of texture components, then it is as if texture
        /// mapping were disabled.
        /// Linear filtering accesses the four nearest texture elements only in 2D
        /// textures.  In 1D textures, linear filtering accesses the two nearest
        /// texture elements.
        /// For OpenGL versions 1.3 and greater, or when the <code>ARB_multitexture</code> extension is supported, <see cref="glTexParameter"/>
        /// specifies the texture parameters for the active texture unit, specified
        /// by calling  <see cref="glActiveTexture"/> .
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="target"/> or <paramref name="pname"/> is not
        /// one of the accepted defined values.
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="ps"/> should have a defined
        /// constant value (based on the value of <paramref name="pname"/>) and does not.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glTexParameter"/> is executed between the
        /// execution of  <see cref="glBegin"/>  and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glTexParameteri(GLenum target, GLenum pname, GLint param);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target texture,
        /// which must be either <code>GL_TEXTURE_1D</code>, <code>GL_TEXTURE_2D</code>,
        /// <code>GL_TEXTURE_3D</code>, or <code>GL_TEXTURE_CUBE_MAP</code>.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of a single-valued texture parameter.
        /// <paramref name="pname"/> can be one of the following:
        /// <code>GL_TEXTURE_MIN_FILTER</code>,
        /// <code>GL_TEXTURE_MAG_FILTER</code>,
        /// <code>GL_TEXTURE_MIN_LOD</code>,
        /// <code>GL_TEXTURE_MAX_LOD</code>,
        /// <code>GL_TEXTURE_BASE_LEVEL</code>,
        /// <code>GL_TEXTURE_MAX_LEVEL</code>,
        /// <code>GL_TEXTURE_WRAP_S</code>,
        /// <code>GL_TEXTURE_WRAP_T</code>,
        /// <code>GL_TEXTURE_WRAP_R</code>,
        /// <code>GL_TEXTURE_PRIORITY</code>,
        /// <code>GL_TEXTURE_COMPARE_MODE</code>,
        /// <code>GL_TEXTURE_COMPARE_FUNC</code>,
        /// <code>GL_DEPTH_TEXTURE_MODE</code>, or
        /// <code>GL_GENERATE_MIPMAP</code>.
        /// </para>
        /// </param>
        /// <param name="param">
        /// Specifies the value of <paramref name="pname"/>.
        /// </param>
        /// <seealso cref="glActiveTexture"/>
        /// <seealso cref="glBindTexture"/>
        /// <seealso cref="glCopyPixels"/>
        /// <seealso cref="glCopyTexImage1D"/>
        /// <seealso cref="glCopyTexImage2D"/>
        /// <seealso cref="glCopyTexSubImage1D"/>
        /// <seealso cref="glCopyTexSubImage2D"/>
        /// <seealso cref="glCopyTexSubImage3D"/>
        /// <seealso cref="glDrawPixels"/>
        /// <seealso cref="glPixelStore"/>
        /// <seealso cref="glPixelTransfer"/>
        /// <seealso cref="glPrioritizeTextures"/>
        /// <seealso cref="glTexEnv"/>
        /// <seealso cref="glTexGen"/>
        /// <seealso cref="glTexImage1D"/>
        /// <seealso cref="glTexImage2D"/>
        /// <seealso cref="glTexImage3D"/>
        /// <seealso cref="glTexSubImage1D"/>
        /// <seealso cref="glTexSubImage2D"/>
        /// <seealso cref="glTexSubImage3D"/>
        public static void glTexParameteri(uint target, uint pname, int param) {
            var _F = _GetProc<GLNativeDelegate.FNglTexParameteri>("glTexParameteri");
            _F(target, pname, param);
        }
        /// <summary>
        /// set texture parameters
        /// <para>Require:</para> <para>GL_VERSION_1_0, GL_VERSION_ES_CM_1_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <code>GL_TEXTURE_3D</code>, <code>GL_TEXTURE_MIN_LOD</code>, <code>GL_TEXTURE_MAX_LOD</code>,
        /// <code>GL_CLAMP_TO_EDGE</code>, <code>GL_TEXTURE_BASE_LEVEL</code>, and <code>GL_TEXTURE_MAX_LEVEL</code> are
        /// available only if the GL version is 1.2 or greater.
        /// <code>GL_CLAMP_TO_BORDER</code> is available only if the GL version is 1.3 or greater.
        /// <code>GL_MIRRORED_REPEAT</code>, <code>GL_TEXTURE_COMPARE_MODE</code>,
        /// <code>GL_TEXTURE_COMPARE_FUNC</code>, <code>GL_DEPTH_TEXTURE_MODE</code>, and
        /// <code>GL_GENERATE_MIPMAP</code> are available only if the GL version is 1.4 or
        /// greater.
        /// <code>GL_TEXTURE_COMPARE_FUNC</code> allows the following additional comparison modes only
        /// if the GL version is 1.5 or greater:
        /// <code>GL_LESS</code>, <code>GL_GREATER</code>,
        /// <code>GL_EQUAL</code>, <code>GL_NOTEQUAL</code>,
        /// <code>GL_ALWAYS</code>, and <code>GL_NEVER</code>.
        /// Suppose that a program has enabled texturing (by calling  <see cref="glEnable"/>  with
        /// argument <code>GL_TEXTURE_1D</code>, <code>GL_TEXTURE_2D</code>, or <code>GL_TEXTURE_3D</code>) and
        /// has set <code>GL_TEXTURE_MIN_FILTER</code> to one of the functions that requires a
        /// mipmap.  If either the dimensions of the texture images currently defined
        /// (with previous calls to  <see cref="glTexImage1D"/> ,  <see cref="glTexImage2D"/> ,
        /// <see cref="glTexImage3D"/> ,  <see cref="glCopyTexImage1D"/> , or  <see cref="glCopyTexImage2D"/> ) do not
        /// follow the proper sequence for mipmaps (described above), or there are
        /// fewer texture images defined than are needed, or the set of texture images
        /// have differing numbers of texture components, then it is as if texture
        /// mapping were disabled.
        /// Linear filtering accesses the four nearest texture elements only in 2D
        /// textures.  In 1D textures, linear filtering accesses the two nearest
        /// texture elements.
        /// For OpenGL versions 1.3 and greater, or when the <code>ARB_multitexture</code> extension is supported, <see cref="glTexParameter"/>
        /// specifies the texture parameters for the active texture unit, specified
        /// by calling  <see cref="glActiveTexture"/> .
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="target"/> or <paramref name="pname"/> is not
        /// one of the accepted defined values.
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="ps"/> should have a defined
        /// constant value (based on the value of <paramref name="pname"/>) and does not.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glTexParameter"/> is executed between the
        /// execution of  <see cref="glBegin"/>  and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glTexParameteriv(GLenum target, GLenum pname, const GLint * params);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target texture,
        /// which must be either <code>GL_TEXTURE_1D</code>, <code>GL_TEXTURE_2D</code> or
        /// <code>GL_TEXTURE_3D</code>.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of a texture parameter.
        /// <paramref name="pname"/> can be one of the following:
        /// <code>GL_TEXTURE_MIN_FILTER</code>,
        /// <code>GL_TEXTURE_MAG_FILTER</code>,
        /// <code>GL_TEXTURE_MIN_LOD</code>,
        /// <code>GL_TEXTURE_MAX_LOD</code>,
        /// <code>GL_TEXTURE_BASE_LEVEL</code>,
        /// <code>GL_TEXTURE_MAX_LEVEL</code>,
        /// <code>GL_TEXTURE_WRAP_S</code>,
        /// <code>GL_TEXTURE_WRAP_T</code>,
        /// <code>GL_TEXTURE_WRAP_R</code>,
        /// <code>GL_TEXTURE_BORDER_COLOR</code>,
        /// <code>GL_TEXTURE_PRIORITY</code>,
        /// <code>GL_TEXTURE_COMPARE_MODE</code>,
        /// <code>GL_TEXTURE_COMPARE_FUNC</code>,
        /// <code>GL_DEPTH_TEXTURE_MODE</code>, or
        /// <code>GL_GENERATE_MIPMAP</code>.
        /// </para>
        /// </param>
        /// <param name="ps">
        /// <para>
        /// Specifies a pointer to an array where the value or values of <paramref name="pname"/>
        /// are stored.
        /// </para>
        /// </param>
        /// <seealso cref="glActiveTexture"/>
        /// <seealso cref="glBindTexture"/>
        /// <seealso cref="glCopyPixels"/>
        /// <seealso cref="glCopyTexImage1D"/>
        /// <seealso cref="glCopyTexImage2D"/>
        /// <seealso cref="glCopyTexSubImage1D"/>
        /// <seealso cref="glCopyTexSubImage2D"/>
        /// <seealso cref="glCopyTexSubImage3D"/>
        /// <seealso cref="glDrawPixels"/>
        /// <seealso cref="glPixelStore"/>
        /// <seealso cref="glPixelTransfer"/>
        /// <seealso cref="glPrioritizeTextures"/>
        /// <seealso cref="glTexEnv"/>
        /// <seealso cref="glTexGen"/>
        /// <seealso cref="glTexImage1D"/>
        /// <seealso cref="glTexImage2D"/>
        /// <seealso cref="glTexImage3D"/>
        /// <seealso cref="glTexSubImage1D"/>
        /// <seealso cref="glTexSubImage2D"/>
        /// <seealso cref="glTexSubImage3D"/>
        public unsafe static void glTexParameteriv(uint target, uint pname, int* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglTexParameteriv>("glTexParameteriv");
            _F(target, pname, ps);
        }
        /// <summary>
        /// specify a one-dimensional texture image
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// Texturing has no effect in color index mode.
        /// If the <code>ARB_imaging</code> extension is supported, RGBA elements may
        /// also be processed by the imaging pipeline.  The following stages may be
        /// applied to an RGBA color before color component clamping to the range
        /// 0 
        /// 1 
        /// :
        /// 1. Color component replacement by the color table specified for 
        /// <code>GL_COLOR_TABLE</code>, if enabled. See  <see cref="glColorTable"/> .
        /// 2. One-dimensional convolution filtering, if enabled. See 
        /// <see cref="glConvolutionFilter1D"/> .
        /// If a convolution filter changes the <paramref name="width"/> of the texture (by
        /// processing with a <code>GL_CONVOLUTION_BORDER_MODE</code> of <code>GL_REDUCE</code>, for
        /// example), the <paramref name="width"/> must 
        /// 2 
        /// n 
        /// + 
        /// 2 
        /// &af; 
        /// border 
        /// ,
        /// for some
        /// integer 
        /// n   ,
        /// after filtering.
        /// 3. RGBA components may be multiplied by <code>GL_POST_CONVOLUTION_c_SCALE</code>, 
        /// and added to <code>GL_POST_CONVOLUTION_c_BIAS</code>, if enabled.  See
        /// <see cref="glPixelTransfer"/> .
        /// 4. Color component replacement by the color table specified for 
        /// <code>GL_POST_CONVOLUTION_COLOR_TABLE</code>, if enabled.  See  <see cref="glColorTable"/> .
        /// 5. Transformation by the color matrix. 
        /// See  <see cref="glMatrixMode"/> .
        /// 6. RGBA components may be multiplied by <code>GL_POST_COLOR_MATRIX_c_SCALE</code>, 
        /// and added to <code>GL_POST_COLOR_MATRIX_c_BIAS</code>, if enabled.  See
        /// <see cref="glPixelTransfer"/> .
        /// 7. Color component replacement by the color table specified for 
        /// <code>GL_POST_COLOR_MATRIX_COLOR_TABLE</code>, if enabled.  See  <see cref="glColorTable"/> .
        /// The texture image can be represented by the same data formats
        /// as the pixels in a  <see cref="glDrawPixels"/>  command,
        /// except that <code>GL_STENCIL_INDEX</code>
        /// cannot be used.
        /// <see cref="glPixelStore"/>  and  <see cref="glPixelTransfer"/>  modes affect texture images
        /// in exactly the way they affect  <see cref="glDrawPixels"/> .
        /// <code>GL_PROXY_TEXTURE_1D</code> may be used only if the GL version is 1.1 or greater.
        /// Internal formats other than 1, 2, 3, or 4 may be
        /// used only if the GL version is 1.1 or greater.
        /// In GL version 1.1 or greater,
        /// <paramref name="data"/> may be a null pointer. In this case texture memory is
        /// allocated to accommodate a texture of width <paramref name="width"/>.
        /// You can then download subtextures to initialize the
        /// texture memory. The image is undefined if the program tries to apply
        /// an uninitialized portion of the texture image to a primitive.
        /// Formats <code>GL_BGR</code>, and <code>GL_BGRA</code> and types
        /// <code>GL_UNSIGNED_BYTE_3_3_2</code>,
        /// <code>GL_UNSIGNED_BYTE_2_3_3_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_5_6_5</code>,
        /// <code>GL_UNSIGNED_SHORT_5_6_5_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_4_4_4_4</code>,
        /// <code>GL_UNSIGNED_SHORT_4_4_4_4_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_5_5_5_1</code>,
        /// <code>GL_UNSIGNED_SHORT_1_5_5_5_REV</code>,
        /// <code>GL_UNSIGNED_INT_8_8_8_8</code>,
        /// <code>GL_UNSIGNED_INT_8_8_8_8_REV</code>,
        /// <code>GL_UNSIGNED_INT_10_10_10_2</code>, and
        /// <code>GL_UNSIGNED_INT_2_10_10_10_REV</code> are available only if the GL version
        /// is 1.2 or greater.
        /// When the <code>ARB_multitexture</code> extension is supported, or the GL version is 1.3 or greater, <see cref="glTexImage1D"/>
        /// specifies the one-dimensional texture for the current texture unit,
        /// specified with  <see cref="glActiveTexture"/> .
        /// <code>GL_DEPTH_COMPONENT</code>, <code>GL_DEPTH_COMPONENT16</code>,
        /// <code>GL_DEPTH_COMPONENT24</code>, and <code>GL_DEPTH_COMPONENT32</code> are available only
        /// if the GL version is 1.4 or greater.
        /// Non-power-of-two textures are supported if the GL version is 2.0 or greater, or if the implementation exports the <code>GL_ARB_texture_non_power_of_two</code> extension.
        /// The 
        /// <code>GL_SRGB</code>,
        /// <code>GL_SRGB8</code>,
        /// <code>GL_SRGB_ALPHA</code>,
        /// <code>GL_SRGB8_ALPHA8</code>,
        /// <code>GL_SLUMINANCE</code>,
        /// <code>GL_SLUMINANCE8</code>,
        /// <code>GL_SLUMINANCE_ALPHA</code>, and
        /// <code>GL_SLUMINANCE8_ALPHA8</code>
        /// internal formats are only available if the GL version is 2.1 or greater.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="target"/> is not <code>GL_TEXTURE_1D</code>
        /// or <code>GL_PROXY_TEXTURE_1D</code>.
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="format"/> is not an accepted
        /// format constant.  Format constants other than <code>GL_STENCIL_INDEX</code>
        /// are accepted.
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="type"/> is not a type constant.
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="type"/> is <code>GL_BITMAP</code> and
        /// <paramref name="format"/> is not <code>GL_COLOR_INDEX</code>.
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="level"/> is less than 0.
        /// <code>GL_INVALID_VALUE</code> may be generated if <paramref name="level"/> is greater than 
        /// log 
        /// 2 
        /// &af; 
        /// max 
        /// ,
        /// where  max  is the returned value of <code>GL_MAX_TEXTURE_SIZE</code>.
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="internalFormat"/> is not 1, 2, 3, 4, or
        /// one of the accepted resolution and format symbolic constants.
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="width"/> is less than 0
        /// or greater than 2 + <code>GL_MAX_TEXTURE_SIZE</code>.
        /// <code>GL_INVALID_VALUE</code> is generated if non-power-of-two textures are not supported and the <paramref name="width"/> cannot be represented as
        /// 2 
        /// n 
        /// + 
        /// 2 
        /// &af; 
        /// border 
        /// for some integer value of  n .
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="border"/> is not 0 or 1.
        /// <code>GL_INVALID_OPERATION</code> is generated if <paramref name="type"/> is one of
        /// <code>GL_UNSIGNED_BYTE_3_3_2</code>,
        /// <code>GL_UNSIGNED_BYTE_2_3_3_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_5_6_5</code>, or
        /// <code>GL_UNSIGNED_SHORT_5_6_5_REV</code>
        /// and <paramref name="format"/> is not <code>GL_RGB</code>.
        /// <code>GL_INVALID_OPERATION</code> is generated if <paramref name="type"/> is one of
        /// <code>GL_UNSIGNED_SHORT_4_4_4_4</code>,
        /// <code>GL_UNSIGNED_SHORT_4_4_4_4_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_5_5_5_1</code>,
        /// <code>GL_UNSIGNED_SHORT_1_5_5_5_REV</code>,
        /// <code>GL_UNSIGNED_INT_8_8_8_8</code>,
        /// <code>GL_UNSIGNED_INT_8_8_8_8_REV</code>,
        /// <code>GL_UNSIGNED_INT_10_10_10_2</code>, or
        /// <code>GL_UNSIGNED_INT_2_10_10_10_REV</code>
        /// and <paramref name="format"/> is neither <code>GL_RGBA</code> nor <code>GL_BGRA</code>.
        /// <code>GL_INVALID_OPERATION</code> is generated if <paramref name="format"/> is
        /// <code>GL_DEPTH_COMPONENT</code> and <paramref name="internalFormat"/> is not
        /// <code>GL_DEPTH_COMPONENT</code>, <code>GL_DEPTH_COMPONENT16</code>,
        /// <code>GL_DEPTH_COMPONENT24</code>, or <code>GL_DEPTH_COMPONENT32</code>.
        /// <code>GL_INVALID_OPERATION</code> is generated if <paramref name="internalFormat"/> is
        /// <code>GL_DEPTH_COMPONENT</code>, <code>GL_DEPTH_COMPONENT16</code>,
        /// <code>GL_DEPTH_COMPONENT24</code>, or <code>GL_DEPTH_COMPONENT32</code>, and <paramref name="format"/> is
        /// not <code>GL_DEPTH_COMPONENT</code>.
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_UNPACK_BUFFER</code> target and the buffer object's data store is currently mapped.
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_UNPACK_BUFFER</code> target and the data would be unpacked from the buffer 
        /// object such that the memory reads required would exceed the data store size.
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_UNPACK_BUFFER</code> target and <paramref name="data"/> is not evenly divisible 
        /// into the number of bytes needed to store in memory a datum indicated by <paramref name="type"/>.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glTexImage1D"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glTexImage1D(GLenum target, GLint level, GLint internalFormat, GLsizei width, GLint border, GLenum format, GLenum type, const void * data);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target texture.
        /// Must be <code>GL_TEXTURE_1D</code> or <code>GL_PROXY_TEXTURE_1D</code>.
        /// </para>
        /// </param>
        /// <param name="level">
        /// <para>
        /// Specifies the level-of-detail number.
        /// Level 0 is the base image level.
        /// Level  n  is the  n th mipmap reduction image.
        /// </para>
        /// </param>
        /// <param name="internalFormat">
        /// <para>
        /// Specifies the number of color components in the texture.
        /// Must be 1, 2, 3, or 4, or one of the following symbolic constants:
        /// <code>GL_ALPHA</code>,
        /// <code>GL_ALPHA4</code>,
        /// <code>GL_ALPHA8</code>,
        /// <code>GL_ALPHA12</code>,
        /// <code>GL_ALPHA16</code>,
        /// <code>GL_COMPRESSED_ALPHA</code>,
        /// <code>GL_COMPRESSED_LUMINANCE</code>,
        /// <code>GL_COMPRESSED_LUMINANCE_ALPHA</code>,
        /// <code>GL_COMPRESSED_INTENSITY</code>,
        /// <code>GL_COMPRESSED_RGB</code>,
        /// <code>GL_COMPRESSED_RGBA</code>,
        /// <code>GL_DEPTH_COMPONENT</code>,
        /// <code>GL_DEPTH_COMPONENT16</code>,
        /// <code>GL_DEPTH_COMPONENT24</code>,
        /// <code>GL_DEPTH_COMPONENT32</code>,
        /// <code>GL_LUMINANCE</code>,
        /// <code>GL_LUMINANCE4</code>,
        /// <code>GL_LUMINANCE8</code>,
        /// <code>GL_LUMINANCE12</code>,
        /// <code>GL_LUMINANCE16</code>,
        /// <code>GL_LUMINANCE_ALPHA</code>,
        /// <code>GL_LUMINANCE4_ALPHA4</code>,
        /// <code>GL_LUMINANCE6_ALPHA2</code>,
        /// <code>GL_LUMINANCE8_ALPHA8</code>,
        /// <code>GL_LUMINANCE12_ALPHA4</code>,
        /// <code>GL_LUMINANCE12_ALPHA12</code>,
        /// <code>GL_LUMINANCE16_ALPHA16</code>,
        /// <code>GL_INTENSITY</code>,
        /// <code>GL_INTENSITY4</code>,
        /// <code>GL_INTENSITY8</code>,
        /// <code>GL_INTENSITY12</code>,
        /// <code>GL_INTENSITY16</code>,
        /// <code>GL_R3_G3_B2</code>,
        /// <code>GL_RGB</code>,
        /// <code>GL_RGB4</code>,
        /// <code>GL_RGB5</code>,
        /// <code>GL_RGB8</code>,
        /// <code>GL_RGB10</code>,
        /// <code>GL_RGB12</code>,
        /// <code>GL_RGB16</code>,
        /// <code>GL_RGBA</code>,
        /// <code>GL_RGBA2</code>,
        /// <code>GL_RGBA4</code>,
        /// <code>GL_RGB5_A1</code>,
        /// <code>GL_RGBA8</code>,
        /// <code>GL_RGB10_A2</code>,
        /// <code>GL_RGBA12</code>,
        /// <code>GL_RGBA16</code>,
        /// <code>GL_SLUMINANCE</code>,
        /// <code>GL_SLUMINANCE8</code>,
        /// <code>GL_SLUMINANCE_ALPHA</code>,
        /// <code>GL_SLUMINANCE8_ALPHA8</code>,
        /// <code>GL_SRGB</code>,
        /// <code>GL_SRGB8</code>,
        /// <code>GL_SRGB_ALPHA</code>, or 
        /// <code>GL_SRGB8_ALPHA8</code>.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// Specifies the width of the texture image including the border if any. If the GL version does not support non-power-of-two sizes, this value must be 
        /// 2 
        /// n 
        /// + 
        /// 2 
        /// &af; 
        /// border 
        /// for some integer 
        /// n   .
        /// All
        /// implementations support texture images that are at least 64 texels
        /// wide. The height of the 1D texture image is 1.
        /// </para>
        /// </param>
        /// <param name="border">
        /// <para>
        /// Specifies the width of the border.
        /// Must be either 0 or 1.
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// Specifies the format of the pixel data.
        /// The following symbolic values are accepted:
        /// <code>GL_COLOR_INDEX</code>,
        /// <code>GL_RED</code>,
        /// <code>GL_GREEN</code>,
        /// <code>GL_BLUE</code>,
        /// <code>GL_ALPHA</code>,
        /// <code>GL_RGB</code>,
        /// <code>GL_BGR</code>,
        /// <code>GL_RGBA</code>,
        /// <code>GL_BGRA</code>,
        /// <code>GL_LUMINANCE</code>, and
        /// <code>GL_LUMINANCE_ALPHA</code>.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the data type of the pixel data.
        /// The following symbolic values are accepted:
        /// <code>GL_UNSIGNED_BYTE</code>,
        /// <code>GL_BYTE</code>,
        /// <code>GL_BITMAP</code>,
        /// <code>GL_UNSIGNED_SHORT</code>,
        /// <code>GL_SHORT</code>,
        /// <code>GL_UNSIGNED_INT</code>,
        /// <code>GL_INT</code>,
        /// <code>GL_FLOAT</code>,
        /// <code>GL_UNSIGNED_BYTE_3_3_2</code>,
        /// <code>GL_UNSIGNED_BYTE_2_3_3_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_5_6_5</code>,
        /// <code>GL_UNSIGNED_SHORT_5_6_5_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_4_4_4_4</code>,
        /// <code>GL_UNSIGNED_SHORT_4_4_4_4_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_5_5_5_1</code>,
        /// <code>GL_UNSIGNED_SHORT_1_5_5_5_REV</code>,
        /// <code>GL_UNSIGNED_INT_8_8_8_8</code>,
        /// <code>GL_UNSIGNED_INT_8_8_8_8_REV</code>,
        /// <code>GL_UNSIGNED_INT_10_10_10_2</code>, and
        /// <code>GL_UNSIGNED_INT_2_10_10_10_REV</code>.
        /// </para>
        /// </param>
        /// <param name="data">
        /// Specifies a pointer to the image data in memory.
        /// </param>
        /// <seealso cref="glActiveTexture"/>
        /// <seealso cref="glColorTable"/>
        /// <seealso cref="glCompressedTexImage1D"/>
        /// <seealso cref="glCompressedTexSubImage1D"/>
        /// <seealso cref="glConvolutionFilter1D"/>
        /// <seealso cref="glCopyPixels"/>
        /// <seealso cref="glCopyTexImage1D"/>
        /// <seealso cref="glCopyTexSubImage1D"/>
        /// <seealso cref="glDrawPixels"/>
        /// <seealso cref="glGetCompressedTexImage"/>
        /// <seealso cref="glMatrixMode"/>
        /// <seealso cref="glPixelStore"/>
        /// <seealso cref="glPixelTransfer"/>
        /// <seealso cref="glTexEnv"/>
        /// <seealso cref="glTexGen"/>
        /// <seealso cref="glTexImage2D"/>
        /// <seealso cref="glTexImage3D"/>
        /// <seealso cref="glTexSubImage1D"/>
        /// <seealso cref="glTexSubImage2D"/>
        /// <seealso cref="glTexSubImage3D"/>
        /// <seealso cref="glTexParameter"/>
        public unsafe static void glTexImage1D(uint target, int level, int internalFormat, int width, int border, uint format, uint type, void* data) {
            var _F = _GetProc<GLNativeDelegate.FNglTexImage1D>("glTexImage1D");
            _F(target, level, internalFormat, width, border, format, type, data);
        }
        /// <summary>
        /// specify a two-dimensional texture image
        /// <para>Require:</para> <para>GL_VERSION_1_0, GL_VERSION_ES_CM_1_0, GL_ES_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// Texturing has no effect in color index mode.
        /// If the <code>ARB_imaging</code> extension is supported, RGBA elements may
        /// also be processed by the imaging pipeline.  The following stages may be
        /// applied to an RGBA color before color component clamping to the range
        /// 0 
        /// 1 
        /// :
        /// 1. Color component replacement by the color table specified for 
        /// <code>GL_COLOR_TABLE</code>, if enabled. See  <see cref="glColorTable"/> .
        /// 2. Two-dimensional Convolution filtering, if enabled. 
        /// See  <see cref="glConvolutionFilter1D"/> .
        /// If a convolution filter changes the <paramref name="width"/> of the texture (by
        /// processing with a <code>GL_CONVOLUTION_BORDER_MODE</code> of <code>GL_REDUCE</code>, for
        /// example), and the GL does not support non-power-of-two textures, the <paramref name="width"/> must 
        /// 2 
        /// n 
        /// + 
        /// 2 
        /// &af; 
        /// border 
        /// ,
        /// for some
        /// integer 
        /// n   ,
        /// and <paramref name="height"/> must be 
        /// 2 
        /// m 
        /// + 
        /// 2 
        /// &af; 
        /// border 
        /// ,
        /// for some
        /// integer 
        /// m   ,
        /// after filtering.
        /// 3. RGBA components may be multiplied by <code>GL_POST_CONVOLUTION_c_SCALE</code>, 
        /// and added to <code>GL_POST_CONVOLUTION_c_BIAS</code>, if enabled.  See
        /// <see cref="glPixelTransfer"/> .
        /// 4. Color component replacement by the color table specified for 
        /// <code>GL_POST_CONVOLUTION_COLOR_TABLE</code>, if enabled.  See  <see cref="glColorTable"/> .
        /// 5. Transformation by the color matrix. 
        /// See  <see cref="glMatrixMode"/> .
        /// 6. RGBA components may be multiplied by <code>GL_POST_COLOR_MATRIX_c_SCALE</code>, 
        /// and added to <code>GL_POST_COLOR_MATRIX_c_BIAS</code>, if enabled.  See
        /// <see cref="glPixelTransfer"/> .
        /// 7. Color component replacement by the color table specified for 
        /// <code>GL_POST_COLOR_MATRIX_COLOR_TABLE</code>, if enabled.  See  <see cref="glColorTable"/> .
        /// The texture image can be represented by the same data formats
        /// as the pixels in a  <see cref="glDrawPixels"/>  command,
        /// except that <code>GL_STENCIL_INDEX</code>
        /// cannot be used.
        /// <see cref="glPixelStore"/>  and  <see cref="glPixelTransfer"/>  modes affect texture images
        /// in exactly the way they affect  <see cref="glDrawPixels"/> .
        /// <see cref="glTexImage2D"/> and <code>GL_PROXY_TEXTURE_2D</code> are available only if the GL
        /// version is 1.1 or greater.
        /// Internal formats other than 1, 2, 3, or 4 may be used only if the GL
        /// version is 1.1 or greater.
        /// In GL version 1.1 or greater, <paramref name="data"/> may be a null pointer.
        /// In this case, texture memory is
        /// allocated to accommodate a texture of width <paramref name="width"/> and height <paramref name="height"/>.
        /// You can then download subtextures to initialize this
        /// texture memory.
        /// The image is undefined if the user tries to apply
        /// an uninitialized portion of the texture image to a primitive.
        /// Formats <code>GL_BGR</code>, and <code>GL_BGRA</code> and types
        /// <code>GL_UNSIGNED_BYTE_3_3_2</code>,
        /// <code>GL_UNSIGNED_BYTE_2_3_3_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_5_6_5</code>,
        /// <code>GL_UNSIGNED_SHORT_5_6_5_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_4_4_4_4</code>,
        /// <code>GL_UNSIGNED_SHORT_4_4_4_4_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_5_5_5_1</code>,
        /// <code>GL_UNSIGNED_SHORT_1_5_5_5_REV</code>,
        /// <code>GL_UNSIGNED_INT_8_8_8_8</code>,
        /// <code>GL_UNSIGNED_INT_8_8_8_8_REV</code>,
        /// <code>GL_UNSIGNED_INT_10_10_10_2</code>, and
        /// <code>GL_UNSIGNED_INT_2_10_10_10_REV</code> are available only if the GL version
        /// is 1.2 or greater.
        /// When the <code>ARB_multitexture</code> extension is supported or the GL version is 1.3 or greater, <see cref="glTexImage2D"/>
        /// specifies the two-dimensional texture for the current texture unit,
        /// specified with  <see cref="glActiveTexture"/> .
        /// <code>GL_TEXTURE_CUBE_MAP</code> and <code>GL_PROXY_TEXTURE_CUBE_MAP</code> are available only if the GL
        /// version is 1.3 or greater.
        /// <code>GL_DEPTH_COMPONENT</code>, <code>GL_DEPTH_COMPONENT16</code>,
        /// <code>GL_DEPTH_COMPONENT24</code>, and <code>GL_DEPTH_COMPONENT32</code> are available only
        /// if the GL version is 1.4 or greater.
        /// Non-power-of-two textures are supported if the GL version is 2.0 or greater, or if the implementation exports the <code>GL_ARB_texture_non_power_of_two</code> extension.
        /// The 
        /// <code>GL_SRGB</code>,
        /// <code>GL_SRGB8</code>,
        /// <code>GL_SRGB_ALPHA</code>,
        /// <code>GL_SRGB8_ALPHA8</code>,
        /// <code>GL_SLUMINANCE</code>,
        /// <code>GL_SLUMINANCE8</code>,
        /// <code>GL_SLUMINANCE_ALPHA</code>, and
        /// <code>GL_SLUMINANCE8_ALPHA8</code>
        /// internal formats are only available if the GL version is 2.1 or greater.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="target"/> is not <code>GL_TEXTURE_2D</code>,
        /// <code>GL_PROXY_TEXTURE_2D</code>,
        /// <code>GL_PROXY_TEXTURE_CUBE_MAP</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_POSITIVE_X</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_NEGATIVE_X</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_POSITIVE_Y</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_NEGATIVE_Y</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_POSITIVE_Z</code>, or 
        /// <code>GL_TEXTURE_CUBE_MAP_NEGATIVE_Z</code>.
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="target"/> is one of the six cube map 2D image targets and the width and height parameters are not equal.
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="type"/> is not a type constant.
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="type"/> is <code>GL_BITMAP</code> and
        /// <paramref name="format"/> is not <code>GL_COLOR_INDEX</code>.
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="width"/> or <paramref name="height"/> is less than 0
        /// or greater than 2 + <code>GL_MAX_TEXTURE_SIZE</code>.
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="level"/> is less than 0.
        /// <code>GL_INVALID_VALUE</code> may be generated if <paramref name="level"/> is greater than 
        /// log 
        /// 2 
        /// &af; 
        /// max 
        /// ,
        /// where  max  is the returned value of <code>GL_MAX_TEXTURE_SIZE</code>.
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="internalFormat"/> is not 1, 2, 3, 4, or one of the
        /// accepted resolution and format symbolic constants.
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="width"/> or <paramref name="height"/> is less than 0
        /// or greater than 2 + <code>GL_MAX_TEXTURE_SIZE</code>.
        /// <code>GL_INVALID_VALUE</code> is generated if non-power-of-two textures are not supported and the <paramref name="width"/> or <paramref name="height"/> cannot be represented as 
        /// 2 
        /// k 
        /// + 
        /// 2 
        /// &af; 
        /// border 
        /// for some
        /// integer value of  k .
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="border"/> is not 0 or 1.
        /// <code>GL_INVALID_OPERATION</code> is generated if <paramref name="type"/> is one of
        /// <code>GL_UNSIGNED_BYTE_3_3_2</code>,
        /// <code>GL_UNSIGNED_BYTE_2_3_3_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_5_6_5</code>, or
        /// <code>GL_UNSIGNED_SHORT_5_6_5_REV</code>
        /// and <paramref name="format"/> is not <code>GL_RGB</code>.
        /// <code>GL_INVALID_OPERATION</code> is generated if <paramref name="type"/> is one of
        /// <code>GL_UNSIGNED_SHORT_4_4_4_4</code>,
        /// <code>GL_UNSIGNED_SHORT_4_4_4_4_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_5_5_5_1</code>,
        /// <code>GL_UNSIGNED_SHORT_1_5_5_5_REV</code>,
        /// <code>GL_UNSIGNED_INT_8_8_8_8</code>,
        /// <code>GL_UNSIGNED_INT_8_8_8_8_REV</code>,
        /// <code>GL_UNSIGNED_INT_10_10_10_2</code>, or
        /// <code>GL_UNSIGNED_INT_2_10_10_10_REV</code>
        /// and <paramref name="format"/> is neither <code>GL_RGBA</code> nor <code>GL_BGRA</code>.
        /// <code>GL_INVALID_OPERATION</code> is generated if <paramref name="target"/> is not
        /// <code>GL_TEXTURE_2D</code> or <code>GL_PROXY_TEXTURE_2D</code> and <paramref name="internalFormat"/> is
        /// <code>GL_DEPTH_COMPONENT</code>, <code>GL_DEPTH_COMPONENT16</code>,
        /// <code>GL_DEPTH_COMPONENT24</code>, or <code>GL_DEPTH_COMPONENT32</code>.
        /// <code>GL_INVALID_OPERATION</code> is generated if <paramref name="format"/> is
        /// <code>GL_DEPTH_COMPONENT</code> and <paramref name="internalFormat"/> is not
        /// <code>GL_DEPTH_COMPONENT</code>, <code>GL_DEPTH_COMPONENT16</code>,
        /// <code>GL_DEPTH_COMPONENT24</code>, or <code>GL_DEPTH_COMPONENT32</code>.
        /// <code>GL_INVALID_OPERATION</code> is generated if <paramref name="internalFormat"/> is
        /// <code>GL_DEPTH_COMPONENT</code>, <code>GL_DEPTH_COMPONENT16</code>,
        /// <code>GL_DEPTH_COMPONENT24</code>, or <code>GL_DEPTH_COMPONENT32</code>, and <paramref name="format"/> is
        /// not <code>GL_DEPTH_COMPONENT</code>.
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_UNPACK_BUFFER</code> target and the buffer object's data store is currently mapped.
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_UNPACK_BUFFER</code> target and the data would be unpacked from the buffer 
        /// object such that the memory reads required would exceed the data store size.
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_UNPACK_BUFFER</code> target and <paramref name="data"/> is not evenly divisible 
        /// into the number of bytes needed to store in memory a datum indicated by <paramref name="type"/>.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glTexImage2D"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glTexImage2D(GLenum target, GLint level, GLint internalFormat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const void * data);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target texture.
        /// Must be <code>GL_TEXTURE_2D</code>, <code>GL_PROXY_TEXTURE_2D</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_POSITIVE_X</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_NEGATIVE_X</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_POSITIVE_Y</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_NEGATIVE_Y</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_POSITIVE_Z</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_NEGATIVE_Z</code>, or
        /// <code>GL_PROXY_TEXTURE_CUBE_MAP</code>.
        /// </para>
        /// </param>
        /// <param name="level">
        /// <para>
        /// Specifies the level-of-detail number.
        /// Level 0 is the base image level.
        /// Level  n  is the  n th mipmap reduction image.
        /// </para>
        /// </param>
        /// <param name="internalFormat">
        /// <para>
        /// Specifies the number of color components in the texture.
        /// Must be 1, 2, 3, or 4, or one of the following symbolic constants:
        /// <code>GL_ALPHA</code>,
        /// <code>GL_ALPHA4</code>,
        /// <code>GL_ALPHA8</code>,
        /// <code>GL_ALPHA12</code>,
        /// <code>GL_ALPHA16</code>,
        /// <code>GL_COMPRESSED_ALPHA</code>,
        /// <code>GL_COMPRESSED_LUMINANCE</code>,
        /// <code>GL_COMPRESSED_LUMINANCE_ALPHA</code>,
        /// <code>GL_COMPRESSED_INTENSITY</code>,
        /// <code>GL_COMPRESSED_RGB</code>,
        /// <code>GL_COMPRESSED_RGBA</code>,
        /// <code>GL_DEPTH_COMPONENT</code>,
        /// <code>GL_DEPTH_COMPONENT16</code>,
        /// <code>GL_DEPTH_COMPONENT24</code>,
        /// <code>GL_DEPTH_COMPONENT32</code>,
        /// <code>GL_LUMINANCE</code>,
        /// <code>GL_LUMINANCE4</code>,
        /// <code>GL_LUMINANCE8</code>,
        /// <code>GL_LUMINANCE12</code>,
        /// <code>GL_LUMINANCE16</code>,
        /// <code>GL_LUMINANCE_ALPHA</code>,
        /// <code>GL_LUMINANCE4_ALPHA4</code>,
        /// <code>GL_LUMINANCE6_ALPHA2</code>,
        /// <code>GL_LUMINANCE8_ALPHA8</code>,
        /// <code>GL_LUMINANCE12_ALPHA4</code>,
        /// <code>GL_LUMINANCE12_ALPHA12</code>,
        /// <code>GL_LUMINANCE16_ALPHA16</code>,
        /// <code>GL_INTENSITY</code>,
        /// <code>GL_INTENSITY4</code>,
        /// <code>GL_INTENSITY8</code>,
        /// <code>GL_INTENSITY12</code>,
        /// <code>GL_INTENSITY16</code>,
        /// <code>GL_R3_G3_B2</code>,
        /// <code>GL_RGB</code>,
        /// <code>GL_RGB4</code>,
        /// <code>GL_RGB5</code>,
        /// <code>GL_RGB8</code>,
        /// <code>GL_RGB10</code>,
        /// <code>GL_RGB12</code>,
        /// <code>GL_RGB16</code>,
        /// <code>GL_RGBA</code>,
        /// <code>GL_RGBA2</code>,
        /// <code>GL_RGBA4</code>,
        /// <code>GL_RGB5_A1</code>,
        /// <code>GL_RGBA8</code>,
        /// <code>GL_RGB10_A2</code>,
        /// <code>GL_RGBA12</code>,
        /// <code>GL_RGBA16</code>,
        /// <code>GL_SLUMINANCE</code>,
        /// <code>GL_SLUMINANCE8</code>,
        /// <code>GL_SLUMINANCE_ALPHA</code>,
        /// <code>GL_SLUMINANCE8_ALPHA8</code>,
        /// <code>GL_SRGB</code>,
        /// <code>GL_SRGB8</code>,
        /// <code>GL_SRGB_ALPHA</code>, or 
        /// <code>GL_SRGB8_ALPHA8</code>.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// Specifies the width of the texture image including the border if any. If the GL version does not support non-power-of-two sizes, this value must be 
        /// 2 
        /// n 
        /// + 
        /// 2 
        /// &af; 
        /// border 
        /// for some integer 
        /// n   .
        /// All
        /// implementations support texture images that are at least 64 texels
        /// wide.
        /// </para>
        /// </param>
        /// <param name="height">
        /// <para>
        /// Specifies the height of the texture image including the border if any. If the GL version does not support non-power-of-two sizes, this value must be 
        /// 2 
        /// m 
        /// + 
        /// 2 
        /// &af; 
        /// border 
        /// for some integer 
        /// m   .
        /// All
        /// implementations support texture images that are at least 64 texels
        /// high.
        /// </para>
        /// </param>
        /// <param name="border">
        /// <para>
        /// Specifies the width of the border.
        /// Must be either 0 or 1.
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// Specifies the format of the pixel data.
        /// The following symbolic values are accepted:
        /// <code>GL_COLOR_INDEX</code>,
        /// <code>GL_RED</code>,
        /// <code>GL_GREEN</code>,
        /// <code>GL_BLUE</code>,
        /// <code>GL_ALPHA</code>,
        /// <code>GL_RGB</code>,
        /// <code>GL_BGR</code>,
        /// <code>GL_RGBA</code>,
        /// <code>GL_BGRA</code>,
        /// <code>GL_LUMINANCE</code>, and
        /// <code>GL_LUMINANCE_ALPHA</code>.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the data type of the pixel data.
        /// The following symbolic values are accepted:
        /// <code>GL_UNSIGNED_BYTE</code>,
        /// <code>GL_BYTE</code>,
        /// <code>GL_BITMAP</code>,
        /// <code>GL_UNSIGNED_SHORT</code>,
        /// <code>GL_SHORT</code>,
        /// <code>GL_UNSIGNED_INT</code>,
        /// <code>GL_INT</code>,
        /// <code>GL_FLOAT</code>,
        /// <code>GL_UNSIGNED_BYTE_3_3_2</code>,
        /// <code>GL_UNSIGNED_BYTE_2_3_3_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_5_6_5</code>,
        /// <code>GL_UNSIGNED_SHORT_5_6_5_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_4_4_4_4</code>,
        /// <code>GL_UNSIGNED_SHORT_4_4_4_4_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_5_5_5_1</code>,
        /// <code>GL_UNSIGNED_SHORT_1_5_5_5_REV</code>,
        /// <code>GL_UNSIGNED_INT_8_8_8_8</code>,
        /// <code>GL_UNSIGNED_INT_8_8_8_8_REV</code>,
        /// <code>GL_UNSIGNED_INT_10_10_10_2</code>, and
        /// <code>GL_UNSIGNED_INT_2_10_10_10_REV</code>.
        /// </para>
        /// </param>
        /// <param name="data">
        /// Specifies a pointer to the image data in memory.
        /// </param>
        /// <seealso cref="glActiveTexture"/>
        /// <seealso cref="glColorTable"/>
        /// <seealso cref="glConvolutionFilter2D"/>
        /// <seealso cref="glCopyPixels"/>
        /// <seealso cref="glCopyTexImage1D"/>
        /// <seealso cref="glCopyTexImage2D"/>
        /// <seealso cref="glCopyTexSubImage1D"/>
        /// <seealso cref="glCopyTexSubImage2D"/>
        /// <seealso cref="glCopyTexSubImage3D"/>
        /// <seealso cref="glDrawPixels"/>
        /// <seealso cref="glMatrixMode"/>
        /// <seealso cref="glPixelStore"/>
        /// <seealso cref="glPixelTransfer"/>
        /// <seealso cref="glSeparableFilter2D"/>
        /// <seealso cref="glTexEnv"/>
        /// <seealso cref="glTexGen"/>
        /// <seealso cref="glTexImage1D"/>
        /// <seealso cref="glTexImage3D"/>
        /// <seealso cref="glTexSubImage1D"/>
        /// <seealso cref="glTexSubImage2D"/>
        /// <seealso cref="glTexSubImage3D"/>
        /// <seealso cref="glTexParameter"/>
        public unsafe static void glTexImage2D(uint target, int level, int internalFormat, int width, int height, int border, uint format, uint type, void* data) {
            var _F = _GetProc<GLNativeDelegate.FNglTexImage2D>("glTexImage2D");
            _F(target, level, internalFormat, width, height, border, format, type, data);
        }
        /// <summary>
        /// specify which color buffers are to be drawn into
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// It is always the case that <code>GL_AUX</code>
        /// i   
        /// = <code>GL_AUX0</code> + 
        /// i   .
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="mode"/> is not an accepted value.
        /// <code>GL_INVALID_OPERATION</code> is generated if none of the buffers indicated
        /// by <paramref name="mode"/> exists.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glDrawBuffer"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glDrawBuffer(GLenum mode);</para>
        /// </summary>
        /// <param name="mode">
        /// <para>
        /// Specifies up to four color buffers to be drawn into.
        /// Symbolic constants
        /// <code>GL_NONE</code>,
        /// <code>GL_FRONT_LEFT</code>,
        /// <code>GL_FRONT_RIGHT</code>,
        /// <code>GL_BACK_LEFT</code>,
        /// <code>GL_BACK_RIGHT</code>,
        /// <code>GL_FRONT</code>,
        /// <code>GL_BACK</code>,
        /// <code>GL_LEFT</code>,
        /// <code>GL_RIGHT</code>,
        /// <code>GL_FRONT_AND_BACK</code>, and
        /// <code>GL_AUX</code> i ,
        /// where  i  is between 0 and the value of <code>GL_AUX_BUFFERS</code> minus 1,
        /// are accepted.  (<code>GL_AUX_BUFFERS</code> is not the upper limit; use  <see cref="glGet"/> 
        /// to query the number of available aux buffers.)
        /// The initial value is <code>GL_FRONT</code> for single-buffered contexts,
        /// and <code>GL_BACK</code> for double-buffered contexts.
        /// </para>
        /// </param>
        /// <seealso cref="glBlendFunc"/>
        /// <seealso cref="glColorMask"/>
        /// <seealso cref="glIndexMask"/>
        /// <seealso cref="glLogicOp"/>
        /// <seealso cref="glReadBuffer"/>
        public static void glDrawBuffer(uint mode) {
            var _F = _GetProc<GLNativeDelegate.FNglDrawBuffer>("glDrawBuffer");
            _F(mode);
        }
        /// <summary>
        /// clear buffers to preset values
        /// <para>Require:</para> <para>GL_VERSION_1_0, GL_VERSION_ES_CM_1_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// If a buffer is not present,
        /// then a <see cref="glClear"/> directed at that buffer has no effect.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if any bit other than the four defined
        /// bits is set in <paramref name="mask"/>.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glClear"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glClear(GLbitfield mask);</para>
        /// </summary>
        /// <param name="mask">
        /// <para>
        /// Bitwise OR of masks that indicate the buffers to be cleared.
        /// The four masks are
        /// <code>GL_COLOR_BUFFER_BIT</code>,
        /// <code>GL_DEPTH_BUFFER_BIT</code>,
        /// <code>GL_ACCUM_BUFFER_BIT</code>, and
        /// <code>GL_STENCIL_BUFFER_BIT</code>.
        /// </para>
        /// </param>
        /// <seealso cref="glClearAccum"/>
        /// <seealso cref="glClearColor"/>
        /// <seealso cref="glClearDepth"/>
        /// <seealso cref="glClearIndex"/>
        /// <seealso cref="glClearStencil"/>
        /// <seealso cref="glColorMask"/>
        /// <seealso cref="glDepthMask"/>
        /// <seealso cref="glDrawBuffer"/>
        /// <seealso cref="glScissor"/>
        /// <seealso cref="glStencilMask"/>
        public static void glClear(uint mask) {
            var _F = _GetProc<GLNativeDelegate.FNglClear>("glClear");
            _F(mask);
        }
        /// <summary>
        /// specify clear values for the color buffers
        /// <para>Require:</para> <para>GL_VERSION_1_0, GL_VERSION_ES_CM_1_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glClearColor"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glClearColor(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha);</para>
        /// </summary>
        /// <param name="red">
        /// <para>
        /// Specify the red, green, blue, and alpha values used when the
        /// color buffers are cleared.
        /// The initial values are all 0.
        /// </para>
        /// </param>
        /// <param name="green">
        /// <para>
        /// Specify the red, green, blue, and alpha values used when the
        /// color buffers are cleared.
        /// The initial values are all 0.
        /// </para>
        /// </param>
        /// <param name="blue">
        /// <para>
        /// Specify the red, green, blue, and alpha values used when the
        /// color buffers are cleared.
        /// The initial values are all 0.
        /// </para>
        /// </param>
        /// <param name="alpha">
        /// <para>
        /// Specify the red, green, blue, and alpha values used when the
        /// color buffers are cleared.
        /// The initial values are all 0.
        /// </para>
        /// </param>
        /// <seealso cref="glClear"/>
        public static void glClearColor(float red, float green, float blue, float alpha) {
            var _F = _GetProc<GLNativeDelegate.FNglClearColor>("glClearColor");
            _F(red, green, blue, alpha);
        }
        /// <summary>
        /// specify the clear value for the stencil buffer
        /// <para>Require:</para> <para>GL_VERSION_1_0, GL_VERSION_ES_CM_1_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glClearStencil"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glClearStencil(GLint s);</para>
        /// </summary>
        /// <param name="s">
        /// <para>
        /// Specifies the index used when the stencil buffer is cleared.
        /// The initial value is 0.
        /// </para>
        /// </param>
        /// <seealso cref="glClear"/>
        /// <seealso cref="glStencilFunc"/>
        /// <seealso cref="glStencilFuncSeparate"/>
        /// <seealso cref="glStencilMask"/>
        /// <seealso cref="glStencilMaskSeparate"/>
        /// <seealso cref="glStencilOp"/>
        /// <seealso cref="glStencilOpSeparate"/>
        public static void glClearStencil(int s) {
            var _F = _GetProc<GLNativeDelegate.FNglClearStencil>("glClearStencil");
            _F(s);
        }
        /// <summary>
        /// specify the clear value for the depth buffer
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glClearDepth"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glClearDepth(GLclampd depth);</para>
        /// </summary>
        /// <param name="depth">
        /// <para>
        /// Specifies the depth value used when the depth buffer is cleared. The
        /// initial value is 1.
        /// </para>
        /// </param>
        /// <seealso cref="glClear"/>
        public static void glClearDepth(double depth) {
            var _F = _GetProc<GLNativeDelegate.FNglClearDepth>("glClearDepth");
            _F(depth);
        }
        /// <summary>
        /// control the front and back writing of individual bits in the stencil planes
        /// <para>Require:</para> <para>GL_VERSION_1_0, GL_VERSION_ES_CM_1_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glStencilMask"/>  is the same as
        /// calling  <see cref="glStencilMaskSeparate"/> 
        /// with <paramref name="face"/> set to <code>GL_FRONT_AND_BACK</code>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glStencilMask"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glStencilMask(GLuint mask);</para>
        /// </summary>
        /// <param name="mask">
        /// <para>
        /// Specifies a bit mask to enable and disable writing of individual bits
        /// in the stencil planes.
        /// Initially, the mask is all 1's.
        /// </para>
        /// </param>
        /// <seealso cref="glColorMask"/>
        /// <seealso cref="glDepthMask"/>
        /// <seealso cref="glIndexMask"/>
        /// <seealso cref="glStencilFunc"/>
        /// <seealso cref="glStencilFuncSeparate"/>
        /// <seealso cref="glStencilMaskSeparate"/>
        /// <seealso cref="glStencilOp"/>
        /// <seealso cref="glStencilOpSeparate"/>
        public static void glStencilMask(uint mask) {
            var _F = _GetProc<GLNativeDelegate.FNglStencilMask>("glStencilMask");
            _F(mask);
        }
        /// <summary>
        /// enable and disable writing of frame buffer color components
        /// <para>Require:</para> <para>GL_VERSION_1_0, GL_VERSION_ES_CM_1_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glColorMask"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glColorMask(GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha);</para>
        /// </summary>
        /// <param name="red">
        /// <para>
        /// Specify whether red, green, blue, and alpha can or cannot be written
        /// into the frame buffer.
        /// The initial values are all <code>GL_TRUE</code>,
        /// indicating that the color components can be written.
        /// </para>
        /// </param>
        /// <param name="green">
        /// <para>
        /// Specify whether red, green, blue, and alpha can or cannot be written
        /// into the frame buffer.
        /// The initial values are all <code>GL_TRUE</code>,
        /// indicating that the color components can be written.
        /// </para>
        /// </param>
        /// <param name="blue">
        /// <para>
        /// Specify whether red, green, blue, and alpha can or cannot be written
        /// into the frame buffer.
        /// The initial values are all <code>GL_TRUE</code>,
        /// indicating that the color components can be written.
        /// </para>
        /// </param>
        /// <param name="alpha">
        /// <para>
        /// Specify whether red, green, blue, and alpha can or cannot be written
        /// into the frame buffer.
        /// The initial values are all <code>GL_TRUE</code>,
        /// indicating that the color components can be written.
        /// </para>
        /// </param>
        /// <seealso cref="glClear"/>
        /// <seealso cref="glColor"/>
        /// <seealso cref="glColorPointer"/>
        /// <seealso cref="glDepthMask"/>
        /// <seealso cref="glIndex"/>
        /// <seealso cref="glIndexPointer"/>
        /// <seealso cref="glIndexMask"/>
        /// <seealso cref="glStencilMask"/>
        public static void glColorMask(bool red, bool green, bool blue, bool alpha) {
            var _F = _GetProc<GLNativeDelegate.FNglColorMask>("glColorMask");
            _F(red, green, blue, alpha);
        }
        /// <summary>
        /// enable or disable writing into the depth buffer
        /// <para>Require:</para> <para>GL_VERSION_1_0, GL_VERSION_ES_CM_1_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glDepthMask"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glDepthMask(GLboolean flag);</para>
        /// </summary>
        /// <param name="flag">
        /// <para>
        /// Specifies whether the depth buffer is enabled for writing.
        /// If <paramref name="flag"/> is <code>GL_FALSE</code>,
        /// depth buffer writing is disabled.
        /// Otherwise, it is enabled.
        /// Initially, depth buffer writing is enabled.
        /// </para>
        /// </param>
        /// <seealso cref="glColorMask"/>
        /// <seealso cref="glDepthFunc"/>
        /// <seealso cref="glDepthRange"/>
        /// <seealso cref="glIndexMask"/>
        /// <seealso cref="glStencilMask"/>
        public static void glDepthMask(bool flag) {
            var _F = _GetProc<GLNativeDelegate.FNglDepthMask>("glDepthMask");
            _F(flag);
        }
        /// <summary>
        /// enable or disable server-side GL capabilities
        /// <para>Require:</para> <para>GL_VERSION_1_0, GL_VERSION_ES_CM_1_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <code>GL_POLYGON_OFFSET_FILL</code>, <code>GL_POLYGON_OFFSET_LINE</code>,
        /// <code>GL_POLYGON_OFFSET_POINT</code>,
        /// <code>GL_COLOR_LOGIC_OP</code>, and <code>GL_INDEX_LOGIC_OP</code> are available
        /// only if the GL version is 1.1 or greater.
        /// <code>GL_RESCALE_NORMAL</code>, and <code>GL_TEXTURE_3D</code> are available only if the
        /// GL version is 1.2 or greater.
        /// <code>GL_MULTISAMPLE</code>,
        /// <code>GL_SAMPLE_ALPHA_TO_COVERAGE</code>,
        /// <code>GL_SAMPLE_ALPHA_TO_ONE</code>,
        /// <code>GL_SAMPLE_COVERAGE</code>,
        /// <code>GL_TEXTURE_CUBE_MAP</code>
        /// are available only if the GL version is 1.3 or greater.
        /// <code>GL_POINT_SPRITE</code>,
        /// <code>GL_VERTEX_PROGRAM_POINT_SIZE</code>, and
        /// <code>GL_VERTEX_PROGRAM_TWO_SIDE</code>
        /// is available only if the GL version is 2.0 or greater.
        /// <code>GL_COLOR_TABLE</code>, <code>GL_CONVOLUTION_1D</code>, <code>GL_CONVOLUTION_2D</code>,
        /// <code>GL_HISTOGRAM</code>, <code>GL_MINMAX</code>,
        /// <code>GL_POST_COLOR_MATRIX_COLOR_TABLE</code>,
        /// <code>GL_POST_CONVOLUTION_COLOR_TABLE</code>, and
        /// <code>GL_SEPARABLE_2D</code> are available only if <code>ARB_imaging</code> is returned
        /// from  <see cref="glGet"/>  with an argument of <code>GL_EXTENSIONS</code>.
        /// For OpenGL versions 1.3 and greater, or when <code>ARB_multitexture</code> is supported, <code>GL_TEXTURE_1D</code>,
        /// <code>GL_TEXTURE_2D</code>, <code>GL_TEXTURE_3D</code>, <code>GL_TEXTURE_GEN_S</code>,
        /// <code>GL_TEXTURE_GEN_T</code>, <code>GL_TEXTURE_GEN_R</code>, and <code>GL_TEXTURE_GEN_Q</code>
        /// enable or disable the respective state for the active texture unit
        /// specified with  <see cref="glActiveTexture"/> .
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="cap"/> is not one of the values
        /// listed previously.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glEnable"/> or  <see cref="glDisable"/> 
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glDisable(GLenum cap);</para>
        /// </summary>
        /// <param name="cap">
        /// Specifies a symbolic constant indicating a GL capability.
        /// </param>
        /// <seealso cref="glActiveTexture"/>
        /// <seealso cref="glAlphaFunc"/>
        /// <seealso cref="glBlendFunc"/>
        /// <seealso cref="glClipPlane"/>
        /// <seealso cref="glColorMaterial"/>
        /// <seealso cref="glCullFace"/>
        /// <seealso cref="glDepthFunc"/>
        /// <seealso cref="glDepthRange"/>
        /// <seealso cref="glEnableClientState"/>
        /// <seealso cref="glFog"/>
        /// <seealso cref="glGet"/>
        /// <seealso cref="glIsEnabled"/>
        /// <seealso cref="glLight"/>
        /// <seealso cref="glLightModel"/>
        /// <seealso cref="glLineWidth"/>
        /// <seealso cref="glLineStipple"/>
        /// <seealso cref="glLogicOp"/>
        /// <seealso cref="glMap1"/>
        /// <seealso cref="glMap2"/>
        /// <seealso cref="glMaterial"/>
        /// <seealso cref="glNormal"/>
        /// <seealso cref="glNormalPointer"/>
        /// <seealso cref="glPointSize"/>
        /// <seealso cref="glPolygonMode"/>
        /// <seealso cref="glPolygonOffset"/>
        /// <seealso cref="glPolygonStipple"/>
        /// <seealso cref="glSampleCoverage"/>
        /// <seealso cref="glScissor"/>
        /// <seealso cref="glStencilFunc"/>
        /// <seealso cref="glStencilOp"/>
        /// <seealso cref="glTexGen"/>
        /// <seealso cref="glTexImage1D"/>
        /// <seealso cref="glTexImage2D"/>
        /// <seealso cref="glTexImage3D"/>
        public static void glDisable(uint cap) {
            var _F = _GetProc<GLNativeDelegate.FNglDisable>("glDisable");
            _F(cap);
        }
        /// <summary>
        /// enable or disable server-side GL capabilities
        /// <para>Require:</para> <para>GL_VERSION_1_0, GL_VERSION_ES_CM_1_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <code>GL_POLYGON_OFFSET_FILL</code>, <code>GL_POLYGON_OFFSET_LINE</code>,
        /// <code>GL_POLYGON_OFFSET_POINT</code>,
        /// <code>GL_COLOR_LOGIC_OP</code>, and <code>GL_INDEX_LOGIC_OP</code> are available
        /// only if the GL version is 1.1 or greater.
        /// <code>GL_RESCALE_NORMAL</code>, and <code>GL_TEXTURE_3D</code> are available only if the
        /// GL version is 1.2 or greater.
        /// <code>GL_MULTISAMPLE</code>,
        /// <code>GL_SAMPLE_ALPHA_TO_COVERAGE</code>,
        /// <code>GL_SAMPLE_ALPHA_TO_ONE</code>,
        /// <code>GL_SAMPLE_COVERAGE</code>,
        /// <code>GL_TEXTURE_CUBE_MAP</code>
        /// are available only if the GL version is 1.3 or greater.
        /// <code>GL_POINT_SPRITE</code>,
        /// <code>GL_VERTEX_PROGRAM_POINT_SIZE</code>, and
        /// <code>GL_VERTEX_PROGRAM_TWO_SIDE</code>
        /// is available only if the GL version is 2.0 or greater.
        /// <code>GL_COLOR_TABLE</code>, <code>GL_CONVOLUTION_1D</code>, <code>GL_CONVOLUTION_2D</code>,
        /// <code>GL_HISTOGRAM</code>, <code>GL_MINMAX</code>,
        /// <code>GL_POST_COLOR_MATRIX_COLOR_TABLE</code>,
        /// <code>GL_POST_CONVOLUTION_COLOR_TABLE</code>, and
        /// <code>GL_SEPARABLE_2D</code> are available only if <code>ARB_imaging</code> is returned
        /// from  <see cref="glGet"/>  with an argument of <code>GL_EXTENSIONS</code>.
        /// For OpenGL versions 1.3 and greater, or when <code>ARB_multitexture</code> is supported, <code>GL_TEXTURE_1D</code>,
        /// <code>GL_TEXTURE_2D</code>, <code>GL_TEXTURE_3D</code>, <code>GL_TEXTURE_GEN_S</code>,
        /// <code>GL_TEXTURE_GEN_T</code>, <code>GL_TEXTURE_GEN_R</code>, and <code>GL_TEXTURE_GEN_Q</code>
        /// enable or disable the respective state for the active texture unit
        /// specified with  <see cref="glActiveTexture"/> .
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="cap"/> is not one of the values
        /// listed previously.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glEnable"/> or  <see cref="glDisable"/> 
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glEnable(GLenum cap);</para>
        /// </summary>
        /// <param name="cap">
        /// Specifies a symbolic constant indicating a GL capability.
        /// </param>
        /// <seealso cref="glActiveTexture"/>
        /// <seealso cref="glAlphaFunc"/>
        /// <seealso cref="glBlendFunc"/>
        /// <seealso cref="glClipPlane"/>
        /// <seealso cref="glColorMaterial"/>
        /// <seealso cref="glCullFace"/>
        /// <seealso cref="glDepthFunc"/>
        /// <seealso cref="glDepthRange"/>
        /// <seealso cref="glEnableClientState"/>
        /// <seealso cref="glFog"/>
        /// <seealso cref="glGet"/>
        /// <seealso cref="glIsEnabled"/>
        /// <seealso cref="glLight"/>
        /// <seealso cref="glLightModel"/>
        /// <seealso cref="glLineWidth"/>
        /// <seealso cref="glLineStipple"/>
        /// <seealso cref="glLogicOp"/>
        /// <seealso cref="glMap1"/>
        /// <seealso cref="glMap2"/>
        /// <seealso cref="glMaterial"/>
        /// <seealso cref="glNormal"/>
        /// <seealso cref="glNormalPointer"/>
        /// <seealso cref="glPointSize"/>
        /// <seealso cref="glPolygonMode"/>
        /// <seealso cref="glPolygonOffset"/>
        /// <seealso cref="glPolygonStipple"/>
        /// <seealso cref="glSampleCoverage"/>
        /// <seealso cref="glScissor"/>
        /// <seealso cref="glStencilFunc"/>
        /// <seealso cref="glStencilOp"/>
        /// <seealso cref="glTexGen"/>
        /// <seealso cref="glTexImage1D"/>
        /// <seealso cref="glTexImage2D"/>
        /// <seealso cref="glTexImage3D"/>
        public static void glEnable(uint cap) {
            var _F = _GetProc<GLNativeDelegate.FNglEnable>("glEnable");
            _F(cap);
        }
        /// <summary>
        /// block until all GL execution is complete
        /// <para>Require:</para> <para>GL_VERSION_1_0, GL_VERSION_ES_CM_1_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <see cref="glFinish"/> requires a round trip to the server.
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glFinish"/> is executed between
        /// the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glFinish();</para>
        /// </summary>
        /// <seealso cref="glFlush"/>
        public static void glFinish() {
            var _F = _GetProc<GLNativeDelegate.FNglFinish>("glFinish");
            _F();
        }
        /// <summary>
        /// force execution of GL commands in finite time
        /// <para>Require:</para> <para>GL_VERSION_1_0, GL_VERSION_ES_CM_1_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glFlush"/> can return at any time.
        /// It does not wait until the execution of all previously
        /// issued GL commands is complete.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glFlush"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glFlush();</para>
        /// </summary>
        /// <seealso cref="glFinish"/>
        public static void glFlush() {
            var _F = _GetProc<GLNativeDelegate.FNglFlush>("glFlush");
            _F();
        }
        /// <summary>
        /// specify pixel arithmetic
        /// <para>Require:</para> <para>GL_VERSION_1_0, GL_VERSION_ES_CM_1_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// Incoming (source) alpha is correctly thought of as a material opacity,
        /// ranging from 1.0 
        /// (  
        /// K 
        /// A 
        /// ),
        /// representing complete opacity,
        /// to 0.0 (0), representing complete
        /// transparency.
        /// When more than one color buffer is enabled for drawing,
        /// the GL performs blending separately for each enabled buffer,
        /// using the contents of that buffer for destination color.
        /// (See  <see cref="glDrawBuffer"/> .)
        /// Blending affects only RGBA rendering.
        /// It is ignored by color index renderers.
        /// <code>GL_CONSTANT_COLOR</code>, <code>GL_ONE_MINUS_CONSTANT_COLOR</code>,
        /// <code>GL_CONSTANT_ALPHA</code>, <code>GL_ONE_MINUS_CONSTANT_ALPHA</code> are available only
        /// if the GL version is 1.4 or greater or if the <code>ARB_imaging</code> is
        /// supported by your implementation.
        /// <code>GL_SRC_COLOR</code> and <code>GL_ONE_MINUS_SRC_COLOR</code> are valid only for
        /// <paramref name="sfactor"/> if the GL version is 1.4 or greater.
        /// <code>GL_DST_COLOR</code> and <code>GL_ONE_MINUS_DST_COLOR</code> are valid only for
        /// <paramref name="dfactor"/> if the GL version is 1.4 or greater.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if either <paramref name="sfactor"/> or <paramref name="dfactor"/> is not an
        /// accepted value.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glBlendFunc"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glBlendFunc(GLenum sfactor, GLenum dfactor);</para>
        /// </summary>
        /// <param name="sfactor">
        /// <para>
        /// Specifies how the red, green, blue,
        /// and alpha source blending factors are computed.
        /// The following symbolic constants are accepted:
        /// <code>GL_ZERO</code>,
        /// <code>GL_ONE</code>,
        /// <code>GL_SRC_COLOR</code>,
        /// <code>GL_ONE_MINUS_SRC_COLOR</code>,
        /// <code>GL_DST_COLOR</code>,
        /// <code>GL_ONE_MINUS_DST_COLOR</code>,
        /// <code>GL_SRC_ALPHA</code>,
        /// <code>GL_ONE_MINUS_SRC_ALPHA</code>,
        /// <code>GL_DST_ALPHA</code>,
        /// <code>GL_ONE_MINUS_DST_ALPHA</code>,
        /// <code>GL_CONSTANT_COLOR</code>,
        /// <code>GL_ONE_MINUS_CONSTANT_COLOR</code>,
        /// <code>GL_CONSTANT_ALPHA</code>,
        /// <code>GL_ONE_MINUS_CONSTANT_ALPHA</code>, and
        /// <code>GL_SRC_ALPHA_SATURATE</code>.
        /// The initial value is <code>GL_ONE</code>.
        /// </para>
        /// </param>
        /// <param name="dfactor">
        /// <para>
        /// Specifies how the red, green, blue,
        /// and alpha destination blending factors are computed.
        /// The following symbolic constants are accepted:
        /// <code>GL_ZERO</code>,
        /// <code>GL_ONE</code>,
        /// <code>GL_SRC_COLOR</code>,
        /// <code>GL_ONE_MINUS_SRC_COLOR</code>,
        /// <code>GL_DST_COLOR</code>,
        /// <code>GL_ONE_MINUS_DST_COLOR</code>,
        /// <code>GL_SRC_ALPHA</code>,
        /// <code>GL_ONE_MINUS_SRC_ALPHA</code>,
        /// <code>GL_DST_ALPHA</code>,
        /// <code>GL_ONE_MINUS_DST_ALPHA</code>.
        /// <code>GL_CONSTANT_COLOR</code>,
        /// <code>GL_ONE_MINUS_CONSTANT_COLOR</code>,
        /// <code>GL_CONSTANT_ALPHA</code>, and
        /// <code>GL_ONE_MINUS_CONSTANT_ALPHA</code>.
        /// The initial value is <code>GL_ZERO</code>.
        /// </para>
        /// </param>
        /// <seealso cref="glAlphaFunc"/>
        /// <seealso cref="glBlendColor"/>
        /// <seealso cref="glBlendEquation"/>
        /// <seealso cref="glBlendFuncSeparate"/>
        /// <seealso cref="glClear"/>
        /// <seealso cref="glDrawBuffer"/>
        /// <seealso cref="glEnable"/>
        /// <seealso cref="glLogicOp"/>
        /// <seealso cref="glStencilFunc"/>
        public static void glBlendFunc(uint sfactor, uint dfactor) {
            var _F = _GetProc<GLNativeDelegate.FNglBlendFunc>("glBlendFunc");
            _F(sfactor, dfactor);
        }
        /// <summary>
        /// specify a logical pixel operation for color index rendering
        /// <para>Require:</para> <para>GL_VERSION_1_0, GL_VERSION_ES_CM_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// Color index logical operations are always supported. RGBA logical
        /// operations are supported only if the GL version is 1.1 or greater.
        /// When more than one RGBA color or index buffer is enabled for drawing,
        /// logical operations are performed separately for each enabled buffer,
        /// using for the destination value the contents of that buffer
        /// (see  <see cref="glDrawBuffer"/> ).
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="opcode"/> is not an accepted value.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glLogicOp"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glLogicOp(GLenum opcode);</para>
        /// </summary>
        /// <param name="opcode">
        /// <para>
        /// Specifies a symbolic constant that selects a logical operation.
        /// The following symbols are accepted:
        /// <code>GL_CLEAR</code>,
        /// <code>GL_SET</code>,
        /// <code>GL_COPY</code>,
        /// <code>GL_COPY_INVERTED</code>,
        /// <code>GL_NOOP</code>,
        /// <code>GL_INVERT</code>,
        /// <code>GL_AND</code>,
        /// <code>GL_NAND</code>,
        /// <code>GL_OR</code>,
        /// <code>GL_NOR</code>,
        /// <code>GL_XOR</code>,
        /// <code>GL_EQUIV</code>,
        /// <code>GL_AND_REVERSE</code>,
        /// <code>GL_AND_INVERTED</code>,
        /// <code>GL_OR_REVERSE</code>, and
        /// <code>GL_OR_INVERTED</code>. The initial value is <code>GL_COPY</code>.
        /// </para>
        /// </param>
        /// <seealso cref="glAlphaFunc"/>
        /// <seealso cref="glBlendFunc"/>
        /// <seealso cref="glDrawBuffer"/>
        /// <seealso cref="glEnable"/>
        /// <seealso cref="glStencilOp"/>
        public static void glLogicOp(uint opcode) {
            var _F = _GetProc<GLNativeDelegate.FNglLogicOp>("glLogicOp");
            _F(opcode);
        }
        /// <summary>
        /// set front and back function and reference value for stencil testing
        /// <para>Require:</para> <para>GL_VERSION_1_0, GL_VERSION_ES_CM_1_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// Initially, the stencil test is disabled.
        /// If there is no stencil buffer,
        /// no stencil modification can occur and it is as if
        /// the stencil test always passes.
        /// <see cref="glStencilFunc"/>  is the same as
        /// calling  <see cref="glStencilFuncSeparate"/> 
        /// with <paramref name="face"/> set to <code>GL_FRONT_AND_BACK</code>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="func"/> is not one of the eight
        /// accepted values.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glStencilFunc"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glStencilFunc(GLenum func, GLint ref, GLuint mask);</para>
        /// </summary>
        /// <param name="func">
        /// <para>
        /// Specifies the test function.
        /// Eight symbolic constants are valid:
        /// <code>GL_NEVER</code>,
        /// <code>GL_LESS</code>,
        /// <code>GL_LEQUAL</code>,
        /// <code>GL_GREATER</code>,
        /// <code>GL_GEQUAL</code>,
        /// <code>GL_EQUAL</code>,
        /// <code>GL_NOTEQUAL</code>, and
        /// <code>GL_ALWAYS</code>. The initial value is <code>GL_ALWAYS</code>.
        /// </para>
        /// </param>
        /// <param name="r">
        /// <para>
        /// Specifies the reference value for the stencil test.
        /// <paramref name="r"/> is clamped to the range 
        /// 0 
        /// 2 
        /// n 
        /// - 
        /// 1 
        /// ,
        /// where 
        /// n   
        /// is the number of bitplanes in the stencil buffer. The
        /// initial value is 0.
        /// </para>
        /// </param>
        /// <param name="mask">
        /// <para>
        /// Specifies a mask that is ANDed with both the reference value
        /// and the stored stencil value when the test is done. The initial value
        /// is all 1's.
        /// </para>
        /// </param>
        /// <seealso cref="glAlphaFunc"/>
        /// <seealso cref="glBlendFunc"/>
        /// <seealso cref="glDepthFunc"/>
        /// <seealso cref="glEnable"/>
        /// <seealso cref="glLogicOp"/>
        /// <seealso cref="glStencilFuncSeparate"/>
        /// <seealso cref="glStencilMask"/>
        /// <seealso cref="glStencilMaskSeparate"/>
        /// <seealso cref="glStencilOp"/>
        /// <seealso cref="glStencilOpSeparate"/>
        public static void glStencilFunc(uint func, int r, uint mask) {
            var _F = _GetProc<GLNativeDelegate.FNglStencilFunc>("glStencilFunc");
            _F(func, r, mask);
        }
        /// <summary>
        /// set front and back stencil test actions
        /// <para>Require:</para> <para>GL_VERSION_1_0, GL_VERSION_ES_CM_1_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <code>GL_DECR_WRAP</code> and <code>GL_INCR_WRAP</code> are available only if the GL
        /// version is 1.4 or greater.
        /// Initially the stencil test is disabled.
        /// If there is no stencil buffer,
        /// no stencil modification can occur
        /// and it is as if the stencil tests always pass,
        /// regardless of any call to <see cref="glStencilOp"/>.
        /// <see cref="glStencilOp"/>  is the same as
        /// calling  <see cref="glStencilOpSeparate"/> 
        /// with <paramref name="face"/> set to <code>GL_FRONT_AND_BACK</code>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="sfail"/>,
        /// <paramref name="dpfail"/>, or <paramref name="dppass"/> is any value other than the eight defined constant values.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glStencilOp"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glStencilOp(GLenum sfail, GLenum dpfail, GLenum dppass);</para>
        /// </summary>
        /// <param name="sfail">
        /// <para>
        /// Specifies the action to take when the stencil test fails.
        /// Eight symbolic constants are accepted:
        /// <code>GL_KEEP</code>,
        /// <code>GL_ZERO</code>,
        /// <code>GL_REPLACE</code>,
        /// <code>GL_INCR</code>,
        /// <code>GL_INCR_WRAP</code>,
        /// <code>GL_DECR</code>,
        /// <code>GL_DECR_WRAP</code>, and
        /// <code>GL_INVERT</code>. The initial value is <code>GL_KEEP</code>.
        /// </para>
        /// </param>
        /// <param name="dpfail">
        /// <para>
        /// Specifies the stencil action when the stencil test passes,
        /// but the depth test fails.
        /// <paramref name="dpfail"/> accepts the same symbolic constants as <paramref name="sfail"/>. The initial value
        /// is <code>GL_KEEP</code>.
        /// </para>
        /// </param>
        /// <param name="dppass">
        /// <para>
        /// Specifies the stencil action when both the stencil test and the depth
        /// test pass, or when the stencil test passes and either there is no
        /// depth buffer or depth testing is not enabled.
        /// <paramref name="dppass"/> accepts the same symbolic constants as <paramref name="sfail"/>. The initial value
        /// is <code>GL_KEEP</code>.
        /// </para>
        /// </param>
        /// <seealso cref="glAlphaFunc"/>
        /// <seealso cref="glBlendFunc"/>
        /// <seealso cref="glDepthFunc"/>
        /// <seealso cref="glEnable"/>
        /// <seealso cref="glLogicOp"/>
        /// <seealso cref="glStencilFunc"/>
        /// <seealso cref="glStencilFuncSeparate"/>
        /// <seealso cref="glStencilMask"/>
        /// <seealso cref="glStencilMaskSeparate"/>
        /// <seealso cref="glStencilOpSeparate"/>
        public static void glStencilOp(uint sfail, uint dpfail, uint dppass) {
            var _F = _GetProc<GLNativeDelegate.FNglStencilOp>("glStencilOp");
            _F(sfail, dpfail, dppass);
        }
        /// <summary>
        /// specify the value used for depth buffer comparisons
        /// <para>Require:</para> <para>GL_VERSION_1_0, GL_VERSION_ES_CM_1_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// Even if the depth buffer exists and the depth mask is non-zero, the
        /// depth buffer is not updated if the depth test is disabled.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="func"/> is not an accepted value.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glDepthFunc"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glDepthFunc(GLenum func);</para>
        /// </summary>
        /// <param name="func">
        /// <para>
        /// Specifies the depth comparison function.
        /// Symbolic constants
        /// <code>GL_NEVER</code>,
        /// <code>GL_LESS</code>,
        /// <code>GL_EQUAL</code>,
        /// <code>GL_LEQUAL</code>,
        /// <code>GL_GREATER</code>,
        /// <code>GL_NOTEQUAL</code>,
        /// <code>GL_GEQUAL</code>, and
        /// <code>GL_ALWAYS</code> are accepted.
        /// The initial value is <code>GL_LESS</code>.
        /// </para>
        /// </param>
        /// <seealso cref="glDepthRange"/>
        /// <seealso cref="glEnable"/>
        /// <seealso cref="glPolygonOffset"/>
        public static void glDepthFunc(uint func) {
            var _F = _GetProc<GLNativeDelegate.FNglDepthFunc>("glDepthFunc");
            _F(func);
        }
        /// <summary>
        /// set pixel storage modes
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The pixel storage modes in effect when
        /// <see cref="glDrawPixels"/> ,
        /// <see cref="glReadPixels"/> ,
        /// <see cref="glTexImage1D"/> ,
        /// <see cref="glTexImage2D"/> ,
        /// <see cref="glTexImage3D"/> ,
        /// <see cref="glTexSubImage1D"/> ,
        /// <see cref="glTexSubImage2D"/> ,
        /// <see cref="glTexSubImage3D"/> ,
        /// <see cref="glBitmap"/> ,
        /// or  <see cref="glPolygonStipple"/>  is placed in a display list control the interpretation
        /// of memory data.
        /// Likewise, if the <code>ARB_imaging</code> extension is supported, the pixel
        /// storage modes in effect when
        /// <see cref="glColorTable"/> ,
        /// <see cref="glColorSubTable"/> ,
        /// <see cref="glConvolutionFilter1D"/> ,
        /// <see cref="glConvolutionFilter2D"/> , of
        /// <see cref="glSeparableFilter2D"/>  is placed in a display list control the
        /// interpretation of memory data.
        /// The pixel storage modes in effect when a display list is executed are
        /// not significant.
        /// Pixel storage modes are client state and must be pushed and restored
        /// using
        /// <see cref="glPushClientAttrib"/>  and  <see cref="glPopClientAttrib"/> .
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="pname"/> is not an accepted value.
        /// <code>GL_INVALID_VALUE</code> is generated if a negative row length,
        /// pixel skip,
        /// or row skip value is specified,
        /// or if alignment is specified as other than 1, 2, 4, or 8.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glPixelStore"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glPixelStoref(GLenum pname, GLfloat param);</para>
        /// </summary>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of the parameter to be set.
        /// Six values affect the packing of pixel data into memory:
        /// <code>GL_PACK_SWAP_BYTES</code>,
        /// <code>GL_PACK_LSB_FIRST</code>,
        /// <code>GL_PACK_ROW_LENGTH</code>,
        /// <code>GL_PACK_IMAGE_HEIGHT</code>,
        /// <code>GL_PACK_SKIP_PIXELS</code>,
        /// <code>GL_PACK_SKIP_ROWS</code>,
        /// <code>GL_PACK_SKIP_IMAGES</code>, and
        /// <code>GL_PACK_ALIGNMENT</code>.
        /// Six more affect the unpacking of pixel data  from  memory:
        /// <code>GL_UNPACK_SWAP_BYTES</code>,
        /// <code>GL_UNPACK_LSB_FIRST</code>,
        /// <code>GL_UNPACK_ROW_LENGTH</code>,
        /// <code>GL_UNPACK_IMAGE_HEIGHT</code>,
        /// <code>GL_UNPACK_SKIP_PIXELS</code>,
        /// <code>GL_UNPACK_SKIP_ROWS</code>,
        /// <code>GL_UNPACK_SKIP_IMAGES</code>, and
        /// <code>GL_UNPACK_ALIGNMENT</code>.
        /// </para>
        /// </param>
        /// <param name="param">
        /// Specifies the value that <paramref name="pname"/> is set to.
        /// </param>
        /// <seealso cref="glBitmap"/>
        /// <seealso cref="glColorTable"/>
        /// <seealso cref="glColorSubTable"/>
        /// <seealso cref="glConvolutionFilter1D"/>
        /// <seealso cref="glConvolutionFilter2D"/>
        /// <seealso cref="glSeparableFilter2D"/>
        /// <seealso cref="glDrawPixels"/>
        /// <seealso cref="glHistogram"/>
        /// <seealso cref="glMinmax"/>
        /// <seealso cref="glPixelMap"/>
        /// <seealso cref="glPixelTransfer"/>
        /// <seealso cref="glPixelZoom"/>
        /// <seealso cref="glPolygonStipple"/>
        /// <seealso cref="glPushClientAttrib"/>
        /// <seealso cref="glReadPixels"/>
        /// <seealso cref="glTexImage1D"/>
        /// <seealso cref="glTexImage2D"/>
        /// <seealso cref="glTexImage3D"/>
        /// <seealso cref="glTexSubImage1D"/>
        /// <seealso cref="glTexSubImage2D"/>
        /// <seealso cref="glTexSubImage3D"/>
        public static void glPixelStoref(uint pname, float param) {
            var _F = _GetProc<GLNativeDelegate.FNglPixelStoref>("glPixelStoref");
            _F(pname, param);
        }
        /// <summary>
        /// set pixel storage modes
        /// <para>Require:</para> <para>GL_VERSION_1_0, GL_VERSION_ES_CM_1_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The pixel storage modes in effect when
        /// <see cref="glDrawPixels"/> ,
        /// <see cref="glReadPixels"/> ,
        /// <see cref="glTexImage1D"/> ,
        /// <see cref="glTexImage2D"/> ,
        /// <see cref="glTexImage3D"/> ,
        /// <see cref="glTexSubImage1D"/> ,
        /// <see cref="glTexSubImage2D"/> ,
        /// <see cref="glTexSubImage3D"/> ,
        /// <see cref="glBitmap"/> ,
        /// or  <see cref="glPolygonStipple"/>  is placed in a display list control the interpretation
        /// of memory data.
        /// Likewise, if the <code>ARB_imaging</code> extension is supported, the pixel
        /// storage modes in effect when
        /// <see cref="glColorTable"/> ,
        /// <see cref="glColorSubTable"/> ,
        /// <see cref="glConvolutionFilter1D"/> ,
        /// <see cref="glConvolutionFilter2D"/> , of
        /// <see cref="glSeparableFilter2D"/>  is placed in a display list control the
        /// interpretation of memory data.
        /// The pixel storage modes in effect when a display list is executed are
        /// not significant.
        /// Pixel storage modes are client state and must be pushed and restored
        /// using
        /// <see cref="glPushClientAttrib"/>  and  <see cref="glPopClientAttrib"/> .
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="pname"/> is not an accepted value.
        /// <code>GL_INVALID_VALUE</code> is generated if a negative row length,
        /// pixel skip,
        /// or row skip value is specified,
        /// or if alignment is specified as other than 1, 2, 4, or 8.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glPixelStore"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glPixelStorei(GLenum pname, GLint param);</para>
        /// </summary>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of the parameter to be set.
        /// Six values affect the packing of pixel data into memory:
        /// <code>GL_PACK_SWAP_BYTES</code>,
        /// <code>GL_PACK_LSB_FIRST</code>,
        /// <code>GL_PACK_ROW_LENGTH</code>,
        /// <code>GL_PACK_IMAGE_HEIGHT</code>,
        /// <code>GL_PACK_SKIP_PIXELS</code>,
        /// <code>GL_PACK_SKIP_ROWS</code>,
        /// <code>GL_PACK_SKIP_IMAGES</code>, and
        /// <code>GL_PACK_ALIGNMENT</code>.
        /// Six more affect the unpacking of pixel data  from  memory:
        /// <code>GL_UNPACK_SWAP_BYTES</code>,
        /// <code>GL_UNPACK_LSB_FIRST</code>,
        /// <code>GL_UNPACK_ROW_LENGTH</code>,
        /// <code>GL_UNPACK_IMAGE_HEIGHT</code>,
        /// <code>GL_UNPACK_SKIP_PIXELS</code>,
        /// <code>GL_UNPACK_SKIP_ROWS</code>,
        /// <code>GL_UNPACK_SKIP_IMAGES</code>, and
        /// <code>GL_UNPACK_ALIGNMENT</code>.
        /// </para>
        /// </param>
        /// <param name="param">
        /// Specifies the value that <paramref name="pname"/> is set to.
        /// </param>
        /// <seealso cref="glBitmap"/>
        /// <seealso cref="glColorTable"/>
        /// <seealso cref="glColorSubTable"/>
        /// <seealso cref="glConvolutionFilter1D"/>
        /// <seealso cref="glConvolutionFilter2D"/>
        /// <seealso cref="glSeparableFilter2D"/>
        /// <seealso cref="glDrawPixels"/>
        /// <seealso cref="glHistogram"/>
        /// <seealso cref="glMinmax"/>
        /// <seealso cref="glPixelMap"/>
        /// <seealso cref="glPixelTransfer"/>
        /// <seealso cref="glPixelZoom"/>
        /// <seealso cref="glPolygonStipple"/>
        /// <seealso cref="glPushClientAttrib"/>
        /// <seealso cref="glReadPixels"/>
        /// <seealso cref="glTexImage1D"/>
        /// <seealso cref="glTexImage2D"/>
        /// <seealso cref="glTexImage3D"/>
        /// <seealso cref="glTexSubImage1D"/>
        /// <seealso cref="glTexSubImage2D"/>
        /// <seealso cref="glTexSubImage3D"/>
        public static void glPixelStorei(uint pname, int param) {
            var _F = _GetProc<GLNativeDelegate.FNglPixelStorei>("glPixelStorei");
            _F(pname, param);
        }
        /// <summary>
        /// select a color buffer source for pixels
        /// <para>Require:</para> <para>GL_VERSION_1_0, GL_ES_VERSION_3_0</para>
        /// Supported: <para>GL</para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="mode"/> is not one of the twelve
        /// (or more) accepted values.
        /// <code>GL_INVALID_OPERATION</code> is generated if <paramref name="mode"/> specifies a buffer
        /// that does not exist.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glReadBuffer"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glReadBuffer(GLenum mode);</para>
        /// </summary>
        /// <param name="mode">
        /// <para>
        /// Specifies a color buffer.
        /// Accepted values are
        /// <code>GL_FRONT_LEFT</code>,
        /// <code>GL_FRONT_RIGHT</code>,
        /// <code>GL_BACK_LEFT</code>,
        /// <code>GL_BACK_RIGHT</code>,
        /// <code>GL_FRONT</code>,
        /// <code>GL_BACK</code>,
        /// <code>GL_LEFT</code>,
        /// <code>GL_RIGHT</code>, and
        /// <code>GL_AUX</code> i ,
        /// where  i  is between 0 and the value of <code>GL_AUX_BUFFERS</code> minus 1.
        /// </para>
        /// </param>
        /// <seealso cref="glCopyPixels"/>
        /// <seealso cref="glCopyTexImage1D"/>
        /// <seealso cref="glCopyTexImage2D"/>
        /// <seealso cref="glCopyTexSubImage1D"/>
        /// <seealso cref="glCopyTexSubImage2D"/>
        /// <seealso cref="glCopyTexSubImage3D"/>
        /// <seealso cref="glDrawBuffer"/>
        /// <seealso cref="glReadPixels"/>
        public static void glReadBuffer(uint mode) {
            var _F = _GetProc<GLNativeDelegate.FNglReadBuffer>("glReadBuffer");
            _F(mode);
        }
        /// <summary>
        /// read a block of pixels from the frame buffer
        /// <para>Require:</para> <para>GL_VERSION_1_0, GL_VERSION_ES_CM_1_0, GL_ES_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// Values for pixels that lie outside the window
        /// connected to the current GL context are undefined.
        /// If an error is generated,
        /// no change is made to the contents of <paramref name="data"/>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="format"/> or <paramref name="type"/> is not an
        /// accepted value.
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="type"/> is <code>GL_BITMAP</code> and <paramref name="format"/> is
        /// not <code>GL_COLOR_INDEX</code> or <code>GL_STENCIL_INDEX</code>.
        /// <code>GL_INVALID_VALUE</code> is generated if either <paramref name="width"/> or <paramref name="height"/> is negative.
        /// <code>GL_INVALID_OPERATION</code> is generated if <paramref name="format"/> is <code>GL_COLOR_INDEX</code>
        /// and the color buffers store RGBA color components.
        /// <code>GL_INVALID_OPERATION</code> is generated if <paramref name="format"/> is <code>GL_STENCIL_INDEX</code>
        /// and there is no stencil buffer.
        /// <code>GL_INVALID_OPERATION</code> is generated if <paramref name="format"/> is <code>GL_DEPTH_COMPONENT</code>
        /// and there is no depth buffer.
        /// <code>GL_INVALID_OPERATION</code> is generated if <paramref name="type"/> is one of
        /// <code>GL_UNSIGNED_BYTE_3_3_2</code>,
        /// <code>GL_UNSIGNED_BYTE_2_3_3_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_5_6_5</code>, or
        /// <code>GL_UNSIGNED_SHORT_5_6_5_REV</code>
        /// and <paramref name="format"/> is not <code>GL_RGB</code>.
        /// <code>GL_INVALID_OPERATION</code> is generated if <paramref name="type"/> is one of
        /// <code>GL_UNSIGNED_SHORT_4_4_4_4</code>,
        /// <code>GL_UNSIGNED_SHORT_4_4_4_4_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_5_5_5_1</code>,
        /// <code>GL_UNSIGNED_SHORT_1_5_5_5_REV</code>,
        /// <code>GL_UNSIGNED_INT_8_8_8_8</code>,
        /// <code>GL_UNSIGNED_INT_8_8_8_8_REV</code>,
        /// <code>GL_UNSIGNED_INT_10_10_10_2</code>, or
        /// <code>GL_UNSIGNED_INT_2_10_10_10_REV</code>
        /// and <paramref name="format"/> is neither <code>GL_RGBA</code> nor <code>GL_BGRA</code>.
        /// The formats <code>GL_BGR</code>, and <code>GL_BGRA</code> and types
        /// <code>GL_UNSIGNED_BYTE_3_3_2</code>,
        /// <code>GL_UNSIGNED_BYTE_2_3_3_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_5_6_5</code>,
        /// <code>GL_UNSIGNED_SHORT_5_6_5_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_4_4_4_4</code>,
        /// <code>GL_UNSIGNED_SHORT_4_4_4_4_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_5_5_5_1</code>,
        /// <code>GL_UNSIGNED_SHORT_1_5_5_5_REV</code>,
        /// <code>GL_UNSIGNED_INT_8_8_8_8</code>,
        /// <code>GL_UNSIGNED_INT_8_8_8_8_REV</code>,
        /// <code>GL_UNSIGNED_INT_10_10_10_2</code>, and
        /// <code>GL_UNSIGNED_INT_2_10_10_10_REV</code> are available only if the GL version
        /// is 1.2 or greater.
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_PACK_BUFFER</code> target and the buffer object's data store is currently mapped.
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_PACK_BUFFER</code> target and the data would be packed to the buffer 
        /// object such that the memory writes required would exceed the data store size.
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_PACK_BUFFER</code> target and <paramref name="data"/> is not evenly divisible 
        /// into the number of bytes needed to store in memory a datum indicated by <paramref name="type"/>.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glReadPixels"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glReadPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, void * data);</para>
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify the window coordinates of the first pixel
        /// that is read from the frame buffer.
        /// This location is the lower left corner of a rectangular block of pixels.
        /// </para>
        /// </param>
        /// <param name="y">
        /// <para>
        /// Specify the window coordinates of the first pixel
        /// that is read from the frame buffer.
        /// This location is the lower left corner of a rectangular block of pixels.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// Specify the dimensions of the pixel rectangle.
        /// <paramref name="width"/> and <paramref name="height"/> of one correspond to a single pixel.
        /// </para>
        /// </param>
        /// <param name="height">
        /// <para>
        /// Specify the dimensions of the pixel rectangle.
        /// <paramref name="width"/> and <paramref name="height"/> of one correspond to a single pixel.
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// Specifies the format of the pixel data.
        /// The following symbolic values are accepted:
        /// <code>GL_COLOR_INDEX</code>,
        /// <code>GL_STENCIL_INDEX</code>,
        /// <code>GL_DEPTH_COMPONENT</code>,
        /// <code>GL_RED</code>,
        /// <code>GL_GREEN</code>,
        /// <code>GL_BLUE</code>,
        /// <code>GL_ALPHA</code>,
        /// <code>GL_RGB</code>,
        /// <code>GL_BGR</code>,
        /// <code>GL_RGBA</code>,
        /// <code>GL_BGRA</code>,
        /// <code>GL_LUMINANCE</code>, and
        /// <code>GL_LUMINANCE_ALPHA</code>.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the data type of the pixel data.
        /// Must be one of
        /// <code>GL_UNSIGNED_BYTE</code>,
        /// <code>GL_BYTE</code>,
        /// <code>GL_BITMAP</code>,
        /// <code>GL_UNSIGNED_SHORT</code>,
        /// <code>GL_SHORT</code>,
        /// <code>GL_UNSIGNED_INT</code>,
        /// <code>GL_INT</code>,
        /// <code>GL_FLOAT</code>,
        /// <code>GL_UNSIGNED_BYTE_3_3_2</code>,
        /// <code>GL_UNSIGNED_BYTE_2_3_3_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_5_6_5</code>,
        /// <code>GL_UNSIGNED_SHORT_5_6_5_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_4_4_4_4</code>,
        /// <code>GL_UNSIGNED_SHORT_4_4_4_4_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_5_5_5_1</code>,
        /// <code>GL_UNSIGNED_SHORT_1_5_5_5_REV</code>,
        /// <code>GL_UNSIGNED_INT_8_8_8_8</code>,
        /// <code>GL_UNSIGNED_INT_8_8_8_8_REV</code>,
        /// <code>GL_UNSIGNED_INT_10_10_10_2</code>, or
        /// <code>GL_UNSIGNED_INT_2_10_10_10_REV</code>.
        /// </para>
        /// </param>
        /// <param name="data">
        /// Returns the pixel data.
        /// </param>
        /// <seealso cref="glCopyPixels"/>
        /// <seealso cref="glDrawPixels"/>
        /// <seealso cref="glPixelMap"/>
        /// <seealso cref="glPixelStore"/>
        /// <seealso cref="glPixelTransfer"/>
        /// <seealso cref="glReadBuffer"/>
        public unsafe static void glReadPixels(int x, int y, int width, int height, uint format, uint type, void* data) {
            var _F = _GetProc<GLNativeDelegate.FNglReadPixels>("glReadPixels");
            _F(x, y, width, height, format, type, data);
        }
        /// <summary>
        /// return the value or values of a selected parameter
        /// <para>Require:</para> <para>GL_VERSION_1_0, GL_VERSION_ES_CM_1_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <code>GL_COLOR_LOGIC_OP</code>,
        /// <code>GL_COLOR_ARRAY</code>,
        /// <code>GL_COLOR_ARRAY_SIZE</code>,
        /// <code>GL_COLOR_ARRAY_STRIDE</code>,
        /// <code>GL_COLOR_ARRAY_TYPE</code>,
        /// <code>GL_EDGE_FLAG_ARRAY</code>,
        /// <code>GL_EDGE_FLAG_ARRAY_STRIDE</code>,
        /// <code>GL_INDEX_ARRAY</code>,
        /// <code>GL_INDEX_ARRAY_STRIDE</code>,
        /// <code>GL_INDEX_ARRAY_TYPE</code>,
        /// <code>GL_INDEX_LOGIC_OP</code>,
        /// <code>GL_NORMAL_ARRAY</code>,
        /// <code>GL_NORMAL_ARRAY_STRIDE</code>,
        /// <code>GL_NORMAL_ARRAY_TYPE</code>,
        /// <code>GL_POLYGON_OFFSET_UNITS</code>,
        /// <code>GL_POLYGON_OFFSET_FACTOR</code>,
        /// <code>GL_POLYGON_OFFSET_FILL</code>,
        /// <code>GL_POLYGON_OFFSET_LINE</code>,
        /// <code>GL_POLYGON_OFFSET_POINT</code>,
        /// <code>GL_TEXTURE_COORD_ARRAY</code>,
        /// <code>GL_TEXTURE_COORD_ARRAY_SIZE</code>,
        /// <code>GL_TEXTURE_COORD_ARRAY_STRIDE</code>,
        /// <code>GL_TEXTURE_COORD_ARRAY_TYPE</code>,
        /// <code>GL_VERTEX_ARRAY</code>,
        /// <code>GL_VERTEX_ARRAY_SIZE</code>,
        /// <code>GL_VERTEX_ARRAY_STRIDE</code>, and
        /// <code>GL_VERTEX_ARRAY_TYPE</code>
        /// are available only if the GL version is 1.1 or greater.
        /// <code>GL_ALIASED_POINT_SIZE_RANGE</code>,
        /// <code>GL_FEEDBACK_BUFFER_SIZE</code>,
        /// <code>GL_FEEDBACK_BUFFER_TYPE</code>,
        /// <code>GL_LIGHT_MODEL_AMBIENT</code>,
        /// <code>GL_LIGHT_MODEL_COLOR_CONTROL</code>,
        /// <code>GL_MAX_3D_TEXTURE_SIZE</code>,
        /// <code>GL_MAX_ELEMENTS_INDICES</code>,
        /// <code>GL_MAX_ELEMENTS_VERTICES</code>,
        /// <code>GL_PACK_IMAGE_HEIGHT</code>,
        /// <code>GL_PACK_SKIP_IMAGES</code>,
        /// <code>GL_RESCALE_NORMAL</code>,
        /// <code>GL_SELECTION_BUFFER_SIZE</code>,
        /// <code>GL_SMOOTH_LINE_WIDTH_GRANULARITY</code>,
        /// <code>GL_SMOOTH_LINE_WIDTH_RANGE</code>,
        /// <code>GL_SMOOTH_POINT_SIZE_GRANULARITY</code>,
        /// <code>GL_SMOOTH_POINT_SIZE_RANGE</code>,
        /// <code>GL_TEXTURE_3D</code>,
        /// <code>GL_TEXTURE_BINDING_3D</code>,
        /// <code>GL_UNPACK_IMAGE_HEIGHT</code>, and
        /// <code>GL_UNPACK_SKIP_IMAGES</code>
        /// are available only if the GL version is 1.2 or greater.
        /// <code>GL_COMPRESSED_TEXTURE_FORMATS</code>,
        /// <code>GL_NUM_COMPRESSED_TEXTURE_FORMATS</code>,
        /// <code>GL_TEXTURE_BINDING_CUBE_MAP</code>, and
        /// <code>GL_TEXTURE_COMPRESSION_HINT</code>
        /// are available only if the GL version is 1.3 or greater.
        /// <code>GL_BLEND_DST_ALPHA</code>,
        /// <code>GL_BLEND_DST_RGB</code>,
        /// <code>GL_BLEND_SRC_ALPHA</code>,
        /// <code>GL_BLEND_SRC_RGB</code>,
        /// <code>GL_CURRENT_FOG_COORD</code>,
        /// <code>GL_CURRENT_SECONDARY_COLOR</code>,
        /// <code>GL_FOG_COORD_ARRAY_STRIDE</code>,
        /// <code>GL_FOG_COORD_ARRAY_TYPE</code>,
        /// <code>GL_FOG_COORD_SRC</code>,
        /// <code>GL_MAX_TEXTURE_LOD_BIAS</code>,
        /// <code>GL_POINT_SIZE_MIN</code>,
        /// <code>GL_POINT_SIZE_MAX</code>,
        /// <code>GL_POINT_FADE_THRESHOLD_SIZE</code>,
        /// <code>GL_POINT_DISTANCE_ATTENUATION</code>,
        /// <code>GL_SECONDARY_COLOR_ARRAY_SIZE</code>,
        /// <code>GL_SECONDARY_COLOR_ARRAY_STRIDE</code>, and
        /// <code>GL_SECONDARY_COLOR_ARRAY_TYPE</code>
        /// are available only if the GL version is 1.4 or greater.
        /// <code>GL_ARRAY_BUFFER_BINDING</code>,
        /// <code>GL_COLOR_ARRAY_BUFFER_BINDING</code>,
        /// <code>GL_EDGE_FLAG_ARRAY_BUFFER_BINDING</code>,
        /// <code>GL_ELEMENT_ARRAY_BUFFER_BINDING</code>,
        /// <code>GL_FOG_COORD_ARRAY_BUFFER_BINDING</code>,
        /// <code>GL_INDEX_ARRAY_BUFFER_BINDING</code>,
        /// <code>GL_NORMAL_ARRAY_BUFFER_BINDING</code>,
        /// <code>GL_SECONDARY_COLOR_ARRAY_BUFFER_BINDING</code>,
        /// <code>GL_TEXTURE_COORD_ARRAY_BUFFER_BINDING</code>, and
        /// <code>GL_VERTEX_ARRAY_BUFFER_BINDING</code>
        /// are available only if the GL version is 1.5 or greater.
        /// <code>GL_BLEND_EQUATION_ALPHA</code>,
        /// <code>GL_BLEND_EQUATION_RGB</code>,
        /// <code>GL_DRAW_BUFFER</code> i ,
        /// <code>GL_FRAGMENT_SHADER_DERIVATIVE_HINT</code>,
        /// <code>GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS</code>,
        /// <code>GL_MAX_DRAW_BUFFERS</code>,
        /// <code>GL_MAX_FRAGMENT_UNIFORM_COMPONENTS</code>,
        /// <code>GL_MAX_TEXTURE_COORDS</code>,
        /// <code>GL_MAX_TEXTURE_IMAGE_UNITS</code>,
        /// <code>GL_MAX_VARYING_FLOATS</code>,
        /// <code>GL_MAX_VERTEX_ATTRIBS</code>,
        /// <code>GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS</code>,
        /// <code>GL_MAX_VERTEX_UNIFORM_COMPONENTS</code>,
        /// <code>GL_POINT_SPRITE</code>,
        /// <code>GL_STENCIL_BACK_FAIL</code>,
        /// <code>GL_STENCIL_BACK_FUNC</code>,
        /// <code>GL_STENCIL_BACK_PASS_DEPTH_FAIL</code>,
        /// <code>GL_STENCIL_BACK_PASS_DEPTH_PASS</code>,
        /// <code>GL_STENCIL_BACK_REF</code>,
        /// <code>GL_STENCIL_BACK_VALUE_MASK</code>,
        /// <code>GL_STENCIL_BACK_WRITEMASK</code>,
        /// <code>GL_VERTEX_PROGRAM_POINT_SIZE</code>, and
        /// <code>GL_VERTEX_PROGRAM_TWO_SIDE</code>
        /// are available only if the GL version is 2.0 or greater.
        /// <code>GL_CURRENT_RASTER_SECONDARY_COLOR</code>,
        /// <code>GL_PIXEL_PACK_BUFFER_BINDING</code> and
        /// <code>GL_PIXEL_UNPACK_BUFFER_BINDING</code>
        /// are available only if the GL version is 2.1 or greater.
        /// <code>GL_LINE_WIDTH_GRANULARITY</code> was deprecated in GL version 1.2.  Its
        /// functionality was replaced by <code>GL_SMOOTH_LINE_WIDTH_GRANULARITY</code>.
        /// <code>GL_LINE_WIDTH_RANGE</code> was deprecated in GL version 1.2.  Its
        /// functionality was replaced by <code>GL_SMOOTH_LINE_WIDTH_RANGE</code>.
        /// <code>GL_POINT_SIZE_GRANULARITY</code> was deprecated in GL version 1.2.  Its
        /// functionality was replaced by <code>GL_SMOOTH_POINT_SIZE_GRANULARITY</code>.
        /// <code>GL_POINT_SIZE_RANGE</code> was deprecated in GL version 1.2.  Its
        /// functionality was replaced by <code>GL_SMOOTH_POINT_SIZE_RANGE</code>.
        /// <code>GL_BLEND_EQUATION</code> was deprecated in GL version 2.0.  Its
        /// functionality was replaced by <code>GL_BLEND_EQUATION_RGB</code> and
        /// <code>GL_BLEND_EQUATION_ALPHA</code>.
        /// <code>GL_COLOR_MATRIX</code>,
        /// <code>GL_COLOR_MATRIX_STACK_DEPTH</code>,
        /// <code>GL_COLOR_TABLE</code>,
        /// <code>GL_CONVOLUTION_1D</code>,
        /// <code>GL_CONVOLUTION_2D</code>,
        /// <code>GL_HISTOGRAM</code>,
        /// <code>GL_MAX_COLOR_MATRIX_STACK_DEPTH</code>,
        /// <code>GL_MINMAX</code>,
        /// <code>GL_POST_COLOR_MATRIX_COLOR_TABLE</code>,
        /// <code>GL_POST_COLOR_MATRIX_RED_BIAS</code>,
        /// <code>GL_POST_COLOR_MATRIX_GREEN_BIAS</code>,
        /// <code>GL_POST_COLOR_MATRIX_BLUE_BIAS</code>,
        /// <code>GL_POST_COLOR_MATRIX_ALPHA_BIAS</code>,
        /// <code>GL_POST_COLOR_MATRIX_RED_SCALE</code>,
        /// <code>GL_POST_COLOR_MATRIX_GREEN_SCALE</code>,
        /// <code>GL_POST_COLOR_MATRIX_BLUE_SCALE</code>,
        /// <code>GL_POST_COLOR_MATRIX_ALPHA_SCALE</code>,
        /// <code>GL_POST_CONVOLUTION_COLOR_TABLE</code>,
        /// <code>GL_POST_CONVOLUTION_RED_BIAS</code>,
        /// <code>GL_POST_CONVOLUTION_GREEN_BIAS</code>,
        /// <code>GL_POST_CONVOLUTION_BLUE_BIAS</code>,
        /// <code>GL_POST_CONVOLUTION_ALPHA_BIAS</code>,
        /// <code>GL_POST_CONVOLUTION_RED_SCALE</code>,
        /// <code>GL_POST_CONVOLUTION_GREEN_SCALE</code>,
        /// <code>GL_POST_CONVOLUTION_BLUE_SCALE</code>,
        /// <code>GL_POST_CONVOLUTION_ALPHA_SCALE</code>, and
        /// <code>GL_SEPARABLE_2D</code>
        /// are available only if <code>ARB_imaging</code> is returned from <see cref="glGet"/>
        /// when called with the argument <code>GL_EXTENSIONS</code>.
        /// When the <code>ARB_multitexture</code> extension is supported, or the GL version
        /// is 1.3 or greater, the following
        /// parameters return the associated value for the active texture unit:
        /// <code>GL_CURRENT_RASTER_TEXTURE_COORDS</code>,
        /// <code>GL_TEXTURE_1D</code>, <code>GL_TEXTURE_BINDING_1D</code>,
        /// <code>GL_TEXTURE_2D</code>, <code>GL_TEXTURE_BINDING_2D</code>,
        /// <code>GL_TEXTURE_3D</code>, <code>GL_TEXTURE_BINDING_3D</code>,
        /// <code>GL_TEXTURE_GEN_S</code>,
        /// <code>GL_TEXTURE_GEN_T</code>,
        /// <code>GL_TEXTURE_GEN_R</code>,
        /// <code>GL_TEXTURE_GEN_Q</code>,
        /// <code>GL_TEXTURE_MATRIX</code>, and
        /// <code>GL_TEXTURE_STACK_DEPTH</code>.
        /// Likewise, the following parameters return the associated value for the
        /// active client texture unit:
        /// <code>GL_TEXTURE_COORD_ARRAY</code>,
        /// <code>GL_TEXTURE_COORD_ARRAY_BUFFER_BINDING</code>,
        /// <code>GL_TEXTURE_COORD_ARRAY_SIZE</code>,
        /// <code>GL_TEXTURE_COORD_ARRAY_STRIDE</code>,
        /// <code>GL_TEXTURE_COORD_ARRAY_TYPE</code>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="pname"/> is not an accepted value.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glGet"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glGetBooleanv(GLenum pname, GLboolean * params);</para>
        /// </summary>
        /// <param name="pname">
        /// <para>
        /// Specifies the parameter value to be returned.
        /// The symbolic constants in the list below are accepted.
        /// </para>
        /// </param>
        /// <param name="ps">
        /// Returns the value or values of the specified parameter.
        /// </param>
        /// <seealso cref="glGetActiveAttrib"/>
        /// <seealso cref="glGetActiveUniform"/>
        /// <seealso cref="glGetAttachedShaders"/>
        /// <seealso cref="glGetAttribLocation"/>
        /// <seealso cref="glGetBufferParameteriv"/>
        /// <seealso cref="glGetBufferPointerv"/>
        /// <seealso cref="glGetBufferSubData"/>
        /// <seealso cref="glGetClipPlane"/>
        /// <seealso cref="glGetColorTable"/>
        /// <seealso cref="glGetColorTableParameter"/>
        /// <seealso cref="glGetCompressedTexImage"/>
        /// <seealso cref="glGetConvolutionFilter"/>
        /// <seealso cref="glGetConvolutionParameter"/>
        /// <seealso cref="glGetError"/>
        /// <seealso cref="glGetHistogram"/>
        /// <seealso cref="glGetHistogramParameter"/>
        /// <seealso cref="glGetLight"/>
        /// <seealso cref="glGetMap"/>
        /// <seealso cref="glGetMaterial"/>
        /// <seealso cref="glGetMinmax"/>
        /// <seealso cref="glGetMinmaxParameter"/>
        /// <seealso cref="glGetPixelMap"/>
        /// <seealso cref="glGetPointerv"/>
        /// <seealso cref="glGetPolygonStipple"/>
        /// <seealso cref="glGetProgram"/>
        /// <seealso cref="glGetProgramInfoLog"/>
        /// <seealso cref="glGetQueryiv"/>
        /// <seealso cref="glGetQueryObject"/>
        /// <seealso cref="glGetSeparableFilter"/>
        /// <seealso cref="glGetShader"/>
        /// <seealso cref="glGetShaderInfoLog"/>
        /// <seealso cref="glGetShaderSource"/>
        /// <seealso cref="glGetString"/>
        /// <seealso cref="glGetTexEnv"/>
        /// <seealso cref="glGetTexGen"/>
        /// <seealso cref="glGetTexImage"/>
        /// <seealso cref="glGetTexLevelParameter"/>
        /// <seealso cref="glGetTexParameter"/>
        /// <seealso cref="glGetUniform"/>
        /// <seealso cref="glGetUniformLocation"/>
        /// <seealso cref="glGetVertexAttrib"/>
        /// <seealso cref="glGetVertexAttribPointerv"/>
        /// <seealso cref="glIsEnabled"/>
        public unsafe static void glGetBooleanv(uint pname, bool* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetBooleanv>("glGetBooleanv");
            _F(pname, ps);
        }
        /// <summary>
        /// return the value or values of a selected parameter
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glGetDoublev(GLenum pname, GLdouble * data);</para>
        /// </summary>
        public unsafe static void glGetDoublev(uint pname, double* data) {
            var _F = _GetProc<GLNativeDelegate.FNglGetDoublev>("glGetDoublev");
            _F(pname, data);
        }
        /// <summary>
        /// return error information
        /// <para>Require:</para> <para>GL_VERSION_1_0, GL_VERSION_ES_CM_1_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <code>GL_TABLE_TOO_LARGE</code> was introduced in GL version 1.2.
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glGetError"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// In this case, <see cref="glGetError"/> returns 0.
        /// </para>
        /// Original: <para>GLenum glGetError();</para>
        /// </summary>
        public static uint glGetError() {
            var _F = _GetProc<GLNativeDelegate.FNglGetError>("glGetError");
            return _F();
        }
        /// <summary>
        /// return the value or values of a selected parameter
        /// <para>Require:</para> <para>GL_VERSION_1_0, GL_VERSION_ES_CM_1_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glGetFloatv(GLenum pname, GLfloat * data);</para>
        /// </summary>
        public unsafe static void glGetFloatv(uint pname, float* data) {
            var _F = _GetProc<GLNativeDelegate.FNglGetFloatv>("glGetFloatv");
            _F(pname, data);
        }
        /// <summary>
        /// return the value or values of a selected parameter
        /// <para>Require:</para> <para>GL_VERSION_1_0, GL_VERSION_ES_CM_1_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glGetIntegerv(GLenum pname, GLint * data);</para>
        /// </summary>
        public unsafe static void glGetIntegerv(uint pname, int* data) {
            var _F = _GetProc<GLNativeDelegate.FNglGetIntegerv>("glGetIntegerv");
            _F(pname, data);
        }
        /// <summary>
        /// return a string describing the current GL connection
        /// <para>Require:</para> <para>GL_VERSION_1_0, GL_VERSION_ES_CM_1_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// If an error is generated, <see cref="glGetString"/> returns 0.
        /// The client and server may support different versions or extensions.
        /// <see cref="glGetString"/> always returns a compatible version number or list of extensions.
        /// The release number always describes the server.
        /// <code>GL_SHADING_LANGUAGE_VERSION</code> is available only if the GL version is 2.0 or greater.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="name"/> is not an accepted value.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glGetString"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>const GLubyte * glGetString(GLenum name);</para>
        /// </summary>
        /// <param name="name">
        /// <para>
        /// Specifies a symbolic constant, one of
        /// <code>GL_VENDOR</code>, <code>GL_RENDERER</code>, <code>GL_VERSION</code>, <code>GL_SHADING_LANGUAGE_VERSION</code>, or <code>GL_EXTENSIONS</code>.
        /// </para>
        /// </param>
        public unsafe static byte* glGetString(uint name) {
            var _F = _GetProc<GLNativeDelegate.FNglGetString>("glGetString");
            return _F(name);
        }
        /// <summary>
        /// return a texture image
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// If an error is generated,
        /// no change is made to the contents of <paramref name="img"/>.
        /// The types <code>GL_UNSIGNED_BYTE_3_3_2</code>,
        /// <code>GL_UNSIGNED_BYTE_2_3_3_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_5_6_5</code>,
        /// <code>GL_UNSIGNED_SHORT_5_6_5_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_4_4_4_4</code>,
        /// <code>GL_UNSIGNED_SHORT_4_4_4_4_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_5_5_5_1</code>,
        /// <code>GL_UNSIGNED_SHORT_1_5_5_5_REV</code>,
        /// <code>GL_UNSIGNED_INT_8_8_8_8</code>,
        /// <code>GL_UNSIGNED_INT_8_8_8_8_REV</code>,
        /// <code>GL_UNSIGNED_INT_10_10_10_2</code>,
        /// <code>GL_UNSIGNED_INT_2_10_10_10_REV</code>,
        /// and the formats
        /// <code>GL_BGR</code>, and <code>GL_BGRA</code> are available only if the GL version is
        /// 1.2 or greater.
        /// For OpenGL versions 1.3 and greater, or when the <code>ARB_multitexture</code> extension is supported, <see cref="glGetTexImage"/> returns
        /// the texture image for the active texture unit.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="target"/>, <paramref name="format"/>, or <paramref name="type"/> is not
        /// an accepted value.
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="level"/> is less than 0.
        /// <code>GL_INVALID_VALUE</code> may be generated if <paramref name="level"/> is greater
        /// than 
        /// log 
        /// 2 
        /// &af; 
        /// max 
        /// ,
        /// where 
        /// max   
        /// is the returned value of <code>GL_MAX_TEXTURE_SIZE</code>.
        /// <code>GL_INVALID_OPERATION</code> is returned if <paramref name="type"/> is one of
        /// <code>GL_UNSIGNED_BYTE_3_3_2</code>,
        /// <code>GL_UNSIGNED_BYTE_2_3_3_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_5_6_5</code>, or
        /// <code>GL_UNSIGNED_SHORT_5_6_5_REV</code> and <paramref name="format"/> is not <code>GL_RGB</code>.
        /// <code>GL_INVALID_OPERATION</code> is returned if <paramref name="type"/> is one of
        /// <code>GL_UNSIGNED_SHORT_4_4_4_4</code>,
        /// <code>GL_UNSIGNED_SHORT_4_4_4_4_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_5_5_5_1</code>,
        /// <code>GL_UNSIGNED_SHORT_1_5_5_5_REV</code>,
        /// <code>GL_UNSIGNED_INT_8_8_8_8</code>,
        /// <code>GL_UNSIGNED_INT_8_8_8_8_REV</code>,
        /// <code>GL_UNSIGNED_INT_10_10_10_2</code>, or
        /// <code>GL_UNSIGNED_INT_2_10_10_10_REV</code>, and <paramref name="format"/> is neither <code>GL_RGBA</code>
        /// or <code>GL_BGRA</code>.
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_PACK_BUFFER</code> target and the buffer object's data store is currently mapped.
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_PACK_BUFFER</code> target and the data would be packed to the buffer 
        /// object such that the memory writes required would exceed the data store size.
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_PACK_BUFFER</code> target and <paramref name="img"/> is not evenly divisible 
        /// into the number of bytes needed to store in memory a datum indicated by <paramref name="type"/>.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glGetTexImage"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glGetTexImage(GLenum target, GLint level, GLenum format, GLenum type, void * img);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies which texture is to be obtained.
        /// <code>GL_TEXTURE_1D</code>, <code>GL_TEXTURE_2D</code>, <code>GL_TEXTURE_3D</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_POSITIVE_X</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_NEGATIVE_X</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_POSITIVE_Y</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_NEGATIVE_Y</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_POSITIVE_Z</code>, and
        /// <code>GL_TEXTURE_CUBE_MAP_NEGATIVE_Z</code> 
        /// are accepted.
        /// </para>
        /// </param>
        /// <param name="level">
        /// <para>
        /// Specifies the level-of-detail number of the desired image.
        /// Level 0 is the base image level.
        /// Level 
        /// n   
        /// is the 
        /// n   th
        /// mipmap reduction image.
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// Specifies a pixel format for the returned data.
        /// The supported formats are
        /// <code>GL_RED</code>,
        /// <code>GL_GREEN</code>,
        /// <code>GL_BLUE</code>,
        /// <code>GL_ALPHA</code>,
        /// <code>GL_RGB</code>,
        /// <code>GL_BGR</code>,
        /// <code>GL_RGBA</code>,
        /// <code>GL_BGRA</code>,
        /// <code>GL_LUMINANCE</code>, and
        /// <code>GL_LUMINANCE_ALPHA</code>.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies a pixel type for the returned data.
        /// The supported types are
        /// <code>GL_UNSIGNED_BYTE</code>,
        /// <code>GL_BYTE</code>,
        /// <code>GL_UNSIGNED_SHORT</code>,
        /// <code>GL_SHORT</code>,
        /// <code>GL_UNSIGNED_INT</code>,
        /// <code>GL_INT</code>,
        /// <code>GL_FLOAT</code>,
        /// <code>GL_UNSIGNED_BYTE_3_3_2</code>,
        /// <code>GL_UNSIGNED_BYTE_2_3_3_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_5_6_5</code>,
        /// <code>GL_UNSIGNED_SHORT_5_6_5_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_4_4_4_4</code>,
        /// <code>GL_UNSIGNED_SHORT_4_4_4_4_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_5_5_5_1</code>,
        /// <code>GL_UNSIGNED_SHORT_1_5_5_5_REV</code>,
        /// <code>GL_UNSIGNED_INT_8_8_8_8</code>,
        /// <code>GL_UNSIGNED_INT_8_8_8_8_REV</code>,
        /// <code>GL_UNSIGNED_INT_10_10_10_2</code>, and
        /// <code>GL_UNSIGNED_INT_2_10_10_10_REV</code>.
        /// </para>
        /// </param>
        /// <param name="img">
        /// <para>
        /// Returns the texture image.
        /// Should be a pointer to an array of the type specified by <paramref name="type"/>.
        /// </para>
        /// </param>
        /// <seealso cref="glActiveTexture"/>
        /// <seealso cref="glDrawPixels"/>
        /// <seealso cref="glReadPixels"/>
        /// <seealso cref="glTexEnv"/>
        /// <seealso cref="glTexGen"/>
        /// <seealso cref="glTexImage1D"/>
        /// <seealso cref="glTexImage2D"/>
        /// <seealso cref="glTexImage3D"/>
        /// <seealso cref="glTexSubImage1D"/>
        /// <seealso cref="glTexSubImage2D"/>
        /// <seealso cref="glTexSubImage3D"/>
        /// <seealso cref="glTexParameter"/>
        public unsafe static void glGetTexImage(uint target, int level, uint format, uint type, void* img) {
            var _F = _GetProc<GLNativeDelegate.FNglGetTexImage>("glGetTexImage");
            _F(target, level, format, type, img);
        }
        /// <summary>
        /// return texture parameter values
        /// <para>Require:</para> <para>GL_VERSION_1_0, GL_VERSION_ES_CM_1_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <code>GL_TEXTURE_PRIORITY</code> and <code>GL_TEXTURE_RESIDENT</code> are
        /// available only if the GL version is 1.1 or greater.
        /// <code>GL_TEXTURE_3D</code>,
        /// <code>GL_TEXTURE_MIN_LOD</code>, <code>GL_TEXTURE_MAX_LOD</code>, <code>GL_TEXTURE_BASE_LEVEL</code>,
        /// <code>GL_TEXTURE_MAX_LEVEL</code>, and <code>GL_TEXTURE_WRAP_R</code> are available only
        /// if the GL version is 1.2 or greater.
        /// <code>GL_TEXTURE_COMPARE_MODE</code>, <code>GL_TEXTURE_COMPARE_FUNC</code>, and
        /// <code>GL_GENERATE_MIPMAP</code> is available only if the GL version is 1.4 or
        /// greater.
        /// If an error is generated,
        /// no change is made to the contents of <paramref name="ps"/>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="target"/> or <paramref name="pname"/> is not an
        /// accepted value.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glGetTexParameter"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glGetTexParameterfv(GLenum target, GLenum pname, GLfloat * params);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the symbolic name of the target texture.
        /// <code>GL_TEXTURE_1D</code>,
        /// <code>GL_TEXTURE_2D</code>,
        /// <code>GL_TEXTURE_3D</code>, and
        /// <code>GL_TEXTURE_CUBE_MAP</code>
        /// are accepted.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of a texture parameter.
        /// <code>GL_TEXTURE_MAG_FILTER</code>,
        /// <code>GL_TEXTURE_MIN_FILTER</code>,
        /// <code>GL_TEXTURE_MIN_LOD</code>,
        /// <code>GL_TEXTURE_MAX_LOD</code>,
        /// <code>GL_TEXTURE_BASE_LEVEL</code>,
        /// <code>GL_TEXTURE_MAX_LEVEL</code>,
        /// <code>GL_TEXTURE_WRAP_S</code>,
        /// <code>GL_TEXTURE_WRAP_T</code>,
        /// <code>GL_TEXTURE_WRAP_R</code>,
        /// <code>GL_TEXTURE_BORDER_COLOR</code>,
        /// <code>GL_TEXTURE_PRIORITY</code>,
        /// <code>GL_TEXTURE_RESIDENT</code>,
        /// <code>GL_TEXTURE_COMPARE_MODE</code>,
        /// <code>GL_TEXTURE_COMPARE_FUNC</code>,
        /// <code>GL_DEPTH_TEXTURE_MODE</code>, and
        /// <code>GL_GENERATE_MIPMAP</code>
        /// are accepted.
        /// </para>
        /// </param>
        /// <param name="ps">
        /// Returns the texture parameters.
        /// </param>
        /// <seealso cref="glAreTexturesResident"/>
        /// <seealso cref="glPrioritizeTextures"/>
        /// <seealso cref="glTexParameter"/>
        public unsafe static void glGetTexParameterfv(uint target, uint pname, float* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetTexParameterfv>("glGetTexParameterfv");
            _F(target, pname, ps);
        }
        /// <summary>
        /// return texture parameter values
        /// <para>Require:</para> <para>GL_VERSION_1_0, GL_VERSION_ES_CM_1_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <code>GL_TEXTURE_PRIORITY</code> and <code>GL_TEXTURE_RESIDENT</code> are
        /// available only if the GL version is 1.1 or greater.
        /// <code>GL_TEXTURE_3D</code>,
        /// <code>GL_TEXTURE_MIN_LOD</code>, <code>GL_TEXTURE_MAX_LOD</code>, <code>GL_TEXTURE_BASE_LEVEL</code>,
        /// <code>GL_TEXTURE_MAX_LEVEL</code>, and <code>GL_TEXTURE_WRAP_R</code> are available only
        /// if the GL version is 1.2 or greater.
        /// <code>GL_TEXTURE_COMPARE_MODE</code>, <code>GL_TEXTURE_COMPARE_FUNC</code>, and
        /// <code>GL_GENERATE_MIPMAP</code> is available only if the GL version is 1.4 or
        /// greater.
        /// If an error is generated,
        /// no change is made to the contents of <paramref name="ps"/>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="target"/> or <paramref name="pname"/> is not an
        /// accepted value.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glGetTexParameter"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glGetTexParameteriv(GLenum target, GLenum pname, GLint * params);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the symbolic name of the target texture.
        /// <code>GL_TEXTURE_1D</code>,
        /// <code>GL_TEXTURE_2D</code>,
        /// <code>GL_TEXTURE_3D</code>, and
        /// <code>GL_TEXTURE_CUBE_MAP</code>
        /// are accepted.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of a texture parameter.
        /// <code>GL_TEXTURE_MAG_FILTER</code>,
        /// <code>GL_TEXTURE_MIN_FILTER</code>,
        /// <code>GL_TEXTURE_MIN_LOD</code>,
        /// <code>GL_TEXTURE_MAX_LOD</code>,
        /// <code>GL_TEXTURE_BASE_LEVEL</code>,
        /// <code>GL_TEXTURE_MAX_LEVEL</code>,
        /// <code>GL_TEXTURE_WRAP_S</code>,
        /// <code>GL_TEXTURE_WRAP_T</code>,
        /// <code>GL_TEXTURE_WRAP_R</code>,
        /// <code>GL_TEXTURE_BORDER_COLOR</code>,
        /// <code>GL_TEXTURE_PRIORITY</code>,
        /// <code>GL_TEXTURE_RESIDENT</code>,
        /// <code>GL_TEXTURE_COMPARE_MODE</code>,
        /// <code>GL_TEXTURE_COMPARE_FUNC</code>,
        /// <code>GL_DEPTH_TEXTURE_MODE</code>, and
        /// <code>GL_GENERATE_MIPMAP</code>
        /// are accepted.
        /// </para>
        /// </param>
        /// <param name="ps">
        /// Returns the texture parameters.
        /// </param>
        /// <seealso cref="glAreTexturesResident"/>
        /// <seealso cref="glPrioritizeTextures"/>
        /// <seealso cref="glTexParameter"/>
        public unsafe static void glGetTexParameteriv(uint target, uint pname, int* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetTexParameteriv>("glGetTexParameteriv");
            _F(target, pname, ps);
        }
        /// <summary>
        /// return texture parameter values for a specific level of detail
        /// <para>Require:</para> <para>GL_VERSION_1_0, GL_ES_VERSION_3_1</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// If an error is generated,
        /// no change is made to the contents of <paramref name="ps"/>.
        /// <code>GL_TEXTURE_INTERNAL_FORMAT</code> is available only if the GL version is
        /// 1.1 or greater. In version 1.0, use <code>GL_TEXTURE_COMPONENTS</code>
        /// instead.
        /// <code>GL_PROXY_TEXTURE_1D</code> and <code>GL_PROXY_TEXTURE_2D</code> are
        /// available only if the GL version is 1.1 or greater.
        /// <code>GL_TEXTURE_3D</code>, <code>GL_PROXY_TEXTURE_3D</code>, and <code>GL_TEXTURE_DEPTH</code>
        /// are available only if the GL version is 1.2 or greater.
        /// <code>GL_TEXTURE_COMPRESSED</code>,
        /// <code>GL_TEXTURE_COMPRESSED_IMAGE_SIZE</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_POSITIVE_X</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_NEGATIVE_X</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_POSITIVE_Y</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_NEGATIVE_Y</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_POSITIVE_Z</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_NEGATIVE_Z</code>, and
        /// <code>GL_PROXY_TEXTURE_CUBE_MAP</code> are available only if the GL version is 1.3
        /// or greater.
        /// For OpenGL versions 1.3 and greater, or when the <code>ARB_multitexture</code> extension is supported, <see cref="glGetTexLevelParameter"/> returns
        /// the texture level parameters for the active texture unit.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="target"/> or <paramref name="pname"/> is not an
        /// accepted value.
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="level"/> is less than 0.
        /// <code>GL_INVALID_VALUE</code> may be generated if <paramref name="level"/> is greater
        /// than 
        /// log 
        /// 2 
        /// max ,
        /// where  max  is the returned value of <code>GL_MAX_TEXTURE_SIZE</code>.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glGetTexLevelParameter"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <code>GL_TEXTURE_COMPRESSED_IMAGE_SIZE</code> is queried on texture images with an
        /// uncompressed internal format or on proxy targets.
        /// </para>
        /// Original: <para>void glGetTexLevelParameterfv(GLenum target, GLint level, GLenum pname, GLfloat * params);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the symbolic name of the target texture,
        /// either <code>GL_TEXTURE_1D</code>, <code>GL_TEXTURE_2D</code>, <code>GL_TEXTURE_3D</code>,
        /// <code>GL_PROXY_TEXTURE_1D</code>, <code>GL_PROXY_TEXTURE_2D</code>,
        /// <code>GL_PROXY_TEXTURE_3D</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_POSITIVE_X</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_NEGATIVE_X</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_POSITIVE_Y</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_NEGATIVE_Y</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_POSITIVE_Z</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_NEGATIVE_Z</code>, or
        /// <code>GL_PROXY_TEXTURE_CUBE_MAP</code>.
        /// </para>
        /// </param>
        /// <param name="level">
        /// <para>
        /// Specifies the level-of-detail number of the desired image.
        /// Level 0 is the base image level.
        /// Level 
        /// n   
        /// is the 
        /// n   th
        /// mipmap reduction image.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of a texture parameter.
        /// <code>GL_TEXTURE_WIDTH</code>,
        /// <code>GL_TEXTURE_HEIGHT</code>,
        /// <code>GL_TEXTURE_DEPTH</code>,
        /// <code>GL_TEXTURE_INTERNAL_FORMAT</code>,
        /// <code>GL_TEXTURE_BORDER</code>,
        /// <code>GL_TEXTURE_RED_SIZE</code>,
        /// <code>GL_TEXTURE_GREEN_SIZE</code>,
        /// <code>GL_TEXTURE_BLUE_SIZE</code>,
        /// <code>GL_TEXTURE_ALPHA_SIZE</code>,
        /// <code>GL_TEXTURE_LUMINANCE_SIZE</code>,
        /// <code>GL_TEXTURE_INTENSITY_SIZE</code>,
        /// <code>GL_TEXTURE_DEPTH_SIZE</code>,
        /// <code>GL_TEXTURE_COMPRESSED</code>, and
        /// <code>GL_TEXTURE_COMPRESSED_IMAGE_SIZE</code>
        /// are accepted.
        /// </para>
        /// </param>
        /// <param name="ps">
        /// Returns the requested data.
        /// </param>
        /// <seealso cref="glActiveTexture"/>
        /// <seealso cref="glGetTexParameter"/>
        /// <seealso cref="glCopyTexImage1D"/>
        /// <seealso cref="glCopyTexImage2D"/>
        /// <seealso cref="glCopyTexSubImage1D"/>
        /// <seealso cref="glCopyTexSubImage2D"/>
        /// <seealso cref="glCopyTexSubImage3D"/>
        /// <seealso cref="glTexEnv"/>
        /// <seealso cref="glTexGen"/>
        /// <seealso cref="glTexImage1D"/>
        /// <seealso cref="glTexImage2D"/>
        /// <seealso cref="glTexImage3D"/>
        /// <seealso cref="glTexSubImage1D"/>
        /// <seealso cref="glTexSubImage2D"/>
        /// <seealso cref="glTexSubImage3D"/>
        /// <seealso cref="glTexParameter"/>
        public unsafe static void glGetTexLevelParameterfv(uint target, int level, uint pname, float* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetTexLevelParameterfv>("glGetTexLevelParameterfv");
            _F(target, level, pname, ps);
        }
        /// <summary>
        /// return texture parameter values for a specific level of detail
        /// <para>Require:</para> <para>GL_VERSION_1_0, GL_ES_VERSION_3_1</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// If an error is generated,
        /// no change is made to the contents of <paramref name="ps"/>.
        /// <code>GL_TEXTURE_INTERNAL_FORMAT</code> is available only if the GL version is
        /// 1.1 or greater. In version 1.0, use <code>GL_TEXTURE_COMPONENTS</code>
        /// instead.
        /// <code>GL_PROXY_TEXTURE_1D</code> and <code>GL_PROXY_TEXTURE_2D</code> are
        /// available only if the GL version is 1.1 or greater.
        /// <code>GL_TEXTURE_3D</code>, <code>GL_PROXY_TEXTURE_3D</code>, and <code>GL_TEXTURE_DEPTH</code>
        /// are available only if the GL version is 1.2 or greater.
        /// <code>GL_TEXTURE_COMPRESSED</code>,
        /// <code>GL_TEXTURE_COMPRESSED_IMAGE_SIZE</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_POSITIVE_X</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_NEGATIVE_X</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_POSITIVE_Y</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_NEGATIVE_Y</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_POSITIVE_Z</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_NEGATIVE_Z</code>, and
        /// <code>GL_PROXY_TEXTURE_CUBE_MAP</code> are available only if the GL version is 1.3
        /// or greater.
        /// For OpenGL versions 1.3 and greater, or when the <code>ARB_multitexture</code> extension is supported, <see cref="glGetTexLevelParameter"/> returns
        /// the texture level parameters for the active texture unit.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="target"/> or <paramref name="pname"/> is not an
        /// accepted value.
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="level"/> is less than 0.
        /// <code>GL_INVALID_VALUE</code> may be generated if <paramref name="level"/> is greater
        /// than 
        /// log 
        /// 2 
        /// max ,
        /// where  max  is the returned value of <code>GL_MAX_TEXTURE_SIZE</code>.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glGetTexLevelParameter"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <code>GL_TEXTURE_COMPRESSED_IMAGE_SIZE</code> is queried on texture images with an
        /// uncompressed internal format or on proxy targets.
        /// </para>
        /// Original: <para>void glGetTexLevelParameteriv(GLenum target, GLint level, GLenum pname, GLint * params);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the symbolic name of the target texture,
        /// either <code>GL_TEXTURE_1D</code>, <code>GL_TEXTURE_2D</code>, <code>GL_TEXTURE_3D</code>,
        /// <code>GL_PROXY_TEXTURE_1D</code>, <code>GL_PROXY_TEXTURE_2D</code>,
        /// <code>GL_PROXY_TEXTURE_3D</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_POSITIVE_X</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_NEGATIVE_X</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_POSITIVE_Y</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_NEGATIVE_Y</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_POSITIVE_Z</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_NEGATIVE_Z</code>, or
        /// <code>GL_PROXY_TEXTURE_CUBE_MAP</code>.
        /// </para>
        /// </param>
        /// <param name="level">
        /// <para>
        /// Specifies the level-of-detail number of the desired image.
        /// Level 0 is the base image level.
        /// Level 
        /// n   
        /// is the 
        /// n   th
        /// mipmap reduction image.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of a texture parameter.
        /// <code>GL_TEXTURE_WIDTH</code>,
        /// <code>GL_TEXTURE_HEIGHT</code>,
        /// <code>GL_TEXTURE_DEPTH</code>,
        /// <code>GL_TEXTURE_INTERNAL_FORMAT</code>,
        /// <code>GL_TEXTURE_BORDER</code>,
        /// <code>GL_TEXTURE_RED_SIZE</code>,
        /// <code>GL_TEXTURE_GREEN_SIZE</code>,
        /// <code>GL_TEXTURE_BLUE_SIZE</code>,
        /// <code>GL_TEXTURE_ALPHA_SIZE</code>,
        /// <code>GL_TEXTURE_LUMINANCE_SIZE</code>,
        /// <code>GL_TEXTURE_INTENSITY_SIZE</code>,
        /// <code>GL_TEXTURE_DEPTH_SIZE</code>,
        /// <code>GL_TEXTURE_COMPRESSED</code>, and
        /// <code>GL_TEXTURE_COMPRESSED_IMAGE_SIZE</code>
        /// are accepted.
        /// </para>
        /// </param>
        /// <param name="ps">
        /// Returns the requested data.
        /// </param>
        /// <seealso cref="glActiveTexture"/>
        /// <seealso cref="glGetTexParameter"/>
        /// <seealso cref="glCopyTexImage1D"/>
        /// <seealso cref="glCopyTexImage2D"/>
        /// <seealso cref="glCopyTexSubImage1D"/>
        /// <seealso cref="glCopyTexSubImage2D"/>
        /// <seealso cref="glCopyTexSubImage3D"/>
        /// <seealso cref="glTexEnv"/>
        /// <seealso cref="glTexGen"/>
        /// <seealso cref="glTexImage1D"/>
        /// <seealso cref="glTexImage2D"/>
        /// <seealso cref="glTexImage3D"/>
        /// <seealso cref="glTexSubImage1D"/>
        /// <seealso cref="glTexSubImage2D"/>
        /// <seealso cref="glTexSubImage3D"/>
        /// <seealso cref="glTexParameter"/>
        public unsafe static void glGetTexLevelParameteriv(uint target, int level, uint pname, int* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetTexLevelParameteriv>("glGetTexLevelParameteriv");
            _F(target, level, pname, ps);
        }
        /// <summary>
        /// test whether a capability is enabled
        /// <para>Require:</para> <para>GL_VERSION_1_0, GL_VERSION_ES_CM_1_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// If an error is generated,
        /// <see cref="glIsEnabled"/> returns 0.
        /// <code>GL_COLOR_LOGIC_OP</code>,
        /// <code>GL_COLOR_ARRAY</code>,
        /// <code>GL_EDGE_FLAG_ARRAY</code>,
        /// <code>GL_INDEX_ARRAY</code>,
        /// <code>GL_INDEX_LOGIC_OP</code>,
        /// <code>GL_NORMAL_ARRAY</code>,
        /// <code>GL_POLYGON_OFFSET_FILL</code>,
        /// <code>GL_POLYGON_OFFSET_LINE</code>,
        /// <code>GL_POLYGON_OFFSET_POINT</code>,
        /// <code>GL_TEXTURE_COORD_ARRAY</code>, and
        /// <code>GL_VERTEX_ARRAY</code>
        /// are available only
        /// if the GL version is 1.1 or greater.
        /// <code>GL_RESCALE_NORMAL</code>, and <code>GL_TEXTURE_3D</code> are available only if the GL
        /// version is 1.2 or greater.
        /// <code>GL_MULTISAMPLE</code>,
        /// <code>GL_SAMPLE_ALPHA_TO_COVERAGE</code>,
        /// <code>GL_SAMPLE_ALPHA_TO_ONE</code>,
        /// <code>GL_SAMPLE_COVERAGE</code>,
        /// <code>GL_TEXTURE_CUBE_MAP</code>
        /// are available only if the GL version is 1.3 or greater.
        /// <code>GL_FOG_COORD_ARRAY</code> and <code>GL_SECONDARY_COLOR_ARRAY</code>
        /// are available only if the GL version is 1.4 or greater.
        /// <code>GL_POINT_SPRITE</code>,
        /// <code>GL_VERTEX_PROGRAM_POINT_SIZE</code>, and
        /// <code>GL_VERTEX_PROGRAM_TWO_SIDE</code>
        /// are available only if the GL version is 2.0 or greater.
        /// <code>GL_COLOR_TABLE</code>, <code>GL_CONVOLUTION_1D</code>, <code>GL_CONVOLUTION_2D</code>,
        /// <code>GL_HISTOGRAM</code>, <code>GL_MINMAX</code>,
        /// <code>GL_POST_COLOR_MATRIX_COLOR_TABLE</code>,
        /// <code>GL_POST_CONVOLUTION_COLOR_TABLE</code>, and
        /// <code>GL_SEPARABLE_2D</code> are available only if <code>ARB_imaging</code> is
        /// returned when  <see cref="glGet"/>  is called with <code>GL_EXTENSIONS</code>.
        /// For OpenGL versions 1.3 and greater, or when the <code>ARB_multitexture</code> extension is supported, the following
        /// parameters return the associated value for the active texture unit:
        /// <code>GL_TEXTURE_1D</code>,
        /// <code>GL_TEXTURE_2D</code>,
        /// <code>GL_TEXTURE_3D</code>,
        /// <code>GL_TEXTURE_CUBE_MAP</code>,
        /// <code>GL_TEXTURE_GEN_S</code>,
        /// <code>GL_TEXTURE_GEN_T</code>,
        /// <code>GL_TEXTURE_GEN_R</code>,
        /// <code>GL_TEXTURE_GEN_Q</code>,
        /// <code>GL_TEXTURE_MATRIX</code>, and
        /// <code>GL_TEXTURE_STACK_DEPTH</code>.
        /// Likewise, the following parameters return the associated value for the
        /// active client texture unit:
        /// <code>GL_TEXTURE_COORD_ARRAY</code>,
        /// <code>GL_TEXTURE_COORD_ARRAY_SIZE</code>,
        /// <code>GL_TEXTURE_COORD_ARRAY_STRIDE</code>,
        /// <code>GL_TEXTURE_COORD_ARRAY_TYPE</code>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="cap"/> is not an accepted value.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glIsEnabled"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>GLboolean glIsEnabled(GLenum cap);</para>
        /// </summary>
        /// <param name="cap">
        /// Specifies a symbolic constant indicating a GL capability.
        /// </param>
        /// <seealso cref="glEnable"/>
        /// <seealso cref="glEnableClientState"/>
        /// <seealso cref="glGet"/>
        public static bool glIsEnabled(uint cap) {
            var _F = _GetProc<GLNativeDelegate.FNglIsEnabled>("glIsEnabled");
            return _F(cap);
        }
        /// <summary>
        /// specify mapping of depth values from normalized device coordinates to window coordinates
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// It is not necessary that <paramref name="nearVal"/> be less than <paramref name="farVal"/>.
        /// Reverse mappings such as 
        /// nearVal 
        /// = 
        /// 1 
        /// ,
        /// and 
        /// farVal 
        /// = 
        /// 0 
        /// are acceptable.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glDepthRange"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glDepthRange(GLclampd nearVal, GLclampd farVal);</para>
        /// </summary>
        /// <param name="nearVal">
        /// <para>
        /// Specifies the mapping of the near clipping plane to window coordinates.
        /// The initial value is 0.
        /// </para>
        /// </param>
        /// <param name="farVal">
        /// <para>
        /// Specifies the mapping of the far clipping plane to window coordinates.
        /// The initial value is 1.
        /// </para>
        /// </param>
        /// <seealso cref="glDepthFunc"/>
        /// <seealso cref="glPolygonOffset"/>
        /// <seealso cref="glViewport"/>
        public static void glDepthRange(double nearVal, double farVal) {
            var _F = _GetProc<GLNativeDelegate.FNglDepthRange>("glDepthRange");
            _F(nearVal, farVal);
        }
        /// <summary>
        /// set the viewport
        /// <para>Require:</para> <para>GL_VERSION_1_0, GL_VERSION_ES_CM_1_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if either <paramref name="width"/> or <paramref name="height"/> is negative.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glViewport"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glViewport(GLint x, GLint y, GLsizei width, GLsizei height);</para>
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify the lower left corner of the viewport rectangle,
        /// in pixels. The initial value is (0,0).
        /// </para>
        /// </param>
        /// <param name="y">
        /// <para>
        /// Specify the lower left corner of the viewport rectangle,
        /// in pixels. The initial value is (0,0).
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// Specify the width and height
        /// of the viewport.
        /// When a GL context is first attached to a window,
        /// <paramref name="width"/> and <paramref name="height"/> are set to the dimensions of that
        /// window.
        /// </para>
        /// </param>
        /// <param name="height">
        /// <para>
        /// Specify the width and height
        /// of the viewport.
        /// When a GL context is first attached to a window,
        /// <paramref name="width"/> and <paramref name="height"/> are set to the dimensions of that
        /// window.
        /// </para>
        /// </param>
        /// <seealso cref="glDepthRange"/>
        public static void glViewport(int x, int y, int width, int height) {
            var _F = _GetProc<GLNativeDelegate.FNglViewport>("glViewport");
            _F(x, y, width, height);
        }
        /// <summary>
        /// create or replace a display list
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glCallList"/>  and  <see cref="glCallLists"/>  can be entered into display lists.
        /// Commands in the display list or lists executed by  <see cref="glCallList"/> 
        /// or  <see cref="glCallLists"/>  are not included in the display list being created,
        /// even if the list creation mode is <code>GL_COMPILE_AND_EXECUTE</code>.
        /// A display list is just a group of commands and arguments, so errors
        /// generated by commands in a display list must be generated when the list is
        /// executed. If the list is created in <code>GL_COMPILE</code> mode, errors are
        /// not generated until the list is executed.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="list"/> is 0.
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="mode"/> is not an accepted value.
        /// <code>GL_INVALID_OPERATION</code> is generated if  <see cref="glEndList"/>  is called
        /// without a preceding <see cref="glNewList"/>,
        /// or if <see cref="glNewList"/> is called while a display list is being defined.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glNewList"/> or  <see cref="glEndList"/> 
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// <code>GL_OUT_OF_MEMORY</code> is generated if there is insufficient memory to
        /// compile the display list. If the GL version is 1.1 or greater, no
        /// change is made to the previous contents of the display list, if any,
        /// and no other change is made to the GL state. (It is as if no attempt
        /// had been made to create the new display list.)
        /// </para>
        /// Original: <para>void glNewList(GLuint list, GLenum mode);</para>
        /// </summary>
        /// <param name="list">
        /// Specifies the display-list name.
        /// </param>
        /// <param name="mode">
        /// <para>
        /// Specifies the compilation mode,
        /// which can be
        /// <code>GL_COMPILE</code> or
        /// <code>GL_COMPILE_AND_EXECUTE</code>.
        /// </para>
        /// </param>
        /// <seealso cref="glCallList"/>
        /// <seealso cref="glCallLists"/>
        /// <seealso cref="glDeleteLists"/>
        /// <seealso cref="glGenLists"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void glNewList(uint list, uint mode) {
            var _F = _GetProc<GLNativeDelegate.FNglNewList>("glNewList");
            _F(list, mode);
        }
        /// <summary>
        /// create or replace a display list
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glCallList"/>  and  <see cref="glCallLists"/>  can be entered into display lists.
        /// Commands in the display list or lists executed by  <see cref="glCallList"/> 
        /// or  <see cref="glCallLists"/>  are not included in the display list being created,
        /// even if the list creation mode is <code>GL_COMPILE_AND_EXECUTE</code>.
        /// A display list is just a group of commands and arguments, so errors
        /// generated by commands in a display list must be generated when the list is
        /// executed. If the list is created in <code>GL_COMPILE</code> mode, errors are
        /// not generated until the list is executed.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="list"/> is 0.
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="mode"/> is not an accepted value.
        /// <code>GL_INVALID_OPERATION</code> is generated if  <see cref="glEndList"/>  is called
        /// without a preceding <see cref="glNewList"/>,
        /// or if <see cref="glNewList"/> is called while a display list is being defined.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glNewList"/> or  <see cref="glEndList"/> 
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// <code>GL_OUT_OF_MEMORY</code> is generated if there is insufficient memory to
        /// compile the display list. If the GL version is 1.1 or greater, no
        /// change is made to the previous contents of the display list, if any,
        /// and no other change is made to the GL state. (It is as if no attempt
        /// had been made to create the new display list.)
        /// </para>
        /// Original: <para>void glEndList();</para>
        /// </summary>
        /// <seealso cref="glCallList"/>
        /// <seealso cref="glCallLists"/>
        /// <seealso cref="glDeleteLists"/>
        /// <seealso cref="glGenLists"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void glEndList() {
            var _F = _GetProc<GLNativeDelegate.FNglEndList>("glEndList");
            _F();
        }
        /// <summary>
        /// execute a display list
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// Display lists can be executed between a call to  <see cref="glBegin"/> 
        /// and the corresponding call to  <see cref="glEnd"/> ,
        /// as long as the display list includes only commands that are allowed
        /// in this interval.
        /// </para>
        /// Original: <para>void glCallList(GLuint list);</para>
        /// </summary>
        /// <param name="list">
        /// Specifies the integer name of the display list to be executed.
        /// </param>
        /// <seealso cref="glCallLists"/>
        /// <seealso cref="glDeleteLists"/>
        /// <seealso cref="glGenLists"/>
        /// <seealso cref="glNewList"/>
        /// <seealso cref="glPushAttrib"/>
        /// <seealso cref="glPushMatrix"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void glCallList(uint list) {
            var _F = _GetProc<GLNativeDelegate.FNglCallList>("glCallList");
            _F(list);
        }
        /// <summary>
        /// execute a list of display lists
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// Display lists can be executed between a call to  <see cref="glBegin"/> 
        /// and the corresponding call to  <see cref="glEnd"/> ,
        /// as long as the display list includes only commands that are allowed
        /// in this interval.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="n"/> is negative.
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="type"/> is not one of
        /// <code>GL_BYTE</code>,
        /// <code>GL_UNSIGNED_BYTE</code>,
        /// <code>GL_SHORT</code>,
        /// <code>GL_UNSIGNED_SHORT</code>,
        /// <code>GL_INT</code>,
        /// <code>GL_UNSIGNED_INT</code>,
        /// <code>GL_FLOAT</code>,
        /// <code>GL_2_BYTES</code>,
        /// <code>GL_3_BYTES</code>,
        /// <code>GL_4_BYTES</code>.
        /// </para>
        /// Original: <para>void glCallLists(GLsizei n, GLenum type, const void * lists);</para>
        /// </summary>
        /// <param name="n">
        /// Specifies the number of display lists to be executed.
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the type of values in <paramref name="lists"/>.
        /// Symbolic constants
        /// <code>GL_BYTE</code>,
        /// <code>GL_UNSIGNED_BYTE</code>,
        /// <code>GL_SHORT</code>,
        /// <code>GL_UNSIGNED_SHORT</code>,
        /// <code>GL_INT</code>,
        /// <code>GL_UNSIGNED_INT</code>,
        /// <code>GL_FLOAT</code>,
        /// <code>GL_2_BYTES</code>,
        /// <code>GL_3_BYTES</code>, and
        /// <code>GL_4_BYTES</code> are accepted.
        /// </para>
        /// </param>
        /// <param name="lists">
        /// <para>
        /// Specifies the address of an array of name offsets in the display list.
        /// The pointer type is void because the offsets can be bytes,
        /// shorts,
        /// ints,
        /// or floats,
        /// depending on the value of <paramref name="type"/>.
        /// </para>
        /// </param>
        /// <seealso cref="glCallList"/>
        /// <seealso cref="glDeleteLists"/>
        /// <seealso cref="glGenLists"/>
        /// <seealso cref="glListBase"/>
        /// <seealso cref="glNewList"/>
        /// <seealso cref="glPushAttrib"/>
        /// <seealso cref="glPushMatrix"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void glCallLists(int n, uint type, void* lists) {
            var _F = _GetProc<GLNativeDelegate.FNglCallLists>("glCallLists");
            _F(n, type, lists);
        }
        /// <summary>
        /// delete a contiguous group of display lists
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="range"/> is negative.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glDeleteLists"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glDeleteLists(GLuint list, GLsizei range);</para>
        /// </summary>
        /// <param name="list">
        /// Specifies the integer name of the first display list to delete.
        /// </param>
        /// <param name="range">
        /// Specifies the number of display lists to delete.
        /// </param>
        /// <seealso cref="glCallList"/>
        /// <seealso cref="glCallLists"/>
        /// <seealso cref="glGenLists"/>
        /// <seealso cref="glIsList"/>
        /// <seealso cref="glNewList"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void glDeleteLists(uint list, int range) {
            var _F = _GetProc<GLNativeDelegate.FNglDeleteLists>("glDeleteLists");
            _F(list, range);
        }
        /// <summary>
        /// generate a contiguous set of empty display lists
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="range"/> is negative.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glGenLists"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>GLuint glGenLists(GLsizei range);</para>
        /// </summary>
        /// <param name="range">
        /// <para>
        /// Specifies the number of contiguous empty display lists
        /// to be generated.
        /// </para>
        /// </param>
        /// <seealso cref="glCallList"/>
        /// <seealso cref="glCallLists"/>
        /// <seealso cref="glDeleteLists"/>
        /// <seealso cref="glNewList"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static uint glGenLists(int range) {
            var _F = _GetProc<GLNativeDelegate.FNglGenLists>("glGenLists");
            return _F(range);
        }
        /// <summary>
        /// set the display-list base for  <see cref="glCallLists"/>
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glListBase"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glListBase(GLuint base);</para>
        /// </summary>
        /// <param name="b">
        /// <para>
        /// Specifies an integer offset that will be added to  <see cref="glCallLists"/> 
        /// offsets to generate display-list names.
        /// The initial value is 0.
        /// </para>
        /// </param>
        /// <seealso cref="glCallLists"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void glListBase(uint b) {
            var _F = _GetProc<GLNativeDelegate.FNglListBase>("glListBase");
            _F(b);
        }
        /// <summary>
        /// delimit the vertices of a primitive or a group of like primitives
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="mode"/> is set to an unaccepted value.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glBegin"/> is executed between a
        /// <see cref="glBegin"/>
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// <code>GL_INVALID_OPERATION</code> is generated if  <see cref="glEnd"/>  is executed without being
        /// preceded by a <see cref="glBegin"/>.
        /// <code>GL_INVALID_OPERATION</code> is generated if a command other than
        /// <see cref="glVertex"/> ,
        /// <see cref="glColor"/> ,
        /// <see cref="glSecondaryColor"/> ,
        /// <see cref="glIndex"/> ,
        /// <see cref="glNormal"/> ,
        /// <see cref="glFogCoord"/> ,
        /// <see cref="glTexCoord"/> ,
        /// <see cref="glMultiTexCoord"/> ,
        /// <see cref="glVertexAttrib"/> ,
        /// <see cref="glEvalCoord"/> ,
        /// <see cref="glEvalPoint"/> ,
        /// <see cref="glArrayElement"/> ,
        /// <see cref="glMaterial"/> ,
        /// <see cref="glEdgeFlag"/> ,
        /// <see cref="glCallList"/> , or
        /// <see cref="glCallLists"/>  is executed between
        /// the execution of <see cref="glBegin"/> and the corresponding
        /// execution  <see cref="glEnd"/> .
        /// Execution of
        /// <see cref="glEnableClientState"/> ,
        /// <see cref="glDisableClientState"/> ,
        /// <see cref="glEdgeFlagPointer"/> ,
        /// <see cref="glFogCoordPointer"/> ,
        /// <see cref="glTexCoordPointer"/> ,
        /// <see cref="glColorPointer"/> ,
        /// <see cref="glSecondaryColorPointer"/> ,
        /// <see cref="glIndexPointer"/> ,
        /// <see cref="glNormalPointer"/> ,
        /// <see cref="glVertexPointer"/> ,
        /// <see cref="glVertexAttribPointer"/> ,
        /// <see cref="glInterleavedArrays"/> , or
        /// <see cref="glPixelStore"/>  is not allowed after a call to <see cref="glBegin"/> and before
        /// the corresponding call to  <see cref="glEnd"/> ,
        /// but an error may or may not be generated.
        /// </para>
        /// Original: <para>void glBegin(GLenum mode);</para>
        /// </summary>
        /// <param name="mode">
        /// <para>
        /// Specifies the primitive or primitives that will be created from vertices
        /// presented between <see cref="glBegin"/> and the subsequent  <see cref="glEnd"/> .
        /// Ten symbolic constants are accepted:
        /// <code>GL_POINTS</code>,
        /// <code>GL_LINES</code>,
        /// <code>GL_LINE_STRIP</code>,
        /// <code>GL_LINE_LOOP</code>,
        /// <code>GL_TRIANGLES</code>,
        /// <code>GL_TRIANGLE_STRIP</code>,
        /// <code>GL_TRIANGLE_FAN</code>,
        /// <code>GL_QUADS</code>,
        /// <code>GL_QUAD_STRIP</code>, and
        /// <code>GL_POLYGON</code>.
        /// </para>
        /// </param>
        /// <seealso cref="glArrayElement"/>
        /// <seealso cref="glCallList"/>
        /// <seealso cref="glCallLists"/>
        /// <seealso cref="glColor"/>
        /// <seealso cref="glEdgeFlag"/>
        /// <seealso cref="glEvalCoord"/>
        /// <seealso cref="glEvalPoint"/>
        /// <seealso cref="glFogCoord"/>
        /// <seealso cref="glIndex"/>
        /// <seealso cref="glMaterial"/>
        /// <seealso cref="glMultiTexCoord"/>
        /// <seealso cref="glNormal"/>
        /// <seealso cref="glSecondaryColor"/>
        /// <seealso cref="glTexCoord"/>
        /// <seealso cref="glVertex"/>
        /// <seealso cref="glVertexAttrib"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void glBegin(uint mode) {
            var _F = _GetProc<GLNativeDelegate.FNglBegin>("glBegin");
            _F(mode);
        }
        /// <summary>
        /// draw a bitmap
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// To set a valid raster position outside the viewport, first set a valid
        /// raster position inside the viewport, then call <see cref="glBitmap"/> with NULL
        /// as the <paramref name="bitmap"/> parameter and with <paramref name="xmove"/> and <paramref name="ymove"/> set to
        /// the offsets of the new raster position. This technique is useful when
        /// panning an image around the viewport.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="width"/> or <paramref name="height"/> is negative.
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_UNPACK_BUFFER</code> target and the buffer object's data store is currently mapped.
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_UNPACK_BUFFER</code> target and the data would be unpacked from the buffer 
        /// object such that the memory reads required would exceed the data store size.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glBitmap"/>
        /// is executed between the execution of  <see cref="glBegin"/>  and the corresponding execution of
        /// <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glBitmap(GLsizei width, GLsizei height, GLfloat xorig, GLfloat yorig, GLfloat xmove, GLfloat ymove, const GLubyte * bitmap);</para>
        /// </summary>
        /// <param name="width">
        /// Specify the pixel width and height of the bitmap image.
        /// </param>
        /// <param name="height">
        /// Specify the pixel width and height of the bitmap image.
        /// </param>
        /// <param name="xorig">
        /// <para>
        /// Specify the location of the origin in the bitmap image.
        /// The origin is measured from the lower left corner of the bitmap,
        /// with right and up being the positive axes.
        /// </para>
        /// </param>
        /// <param name="yorig">
        /// <para>
        /// Specify the location of the origin in the bitmap image.
        /// The origin is measured from the lower left corner of the bitmap,
        /// with right and up being the positive axes.
        /// </para>
        /// </param>
        /// <param name="xmove">
        /// <para>
        /// Specify the  x  and  y  offsets to be added to the current raster position
        /// after the bitmap is drawn.
        /// </para>
        /// </param>
        /// <param name="ymove">
        /// <para>
        /// Specify the  x  and  y  offsets to be added to the current raster position
        /// after the bitmap is drawn.
        /// </para>
        /// </param>
        /// <param name="bitmap">
        /// Specifies the address of the bitmap image.
        /// </param>
        /// <seealso cref="glBindBuffer"/>
        /// <seealso cref="glDrawPixels"/>
        /// <seealso cref="glPixelStore"/>
        /// <seealso cref="glPixelTransfer"/>
        /// <seealso cref="glRasterPos"/>
        /// <seealso cref="glWindowPos"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void glBitmap(int width, int height, float xorig, float yorig, float xmove, float ymove, byte* bitmap) {
            var _F = _GetProc<GLNativeDelegate.FNglBitmap>("glBitmap");
            _F(width, height, xorig, yorig, xmove, ymove, bitmap);
        }
        /// <summary>
        /// set the current color
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The initial value for the current color is (1, 1, 1, 1).
        /// The current color can be updated at any time.
        /// In particular,
        /// <see cref="glColor"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glColor3b(GLbyte red, GLbyte green, GLbyte blue);</para>
        /// </summary>
        /// <param name="red">
        /// Specify new red, green, and blue values for the current color.
        /// </param>
        /// <param name="green">
        /// Specify new red, green, and blue values for the current color.
        /// </param>
        /// <param name="blue">
        /// Specify new red, green, and blue values for the current color.
        /// </param>
        /// <seealso cref="glColorPointer"/>
        /// <seealso cref="glIndex"/>
        /// <seealso cref="glSecondaryColor"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void glColor3b(byte red, byte green, byte blue) {
            var _F = _GetProc<GLNativeDelegate.FNglColor3b>("glColor3b");
            _F(red, green, blue);
        }
        /// <summary>
        /// set the current color
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The initial value for the current color is (1, 1, 1, 1).
        /// The current color can be updated at any time.
        /// In particular,
        /// <see cref="glColor"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glColor3bv(const GLbyte * v);</para>
        /// </summary>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array that contains red, green, blue,
        /// and (sometimes) alpha values.
        /// </para>
        /// </param>
        /// <seealso cref="glColorPointer"/>
        /// <seealso cref="glIndex"/>
        /// <seealso cref="glSecondaryColor"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void glColor3bv(byte* v) {
            var _F = _GetProc<GLNativeDelegate.FNglColor3bv>("glColor3bv");
            _F(v);
        }
        /// <summary>
        /// set the current color
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The initial value for the current color is (1, 1, 1, 1).
        /// The current color can be updated at any time.
        /// In particular,
        /// <see cref="glColor"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glColor3d(GLdouble red, GLdouble green, GLdouble blue);</para>
        /// </summary>
        /// <param name="red">
        /// Specify new red, green, and blue values for the current color.
        /// </param>
        /// <param name="green">
        /// Specify new red, green, and blue values for the current color.
        /// </param>
        /// <param name="blue">
        /// Specify new red, green, and blue values for the current color.
        /// </param>
        /// <seealso cref="glColorPointer"/>
        /// <seealso cref="glIndex"/>
        /// <seealso cref="glSecondaryColor"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void glColor3d(double red, double green, double blue) {
            var _F = _GetProc<GLNativeDelegate.FNglColor3d>("glColor3d");
            _F(red, green, blue);
        }
        /// <summary>
        /// set the current color
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The initial value for the current color is (1, 1, 1, 1).
        /// The current color can be updated at any time.
        /// In particular,
        /// <see cref="glColor"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glColor3dv(const GLdouble * v);</para>
        /// </summary>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array that contains red, green, blue,
        /// and (sometimes) alpha values.
        /// </para>
        /// </param>
        /// <seealso cref="glColorPointer"/>
        /// <seealso cref="glIndex"/>
        /// <seealso cref="glSecondaryColor"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void glColor3dv(double* v) {
            var _F = _GetProc<GLNativeDelegate.FNglColor3dv>("glColor3dv");
            _F(v);
        }
        /// <summary>
        /// set the current color
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The initial value for the current color is (1, 1, 1, 1).
        /// The current color can be updated at any time.
        /// In particular,
        /// <see cref="glColor"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glColor3f(GLfloat red, GLfloat green, GLfloat blue);</para>
        /// </summary>
        /// <param name="red">
        /// Specify new red, green, and blue values for the current color.
        /// </param>
        /// <param name="green">
        /// Specify new red, green, and blue values for the current color.
        /// </param>
        /// <param name="blue">
        /// Specify new red, green, and blue values for the current color.
        /// </param>
        /// <seealso cref="glColorPointer"/>
        /// <seealso cref="glIndex"/>
        /// <seealso cref="glSecondaryColor"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void glColor3f(float red, float green, float blue) {
            var _F = _GetProc<GLNativeDelegate.FNglColor3f>("glColor3f");
            _F(red, green, blue);
        }
        /// <summary>
        /// set the current color
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The initial value for the current color is (1, 1, 1, 1).
        /// The current color can be updated at any time.
        /// In particular,
        /// <see cref="glColor"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glColor3fv(const GLfloat * v);</para>
        /// </summary>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array that contains red, green, blue,
        /// and (sometimes) alpha values.
        /// </para>
        /// </param>
        /// <seealso cref="glColorPointer"/>
        /// <seealso cref="glIndex"/>
        /// <seealso cref="glSecondaryColor"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void glColor3fv(float* v) {
            var _F = _GetProc<GLNativeDelegate.FNglColor3fv>("glColor3fv");
            _F(v);
        }
        /// <summary>
        /// set the current color
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The initial value for the current color is (1, 1, 1, 1).
        /// The current color can be updated at any time.
        /// In particular,
        /// <see cref="glColor"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glColor3i(GLint red, GLint green, GLint blue);</para>
        /// </summary>
        /// <param name="red">
        /// Specify new red, green, and blue values for the current color.
        /// </param>
        /// <param name="green">
        /// Specify new red, green, and blue values for the current color.
        /// </param>
        /// <param name="blue">
        /// Specify new red, green, and blue values for the current color.
        /// </param>
        /// <seealso cref="glColorPointer"/>
        /// <seealso cref="glIndex"/>
        /// <seealso cref="glSecondaryColor"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void glColor3i(int red, int green, int blue) {
            var _F = _GetProc<GLNativeDelegate.FNglColor3i>("glColor3i");
            _F(red, green, blue);
        }
        /// <summary>
        /// set the current color
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The initial value for the current color is (1, 1, 1, 1).
        /// The current color can be updated at any time.
        /// In particular,
        /// <see cref="glColor"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glColor3iv(const GLint * v);</para>
        /// </summary>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array that contains red, green, blue,
        /// and (sometimes) alpha values.
        /// </para>
        /// </param>
        /// <seealso cref="glColorPointer"/>
        /// <seealso cref="glIndex"/>
        /// <seealso cref="glSecondaryColor"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void glColor3iv(int* v) {
            var _F = _GetProc<GLNativeDelegate.FNglColor3iv>("glColor3iv");
            _F(v);
        }
        /// <summary>
        /// set the current color
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The initial value for the current color is (1, 1, 1, 1).
        /// The current color can be updated at any time.
        /// In particular,
        /// <see cref="glColor"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glColor3s(GLshort red, GLshort green, GLshort blue);</para>
        /// </summary>
        /// <param name="red">
        /// Specify new red, green, and blue values for the current color.
        /// </param>
        /// <param name="green">
        /// Specify new red, green, and blue values for the current color.
        /// </param>
        /// <param name="blue">
        /// Specify new red, green, and blue values for the current color.
        /// </param>
        /// <seealso cref="glColorPointer"/>
        /// <seealso cref="glIndex"/>
        /// <seealso cref="glSecondaryColor"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void glColor3s(short red, short green, short blue) {
            var _F = _GetProc<GLNativeDelegate.FNglColor3s>("glColor3s");
            _F(red, green, blue);
        }
        /// <summary>
        /// set the current color
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The initial value for the current color is (1, 1, 1, 1).
        /// The current color can be updated at any time.
        /// In particular,
        /// <see cref="glColor"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glColor3sv(const GLshort * v);</para>
        /// </summary>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array that contains red, green, blue,
        /// and (sometimes) alpha values.
        /// </para>
        /// </param>
        /// <seealso cref="glColorPointer"/>
        /// <seealso cref="glIndex"/>
        /// <seealso cref="glSecondaryColor"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void glColor3sv(short* v) {
            var _F = _GetProc<GLNativeDelegate.FNglColor3sv>("glColor3sv");
            _F(v);
        }
        /// <summary>
        /// set the current color
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The initial value for the current color is (1, 1, 1, 1).
        /// The current color can be updated at any time.
        /// In particular,
        /// <see cref="glColor"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glColor3ub(GLubyte red, GLubyte green, GLubyte blue);</para>
        /// </summary>
        /// <param name="red">
        /// Specify new red, green, and blue values for the current color.
        /// </param>
        /// <param name="green">
        /// Specify new red, green, and blue values for the current color.
        /// </param>
        /// <param name="blue">
        /// Specify new red, green, and blue values for the current color.
        /// </param>
        /// <seealso cref="glColorPointer"/>
        /// <seealso cref="glIndex"/>
        /// <seealso cref="glSecondaryColor"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void glColor3ub(byte red, byte green, byte blue) {
            var _F = _GetProc<GLNativeDelegate.FNglColor3ub>("glColor3ub");
            _F(red, green, blue);
        }
        /// <summary>
        /// set the current color
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The initial value for the current color is (1, 1, 1, 1).
        /// The current color can be updated at any time.
        /// In particular,
        /// <see cref="glColor"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glColor3ubv(const GLubyte * v);</para>
        /// </summary>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array that contains red, green, blue,
        /// and (sometimes) alpha values.
        /// </para>
        /// </param>
        /// <seealso cref="glColorPointer"/>
        /// <seealso cref="glIndex"/>
        /// <seealso cref="glSecondaryColor"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void glColor3ubv(byte* v) {
            var _F = _GetProc<GLNativeDelegate.FNglColor3ubv>("glColor3ubv");
            _F(v);
        }
        /// <summary>
        /// set the current color
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The initial value for the current color is (1, 1, 1, 1).
        /// The current color can be updated at any time.
        /// In particular,
        /// <see cref="glColor"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glColor3ui(GLuint red, GLuint green, GLuint blue);</para>
        /// </summary>
        /// <param name="red">
        /// Specify new red, green, and blue values for the current color.
        /// </param>
        /// <param name="green">
        /// Specify new red, green, and blue values for the current color.
        /// </param>
        /// <param name="blue">
        /// Specify new red, green, and blue values for the current color.
        /// </param>
        /// <seealso cref="glColorPointer"/>
        /// <seealso cref="glIndex"/>
        /// <seealso cref="glSecondaryColor"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void glColor3ui(uint red, uint green, uint blue) {
            var _F = _GetProc<GLNativeDelegate.FNglColor3ui>("glColor3ui");
            _F(red, green, blue);
        }
        /// <summary>
        /// set the current color
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The initial value for the current color is (1, 1, 1, 1).
        /// The current color can be updated at any time.
        /// In particular,
        /// <see cref="glColor"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glColor3uiv(const GLuint * v);</para>
        /// </summary>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array that contains red, green, blue,
        /// and (sometimes) alpha values.
        /// </para>
        /// </param>
        /// <seealso cref="glColorPointer"/>
        /// <seealso cref="glIndex"/>
        /// <seealso cref="glSecondaryColor"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void glColor3uiv(uint* v) {
            var _F = _GetProc<GLNativeDelegate.FNglColor3uiv>("glColor3uiv");
            _F(v);
        }
        /// <summary>
        /// set the current color
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The initial value for the current color is (1, 1, 1, 1).
        /// The current color can be updated at any time.
        /// In particular,
        /// <see cref="glColor"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glColor3us(GLushort red, GLushort green, GLushort blue);</para>
        /// </summary>
        /// <param name="red">
        /// Specify new red, green, and blue values for the current color.
        /// </param>
        /// <param name="green">
        /// Specify new red, green, and blue values for the current color.
        /// </param>
        /// <param name="blue">
        /// Specify new red, green, and blue values for the current color.
        /// </param>
        /// <seealso cref="glColorPointer"/>
        /// <seealso cref="glIndex"/>
        /// <seealso cref="glSecondaryColor"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void glColor3us(ushort red, ushort green, ushort blue) {
            var _F = _GetProc<GLNativeDelegate.FNglColor3us>("glColor3us");
            _F(red, green, blue);
        }
        /// <summary>
        /// set the current color
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The initial value for the current color is (1, 1, 1, 1).
        /// The current color can be updated at any time.
        /// In particular,
        /// <see cref="glColor"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glColor3usv(const GLushort * v);</para>
        /// </summary>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array that contains red, green, blue,
        /// and (sometimes) alpha values.
        /// </para>
        /// </param>
        /// <seealso cref="glColorPointer"/>
        /// <seealso cref="glIndex"/>
        /// <seealso cref="glSecondaryColor"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void glColor3usv(ushort* v) {
            var _F = _GetProc<GLNativeDelegate.FNglColor3usv>("glColor3usv");
            _F(v);
        }
        /// <summary>
        /// set the current color
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The initial value for the current color is (1, 1, 1, 1).
        /// The current color can be updated at any time.
        /// In particular,
        /// <see cref="glColor"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glColor4b(GLbyte red, GLbyte green, GLbyte blue, GLbyte alpha);</para>
        /// </summary>
        /// <param name="red">
        /// Specify new red, green, and blue values for the current color.
        /// </param>
        /// <param name="green">
        /// Specify new red, green, and blue values for the current color.
        /// </param>
        /// <param name="blue">
        /// Specify new red, green, and blue values for the current color.
        /// </param>
        /// <param name="alpha">
        /// <para>
        /// Specifies a new alpha value for the current color.
        /// Included only in the four-argument <see cref="glColor4"/> commands.
        /// </para>
        /// </param>
        /// <seealso cref="glColorPointer"/>
        /// <seealso cref="glIndex"/>
        /// <seealso cref="glSecondaryColor"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void glColor4b(byte red, byte green, byte blue, byte alpha) {
            var _F = _GetProc<GLNativeDelegate.FNglColor4b>("glColor4b");
            _F(red, green, blue, alpha);
        }
        /// <summary>
        /// set the current color
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The initial value for the current color is (1, 1, 1, 1).
        /// The current color can be updated at any time.
        /// In particular,
        /// <see cref="glColor"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glColor4bv(const GLbyte * v);</para>
        /// </summary>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array that contains red, green, blue,
        /// and (sometimes) alpha values.
        /// </para>
        /// </param>
        /// <seealso cref="glColorPointer"/>
        /// <seealso cref="glIndex"/>
        /// <seealso cref="glSecondaryColor"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void glColor4bv(byte* v) {
            var _F = _GetProc<GLNativeDelegate.FNglColor4bv>("glColor4bv");
            _F(v);
        }
        /// <summary>
        /// set the current color
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The initial value for the current color is (1, 1, 1, 1).
        /// The current color can be updated at any time.
        /// In particular,
        /// <see cref="glColor"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glColor4d(GLdouble red, GLdouble green, GLdouble blue, GLdouble alpha);</para>
        /// </summary>
        /// <param name="red">
        /// Specify new red, green, and blue values for the current color.
        /// </param>
        /// <param name="green">
        /// Specify new red, green, and blue values for the current color.
        /// </param>
        /// <param name="blue">
        /// Specify new red, green, and blue values for the current color.
        /// </param>
        /// <param name="alpha">
        /// <para>
        /// Specifies a new alpha value for the current color.
        /// Included only in the four-argument <see cref="glColor4"/> commands.
        /// </para>
        /// </param>
        /// <seealso cref="glColorPointer"/>
        /// <seealso cref="glIndex"/>
        /// <seealso cref="glSecondaryColor"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void glColor4d(double red, double green, double blue, double alpha) {
            var _F = _GetProc<GLNativeDelegate.FNglColor4d>("glColor4d");
            _F(red, green, blue, alpha);
        }
        /// <summary>
        /// set the current color
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The initial value for the current color is (1, 1, 1, 1).
        /// The current color can be updated at any time.
        /// In particular,
        /// <see cref="glColor"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glColor4dv(const GLdouble * v);</para>
        /// </summary>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array that contains red, green, blue,
        /// and (sometimes) alpha values.
        /// </para>
        /// </param>
        /// <seealso cref="glColorPointer"/>
        /// <seealso cref="glIndex"/>
        /// <seealso cref="glSecondaryColor"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void glColor4dv(double* v) {
            var _F = _GetProc<GLNativeDelegate.FNglColor4dv>("glColor4dv");
            _F(v);
        }
        /// <summary>
        /// set the current color
        /// <para>Require:</para> <para>GL_VERSION_1_0, GL_VERSION_ES_CM_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The initial value for the current color is (1, 1, 1, 1).
        /// The current color can be updated at any time.
        /// In particular,
        /// <see cref="glColor"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glColor4f(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha);</para>
        /// </summary>
        /// <param name="red">
        /// Specify new red, green, and blue values for the current color.
        /// </param>
        /// <param name="green">
        /// Specify new red, green, and blue values for the current color.
        /// </param>
        /// <param name="blue">
        /// Specify new red, green, and blue values for the current color.
        /// </param>
        /// <param name="alpha">
        /// <para>
        /// Specifies a new alpha value for the current color.
        /// Included only in the four-argument <see cref="glColor4"/> commands.
        /// </para>
        /// </param>
        /// <seealso cref="glColorPointer"/>
        /// <seealso cref="glIndex"/>
        /// <seealso cref="glSecondaryColor"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void glColor4f(float red, float green, float blue, float alpha) {
            var _F = _GetProc<GLNativeDelegate.FNglColor4f>("glColor4f");
            _F(red, green, blue, alpha);
        }
        /// <summary>
        /// set the current color
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The initial value for the current color is (1, 1, 1, 1).
        /// The current color can be updated at any time.
        /// In particular,
        /// <see cref="glColor"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glColor4fv(const GLfloat * v);</para>
        /// </summary>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array that contains red, green, blue,
        /// and (sometimes) alpha values.
        /// </para>
        /// </param>
        /// <seealso cref="glColorPointer"/>
        /// <seealso cref="glIndex"/>
        /// <seealso cref="glSecondaryColor"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void glColor4fv(float* v) {
            var _F = _GetProc<GLNativeDelegate.FNglColor4fv>("glColor4fv");
            _F(v);
        }
        /// <summary>
        /// set the current color
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The initial value for the current color is (1, 1, 1, 1).
        /// The current color can be updated at any time.
        /// In particular,
        /// <see cref="glColor"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glColor4i(GLint red, GLint green, GLint blue, GLint alpha);</para>
        /// </summary>
        /// <param name="red">
        /// Specify new red, green, and blue values for the current color.
        /// </param>
        /// <param name="green">
        /// Specify new red, green, and blue values for the current color.
        /// </param>
        /// <param name="blue">
        /// Specify new red, green, and blue values for the current color.
        /// </param>
        /// <param name="alpha">
        /// <para>
        /// Specifies a new alpha value for the current color.
        /// Included only in the four-argument <see cref="glColor4"/> commands.
        /// </para>
        /// </param>
        /// <seealso cref="glColorPointer"/>
        /// <seealso cref="glIndex"/>
        /// <seealso cref="glSecondaryColor"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void glColor4i(int red, int green, int blue, int alpha) {
            var _F = _GetProc<GLNativeDelegate.FNglColor4i>("glColor4i");
            _F(red, green, blue, alpha);
        }
        /// <summary>
        /// set the current color
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The initial value for the current color is (1, 1, 1, 1).
        /// The current color can be updated at any time.
        /// In particular,
        /// <see cref="glColor"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glColor4iv(const GLint * v);</para>
        /// </summary>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array that contains red, green, blue,
        /// and (sometimes) alpha values.
        /// </para>
        /// </param>
        /// <seealso cref="glColorPointer"/>
        /// <seealso cref="glIndex"/>
        /// <seealso cref="glSecondaryColor"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void glColor4iv(int* v) {
            var _F = _GetProc<GLNativeDelegate.FNglColor4iv>("glColor4iv");
            _F(v);
        }
        /// <summary>
        /// set the current color
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The initial value for the current color is (1, 1, 1, 1).
        /// The current color can be updated at any time.
        /// In particular,
        /// <see cref="glColor"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glColor4s(GLshort red, GLshort green, GLshort blue, GLshort alpha);</para>
        /// </summary>
        /// <param name="red">
        /// Specify new red, green, and blue values for the current color.
        /// </param>
        /// <param name="green">
        /// Specify new red, green, and blue values for the current color.
        /// </param>
        /// <param name="blue">
        /// Specify new red, green, and blue values for the current color.
        /// </param>
        /// <param name="alpha">
        /// <para>
        /// Specifies a new alpha value for the current color.
        /// Included only in the four-argument <see cref="glColor4"/> commands.
        /// </para>
        /// </param>
        /// <seealso cref="glColorPointer"/>
        /// <seealso cref="glIndex"/>
        /// <seealso cref="glSecondaryColor"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void glColor4s(short red, short green, short blue, short alpha) {
            var _F = _GetProc<GLNativeDelegate.FNglColor4s>("glColor4s");
            _F(red, green, blue, alpha);
        }
        /// <summary>
        /// set the current color
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The initial value for the current color is (1, 1, 1, 1).
        /// The current color can be updated at any time.
        /// In particular,
        /// <see cref="glColor"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glColor4sv(const GLshort * v);</para>
        /// </summary>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array that contains red, green, blue,
        /// and (sometimes) alpha values.
        /// </para>
        /// </param>
        /// <seealso cref="glColorPointer"/>
        /// <seealso cref="glIndex"/>
        /// <seealso cref="glSecondaryColor"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void glColor4sv(short* v) {
            var _F = _GetProc<GLNativeDelegate.FNglColor4sv>("glColor4sv");
            _F(v);
        }
        /// <summary>
        /// set the current color
        /// <para>Require:</para> <para>GL_VERSION_1_0, GL_VERSION_ES_CM_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The initial value for the current color is (1, 1, 1, 1).
        /// The current color can be updated at any time.
        /// In particular,
        /// <see cref="glColor"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glColor4ub(GLubyte red, GLubyte green, GLubyte blue, GLubyte alpha);</para>
        /// </summary>
        /// <param name="red">
        /// Specify new red, green, and blue values for the current color.
        /// </param>
        /// <param name="green">
        /// Specify new red, green, and blue values for the current color.
        /// </param>
        /// <param name="blue">
        /// Specify new red, green, and blue values for the current color.
        /// </param>
        /// <param name="alpha">
        /// <para>
        /// Specifies a new alpha value for the current color.
        /// Included only in the four-argument <see cref="glColor4"/> commands.
        /// </para>
        /// </param>
        /// <seealso cref="glColorPointer"/>
        /// <seealso cref="glIndex"/>
        /// <seealso cref="glSecondaryColor"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void glColor4ub(byte red, byte green, byte blue, byte alpha) {
            var _F = _GetProc<GLNativeDelegate.FNglColor4ub>("glColor4ub");
            _F(red, green, blue, alpha);
        }
        /// <summary>
        /// set the current color
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The initial value for the current color is (1, 1, 1, 1).
        /// The current color can be updated at any time.
        /// In particular,
        /// <see cref="glColor"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glColor4ubv(const GLubyte * v);</para>
        /// </summary>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array that contains red, green, blue,
        /// and (sometimes) alpha values.
        /// </para>
        /// </param>
        /// <seealso cref="glColorPointer"/>
        /// <seealso cref="glIndex"/>
        /// <seealso cref="glSecondaryColor"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void glColor4ubv(byte* v) {
            var _F = _GetProc<GLNativeDelegate.FNglColor4ubv>("glColor4ubv");
            _F(v);
        }
        /// <summary>
        /// set the current color
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The initial value for the current color is (1, 1, 1, 1).
        /// The current color can be updated at any time.
        /// In particular,
        /// <see cref="glColor"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glColor4ui(GLuint red, GLuint green, GLuint blue, GLuint alpha);</para>
        /// </summary>
        /// <param name="red">
        /// Specify new red, green, and blue values for the current color.
        /// </param>
        /// <param name="green">
        /// Specify new red, green, and blue values for the current color.
        /// </param>
        /// <param name="blue">
        /// Specify new red, green, and blue values for the current color.
        /// </param>
        /// <param name="alpha">
        /// <para>
        /// Specifies a new alpha value for the current color.
        /// Included only in the four-argument <see cref="glColor4"/> commands.
        /// </para>
        /// </param>
        /// <seealso cref="glColorPointer"/>
        /// <seealso cref="glIndex"/>
        /// <seealso cref="glSecondaryColor"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void glColor4ui(uint red, uint green, uint blue, uint alpha) {
            var _F = _GetProc<GLNativeDelegate.FNglColor4ui>("glColor4ui");
            _F(red, green, blue, alpha);
        }
        /// <summary>
        /// set the current color
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The initial value for the current color is (1, 1, 1, 1).
        /// The current color can be updated at any time.
        /// In particular,
        /// <see cref="glColor"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glColor4uiv(const GLuint * v);</para>
        /// </summary>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array that contains red, green, blue,
        /// and (sometimes) alpha values.
        /// </para>
        /// </param>
        /// <seealso cref="glColorPointer"/>
        /// <seealso cref="glIndex"/>
        /// <seealso cref="glSecondaryColor"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void glColor4uiv(uint* v) {
            var _F = _GetProc<GLNativeDelegate.FNglColor4uiv>("glColor4uiv");
            _F(v);
        }
        /// <summary>
        /// set the current color
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The initial value for the current color is (1, 1, 1, 1).
        /// The current color can be updated at any time.
        /// In particular,
        /// <see cref="glColor"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glColor4us(GLushort red, GLushort green, GLushort blue, GLushort alpha);</para>
        /// </summary>
        /// <param name="red">
        /// Specify new red, green, and blue values for the current color.
        /// </param>
        /// <param name="green">
        /// Specify new red, green, and blue values for the current color.
        /// </param>
        /// <param name="blue">
        /// Specify new red, green, and blue values for the current color.
        /// </param>
        /// <param name="alpha">
        /// <para>
        /// Specifies a new alpha value for the current color.
        /// Included only in the four-argument <see cref="glColor4"/> commands.
        /// </para>
        /// </param>
        /// <seealso cref="glColorPointer"/>
        /// <seealso cref="glIndex"/>
        /// <seealso cref="glSecondaryColor"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void glColor4us(ushort red, ushort green, ushort blue, ushort alpha) {
            var _F = _GetProc<GLNativeDelegate.FNglColor4us>("glColor4us");
            _F(red, green, blue, alpha);
        }
        /// <summary>
        /// set the current color
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The initial value for the current color is (1, 1, 1, 1).
        /// The current color can be updated at any time.
        /// In particular,
        /// <see cref="glColor"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glColor4usv(const GLushort * v);</para>
        /// </summary>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array that contains red, green, blue,
        /// and (sometimes) alpha values.
        /// </para>
        /// </param>
        /// <seealso cref="glColorPointer"/>
        /// <seealso cref="glIndex"/>
        /// <seealso cref="glSecondaryColor"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void glColor4usv(ushort* v) {
            var _F = _GetProc<GLNativeDelegate.FNglColor4usv>("glColor4usv");
            _F(v);
        }
        /// <summary>
        /// flag edges as either boundary or nonboundary
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The current edge flag can be updated at any time.
        /// In particular,
        /// <see cref="glEdgeFlag"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glEdgeFlag(GLboolean flag);</para>
        /// </summary>
        /// <param name="flag">
        /// <para>
        /// Specifies the current edge flag value,
        /// either <code>GL_TRUE</code> or <code>GL_FALSE</code>. The initial value is <code>GL_TRUE</code>.
        /// </para>
        /// </param>
        /// <seealso cref="glBegin"/>
        /// <seealso cref="glEdgeFlagPointer"/>
        /// <seealso cref="glPolygonMode"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void glEdgeFlag(bool flag) {
            var _F = _GetProc<GLNativeDelegate.FNglEdgeFlag>("glEdgeFlag");
            _F(flag);
        }
        /// <summary>
        /// flag edges as either boundary or nonboundary
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The current edge flag can be updated at any time.
        /// In particular,
        /// <see cref="glEdgeFlag"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glEdgeFlagv(const GLboolean * flag);</para>
        /// </summary>
        /// <param name="flag">
        /// <para>
        /// Specifies a pointer to an array that contains a single boolean element,
        /// which replaces the current edge flag value.
        /// </para>
        /// </param>
        /// <seealso cref="glBegin"/>
        /// <seealso cref="glEdgeFlagPointer"/>
        /// <seealso cref="glPolygonMode"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void glEdgeFlagv(bool* flag) {
            var _F = _GetProc<GLNativeDelegate.FNglEdgeFlagv>("glEdgeFlagv");
            _F(flag);
        }
        /// <summary>
        /// delimit the vertices of a primitive or a group of like primitives
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="mode"/> is set to an unaccepted value.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glBegin"/> is executed between a
        /// <see cref="glBegin"/>
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// <code>GL_INVALID_OPERATION</code> is generated if  <see cref="glEnd"/>  is executed without being
        /// preceded by a <see cref="glBegin"/>.
        /// <code>GL_INVALID_OPERATION</code> is generated if a command other than
        /// <see cref="glVertex"/> ,
        /// <see cref="glColor"/> ,
        /// <see cref="glSecondaryColor"/> ,
        /// <see cref="glIndex"/> ,
        /// <see cref="glNormal"/> ,
        /// <see cref="glFogCoord"/> ,
        /// <see cref="glTexCoord"/> ,
        /// <see cref="glMultiTexCoord"/> ,
        /// <see cref="glVertexAttrib"/> ,
        /// <see cref="glEvalCoord"/> ,
        /// <see cref="glEvalPoint"/> ,
        /// <see cref="glArrayElement"/> ,
        /// <see cref="glMaterial"/> ,
        /// <see cref="glEdgeFlag"/> ,
        /// <see cref="glCallList"/> , or
        /// <see cref="glCallLists"/>  is executed between
        /// the execution of <see cref="glBegin"/> and the corresponding
        /// execution  <see cref="glEnd"/> .
        /// Execution of
        /// <see cref="glEnableClientState"/> ,
        /// <see cref="glDisableClientState"/> ,
        /// <see cref="glEdgeFlagPointer"/> ,
        /// <see cref="glFogCoordPointer"/> ,
        /// <see cref="glTexCoordPointer"/> ,
        /// <see cref="glColorPointer"/> ,
        /// <see cref="glSecondaryColorPointer"/> ,
        /// <see cref="glIndexPointer"/> ,
        /// <see cref="glNormalPointer"/> ,
        /// <see cref="glVertexPointer"/> ,
        /// <see cref="glVertexAttribPointer"/> ,
        /// <see cref="glInterleavedArrays"/> , or
        /// <see cref="glPixelStore"/>  is not allowed after a call to <see cref="glBegin"/> and before
        /// the corresponding call to  <see cref="glEnd"/> ,
        /// but an error may or may not be generated.
        /// </para>
        /// Original: <para>void glEnd();</para>
        /// </summary>
        /// <seealso cref="glArrayElement"/>
        /// <seealso cref="glCallList"/>
        /// <seealso cref="glCallLists"/>
        /// <seealso cref="glColor"/>
        /// <seealso cref="glEdgeFlag"/>
        /// <seealso cref="glEvalCoord"/>
        /// <seealso cref="glEvalPoint"/>
        /// <seealso cref="glFogCoord"/>
        /// <seealso cref="glIndex"/>
        /// <seealso cref="glMaterial"/>
        /// <seealso cref="glMultiTexCoord"/>
        /// <seealso cref="glNormal"/>
        /// <seealso cref="glSecondaryColor"/>
        /// <seealso cref="glTexCoord"/>
        /// <seealso cref="glVertex"/>
        /// <seealso cref="glVertexAttrib"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void glEnd() {
            var _F = _GetProc<GLNativeDelegate.FNglEnd>("glEnd");
            _F();
        }
        /// <summary>
        /// set the current color index
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glIndexub"/> and <see cref="glIndexubv"/> are available only if the GL version is
        /// 1.1 or greater.
        /// The current index can be updated at any time.
        /// In particular,
        /// <see cref="glIndex"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glIndexd(GLdouble c);</para>
        /// </summary>
        /// <param name="c">
        /// Specifies the new value for the current color index.
        /// </param>
        /// <seealso cref="glColor"/>
        /// <seealso cref="glIndexPointer"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void glIndexd(double c) {
            var _F = _GetProc<GLNativeDelegate.FNglIndexd>("glIndexd");
            _F(c);
        }
        /// <summary>
        /// set the current color index
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glIndexub"/> and <see cref="glIndexubv"/> are available only if the GL version is
        /// 1.1 or greater.
        /// The current index can be updated at any time.
        /// In particular,
        /// <see cref="glIndex"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glIndexdv(const GLdouble * c);</para>
        /// </summary>
        /// <param name="c">
        /// <para>
        /// Specifies a pointer to a one-element array that contains
        /// the new value for the current color index.
        /// </para>
        /// </param>
        /// <seealso cref="glColor"/>
        /// <seealso cref="glIndexPointer"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void glIndexdv(double* c) {
            var _F = _GetProc<GLNativeDelegate.FNglIndexdv>("glIndexdv");
            _F(c);
        }
        /// <summary>
        /// set the current color index
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glIndexub"/> and <see cref="glIndexubv"/> are available only if the GL version is
        /// 1.1 or greater.
        /// The current index can be updated at any time.
        /// In particular,
        /// <see cref="glIndex"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glIndexf(GLfloat c);</para>
        /// </summary>
        /// <param name="c">
        /// Specifies the new value for the current color index.
        /// </param>
        /// <seealso cref="glColor"/>
        /// <seealso cref="glIndexPointer"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void glIndexf(float c) {
            var _F = _GetProc<GLNativeDelegate.FNglIndexf>("glIndexf");
            _F(c);
        }
        /// <summary>
        /// set the current color index
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glIndexub"/> and <see cref="glIndexubv"/> are available only if the GL version is
        /// 1.1 or greater.
        /// The current index can be updated at any time.
        /// In particular,
        /// <see cref="glIndex"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glIndexfv(const GLfloat * c);</para>
        /// </summary>
        /// <param name="c">
        /// <para>
        /// Specifies a pointer to a one-element array that contains
        /// the new value for the current color index.
        /// </para>
        /// </param>
        /// <seealso cref="glColor"/>
        /// <seealso cref="glIndexPointer"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void glIndexfv(float* c) {
            var _F = _GetProc<GLNativeDelegate.FNglIndexfv>("glIndexfv");
            _F(c);
        }
        /// <summary>
        /// set the current color index
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glIndexub"/> and <see cref="glIndexubv"/> are available only if the GL version is
        /// 1.1 or greater.
        /// The current index can be updated at any time.
        /// In particular,
        /// <see cref="glIndex"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glIndexi(GLint c);</para>
        /// </summary>
        /// <param name="c">
        /// Specifies the new value for the current color index.
        /// </param>
        /// <seealso cref="glColor"/>
        /// <seealso cref="glIndexPointer"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void glIndexi(int c) {
            var _F = _GetProc<GLNativeDelegate.FNglIndexi>("glIndexi");
            _F(c);
        }
        /// <summary>
        /// set the current color index
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glIndexub"/> and <see cref="glIndexubv"/> are available only if the GL version is
        /// 1.1 or greater.
        /// The current index can be updated at any time.
        /// In particular,
        /// <see cref="glIndex"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glIndexiv(const GLint * c);</para>
        /// </summary>
        /// <param name="c">
        /// <para>
        /// Specifies a pointer to a one-element array that contains
        /// the new value for the current color index.
        /// </para>
        /// </param>
        /// <seealso cref="glColor"/>
        /// <seealso cref="glIndexPointer"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void glIndexiv(int* c) {
            var _F = _GetProc<GLNativeDelegate.FNglIndexiv>("glIndexiv");
            _F(c);
        }
        /// <summary>
        /// set the current color index
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glIndexub"/> and <see cref="glIndexubv"/> are available only if the GL version is
        /// 1.1 or greater.
        /// The current index can be updated at any time.
        /// In particular,
        /// <see cref="glIndex"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glIndexs(GLshort c);</para>
        /// </summary>
        /// <param name="c">
        /// Specifies the new value for the current color index.
        /// </param>
        /// <seealso cref="glColor"/>
        /// <seealso cref="glIndexPointer"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void glIndexs(short c) {
            var _F = _GetProc<GLNativeDelegate.FNglIndexs>("glIndexs");
            _F(c);
        }
        /// <summary>
        /// set the current color index
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glIndexub"/> and <see cref="glIndexubv"/> are available only if the GL version is
        /// 1.1 or greater.
        /// The current index can be updated at any time.
        /// In particular,
        /// <see cref="glIndex"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glIndexsv(const GLshort * c);</para>
        /// </summary>
        /// <param name="c">
        /// <para>
        /// Specifies a pointer to a one-element array that contains
        /// the new value for the current color index.
        /// </para>
        /// </param>
        /// <seealso cref="glColor"/>
        /// <seealso cref="glIndexPointer"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void glIndexsv(short* c) {
            var _F = _GetProc<GLNativeDelegate.FNglIndexsv>("glIndexsv");
            _F(c);
        }
        /// <summary>
        /// set the current normal vector
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The current normal can be updated at any time.
        /// In particular, <see cref="glNormal"/> can be called between a call to  <see cref="glBegin"/>  and
        /// the corresponding call to  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glNormal3b(GLbyte nx, GLbyte ny, GLbyte nz);</para>
        /// </summary>
        /// <param name="nx">
        /// <para>
        /// Specify the 
        /// x   ,
        /// y   ,
        /// and 
        /// z   
        /// coordinates of the new current normal.
        /// The initial value of the current normal is the unit vector, (0, 0, 1).
        /// </para>
        /// </param>
        /// <param name="ny">
        /// <para>
        /// Specify the 
        /// x   ,
        /// y   ,
        /// and 
        /// z   
        /// coordinates of the new current normal.
        /// The initial value of the current normal is the unit vector, (0, 0, 1).
        /// </para>
        /// </param>
        /// <param name="nz">
        /// <para>
        /// Specify the 
        /// x   ,
        /// y   ,
        /// and 
        /// z   
        /// coordinates of the new current normal.
        /// The initial value of the current normal is the unit vector, (0, 0, 1).
        /// </para>
        /// </param>
        /// <seealso cref="glBegin"/>
        /// <seealso cref="glColor"/>
        /// <seealso cref="glIndex"/>
        /// <seealso cref="glMultiTexCoord"/>
        /// <seealso cref="glNormalPointer"/>
        /// <seealso cref="glTexCoord"/>
        /// <seealso cref="glVertex"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void glNormal3b(byte nx, byte ny, byte nz) {
            var _F = _GetProc<GLNativeDelegate.FNglNormal3b>("glNormal3b");
            _F(nx, ny, nz);
        }
        /// <summary>
        /// set the current normal vector
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The current normal can be updated at any time.
        /// In particular, <see cref="glNormal"/> can be called between a call to  <see cref="glBegin"/>  and
        /// the corresponding call to  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glNormal3bv(const GLbyte * v);</para>
        /// </summary>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array of three elements:
        /// the 
        /// x   ,
        /// y   ,
        /// and 
        /// z   
        /// coordinates of the new current normal.
        /// </para>
        /// </param>
        /// <seealso cref="glBegin"/>
        /// <seealso cref="glColor"/>
        /// <seealso cref="glIndex"/>
        /// <seealso cref="glMultiTexCoord"/>
        /// <seealso cref="glNormalPointer"/>
        /// <seealso cref="glTexCoord"/>
        /// <seealso cref="glVertex"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void glNormal3bv(byte* v) {
            var _F = _GetProc<GLNativeDelegate.FNglNormal3bv>("glNormal3bv");
            _F(v);
        }
        /// <summary>
        /// set the current normal vector
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The current normal can be updated at any time.
        /// In particular, <see cref="glNormal"/> can be called between a call to  <see cref="glBegin"/>  and
        /// the corresponding call to  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glNormal3d(GLdouble nx, GLdouble ny, GLdouble nz);</para>
        /// </summary>
        /// <param name="nx">
        /// <para>
        /// Specify the 
        /// x   ,
        /// y   ,
        /// and 
        /// z   
        /// coordinates of the new current normal.
        /// The initial value of the current normal is the unit vector, (0, 0, 1).
        /// </para>
        /// </param>
        /// <param name="ny">
        /// <para>
        /// Specify the 
        /// x   ,
        /// y   ,
        /// and 
        /// z   
        /// coordinates of the new current normal.
        /// The initial value of the current normal is the unit vector, (0, 0, 1).
        /// </para>
        /// </param>
        /// <param name="nz">
        /// <para>
        /// Specify the 
        /// x   ,
        /// y   ,
        /// and 
        /// z   
        /// coordinates of the new current normal.
        /// The initial value of the current normal is the unit vector, (0, 0, 1).
        /// </para>
        /// </param>
        /// <seealso cref="glBegin"/>
        /// <seealso cref="glColor"/>
        /// <seealso cref="glIndex"/>
        /// <seealso cref="glMultiTexCoord"/>
        /// <seealso cref="glNormalPointer"/>
        /// <seealso cref="glTexCoord"/>
        /// <seealso cref="glVertex"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void glNormal3d(double nx, double ny, double nz) {
            var _F = _GetProc<GLNativeDelegate.FNglNormal3d>("glNormal3d");
            _F(nx, ny, nz);
        }
        /// <summary>
        /// set the current normal vector
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The current normal can be updated at any time.
        /// In particular, <see cref="glNormal"/> can be called between a call to  <see cref="glBegin"/>  and
        /// the corresponding call to  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glNormal3dv(const GLdouble * v);</para>
        /// </summary>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array of three elements:
        /// the 
        /// x   ,
        /// y   ,
        /// and 
        /// z   
        /// coordinates of the new current normal.
        /// </para>
        /// </param>
        /// <seealso cref="glBegin"/>
        /// <seealso cref="glColor"/>
        /// <seealso cref="glIndex"/>
        /// <seealso cref="glMultiTexCoord"/>
        /// <seealso cref="glNormalPointer"/>
        /// <seealso cref="glTexCoord"/>
        /// <seealso cref="glVertex"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void glNormal3dv(double* v) {
            var _F = _GetProc<GLNativeDelegate.FNglNormal3dv>("glNormal3dv");
            _F(v);
        }
        /// <summary>
        /// set the current normal vector
        /// <para>Require:</para> <para>GL_VERSION_1_0, GL_VERSION_ES_CM_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The current normal can be updated at any time.
        /// In particular, <see cref="glNormal"/> can be called between a call to  <see cref="glBegin"/>  and
        /// the corresponding call to  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glNormal3f(GLfloat nx, GLfloat ny, GLfloat nz);</para>
        /// </summary>
        /// <param name="nx">
        /// <para>
        /// Specify the 
        /// x   ,
        /// y   ,
        /// and 
        /// z   
        /// coordinates of the new current normal.
        /// The initial value of the current normal is the unit vector, (0, 0, 1).
        /// </para>
        /// </param>
        /// <param name="ny">
        /// <para>
        /// Specify the 
        /// x   ,
        /// y   ,
        /// and 
        /// z   
        /// coordinates of the new current normal.
        /// The initial value of the current normal is the unit vector, (0, 0, 1).
        /// </para>
        /// </param>
        /// <param name="nz">
        /// <para>
        /// Specify the 
        /// x   ,
        /// y   ,
        /// and 
        /// z   
        /// coordinates of the new current normal.
        /// The initial value of the current normal is the unit vector, (0, 0, 1).
        /// </para>
        /// </param>
        /// <seealso cref="glBegin"/>
        /// <seealso cref="glColor"/>
        /// <seealso cref="glIndex"/>
        /// <seealso cref="glMultiTexCoord"/>
        /// <seealso cref="glNormalPointer"/>
        /// <seealso cref="glTexCoord"/>
        /// <seealso cref="glVertex"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void glNormal3f(float nx, float ny, float nz) {
            var _F = _GetProc<GLNativeDelegate.FNglNormal3f>("glNormal3f");
            _F(nx, ny, nz);
        }
        /// <summary>
        /// set the current normal vector
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The current normal can be updated at any time.
        /// In particular, <see cref="glNormal"/> can be called between a call to  <see cref="glBegin"/>  and
        /// the corresponding call to  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glNormal3fv(const GLfloat * v);</para>
        /// </summary>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array of three elements:
        /// the 
        /// x   ,
        /// y   ,
        /// and 
        /// z   
        /// coordinates of the new current normal.
        /// </para>
        /// </param>
        /// <seealso cref="glBegin"/>
        /// <seealso cref="glColor"/>
        /// <seealso cref="glIndex"/>
        /// <seealso cref="glMultiTexCoord"/>
        /// <seealso cref="glNormalPointer"/>
        /// <seealso cref="glTexCoord"/>
        /// <seealso cref="glVertex"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void glNormal3fv(float* v) {
            var _F = _GetProc<GLNativeDelegate.FNglNormal3fv>("glNormal3fv");
            _F(v);
        }
        /// <summary>
        /// set the current normal vector
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The current normal can be updated at any time.
        /// In particular, <see cref="glNormal"/> can be called between a call to  <see cref="glBegin"/>  and
        /// the corresponding call to  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glNormal3i(GLint nx, GLint ny, GLint nz);</para>
        /// </summary>
        /// <param name="nx">
        /// <para>
        /// Specify the 
        /// x   ,
        /// y   ,
        /// and 
        /// z   
        /// coordinates of the new current normal.
        /// The initial value of the current normal is the unit vector, (0, 0, 1).
        /// </para>
        /// </param>
        /// <param name="ny">
        /// <para>
        /// Specify the 
        /// x   ,
        /// y   ,
        /// and 
        /// z   
        /// coordinates of the new current normal.
        /// The initial value of the current normal is the unit vector, (0, 0, 1).
        /// </para>
        /// </param>
        /// <param name="nz">
        /// <para>
        /// Specify the 
        /// x   ,
        /// y   ,
        /// and 
        /// z   
        /// coordinates of the new current normal.
        /// The initial value of the current normal is the unit vector, (0, 0, 1).
        /// </para>
        /// </param>
        /// <seealso cref="glBegin"/>
        /// <seealso cref="glColor"/>
        /// <seealso cref="glIndex"/>
        /// <seealso cref="glMultiTexCoord"/>
        /// <seealso cref="glNormalPointer"/>
        /// <seealso cref="glTexCoord"/>
        /// <seealso cref="glVertex"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void glNormal3i(int nx, int ny, int nz) {
            var _F = _GetProc<GLNativeDelegate.FNglNormal3i>("glNormal3i");
            _F(nx, ny, nz);
        }
        /// <summary>
        /// set the current normal vector
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The current normal can be updated at any time.
        /// In particular, <see cref="glNormal"/> can be called between a call to  <see cref="glBegin"/>  and
        /// the corresponding call to  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glNormal3iv(const GLint * v);</para>
        /// </summary>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array of three elements:
        /// the 
        /// x   ,
        /// y   ,
        /// and 
        /// z   
        /// coordinates of the new current normal.
        /// </para>
        /// </param>
        /// <seealso cref="glBegin"/>
        /// <seealso cref="glColor"/>
        /// <seealso cref="glIndex"/>
        /// <seealso cref="glMultiTexCoord"/>
        /// <seealso cref="glNormalPointer"/>
        /// <seealso cref="glTexCoord"/>
        /// <seealso cref="glVertex"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void glNormal3iv(int* v) {
            var _F = _GetProc<GLNativeDelegate.FNglNormal3iv>("glNormal3iv");
            _F(v);
        }
        /// <summary>
        /// set the current normal vector
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The current normal can be updated at any time.
        /// In particular, <see cref="glNormal"/> can be called between a call to  <see cref="glBegin"/>  and
        /// the corresponding call to  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glNormal3s(GLshort nx, GLshort ny, GLshort nz);</para>
        /// </summary>
        /// <param name="nx">
        /// <para>
        /// Specify the 
        /// x   ,
        /// y   ,
        /// and 
        /// z   
        /// coordinates of the new current normal.
        /// The initial value of the current normal is the unit vector, (0, 0, 1).
        /// </para>
        /// </param>
        /// <param name="ny">
        /// <para>
        /// Specify the 
        /// x   ,
        /// y   ,
        /// and 
        /// z   
        /// coordinates of the new current normal.
        /// The initial value of the current normal is the unit vector, (0, 0, 1).
        /// </para>
        /// </param>
        /// <param name="nz">
        /// <para>
        /// Specify the 
        /// x   ,
        /// y   ,
        /// and 
        /// z   
        /// coordinates of the new current normal.
        /// The initial value of the current normal is the unit vector, (0, 0, 1).
        /// </para>
        /// </param>
        /// <seealso cref="glBegin"/>
        /// <seealso cref="glColor"/>
        /// <seealso cref="glIndex"/>
        /// <seealso cref="glMultiTexCoord"/>
        /// <seealso cref="glNormalPointer"/>
        /// <seealso cref="glTexCoord"/>
        /// <seealso cref="glVertex"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void glNormal3s(short nx, short ny, short nz) {
            var _F = _GetProc<GLNativeDelegate.FNglNormal3s>("glNormal3s");
            _F(nx, ny, nz);
        }
        /// <summary>
        /// set the current normal vector
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The current normal can be updated at any time.
        /// In particular, <see cref="glNormal"/> can be called between a call to  <see cref="glBegin"/>  and
        /// the corresponding call to  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glNormal3sv(const GLshort * v);</para>
        /// </summary>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array of three elements:
        /// the 
        /// x   ,
        /// y   ,
        /// and 
        /// z   
        /// coordinates of the new current normal.
        /// </para>
        /// </param>
        /// <seealso cref="glBegin"/>
        /// <seealso cref="glColor"/>
        /// <seealso cref="glIndex"/>
        /// <seealso cref="glMultiTexCoord"/>
        /// <seealso cref="glNormalPointer"/>
        /// <seealso cref="glTexCoord"/>
        /// <seealso cref="glVertex"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void glNormal3sv(short* v) {
            var _F = _GetProc<GLNativeDelegate.FNglNormal3sv>("glNormal3sv");
            _F(v);
        }
        /// <summary>
        /// specify the raster position for pixel operations
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The raster position is modified by <see cref="glRasterPos"/>,  <see cref="glBitmap"/> , and  <see cref="glWindowPos"/> .
        /// When the raster position coordinates are invalid,
        /// drawing commands that are based on the raster position are
        /// ignored (that is, they do not result in changes to GL state).
        /// Calling  <see cref="glDrawElements"/>  or  <see cref="glDrawRangeElements"/>  may leave the
        /// current color or index indeterminate.
        /// If <see cref="glRasterPos"/> is executed while the current color or index is indeterminate, the
        /// current raster color or current raster index remains indeterminate.
        /// To set a valid raster position outside the viewport, first set a valid
        /// raster position, then call  <see cref="glBitmap"/>  with NULL as the  bitmap 
        /// parameter.
        /// When the <code>ARB_imaging</code> extension is supported, there are distinct
        /// raster texture coordinates for each texture unit. Each texture unit's
        /// current raster texture coordinates are updated by <see cref="glRasterPos"/>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glRasterPos"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glRasterPos2d(GLdouble x, GLdouble y);</para>
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify the 
        /// x   ,
        /// y   ,
        /// z   ,
        /// and 
        /// w   
        /// object coordinates
        /// (if present)
        /// for the raster
        /// position.
        /// </para>
        /// </param>
        /// <param name="y">
        /// <para>
        /// Specify the 
        /// x   ,
        /// y   ,
        /// z   ,
        /// and 
        /// w   
        /// object coordinates
        /// (if present)
        /// for the raster
        /// position.
        /// </para>
        /// </param>
        /// <seealso cref="glBitmap"/>
        /// <seealso cref="glCopyPixels"/>
        /// <seealso cref="glDrawArrays"/>
        /// <seealso cref="glDrawElements"/>
        /// <seealso cref="glDrawRangeElements"/>
        /// <seealso cref="glDrawPixels"/>
        /// <seealso cref="glMultiTexCoord"/>
        /// <seealso cref="glTexCoord"/>
        /// <seealso cref="glTexGen"/>
        /// <seealso cref="glVertex"/>
        /// <seealso cref="glWindowPos"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void glRasterPos2d(double x, double y) {
            var _F = _GetProc<GLNativeDelegate.FNglRasterPos2d>("glRasterPos2d");
            _F(x, y);
        }
        /// <summary>
        /// specify the raster position for pixel operations
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The raster position is modified by <see cref="glRasterPos"/>,  <see cref="glBitmap"/> , and  <see cref="glWindowPos"/> .
        /// When the raster position coordinates are invalid,
        /// drawing commands that are based on the raster position are
        /// ignored (that is, they do not result in changes to GL state).
        /// Calling  <see cref="glDrawElements"/>  or  <see cref="glDrawRangeElements"/>  may leave the
        /// current color or index indeterminate.
        /// If <see cref="glRasterPos"/> is executed while the current color or index is indeterminate, the
        /// current raster color or current raster index remains indeterminate.
        /// To set a valid raster position outside the viewport, first set a valid
        /// raster position, then call  <see cref="glBitmap"/>  with NULL as the  bitmap 
        /// parameter.
        /// When the <code>ARB_imaging</code> extension is supported, there are distinct
        /// raster texture coordinates for each texture unit. Each texture unit's
        /// current raster texture coordinates are updated by <see cref="glRasterPos"/>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glRasterPos"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glRasterPos2dv(const GLdouble * v);</para>
        /// </summary>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array of two,
        /// three,
        /// or four elements,
        /// specifying 
        /// x   ,
        /// y   ,
        /// z   ,
        /// and 
        /// w   
        /// coordinates, respectively.
        /// </para>
        /// </param>
        /// <seealso cref="glBitmap"/>
        /// <seealso cref="glCopyPixels"/>
        /// <seealso cref="glDrawArrays"/>
        /// <seealso cref="glDrawElements"/>
        /// <seealso cref="glDrawRangeElements"/>
        /// <seealso cref="glDrawPixels"/>
        /// <seealso cref="glMultiTexCoord"/>
        /// <seealso cref="glTexCoord"/>
        /// <seealso cref="glTexGen"/>
        /// <seealso cref="glVertex"/>
        /// <seealso cref="glWindowPos"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void glRasterPos2dv(double* v) {
            var _F = _GetProc<GLNativeDelegate.FNglRasterPos2dv>("glRasterPos2dv");
            _F(v);
        }
        /// <summary>
        /// specify the raster position for pixel operations
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The raster position is modified by <see cref="glRasterPos"/>,  <see cref="glBitmap"/> , and  <see cref="glWindowPos"/> .
        /// When the raster position coordinates are invalid,
        /// drawing commands that are based on the raster position are
        /// ignored (that is, they do not result in changes to GL state).
        /// Calling  <see cref="glDrawElements"/>  or  <see cref="glDrawRangeElements"/>  may leave the
        /// current color or index indeterminate.
        /// If <see cref="glRasterPos"/> is executed while the current color or index is indeterminate, the
        /// current raster color or current raster index remains indeterminate.
        /// To set a valid raster position outside the viewport, first set a valid
        /// raster position, then call  <see cref="glBitmap"/>  with NULL as the  bitmap 
        /// parameter.
        /// When the <code>ARB_imaging</code> extension is supported, there are distinct
        /// raster texture coordinates for each texture unit. Each texture unit's
        /// current raster texture coordinates are updated by <see cref="glRasterPos"/>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glRasterPos"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glRasterPos2f(GLfloat x, GLfloat y);</para>
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify the 
        /// x   ,
        /// y   ,
        /// z   ,
        /// and 
        /// w   
        /// object coordinates
        /// (if present)
        /// for the raster
        /// position.
        /// </para>
        /// </param>
        /// <param name="y">
        /// <para>
        /// Specify the 
        /// x   ,
        /// y   ,
        /// z   ,
        /// and 
        /// w   
        /// object coordinates
        /// (if present)
        /// for the raster
        /// position.
        /// </para>
        /// </param>
        /// <seealso cref="glBitmap"/>
        /// <seealso cref="glCopyPixels"/>
        /// <seealso cref="glDrawArrays"/>
        /// <seealso cref="glDrawElements"/>
        /// <seealso cref="glDrawRangeElements"/>
        /// <seealso cref="glDrawPixels"/>
        /// <seealso cref="glMultiTexCoord"/>
        /// <seealso cref="glTexCoord"/>
        /// <seealso cref="glTexGen"/>
        /// <seealso cref="glVertex"/>
        /// <seealso cref="glWindowPos"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void glRasterPos2f(float x, float y) {
            var _F = _GetProc<GLNativeDelegate.FNglRasterPos2f>("glRasterPos2f");
            _F(x, y);
        }
        /// <summary>
        /// specify the raster position for pixel operations
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The raster position is modified by <see cref="glRasterPos"/>,  <see cref="glBitmap"/> , and  <see cref="glWindowPos"/> .
        /// When the raster position coordinates are invalid,
        /// drawing commands that are based on the raster position are
        /// ignored (that is, they do not result in changes to GL state).
        /// Calling  <see cref="glDrawElements"/>  or  <see cref="glDrawRangeElements"/>  may leave the
        /// current color or index indeterminate.
        /// If <see cref="glRasterPos"/> is executed while the current color or index is indeterminate, the
        /// current raster color or current raster index remains indeterminate.
        /// To set a valid raster position outside the viewport, first set a valid
        /// raster position, then call  <see cref="glBitmap"/>  with NULL as the  bitmap 
        /// parameter.
        /// When the <code>ARB_imaging</code> extension is supported, there are distinct
        /// raster texture coordinates for each texture unit. Each texture unit's
        /// current raster texture coordinates are updated by <see cref="glRasterPos"/>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glRasterPos"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glRasterPos2fv(const GLfloat * v);</para>
        /// </summary>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array of two,
        /// three,
        /// or four elements,
        /// specifying 
        /// x   ,
        /// y   ,
        /// z   ,
        /// and 
        /// w   
        /// coordinates, respectively.
        /// </para>
        /// </param>
        /// <seealso cref="glBitmap"/>
        /// <seealso cref="glCopyPixels"/>
        /// <seealso cref="glDrawArrays"/>
        /// <seealso cref="glDrawElements"/>
        /// <seealso cref="glDrawRangeElements"/>
        /// <seealso cref="glDrawPixels"/>
        /// <seealso cref="glMultiTexCoord"/>
        /// <seealso cref="glTexCoord"/>
        /// <seealso cref="glTexGen"/>
        /// <seealso cref="glVertex"/>
        /// <seealso cref="glWindowPos"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void glRasterPos2fv(float* v) {
            var _F = _GetProc<GLNativeDelegate.FNglRasterPos2fv>("glRasterPos2fv");
            _F(v);
        }
        /// <summary>
        /// specify the raster position for pixel operations
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The raster position is modified by <see cref="glRasterPos"/>,  <see cref="glBitmap"/> , and  <see cref="glWindowPos"/> .
        /// When the raster position coordinates are invalid,
        /// drawing commands that are based on the raster position are
        /// ignored (that is, they do not result in changes to GL state).
        /// Calling  <see cref="glDrawElements"/>  or  <see cref="glDrawRangeElements"/>  may leave the
        /// current color or index indeterminate.
        /// If <see cref="glRasterPos"/> is executed while the current color or index is indeterminate, the
        /// current raster color or current raster index remains indeterminate.
        /// To set a valid raster position outside the viewport, first set a valid
        /// raster position, then call  <see cref="glBitmap"/>  with NULL as the  bitmap 
        /// parameter.
        /// When the <code>ARB_imaging</code> extension is supported, there are distinct
        /// raster texture coordinates for each texture unit. Each texture unit's
        /// current raster texture coordinates are updated by <see cref="glRasterPos"/>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glRasterPos"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glRasterPos2i(GLint x, GLint y);</para>
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify the 
        /// x   ,
        /// y   ,
        /// z   ,
        /// and 
        /// w   
        /// object coordinates
        /// (if present)
        /// for the raster
        /// position.
        /// </para>
        /// </param>
        /// <param name="y">
        /// <para>
        /// Specify the 
        /// x   ,
        /// y   ,
        /// z   ,
        /// and 
        /// w   
        /// object coordinates
        /// (if present)
        /// for the raster
        /// position.
        /// </para>
        /// </param>
        /// <seealso cref="glBitmap"/>
        /// <seealso cref="glCopyPixels"/>
        /// <seealso cref="glDrawArrays"/>
        /// <seealso cref="glDrawElements"/>
        /// <seealso cref="glDrawRangeElements"/>
        /// <seealso cref="glDrawPixels"/>
        /// <seealso cref="glMultiTexCoord"/>
        /// <seealso cref="glTexCoord"/>
        /// <seealso cref="glTexGen"/>
        /// <seealso cref="glVertex"/>
        /// <seealso cref="glWindowPos"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void glRasterPos2i(int x, int y) {
            var _F = _GetProc<GLNativeDelegate.FNglRasterPos2i>("glRasterPos2i");
            _F(x, y);
        }
        /// <summary>
        /// specify the raster position for pixel operations
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The raster position is modified by <see cref="glRasterPos"/>,  <see cref="glBitmap"/> , and  <see cref="glWindowPos"/> .
        /// When the raster position coordinates are invalid,
        /// drawing commands that are based on the raster position are
        /// ignored (that is, they do not result in changes to GL state).
        /// Calling  <see cref="glDrawElements"/>  or  <see cref="glDrawRangeElements"/>  may leave the
        /// current color or index indeterminate.
        /// If <see cref="glRasterPos"/> is executed while the current color or index is indeterminate, the
        /// current raster color or current raster index remains indeterminate.
        /// To set a valid raster position outside the viewport, first set a valid
        /// raster position, then call  <see cref="glBitmap"/>  with NULL as the  bitmap 
        /// parameter.
        /// When the <code>ARB_imaging</code> extension is supported, there are distinct
        /// raster texture coordinates for each texture unit. Each texture unit's
        /// current raster texture coordinates are updated by <see cref="glRasterPos"/>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glRasterPos"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glRasterPos2iv(const GLint * v);</para>
        /// </summary>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array of two,
        /// three,
        /// or four elements,
        /// specifying 
        /// x   ,
        /// y   ,
        /// z   ,
        /// and 
        /// w   
        /// coordinates, respectively.
        /// </para>
        /// </param>
        /// <seealso cref="glBitmap"/>
        /// <seealso cref="glCopyPixels"/>
        /// <seealso cref="glDrawArrays"/>
        /// <seealso cref="glDrawElements"/>
        /// <seealso cref="glDrawRangeElements"/>
        /// <seealso cref="glDrawPixels"/>
        /// <seealso cref="glMultiTexCoord"/>
        /// <seealso cref="glTexCoord"/>
        /// <seealso cref="glTexGen"/>
        /// <seealso cref="glVertex"/>
        /// <seealso cref="glWindowPos"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void glRasterPos2iv(int* v) {
            var _F = _GetProc<GLNativeDelegate.FNglRasterPos2iv>("glRasterPos2iv");
            _F(v);
        }
        /// <summary>
        /// specify the raster position for pixel operations
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The raster position is modified by <see cref="glRasterPos"/>,  <see cref="glBitmap"/> , and  <see cref="glWindowPos"/> .
        /// When the raster position coordinates are invalid,
        /// drawing commands that are based on the raster position are
        /// ignored (that is, they do not result in changes to GL state).
        /// Calling  <see cref="glDrawElements"/>  or  <see cref="glDrawRangeElements"/>  may leave the
        /// current color or index indeterminate.
        /// If <see cref="glRasterPos"/> is executed while the current color or index is indeterminate, the
        /// current raster color or current raster index remains indeterminate.
        /// To set a valid raster position outside the viewport, first set a valid
        /// raster position, then call  <see cref="glBitmap"/>  with NULL as the  bitmap 
        /// parameter.
        /// When the <code>ARB_imaging</code> extension is supported, there are distinct
        /// raster texture coordinates for each texture unit. Each texture unit's
        /// current raster texture coordinates are updated by <see cref="glRasterPos"/>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glRasterPos"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glRasterPos2s(GLshort x, GLshort y);</para>
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify the 
        /// x   ,
        /// y   ,
        /// z   ,
        /// and 
        /// w   
        /// object coordinates
        /// (if present)
        /// for the raster
        /// position.
        /// </para>
        /// </param>
        /// <param name="y">
        /// <para>
        /// Specify the 
        /// x   ,
        /// y   ,
        /// z   ,
        /// and 
        /// w   
        /// object coordinates
        /// (if present)
        /// for the raster
        /// position.
        /// </para>
        /// </param>
        /// <seealso cref="glBitmap"/>
        /// <seealso cref="glCopyPixels"/>
        /// <seealso cref="glDrawArrays"/>
        /// <seealso cref="glDrawElements"/>
        /// <seealso cref="glDrawRangeElements"/>
        /// <seealso cref="glDrawPixels"/>
        /// <seealso cref="glMultiTexCoord"/>
        /// <seealso cref="glTexCoord"/>
        /// <seealso cref="glTexGen"/>
        /// <seealso cref="glVertex"/>
        /// <seealso cref="glWindowPos"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void glRasterPos2s(short x, short y) {
            var _F = _GetProc<GLNativeDelegate.FNglRasterPos2s>("glRasterPos2s");
            _F(x, y);
        }
        /// <summary>
        /// specify the raster position for pixel operations
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The raster position is modified by <see cref="glRasterPos"/>,  <see cref="glBitmap"/> , and  <see cref="glWindowPos"/> .
        /// When the raster position coordinates are invalid,
        /// drawing commands that are based on the raster position are
        /// ignored (that is, they do not result in changes to GL state).
        /// Calling  <see cref="glDrawElements"/>  or  <see cref="glDrawRangeElements"/>  may leave the
        /// current color or index indeterminate.
        /// If <see cref="glRasterPos"/> is executed while the current color or index is indeterminate, the
        /// current raster color or current raster index remains indeterminate.
        /// To set a valid raster position outside the viewport, first set a valid
        /// raster position, then call  <see cref="glBitmap"/>  with NULL as the  bitmap 
        /// parameter.
        /// When the <code>ARB_imaging</code> extension is supported, there are distinct
        /// raster texture coordinates for each texture unit. Each texture unit's
        /// current raster texture coordinates are updated by <see cref="glRasterPos"/>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glRasterPos"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glRasterPos2sv(const GLshort * v);</para>
        /// </summary>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array of two,
        /// three,
        /// or four elements,
        /// specifying 
        /// x   ,
        /// y   ,
        /// z   ,
        /// and 
        /// w   
        /// coordinates, respectively.
        /// </para>
        /// </param>
        /// <seealso cref="glBitmap"/>
        /// <seealso cref="glCopyPixels"/>
        /// <seealso cref="glDrawArrays"/>
        /// <seealso cref="glDrawElements"/>
        /// <seealso cref="glDrawRangeElements"/>
        /// <seealso cref="glDrawPixels"/>
        /// <seealso cref="glMultiTexCoord"/>
        /// <seealso cref="glTexCoord"/>
        /// <seealso cref="glTexGen"/>
        /// <seealso cref="glVertex"/>
        /// <seealso cref="glWindowPos"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void glRasterPos2sv(short* v) {
            var _F = _GetProc<GLNativeDelegate.FNglRasterPos2sv>("glRasterPos2sv");
            _F(v);
        }
        /// <summary>
        /// specify the raster position for pixel operations
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The raster position is modified by <see cref="glRasterPos"/>,  <see cref="glBitmap"/> , and  <see cref="glWindowPos"/> .
        /// When the raster position coordinates are invalid,
        /// drawing commands that are based on the raster position are
        /// ignored (that is, they do not result in changes to GL state).
        /// Calling  <see cref="glDrawElements"/>  or  <see cref="glDrawRangeElements"/>  may leave the
        /// current color or index indeterminate.
        /// If <see cref="glRasterPos"/> is executed while the current color or index is indeterminate, the
        /// current raster color or current raster index remains indeterminate.
        /// To set a valid raster position outside the viewport, first set a valid
        /// raster position, then call  <see cref="glBitmap"/>  with NULL as the  bitmap 
        /// parameter.
        /// When the <code>ARB_imaging</code> extension is supported, there are distinct
        /// raster texture coordinates for each texture unit. Each texture unit's
        /// current raster texture coordinates are updated by <see cref="glRasterPos"/>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glRasterPos"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glRasterPos3d(GLdouble x, GLdouble y, GLdouble z);</para>
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify the 
        /// x   ,
        /// y   ,
        /// z   ,
        /// and 
        /// w   
        /// object coordinates
        /// (if present)
        /// for the raster
        /// position.
        /// </para>
        /// </param>
        /// <param name="y">
        /// <para>
        /// Specify the 
        /// x   ,
        /// y   ,
        /// z   ,
        /// and 
        /// w   
        /// object coordinates
        /// (if present)
        /// for the raster
        /// position.
        /// </para>
        /// </param>
        /// <param name="z">
        /// <para>
        /// Specify the 
        /// x   ,
        /// y   ,
        /// z   ,
        /// and 
        /// w   
        /// object coordinates
        /// (if present)
        /// for the raster
        /// position.
        /// </para>
        /// </param>
        /// <seealso cref="glBitmap"/>
        /// <seealso cref="glCopyPixels"/>
        /// <seealso cref="glDrawArrays"/>
        /// <seealso cref="glDrawElements"/>
        /// <seealso cref="glDrawRangeElements"/>
        /// <seealso cref="glDrawPixels"/>
        /// <seealso cref="glMultiTexCoord"/>
        /// <seealso cref="glTexCoord"/>
        /// <seealso cref="glTexGen"/>
        /// <seealso cref="glVertex"/>
        /// <seealso cref="glWindowPos"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void glRasterPos3d(double x, double y, double z) {
            var _F = _GetProc<GLNativeDelegate.FNglRasterPos3d>("glRasterPos3d");
            _F(x, y, z);
        }
        /// <summary>
        /// specify the raster position for pixel operations
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The raster position is modified by <see cref="glRasterPos"/>,  <see cref="glBitmap"/> , and  <see cref="glWindowPos"/> .
        /// When the raster position coordinates are invalid,
        /// drawing commands that are based on the raster position are
        /// ignored (that is, they do not result in changes to GL state).
        /// Calling  <see cref="glDrawElements"/>  or  <see cref="glDrawRangeElements"/>  may leave the
        /// current color or index indeterminate.
        /// If <see cref="glRasterPos"/> is executed while the current color or index is indeterminate, the
        /// current raster color or current raster index remains indeterminate.
        /// To set a valid raster position outside the viewport, first set a valid
        /// raster position, then call  <see cref="glBitmap"/>  with NULL as the  bitmap 
        /// parameter.
        /// When the <code>ARB_imaging</code> extension is supported, there are distinct
        /// raster texture coordinates for each texture unit. Each texture unit's
        /// current raster texture coordinates are updated by <see cref="glRasterPos"/>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glRasterPos"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glRasterPos3dv(const GLdouble * v);</para>
        /// </summary>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array of two,
        /// three,
        /// or four elements,
        /// specifying 
        /// x   ,
        /// y   ,
        /// z   ,
        /// and 
        /// w   
        /// coordinates, respectively.
        /// </para>
        /// </param>
        /// <seealso cref="glBitmap"/>
        /// <seealso cref="glCopyPixels"/>
        /// <seealso cref="glDrawArrays"/>
        /// <seealso cref="glDrawElements"/>
        /// <seealso cref="glDrawRangeElements"/>
        /// <seealso cref="glDrawPixels"/>
        /// <seealso cref="glMultiTexCoord"/>
        /// <seealso cref="glTexCoord"/>
        /// <seealso cref="glTexGen"/>
        /// <seealso cref="glVertex"/>
        /// <seealso cref="glWindowPos"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void glRasterPos3dv(double* v) {
            var _F = _GetProc<GLNativeDelegate.FNglRasterPos3dv>("glRasterPos3dv");
            _F(v);
        }
        /// <summary>
        /// specify the raster position for pixel operations
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The raster position is modified by <see cref="glRasterPos"/>,  <see cref="glBitmap"/> , and  <see cref="glWindowPos"/> .
        /// When the raster position coordinates are invalid,
        /// drawing commands that are based on the raster position are
        /// ignored (that is, they do not result in changes to GL state).
        /// Calling  <see cref="glDrawElements"/>  or  <see cref="glDrawRangeElements"/>  may leave the
        /// current color or index indeterminate.
        /// If <see cref="glRasterPos"/> is executed while the current color or index is indeterminate, the
        /// current raster color or current raster index remains indeterminate.
        /// To set a valid raster position outside the viewport, first set a valid
        /// raster position, then call  <see cref="glBitmap"/>  with NULL as the  bitmap 
        /// parameter.
        /// When the <code>ARB_imaging</code> extension is supported, there are distinct
        /// raster texture coordinates for each texture unit. Each texture unit's
        /// current raster texture coordinates are updated by <see cref="glRasterPos"/>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glRasterPos"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glRasterPos3f(GLfloat x, GLfloat y, GLfloat z);</para>
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify the 
        /// x   ,
        /// y   ,
        /// z   ,
        /// and 
        /// w   
        /// object coordinates
        /// (if present)
        /// for the raster
        /// position.
        /// </para>
        /// </param>
        /// <param name="y">
        /// <para>
        /// Specify the 
        /// x   ,
        /// y   ,
        /// z   ,
        /// and 
        /// w   
        /// object coordinates
        /// (if present)
        /// for the raster
        /// position.
        /// </para>
        /// </param>
        /// <param name="z">
        /// <para>
        /// Specify the 
        /// x   ,
        /// y   ,
        /// z   ,
        /// and 
        /// w   
        /// object coordinates
        /// (if present)
        /// for the raster
        /// position.
        /// </para>
        /// </param>
        /// <seealso cref="glBitmap"/>
        /// <seealso cref="glCopyPixels"/>
        /// <seealso cref="glDrawArrays"/>
        /// <seealso cref="glDrawElements"/>
        /// <seealso cref="glDrawRangeElements"/>
        /// <seealso cref="glDrawPixels"/>
        /// <seealso cref="glMultiTexCoord"/>
        /// <seealso cref="glTexCoord"/>
        /// <seealso cref="glTexGen"/>
        /// <seealso cref="glVertex"/>
        /// <seealso cref="glWindowPos"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void glRasterPos3f(float x, float y, float z) {
            var _F = _GetProc<GLNativeDelegate.FNglRasterPos3f>("glRasterPos3f");
            _F(x, y, z);
        }
        /// <summary>
        /// specify the raster position for pixel operations
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The raster position is modified by <see cref="glRasterPos"/>,  <see cref="glBitmap"/> , and  <see cref="glWindowPos"/> .
        /// When the raster position coordinates are invalid,
        /// drawing commands that are based on the raster position are
        /// ignored (that is, they do not result in changes to GL state).
        /// Calling  <see cref="glDrawElements"/>  or  <see cref="glDrawRangeElements"/>  may leave the
        /// current color or index indeterminate.
        /// If <see cref="glRasterPos"/> is executed while the current color or index is indeterminate, the
        /// current raster color or current raster index remains indeterminate.
        /// To set a valid raster position outside the viewport, first set a valid
        /// raster position, then call  <see cref="glBitmap"/>  with NULL as the  bitmap 
        /// parameter.
        /// When the <code>ARB_imaging</code> extension is supported, there are distinct
        /// raster texture coordinates for each texture unit. Each texture unit's
        /// current raster texture coordinates are updated by <see cref="glRasterPos"/>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glRasterPos"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glRasterPos3fv(const GLfloat * v);</para>
        /// </summary>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array of two,
        /// three,
        /// or four elements,
        /// specifying 
        /// x   ,
        /// y   ,
        /// z   ,
        /// and 
        /// w   
        /// coordinates, respectively.
        /// </para>
        /// </param>
        /// <seealso cref="glBitmap"/>
        /// <seealso cref="glCopyPixels"/>
        /// <seealso cref="glDrawArrays"/>
        /// <seealso cref="glDrawElements"/>
        /// <seealso cref="glDrawRangeElements"/>
        /// <seealso cref="glDrawPixels"/>
        /// <seealso cref="glMultiTexCoord"/>
        /// <seealso cref="glTexCoord"/>
        /// <seealso cref="glTexGen"/>
        /// <seealso cref="glVertex"/>
        /// <seealso cref="glWindowPos"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void glRasterPos3fv(float* v) {
            var _F = _GetProc<GLNativeDelegate.FNglRasterPos3fv>("glRasterPos3fv");
            _F(v);
        }
        /// <summary>
        /// specify the raster position for pixel operations
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The raster position is modified by <see cref="glRasterPos"/>,  <see cref="glBitmap"/> , and  <see cref="glWindowPos"/> .
        /// When the raster position coordinates are invalid,
        /// drawing commands that are based on the raster position are
        /// ignored (that is, they do not result in changes to GL state).
        /// Calling  <see cref="glDrawElements"/>  or  <see cref="glDrawRangeElements"/>  may leave the
        /// current color or index indeterminate.
        /// If <see cref="glRasterPos"/> is executed while the current color or index is indeterminate, the
        /// current raster color or current raster index remains indeterminate.
        /// To set a valid raster position outside the viewport, first set a valid
        /// raster position, then call  <see cref="glBitmap"/>  with NULL as the  bitmap 
        /// parameter.
        /// When the <code>ARB_imaging</code> extension is supported, there are distinct
        /// raster texture coordinates for each texture unit. Each texture unit's
        /// current raster texture coordinates are updated by <see cref="glRasterPos"/>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glRasterPos"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glRasterPos3i(GLint x, GLint y, GLint z);</para>
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify the 
        /// x   ,
        /// y   ,
        /// z   ,
        /// and 
        /// w   
        /// object coordinates
        /// (if present)
        /// for the raster
        /// position.
        /// </para>
        /// </param>
        /// <param name="y">
        /// <para>
        /// Specify the 
        /// x   ,
        /// y   ,
        /// z   ,
        /// and 
        /// w   
        /// object coordinates
        /// (if present)
        /// for the raster
        /// position.
        /// </para>
        /// </param>
        /// <param name="z">
        /// <para>
        /// Specify the 
        /// x   ,
        /// y   ,
        /// z   ,
        /// and 
        /// w   
        /// object coordinates
        /// (if present)
        /// for the raster
        /// position.
        /// </para>
        /// </param>
        /// <seealso cref="glBitmap"/>
        /// <seealso cref="glCopyPixels"/>
        /// <seealso cref="glDrawArrays"/>
        /// <seealso cref="glDrawElements"/>
        /// <seealso cref="glDrawRangeElements"/>
        /// <seealso cref="glDrawPixels"/>
        /// <seealso cref="glMultiTexCoord"/>
        /// <seealso cref="glTexCoord"/>
        /// <seealso cref="glTexGen"/>
        /// <seealso cref="glVertex"/>
        /// <seealso cref="glWindowPos"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void glRasterPos3i(int x, int y, int z) {
            var _F = _GetProc<GLNativeDelegate.FNglRasterPos3i>("glRasterPos3i");
            _F(x, y, z);
        }
        /// <summary>
        /// specify the raster position for pixel operations
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The raster position is modified by <see cref="glRasterPos"/>,  <see cref="glBitmap"/> , and  <see cref="glWindowPos"/> .
        /// When the raster position coordinates are invalid,
        /// drawing commands that are based on the raster position are
        /// ignored (that is, they do not result in changes to GL state).
        /// Calling  <see cref="glDrawElements"/>  or  <see cref="glDrawRangeElements"/>  may leave the
        /// current color or index indeterminate.
        /// If <see cref="glRasterPos"/> is executed while the current color or index is indeterminate, the
        /// current raster color or current raster index remains indeterminate.
        /// To set a valid raster position outside the viewport, first set a valid
        /// raster position, then call  <see cref="glBitmap"/>  with NULL as the  bitmap 
        /// parameter.
        /// When the <code>ARB_imaging</code> extension is supported, there are distinct
        /// raster texture coordinates for each texture unit. Each texture unit's
        /// current raster texture coordinates are updated by <see cref="glRasterPos"/>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glRasterPos"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glRasterPos3iv(const GLint * v);</para>
        /// </summary>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array of two,
        /// three,
        /// or four elements,
        /// specifying 
        /// x   ,
        /// y   ,
        /// z   ,
        /// and 
        /// w   
        /// coordinates, respectively.
        /// </para>
        /// </param>
        /// <seealso cref="glBitmap"/>
        /// <seealso cref="glCopyPixels"/>
        /// <seealso cref="glDrawArrays"/>
        /// <seealso cref="glDrawElements"/>
        /// <seealso cref="glDrawRangeElements"/>
        /// <seealso cref="glDrawPixels"/>
        /// <seealso cref="glMultiTexCoord"/>
        /// <seealso cref="glTexCoord"/>
        /// <seealso cref="glTexGen"/>
        /// <seealso cref="glVertex"/>
        /// <seealso cref="glWindowPos"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void glRasterPos3iv(int* v) {
            var _F = _GetProc<GLNativeDelegate.FNglRasterPos3iv>("glRasterPos3iv");
            _F(v);
        }
        /// <summary>
        /// specify the raster position for pixel operations
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The raster position is modified by <see cref="glRasterPos"/>,  <see cref="glBitmap"/> , and  <see cref="glWindowPos"/> .
        /// When the raster position coordinates are invalid,
        /// drawing commands that are based on the raster position are
        /// ignored (that is, they do not result in changes to GL state).
        /// Calling  <see cref="glDrawElements"/>  or  <see cref="glDrawRangeElements"/>  may leave the
        /// current color or index indeterminate.
        /// If <see cref="glRasterPos"/> is executed while the current color or index is indeterminate, the
        /// current raster color or current raster index remains indeterminate.
        /// To set a valid raster position outside the viewport, first set a valid
        /// raster position, then call  <see cref="glBitmap"/>  with NULL as the  bitmap 
        /// parameter.
        /// When the <code>ARB_imaging</code> extension is supported, there are distinct
        /// raster texture coordinates for each texture unit. Each texture unit's
        /// current raster texture coordinates are updated by <see cref="glRasterPos"/>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glRasterPos"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glRasterPos3s(GLshort x, GLshort y, GLshort z);</para>
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify the 
        /// x   ,
        /// y   ,
        /// z   ,
        /// and 
        /// w   
        /// object coordinates
        /// (if present)
        /// for the raster
        /// position.
        /// </para>
        /// </param>
        /// <param name="y">
        /// <para>
        /// Specify the 
        /// x   ,
        /// y   ,
        /// z   ,
        /// and 
        /// w   
        /// object coordinates
        /// (if present)
        /// for the raster
        /// position.
        /// </para>
        /// </param>
        /// <param name="z">
        /// <para>
        /// Specify the 
        /// x   ,
        /// y   ,
        /// z   ,
        /// and 
        /// w   
        /// object coordinates
        /// (if present)
        /// for the raster
        /// position.
        /// </para>
        /// </param>
        /// <seealso cref="glBitmap"/>
        /// <seealso cref="glCopyPixels"/>
        /// <seealso cref="glDrawArrays"/>
        /// <seealso cref="glDrawElements"/>
        /// <seealso cref="glDrawRangeElements"/>
        /// <seealso cref="glDrawPixels"/>
        /// <seealso cref="glMultiTexCoord"/>
        /// <seealso cref="glTexCoord"/>
        /// <seealso cref="glTexGen"/>
        /// <seealso cref="glVertex"/>
        /// <seealso cref="glWindowPos"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void glRasterPos3s(short x, short y, short z) {
            var _F = _GetProc<GLNativeDelegate.FNglRasterPos3s>("glRasterPos3s");
            _F(x, y, z);
        }
        /// <summary>
        /// specify the raster position for pixel operations
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The raster position is modified by <see cref="glRasterPos"/>,  <see cref="glBitmap"/> , and  <see cref="glWindowPos"/> .
        /// When the raster position coordinates are invalid,
        /// drawing commands that are based on the raster position are
        /// ignored (that is, they do not result in changes to GL state).
        /// Calling  <see cref="glDrawElements"/>  or  <see cref="glDrawRangeElements"/>  may leave the
        /// current color or index indeterminate.
        /// If <see cref="glRasterPos"/> is executed while the current color or index is indeterminate, the
        /// current raster color or current raster index remains indeterminate.
        /// To set a valid raster position outside the viewport, first set a valid
        /// raster position, then call  <see cref="glBitmap"/>  with NULL as the  bitmap 
        /// parameter.
        /// When the <code>ARB_imaging</code> extension is supported, there are distinct
        /// raster texture coordinates for each texture unit. Each texture unit's
        /// current raster texture coordinates are updated by <see cref="glRasterPos"/>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glRasterPos"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glRasterPos3sv(const GLshort * v);</para>
        /// </summary>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array of two,
        /// three,
        /// or four elements,
        /// specifying 
        /// x   ,
        /// y   ,
        /// z   ,
        /// and 
        /// w   
        /// coordinates, respectively.
        /// </para>
        /// </param>
        /// <seealso cref="glBitmap"/>
        /// <seealso cref="glCopyPixels"/>
        /// <seealso cref="glDrawArrays"/>
        /// <seealso cref="glDrawElements"/>
        /// <seealso cref="glDrawRangeElements"/>
        /// <seealso cref="glDrawPixels"/>
        /// <seealso cref="glMultiTexCoord"/>
        /// <seealso cref="glTexCoord"/>
        /// <seealso cref="glTexGen"/>
        /// <seealso cref="glVertex"/>
        /// <seealso cref="glWindowPos"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void glRasterPos3sv(short* v) {
            var _F = _GetProc<GLNativeDelegate.FNglRasterPos3sv>("glRasterPos3sv");
            _F(v);
        }
        /// <summary>
        /// specify the raster position for pixel operations
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The raster position is modified by <see cref="glRasterPos"/>,  <see cref="glBitmap"/> , and  <see cref="glWindowPos"/> .
        /// When the raster position coordinates are invalid,
        /// drawing commands that are based on the raster position are
        /// ignored (that is, they do not result in changes to GL state).
        /// Calling  <see cref="glDrawElements"/>  or  <see cref="glDrawRangeElements"/>  may leave the
        /// current color or index indeterminate.
        /// If <see cref="glRasterPos"/> is executed while the current color or index is indeterminate, the
        /// current raster color or current raster index remains indeterminate.
        /// To set a valid raster position outside the viewport, first set a valid
        /// raster position, then call  <see cref="glBitmap"/>  with NULL as the  bitmap 
        /// parameter.
        /// When the <code>ARB_imaging</code> extension is supported, there are distinct
        /// raster texture coordinates for each texture unit. Each texture unit's
        /// current raster texture coordinates are updated by <see cref="glRasterPos"/>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glRasterPos"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glRasterPos4d(GLdouble x, GLdouble y, GLdouble z, GLdouble w);</para>
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify the 
        /// x   ,
        /// y   ,
        /// z   ,
        /// and 
        /// w   
        /// object coordinates
        /// (if present)
        /// for the raster
        /// position.
        /// </para>
        /// </param>
        /// <param name="y">
        /// <para>
        /// Specify the 
        /// x   ,
        /// y   ,
        /// z   ,
        /// and 
        /// w   
        /// object coordinates
        /// (if present)
        /// for the raster
        /// position.
        /// </para>
        /// </param>
        /// <param name="z">
        /// <para>
        /// Specify the 
        /// x   ,
        /// y   ,
        /// z   ,
        /// and 
        /// w   
        /// object coordinates
        /// (if present)
        /// for the raster
        /// position.
        /// </para>
        /// </param>
        /// <param name="w">
        /// <para>
        /// Specify the 
        /// x   ,
        /// y   ,
        /// z   ,
        /// and 
        /// w   
        /// object coordinates
        /// (if present)
        /// for the raster
        /// position.
        /// </para>
        /// </param>
        /// <seealso cref="glBitmap"/>
        /// <seealso cref="glCopyPixels"/>
        /// <seealso cref="glDrawArrays"/>
        /// <seealso cref="glDrawElements"/>
        /// <seealso cref="glDrawRangeElements"/>
        /// <seealso cref="glDrawPixels"/>
        /// <seealso cref="glMultiTexCoord"/>
        /// <seealso cref="glTexCoord"/>
        /// <seealso cref="glTexGen"/>
        /// <seealso cref="glVertex"/>
        /// <seealso cref="glWindowPos"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void glRasterPos4d(double x, double y, double z, double w) {
            var _F = _GetProc<GLNativeDelegate.FNglRasterPos4d>("glRasterPos4d");
            _F(x, y, z, w);
        }
        /// <summary>
        /// specify the raster position for pixel operations
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The raster position is modified by <see cref="glRasterPos"/>,  <see cref="glBitmap"/> , and  <see cref="glWindowPos"/> .
        /// When the raster position coordinates are invalid,
        /// drawing commands that are based on the raster position are
        /// ignored (that is, they do not result in changes to GL state).
        /// Calling  <see cref="glDrawElements"/>  or  <see cref="glDrawRangeElements"/>  may leave the
        /// current color or index indeterminate.
        /// If <see cref="glRasterPos"/> is executed while the current color or index is indeterminate, the
        /// current raster color or current raster index remains indeterminate.
        /// To set a valid raster position outside the viewport, first set a valid
        /// raster position, then call  <see cref="glBitmap"/>  with NULL as the  bitmap 
        /// parameter.
        /// When the <code>ARB_imaging</code> extension is supported, there are distinct
        /// raster texture coordinates for each texture unit. Each texture unit's
        /// current raster texture coordinates are updated by <see cref="glRasterPos"/>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glRasterPos"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glRasterPos4dv(const GLdouble * v);</para>
        /// </summary>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array of two,
        /// three,
        /// or four elements,
        /// specifying 
        /// x   ,
        /// y   ,
        /// z   ,
        /// and 
        /// w   
        /// coordinates, respectively.
        /// </para>
        /// </param>
        /// <seealso cref="glBitmap"/>
        /// <seealso cref="glCopyPixels"/>
        /// <seealso cref="glDrawArrays"/>
        /// <seealso cref="glDrawElements"/>
        /// <seealso cref="glDrawRangeElements"/>
        /// <seealso cref="glDrawPixels"/>
        /// <seealso cref="glMultiTexCoord"/>
        /// <seealso cref="glTexCoord"/>
        /// <seealso cref="glTexGen"/>
        /// <seealso cref="glVertex"/>
        /// <seealso cref="glWindowPos"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void glRasterPos4dv(double* v) {
            var _F = _GetProc<GLNativeDelegate.FNglRasterPos4dv>("glRasterPos4dv");
            _F(v);
        }
        /// <summary>
        /// specify the raster position for pixel operations
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The raster position is modified by <see cref="glRasterPos"/>,  <see cref="glBitmap"/> , and  <see cref="glWindowPos"/> .
        /// When the raster position coordinates are invalid,
        /// drawing commands that are based on the raster position are
        /// ignored (that is, they do not result in changes to GL state).
        /// Calling  <see cref="glDrawElements"/>  or  <see cref="glDrawRangeElements"/>  may leave the
        /// current color or index indeterminate.
        /// If <see cref="glRasterPos"/> is executed while the current color or index is indeterminate, the
        /// current raster color or current raster index remains indeterminate.
        /// To set a valid raster position outside the viewport, first set a valid
        /// raster position, then call  <see cref="glBitmap"/>  with NULL as the  bitmap 
        /// parameter.
        /// When the <code>ARB_imaging</code> extension is supported, there are distinct
        /// raster texture coordinates for each texture unit. Each texture unit's
        /// current raster texture coordinates are updated by <see cref="glRasterPos"/>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glRasterPos"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glRasterPos4f(GLfloat x, GLfloat y, GLfloat z, GLfloat w);</para>
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify the 
        /// x   ,
        /// y   ,
        /// z   ,
        /// and 
        /// w   
        /// object coordinates
        /// (if present)
        /// for the raster
        /// position.
        /// </para>
        /// </param>
        /// <param name="y">
        /// <para>
        /// Specify the 
        /// x   ,
        /// y   ,
        /// z   ,
        /// and 
        /// w   
        /// object coordinates
        /// (if present)
        /// for the raster
        /// position.
        /// </para>
        /// </param>
        /// <param name="z">
        /// <para>
        /// Specify the 
        /// x   ,
        /// y   ,
        /// z   ,
        /// and 
        /// w   
        /// object coordinates
        /// (if present)
        /// for the raster
        /// position.
        /// </para>
        /// </param>
        /// <param name="w">
        /// <para>
        /// Specify the 
        /// x   ,
        /// y   ,
        /// z   ,
        /// and 
        /// w   
        /// object coordinates
        /// (if present)
        /// for the raster
        /// position.
        /// </para>
        /// </param>
        /// <seealso cref="glBitmap"/>
        /// <seealso cref="glCopyPixels"/>
        /// <seealso cref="glDrawArrays"/>
        /// <seealso cref="glDrawElements"/>
        /// <seealso cref="glDrawRangeElements"/>
        /// <seealso cref="glDrawPixels"/>
        /// <seealso cref="glMultiTexCoord"/>
        /// <seealso cref="glTexCoord"/>
        /// <seealso cref="glTexGen"/>
        /// <seealso cref="glVertex"/>
        /// <seealso cref="glWindowPos"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void glRasterPos4f(float x, float y, float z, float w) {
            var _F = _GetProc<GLNativeDelegate.FNglRasterPos4f>("glRasterPos4f");
            _F(x, y, z, w);
        }
        /// <summary>
        /// specify the raster position for pixel operations
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The raster position is modified by <see cref="glRasterPos"/>,  <see cref="glBitmap"/> , and  <see cref="glWindowPos"/> .
        /// When the raster position coordinates are invalid,
        /// drawing commands that are based on the raster position are
        /// ignored (that is, they do not result in changes to GL state).
        /// Calling  <see cref="glDrawElements"/>  or  <see cref="glDrawRangeElements"/>  may leave the
        /// current color or index indeterminate.
        /// If <see cref="glRasterPos"/> is executed while the current color or index is indeterminate, the
        /// current raster color or current raster index remains indeterminate.
        /// To set a valid raster position outside the viewport, first set a valid
        /// raster position, then call  <see cref="glBitmap"/>  with NULL as the  bitmap 
        /// parameter.
        /// When the <code>ARB_imaging</code> extension is supported, there are distinct
        /// raster texture coordinates for each texture unit. Each texture unit's
        /// current raster texture coordinates are updated by <see cref="glRasterPos"/>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glRasterPos"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glRasterPos4fv(const GLfloat * v);</para>
        /// </summary>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array of two,
        /// three,
        /// or four elements,
        /// specifying 
        /// x   ,
        /// y   ,
        /// z   ,
        /// and 
        /// w   
        /// coordinates, respectively.
        /// </para>
        /// </param>
        /// <seealso cref="glBitmap"/>
        /// <seealso cref="glCopyPixels"/>
        /// <seealso cref="glDrawArrays"/>
        /// <seealso cref="glDrawElements"/>
        /// <seealso cref="glDrawRangeElements"/>
        /// <seealso cref="glDrawPixels"/>
        /// <seealso cref="glMultiTexCoord"/>
        /// <seealso cref="glTexCoord"/>
        /// <seealso cref="glTexGen"/>
        /// <seealso cref="glVertex"/>
        /// <seealso cref="glWindowPos"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void glRasterPos4fv(float* v) {
            var _F = _GetProc<GLNativeDelegate.FNglRasterPos4fv>("glRasterPos4fv");
            _F(v);
        }
        /// <summary>
        /// specify the raster position for pixel operations
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The raster position is modified by <see cref="glRasterPos"/>,  <see cref="glBitmap"/> , and  <see cref="glWindowPos"/> .
        /// When the raster position coordinates are invalid,
        /// drawing commands that are based on the raster position are
        /// ignored (that is, they do not result in changes to GL state).
        /// Calling  <see cref="glDrawElements"/>  or  <see cref="glDrawRangeElements"/>  may leave the
        /// current color or index indeterminate.
        /// If <see cref="glRasterPos"/> is executed while the current color or index is indeterminate, the
        /// current raster color or current raster index remains indeterminate.
        /// To set a valid raster position outside the viewport, first set a valid
        /// raster position, then call  <see cref="glBitmap"/>  with NULL as the  bitmap 
        /// parameter.
        /// When the <code>ARB_imaging</code> extension is supported, there are distinct
        /// raster texture coordinates for each texture unit. Each texture unit's
        /// current raster texture coordinates are updated by <see cref="glRasterPos"/>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glRasterPos"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glRasterPos4i(GLint x, GLint y, GLint z, GLint w);</para>
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify the 
        /// x   ,
        /// y   ,
        /// z   ,
        /// and 
        /// w   
        /// object coordinates
        /// (if present)
        /// for the raster
        /// position.
        /// </para>
        /// </param>
        /// <param name="y">
        /// <para>
        /// Specify the 
        /// x   ,
        /// y   ,
        /// z   ,
        /// and 
        /// w   
        /// object coordinates
        /// (if present)
        /// for the raster
        /// position.
        /// </para>
        /// </param>
        /// <param name="z">
        /// <para>
        /// Specify the 
        /// x   ,
        /// y   ,
        /// z   ,
        /// and 
        /// w   
        /// object coordinates
        /// (if present)
        /// for the raster
        /// position.
        /// </para>
        /// </param>
        /// <param name="w">
        /// <para>
        /// Specify the 
        /// x   ,
        /// y   ,
        /// z   ,
        /// and 
        /// w   
        /// object coordinates
        /// (if present)
        /// for the raster
        /// position.
        /// </para>
        /// </param>
        /// <seealso cref="glBitmap"/>
        /// <seealso cref="glCopyPixels"/>
        /// <seealso cref="glDrawArrays"/>
        /// <seealso cref="glDrawElements"/>
        /// <seealso cref="glDrawRangeElements"/>
        /// <seealso cref="glDrawPixels"/>
        /// <seealso cref="glMultiTexCoord"/>
        /// <seealso cref="glTexCoord"/>
        /// <seealso cref="glTexGen"/>
        /// <seealso cref="glVertex"/>
        /// <seealso cref="glWindowPos"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void glRasterPos4i(int x, int y, int z, int w) {
            var _F = _GetProc<GLNativeDelegate.FNglRasterPos4i>("glRasterPos4i");
            _F(x, y, z, w);
        }
        /// <summary>
        /// specify the raster position for pixel operations
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The raster position is modified by <see cref="glRasterPos"/>,  <see cref="glBitmap"/> , and  <see cref="glWindowPos"/> .
        /// When the raster position coordinates are invalid,
        /// drawing commands that are based on the raster position are
        /// ignored (that is, they do not result in changes to GL state).
        /// Calling  <see cref="glDrawElements"/>  or  <see cref="glDrawRangeElements"/>  may leave the
        /// current color or index indeterminate.
        /// If <see cref="glRasterPos"/> is executed while the current color or index is indeterminate, the
        /// current raster color or current raster index remains indeterminate.
        /// To set a valid raster position outside the viewport, first set a valid
        /// raster position, then call  <see cref="glBitmap"/>  with NULL as the  bitmap 
        /// parameter.
        /// When the <code>ARB_imaging</code> extension is supported, there are distinct
        /// raster texture coordinates for each texture unit. Each texture unit's
        /// current raster texture coordinates are updated by <see cref="glRasterPos"/>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glRasterPos"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glRasterPos4iv(const GLint * v);</para>
        /// </summary>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array of two,
        /// three,
        /// or four elements,
        /// specifying 
        /// x   ,
        /// y   ,
        /// z   ,
        /// and 
        /// w   
        /// coordinates, respectively.
        /// </para>
        /// </param>
        /// <seealso cref="glBitmap"/>
        /// <seealso cref="glCopyPixels"/>
        /// <seealso cref="glDrawArrays"/>
        /// <seealso cref="glDrawElements"/>
        /// <seealso cref="glDrawRangeElements"/>
        /// <seealso cref="glDrawPixels"/>
        /// <seealso cref="glMultiTexCoord"/>
        /// <seealso cref="glTexCoord"/>
        /// <seealso cref="glTexGen"/>
        /// <seealso cref="glVertex"/>
        /// <seealso cref="glWindowPos"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void glRasterPos4iv(int* v) {
            var _F = _GetProc<GLNativeDelegate.FNglRasterPos4iv>("glRasterPos4iv");
            _F(v);
        }
        /// <summary>
        /// specify the raster position for pixel operations
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The raster position is modified by <see cref="glRasterPos"/>,  <see cref="glBitmap"/> , and  <see cref="glWindowPos"/> .
        /// When the raster position coordinates are invalid,
        /// drawing commands that are based on the raster position are
        /// ignored (that is, they do not result in changes to GL state).
        /// Calling  <see cref="glDrawElements"/>  or  <see cref="glDrawRangeElements"/>  may leave the
        /// current color or index indeterminate.
        /// If <see cref="glRasterPos"/> is executed while the current color or index is indeterminate, the
        /// current raster color or current raster index remains indeterminate.
        /// To set a valid raster position outside the viewport, first set a valid
        /// raster position, then call  <see cref="glBitmap"/>  with NULL as the  bitmap 
        /// parameter.
        /// When the <code>ARB_imaging</code> extension is supported, there are distinct
        /// raster texture coordinates for each texture unit. Each texture unit's
        /// current raster texture coordinates are updated by <see cref="glRasterPos"/>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glRasterPos"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glRasterPos4s(GLshort x, GLshort y, GLshort z, GLshort w);</para>
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify the 
        /// x   ,
        /// y   ,
        /// z   ,
        /// and 
        /// w   
        /// object coordinates
        /// (if present)
        /// for the raster
        /// position.
        /// </para>
        /// </param>
        /// <param name="y">
        /// <para>
        /// Specify the 
        /// x   ,
        /// y   ,
        /// z   ,
        /// and 
        /// w   
        /// object coordinates
        /// (if present)
        /// for the raster
        /// position.
        /// </para>
        /// </param>
        /// <param name="z">
        /// <para>
        /// Specify the 
        /// x   ,
        /// y   ,
        /// z   ,
        /// and 
        /// w   
        /// object coordinates
        /// (if present)
        /// for the raster
        /// position.
        /// </para>
        /// </param>
        /// <param name="w">
        /// <para>
        /// Specify the 
        /// x   ,
        /// y   ,
        /// z   ,
        /// and 
        /// w   
        /// object coordinates
        /// (if present)
        /// for the raster
        /// position.
        /// </para>
        /// </param>
        /// <seealso cref="glBitmap"/>
        /// <seealso cref="glCopyPixels"/>
        /// <seealso cref="glDrawArrays"/>
        /// <seealso cref="glDrawElements"/>
        /// <seealso cref="glDrawRangeElements"/>
        /// <seealso cref="glDrawPixels"/>
        /// <seealso cref="glMultiTexCoord"/>
        /// <seealso cref="glTexCoord"/>
        /// <seealso cref="glTexGen"/>
        /// <seealso cref="glVertex"/>
        /// <seealso cref="glWindowPos"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void glRasterPos4s(short x, short y, short z, short w) {
            var _F = _GetProc<GLNativeDelegate.FNglRasterPos4s>("glRasterPos4s");
            _F(x, y, z, w);
        }
        /// <summary>
        /// specify the raster position for pixel operations
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The raster position is modified by <see cref="glRasterPos"/>,  <see cref="glBitmap"/> , and  <see cref="glWindowPos"/> .
        /// When the raster position coordinates are invalid,
        /// drawing commands that are based on the raster position are
        /// ignored (that is, they do not result in changes to GL state).
        /// Calling  <see cref="glDrawElements"/>  or  <see cref="glDrawRangeElements"/>  may leave the
        /// current color or index indeterminate.
        /// If <see cref="glRasterPos"/> is executed while the current color or index is indeterminate, the
        /// current raster color or current raster index remains indeterminate.
        /// To set a valid raster position outside the viewport, first set a valid
        /// raster position, then call  <see cref="glBitmap"/>  with NULL as the  bitmap 
        /// parameter.
        /// When the <code>ARB_imaging</code> extension is supported, there are distinct
        /// raster texture coordinates for each texture unit. Each texture unit's
        /// current raster texture coordinates are updated by <see cref="glRasterPos"/>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glRasterPos"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glRasterPos4sv(const GLshort * v);</para>
        /// </summary>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array of two,
        /// three,
        /// or four elements,
        /// specifying 
        /// x   ,
        /// y   ,
        /// z   ,
        /// and 
        /// w   
        /// coordinates, respectively.
        /// </para>
        /// </param>
        /// <seealso cref="glBitmap"/>
        /// <seealso cref="glCopyPixels"/>
        /// <seealso cref="glDrawArrays"/>
        /// <seealso cref="glDrawElements"/>
        /// <seealso cref="glDrawRangeElements"/>
        /// <seealso cref="glDrawPixels"/>
        /// <seealso cref="glMultiTexCoord"/>
        /// <seealso cref="glTexCoord"/>
        /// <seealso cref="glTexGen"/>
        /// <seealso cref="glVertex"/>
        /// <seealso cref="glWindowPos"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void glRasterPos4sv(short* v) {
            var _F = _GetProc<GLNativeDelegate.FNglRasterPos4sv>("glRasterPos4sv");
            _F(v);
        }
        /// <summary>
        /// draw a rectangle
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glRect"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glRectd(GLdouble x1, GLdouble y1, GLdouble x2, GLdouble y2);</para>
        /// </summary>
        /// <param name="x1">
        /// Specify one vertex of a rectangle.
        /// </param>
        /// <param name="y1">
        /// Specify one vertex of a rectangle.
        /// </param>
        /// <param name="x2">
        /// Specify the opposite vertex of the rectangle.
        /// </param>
        /// <param name="y2">
        /// Specify the opposite vertex of the rectangle.
        /// </param>
        /// <seealso cref="glBegin"/>
        /// <seealso cref="glVertex"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void glRectd(double x1, double y1, double x2, double y2) {
            var _F = _GetProc<GLNativeDelegate.FNglRectd>("glRectd");
            _F(x1, y1, x2, y2);
        }
        /// <summary>
        /// draw a rectangle
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glRect"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glRectdv(const GLdouble * v1, const GLdouble * v2);</para>
        /// </summary>
        /// <param name="v1">
        /// Specifies a pointer to one vertex of a rectangle.
        /// </param>
        /// <param name="v2">
        /// Specifies a pointer to the opposite vertex of the rectangle.
        /// </param>
        /// <seealso cref="glBegin"/>
        /// <seealso cref="glVertex"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void glRectdv(double* v1, double* v2) {
            var _F = _GetProc<GLNativeDelegate.FNglRectdv>("glRectdv");
            _F(v1, v2);
        }
        /// <summary>
        /// draw a rectangle
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glRect"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glRectf(GLfloat x1, GLfloat y1, GLfloat x2, GLfloat y2);</para>
        /// </summary>
        /// <param name="x1">
        /// Specify one vertex of a rectangle.
        /// </param>
        /// <param name="y1">
        /// Specify one vertex of a rectangle.
        /// </param>
        /// <param name="x2">
        /// Specify the opposite vertex of the rectangle.
        /// </param>
        /// <param name="y2">
        /// Specify the opposite vertex of the rectangle.
        /// </param>
        /// <seealso cref="glBegin"/>
        /// <seealso cref="glVertex"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void glRectf(float x1, float y1, float x2, float y2) {
            var _F = _GetProc<GLNativeDelegate.FNglRectf>("glRectf");
            _F(x1, y1, x2, y2);
        }
        /// <summary>
        /// draw a rectangle
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glRect"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glRectfv(const GLfloat * v1, const GLfloat * v2);</para>
        /// </summary>
        /// <param name="v1">
        /// Specifies a pointer to one vertex of a rectangle.
        /// </param>
        /// <param name="v2">
        /// Specifies a pointer to the opposite vertex of the rectangle.
        /// </param>
        /// <seealso cref="glBegin"/>
        /// <seealso cref="glVertex"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void glRectfv(float* v1, float* v2) {
            var _F = _GetProc<GLNativeDelegate.FNglRectfv>("glRectfv");
            _F(v1, v2);
        }
        /// <summary>
        /// draw a rectangle
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glRect"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glRecti(GLint x1, GLint y1, GLint x2, GLint y2);</para>
        /// </summary>
        /// <param name="x1">
        /// Specify one vertex of a rectangle.
        /// </param>
        /// <param name="y1">
        /// Specify one vertex of a rectangle.
        /// </param>
        /// <param name="x2">
        /// Specify the opposite vertex of the rectangle.
        /// </param>
        /// <param name="y2">
        /// Specify the opposite vertex of the rectangle.
        /// </param>
        /// <seealso cref="glBegin"/>
        /// <seealso cref="glVertex"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void glRecti(int x1, int y1, int x2, int y2) {
            var _F = _GetProc<GLNativeDelegate.FNglRecti>("glRecti");
            _F(x1, y1, x2, y2);
        }
        /// <summary>
        /// draw a rectangle
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glRect"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glRectiv(const GLint * v1, const GLint * v2);</para>
        /// </summary>
        /// <param name="v1">
        /// Specifies a pointer to one vertex of a rectangle.
        /// </param>
        /// <param name="v2">
        /// Specifies a pointer to the opposite vertex of the rectangle.
        /// </param>
        /// <seealso cref="glBegin"/>
        /// <seealso cref="glVertex"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void glRectiv(int* v1, int* v2) {
            var _F = _GetProc<GLNativeDelegate.FNglRectiv>("glRectiv");
            _F(v1, v2);
        }
        /// <summary>
        /// draw a rectangle
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glRect"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glRects(GLshort x1, GLshort y1, GLshort x2, GLshort y2);</para>
        /// </summary>
        /// <param name="x1">
        /// Specify one vertex of a rectangle.
        /// </param>
        /// <param name="y1">
        /// Specify one vertex of a rectangle.
        /// </param>
        /// <param name="x2">
        /// Specify the opposite vertex of the rectangle.
        /// </param>
        /// <param name="y2">
        /// Specify the opposite vertex of the rectangle.
        /// </param>
        /// <seealso cref="glBegin"/>
        /// <seealso cref="glVertex"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void glRects(short x1, short y1, short x2, short y2) {
            var _F = _GetProc<GLNativeDelegate.FNglRects>("glRects");
            _F(x1, y1, x2, y2);
        }
        /// <summary>
        /// draw a rectangle
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glRect"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glRectsv(const GLshort * v1, const GLshort * v2);</para>
        /// </summary>
        /// <param name="v1">
        /// Specifies a pointer to one vertex of a rectangle.
        /// </param>
        /// <param name="v2">
        /// Specifies a pointer to the opposite vertex of the rectangle.
        /// </param>
        /// <seealso cref="glBegin"/>
        /// <seealso cref="glVertex"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void glRectsv(short* v1, short* v2) {
            var _F = _GetProc<GLNativeDelegate.FNglRectsv>("glRectsv");
            _F(v1, v2);
        }
        /// <summary>
        /// set the current texture coordinates
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The current texture coordinates can be updated at any time.
        /// In particular,
        /// <see cref="glTexCoord"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// When the <code>ARB_imaging</code> extension is supported, <see cref="glTexCoord"/> always
        /// updates texture unit <code>GL_TEXTURE0</code>.
        /// </para>
        /// Original: <para>void glTexCoord1d(GLdouble s);</para>
        /// </summary>
        /// <param name="s">
        /// <para>
        /// Specify  s ,  t ,  r , and  q   texture coordinates.
        /// Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        /// <seealso cref="glMultiTexCoord"/>
        /// <seealso cref="glTexCoordPointer"/>
        /// <seealso cref="glVertex"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void glTexCoord1d(double s) {
            var _F = _GetProc<GLNativeDelegate.FNglTexCoord1d>("glTexCoord1d");
            _F(s);
        }
        /// <summary>
        /// set the current texture coordinates
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The current texture coordinates can be updated at any time.
        /// In particular,
        /// <see cref="glTexCoord"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// When the <code>ARB_imaging</code> extension is supported, <see cref="glTexCoord"/> always
        /// updates texture unit <code>GL_TEXTURE0</code>.
        /// </para>
        /// Original: <para>void glTexCoord1dv(const GLdouble * v);</para>
        /// </summary>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array of one, two, three, or four elements,
        /// which in turn specify the
        /// s ,
        /// t ,
        /// r , and
        /// q  texture coordinates.
        /// </para>
        /// </param>
        /// <seealso cref="glMultiTexCoord"/>
        /// <seealso cref="glTexCoordPointer"/>
        /// <seealso cref="glVertex"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void glTexCoord1dv(double* v) {
            var _F = _GetProc<GLNativeDelegate.FNglTexCoord1dv>("glTexCoord1dv");
            _F(v);
        }
        /// <summary>
        /// set the current texture coordinates
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The current texture coordinates can be updated at any time.
        /// In particular,
        /// <see cref="glTexCoord"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// When the <code>ARB_imaging</code> extension is supported, <see cref="glTexCoord"/> always
        /// updates texture unit <code>GL_TEXTURE0</code>.
        /// </para>
        /// Original: <para>void glTexCoord1f(GLfloat s);</para>
        /// </summary>
        /// <param name="s">
        /// <para>
        /// Specify  s ,  t ,  r , and  q   texture coordinates.
        /// Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        /// <seealso cref="glMultiTexCoord"/>
        /// <seealso cref="glTexCoordPointer"/>
        /// <seealso cref="glVertex"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void glTexCoord1f(float s) {
            var _F = _GetProc<GLNativeDelegate.FNglTexCoord1f>("glTexCoord1f");
            _F(s);
        }
        /// <summary>
        /// set the current texture coordinates
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The current texture coordinates can be updated at any time.
        /// In particular,
        /// <see cref="glTexCoord"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// When the <code>ARB_imaging</code> extension is supported, <see cref="glTexCoord"/> always
        /// updates texture unit <code>GL_TEXTURE0</code>.
        /// </para>
        /// Original: <para>void glTexCoord1fv(const GLfloat * v);</para>
        /// </summary>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array of one, two, three, or four elements,
        /// which in turn specify the
        /// s ,
        /// t ,
        /// r , and
        /// q  texture coordinates.
        /// </para>
        /// </param>
        /// <seealso cref="glMultiTexCoord"/>
        /// <seealso cref="glTexCoordPointer"/>
        /// <seealso cref="glVertex"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void glTexCoord1fv(float* v) {
            var _F = _GetProc<GLNativeDelegate.FNglTexCoord1fv>("glTexCoord1fv");
            _F(v);
        }
        /// <summary>
        /// set the current texture coordinates
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The current texture coordinates can be updated at any time.
        /// In particular,
        /// <see cref="glTexCoord"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// When the <code>ARB_imaging</code> extension is supported, <see cref="glTexCoord"/> always
        /// updates texture unit <code>GL_TEXTURE0</code>.
        /// </para>
        /// Original: <para>void glTexCoord1i(GLint s);</para>
        /// </summary>
        /// <param name="s">
        /// <para>
        /// Specify  s ,  t ,  r , and  q   texture coordinates.
        /// Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        /// <seealso cref="glMultiTexCoord"/>
        /// <seealso cref="glTexCoordPointer"/>
        /// <seealso cref="glVertex"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void glTexCoord1i(int s) {
            var _F = _GetProc<GLNativeDelegate.FNglTexCoord1i>("glTexCoord1i");
            _F(s);
        }
        /// <summary>
        /// set the current texture coordinates
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The current texture coordinates can be updated at any time.
        /// In particular,
        /// <see cref="glTexCoord"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// When the <code>ARB_imaging</code> extension is supported, <see cref="glTexCoord"/> always
        /// updates texture unit <code>GL_TEXTURE0</code>.
        /// </para>
        /// Original: <para>void glTexCoord1iv(const GLint * v);</para>
        /// </summary>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array of one, two, three, or four elements,
        /// which in turn specify the
        /// s ,
        /// t ,
        /// r , and
        /// q  texture coordinates.
        /// </para>
        /// </param>
        /// <seealso cref="glMultiTexCoord"/>
        /// <seealso cref="glTexCoordPointer"/>
        /// <seealso cref="glVertex"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void glTexCoord1iv(int* v) {
            var _F = _GetProc<GLNativeDelegate.FNglTexCoord1iv>("glTexCoord1iv");
            _F(v);
        }
        /// <summary>
        /// set the current texture coordinates
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The current texture coordinates can be updated at any time.
        /// In particular,
        /// <see cref="glTexCoord"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// When the <code>ARB_imaging</code> extension is supported, <see cref="glTexCoord"/> always
        /// updates texture unit <code>GL_TEXTURE0</code>.
        /// </para>
        /// Original: <para>void glTexCoord1s(GLshort s);</para>
        /// </summary>
        /// <param name="s">
        /// <para>
        /// Specify  s ,  t ,  r , and  q   texture coordinates.
        /// Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        /// <seealso cref="glMultiTexCoord"/>
        /// <seealso cref="glTexCoordPointer"/>
        /// <seealso cref="glVertex"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void glTexCoord1s(short s) {
            var _F = _GetProc<GLNativeDelegate.FNglTexCoord1s>("glTexCoord1s");
            _F(s);
        }
        /// <summary>
        /// set the current texture coordinates
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The current texture coordinates can be updated at any time.
        /// In particular,
        /// <see cref="glTexCoord"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// When the <code>ARB_imaging</code> extension is supported, <see cref="glTexCoord"/> always
        /// updates texture unit <code>GL_TEXTURE0</code>.
        /// </para>
        /// Original: <para>void glTexCoord1sv(const GLshort * v);</para>
        /// </summary>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array of one, two, three, or four elements,
        /// which in turn specify the
        /// s ,
        /// t ,
        /// r , and
        /// q  texture coordinates.
        /// </para>
        /// </param>
        /// <seealso cref="glMultiTexCoord"/>
        /// <seealso cref="glTexCoordPointer"/>
        /// <seealso cref="glVertex"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void glTexCoord1sv(short* v) {
            var _F = _GetProc<GLNativeDelegate.FNglTexCoord1sv>("glTexCoord1sv");
            _F(v);
        }
        /// <summary>
        /// set the current texture coordinates
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The current texture coordinates can be updated at any time.
        /// In particular,
        /// <see cref="glTexCoord"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// When the <code>ARB_imaging</code> extension is supported, <see cref="glTexCoord"/> always
        /// updates texture unit <code>GL_TEXTURE0</code>.
        /// </para>
        /// Original: <para>void glTexCoord2d(GLdouble s, GLdouble t);</para>
        /// </summary>
        /// <param name="s">
        /// <para>
        /// Specify  s ,  t ,  r , and  q   texture coordinates.
        /// Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        /// <param name="t">
        /// <para>
        /// Specify  s ,  t ,  r , and  q   texture coordinates.
        /// Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        /// <seealso cref="glMultiTexCoord"/>
        /// <seealso cref="glTexCoordPointer"/>
        /// <seealso cref="glVertex"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void glTexCoord2d(double s, double t) {
            var _F = _GetProc<GLNativeDelegate.FNglTexCoord2d>("glTexCoord2d");
            _F(s, t);
        }
        /// <summary>
        /// set the current texture coordinates
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The current texture coordinates can be updated at any time.
        /// In particular,
        /// <see cref="glTexCoord"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// When the <code>ARB_imaging</code> extension is supported, <see cref="glTexCoord"/> always
        /// updates texture unit <code>GL_TEXTURE0</code>.
        /// </para>
        /// Original: <para>void glTexCoord2dv(const GLdouble * v);</para>
        /// </summary>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array of one, two, three, or four elements,
        /// which in turn specify the
        /// s ,
        /// t ,
        /// r , and
        /// q  texture coordinates.
        /// </para>
        /// </param>
        /// <seealso cref="glMultiTexCoord"/>
        /// <seealso cref="glTexCoordPointer"/>
        /// <seealso cref="glVertex"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void glTexCoord2dv(double* v) {
            var _F = _GetProc<GLNativeDelegate.FNglTexCoord2dv>("glTexCoord2dv");
            _F(v);
        }
        /// <summary>
        /// set the current texture coordinates
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The current texture coordinates can be updated at any time.
        /// In particular,
        /// <see cref="glTexCoord"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// When the <code>ARB_imaging</code> extension is supported, <see cref="glTexCoord"/> always
        /// updates texture unit <code>GL_TEXTURE0</code>.
        /// </para>
        /// Original: <para>void glTexCoord2f(GLfloat s, GLfloat t);</para>
        /// </summary>
        /// <param name="s">
        /// <para>
        /// Specify  s ,  t ,  r , and  q   texture coordinates.
        /// Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        /// <param name="t">
        /// <para>
        /// Specify  s ,  t ,  r , and  q   texture coordinates.
        /// Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        /// <seealso cref="glMultiTexCoord"/>
        /// <seealso cref="glTexCoordPointer"/>
        /// <seealso cref="glVertex"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void glTexCoord2f(float s, float t) {
            var _F = _GetProc<GLNativeDelegate.FNglTexCoord2f>("glTexCoord2f");
            _F(s, t);
        }
        /// <summary>
        /// set the current texture coordinates
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The current texture coordinates can be updated at any time.
        /// In particular,
        /// <see cref="glTexCoord"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// When the <code>ARB_imaging</code> extension is supported, <see cref="glTexCoord"/> always
        /// updates texture unit <code>GL_TEXTURE0</code>.
        /// </para>
        /// Original: <para>void glTexCoord2fv(const GLfloat * v);</para>
        /// </summary>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array of one, two, three, or four elements,
        /// which in turn specify the
        /// s ,
        /// t ,
        /// r , and
        /// q  texture coordinates.
        /// </para>
        /// </param>
        /// <seealso cref="glMultiTexCoord"/>
        /// <seealso cref="glTexCoordPointer"/>
        /// <seealso cref="glVertex"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void glTexCoord2fv(float* v) {
            var _F = _GetProc<GLNativeDelegate.FNglTexCoord2fv>("glTexCoord2fv");
            _F(v);
        }
        /// <summary>
        /// set the current texture coordinates
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The current texture coordinates can be updated at any time.
        /// In particular,
        /// <see cref="glTexCoord"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// When the <code>ARB_imaging</code> extension is supported, <see cref="glTexCoord"/> always
        /// updates texture unit <code>GL_TEXTURE0</code>.
        /// </para>
        /// Original: <para>void glTexCoord2i(GLint s, GLint t);</para>
        /// </summary>
        /// <param name="s">
        /// <para>
        /// Specify  s ,  t ,  r , and  q   texture coordinates.
        /// Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        /// <param name="t">
        /// <para>
        /// Specify  s ,  t ,  r , and  q   texture coordinates.
        /// Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        /// <seealso cref="glMultiTexCoord"/>
        /// <seealso cref="glTexCoordPointer"/>
        /// <seealso cref="glVertex"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void glTexCoord2i(int s, int t) {
            var _F = _GetProc<GLNativeDelegate.FNglTexCoord2i>("glTexCoord2i");
            _F(s, t);
        }
        /// <summary>
        /// set the current texture coordinates
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The current texture coordinates can be updated at any time.
        /// In particular,
        /// <see cref="glTexCoord"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// When the <code>ARB_imaging</code> extension is supported, <see cref="glTexCoord"/> always
        /// updates texture unit <code>GL_TEXTURE0</code>.
        /// </para>
        /// Original: <para>void glTexCoord2iv(const GLint * v);</para>
        /// </summary>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array of one, two, three, or four elements,
        /// which in turn specify the
        /// s ,
        /// t ,
        /// r , and
        /// q  texture coordinates.
        /// </para>
        /// </param>
        /// <seealso cref="glMultiTexCoord"/>
        /// <seealso cref="glTexCoordPointer"/>
        /// <seealso cref="glVertex"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void glTexCoord2iv(int* v) {
            var _F = _GetProc<GLNativeDelegate.FNglTexCoord2iv>("glTexCoord2iv");
            _F(v);
        }
        /// <summary>
        /// set the current texture coordinates
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The current texture coordinates can be updated at any time.
        /// In particular,
        /// <see cref="glTexCoord"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// When the <code>ARB_imaging</code> extension is supported, <see cref="glTexCoord"/> always
        /// updates texture unit <code>GL_TEXTURE0</code>.
        /// </para>
        /// Original: <para>void glTexCoord2s(GLshort s, GLshort t);</para>
        /// </summary>
        /// <param name="s">
        /// <para>
        /// Specify  s ,  t ,  r , and  q   texture coordinates.
        /// Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        /// <param name="t">
        /// <para>
        /// Specify  s ,  t ,  r , and  q   texture coordinates.
        /// Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        /// <seealso cref="glMultiTexCoord"/>
        /// <seealso cref="glTexCoordPointer"/>
        /// <seealso cref="glVertex"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void glTexCoord2s(short s, short t) {
            var _F = _GetProc<GLNativeDelegate.FNglTexCoord2s>("glTexCoord2s");
            _F(s, t);
        }
        /// <summary>
        /// set the current texture coordinates
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The current texture coordinates can be updated at any time.
        /// In particular,
        /// <see cref="glTexCoord"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// When the <code>ARB_imaging</code> extension is supported, <see cref="glTexCoord"/> always
        /// updates texture unit <code>GL_TEXTURE0</code>.
        /// </para>
        /// Original: <para>void glTexCoord2sv(const GLshort * v);</para>
        /// </summary>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array of one, two, three, or four elements,
        /// which in turn specify the
        /// s ,
        /// t ,
        /// r , and
        /// q  texture coordinates.
        /// </para>
        /// </param>
        /// <seealso cref="glMultiTexCoord"/>
        /// <seealso cref="glTexCoordPointer"/>
        /// <seealso cref="glVertex"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void glTexCoord2sv(short* v) {
            var _F = _GetProc<GLNativeDelegate.FNglTexCoord2sv>("glTexCoord2sv");
            _F(v);
        }
        /// <summary>
        /// set the current texture coordinates
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The current texture coordinates can be updated at any time.
        /// In particular,
        /// <see cref="glTexCoord"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// When the <code>ARB_imaging</code> extension is supported, <see cref="glTexCoord"/> always
        /// updates texture unit <code>GL_TEXTURE0</code>.
        /// </para>
        /// Original: <para>void glTexCoord3d(GLdouble s, GLdouble t, GLdouble r);</para>
        /// </summary>
        /// <param name="s">
        /// <para>
        /// Specify  s ,  t ,  r , and  q   texture coordinates.
        /// Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        /// <param name="t">
        /// <para>
        /// Specify  s ,  t ,  r , and  q   texture coordinates.
        /// Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        /// <param name="r">
        /// <para>
        /// Specify  s ,  t ,  r , and  q   texture coordinates.
        /// Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        /// <seealso cref="glMultiTexCoord"/>
        /// <seealso cref="glTexCoordPointer"/>
        /// <seealso cref="glVertex"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void glTexCoord3d(double s, double t, double r) {
            var _F = _GetProc<GLNativeDelegate.FNglTexCoord3d>("glTexCoord3d");
            _F(s, t, r);
        }
        /// <summary>
        /// set the current texture coordinates
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The current texture coordinates can be updated at any time.
        /// In particular,
        /// <see cref="glTexCoord"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// When the <code>ARB_imaging</code> extension is supported, <see cref="glTexCoord"/> always
        /// updates texture unit <code>GL_TEXTURE0</code>.
        /// </para>
        /// Original: <para>void glTexCoord3dv(const GLdouble * v);</para>
        /// </summary>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array of one, two, three, or four elements,
        /// which in turn specify the
        /// s ,
        /// t ,
        /// r , and
        /// q  texture coordinates.
        /// </para>
        /// </param>
        /// <seealso cref="glMultiTexCoord"/>
        /// <seealso cref="glTexCoordPointer"/>
        /// <seealso cref="glVertex"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void glTexCoord3dv(double* v) {
            var _F = _GetProc<GLNativeDelegate.FNglTexCoord3dv>("glTexCoord3dv");
            _F(v);
        }
        /// <summary>
        /// set the current texture coordinates
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The current texture coordinates can be updated at any time.
        /// In particular,
        /// <see cref="glTexCoord"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// When the <code>ARB_imaging</code> extension is supported, <see cref="glTexCoord"/> always
        /// updates texture unit <code>GL_TEXTURE0</code>.
        /// </para>
        /// Original: <para>void glTexCoord3f(GLfloat s, GLfloat t, GLfloat r);</para>
        /// </summary>
        /// <param name="s">
        /// <para>
        /// Specify  s ,  t ,  r , and  q   texture coordinates.
        /// Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        /// <param name="t">
        /// <para>
        /// Specify  s ,  t ,  r , and  q   texture coordinates.
        /// Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        /// <param name="r">
        /// <para>
        /// Specify  s ,  t ,  r , and  q   texture coordinates.
        /// Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        /// <seealso cref="glMultiTexCoord"/>
        /// <seealso cref="glTexCoordPointer"/>
        /// <seealso cref="glVertex"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void glTexCoord3f(float s, float t, float r) {
            var _F = _GetProc<GLNativeDelegate.FNglTexCoord3f>("glTexCoord3f");
            _F(s, t, r);
        }
        /// <summary>
        /// set the current texture coordinates
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The current texture coordinates can be updated at any time.
        /// In particular,
        /// <see cref="glTexCoord"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// When the <code>ARB_imaging</code> extension is supported, <see cref="glTexCoord"/> always
        /// updates texture unit <code>GL_TEXTURE0</code>.
        /// </para>
        /// Original: <para>void glTexCoord3fv(const GLfloat * v);</para>
        /// </summary>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array of one, two, three, or four elements,
        /// which in turn specify the
        /// s ,
        /// t ,
        /// r , and
        /// q  texture coordinates.
        /// </para>
        /// </param>
        /// <seealso cref="glMultiTexCoord"/>
        /// <seealso cref="glTexCoordPointer"/>
        /// <seealso cref="glVertex"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void glTexCoord3fv(float* v) {
            var _F = _GetProc<GLNativeDelegate.FNglTexCoord3fv>("glTexCoord3fv");
            _F(v);
        }
        /// <summary>
        /// set the current texture coordinates
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The current texture coordinates can be updated at any time.
        /// In particular,
        /// <see cref="glTexCoord"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// When the <code>ARB_imaging</code> extension is supported, <see cref="glTexCoord"/> always
        /// updates texture unit <code>GL_TEXTURE0</code>.
        /// </para>
        /// Original: <para>void glTexCoord3i(GLint s, GLint t, GLint r);</para>
        /// </summary>
        /// <param name="s">
        /// <para>
        /// Specify  s ,  t ,  r , and  q   texture coordinates.
        /// Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        /// <param name="t">
        /// <para>
        /// Specify  s ,  t ,  r , and  q   texture coordinates.
        /// Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        /// <param name="r">
        /// <para>
        /// Specify  s ,  t ,  r , and  q   texture coordinates.
        /// Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        /// <seealso cref="glMultiTexCoord"/>
        /// <seealso cref="glTexCoordPointer"/>
        /// <seealso cref="glVertex"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void glTexCoord3i(int s, int t, int r) {
            var _F = _GetProc<GLNativeDelegate.FNglTexCoord3i>("glTexCoord3i");
            _F(s, t, r);
        }
        /// <summary>
        /// set the current texture coordinates
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The current texture coordinates can be updated at any time.
        /// In particular,
        /// <see cref="glTexCoord"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// When the <code>ARB_imaging</code> extension is supported, <see cref="glTexCoord"/> always
        /// updates texture unit <code>GL_TEXTURE0</code>.
        /// </para>
        /// Original: <para>void glTexCoord3iv(const GLint * v);</para>
        /// </summary>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array of one, two, three, or four elements,
        /// which in turn specify the
        /// s ,
        /// t ,
        /// r , and
        /// q  texture coordinates.
        /// </para>
        /// </param>
        /// <seealso cref="glMultiTexCoord"/>
        /// <seealso cref="glTexCoordPointer"/>
        /// <seealso cref="glVertex"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void glTexCoord3iv(int* v) {
            var _F = _GetProc<GLNativeDelegate.FNglTexCoord3iv>("glTexCoord3iv");
            _F(v);
        }
        /// <summary>
        /// set the current texture coordinates
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The current texture coordinates can be updated at any time.
        /// In particular,
        /// <see cref="glTexCoord"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// When the <code>ARB_imaging</code> extension is supported, <see cref="glTexCoord"/> always
        /// updates texture unit <code>GL_TEXTURE0</code>.
        /// </para>
        /// Original: <para>void glTexCoord3s(GLshort s, GLshort t, GLshort r);</para>
        /// </summary>
        /// <param name="s">
        /// <para>
        /// Specify  s ,  t ,  r , and  q   texture coordinates.
        /// Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        /// <param name="t">
        /// <para>
        /// Specify  s ,  t ,  r , and  q   texture coordinates.
        /// Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        /// <param name="r">
        /// <para>
        /// Specify  s ,  t ,  r , and  q   texture coordinates.
        /// Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        /// <seealso cref="glMultiTexCoord"/>
        /// <seealso cref="glTexCoordPointer"/>
        /// <seealso cref="glVertex"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void glTexCoord3s(short s, short t, short r) {
            var _F = _GetProc<GLNativeDelegate.FNglTexCoord3s>("glTexCoord3s");
            _F(s, t, r);
        }
        /// <summary>
        /// set the current texture coordinates
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The current texture coordinates can be updated at any time.
        /// In particular,
        /// <see cref="glTexCoord"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// When the <code>ARB_imaging</code> extension is supported, <see cref="glTexCoord"/> always
        /// updates texture unit <code>GL_TEXTURE0</code>.
        /// </para>
        /// Original: <para>void glTexCoord3sv(const GLshort * v);</para>
        /// </summary>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array of one, two, three, or four elements,
        /// which in turn specify the
        /// s ,
        /// t ,
        /// r , and
        /// q  texture coordinates.
        /// </para>
        /// </param>
        /// <seealso cref="glMultiTexCoord"/>
        /// <seealso cref="glTexCoordPointer"/>
        /// <seealso cref="glVertex"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void glTexCoord3sv(short* v) {
            var _F = _GetProc<GLNativeDelegate.FNglTexCoord3sv>("glTexCoord3sv");
            _F(v);
        }
        /// <summary>
        /// set the current texture coordinates
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The current texture coordinates can be updated at any time.
        /// In particular,
        /// <see cref="glTexCoord"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// When the <code>ARB_imaging</code> extension is supported, <see cref="glTexCoord"/> always
        /// updates texture unit <code>GL_TEXTURE0</code>.
        /// </para>
        /// Original: <para>void glTexCoord4d(GLdouble s, GLdouble t, GLdouble r, GLdouble q);</para>
        /// </summary>
        /// <param name="s">
        /// <para>
        /// Specify  s ,  t ,  r , and  q   texture coordinates.
        /// Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        /// <param name="t">
        /// <para>
        /// Specify  s ,  t ,  r , and  q   texture coordinates.
        /// Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        /// <param name="r">
        /// <para>
        /// Specify  s ,  t ,  r , and  q   texture coordinates.
        /// Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        /// <param name="q">
        /// <para>
        /// Specify  s ,  t ,  r , and  q   texture coordinates.
        /// Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        /// <seealso cref="glMultiTexCoord"/>
        /// <seealso cref="glTexCoordPointer"/>
        /// <seealso cref="glVertex"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void glTexCoord4d(double s, double t, double r, double q) {
            var _F = _GetProc<GLNativeDelegate.FNglTexCoord4d>("glTexCoord4d");
            _F(s, t, r, q);
        }
        /// <summary>
        /// set the current texture coordinates
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The current texture coordinates can be updated at any time.
        /// In particular,
        /// <see cref="glTexCoord"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// When the <code>ARB_imaging</code> extension is supported, <see cref="glTexCoord"/> always
        /// updates texture unit <code>GL_TEXTURE0</code>.
        /// </para>
        /// Original: <para>void glTexCoord4dv(const GLdouble * v);</para>
        /// </summary>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array of one, two, three, or four elements,
        /// which in turn specify the
        /// s ,
        /// t ,
        /// r , and
        /// q  texture coordinates.
        /// </para>
        /// </param>
        /// <seealso cref="glMultiTexCoord"/>
        /// <seealso cref="glTexCoordPointer"/>
        /// <seealso cref="glVertex"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void glTexCoord4dv(double* v) {
            var _F = _GetProc<GLNativeDelegate.FNglTexCoord4dv>("glTexCoord4dv");
            _F(v);
        }
        /// <summary>
        /// set the current texture coordinates
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The current texture coordinates can be updated at any time.
        /// In particular,
        /// <see cref="glTexCoord"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// When the <code>ARB_imaging</code> extension is supported, <see cref="glTexCoord"/> always
        /// updates texture unit <code>GL_TEXTURE0</code>.
        /// </para>
        /// Original: <para>void glTexCoord4f(GLfloat s, GLfloat t, GLfloat r, GLfloat q);</para>
        /// </summary>
        /// <param name="s">
        /// <para>
        /// Specify  s ,  t ,  r , and  q   texture coordinates.
        /// Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        /// <param name="t">
        /// <para>
        /// Specify  s ,  t ,  r , and  q   texture coordinates.
        /// Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        /// <param name="r">
        /// <para>
        /// Specify  s ,  t ,  r , and  q   texture coordinates.
        /// Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        /// <param name="q">
        /// <para>
        /// Specify  s ,  t ,  r , and  q   texture coordinates.
        /// Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        /// <seealso cref="glMultiTexCoord"/>
        /// <seealso cref="glTexCoordPointer"/>
        /// <seealso cref="glVertex"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void glTexCoord4f(float s, float t, float r, float q) {
            var _F = _GetProc<GLNativeDelegate.FNglTexCoord4f>("glTexCoord4f");
            _F(s, t, r, q);
        }
        /// <summary>
        /// set the current texture coordinates
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The current texture coordinates can be updated at any time.
        /// In particular,
        /// <see cref="glTexCoord"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// When the <code>ARB_imaging</code> extension is supported, <see cref="glTexCoord"/> always
        /// updates texture unit <code>GL_TEXTURE0</code>.
        /// </para>
        /// Original: <para>void glTexCoord4fv(const GLfloat * v);</para>
        /// </summary>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array of one, two, three, or four elements,
        /// which in turn specify the
        /// s ,
        /// t ,
        /// r , and
        /// q  texture coordinates.
        /// </para>
        /// </param>
        /// <seealso cref="glMultiTexCoord"/>
        /// <seealso cref="glTexCoordPointer"/>
        /// <seealso cref="glVertex"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void glTexCoord4fv(float* v) {
            var _F = _GetProc<GLNativeDelegate.FNglTexCoord4fv>("glTexCoord4fv");
            _F(v);
        }
        /// <summary>
        /// set the current texture coordinates
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The current texture coordinates can be updated at any time.
        /// In particular,
        /// <see cref="glTexCoord"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// When the <code>ARB_imaging</code> extension is supported, <see cref="glTexCoord"/> always
        /// updates texture unit <code>GL_TEXTURE0</code>.
        /// </para>
        /// Original: <para>void glTexCoord4i(GLint s, GLint t, GLint r, GLint q);</para>
        /// </summary>
        /// <param name="s">
        /// <para>
        /// Specify  s ,  t ,  r , and  q   texture coordinates.
        /// Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        /// <param name="t">
        /// <para>
        /// Specify  s ,  t ,  r , and  q   texture coordinates.
        /// Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        /// <param name="r">
        /// <para>
        /// Specify  s ,  t ,  r , and  q   texture coordinates.
        /// Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        /// <param name="q">
        /// <para>
        /// Specify  s ,  t ,  r , and  q   texture coordinates.
        /// Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        /// <seealso cref="glMultiTexCoord"/>
        /// <seealso cref="glTexCoordPointer"/>
        /// <seealso cref="glVertex"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void glTexCoord4i(int s, int t, int r, int q) {
            var _F = _GetProc<GLNativeDelegate.FNglTexCoord4i>("glTexCoord4i");
            _F(s, t, r, q);
        }
        /// <summary>
        /// set the current texture coordinates
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The current texture coordinates can be updated at any time.
        /// In particular,
        /// <see cref="glTexCoord"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// When the <code>ARB_imaging</code> extension is supported, <see cref="glTexCoord"/> always
        /// updates texture unit <code>GL_TEXTURE0</code>.
        /// </para>
        /// Original: <para>void glTexCoord4iv(const GLint * v);</para>
        /// </summary>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array of one, two, three, or four elements,
        /// which in turn specify the
        /// s ,
        /// t ,
        /// r , and
        /// q  texture coordinates.
        /// </para>
        /// </param>
        /// <seealso cref="glMultiTexCoord"/>
        /// <seealso cref="glTexCoordPointer"/>
        /// <seealso cref="glVertex"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void glTexCoord4iv(int* v) {
            var _F = _GetProc<GLNativeDelegate.FNglTexCoord4iv>("glTexCoord4iv");
            _F(v);
        }
        /// <summary>
        /// set the current texture coordinates
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The current texture coordinates can be updated at any time.
        /// In particular,
        /// <see cref="glTexCoord"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// When the <code>ARB_imaging</code> extension is supported, <see cref="glTexCoord"/> always
        /// updates texture unit <code>GL_TEXTURE0</code>.
        /// </para>
        /// Original: <para>void glTexCoord4s(GLshort s, GLshort t, GLshort r, GLshort q);</para>
        /// </summary>
        /// <param name="s">
        /// <para>
        /// Specify  s ,  t ,  r , and  q   texture coordinates.
        /// Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        /// <param name="t">
        /// <para>
        /// Specify  s ,  t ,  r , and  q   texture coordinates.
        /// Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        /// <param name="r">
        /// <para>
        /// Specify  s ,  t ,  r , and  q   texture coordinates.
        /// Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        /// <param name="q">
        /// <para>
        /// Specify  s ,  t ,  r , and  q   texture coordinates.
        /// Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        /// <seealso cref="glMultiTexCoord"/>
        /// <seealso cref="glTexCoordPointer"/>
        /// <seealso cref="glVertex"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void glTexCoord4s(short s, short t, short r, short q) {
            var _F = _GetProc<GLNativeDelegate.FNglTexCoord4s>("glTexCoord4s");
            _F(s, t, r, q);
        }
        /// <summary>
        /// set the current texture coordinates
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The current texture coordinates can be updated at any time.
        /// In particular,
        /// <see cref="glTexCoord"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// When the <code>ARB_imaging</code> extension is supported, <see cref="glTexCoord"/> always
        /// updates texture unit <code>GL_TEXTURE0</code>.
        /// </para>
        /// Original: <para>void glTexCoord4sv(const GLshort * v);</para>
        /// </summary>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array of one, two, three, or four elements,
        /// which in turn specify the
        /// s ,
        /// t ,
        /// r , and
        /// q  texture coordinates.
        /// </para>
        /// </param>
        /// <seealso cref="glMultiTexCoord"/>
        /// <seealso cref="glTexCoordPointer"/>
        /// <seealso cref="glVertex"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void glTexCoord4sv(short* v) {
            var _F = _GetProc<GLNativeDelegate.FNglTexCoord4sv>("glTexCoord4sv");
            _F(v);
        }
        /// <summary>
        /// specify a vertex
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// Invoking <see cref="glVertex"/> outside of a  <see cref="glBegin"/> / <see cref="glEnd"/>  pair
        /// results in undefined behavior.
        /// </para>
        /// Original: <para>void glVertex2d(GLdouble x, GLdouble y);</para>
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify  x ,  y ,  z , and  w  coordinates of a vertex.
        /// Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        /// <param name="y">
        /// <para>
        /// Specify  x ,  y ,  z , and  w  coordinates of a vertex.
        /// Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        /// <seealso cref="glBegin"/>
        /// <seealso cref="glCallList"/>
        /// <seealso cref="glColor"/>
        /// <seealso cref="glEdgeFlag"/>
        /// <seealso cref="glEvalCoord"/>
        /// <seealso cref="glFogCoord"/>
        /// <seealso cref="glIndex"/>
        /// <seealso cref="glMaterial"/>
        /// <seealso cref="glMultiTexCoord"/>
        /// <seealso cref="glNormal"/>
        /// <seealso cref="glRect"/>
        /// <seealso cref="glTexCoord"/>
        /// <seealso cref="glVertexPointer"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void glVertex2d(double x, double y) {
            var _F = _GetProc<GLNativeDelegate.FNglVertex2d>("glVertex2d");
            _F(x, y);
        }
        /// <summary>
        /// specify a vertex
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// Invoking <see cref="glVertex"/> outside of a  <see cref="glBegin"/> / <see cref="glEnd"/>  pair
        /// results in undefined behavior.
        /// </para>
        /// Original: <para>void glVertex2dv(const GLdouble * v);</para>
        /// </summary>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array of two, three, or four elements.
        /// The elements of a two-element array are 
        /// x   
        /// and 
        /// y   ;
        /// of a three-element array, 
        /// x   ,
        /// y   ,
        /// and 
        /// z   ;
        /// and of a four-element array, 
        /// x   ,
        /// y   ,
        /// z   ,
        /// and 
        /// w   .
        /// </para>
        /// </param>
        /// <seealso cref="glBegin"/>
        /// <seealso cref="glCallList"/>
        /// <seealso cref="glColor"/>
        /// <seealso cref="glEdgeFlag"/>
        /// <seealso cref="glEvalCoord"/>
        /// <seealso cref="glFogCoord"/>
        /// <seealso cref="glIndex"/>
        /// <seealso cref="glMaterial"/>
        /// <seealso cref="glMultiTexCoord"/>
        /// <seealso cref="glNormal"/>
        /// <seealso cref="glRect"/>
        /// <seealso cref="glTexCoord"/>
        /// <seealso cref="glVertexPointer"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void glVertex2dv(double* v) {
            var _F = _GetProc<GLNativeDelegate.FNglVertex2dv>("glVertex2dv");
            _F(v);
        }
        /// <summary>
        /// specify a vertex
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// Invoking <see cref="glVertex"/> outside of a  <see cref="glBegin"/> / <see cref="glEnd"/>  pair
        /// results in undefined behavior.
        /// </para>
        /// Original: <para>void glVertex2f(GLfloat x, GLfloat y);</para>
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify  x ,  y ,  z , and  w  coordinates of a vertex.
        /// Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        /// <param name="y">
        /// <para>
        /// Specify  x ,  y ,  z , and  w  coordinates of a vertex.
        /// Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        /// <seealso cref="glBegin"/>
        /// <seealso cref="glCallList"/>
        /// <seealso cref="glColor"/>
        /// <seealso cref="glEdgeFlag"/>
        /// <seealso cref="glEvalCoord"/>
        /// <seealso cref="glFogCoord"/>
        /// <seealso cref="glIndex"/>
        /// <seealso cref="glMaterial"/>
        /// <seealso cref="glMultiTexCoord"/>
        /// <seealso cref="glNormal"/>
        /// <seealso cref="glRect"/>
        /// <seealso cref="glTexCoord"/>
        /// <seealso cref="glVertexPointer"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void glVertex2f(float x, float y) {
            var _F = _GetProc<GLNativeDelegate.FNglVertex2f>("glVertex2f");
            _F(x, y);
        }
        /// <summary>
        /// specify a vertex
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// Invoking <see cref="glVertex"/> outside of a  <see cref="glBegin"/> / <see cref="glEnd"/>  pair
        /// results in undefined behavior.
        /// </para>
        /// Original: <para>void glVertex2fv(const GLfloat * v);</para>
        /// </summary>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array of two, three, or four elements.
        /// The elements of a two-element array are 
        /// x   
        /// and 
        /// y   ;
        /// of a three-element array, 
        /// x   ,
        /// y   ,
        /// and 
        /// z   ;
        /// and of a four-element array, 
        /// x   ,
        /// y   ,
        /// z   ,
        /// and 
        /// w   .
        /// </para>
        /// </param>
        /// <seealso cref="glBegin"/>
        /// <seealso cref="glCallList"/>
        /// <seealso cref="glColor"/>
        /// <seealso cref="glEdgeFlag"/>
        /// <seealso cref="glEvalCoord"/>
        /// <seealso cref="glFogCoord"/>
        /// <seealso cref="glIndex"/>
        /// <seealso cref="glMaterial"/>
        /// <seealso cref="glMultiTexCoord"/>
        /// <seealso cref="glNormal"/>
        /// <seealso cref="glRect"/>
        /// <seealso cref="glTexCoord"/>
        /// <seealso cref="glVertexPointer"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void glVertex2fv(float* v) {
            var _F = _GetProc<GLNativeDelegate.FNglVertex2fv>("glVertex2fv");
            _F(v);
        }
        /// <summary>
        /// specify a vertex
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// Invoking <see cref="glVertex"/> outside of a  <see cref="glBegin"/> / <see cref="glEnd"/>  pair
        /// results in undefined behavior.
        /// </para>
        /// Original: <para>void glVertex2i(GLint x, GLint y);</para>
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify  x ,  y ,  z , and  w  coordinates of a vertex.
        /// Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        /// <param name="y">
        /// <para>
        /// Specify  x ,  y ,  z , and  w  coordinates of a vertex.
        /// Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        /// <seealso cref="glBegin"/>
        /// <seealso cref="glCallList"/>
        /// <seealso cref="glColor"/>
        /// <seealso cref="glEdgeFlag"/>
        /// <seealso cref="glEvalCoord"/>
        /// <seealso cref="glFogCoord"/>
        /// <seealso cref="glIndex"/>
        /// <seealso cref="glMaterial"/>
        /// <seealso cref="glMultiTexCoord"/>
        /// <seealso cref="glNormal"/>
        /// <seealso cref="glRect"/>
        /// <seealso cref="glTexCoord"/>
        /// <seealso cref="glVertexPointer"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void glVertex2i(int x, int y) {
            var _F = _GetProc<GLNativeDelegate.FNglVertex2i>("glVertex2i");
            _F(x, y);
        }
        /// <summary>
        /// specify a vertex
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// Invoking <see cref="glVertex"/> outside of a  <see cref="glBegin"/> / <see cref="glEnd"/>  pair
        /// results in undefined behavior.
        /// </para>
        /// Original: <para>void glVertex2iv(const GLint * v);</para>
        /// </summary>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array of two, three, or four elements.
        /// The elements of a two-element array are 
        /// x   
        /// and 
        /// y   ;
        /// of a three-element array, 
        /// x   ,
        /// y   ,
        /// and 
        /// z   ;
        /// and of a four-element array, 
        /// x   ,
        /// y   ,
        /// z   ,
        /// and 
        /// w   .
        /// </para>
        /// </param>
        /// <seealso cref="glBegin"/>
        /// <seealso cref="glCallList"/>
        /// <seealso cref="glColor"/>
        /// <seealso cref="glEdgeFlag"/>
        /// <seealso cref="glEvalCoord"/>
        /// <seealso cref="glFogCoord"/>
        /// <seealso cref="glIndex"/>
        /// <seealso cref="glMaterial"/>
        /// <seealso cref="glMultiTexCoord"/>
        /// <seealso cref="glNormal"/>
        /// <seealso cref="glRect"/>
        /// <seealso cref="glTexCoord"/>
        /// <seealso cref="glVertexPointer"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void glVertex2iv(int* v) {
            var _F = _GetProc<GLNativeDelegate.FNglVertex2iv>("glVertex2iv");
            _F(v);
        }
        /// <summary>
        /// specify a vertex
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// Invoking <see cref="glVertex"/> outside of a  <see cref="glBegin"/> / <see cref="glEnd"/>  pair
        /// results in undefined behavior.
        /// </para>
        /// Original: <para>void glVertex2s(GLshort x, GLshort y);</para>
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify  x ,  y ,  z , and  w  coordinates of a vertex.
        /// Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        /// <param name="y">
        /// <para>
        /// Specify  x ,  y ,  z , and  w  coordinates of a vertex.
        /// Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        /// <seealso cref="glBegin"/>
        /// <seealso cref="glCallList"/>
        /// <seealso cref="glColor"/>
        /// <seealso cref="glEdgeFlag"/>
        /// <seealso cref="glEvalCoord"/>
        /// <seealso cref="glFogCoord"/>
        /// <seealso cref="glIndex"/>
        /// <seealso cref="glMaterial"/>
        /// <seealso cref="glMultiTexCoord"/>
        /// <seealso cref="glNormal"/>
        /// <seealso cref="glRect"/>
        /// <seealso cref="glTexCoord"/>
        /// <seealso cref="glVertexPointer"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void glVertex2s(short x, short y) {
            var _F = _GetProc<GLNativeDelegate.FNglVertex2s>("glVertex2s");
            _F(x, y);
        }
        /// <summary>
        /// specify a vertex
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// Invoking <see cref="glVertex"/> outside of a  <see cref="glBegin"/> / <see cref="glEnd"/>  pair
        /// results in undefined behavior.
        /// </para>
        /// Original: <para>void glVertex2sv(const GLshort * v);</para>
        /// </summary>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array of two, three, or four elements.
        /// The elements of a two-element array are 
        /// x   
        /// and 
        /// y   ;
        /// of a three-element array, 
        /// x   ,
        /// y   ,
        /// and 
        /// z   ;
        /// and of a four-element array, 
        /// x   ,
        /// y   ,
        /// z   ,
        /// and 
        /// w   .
        /// </para>
        /// </param>
        /// <seealso cref="glBegin"/>
        /// <seealso cref="glCallList"/>
        /// <seealso cref="glColor"/>
        /// <seealso cref="glEdgeFlag"/>
        /// <seealso cref="glEvalCoord"/>
        /// <seealso cref="glFogCoord"/>
        /// <seealso cref="glIndex"/>
        /// <seealso cref="glMaterial"/>
        /// <seealso cref="glMultiTexCoord"/>
        /// <seealso cref="glNormal"/>
        /// <seealso cref="glRect"/>
        /// <seealso cref="glTexCoord"/>
        /// <seealso cref="glVertexPointer"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void glVertex2sv(short* v) {
            var _F = _GetProc<GLNativeDelegate.FNglVertex2sv>("glVertex2sv");
            _F(v);
        }
        /// <summary>
        /// specify a vertex
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// Invoking <see cref="glVertex"/> outside of a  <see cref="glBegin"/> / <see cref="glEnd"/>  pair
        /// results in undefined behavior.
        /// </para>
        /// Original: <para>void glVertex3d(GLdouble x, GLdouble y, GLdouble z);</para>
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify  x ,  y ,  z , and  w  coordinates of a vertex.
        /// Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        /// <param name="y">
        /// <para>
        /// Specify  x ,  y ,  z , and  w  coordinates of a vertex.
        /// Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        /// <param name="z">
        /// <para>
        /// Specify  x ,  y ,  z , and  w  coordinates of a vertex.
        /// Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        /// <seealso cref="glBegin"/>
        /// <seealso cref="glCallList"/>
        /// <seealso cref="glColor"/>
        /// <seealso cref="glEdgeFlag"/>
        /// <seealso cref="glEvalCoord"/>
        /// <seealso cref="glFogCoord"/>
        /// <seealso cref="glIndex"/>
        /// <seealso cref="glMaterial"/>
        /// <seealso cref="glMultiTexCoord"/>
        /// <seealso cref="glNormal"/>
        /// <seealso cref="glRect"/>
        /// <seealso cref="glTexCoord"/>
        /// <seealso cref="glVertexPointer"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void glVertex3d(double x, double y, double z) {
            var _F = _GetProc<GLNativeDelegate.FNglVertex3d>("glVertex3d");
            _F(x, y, z);
        }
        /// <summary>
        /// specify a vertex
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// Invoking <see cref="glVertex"/> outside of a  <see cref="glBegin"/> / <see cref="glEnd"/>  pair
        /// results in undefined behavior.
        /// </para>
        /// Original: <para>void glVertex3dv(const GLdouble * v);</para>
        /// </summary>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array of two, three, or four elements.
        /// The elements of a two-element array are 
        /// x   
        /// and 
        /// y   ;
        /// of a three-element array, 
        /// x   ,
        /// y   ,
        /// and 
        /// z   ;
        /// and of a four-element array, 
        /// x   ,
        /// y   ,
        /// z   ,
        /// and 
        /// w   .
        /// </para>
        /// </param>
        /// <seealso cref="glBegin"/>
        /// <seealso cref="glCallList"/>
        /// <seealso cref="glColor"/>
        /// <seealso cref="glEdgeFlag"/>
        /// <seealso cref="glEvalCoord"/>
        /// <seealso cref="glFogCoord"/>
        /// <seealso cref="glIndex"/>
        /// <seealso cref="glMaterial"/>
        /// <seealso cref="glMultiTexCoord"/>
        /// <seealso cref="glNormal"/>
        /// <seealso cref="glRect"/>
        /// <seealso cref="glTexCoord"/>
        /// <seealso cref="glVertexPointer"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void glVertex3dv(double* v) {
            var _F = _GetProc<GLNativeDelegate.FNglVertex3dv>("glVertex3dv");
            _F(v);
        }
        /// <summary>
        /// specify a vertex
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// Invoking <see cref="glVertex"/> outside of a  <see cref="glBegin"/> / <see cref="glEnd"/>  pair
        /// results in undefined behavior.
        /// </para>
        /// Original: <para>void glVertex3f(GLfloat x, GLfloat y, GLfloat z);</para>
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify  x ,  y ,  z , and  w  coordinates of a vertex.
        /// Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        /// <param name="y">
        /// <para>
        /// Specify  x ,  y ,  z , and  w  coordinates of a vertex.
        /// Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        /// <param name="z">
        /// <para>
        /// Specify  x ,  y ,  z , and  w  coordinates of a vertex.
        /// Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        /// <seealso cref="glBegin"/>
        /// <seealso cref="glCallList"/>
        /// <seealso cref="glColor"/>
        /// <seealso cref="glEdgeFlag"/>
        /// <seealso cref="glEvalCoord"/>
        /// <seealso cref="glFogCoord"/>
        /// <seealso cref="glIndex"/>
        /// <seealso cref="glMaterial"/>
        /// <seealso cref="glMultiTexCoord"/>
        /// <seealso cref="glNormal"/>
        /// <seealso cref="glRect"/>
        /// <seealso cref="glTexCoord"/>
        /// <seealso cref="glVertexPointer"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void glVertex3f(float x, float y, float z) {
            var _F = _GetProc<GLNativeDelegate.FNglVertex3f>("glVertex3f");
            _F(x, y, z);
        }
        /// <summary>
        /// specify a vertex
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// Invoking <see cref="glVertex"/> outside of a  <see cref="glBegin"/> / <see cref="glEnd"/>  pair
        /// results in undefined behavior.
        /// </para>
        /// Original: <para>void glVertex3fv(const GLfloat * v);</para>
        /// </summary>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array of two, three, or four elements.
        /// The elements of a two-element array are 
        /// x   
        /// and 
        /// y   ;
        /// of a three-element array, 
        /// x   ,
        /// y   ,
        /// and 
        /// z   ;
        /// and of a four-element array, 
        /// x   ,
        /// y   ,
        /// z   ,
        /// and 
        /// w   .
        /// </para>
        /// </param>
        /// <seealso cref="glBegin"/>
        /// <seealso cref="glCallList"/>
        /// <seealso cref="glColor"/>
        /// <seealso cref="glEdgeFlag"/>
        /// <seealso cref="glEvalCoord"/>
        /// <seealso cref="glFogCoord"/>
        /// <seealso cref="glIndex"/>
        /// <seealso cref="glMaterial"/>
        /// <seealso cref="glMultiTexCoord"/>
        /// <seealso cref="glNormal"/>
        /// <seealso cref="glRect"/>
        /// <seealso cref="glTexCoord"/>
        /// <seealso cref="glVertexPointer"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void glVertex3fv(float* v) {
            var _F = _GetProc<GLNativeDelegate.FNglVertex3fv>("glVertex3fv");
            _F(v);
        }
        /// <summary>
        /// specify a vertex
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// Invoking <see cref="glVertex"/> outside of a  <see cref="glBegin"/> / <see cref="glEnd"/>  pair
        /// results in undefined behavior.
        /// </para>
        /// Original: <para>void glVertex3i(GLint x, GLint y, GLint z);</para>
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify  x ,  y ,  z , and  w  coordinates of a vertex.
        /// Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        /// <param name="y">
        /// <para>
        /// Specify  x ,  y ,  z , and  w  coordinates of a vertex.
        /// Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        /// <param name="z">
        /// <para>
        /// Specify  x ,  y ,  z , and  w  coordinates of a vertex.
        /// Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        /// <seealso cref="glBegin"/>
        /// <seealso cref="glCallList"/>
        /// <seealso cref="glColor"/>
        /// <seealso cref="glEdgeFlag"/>
        /// <seealso cref="glEvalCoord"/>
        /// <seealso cref="glFogCoord"/>
        /// <seealso cref="glIndex"/>
        /// <seealso cref="glMaterial"/>
        /// <seealso cref="glMultiTexCoord"/>
        /// <seealso cref="glNormal"/>
        /// <seealso cref="glRect"/>
        /// <seealso cref="glTexCoord"/>
        /// <seealso cref="glVertexPointer"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void glVertex3i(int x, int y, int z) {
            var _F = _GetProc<GLNativeDelegate.FNglVertex3i>("glVertex3i");
            _F(x, y, z);
        }
        /// <summary>
        /// specify a vertex
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// Invoking <see cref="glVertex"/> outside of a  <see cref="glBegin"/> / <see cref="glEnd"/>  pair
        /// results in undefined behavior.
        /// </para>
        /// Original: <para>void glVertex3iv(const GLint * v);</para>
        /// </summary>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array of two, three, or four elements.
        /// The elements of a two-element array are 
        /// x   
        /// and 
        /// y   ;
        /// of a three-element array, 
        /// x   ,
        /// y   ,
        /// and 
        /// z   ;
        /// and of a four-element array, 
        /// x   ,
        /// y   ,
        /// z   ,
        /// and 
        /// w   .
        /// </para>
        /// </param>
        /// <seealso cref="glBegin"/>
        /// <seealso cref="glCallList"/>
        /// <seealso cref="glColor"/>
        /// <seealso cref="glEdgeFlag"/>
        /// <seealso cref="glEvalCoord"/>
        /// <seealso cref="glFogCoord"/>
        /// <seealso cref="glIndex"/>
        /// <seealso cref="glMaterial"/>
        /// <seealso cref="glMultiTexCoord"/>
        /// <seealso cref="glNormal"/>
        /// <seealso cref="glRect"/>
        /// <seealso cref="glTexCoord"/>
        /// <seealso cref="glVertexPointer"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void glVertex3iv(int* v) {
            var _F = _GetProc<GLNativeDelegate.FNglVertex3iv>("glVertex3iv");
            _F(v);
        }
        /// <summary>
        /// specify a vertex
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// Invoking <see cref="glVertex"/> outside of a  <see cref="glBegin"/> / <see cref="glEnd"/>  pair
        /// results in undefined behavior.
        /// </para>
        /// Original: <para>void glVertex3s(GLshort x, GLshort y, GLshort z);</para>
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify  x ,  y ,  z , and  w  coordinates of a vertex.
        /// Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        /// <param name="y">
        /// <para>
        /// Specify  x ,  y ,  z , and  w  coordinates of a vertex.
        /// Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        /// <param name="z">
        /// <para>
        /// Specify  x ,  y ,  z , and  w  coordinates of a vertex.
        /// Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        /// <seealso cref="glBegin"/>
        /// <seealso cref="glCallList"/>
        /// <seealso cref="glColor"/>
        /// <seealso cref="glEdgeFlag"/>
        /// <seealso cref="glEvalCoord"/>
        /// <seealso cref="glFogCoord"/>
        /// <seealso cref="glIndex"/>
        /// <seealso cref="glMaterial"/>
        /// <seealso cref="glMultiTexCoord"/>
        /// <seealso cref="glNormal"/>
        /// <seealso cref="glRect"/>
        /// <seealso cref="glTexCoord"/>
        /// <seealso cref="glVertexPointer"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void glVertex3s(short x, short y, short z) {
            var _F = _GetProc<GLNativeDelegate.FNglVertex3s>("glVertex3s");
            _F(x, y, z);
        }
        /// <summary>
        /// specify a vertex
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// Invoking <see cref="glVertex"/> outside of a  <see cref="glBegin"/> / <see cref="glEnd"/>  pair
        /// results in undefined behavior.
        /// </para>
        /// Original: <para>void glVertex3sv(const GLshort * v);</para>
        /// </summary>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array of two, three, or four elements.
        /// The elements of a two-element array are 
        /// x   
        /// and 
        /// y   ;
        /// of a three-element array, 
        /// x   ,
        /// y   ,
        /// and 
        /// z   ;
        /// and of a four-element array, 
        /// x   ,
        /// y   ,
        /// z   ,
        /// and 
        /// w   .
        /// </para>
        /// </param>
        /// <seealso cref="glBegin"/>
        /// <seealso cref="glCallList"/>
        /// <seealso cref="glColor"/>
        /// <seealso cref="glEdgeFlag"/>
        /// <seealso cref="glEvalCoord"/>
        /// <seealso cref="glFogCoord"/>
        /// <seealso cref="glIndex"/>
        /// <seealso cref="glMaterial"/>
        /// <seealso cref="glMultiTexCoord"/>
        /// <seealso cref="glNormal"/>
        /// <seealso cref="glRect"/>
        /// <seealso cref="glTexCoord"/>
        /// <seealso cref="glVertexPointer"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void glVertex3sv(short* v) {
            var _F = _GetProc<GLNativeDelegate.FNglVertex3sv>("glVertex3sv");
            _F(v);
        }
        /// <summary>
        /// specify a vertex
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// Invoking <see cref="glVertex"/> outside of a  <see cref="glBegin"/> / <see cref="glEnd"/>  pair
        /// results in undefined behavior.
        /// </para>
        /// Original: <para>void glVertex4d(GLdouble x, GLdouble y, GLdouble z, GLdouble w);</para>
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify  x ,  y ,  z , and  w  coordinates of a vertex.
        /// Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        /// <param name="y">
        /// <para>
        /// Specify  x ,  y ,  z , and  w  coordinates of a vertex.
        /// Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        /// <param name="z">
        /// <para>
        /// Specify  x ,  y ,  z , and  w  coordinates of a vertex.
        /// Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        /// <param name="w">
        /// <para>
        /// Specify  x ,  y ,  z , and  w  coordinates of a vertex.
        /// Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        /// <seealso cref="glBegin"/>
        /// <seealso cref="glCallList"/>
        /// <seealso cref="glColor"/>
        /// <seealso cref="glEdgeFlag"/>
        /// <seealso cref="glEvalCoord"/>
        /// <seealso cref="glFogCoord"/>
        /// <seealso cref="glIndex"/>
        /// <seealso cref="glMaterial"/>
        /// <seealso cref="glMultiTexCoord"/>
        /// <seealso cref="glNormal"/>
        /// <seealso cref="glRect"/>
        /// <seealso cref="glTexCoord"/>
        /// <seealso cref="glVertexPointer"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void glVertex4d(double x, double y, double z, double w) {
            var _F = _GetProc<GLNativeDelegate.FNglVertex4d>("glVertex4d");
            _F(x, y, z, w);
        }
        /// <summary>
        /// specify a vertex
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// Invoking <see cref="glVertex"/> outside of a  <see cref="glBegin"/> / <see cref="glEnd"/>  pair
        /// results in undefined behavior.
        /// </para>
        /// Original: <para>void glVertex4dv(const GLdouble * v);</para>
        /// </summary>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array of two, three, or four elements.
        /// The elements of a two-element array are 
        /// x   
        /// and 
        /// y   ;
        /// of a three-element array, 
        /// x   ,
        /// y   ,
        /// and 
        /// z   ;
        /// and of a four-element array, 
        /// x   ,
        /// y   ,
        /// z   ,
        /// and 
        /// w   .
        /// </para>
        /// </param>
        /// <seealso cref="glBegin"/>
        /// <seealso cref="glCallList"/>
        /// <seealso cref="glColor"/>
        /// <seealso cref="glEdgeFlag"/>
        /// <seealso cref="glEvalCoord"/>
        /// <seealso cref="glFogCoord"/>
        /// <seealso cref="glIndex"/>
        /// <seealso cref="glMaterial"/>
        /// <seealso cref="glMultiTexCoord"/>
        /// <seealso cref="glNormal"/>
        /// <seealso cref="glRect"/>
        /// <seealso cref="glTexCoord"/>
        /// <seealso cref="glVertexPointer"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void glVertex4dv(double* v) {
            var _F = _GetProc<GLNativeDelegate.FNglVertex4dv>("glVertex4dv");
            _F(v);
        }
        /// <summary>
        /// specify a vertex
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// Invoking <see cref="glVertex"/> outside of a  <see cref="glBegin"/> / <see cref="glEnd"/>  pair
        /// results in undefined behavior.
        /// </para>
        /// Original: <para>void glVertex4f(GLfloat x, GLfloat y, GLfloat z, GLfloat w);</para>
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify  x ,  y ,  z , and  w  coordinates of a vertex.
        /// Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        /// <param name="y">
        /// <para>
        /// Specify  x ,  y ,  z , and  w  coordinates of a vertex.
        /// Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        /// <param name="z">
        /// <para>
        /// Specify  x ,  y ,  z , and  w  coordinates of a vertex.
        /// Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        /// <param name="w">
        /// <para>
        /// Specify  x ,  y ,  z , and  w  coordinates of a vertex.
        /// Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        /// <seealso cref="glBegin"/>
        /// <seealso cref="glCallList"/>
        /// <seealso cref="glColor"/>
        /// <seealso cref="glEdgeFlag"/>
        /// <seealso cref="glEvalCoord"/>
        /// <seealso cref="glFogCoord"/>
        /// <seealso cref="glIndex"/>
        /// <seealso cref="glMaterial"/>
        /// <seealso cref="glMultiTexCoord"/>
        /// <seealso cref="glNormal"/>
        /// <seealso cref="glRect"/>
        /// <seealso cref="glTexCoord"/>
        /// <seealso cref="glVertexPointer"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void glVertex4f(float x, float y, float z, float w) {
            var _F = _GetProc<GLNativeDelegate.FNglVertex4f>("glVertex4f");
            _F(x, y, z, w);
        }
        /// <summary>
        /// specify a vertex
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// Invoking <see cref="glVertex"/> outside of a  <see cref="glBegin"/> / <see cref="glEnd"/>  pair
        /// results in undefined behavior.
        /// </para>
        /// Original: <para>void glVertex4fv(const GLfloat * v);</para>
        /// </summary>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array of two, three, or four elements.
        /// The elements of a two-element array are 
        /// x   
        /// and 
        /// y   ;
        /// of a three-element array, 
        /// x   ,
        /// y   ,
        /// and 
        /// z   ;
        /// and of a four-element array, 
        /// x   ,
        /// y   ,
        /// z   ,
        /// and 
        /// w   .
        /// </para>
        /// </param>
        /// <seealso cref="glBegin"/>
        /// <seealso cref="glCallList"/>
        /// <seealso cref="glColor"/>
        /// <seealso cref="glEdgeFlag"/>
        /// <seealso cref="glEvalCoord"/>
        /// <seealso cref="glFogCoord"/>
        /// <seealso cref="glIndex"/>
        /// <seealso cref="glMaterial"/>
        /// <seealso cref="glMultiTexCoord"/>
        /// <seealso cref="glNormal"/>
        /// <seealso cref="glRect"/>
        /// <seealso cref="glTexCoord"/>
        /// <seealso cref="glVertexPointer"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void glVertex4fv(float* v) {
            var _F = _GetProc<GLNativeDelegate.FNglVertex4fv>("glVertex4fv");
            _F(v);
        }
        /// <summary>
        /// specify a vertex
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// Invoking <see cref="glVertex"/> outside of a  <see cref="glBegin"/> / <see cref="glEnd"/>  pair
        /// results in undefined behavior.
        /// </para>
        /// Original: <para>void glVertex4i(GLint x, GLint y, GLint z, GLint w);</para>
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify  x ,  y ,  z , and  w  coordinates of a vertex.
        /// Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        /// <param name="y">
        /// <para>
        /// Specify  x ,  y ,  z , and  w  coordinates of a vertex.
        /// Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        /// <param name="z">
        /// <para>
        /// Specify  x ,  y ,  z , and  w  coordinates of a vertex.
        /// Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        /// <param name="w">
        /// <para>
        /// Specify  x ,  y ,  z , and  w  coordinates of a vertex.
        /// Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        /// <seealso cref="glBegin"/>
        /// <seealso cref="glCallList"/>
        /// <seealso cref="glColor"/>
        /// <seealso cref="glEdgeFlag"/>
        /// <seealso cref="glEvalCoord"/>
        /// <seealso cref="glFogCoord"/>
        /// <seealso cref="glIndex"/>
        /// <seealso cref="glMaterial"/>
        /// <seealso cref="glMultiTexCoord"/>
        /// <seealso cref="glNormal"/>
        /// <seealso cref="glRect"/>
        /// <seealso cref="glTexCoord"/>
        /// <seealso cref="glVertexPointer"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void glVertex4i(int x, int y, int z, int w) {
            var _F = _GetProc<GLNativeDelegate.FNglVertex4i>("glVertex4i");
            _F(x, y, z, w);
        }
        /// <summary>
        /// specify a vertex
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// Invoking <see cref="glVertex"/> outside of a  <see cref="glBegin"/> / <see cref="glEnd"/>  pair
        /// results in undefined behavior.
        /// </para>
        /// Original: <para>void glVertex4iv(const GLint * v);</para>
        /// </summary>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array of two, three, or four elements.
        /// The elements of a two-element array are 
        /// x   
        /// and 
        /// y   ;
        /// of a three-element array, 
        /// x   ,
        /// y   ,
        /// and 
        /// z   ;
        /// and of a four-element array, 
        /// x   ,
        /// y   ,
        /// z   ,
        /// and 
        /// w   .
        /// </para>
        /// </param>
        /// <seealso cref="glBegin"/>
        /// <seealso cref="glCallList"/>
        /// <seealso cref="glColor"/>
        /// <seealso cref="glEdgeFlag"/>
        /// <seealso cref="glEvalCoord"/>
        /// <seealso cref="glFogCoord"/>
        /// <seealso cref="glIndex"/>
        /// <seealso cref="glMaterial"/>
        /// <seealso cref="glMultiTexCoord"/>
        /// <seealso cref="glNormal"/>
        /// <seealso cref="glRect"/>
        /// <seealso cref="glTexCoord"/>
        /// <seealso cref="glVertexPointer"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void glVertex4iv(int* v) {
            var _F = _GetProc<GLNativeDelegate.FNglVertex4iv>("glVertex4iv");
            _F(v);
        }
        /// <summary>
        /// specify a vertex
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// Invoking <see cref="glVertex"/> outside of a  <see cref="glBegin"/> / <see cref="glEnd"/>  pair
        /// results in undefined behavior.
        /// </para>
        /// Original: <para>void glVertex4s(GLshort x, GLshort y, GLshort z, GLshort w);</para>
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify  x ,  y ,  z , and  w  coordinates of a vertex.
        /// Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        /// <param name="y">
        /// <para>
        /// Specify  x ,  y ,  z , and  w  coordinates of a vertex.
        /// Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        /// <param name="z">
        /// <para>
        /// Specify  x ,  y ,  z , and  w  coordinates of a vertex.
        /// Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        /// <param name="w">
        /// <para>
        /// Specify  x ,  y ,  z , and  w  coordinates of a vertex.
        /// Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        /// <seealso cref="glBegin"/>
        /// <seealso cref="glCallList"/>
        /// <seealso cref="glColor"/>
        /// <seealso cref="glEdgeFlag"/>
        /// <seealso cref="glEvalCoord"/>
        /// <seealso cref="glFogCoord"/>
        /// <seealso cref="glIndex"/>
        /// <seealso cref="glMaterial"/>
        /// <seealso cref="glMultiTexCoord"/>
        /// <seealso cref="glNormal"/>
        /// <seealso cref="glRect"/>
        /// <seealso cref="glTexCoord"/>
        /// <seealso cref="glVertexPointer"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void glVertex4s(short x, short y, short z, short w) {
            var _F = _GetProc<GLNativeDelegate.FNglVertex4s>("glVertex4s");
            _F(x, y, z, w);
        }
        /// <summary>
        /// specify a vertex
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// Invoking <see cref="glVertex"/> outside of a  <see cref="glBegin"/> / <see cref="glEnd"/>  pair
        /// results in undefined behavior.
        /// </para>
        /// Original: <para>void glVertex4sv(const GLshort * v);</para>
        /// </summary>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array of two, three, or four elements.
        /// The elements of a two-element array are 
        /// x   
        /// and 
        /// y   ;
        /// of a three-element array, 
        /// x   ,
        /// y   ,
        /// and 
        /// z   ;
        /// and of a four-element array, 
        /// x   ,
        /// y   ,
        /// z   ,
        /// and 
        /// w   .
        /// </para>
        /// </param>
        /// <seealso cref="glBegin"/>
        /// <seealso cref="glCallList"/>
        /// <seealso cref="glColor"/>
        /// <seealso cref="glEdgeFlag"/>
        /// <seealso cref="glEvalCoord"/>
        /// <seealso cref="glFogCoord"/>
        /// <seealso cref="glIndex"/>
        /// <seealso cref="glMaterial"/>
        /// <seealso cref="glMultiTexCoord"/>
        /// <seealso cref="glNormal"/>
        /// <seealso cref="glRect"/>
        /// <seealso cref="glTexCoord"/>
        /// <seealso cref="glVertexPointer"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void glVertex4sv(short* v) {
            var _F = _GetProc<GLNativeDelegate.FNglVertex4sv>("glVertex4sv");
            _F(v);
        }
        /// <summary>
        /// specify a plane against which all geometry is clipped
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// It is always the case that <code>GL_CLIP_PLANE</code>
        /// i   
        /// = <code>GL_CLIP_PLANE0</code> + 
        /// i   .
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="plane"/> is not an accepted value.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glClipPlane"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glClipPlane(GLenum plane, const GLdouble * equation);</para>
        /// </summary>
        /// <param name="plane">
        /// <para>
        /// Specifies which clipping plane is being positioned.
        /// Symbolic names of the form <code>GL_CLIP_PLANE</code> i ,
        /// where  i  is an integer between 0 and <code>GL_MAX_CLIP_PLANES</code>
        /// -1 
        /// ,
        /// are accepted.
        /// </para>
        /// </param>
        /// <param name="equation">
        /// <para>
        /// Specifies the address of an array of four double-precision floating-point values.
        /// These values are interpreted as a plane equation.
        /// </para>
        /// </param>
        /// <seealso cref="glEnable"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void glClipPlane(uint plane, double* equation) {
            var _F = _GetProc<GLNativeDelegate.FNglClipPlane>("glClipPlane");
            _F(plane, equation);
        }
        /// <summary>
        /// cause a material color to track the current color
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glColorMaterial"/> makes it possible to change a subset of material parameters for each
        /// vertex using only the  <see cref="glColor"/>  command,
        /// without calling  <see cref="glMaterial"/> .
        /// If only such a subset of parameters is to be specified for each
        /// vertex, calling <see cref="glColorMaterial"/> is preferable to calling  <see cref="glMaterial"/> .
        /// Call <see cref="glColorMaterial"/> before enabling <code>GL_COLOR_MATERIAL</code>.
        /// Calling  <see cref="glDrawElements"/> ,  <see cref="glDrawArrays"/> , or  <see cref="glDrawRangeElements"/> 
        /// may leave the current color indeterminate, if the color array is enabled.
        /// If
        /// <see cref="glColorMaterial"/> is enabled while the current color is indeterminate, the
        /// lighting material state specified by <paramref name="face"/> and <paramref name="mode"/> is also indeterminate.
        /// If the GL version is 1.1 or greater, and <code>GL_COLOR_MATERIAL</code> is
        /// enabled, evaluated color values affect the results of the lighting
        /// equation as if the current color were being modified, but no change is
        /// made to the tracking lighting parameter of the current color.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="face"/> or <paramref name="mode"/> is not an
        /// accepted value.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glColorMaterial"/> is executed between
        /// the execution of  <see cref="glBegin"/>  and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glColorMaterial(GLenum face, GLenum mode);</para>
        /// </summary>
        /// <param name="face">
        /// <para>
        /// Specifies whether front,
        /// back,
        /// or both front and back material parameters should track the current color.
        /// Accepted values are
        /// <code>GL_FRONT</code>,
        /// <code>GL_BACK</code>,
        /// and <code>GL_FRONT_AND_BACK</code>.
        /// The initial value is <code>GL_FRONT_AND_BACK</code>.
        /// </para>
        /// </param>
        /// <param name="mode">
        /// <para>
        /// Specifies which of several material parameters track the current color.
        /// Accepted values are
        /// <code>GL_EMISSION</code>,
        /// <code>GL_AMBIENT</code>,
        /// <code>GL_DIFFUSE</code>,
        /// <code>GL_SPECULAR</code>,
        /// and <code>GL_AMBIENT_AND_DIFFUSE</code>.
        /// The initial value is <code>GL_AMBIENT_AND_DIFFUSE</code>.
        /// </para>
        /// </param>
        /// <seealso cref="glColor"/>
        /// <seealso cref="glColorPointer"/>
        /// <seealso cref="glDrawArrays"/>
        /// <seealso cref="glDrawElements"/>
        /// <seealso cref="glDrawRangeElements"/>
        /// <seealso cref="glEnable"/>
        /// <seealso cref="glLight"/>
        /// <seealso cref="glLightModel"/>
        /// <seealso cref="glMaterial"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void glColorMaterial(uint face, uint mode) {
            var _F = _GetProc<GLNativeDelegate.FNglColorMaterial>("glColorMaterial");
            _F(face, mode);
        }
        /// <summary>
        /// specify fog parameters
        /// <para>Require:</para> <para>GL_VERSION_1_0, GL_VERSION_ES_CM_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <code>GL_FOG_COORD_SRC</code> is available only if the GL version is 1.4 or
        /// greater.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="pname"/> is not an accepted value,
        /// or if <paramref name="pname"/> is <code>GL_FOG_MODE</code> and <paramref name="ps"/> is not an accepted value.
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="pname"/> is <code>GL_FOG_DENSITY</code>
        /// and <paramref name="ps"/> is negative.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glFog"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glFogf(GLenum pname, GLfloat param);</para>
        /// </summary>
        /// <param name="pname">
        /// <para>
        /// Specifies a single-valued fog parameter.
        /// <code>GL_FOG_MODE</code>,
        /// <code>GL_FOG_DENSITY</code>,
        /// <code>GL_FOG_START</code>,
        /// <code>GL_FOG_END</code>,
        /// <code>GL_FOG_INDEX</code>, and
        /// <code>GL_FOG_COORD_SRC</code>
        /// are accepted.
        /// </para>
        /// </param>
        /// <param name="param">
        /// Specifies the value that <paramref name="pname"/> will be set to.
        /// </param>
        /// <seealso cref="glEnable"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void glFogf(uint pname, float param) {
            var _F = _GetProc<GLNativeDelegate.FNglFogf>("glFogf");
            _F(pname, param);
        }
        /// <summary>
        /// specify fog parameters
        /// <para>Require:</para> <para>GL_VERSION_1_0, GL_VERSION_ES_CM_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <code>GL_FOG_COORD_SRC</code> is available only if the GL version is 1.4 or
        /// greater.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="pname"/> is not an accepted value,
        /// or if <paramref name="pname"/> is <code>GL_FOG_MODE</code> and <paramref name="ps"/> is not an accepted value.
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="pname"/> is <code>GL_FOG_DENSITY</code>
        /// and <paramref name="ps"/> is negative.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glFog"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glFogfv(GLenum pname, const GLfloat * params);</para>
        /// </summary>
        /// <param name="pname">
        /// <para>
        /// Specifies a fog parameter.
        /// <code>GL_FOG_MODE</code>,
        /// <code>GL_FOG_DENSITY</code>,
        /// <code>GL_FOG_START</code>,
        /// <code>GL_FOG_END</code>,
        /// <code>GL_FOG_INDEX</code>,
        /// <code>GL_FOG_COLOR</code>, and
        /// <code>GL_FOG_COORD_SRC</code>
        /// are accepted.
        /// </para>
        /// </param>
        /// <param name="ps">
        /// <para>
        /// Specifies the value or values to be assigned to <paramref name="pname"/>.
        /// <code>GL_FOG_COLOR</code> requires an array of four values.
        /// All other parameters accept an array containing only a single value.
        /// </para>
        /// </param>
        /// <seealso cref="glEnable"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void glFogfv(uint pname, float* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglFogfv>("glFogfv");
            _F(pname, ps);
        }
        /// <summary>
        /// specify fog parameters
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <code>GL_FOG_COORD_SRC</code> is available only if the GL version is 1.4 or
        /// greater.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="pname"/> is not an accepted value,
        /// or if <paramref name="pname"/> is <code>GL_FOG_MODE</code> and <paramref name="ps"/> is not an accepted value.
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="pname"/> is <code>GL_FOG_DENSITY</code>
        /// and <paramref name="ps"/> is negative.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glFog"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glFogi(GLenum pname, GLint param);</para>
        /// </summary>
        /// <param name="pname">
        /// <para>
        /// Specifies a single-valued fog parameter.
        /// <code>GL_FOG_MODE</code>,
        /// <code>GL_FOG_DENSITY</code>,
        /// <code>GL_FOG_START</code>,
        /// <code>GL_FOG_END</code>,
        /// <code>GL_FOG_INDEX</code>, and
        /// <code>GL_FOG_COORD_SRC</code>
        /// are accepted.
        /// </para>
        /// </param>
        /// <param name="param">
        /// Specifies the value that <paramref name="pname"/> will be set to.
        /// </param>
        /// <seealso cref="glEnable"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void glFogi(uint pname, int param) {
            var _F = _GetProc<GLNativeDelegate.FNglFogi>("glFogi");
            _F(pname, param);
        }
        /// <summary>
        /// specify fog parameters
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <code>GL_FOG_COORD_SRC</code> is available only if the GL version is 1.4 or
        /// greater.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="pname"/> is not an accepted value,
        /// or if <paramref name="pname"/> is <code>GL_FOG_MODE</code> and <paramref name="ps"/> is not an accepted value.
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="pname"/> is <code>GL_FOG_DENSITY</code>
        /// and <paramref name="ps"/> is negative.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glFog"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glFogiv(GLenum pname, const GLint * params);</para>
        /// </summary>
        /// <param name="pname">
        /// <para>
        /// Specifies a fog parameter.
        /// <code>GL_FOG_MODE</code>,
        /// <code>GL_FOG_DENSITY</code>,
        /// <code>GL_FOG_START</code>,
        /// <code>GL_FOG_END</code>,
        /// <code>GL_FOG_INDEX</code>,
        /// <code>GL_FOG_COLOR</code>, and
        /// <code>GL_FOG_COORD_SRC</code>
        /// are accepted.
        /// </para>
        /// </param>
        /// <param name="ps">
        /// <para>
        /// Specifies the value or values to be assigned to <paramref name="pname"/>.
        /// <code>GL_FOG_COLOR</code> requires an array of four values.
        /// All other parameters accept an array containing only a single value.
        /// </para>
        /// </param>
        /// <seealso cref="glEnable"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void glFogiv(uint pname, int* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglFogiv>("glFogiv");
            _F(pname, ps);
        }
        /// <summary>
        /// set light source parameters
        /// <para>Require:</para> <para>GL_VERSION_1_0, GL_VERSION_ES_CM_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// It is always the case that <code>GL_LIGHT</code>
        /// i   
        /// = <code>GL_LIGHT0</code> + 
        /// i   .
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if either <paramref name="light"/> or <paramref name="pname"/>
        /// is not an accepted value.
        /// <code>GL_INVALID_VALUE</code> is generated if a spot exponent value is specified
        /// outside the range 
        /// 0 
        /// 128 
        /// ,
        /// or if spot cutoff is specified outside the range 
        /// 0 
        /// 90 
        /// (except for the
        /// special value 180),
        /// or if a negative attenuation factor is specified.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glLight"/> is executed between
        /// the execution of
        /// <see cref="glBegin"/>  and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glLightf(GLenum light, GLenum pname, GLfloat param);</para>
        /// </summary>
        /// <param name="light">
        /// <para>
        /// Specifies a light.
        /// The number of lights depends on the implementation,
        /// but at least eight lights are supported.
        /// They are identified by symbolic names of the form <code>GL_LIGHT</code>
        /// i   ,
        /// where i ranges from 0 to the value of <code>GL_MAX_LIGHTS</code> - 1.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies a single-valued light source parameter for <paramref name="light"/>.
        /// <code>GL_SPOT_EXPONENT</code>,
        /// <code>GL_SPOT_CUTOFF</code>,
        /// <code>GL_CONSTANT_ATTENUATION</code>,
        /// <code>GL_LINEAR_ATTENUATION</code>, and
        /// <code>GL_QUADRATIC_ATTENUATION</code> are accepted.
        /// </para>
        /// </param>
        /// <param name="param">
        /// <para>
        /// Specifies the value that parameter <paramref name="pname"/> of light source <paramref name="light"/>
        /// will be set to.
        /// </para>
        /// </param>
        /// <seealso cref="glColorMaterial"/>
        /// <seealso cref="glLightModel"/>
        /// <seealso cref="glMaterial"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void glLightf(uint light, uint pname, float param) {
            var _F = _GetProc<GLNativeDelegate.FNglLightf>("glLightf");
            _F(light, pname, param);
        }
        /// <summary>
        /// set light source parameters
        /// <para>Require:</para> <para>GL_VERSION_1_0, GL_VERSION_ES_CM_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// It is always the case that <code>GL_LIGHT</code>
        /// i   
        /// = <code>GL_LIGHT0</code> + 
        /// i   .
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if either <paramref name="light"/> or <paramref name="pname"/>
        /// is not an accepted value.
        /// <code>GL_INVALID_VALUE</code> is generated if a spot exponent value is specified
        /// outside the range 
        /// 0 
        /// 128 
        /// ,
        /// or if spot cutoff is specified outside the range 
        /// 0 
        /// 90 
        /// (except for the
        /// special value 180),
        /// or if a negative attenuation factor is specified.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glLight"/> is executed between
        /// the execution of
        /// <see cref="glBegin"/>  and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glLightfv(GLenum light, GLenum pname, const GLfloat * params);</para>
        /// </summary>
        /// <param name="light">
        /// <para>
        /// Specifies a light.
        /// The number of lights depends on the implementation, but
        /// at least eight lights are supported.
        /// They are identified by symbolic names of the form <code>GL_LIGHT</code>
        /// i   ,
        /// where i ranges from 0 to the value of <code>GL_MAX_LIGHTS</code> - 1.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies a light source parameter for <paramref name="light"/>.
        /// <code>GL_AMBIENT</code>,
        /// <code>GL_DIFFUSE</code>,
        /// <code>GL_SPECULAR</code>,
        /// <code>GL_POSITION</code>,
        /// <code>GL_SPOT_CUTOFF</code>,
        /// <code>GL_SPOT_DIRECTION</code>,
        /// <code>GL_SPOT_EXPONENT</code>,
        /// <code>GL_CONSTANT_ATTENUATION</code>,
        /// <code>GL_LINEAR_ATTENUATION</code>, and
        /// <code>GL_QUADRATIC_ATTENUATION</code> are accepted.
        /// </para>
        /// </param>
        /// <param name="ps">
        /// <para>
        /// Specifies a pointer to the value or values that parameter <paramref name="pname"/>
        /// of light source <paramref name="light"/> will be set to.
        /// </para>
        /// </param>
        /// <seealso cref="glColorMaterial"/>
        /// <seealso cref="glLightModel"/>
        /// <seealso cref="glMaterial"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void glLightfv(uint light, uint pname, float* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglLightfv>("glLightfv");
            _F(light, pname, ps);
        }
        /// <summary>
        /// set light source parameters
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// It is always the case that <code>GL_LIGHT</code>
        /// i   
        /// = <code>GL_LIGHT0</code> + 
        /// i   .
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if either <paramref name="light"/> or <paramref name="pname"/>
        /// is not an accepted value.
        /// <code>GL_INVALID_VALUE</code> is generated if a spot exponent value is specified
        /// outside the range 
        /// 0 
        /// 128 
        /// ,
        /// or if spot cutoff is specified outside the range 
        /// 0 
        /// 90 
        /// (except for the
        /// special value 180),
        /// or if a negative attenuation factor is specified.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glLight"/> is executed between
        /// the execution of
        /// <see cref="glBegin"/>  and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glLighti(GLenum light, GLenum pname, GLint param);</para>
        /// </summary>
        /// <param name="light">
        /// <para>
        /// Specifies a light.
        /// The number of lights depends on the implementation,
        /// but at least eight lights are supported.
        /// They are identified by symbolic names of the form <code>GL_LIGHT</code>
        /// i   ,
        /// where i ranges from 0 to the value of <code>GL_MAX_LIGHTS</code> - 1.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies a single-valued light source parameter for <paramref name="light"/>.
        /// <code>GL_SPOT_EXPONENT</code>,
        /// <code>GL_SPOT_CUTOFF</code>,
        /// <code>GL_CONSTANT_ATTENUATION</code>,
        /// <code>GL_LINEAR_ATTENUATION</code>, and
        /// <code>GL_QUADRATIC_ATTENUATION</code> are accepted.
        /// </para>
        /// </param>
        /// <param name="param">
        /// <para>
        /// Specifies the value that parameter <paramref name="pname"/> of light source <paramref name="light"/>
        /// will be set to.
        /// </para>
        /// </param>
        /// <seealso cref="glColorMaterial"/>
        /// <seealso cref="glLightModel"/>
        /// <seealso cref="glMaterial"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void glLighti(uint light, uint pname, int param) {
            var _F = _GetProc<GLNativeDelegate.FNglLighti>("glLighti");
            _F(light, pname, param);
        }
        /// <summary>
        /// set light source parameters
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// It is always the case that <code>GL_LIGHT</code>
        /// i   
        /// = <code>GL_LIGHT0</code> + 
        /// i   .
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if either <paramref name="light"/> or <paramref name="pname"/>
        /// is not an accepted value.
        /// <code>GL_INVALID_VALUE</code> is generated if a spot exponent value is specified
        /// outside the range 
        /// 0 
        /// 128 
        /// ,
        /// or if spot cutoff is specified outside the range 
        /// 0 
        /// 90 
        /// (except for the
        /// special value 180),
        /// or if a negative attenuation factor is specified.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glLight"/> is executed between
        /// the execution of
        /// <see cref="glBegin"/>  and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glLightiv(GLenum light, GLenum pname, const GLint * params);</para>
        /// </summary>
        /// <param name="light">
        /// <para>
        /// Specifies a light.
        /// The number of lights depends on the implementation, but
        /// at least eight lights are supported.
        /// They are identified by symbolic names of the form <code>GL_LIGHT</code>
        /// i   ,
        /// where i ranges from 0 to the value of <code>GL_MAX_LIGHTS</code> - 1.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies a light source parameter for <paramref name="light"/>.
        /// <code>GL_AMBIENT</code>,
        /// <code>GL_DIFFUSE</code>,
        /// <code>GL_SPECULAR</code>,
        /// <code>GL_POSITION</code>,
        /// <code>GL_SPOT_CUTOFF</code>,
        /// <code>GL_SPOT_DIRECTION</code>,
        /// <code>GL_SPOT_EXPONENT</code>,
        /// <code>GL_CONSTANT_ATTENUATION</code>,
        /// <code>GL_LINEAR_ATTENUATION</code>, and
        /// <code>GL_QUADRATIC_ATTENUATION</code> are accepted.
        /// </para>
        /// </param>
        /// <param name="ps">
        /// <para>
        /// Specifies a pointer to the value or values that parameter <paramref name="pname"/>
        /// of light source <paramref name="light"/> will be set to.
        /// </para>
        /// </param>
        /// <seealso cref="glColorMaterial"/>
        /// <seealso cref="glLightModel"/>
        /// <seealso cref="glMaterial"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void glLightiv(uint light, uint pname, int* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglLightiv>("glLightiv");
            _F(light, pname, ps);
        }
        /// <summary>
        /// set the lighting model parameters
        /// <para>Require:</para> <para>GL_VERSION_1_0, GL_VERSION_ES_CM_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <code>GL_LIGHT_MODEL_COLOR_CONTROL</code> is available only if the GL version is
        /// 1.2 or greater.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="pname"/> is not an accepted value.
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="pname"/> is
        /// <code>GL_LIGHT_MODEL_COLOR_CONTROL</code> and <paramref name="ps"/> is not one of
        /// <code>GL_SINGLE_COLOR</code> or <code>GL_SEPARATE_SPECULAR_COLOR</code>.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glLightModel"/> is executed between
        /// the execution of  <see cref="glBegin"/>  and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glLightModelf(GLenum pname, GLfloat param);</para>
        /// </summary>
        /// <param name="pname">
        /// <para>
        /// Specifies a single-valued lighting model parameter.
        /// <code>GL_LIGHT_MODEL_LOCAL_VIEWER</code>,
        /// <code>GL_LIGHT_MODEL_COLOR_CONTROL</code>, and
        /// <code>GL_LIGHT_MODEL_TWO_SIDE</code> are accepted.
        /// </para>
        /// </param>
        /// <param name="param">
        /// Specifies the value that <paramref name="param"/> will be set to.
        /// </param>
        /// <seealso cref="glLight"/>
        /// <seealso cref="glMaterial"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void glLightModelf(uint pname, float param) {
            var _F = _GetProc<GLNativeDelegate.FNglLightModelf>("glLightModelf");
            _F(pname, param);
        }
        /// <summary>
        /// set the lighting model parameters
        /// <para>Require:</para> <para>GL_VERSION_1_0, GL_VERSION_ES_CM_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <code>GL_LIGHT_MODEL_COLOR_CONTROL</code> is available only if the GL version is
        /// 1.2 or greater.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="pname"/> is not an accepted value.
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="pname"/> is
        /// <code>GL_LIGHT_MODEL_COLOR_CONTROL</code> and <paramref name="ps"/> is not one of
        /// <code>GL_SINGLE_COLOR</code> or <code>GL_SEPARATE_SPECULAR_COLOR</code>.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glLightModel"/> is executed between
        /// the execution of  <see cref="glBegin"/>  and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glLightModelfv(GLenum pname, const GLfloat * params);</para>
        /// </summary>
        /// <param name="pname">
        /// <para>
        /// Specifies a lighting model parameter.
        /// <code>GL_LIGHT_MODEL_AMBIENT</code>,
        /// <code>GL_LIGHT_MODEL_COLOR_CONTROL</code>,
        /// <code>GL_LIGHT_MODEL_LOCAL_VIEWER</code>, and
        /// <code>GL_LIGHT_MODEL_TWO_SIDE</code> are accepted.
        /// </para>
        /// </param>
        /// <param name="ps">
        /// Specifies a pointer to the value or values that <paramref name="ps"/> will be set to.
        /// </param>
        /// <seealso cref="glLight"/>
        /// <seealso cref="glMaterial"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void glLightModelfv(uint pname, float* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglLightModelfv>("glLightModelfv");
            _F(pname, ps);
        }
        /// <summary>
        /// set the lighting model parameters
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <code>GL_LIGHT_MODEL_COLOR_CONTROL</code> is available only if the GL version is
        /// 1.2 or greater.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="pname"/> is not an accepted value.
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="pname"/> is
        /// <code>GL_LIGHT_MODEL_COLOR_CONTROL</code> and <paramref name="ps"/> is not one of
        /// <code>GL_SINGLE_COLOR</code> or <code>GL_SEPARATE_SPECULAR_COLOR</code>.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glLightModel"/> is executed between
        /// the execution of  <see cref="glBegin"/>  and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glLightModeli(GLenum pname, GLint param);</para>
        /// </summary>
        /// <param name="pname">
        /// <para>
        /// Specifies a single-valued lighting model parameter.
        /// <code>GL_LIGHT_MODEL_LOCAL_VIEWER</code>,
        /// <code>GL_LIGHT_MODEL_COLOR_CONTROL</code>, and
        /// <code>GL_LIGHT_MODEL_TWO_SIDE</code> are accepted.
        /// </para>
        /// </param>
        /// <param name="param">
        /// Specifies the value that <paramref name="param"/> will be set to.
        /// </param>
        /// <seealso cref="glLight"/>
        /// <seealso cref="glMaterial"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void glLightModeli(uint pname, int param) {
            var _F = _GetProc<GLNativeDelegate.FNglLightModeli>("glLightModeli");
            _F(pname, param);
        }
        /// <summary>
        /// set the lighting model parameters
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <code>GL_LIGHT_MODEL_COLOR_CONTROL</code> is available only if the GL version is
        /// 1.2 or greater.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="pname"/> is not an accepted value.
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="pname"/> is
        /// <code>GL_LIGHT_MODEL_COLOR_CONTROL</code> and <paramref name="ps"/> is not one of
        /// <code>GL_SINGLE_COLOR</code> or <code>GL_SEPARATE_SPECULAR_COLOR</code>.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glLightModel"/> is executed between
        /// the execution of  <see cref="glBegin"/>  and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glLightModeliv(GLenum pname, const GLint * params);</para>
        /// </summary>
        /// <param name="pname">
        /// <para>
        /// Specifies a lighting model parameter.
        /// <code>GL_LIGHT_MODEL_AMBIENT</code>,
        /// <code>GL_LIGHT_MODEL_COLOR_CONTROL</code>,
        /// <code>GL_LIGHT_MODEL_LOCAL_VIEWER</code>, and
        /// <code>GL_LIGHT_MODEL_TWO_SIDE</code> are accepted.
        /// </para>
        /// </param>
        /// <param name="ps">
        /// Specifies a pointer to the value or values that <paramref name="ps"/> will be set to.
        /// </param>
        /// <seealso cref="glLight"/>
        /// <seealso cref="glMaterial"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void glLightModeliv(uint pname, int* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglLightModeliv>("glLightModeliv");
            _F(pname, ps);
        }
        /// <summary>
        /// specify the line stipple pattern
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glLineStipple"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glLineStipple(GLint factor, GLushort pattern);</para>
        /// </summary>
        /// <param name="factor">
        /// <para>
        /// Specifies a multiplier for each bit in the line stipple pattern.
        /// If <paramref name="factor"/> is 3,
        /// for example,
        /// each bit in the pattern is used three times
        /// before the next bit in the pattern is used.
        /// <paramref name="factor"/> is clamped to the range [1, 256] and defaults to 1.
        /// </para>
        /// </param>
        /// <param name="pattern">
        /// <para>
        /// Specifies a 16-bit integer whose bit pattern determines
        /// which fragments of a line will be drawn when the line is rasterized.
        /// Bit zero is used first; the default pattern is all 1's.
        /// </para>
        /// </param>
        /// <seealso cref="glLineWidth"/>
        /// <seealso cref="glPolygonStipple"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void glLineStipple(int factor, ushort pattern) {
            var _F = _GetProc<GLNativeDelegate.FNglLineStipple>("glLineStipple");
            _F(factor, pattern);
        }
        /// <summary>
        /// specify material parameters for the lighting model
        /// <para>Require:</para> <para>GL_VERSION_1_0, GL_VERSION_ES_CM_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The material parameters can be updated at any time.
        /// In particular,
        /// <see cref="glMaterial"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// If only a single material parameter is to be changed per vertex,
        /// however,
        /// <see cref="glColorMaterial"/>  is preferred over <see cref="glMaterial"/>
        /// (see  <see cref="glColorMaterial"/> ).
        /// While the ambient, diffuse, specular and emission material parameters
        /// all have alpha components, only the diffuse alpha component is used in
        /// the lighting computation.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if either <paramref name="face"/> or <paramref name="pname"/> is not
        /// an accepted value.
        /// <code>GL_INVALID_VALUE</code> is generated if a specular exponent outside the range
        /// 0 
        /// 128 
        /// is specified.
        /// </para>
        /// Original: <para>void glMaterialf(GLenum face, GLenum pname, GLfloat param);</para>
        /// </summary>
        /// <param name="face">
        /// <para>
        /// Specifies which face or faces are being updated.
        /// Must be one of
        /// <code>GL_FRONT</code>,
        /// <code>GL_BACK</code>, or
        /// <code>GL_FRONT_AND_BACK</code>.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the single-valued material parameter of the face or faces
        /// that is being updated.
        /// Must be <code>GL_SHININESS</code>.
        /// </para>
        /// </param>
        /// <param name="param">
        /// Specifies the value that parameter <code>GL_SHININESS</code> will be set to.
        /// </param>
        /// <seealso cref="glColorMaterial"/>
        /// <seealso cref="glLight"/>
        /// <seealso cref="glLightModel"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void glMaterialf(uint face, uint pname, float param) {
            var _F = _GetProc<GLNativeDelegate.FNglMaterialf>("glMaterialf");
            _F(face, pname, param);
        }
        /// <summary>
        /// specify material parameters for the lighting model
        /// <para>Require:</para> <para>GL_VERSION_1_0, GL_VERSION_ES_CM_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The material parameters can be updated at any time.
        /// In particular,
        /// <see cref="glMaterial"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// If only a single material parameter is to be changed per vertex,
        /// however,
        /// <see cref="glColorMaterial"/>  is preferred over <see cref="glMaterial"/>
        /// (see  <see cref="glColorMaterial"/> ).
        /// While the ambient, diffuse, specular and emission material parameters
        /// all have alpha components, only the diffuse alpha component is used in
        /// the lighting computation.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if either <paramref name="face"/> or <paramref name="pname"/> is not
        /// an accepted value.
        /// <code>GL_INVALID_VALUE</code> is generated if a specular exponent outside the range
        /// 0 
        /// 128 
        /// is specified.
        /// </para>
        /// Original: <para>void glMaterialfv(GLenum face, GLenum pname, const GLfloat * params);</para>
        /// </summary>
        /// <param name="face">
        /// <para>
        /// Specifies which face or faces are being updated.
        /// Must be one of
        /// <code>GL_FRONT</code>,
        /// <code>GL_BACK</code>, or
        /// <code>GL_FRONT_AND_BACK</code>.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the material parameter of the face or faces that is being updated.
        /// Must be one of
        /// <code>GL_AMBIENT</code>,
        /// <code>GL_DIFFUSE</code>,
        /// <code>GL_SPECULAR</code>,
        /// <code>GL_EMISSION</code>,
        /// <code>GL_SHININESS</code>,
        /// <code>GL_AMBIENT_AND_DIFFUSE</code>, or
        /// <code>GL_COLOR_INDEXES</code>.
        /// </para>
        /// </param>
        /// <param name="ps">
        /// Specifies a pointer to the value or values that <paramref name="pname"/> will be set to.
        /// </param>
        /// <seealso cref="glColorMaterial"/>
        /// <seealso cref="glLight"/>
        /// <seealso cref="glLightModel"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void glMaterialfv(uint face, uint pname, float* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglMaterialfv>("glMaterialfv");
            _F(face, pname, ps);
        }
        /// <summary>
        /// specify material parameters for the lighting model
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The material parameters can be updated at any time.
        /// In particular,
        /// <see cref="glMaterial"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// If only a single material parameter is to be changed per vertex,
        /// however,
        /// <see cref="glColorMaterial"/>  is preferred over <see cref="glMaterial"/>
        /// (see  <see cref="glColorMaterial"/> ).
        /// While the ambient, diffuse, specular and emission material parameters
        /// all have alpha components, only the diffuse alpha component is used in
        /// the lighting computation.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if either <paramref name="face"/> or <paramref name="pname"/> is not
        /// an accepted value.
        /// <code>GL_INVALID_VALUE</code> is generated if a specular exponent outside the range
        /// 0 
        /// 128 
        /// is specified.
        /// </para>
        /// Original: <para>void glMateriali(GLenum face, GLenum pname, GLint param);</para>
        /// </summary>
        /// <param name="face">
        /// <para>
        /// Specifies which face or faces are being updated.
        /// Must be one of
        /// <code>GL_FRONT</code>,
        /// <code>GL_BACK</code>, or
        /// <code>GL_FRONT_AND_BACK</code>.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the single-valued material parameter of the face or faces
        /// that is being updated.
        /// Must be <code>GL_SHININESS</code>.
        /// </para>
        /// </param>
        /// <param name="param">
        /// Specifies the value that parameter <code>GL_SHININESS</code> will be set to.
        /// </param>
        /// <seealso cref="glColorMaterial"/>
        /// <seealso cref="glLight"/>
        /// <seealso cref="glLightModel"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void glMateriali(uint face, uint pname, int param) {
            var _F = _GetProc<GLNativeDelegate.FNglMateriali>("glMateriali");
            _F(face, pname, param);
        }
        /// <summary>
        /// specify material parameters for the lighting model
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The material parameters can be updated at any time.
        /// In particular,
        /// <see cref="glMaterial"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// If only a single material parameter is to be changed per vertex,
        /// however,
        /// <see cref="glColorMaterial"/>  is preferred over <see cref="glMaterial"/>
        /// (see  <see cref="glColorMaterial"/> ).
        /// While the ambient, diffuse, specular and emission material parameters
        /// all have alpha components, only the diffuse alpha component is used in
        /// the lighting computation.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if either <paramref name="face"/> or <paramref name="pname"/> is not
        /// an accepted value.
        /// <code>GL_INVALID_VALUE</code> is generated if a specular exponent outside the range
        /// 0 
        /// 128 
        /// is specified.
        /// </para>
        /// Original: <para>void glMaterialiv(GLenum face, GLenum pname, const GLint * params);</para>
        /// </summary>
        /// <param name="face">
        /// <para>
        /// Specifies which face or faces are being updated.
        /// Must be one of
        /// <code>GL_FRONT</code>,
        /// <code>GL_BACK</code>, or
        /// <code>GL_FRONT_AND_BACK</code>.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the material parameter of the face or faces that is being updated.
        /// Must be one of
        /// <code>GL_AMBIENT</code>,
        /// <code>GL_DIFFUSE</code>,
        /// <code>GL_SPECULAR</code>,
        /// <code>GL_EMISSION</code>,
        /// <code>GL_SHININESS</code>,
        /// <code>GL_AMBIENT_AND_DIFFUSE</code>, or
        /// <code>GL_COLOR_INDEXES</code>.
        /// </para>
        /// </param>
        /// <param name="ps">
        /// Specifies a pointer to the value or values that <paramref name="pname"/> will be set to.
        /// </param>
        /// <seealso cref="glColorMaterial"/>
        /// <seealso cref="glLight"/>
        /// <seealso cref="glLightModel"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void glMaterialiv(uint face, uint pname, int* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglMaterialiv>("glMaterialiv");
            _F(face, pname, ps);
        }
        /// <summary>
        /// set the polygon stippling pattern
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_UNPACK_BUFFER</code> target and the buffer object's data store is currently mapped.
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_UNPACK_BUFFER</code> target and the data would be unpacked from the buffer 
        /// object such that the memory reads required would exceed the data store size.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glPolygonStipple"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glPolygonStipple(const GLubyte * pattern);</para>
        /// </summary>
        /// <param name="pattern">
        /// <para>
        /// Specifies a pointer to a 
        /// 32 
        /// &times; 
        /// 32 
        /// stipple pattern that will be unpacked
        /// from memory in the same way that  <see cref="glDrawPixels"/>  unpacks pixels.
        /// </para>
        /// </param>
        /// <seealso cref="glDrawPixels"/>
        /// <seealso cref="glLineStipple"/>
        /// <seealso cref="glPixelStore"/>
        /// <seealso cref="glPixelTransfer"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void glPolygonStipple(byte* pattern) {
            var _F = _GetProc<GLNativeDelegate.FNglPolygonStipple>("glPolygonStipple");
            _F(pattern);
        }
        /// <summary>
        /// select flat or smooth shading
        /// <para>Require:</para> <para>GL_VERSION_1_0, GL_VERSION_ES_CM_1_0</para>
        /// Supported: <para>GL</para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="mode"/> is any value other than
        /// <code>GL_FLAT</code> or <code>GL_SMOOTH</code>.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glShadeModel"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glShadeModel(GLenum mode);</para>
        /// </summary>
        /// <param name="mode">
        /// <para>
        /// Specifies a symbolic value representing a shading technique.
        /// Accepted values are <code>GL_FLAT</code> and <code>GL_SMOOTH</code>.
        /// The initial value is <code>GL_SMOOTH</code>.
        /// </para>
        /// </param>
        /// <seealso cref="glBegin"/>
        /// <seealso cref="glColor"/>
        /// <seealso cref="glLight"/>
        /// <seealso cref="glLightModel"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void glShadeModel(uint mode) {
            var _F = _GetProc<GLNativeDelegate.FNglShadeModel>("glShadeModel");
            _F(mode);
        }
        /// <summary>
        /// set texture environment parameters
        /// <para>Require:</para> <para>GL_VERSION_1_0, GL_VERSION_ES_CM_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <code>GL_REPLACE</code> may only be used if the GL version is 1.1 or greater.
        /// <code>GL_TEXTURE_FILTER_CONTROL</code> and <code>GL_TEXTURE_LOD_BIAS</code> may only be
        /// used if the GL version is 1.4 or greater.
        /// <code>GL_COMBINE</code> mode and its associated constants may only be used if the
        /// GL version is 1.3 or greater.
        /// <code>GL_TEXTUREn</code> may only be used if the GL version is 1.4 or greater.
        /// Internal formats other than 1, 2, 3, or 4 may only be used if the GL
        /// version is 1.1 or greater.
        /// For OpenGL versions 1.3 and greater, or when the <code>ARB_multitexture</code> extension is supported, <see cref="glTexEnv"/> controls
        /// the texture environment for the current active texture unit, selected by
        /// <see cref="glActiveTexture"/> .
        /// <code>GL_POINT_SPRITE</code> and <code>GL_COORD_REPLACE</code> are available
        /// only if the GL version is 2.0 or greater.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated when <paramref name="target"/> or <paramref name="pname"/> is not
        /// one of the accepted defined values,
        /// or when <paramref name="ps"/> should have a defined constant value
        /// (based on the value of <paramref name="pname"/>)
        /// and does not.
        /// <code>GL_INVALID_VALUE</code> is generated if the <paramref name="ps"/> value for
        /// <code>GL_RGB_SCALE</code> or <code>GL_ALPHA_SCALE</code> are not one of 1.0, 2.0,
        /// or 4.0.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glTexEnv"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glTexEnvf(GLenum target, GLenum pname, GLfloat param);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies a texture environment.
        /// May be <code>GL_TEXTURE_ENV</code>, <code>GL_TEXTURE_FILTER_CONTROL</code> or <code>GL_POINT_SPRITE</code>.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of a single-valued texture environment parameter.
        /// May be either <code>GL_TEXTURE_ENV_MODE</code>, <code>GL_TEXTURE_LOD_BIAS</code>,
        /// <code>GL_COMBINE_RGB</code>,
        /// <code>GL_COMBINE_ALPHA</code>,
        /// <code>GL_SRC0_RGB</code>,
        /// <code>GL_SRC1_RGB</code>,
        /// <code>GL_SRC2_RGB</code>,
        /// <code>GL_SRC0_ALPHA</code>,
        /// <code>GL_SRC1_ALPHA</code>,
        /// <code>GL_SRC2_ALPHA</code>,
        /// <code>GL_OPERAND0_RGB</code>,
        /// <code>GL_OPERAND1_RGB</code>,
        /// <code>GL_OPERAND2_RGB</code>,
        /// <code>GL_OPERAND0_ALPHA</code>,
        /// <code>GL_OPERAND1_ALPHA</code>,
        /// <code>GL_OPERAND2_ALPHA</code>,
        /// <code>GL_RGB_SCALE</code>,
        /// <code>GL_ALPHA_SCALE</code>, or
        /// <code>GL_COORD_REPLACE</code>.
        /// </para>
        /// </param>
        /// <param name="param">
        /// <para>
        /// Specifies a single symbolic constant, one of <code>GL_ADD</code>,
        /// <code>GL_ADD_SIGNED</code>, <code>GL_INTERPOLATE</code>, <code>GL_MODULATE</code>, <code>GL_DECAL</code>,
        /// <code>GL_BLEND</code>, <code>GL_REPLACE</code>, <code>GL_SUBTRACT</code>, <code>GL_COMBINE</code>,
        /// <code>GL_TEXTURE</code>, <code>GL_CONSTANT</code>, <code>GL_PRIMARY_COLOR</code>, <code>GL_PREVIOUS</code>,
        /// <code>GL_SRC_COLOR</code>, <code>GL_ONE_MINUS_SRC_COLOR</code>, <code>GL_SRC_ALPHA</code>,
        /// <code>GL_ONE_MINUS_SRC_ALPHA</code>,
        /// a single boolean value for the point sprite texture coordinate replacement,
        /// a single floating-point value for the texture level-of-detail bias,
        /// or 1.0, 2.0, or 4.0 when specifying the <code>GL_RGB_SCALE</code> or <code>GL_ALPHA_SCALE</code>.
        /// </para>
        /// </param>
        /// <seealso cref="glActiveTexture"/>
        /// <seealso cref="glCopyPixels"/>
        /// <seealso cref="glCopyTexImage1D"/>
        /// <seealso cref="glCopyTexImage2D"/>
        /// <seealso cref="glCopyTexSubImage1D"/>
        /// <seealso cref="glCopyTexSubImage2D"/>
        /// <seealso cref="glCopyTexSubImage3D"/>
        /// <seealso cref="glTexImage1D"/>
        /// <seealso cref="glTexImage2D"/>
        /// <seealso cref="glTexImage3D"/>
        /// <seealso cref="glTexParameter"/>
        /// <seealso cref="glTexSubImage1D"/>
        /// <seealso cref="glTexSubImage2D"/>
        /// <seealso cref="glTexSubImage3D"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void glTexEnvf(uint target, uint pname, float param) {
            var _F = _GetProc<GLNativeDelegate.FNglTexEnvf>("glTexEnvf");
            _F(target, pname, param);
        }
        /// <summary>
        /// set texture environment parameters
        /// <para>Require:</para> <para>GL_VERSION_1_0, GL_VERSION_ES_CM_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <code>GL_REPLACE</code> may only be used if the GL version is 1.1 or greater.
        /// <code>GL_TEXTURE_FILTER_CONTROL</code> and <code>GL_TEXTURE_LOD_BIAS</code> may only be
        /// used if the GL version is 1.4 or greater.
        /// <code>GL_COMBINE</code> mode and its associated constants may only be used if the
        /// GL version is 1.3 or greater.
        /// <code>GL_TEXTUREn</code> may only be used if the GL version is 1.4 or greater.
        /// Internal formats other than 1, 2, 3, or 4 may only be used if the GL
        /// version is 1.1 or greater.
        /// For OpenGL versions 1.3 and greater, or when the <code>ARB_multitexture</code> extension is supported, <see cref="glTexEnv"/> controls
        /// the texture environment for the current active texture unit, selected by
        /// <see cref="glActiveTexture"/> .
        /// <code>GL_POINT_SPRITE</code> and <code>GL_COORD_REPLACE</code> are available
        /// only if the GL version is 2.0 or greater.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated when <paramref name="target"/> or <paramref name="pname"/> is not
        /// one of the accepted defined values,
        /// or when <paramref name="ps"/> should have a defined constant value
        /// (based on the value of <paramref name="pname"/>)
        /// and does not.
        /// <code>GL_INVALID_VALUE</code> is generated if the <paramref name="ps"/> value for
        /// <code>GL_RGB_SCALE</code> or <code>GL_ALPHA_SCALE</code> are not one of 1.0, 2.0,
        /// or 4.0.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glTexEnv"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glTexEnvfv(GLenum target, GLenum pname, const GLfloat * params);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies a texture environment.
        /// May be either <code>GL_TEXTURE_ENV</code>, or <code>GL_TEXTURE_FILTER_CONTROL</code>.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of a texture environment parameter.
        /// Accepted values are <code>GL_TEXTURE_ENV_MODE</code>, <code>GL_TEXTURE_ENV_COLOR</code>, or
        /// <code>GL_TEXTURE_LOD_BIAS</code>.
        /// </para>
        /// </param>
        /// <param name="ps">
        /// <para>
        /// Specifies a pointer to a parameter array that contains
        /// either a single symbolic constant, single floating-point number, or an RGBA
        /// color.
        /// </para>
        /// </param>
        /// <seealso cref="glActiveTexture"/>
        /// <seealso cref="glCopyPixels"/>
        /// <seealso cref="glCopyTexImage1D"/>
        /// <seealso cref="glCopyTexImage2D"/>
        /// <seealso cref="glCopyTexSubImage1D"/>
        /// <seealso cref="glCopyTexSubImage2D"/>
        /// <seealso cref="glCopyTexSubImage3D"/>
        /// <seealso cref="glTexImage1D"/>
        /// <seealso cref="glTexImage2D"/>
        /// <seealso cref="glTexImage3D"/>
        /// <seealso cref="glTexParameter"/>
        /// <seealso cref="glTexSubImage1D"/>
        /// <seealso cref="glTexSubImage2D"/>
        /// <seealso cref="glTexSubImage3D"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void glTexEnvfv(uint target, uint pname, float* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglTexEnvfv>("glTexEnvfv");
            _F(target, pname, ps);
        }
        /// <summary>
        /// set texture environment parameters
        /// <para>Require:</para> <para>GL_VERSION_1_0, GL_VERSION_ES_CM_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <code>GL_REPLACE</code> may only be used if the GL version is 1.1 or greater.
        /// <code>GL_TEXTURE_FILTER_CONTROL</code> and <code>GL_TEXTURE_LOD_BIAS</code> may only be
        /// used if the GL version is 1.4 or greater.
        /// <code>GL_COMBINE</code> mode and its associated constants may only be used if the
        /// GL version is 1.3 or greater.
        /// <code>GL_TEXTUREn</code> may only be used if the GL version is 1.4 or greater.
        /// Internal formats other than 1, 2, 3, or 4 may only be used if the GL
        /// version is 1.1 or greater.
        /// For OpenGL versions 1.3 and greater, or when the <code>ARB_multitexture</code> extension is supported, <see cref="glTexEnv"/> controls
        /// the texture environment for the current active texture unit, selected by
        /// <see cref="glActiveTexture"/> .
        /// <code>GL_POINT_SPRITE</code> and <code>GL_COORD_REPLACE</code> are available
        /// only if the GL version is 2.0 or greater.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated when <paramref name="target"/> or <paramref name="pname"/> is not
        /// one of the accepted defined values,
        /// or when <paramref name="ps"/> should have a defined constant value
        /// (based on the value of <paramref name="pname"/>)
        /// and does not.
        /// <code>GL_INVALID_VALUE</code> is generated if the <paramref name="ps"/> value for
        /// <code>GL_RGB_SCALE</code> or <code>GL_ALPHA_SCALE</code> are not one of 1.0, 2.0,
        /// or 4.0.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glTexEnv"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glTexEnvi(GLenum target, GLenum pname, GLint param);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies a texture environment.
        /// May be <code>GL_TEXTURE_ENV</code>, <code>GL_TEXTURE_FILTER_CONTROL</code> or <code>GL_POINT_SPRITE</code>.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of a single-valued texture environment parameter.
        /// May be either <code>GL_TEXTURE_ENV_MODE</code>, <code>GL_TEXTURE_LOD_BIAS</code>,
        /// <code>GL_COMBINE_RGB</code>,
        /// <code>GL_COMBINE_ALPHA</code>,
        /// <code>GL_SRC0_RGB</code>,
        /// <code>GL_SRC1_RGB</code>,
        /// <code>GL_SRC2_RGB</code>,
        /// <code>GL_SRC0_ALPHA</code>,
        /// <code>GL_SRC1_ALPHA</code>,
        /// <code>GL_SRC2_ALPHA</code>,
        /// <code>GL_OPERAND0_RGB</code>,
        /// <code>GL_OPERAND1_RGB</code>,
        /// <code>GL_OPERAND2_RGB</code>,
        /// <code>GL_OPERAND0_ALPHA</code>,
        /// <code>GL_OPERAND1_ALPHA</code>,
        /// <code>GL_OPERAND2_ALPHA</code>,
        /// <code>GL_RGB_SCALE</code>,
        /// <code>GL_ALPHA_SCALE</code>, or
        /// <code>GL_COORD_REPLACE</code>.
        /// </para>
        /// </param>
        /// <param name="param">
        /// <para>
        /// Specifies a single symbolic constant, one of <code>GL_ADD</code>,
        /// <code>GL_ADD_SIGNED</code>, <code>GL_INTERPOLATE</code>, <code>GL_MODULATE</code>, <code>GL_DECAL</code>,
        /// <code>GL_BLEND</code>, <code>GL_REPLACE</code>, <code>GL_SUBTRACT</code>, <code>GL_COMBINE</code>,
        /// <code>GL_TEXTURE</code>, <code>GL_CONSTANT</code>, <code>GL_PRIMARY_COLOR</code>, <code>GL_PREVIOUS</code>,
        /// <code>GL_SRC_COLOR</code>, <code>GL_ONE_MINUS_SRC_COLOR</code>, <code>GL_SRC_ALPHA</code>,
        /// <code>GL_ONE_MINUS_SRC_ALPHA</code>,
        /// a single boolean value for the point sprite texture coordinate replacement,
        /// a single floating-point value for the texture level-of-detail bias,
        /// or 1.0, 2.0, or 4.0 when specifying the <code>GL_RGB_SCALE</code> or <code>GL_ALPHA_SCALE</code>.
        /// </para>
        /// </param>
        /// <seealso cref="glActiveTexture"/>
        /// <seealso cref="glCopyPixels"/>
        /// <seealso cref="glCopyTexImage1D"/>
        /// <seealso cref="glCopyTexImage2D"/>
        /// <seealso cref="glCopyTexSubImage1D"/>
        /// <seealso cref="glCopyTexSubImage2D"/>
        /// <seealso cref="glCopyTexSubImage3D"/>
        /// <seealso cref="glTexImage1D"/>
        /// <seealso cref="glTexImage2D"/>
        /// <seealso cref="glTexImage3D"/>
        /// <seealso cref="glTexParameter"/>
        /// <seealso cref="glTexSubImage1D"/>
        /// <seealso cref="glTexSubImage2D"/>
        /// <seealso cref="glTexSubImage3D"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void glTexEnvi(uint target, uint pname, int param) {
            var _F = _GetProc<GLNativeDelegate.FNglTexEnvi>("glTexEnvi");
            _F(target, pname, param);
        }
        /// <summary>
        /// set texture environment parameters
        /// <para>Require:</para> <para>GL_VERSION_1_0, GL_VERSION_ES_CM_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <code>GL_REPLACE</code> may only be used if the GL version is 1.1 or greater.
        /// <code>GL_TEXTURE_FILTER_CONTROL</code> and <code>GL_TEXTURE_LOD_BIAS</code> may only be
        /// used if the GL version is 1.4 or greater.
        /// <code>GL_COMBINE</code> mode and its associated constants may only be used if the
        /// GL version is 1.3 or greater.
        /// <code>GL_TEXTUREn</code> may only be used if the GL version is 1.4 or greater.
        /// Internal formats other than 1, 2, 3, or 4 may only be used if the GL
        /// version is 1.1 or greater.
        /// For OpenGL versions 1.3 and greater, or when the <code>ARB_multitexture</code> extension is supported, <see cref="glTexEnv"/> controls
        /// the texture environment for the current active texture unit, selected by
        /// <see cref="glActiveTexture"/> .
        /// <code>GL_POINT_SPRITE</code> and <code>GL_COORD_REPLACE</code> are available
        /// only if the GL version is 2.0 or greater.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated when <paramref name="target"/> or <paramref name="pname"/> is not
        /// one of the accepted defined values,
        /// or when <paramref name="ps"/> should have a defined constant value
        /// (based on the value of <paramref name="pname"/>)
        /// and does not.
        /// <code>GL_INVALID_VALUE</code> is generated if the <paramref name="ps"/> value for
        /// <code>GL_RGB_SCALE</code> or <code>GL_ALPHA_SCALE</code> are not one of 1.0, 2.0,
        /// or 4.0.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glTexEnv"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glTexEnviv(GLenum target, GLenum pname, const GLint * params);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies a texture environment.
        /// May be either <code>GL_TEXTURE_ENV</code>, or <code>GL_TEXTURE_FILTER_CONTROL</code>.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of a texture environment parameter.
        /// Accepted values are <code>GL_TEXTURE_ENV_MODE</code>, <code>GL_TEXTURE_ENV_COLOR</code>, or
        /// <code>GL_TEXTURE_LOD_BIAS</code>.
        /// </para>
        /// </param>
        /// <param name="ps">
        /// <para>
        /// Specifies a pointer to a parameter array that contains
        /// either a single symbolic constant, single floating-point number, or an RGBA
        /// color.
        /// </para>
        /// </param>
        /// <seealso cref="glActiveTexture"/>
        /// <seealso cref="glCopyPixels"/>
        /// <seealso cref="glCopyTexImage1D"/>
        /// <seealso cref="glCopyTexImage2D"/>
        /// <seealso cref="glCopyTexSubImage1D"/>
        /// <seealso cref="glCopyTexSubImage2D"/>
        /// <seealso cref="glCopyTexSubImage3D"/>
        /// <seealso cref="glTexImage1D"/>
        /// <seealso cref="glTexImage2D"/>
        /// <seealso cref="glTexImage3D"/>
        /// <seealso cref="glTexParameter"/>
        /// <seealso cref="glTexSubImage1D"/>
        /// <seealso cref="glTexSubImage2D"/>
        /// <seealso cref="glTexSubImage3D"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void glTexEnviv(uint target, uint pname, int* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglTexEnviv>("glTexEnviv");
            _F(target, pname, ps);
        }
        /// <summary>
        /// control the generation of texture coordinates
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated when <paramref name="coord"/> or <paramref name="pname"/> is not an
        /// accepted defined value,
        /// or when <paramref name="pname"/> is <code>GL_TEXTURE_GEN_MODE</code> and <paramref name="ps"/> is not an
        /// accepted defined value.
        /// <code>GL_INVALID_ENUM</code> is generated when <paramref name="pname"/> is <code>GL_TEXTURE_GEN_MODE</code>,
        /// <paramref name="ps"/> is <code>GL_SPHERE_MAP</code>,
        /// and <paramref name="coord"/> is either <code>GL_R</code> or <code>GL_Q</code>.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glTexGen"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glTexGend(GLenum coord, GLenum pname, GLdouble param);</para>
        /// </summary>
        /// <param name="coord">
        /// <para>
        /// Specifies a texture coordinate.
        /// Must be one of <code>GL_S</code>, <code>GL_T</code>, <code>GL_R</code>, or <code>GL_Q</code>.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of the texture-coordinate generation function.
        /// Must be <code>GL_TEXTURE_GEN_MODE</code>.
        /// </para>
        /// </param>
        /// <param name="param">
        /// <para>
        /// Specifies a single-valued texture generation parameter,
        /// one of <code>GL_OBJECT_LINEAR</code>, <code>GL_EYE_LINEAR</code>, <code>GL_SPHERE_MAP</code>,
        /// <code>GL_NORMAL_MAP</code>, or <code>GL_REFLECTION_MAP</code>.
        /// </para>
        /// </param>
        /// <seealso cref="glActiveTexture"/>
        /// <seealso cref="glCopyPixels"/>
        /// <seealso cref="glCopyTexImage2D"/>
        /// <seealso cref="glCopyTexSubImage1D"/>
        /// <seealso cref="glCopyTexSubImage2D"/>
        /// <seealso cref="glCopyTexSubImage3D"/>
        /// <seealso cref="glTexEnv"/>
        /// <seealso cref="glTexImage1D"/>
        /// <seealso cref="glTexImage2D"/>
        /// <seealso cref="glTexImage3D"/>
        /// <seealso cref="glTexParameter"/>
        /// <seealso cref="glTexSubImage1D"/>
        /// <seealso cref="glTexSubImage2D"/>
        /// <seealso cref="glTexSubImage3D"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void glTexGend(uint coord, uint pname, double param) {
            var _F = _GetProc<GLNativeDelegate.FNglTexGend>("glTexGend");
            _F(coord, pname, param);
        }
        /// <summary>
        /// control the generation of texture coordinates
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated when <paramref name="coord"/> or <paramref name="pname"/> is not an
        /// accepted defined value,
        /// or when <paramref name="pname"/> is <code>GL_TEXTURE_GEN_MODE</code> and <paramref name="ps"/> is not an
        /// accepted defined value.
        /// <code>GL_INVALID_ENUM</code> is generated when <paramref name="pname"/> is <code>GL_TEXTURE_GEN_MODE</code>,
        /// <paramref name="ps"/> is <code>GL_SPHERE_MAP</code>,
        /// and <paramref name="coord"/> is either <code>GL_R</code> or <code>GL_Q</code>.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glTexGen"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glTexGendv(GLenum coord, GLenum pname, const GLdouble * params);</para>
        /// </summary>
        /// <param name="coord">
        /// <para>
        /// Specifies a texture coordinate.
        /// Must be one of <code>GL_S</code>, <code>GL_T</code>, <code>GL_R</code>, or <code>GL_Q</code>.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of the texture-coordinate generation function
        /// or function parameters.
        /// Must be
        /// <code>GL_TEXTURE_GEN_MODE</code>,
        /// <code>GL_OBJECT_PLANE</code>, or
        /// <code>GL_EYE_PLANE</code>.
        /// </para>
        /// </param>
        /// <param name="ps">
        /// <para>
        /// Specifies a pointer to an array of texture generation parameters.
        /// If <paramref name="pname"/> is <code>GL_TEXTURE_GEN_MODE</code>,
        /// then the array must contain a single symbolic constant,
        /// one of
        /// <code>GL_OBJECT_LINEAR</code>,
        /// <code>GL_EYE_LINEAR</code>,
        /// <code>GL_SPHERE_MAP</code>,
        /// <code>GL_NORMAL_MAP</code>, or
        /// <code>GL_REFLECTION_MAP</code>.
        /// Otherwise,
        /// <paramref name="ps"/> holds the coefficients for the texture-coordinate generation function
        /// specified by <paramref name="pname"/>.
        /// </para>
        /// </param>
        /// <seealso cref="glActiveTexture"/>
        /// <seealso cref="glCopyPixels"/>
        /// <seealso cref="glCopyTexImage2D"/>
        /// <seealso cref="glCopyTexSubImage1D"/>
        /// <seealso cref="glCopyTexSubImage2D"/>
        /// <seealso cref="glCopyTexSubImage3D"/>
        /// <seealso cref="glTexEnv"/>
        /// <seealso cref="glTexImage1D"/>
        /// <seealso cref="glTexImage2D"/>
        /// <seealso cref="glTexImage3D"/>
        /// <seealso cref="glTexParameter"/>
        /// <seealso cref="glTexSubImage1D"/>
        /// <seealso cref="glTexSubImage2D"/>
        /// <seealso cref="glTexSubImage3D"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void glTexGendv(uint coord, uint pname, double* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglTexGendv>("glTexGendv");
            _F(coord, pname, ps);
        }
        /// <summary>
        /// control the generation of texture coordinates
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated when <paramref name="coord"/> or <paramref name="pname"/> is not an
        /// accepted defined value,
        /// or when <paramref name="pname"/> is <code>GL_TEXTURE_GEN_MODE</code> and <paramref name="ps"/> is not an
        /// accepted defined value.
        /// <code>GL_INVALID_ENUM</code> is generated when <paramref name="pname"/> is <code>GL_TEXTURE_GEN_MODE</code>,
        /// <paramref name="ps"/> is <code>GL_SPHERE_MAP</code>,
        /// and <paramref name="coord"/> is either <code>GL_R</code> or <code>GL_Q</code>.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glTexGen"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glTexGenf(GLenum coord, GLenum pname, GLfloat param);</para>
        /// </summary>
        /// <param name="coord">
        /// <para>
        /// Specifies a texture coordinate.
        /// Must be one of <code>GL_S</code>, <code>GL_T</code>, <code>GL_R</code>, or <code>GL_Q</code>.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of the texture-coordinate generation function.
        /// Must be <code>GL_TEXTURE_GEN_MODE</code>.
        /// </para>
        /// </param>
        /// <param name="param">
        /// <para>
        /// Specifies a single-valued texture generation parameter,
        /// one of <code>GL_OBJECT_LINEAR</code>, <code>GL_EYE_LINEAR</code>, <code>GL_SPHERE_MAP</code>,
        /// <code>GL_NORMAL_MAP</code>, or <code>GL_REFLECTION_MAP</code>.
        /// </para>
        /// </param>
        /// <seealso cref="glActiveTexture"/>
        /// <seealso cref="glCopyPixels"/>
        /// <seealso cref="glCopyTexImage2D"/>
        /// <seealso cref="glCopyTexSubImage1D"/>
        /// <seealso cref="glCopyTexSubImage2D"/>
        /// <seealso cref="glCopyTexSubImage3D"/>
        /// <seealso cref="glTexEnv"/>
        /// <seealso cref="glTexImage1D"/>
        /// <seealso cref="glTexImage2D"/>
        /// <seealso cref="glTexImage3D"/>
        /// <seealso cref="glTexParameter"/>
        /// <seealso cref="glTexSubImage1D"/>
        /// <seealso cref="glTexSubImage2D"/>
        /// <seealso cref="glTexSubImage3D"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void glTexGenf(uint coord, uint pname, float param) {
            var _F = _GetProc<GLNativeDelegate.FNglTexGenf>("glTexGenf");
            _F(coord, pname, param);
        }
        /// <summary>
        /// control the generation of texture coordinates
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated when <paramref name="coord"/> or <paramref name="pname"/> is not an
        /// accepted defined value,
        /// or when <paramref name="pname"/> is <code>GL_TEXTURE_GEN_MODE</code> and <paramref name="ps"/> is not an
        /// accepted defined value.
        /// <code>GL_INVALID_ENUM</code> is generated when <paramref name="pname"/> is <code>GL_TEXTURE_GEN_MODE</code>,
        /// <paramref name="ps"/> is <code>GL_SPHERE_MAP</code>,
        /// and <paramref name="coord"/> is either <code>GL_R</code> or <code>GL_Q</code>.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glTexGen"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glTexGenfv(GLenum coord, GLenum pname, const GLfloat * params);</para>
        /// </summary>
        /// <param name="coord">
        /// <para>
        /// Specifies a texture coordinate.
        /// Must be one of <code>GL_S</code>, <code>GL_T</code>, <code>GL_R</code>, or <code>GL_Q</code>.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of the texture-coordinate generation function
        /// or function parameters.
        /// Must be
        /// <code>GL_TEXTURE_GEN_MODE</code>,
        /// <code>GL_OBJECT_PLANE</code>, or
        /// <code>GL_EYE_PLANE</code>.
        /// </para>
        /// </param>
        /// <param name="ps">
        /// <para>
        /// Specifies a pointer to an array of texture generation parameters.
        /// If <paramref name="pname"/> is <code>GL_TEXTURE_GEN_MODE</code>,
        /// then the array must contain a single symbolic constant,
        /// one of
        /// <code>GL_OBJECT_LINEAR</code>,
        /// <code>GL_EYE_LINEAR</code>,
        /// <code>GL_SPHERE_MAP</code>,
        /// <code>GL_NORMAL_MAP</code>, or
        /// <code>GL_REFLECTION_MAP</code>.
        /// Otherwise,
        /// <paramref name="ps"/> holds the coefficients for the texture-coordinate generation function
        /// specified by <paramref name="pname"/>.
        /// </para>
        /// </param>
        /// <seealso cref="glActiveTexture"/>
        /// <seealso cref="glCopyPixels"/>
        /// <seealso cref="glCopyTexImage2D"/>
        /// <seealso cref="glCopyTexSubImage1D"/>
        /// <seealso cref="glCopyTexSubImage2D"/>
        /// <seealso cref="glCopyTexSubImage3D"/>
        /// <seealso cref="glTexEnv"/>
        /// <seealso cref="glTexImage1D"/>
        /// <seealso cref="glTexImage2D"/>
        /// <seealso cref="glTexImage3D"/>
        /// <seealso cref="glTexParameter"/>
        /// <seealso cref="glTexSubImage1D"/>
        /// <seealso cref="glTexSubImage2D"/>
        /// <seealso cref="glTexSubImage3D"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void glTexGenfv(uint coord, uint pname, float* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglTexGenfv>("glTexGenfv");
            _F(coord, pname, ps);
        }
        /// <summary>
        /// control the generation of texture coordinates
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated when <paramref name="coord"/> or <paramref name="pname"/> is not an
        /// accepted defined value,
        /// or when <paramref name="pname"/> is <code>GL_TEXTURE_GEN_MODE</code> and <paramref name="ps"/> is not an
        /// accepted defined value.
        /// <code>GL_INVALID_ENUM</code> is generated when <paramref name="pname"/> is <code>GL_TEXTURE_GEN_MODE</code>,
        /// <paramref name="ps"/> is <code>GL_SPHERE_MAP</code>,
        /// and <paramref name="coord"/> is either <code>GL_R</code> or <code>GL_Q</code>.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glTexGen"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glTexGeni(GLenum coord, GLenum pname, GLint param);</para>
        /// </summary>
        /// <param name="coord">
        /// <para>
        /// Specifies a texture coordinate.
        /// Must be one of <code>GL_S</code>, <code>GL_T</code>, <code>GL_R</code>, or <code>GL_Q</code>.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of the texture-coordinate generation function.
        /// Must be <code>GL_TEXTURE_GEN_MODE</code>.
        /// </para>
        /// </param>
        /// <param name="param">
        /// <para>
        /// Specifies a single-valued texture generation parameter,
        /// one of <code>GL_OBJECT_LINEAR</code>, <code>GL_EYE_LINEAR</code>, <code>GL_SPHERE_MAP</code>,
        /// <code>GL_NORMAL_MAP</code>, or <code>GL_REFLECTION_MAP</code>.
        /// </para>
        /// </param>
        /// <seealso cref="glActiveTexture"/>
        /// <seealso cref="glCopyPixels"/>
        /// <seealso cref="glCopyTexImage2D"/>
        /// <seealso cref="glCopyTexSubImage1D"/>
        /// <seealso cref="glCopyTexSubImage2D"/>
        /// <seealso cref="glCopyTexSubImage3D"/>
        /// <seealso cref="glTexEnv"/>
        /// <seealso cref="glTexImage1D"/>
        /// <seealso cref="glTexImage2D"/>
        /// <seealso cref="glTexImage3D"/>
        /// <seealso cref="glTexParameter"/>
        /// <seealso cref="glTexSubImage1D"/>
        /// <seealso cref="glTexSubImage2D"/>
        /// <seealso cref="glTexSubImage3D"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void glTexGeni(uint coord, uint pname, int param) {
            var _F = _GetProc<GLNativeDelegate.FNglTexGeni>("glTexGeni");
            _F(coord, pname, param);
        }
        /// <summary>
        /// control the generation of texture coordinates
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated when <paramref name="coord"/> or <paramref name="pname"/> is not an
        /// accepted defined value,
        /// or when <paramref name="pname"/> is <code>GL_TEXTURE_GEN_MODE</code> and <paramref name="ps"/> is not an
        /// accepted defined value.
        /// <code>GL_INVALID_ENUM</code> is generated when <paramref name="pname"/> is <code>GL_TEXTURE_GEN_MODE</code>,
        /// <paramref name="ps"/> is <code>GL_SPHERE_MAP</code>,
        /// and <paramref name="coord"/> is either <code>GL_R</code> or <code>GL_Q</code>.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glTexGen"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glTexGeniv(GLenum coord, GLenum pname, const GLint * params);</para>
        /// </summary>
        /// <param name="coord">
        /// <para>
        /// Specifies a texture coordinate.
        /// Must be one of <code>GL_S</code>, <code>GL_T</code>, <code>GL_R</code>, or <code>GL_Q</code>.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of the texture-coordinate generation function
        /// or function parameters.
        /// Must be
        /// <code>GL_TEXTURE_GEN_MODE</code>,
        /// <code>GL_OBJECT_PLANE</code>, or
        /// <code>GL_EYE_PLANE</code>.
        /// </para>
        /// </param>
        /// <param name="ps">
        /// <para>
        /// Specifies a pointer to an array of texture generation parameters.
        /// If <paramref name="pname"/> is <code>GL_TEXTURE_GEN_MODE</code>,
        /// then the array must contain a single symbolic constant,
        /// one of
        /// <code>GL_OBJECT_LINEAR</code>,
        /// <code>GL_EYE_LINEAR</code>,
        /// <code>GL_SPHERE_MAP</code>,
        /// <code>GL_NORMAL_MAP</code>, or
        /// <code>GL_REFLECTION_MAP</code>.
        /// Otherwise,
        /// <paramref name="ps"/> holds the coefficients for the texture-coordinate generation function
        /// specified by <paramref name="pname"/>.
        /// </para>
        /// </param>
        /// <seealso cref="glActiveTexture"/>
        /// <seealso cref="glCopyPixels"/>
        /// <seealso cref="glCopyTexImage2D"/>
        /// <seealso cref="glCopyTexSubImage1D"/>
        /// <seealso cref="glCopyTexSubImage2D"/>
        /// <seealso cref="glCopyTexSubImage3D"/>
        /// <seealso cref="glTexEnv"/>
        /// <seealso cref="glTexImage1D"/>
        /// <seealso cref="glTexImage2D"/>
        /// <seealso cref="glTexImage3D"/>
        /// <seealso cref="glTexParameter"/>
        /// <seealso cref="glTexSubImage1D"/>
        /// <seealso cref="glTexSubImage2D"/>
        /// <seealso cref="glTexSubImage3D"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void glTexGeniv(uint coord, uint pname, int* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglTexGeniv>("glTexGeniv");
            _F(coord, pname, ps);
        }
        /// <summary>
        /// controls feedback mode
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glFeedbackBuffer"/>, when used in a display list, is not compiled into the display list
        /// but is executed immediately.
        /// <see cref="glFeedbackBuffer"/> returns only the texture coordinate of texture unit <code>GL_TEXTURE0</code>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="type"/> is not an accepted value.
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="size"/> is negative.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glFeedbackBuffer"/> is called while the
        /// render mode is <code>GL_FEEDBACK</code>,
        /// or if  <see cref="glRenderMode"/>  is called with argument <code>GL_FEEDBACK</code> before
        /// <see cref="glFeedbackBuffer"/> is called at least once.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glFeedbackBuffer"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glFeedbackBuffer(GLsizei size, GLenum type, GLfloat * buffer);</para>
        /// </summary>
        /// <param name="size">
        /// Specifies the maximum number of values that can be written into <paramref name="buffer"/>.
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies a symbolic constant that describes the information
        /// that will be returned for each vertex.
        /// <code>GL_2D</code>,
        /// <code>GL_3D</code>,
        /// <code>GL_3D_COLOR</code>,
        /// <code>GL_3D_COLOR_TEXTURE</code>, and
        /// <code>GL_4D_COLOR_TEXTURE</code> are accepted.
        /// </para>
        /// </param>
        /// <param name="buffer">
        /// Returns the feedback data.
        /// </param>
        /// <seealso cref="glBegin"/>
        /// <seealso cref="glLineStipple"/>
        /// <seealso cref="glPassThrough"/>
        /// <seealso cref="glPolygonMode"/>
        /// <seealso cref="glRenderMode"/>
        /// <seealso cref="glSelectBuffer"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void glFeedbackBuffer(int size, uint type, float* buffer) {
            var _F = _GetProc<GLNativeDelegate.FNglFeedbackBuffer>("glFeedbackBuffer");
            _F(size, type, buffer);
        }
        /// <summary>
        /// establish a buffer for selection mode values
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// The contents of <paramref name="buffer"/> is undefined until  <see cref="glRenderMode"/>  is called
        /// with an argument other than <code>GL_SELECT</code>.
        /// <see cref="glBegin"/> / <see cref="glEnd"/>  primitives and calls to  <see cref="glRasterPos"/> 
        /// can result in hits.   <see cref="glWindowPos"/>  will always generate a selection hit.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="size"/> is negative.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glSelectBuffer"/> is called while the
        /// render mode is <code>GL_SELECT</code>,
        /// or if  <see cref="glRenderMode"/>  is called with argument <code>GL_SELECT</code> before
        /// <see cref="glSelectBuffer"/> is called at least once.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glSelectBuffer"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glSelectBuffer(GLsizei size, GLuint * buffer);</para>
        /// </summary>
        /// <param name="size">
        /// Specifies the size of <paramref name="buffer"/>.
        /// </param>
        /// <param name="buffer">
        /// Returns the selection data.
        /// </param>
        /// <seealso cref="glFeedbackBuffer"/>
        /// <seealso cref="glInitNames"/>
        /// <seealso cref="glLoadName"/>
        /// <seealso cref="glPushName"/>
        /// <seealso cref="glRenderMode"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void glSelectBuffer(int size, uint* buffer) {
            var _F = _GetProc<GLNativeDelegate.FNglSelectBuffer>("glSelectBuffer");
            _F(size, buffer);
        }
        /// <summary>
        /// set rasterization mode
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// If an error is generated,
        /// <see cref="glRenderMode"/> returns 0 regardless of the current render mode.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="mode"/> is not one of the three
        /// accepted values.
        /// <code>GL_INVALID_OPERATION</code> is generated if  <see cref="glSelectBuffer"/>  is called
        /// while the render mode is <code>GL_SELECT</code>,
        /// or if <see cref="glRenderMode"/> is called with argument <code>GL_SELECT</code> before
        /// <see cref="glSelectBuffer"/>  is called at least once.
        /// <code>GL_INVALID_OPERATION</code> is generated if  <see cref="glFeedbackBuffer"/>  is called
        /// while the render mode is <code>GL_FEEDBACK</code>,
        /// or if <see cref="glRenderMode"/> is called with argument <code>GL_FEEDBACK</code> before
        /// <see cref="glFeedbackBuffer"/>  is called at least once.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glRenderMode"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>GLint glRenderMode(GLenum mode);</para>
        /// </summary>
        /// <param name="mode">
        /// <para>
        /// Specifies the rasterization mode.
        /// Three values are accepted:
        /// <code>GL_RENDER</code>,
        /// <code>GL_SELECT</code>, and
        /// <code>GL_FEEDBACK</code>.
        /// The initial value is <code>GL_RENDER</code>.
        /// </para>
        /// </param>
        /// <seealso cref="glFeedbackBuffer"/>
        /// <seealso cref="glInitNames"/>
        /// <seealso cref="glLoadName"/>
        /// <seealso cref="glPassThrough"/>
        /// <seealso cref="glPushName"/>
        /// <seealso cref="glSelectBuffer"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static int glRenderMode(uint mode) {
            var _F = _GetProc<GLNativeDelegate.FNglRenderMode>("glRenderMode");
            return _F(mode);
        }
        /// <summary>
        /// initialize the name stack
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glInitNames"/>
        /// is executed between the execution of  <see cref="glBegin"/>  and the corresponding execution of
        /// <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glInitNames();</para>
        /// </summary>
        /// <seealso cref="glLoadName"/>
        /// <seealso cref="glPushName"/>
        /// <seealso cref="glRenderMode"/>
        /// <seealso cref="glSelectBuffer"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void glInitNames() {
            var _F = _GetProc<GLNativeDelegate.FNglInitNames>("glInitNames");
            _F();
        }
        /// <summary>
        /// load a name onto the name stack
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glLoadName"/> is called while the
        /// name stack is empty.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glLoadName"/> is executed between
        /// the execution of  <see cref="glBegin"/>  and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glLoadName(GLuint name);</para>
        /// </summary>
        /// <param name="name">
        /// Specifies a name that will replace the top value on the name stack.
        /// </param>
        /// <seealso cref="glInitNames"/>
        /// <seealso cref="glPushName"/>
        /// <seealso cref="glRenderMode"/>
        /// <seealso cref="glSelectBuffer"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void glLoadName(uint name) {
            var _F = _GetProc<GLNativeDelegate.FNglLoadName>("glLoadName");
            _F(name);
        }
        /// <summary>
        /// place a marker in the feedback buffer
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <see cref="glPassThrough"/> is ignored if the GL is not in feedback mode.
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glPassThrough"/> is executed between
        /// the execution of  <see cref="glBegin"/>  and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glPassThrough(GLfloat token);</para>
        /// </summary>
        /// <param name="token">
        /// <para>
        /// Specifies a marker value to be placed in the feedback buffer
        /// following a <code>GL_PASS_THROUGH_TOKEN</code>.
        /// </para>
        /// </param>
        /// <seealso cref="glFeedbackBuffer"/>
        /// <seealso cref="glRenderMode"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void glPassThrough(float token) {
            var _F = _GetProc<GLNativeDelegate.FNglPassThrough>("glPassThrough");
            _F(token);
        }
        /// <summary>
        /// push and pop the name stack
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Errors: 
        /// <para>
        /// <code>GL_STACK_OVERFLOW</code> is generated if <see cref="glPushName"/> is called while the
        /// name stack is full.
        /// <code>GL_STACK_UNDERFLOW</code> is generated if  <see cref="glPopName"/>  is called while the
        /// name stack is empty.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glPushName"/> or  <see cref="glPopName"/> 
        /// is executed between a call to  <see cref="glBegin"/>  and the corresponding call to
        /// <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glPopName();</para>
        /// </summary>
        /// <seealso cref="glInitNames"/>
        /// <seealso cref="glLoadName"/>
        /// <seealso cref="glRenderMode"/>
        /// <seealso cref="glSelectBuffer"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void glPopName() {
            var _F = _GetProc<GLNativeDelegate.FNglPopName>("glPopName");
            _F();
        }
        /// <summary>
        /// push and pop the name stack
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Errors: 
        /// <para>
        /// <code>GL_STACK_OVERFLOW</code> is generated if <see cref="glPushName"/> is called while the
        /// name stack is full.
        /// <code>GL_STACK_UNDERFLOW</code> is generated if  <see cref="glPopName"/>  is called while the
        /// name stack is empty.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glPushName"/> or  <see cref="glPopName"/> 
        /// is executed between a call to  <see cref="glBegin"/>  and the corresponding call to
        /// <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glPushName(GLuint name);</para>
        /// </summary>
        /// <param name="name">
        /// Specifies a name that will be pushed onto the name stack.
        /// </param>
        /// <seealso cref="glInitNames"/>
        /// <seealso cref="glLoadName"/>
        /// <seealso cref="glRenderMode"/>
        /// <seealso cref="glSelectBuffer"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void glPushName(uint name) {
            var _F = _GetProc<GLNativeDelegate.FNglPushName>("glPushName");
            _F(name);
        }
        /// <summary>
        /// specify clear values for the accumulation buffer
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glClearAccum"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glClearAccum(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha);</para>
        /// </summary>
        /// <param name="red">
        /// <para>
        /// Specify the red, green, blue, and alpha values used when the
        /// accumulation buffer is cleared.
        /// The initial values are all 0.
        /// </para>
        /// </param>
        /// <param name="green">
        /// <para>
        /// Specify the red, green, blue, and alpha values used when the
        /// accumulation buffer is cleared.
        /// The initial values are all 0.
        /// </para>
        /// </param>
        /// <param name="blue">
        /// <para>
        /// Specify the red, green, blue, and alpha values used when the
        /// accumulation buffer is cleared.
        /// The initial values are all 0.
        /// </para>
        /// </param>
        /// <param name="alpha">
        /// <para>
        /// Specify the red, green, blue, and alpha values used when the
        /// accumulation buffer is cleared.
        /// The initial values are all 0.
        /// </para>
        /// </param>
        /// <seealso cref="glAccum"/>
        /// <seealso cref="glClear"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void glClearAccum(float red, float green, float blue, float alpha) {
            var _F = _GetProc<GLNativeDelegate.FNglClearAccum>("glClearAccum");
            _F(red, green, blue, alpha);
        }
        /// <summary>
        /// specify the clear value for the color index buffers
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glClearIndex"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glClearIndex(GLfloat c);</para>
        /// </summary>
        /// <param name="c">
        /// <para>
        /// Specifies the index used when the color index buffers are cleared.
        /// The initial value is 0.
        /// </para>
        /// </param>
        /// <seealso cref="glClear"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void glClearIndex(float c) {
            var _F = _GetProc<GLNativeDelegate.FNglClearIndex>("glClearIndex");
            _F(c);
        }
        /// <summary>
        /// control the writing of individual bits in the color index buffers
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glIndexMask"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glIndexMask(GLuint mask);</para>
        /// </summary>
        /// <param name="mask">
        /// <para>
        /// Specifies a bit mask to enable and disable the writing of individual bits
        /// in the color index buffers.
        /// Initially, the mask is all 1's.
        /// </para>
        /// </param>
        /// <seealso cref="glColorMask"/>
        /// <seealso cref="glDepthMask"/>
        /// <seealso cref="glDrawBuffer"/>
        /// <seealso cref="glIndex"/>
        /// <seealso cref="glIndexPointer"/>
        /// <seealso cref="glStencilMask"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void glIndexMask(uint mask) {
            var _F = _GetProc<GLNativeDelegate.FNglIndexMask>("glIndexMask");
            _F(mask);
        }
        /// <summary>
        /// operate on the accumulation buffer
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// Only pixels within the current scissor box are updated by a
        /// <see cref="glAccum"/> operation.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="op"/> is not an accepted value.
        /// <code>GL_INVALID_OPERATION</code> is generated if there is no accumulation buffer.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glAccum"/>
        /// is executed between the execution of
        /// <see cref="glBegin"/>  and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glAccum(GLenum op, GLfloat value);</para>
        /// </summary>
        /// <param name="op">
        /// <para>
        /// Specifies the accumulation buffer operation.
        /// Symbolic constants
        /// <code>GL_ACCUM</code>,
        /// <code>GL_LOAD</code>,
        /// <code>GL_ADD</code>,
        /// <code>GL_MULT</code>,
        /// and
        /// <code>GL_RETURN</code> are accepted.
        /// </para>
        /// </param>
        /// <param name="value">
        /// <para>
        /// Specifies a floating-point value used in the accumulation buffer operation.
        /// <paramref name="op"/> determines how <paramref name="value"/> is used.
        /// </para>
        /// </param>
        /// <seealso cref="glClear"/>
        /// <seealso cref="glClearAccum"/>
        /// <seealso cref="glCopyPixels"/>
        /// <seealso cref="glDrawBuffer"/>
        /// <seealso cref="glGet"/>
        /// <seealso cref="glReadBuffer"/>
        /// <seealso cref="glReadPixels"/>
        /// <seealso cref="glScissor"/>
        /// <seealso cref="glStencilOp"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void glAccum(uint op, float value) {
            var _F = _GetProc<GLNativeDelegate.FNglAccum>("glAccum");
            _F(op, value);
        }
        /// <summary>
        /// push and pop the server attribute stack
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// Not all values for GL state can be saved on the attribute stack.
        /// For example,
        /// render mode state,
        /// and select and feedback state cannot be saved.
        /// Client state must be saved with
        /// <see cref="glPushClientAttrib"/> .
        /// The depth of the attribute stack depends on the implementation,
        /// but it must be at least 16.
        /// For OpenGL versions 1.3 and greater, or when the <code>ARB_multitexture</code> extension is supported, pushing and
        /// popping texture state applies to all supported texture units.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_STACK_OVERFLOW</code> is generated if <see cref="glPushAttrib"/> is called while
        /// the attribute stack is full.
        /// <code>GL_STACK_UNDERFLOW</code> is generated if  <see cref="glPopAttrib"/>  is called while
        /// the attribute stack is empty.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glPushAttrib"/> or  <see cref="glPopAttrib"/> 
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glPopAttrib();</para>
        /// </summary>
        /// <seealso cref="glGet"/>
        /// <seealso cref="glGetClipPlane"/>
        /// <seealso cref="glGetError"/>
        /// <seealso cref="glGetLight"/>
        /// <seealso cref="glGetMap"/>
        /// <seealso cref="glGetMaterial"/>
        /// <seealso cref="glGetPixelMap"/>
        /// <seealso cref="glGetPolygonStipple"/>
        /// <seealso cref="glGetString"/>
        /// <seealso cref="glGetTexEnv"/>
        /// <seealso cref="glGetTexGen"/>
        /// <seealso cref="glGetTexImage"/>
        /// <seealso cref="glGetTexLevelParameter"/>
        /// <seealso cref="glGetTexParameter"/>
        /// <seealso cref="glIsEnabled"/>
        /// <seealso cref="glPushClientAttrib"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void glPopAttrib() {
            var _F = _GetProc<GLNativeDelegate.FNglPopAttrib>("glPopAttrib");
            _F();
        }
        /// <summary>
        /// push and pop the server attribute stack
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// Not all values for GL state can be saved on the attribute stack.
        /// For example,
        /// render mode state,
        /// and select and feedback state cannot be saved.
        /// Client state must be saved with
        /// <see cref="glPushClientAttrib"/> .
        /// The depth of the attribute stack depends on the implementation,
        /// but it must be at least 16.
        /// For OpenGL versions 1.3 and greater, or when the <code>ARB_multitexture</code> extension is supported, pushing and
        /// popping texture state applies to all supported texture units.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_STACK_OVERFLOW</code> is generated if <see cref="glPushAttrib"/> is called while
        /// the attribute stack is full.
        /// <code>GL_STACK_UNDERFLOW</code> is generated if  <see cref="glPopAttrib"/>  is called while
        /// the attribute stack is empty.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glPushAttrib"/> or  <see cref="glPopAttrib"/> 
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glPushAttrib(GLbitfield mask);</para>
        /// </summary>
        /// <param name="mask">
        /// <para>
        /// Specifies a mask that indicates which attributes to save. Values for
        /// <paramref name="mask"/> are listed below.
        /// </para>
        /// </param>
        /// <seealso cref="glGet"/>
        /// <seealso cref="glGetClipPlane"/>
        /// <seealso cref="glGetError"/>
        /// <seealso cref="glGetLight"/>
        /// <seealso cref="glGetMap"/>
        /// <seealso cref="glGetMaterial"/>
        /// <seealso cref="glGetPixelMap"/>
        /// <seealso cref="glGetPolygonStipple"/>
        /// <seealso cref="glGetString"/>
        /// <seealso cref="glGetTexEnv"/>
        /// <seealso cref="glGetTexGen"/>
        /// <seealso cref="glGetTexImage"/>
        /// <seealso cref="glGetTexLevelParameter"/>
        /// <seealso cref="glGetTexParameter"/>
        /// <seealso cref="glIsEnabled"/>
        /// <seealso cref="glPushClientAttrib"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void glPushAttrib(uint mask) {
            var _F = _GetProc<GLNativeDelegate.FNglPushAttrib>("glPushAttrib");
            _F(mask);
        }
        /// <summary>
        /// define a one-dimensional evaluator
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// As is the case with all GL commands that accept pointers to data,
        /// it is as if the contents of <paramref name="points"/> were copied by <see cref="glMap1"/> before <see cref="glMap1"/>
        /// returns.
        /// Changes to the contents of <paramref name="points"/> have no effect after <see cref="glMap1"/> is called.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="target"/> is not an accepted value.
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="u1"/> is equal to <paramref name="u2"/>.
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="stride"/> is less than the number
        /// of values in a control point.
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="order"/> is less than 1 or
        /// greater than the return value of <code>GL_MAX_EVAL_ORDER</code>.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glMap1"/>
        /// is executed between the execution of
        /// <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glMap1"/> is called and the value
        /// of <code>GL_ACTIVE_TEXTURE</code> is not <code>GL_TEXTURE0</code>.
        /// </para>
        /// Original: <para>void glMap1d(GLenum target, GLdouble u1, GLdouble u2, GLint stride, GLint order, const GLdouble * points);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the kind of values that are generated by the evaluator.
        /// Symbolic constants
        /// <code>GL_MAP1_VERTEX_3</code>,
        /// <code>GL_MAP1_VERTEX_4</code>,
        /// <code>GL_MAP1_INDEX</code>,
        /// <code>GL_MAP1_COLOR_4</code>,
        /// <code>GL_MAP1_NORMAL</code>,
        /// <code>GL_MAP1_TEXTURE_COORD_1</code>,
        /// <code>GL_MAP1_TEXTURE_COORD_2</code>,
        /// <code>GL_MAP1_TEXTURE_COORD_3</code>, and
        /// <code>GL_MAP1_TEXTURE_COORD_4</code> are accepted.
        /// </para>
        /// </param>
        /// <param name="u1">
        /// <para>
        /// Specify a linear mapping of 
        /// u   ,
        /// as presented to  <see cref="glEvalCoord1"/> ,
        /// to 
        /// u  &Hat;  
        /// ,
        /// the variable that is evaluated by the equations specified by this command.
        /// </para>
        /// </param>
        /// <param name="u2">
        /// <para>
        /// Specify a linear mapping of 
        /// u   ,
        /// as presented to  <see cref="glEvalCoord1"/> ,
        /// to 
        /// u  &Hat;  
        /// ,
        /// the variable that is evaluated by the equations specified by this command.
        /// </para>
        /// </param>
        /// <param name="stride">
        /// <para>
        /// Specifies the number of floats or doubles between
        /// the beginning of one control point and the beginning of the next one
        /// in the data structure referenced in <paramref name="points"/>.
        /// This allows control points to be embedded in arbitrary data structures.
        /// The only constraint is that the values for a particular control point
        /// must occupy contiguous memory locations.
        /// </para>
        /// </param>
        /// <param name="order">
        /// <para>
        /// Specifies the number of control points.
        /// Must be positive.
        /// </para>
        /// </param>
        /// <param name="points">
        /// Specifies a pointer to the array of control points.
        /// </param>
        /// <seealso cref="glBegin"/>
        /// <seealso cref="glColor"/>
        /// <seealso cref="glEnable"/>
        /// <seealso cref="glEvalCoord"/>
        /// <seealso cref="glEvalMesh"/>
        /// <seealso cref="glEvalPoint"/>
        /// <seealso cref="glMap2"/>
        /// <seealso cref="glMapGrid"/>
        /// <seealso cref="glNormal"/>
        /// <seealso cref="glTexCoord"/>
        /// <seealso cref="glVertex"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void glMap1d(uint target, double u1, double u2, int stride, int order, double* points) {
            var _F = _GetProc<GLNativeDelegate.FNglMap1d>("glMap1d");
            _F(target, u1, u2, stride, order, points);
        }
        /// <summary>
        /// define a one-dimensional evaluator
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// As is the case with all GL commands that accept pointers to data,
        /// it is as if the contents of <paramref name="points"/> were copied by <see cref="glMap1"/> before <see cref="glMap1"/>
        /// returns.
        /// Changes to the contents of <paramref name="points"/> have no effect after <see cref="glMap1"/> is called.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="target"/> is not an accepted value.
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="u1"/> is equal to <paramref name="u2"/>.
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="stride"/> is less than the number
        /// of values in a control point.
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="order"/> is less than 1 or
        /// greater than the return value of <code>GL_MAX_EVAL_ORDER</code>.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glMap1"/>
        /// is executed between the execution of
        /// <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glMap1"/> is called and the value
        /// of <code>GL_ACTIVE_TEXTURE</code> is not <code>GL_TEXTURE0</code>.
        /// </para>
        /// Original: <para>void glMap1f(GLenum target, GLfloat u1, GLfloat u2, GLint stride, GLint order, const GLfloat * points);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the kind of values that are generated by the evaluator.
        /// Symbolic constants
        /// <code>GL_MAP1_VERTEX_3</code>,
        /// <code>GL_MAP1_VERTEX_4</code>,
        /// <code>GL_MAP1_INDEX</code>,
        /// <code>GL_MAP1_COLOR_4</code>,
        /// <code>GL_MAP1_NORMAL</code>,
        /// <code>GL_MAP1_TEXTURE_COORD_1</code>,
        /// <code>GL_MAP1_TEXTURE_COORD_2</code>,
        /// <code>GL_MAP1_TEXTURE_COORD_3</code>, and
        /// <code>GL_MAP1_TEXTURE_COORD_4</code> are accepted.
        /// </para>
        /// </param>
        /// <param name="u1">
        /// <para>
        /// Specify a linear mapping of 
        /// u   ,
        /// as presented to  <see cref="glEvalCoord1"/> ,
        /// to 
        /// u  &Hat;  
        /// ,
        /// the variable that is evaluated by the equations specified by this command.
        /// </para>
        /// </param>
        /// <param name="u2">
        /// <para>
        /// Specify a linear mapping of 
        /// u   ,
        /// as presented to  <see cref="glEvalCoord1"/> ,
        /// to 
        /// u  &Hat;  
        /// ,
        /// the variable that is evaluated by the equations specified by this command.
        /// </para>
        /// </param>
        /// <param name="stride">
        /// <para>
        /// Specifies the number of floats or doubles between
        /// the beginning of one control point and the beginning of the next one
        /// in the data structure referenced in <paramref name="points"/>.
        /// This allows control points to be embedded in arbitrary data structures.
        /// The only constraint is that the values for a particular control point
        /// must occupy contiguous memory locations.
        /// </para>
        /// </param>
        /// <param name="order">
        /// <para>
        /// Specifies the number of control points.
        /// Must be positive.
        /// </para>
        /// </param>
        /// <param name="points">
        /// Specifies a pointer to the array of control points.
        /// </param>
        /// <seealso cref="glBegin"/>
        /// <seealso cref="glColor"/>
        /// <seealso cref="glEnable"/>
        /// <seealso cref="glEvalCoord"/>
        /// <seealso cref="glEvalMesh"/>
        /// <seealso cref="glEvalPoint"/>
        /// <seealso cref="glMap2"/>
        /// <seealso cref="glMapGrid"/>
        /// <seealso cref="glNormal"/>
        /// <seealso cref="glTexCoord"/>
        /// <seealso cref="glVertex"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void glMap1f(uint target, float u1, float u2, int stride, int order, float* points) {
            var _F = _GetProc<GLNativeDelegate.FNglMap1f>("glMap1f");
            _F(target, u1, u2, stride, order, points);
        }
        /// <summary>
        /// define a two-dimensional evaluator
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// As is the case with all GL commands that accept pointers to data,
        /// it is as if the contents of <paramref name="points"/> were copied by <see cref="glMap2"/> before <see cref="glMap2"/>
        /// returns.
        /// Changes to the contents of <paramref name="points"/> have no effect after <see cref="glMap2"/> is called.
        /// Initially, <code>GL_AUTO_NORMAL</code> is enabled. If <code>GL_AUTO_NORMAL</code> is enabled,
        /// normal vectors are generated when either
        /// <code>GL_MAP2_VERTEX_3</code> or <code>GL_MAP2_VERTEX_4</code> is used to generate
        /// vertices.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="target"/> is not an accepted value.
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="u1"/> is equal to <paramref name="u2"/>,
        /// or if <paramref name="v1"/> is equal to <paramref name="v2"/>.
        /// <code>GL_INVALID_VALUE</code> is generated if either <paramref name="ustride"/> or <paramref name="vstride"/>
        /// is less than the number of values in a control point.
        /// <code>GL_INVALID_VALUE</code> is generated if either <paramref name="uorder"/> or <paramref name="vorder"/>
        /// is less than 1 or greater than the return value of <code>GL_MAX_EVAL_ORDER</code>.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glMap2"/>
        /// is executed between the execution of
        /// <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glMap2"/> is called and the value
        /// of <code>GL_ACTIVE_TEXTURE</code> is not <code>GL_TEXTURE0</code>.
        /// </para>
        /// Original: <para>void glMap2d(GLenum target, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, const GLdouble * points);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the kind of values that are generated by the evaluator.
        /// Symbolic constants
        /// <code>GL_MAP2_VERTEX_3</code>,
        /// <code>GL_MAP2_VERTEX_4</code>,
        /// <code>GL_MAP2_INDEX</code>,
        /// <code>GL_MAP2_COLOR_4</code>,
        /// <code>GL_MAP2_NORMAL</code>,
        /// <code>GL_MAP2_TEXTURE_COORD_1</code>,
        /// <code>GL_MAP2_TEXTURE_COORD_2</code>,
        /// <code>GL_MAP2_TEXTURE_COORD_3</code>, and
        /// <code>GL_MAP2_TEXTURE_COORD_4</code> are accepted.
        /// </para>
        /// </param>
        /// <param name="u1">
        /// <para>
        /// Specify a linear mapping of 
        /// u   ,
        /// as presented to  <see cref="glEvalCoord2"/> ,
        /// to 
        /// u  &Hat;  
        /// ,
        /// one of the two variables that are evaluated by the equations specified
        /// by this command. Initially, <paramref name="u1"/> is 0 and <paramref name="u2"/> is 1.
        /// </para>
        /// </param>
        /// <param name="u2">
        /// <para>
        /// Specify a linear mapping of 
        /// u   ,
        /// as presented to  <see cref="glEvalCoord2"/> ,
        /// to 
        /// u  &Hat;  
        /// ,
        /// one of the two variables that are evaluated by the equations specified
        /// by this command. Initially, <paramref name="u1"/> is 0 and <paramref name="u2"/> is 1.
        /// </para>
        /// </param>
        /// <param name="ustride">
        /// <para>
        /// Specifies the number of floats or doubles between
        /// the beginning of control point
        /// R 
        /// ij 
        /// and the beginning of control point
        /// R 
        /// i 
        /// + 
        /// 1 
        /// &it; 
        /// j 
        /// ,
        /// where 
        /// i   
        /// and 
        /// j   
        /// are the 
        /// u   
        /// and 
        /// v   
        /// control point indices, respectively.
        /// This allows control points to be embedded in arbitrary data structures.
        /// The only constraint is that the values for a particular control point
        /// must occupy contiguous memory locations. The initial value of <paramref name="ustride"/> is 0.
        /// </para>
        /// </param>
        /// <param name="uorder">
        /// <para>
        /// Specifies the dimension of the control point array in the 
        /// u   
        /// axis.
        /// Must be positive. The initial value is 1.
        /// </para>
        /// </param>
        /// <param name="v1">
        /// <para>
        /// Specify a linear mapping of 
        /// v   ,
        /// as presented to  <see cref="glEvalCoord2"/> ,
        /// to 
        /// v  &Hat;  
        /// ,
        /// one of the two variables that are evaluated by the equations specified
        /// by this command. Initially, <paramref name="v1"/> is 0 and <paramref name="v2"/> is 1.
        /// </para>
        /// </param>
        /// <param name="v2">
        /// <para>
        /// Specify a linear mapping of 
        /// v   ,
        /// as presented to  <see cref="glEvalCoord2"/> ,
        /// to 
        /// v  &Hat;  
        /// ,
        /// one of the two variables that are evaluated by the equations specified
        /// by this command. Initially, <paramref name="v1"/> is 0 and <paramref name="v2"/> is 1.
        /// </para>
        /// </param>
        /// <param name="vstride">
        /// <para>
        /// Specifies the number of floats or doubles between
        /// the beginning of control point
        /// R 
        /// ij 
        /// and the beginning of control point
        /// R 
        /// i 
        /// &af; 
        /// j 
        /// + 
        /// 1 
        /// ,
        /// where 
        /// i   
        /// and 
        /// j   
        /// are the 
        /// u   
        /// and 
        /// v   
        /// control point indices, respectively.
        /// This allows control points to be embedded in arbitrary data structures.
        /// The only constraint is that the values for a particular control point
        /// must occupy contiguous memory locations. The initial value of <paramref name="vstride"/> is 0.
        /// </para>
        /// </param>
        /// <param name="vorder">
        /// <para>
        /// Specifies the dimension of the control point array in the 
        /// v   
        /// axis.
        /// Must be positive. The initial value is 1.
        /// </para>
        /// </param>
        /// <param name="points">
        /// Specifies a pointer to the array of control points.
        /// </param>
        /// <seealso cref="glBegin"/>
        /// <seealso cref="glColor"/>
        /// <seealso cref="glEnable"/>
        /// <seealso cref="glEvalCoord"/>
        /// <seealso cref="glEvalMesh"/>
        /// <seealso cref="glEvalPoint"/>
        /// <seealso cref="glMap1"/>
        /// <seealso cref="glMapGrid"/>
        /// <seealso cref="glNormal"/>
        /// <seealso cref="glTexCoord"/>
        /// <seealso cref="glVertex"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void glMap2d(uint target, double u1, double u2, int ustride, int uorder, double v1, double v2, int vstride, int vorder, double* points) {
            var _F = _GetProc<GLNativeDelegate.FNglMap2d>("glMap2d");
            _F(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
        }
        /// <summary>
        /// define a two-dimensional evaluator
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// As is the case with all GL commands that accept pointers to data,
        /// it is as if the contents of <paramref name="points"/> were copied by <see cref="glMap2"/> before <see cref="glMap2"/>
        /// returns.
        /// Changes to the contents of <paramref name="points"/> have no effect after <see cref="glMap2"/> is called.
        /// Initially, <code>GL_AUTO_NORMAL</code> is enabled. If <code>GL_AUTO_NORMAL</code> is enabled,
        /// normal vectors are generated when either
        /// <code>GL_MAP2_VERTEX_3</code> or <code>GL_MAP2_VERTEX_4</code> is used to generate
        /// vertices.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="target"/> is not an accepted value.
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="u1"/> is equal to <paramref name="u2"/>,
        /// or if <paramref name="v1"/> is equal to <paramref name="v2"/>.
        /// <code>GL_INVALID_VALUE</code> is generated if either <paramref name="ustride"/> or <paramref name="vstride"/>
        /// is less than the number of values in a control point.
        /// <code>GL_INVALID_VALUE</code> is generated if either <paramref name="uorder"/> or <paramref name="vorder"/>
        /// is less than 1 or greater than the return value of <code>GL_MAX_EVAL_ORDER</code>.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glMap2"/>
        /// is executed between the execution of
        /// <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glMap2"/> is called and the value
        /// of <code>GL_ACTIVE_TEXTURE</code> is not <code>GL_TEXTURE0</code>.
        /// </para>
        /// Original: <para>void glMap2f(GLenum target, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, const GLfloat * points);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the kind of values that are generated by the evaluator.
        /// Symbolic constants
        /// <code>GL_MAP2_VERTEX_3</code>,
        /// <code>GL_MAP2_VERTEX_4</code>,
        /// <code>GL_MAP2_INDEX</code>,
        /// <code>GL_MAP2_COLOR_4</code>,
        /// <code>GL_MAP2_NORMAL</code>,
        /// <code>GL_MAP2_TEXTURE_COORD_1</code>,
        /// <code>GL_MAP2_TEXTURE_COORD_2</code>,
        /// <code>GL_MAP2_TEXTURE_COORD_3</code>, and
        /// <code>GL_MAP2_TEXTURE_COORD_4</code> are accepted.
        /// </para>
        /// </param>
        /// <param name="u1">
        /// <para>
        /// Specify a linear mapping of 
        /// u   ,
        /// as presented to  <see cref="glEvalCoord2"/> ,
        /// to 
        /// u  &Hat;  
        /// ,
        /// one of the two variables that are evaluated by the equations specified
        /// by this command. Initially, <paramref name="u1"/> is 0 and <paramref name="u2"/> is 1.
        /// </para>
        /// </param>
        /// <param name="u2">
        /// <para>
        /// Specify a linear mapping of 
        /// u   ,
        /// as presented to  <see cref="glEvalCoord2"/> ,
        /// to 
        /// u  &Hat;  
        /// ,
        /// one of the two variables that are evaluated by the equations specified
        /// by this command. Initially, <paramref name="u1"/> is 0 and <paramref name="u2"/> is 1.
        /// </para>
        /// </param>
        /// <param name="ustride">
        /// <para>
        /// Specifies the number of floats or doubles between
        /// the beginning of control point
        /// R 
        /// ij 
        /// and the beginning of control point
        /// R 
        /// i 
        /// + 
        /// 1 
        /// &it; 
        /// j 
        /// ,
        /// where 
        /// i   
        /// and 
        /// j   
        /// are the 
        /// u   
        /// and 
        /// v   
        /// control point indices, respectively.
        /// This allows control points to be embedded in arbitrary data structures.
        /// The only constraint is that the values for a particular control point
        /// must occupy contiguous memory locations. The initial value of <paramref name="ustride"/> is 0.
        /// </para>
        /// </param>
        /// <param name="uorder">
        /// <para>
        /// Specifies the dimension of the control point array in the 
        /// u   
        /// axis.
        /// Must be positive. The initial value is 1.
        /// </para>
        /// </param>
        /// <param name="v1">
        /// <para>
        /// Specify a linear mapping of 
        /// v   ,
        /// as presented to  <see cref="glEvalCoord2"/> ,
        /// to 
        /// v  &Hat;  
        /// ,
        /// one of the two variables that are evaluated by the equations specified
        /// by this command. Initially, <paramref name="v1"/> is 0 and <paramref name="v2"/> is 1.
        /// </para>
        /// </param>
        /// <param name="v2">
        /// <para>
        /// Specify a linear mapping of 
        /// v   ,
        /// as presented to  <see cref="glEvalCoord2"/> ,
        /// to 
        /// v  &Hat;  
        /// ,
        /// one of the two variables that are evaluated by the equations specified
        /// by this command. Initially, <paramref name="v1"/> is 0 and <paramref name="v2"/> is 1.
        /// </para>
        /// </param>
        /// <param name="vstride">
        /// <para>
        /// Specifies the number of floats or doubles between
        /// the beginning of control point
        /// R 
        /// ij 
        /// and the beginning of control point
        /// R 
        /// i 
        /// &af; 
        /// j 
        /// + 
        /// 1 
        /// ,
        /// where 
        /// i   
        /// and 
        /// j   
        /// are the 
        /// u   
        /// and 
        /// v   
        /// control point indices, respectively.
        /// This allows control points to be embedded in arbitrary data structures.
        /// The only constraint is that the values for a particular control point
        /// must occupy contiguous memory locations. The initial value of <paramref name="vstride"/> is 0.
        /// </para>
        /// </param>
        /// <param name="vorder">
        /// <para>
        /// Specifies the dimension of the control point array in the 
        /// v   
        /// axis.
        /// Must be positive. The initial value is 1.
        /// </para>
        /// </param>
        /// <param name="points">
        /// Specifies a pointer to the array of control points.
        /// </param>
        /// <seealso cref="glBegin"/>
        /// <seealso cref="glColor"/>
        /// <seealso cref="glEnable"/>
        /// <seealso cref="glEvalCoord"/>
        /// <seealso cref="glEvalMesh"/>
        /// <seealso cref="glEvalPoint"/>
        /// <seealso cref="glMap1"/>
        /// <seealso cref="glMapGrid"/>
        /// <seealso cref="glNormal"/>
        /// <seealso cref="glTexCoord"/>
        /// <seealso cref="glVertex"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void glMap2f(uint target, float u1, float u2, int ustride, int uorder, float v1, float v2, int vstride, int vorder, float* points) {
            var _F = _GetProc<GLNativeDelegate.FNglMap2f>("glMap2f");
            _F(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
        }
        /// <summary>
        /// define a one- or two-dimensional mesh
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if either <paramref name="un"/> or <paramref name="vn"/> is not
        /// positive.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glMapGrid"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glMapGrid1d(GLint un, GLdouble u1, GLdouble u2);</para>
        /// </summary>
        /// <param name="un">
        /// <para>
        /// Specifies the number of partitions in the grid range interval
        /// [<paramref name="u1"/>, <paramref name="u2"/>].
        /// Must be positive.
        /// </para>
        /// </param>
        /// <param name="u1">
        /// <para>
        /// Specify the mappings for integer grid domain values 
        /// i 
        /// = 
        /// 0 
        /// and 
        /// i 
        /// = 
        /// un 
        /// .
        /// </para>
        /// </param>
        /// <param name="u2">
        /// <para>
        /// Specify the mappings for integer grid domain values 
        /// i 
        /// = 
        /// 0 
        /// and 
        /// i 
        /// = 
        /// un 
        /// .
        /// </para>
        /// </param>
        /// <seealso cref="glEvalCoord"/>
        /// <seealso cref="glEvalMesh"/>
        /// <seealso cref="glEvalPoint"/>
        /// <seealso cref="glMap1"/>
        /// <seealso cref="glMap2"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void glMapGrid1d(int un, double u1, double u2) {
            var _F = _GetProc<GLNativeDelegate.FNglMapGrid1d>("glMapGrid1d");
            _F(un, u1, u2);
        }
        /// <summary>
        /// define a one- or two-dimensional mesh
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if either <paramref name="un"/> or <paramref name="vn"/> is not
        /// positive.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glMapGrid"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glMapGrid1f(GLint un, GLfloat u1, GLfloat u2);</para>
        /// </summary>
        /// <param name="un">
        /// <para>
        /// Specifies the number of partitions in the grid range interval
        /// [<paramref name="u1"/>, <paramref name="u2"/>].
        /// Must be positive.
        /// </para>
        /// </param>
        /// <param name="u1">
        /// <para>
        /// Specify the mappings for integer grid domain values 
        /// i 
        /// = 
        /// 0 
        /// and 
        /// i 
        /// = 
        /// un 
        /// .
        /// </para>
        /// </param>
        /// <param name="u2">
        /// <para>
        /// Specify the mappings for integer grid domain values 
        /// i 
        /// = 
        /// 0 
        /// and 
        /// i 
        /// = 
        /// un 
        /// .
        /// </para>
        /// </param>
        /// <seealso cref="glEvalCoord"/>
        /// <seealso cref="glEvalMesh"/>
        /// <seealso cref="glEvalPoint"/>
        /// <seealso cref="glMap1"/>
        /// <seealso cref="glMap2"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void glMapGrid1f(int un, float u1, float u2) {
            var _F = _GetProc<GLNativeDelegate.FNglMapGrid1f>("glMapGrid1f");
            _F(un, u1, u2);
        }
        /// <summary>
        /// define a one- or two-dimensional mesh
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if either <paramref name="un"/> or <paramref name="vn"/> is not
        /// positive.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glMapGrid"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glMapGrid2d(GLint un, GLdouble u1, GLdouble u2, GLint vn, GLdouble v1, GLdouble v2);</para>
        /// </summary>
        /// <param name="un">
        /// <para>
        /// Specifies the number of partitions in the grid range interval
        /// [<paramref name="u1"/>, <paramref name="u2"/>].
        /// Must be positive.
        /// </para>
        /// </param>
        /// <param name="u1">
        /// <para>
        /// Specify the mappings for integer grid domain values 
        /// i 
        /// = 
        /// 0 
        /// and 
        /// i 
        /// = 
        /// un 
        /// .
        /// </para>
        /// </param>
        /// <param name="u2">
        /// <para>
        /// Specify the mappings for integer grid domain values 
        /// i 
        /// = 
        /// 0 
        /// and 
        /// i 
        /// = 
        /// un 
        /// .
        /// </para>
        /// </param>
        /// <param name="vn">
        /// <para>
        /// Specifies the number of partitions in the grid range interval
        /// [<paramref name="v1"/>, <paramref name="v2"/>]
        /// (<see cref="glMapGrid2"/> only).
        /// </para>
        /// </param>
        /// <param name="v1">
        /// <para>
        /// Specify the mappings for integer grid domain values 
        /// j 
        /// = 
        /// 0 
        /// and 
        /// j 
        /// = 
        /// vn 
        /// (<see cref="glMapGrid2"/> only).
        /// </para>
        /// </param>
        /// <param name="v2">
        /// <para>
        /// Specify the mappings for integer grid domain values 
        /// j 
        /// = 
        /// 0 
        /// and 
        /// j 
        /// = 
        /// vn 
        /// (<see cref="glMapGrid2"/> only).
        /// </para>
        /// </param>
        /// <seealso cref="glEvalCoord"/>
        /// <seealso cref="glEvalMesh"/>
        /// <seealso cref="glEvalPoint"/>
        /// <seealso cref="glMap1"/>
        /// <seealso cref="glMap2"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void glMapGrid2d(int un, double u1, double u2, int vn, double v1, double v2) {
            var _F = _GetProc<GLNativeDelegate.FNglMapGrid2d>("glMapGrid2d");
            _F(un, u1, u2, vn, v1, v2);
        }
        /// <summary>
        /// define a one- or two-dimensional mesh
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if either <paramref name="un"/> or <paramref name="vn"/> is not
        /// positive.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glMapGrid"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glMapGrid2f(GLint un, GLfloat u1, GLfloat u2, GLint vn, GLfloat v1, GLfloat v2);</para>
        /// </summary>
        /// <param name="un">
        /// <para>
        /// Specifies the number of partitions in the grid range interval
        /// [<paramref name="u1"/>, <paramref name="u2"/>].
        /// Must be positive.
        /// </para>
        /// </param>
        /// <param name="u1">
        /// <para>
        /// Specify the mappings for integer grid domain values 
        /// i 
        /// = 
        /// 0 
        /// and 
        /// i 
        /// = 
        /// un 
        /// .
        /// </para>
        /// </param>
        /// <param name="u2">
        /// <para>
        /// Specify the mappings for integer grid domain values 
        /// i 
        /// = 
        /// 0 
        /// and 
        /// i 
        /// = 
        /// un 
        /// .
        /// </para>
        /// </param>
        /// <param name="vn">
        /// <para>
        /// Specifies the number of partitions in the grid range interval
        /// [<paramref name="v1"/>, <paramref name="v2"/>]
        /// (<see cref="glMapGrid2"/> only).
        /// </para>
        /// </param>
        /// <param name="v1">
        /// <para>
        /// Specify the mappings for integer grid domain values 
        /// j 
        /// = 
        /// 0 
        /// and 
        /// j 
        /// = 
        /// vn 
        /// (<see cref="glMapGrid2"/> only).
        /// </para>
        /// </param>
        /// <param name="v2">
        /// <para>
        /// Specify the mappings for integer grid domain values 
        /// j 
        /// = 
        /// 0 
        /// and 
        /// j 
        /// = 
        /// vn 
        /// (<see cref="glMapGrid2"/> only).
        /// </para>
        /// </param>
        /// <seealso cref="glEvalCoord"/>
        /// <seealso cref="glEvalMesh"/>
        /// <seealso cref="glEvalPoint"/>
        /// <seealso cref="glMap1"/>
        /// <seealso cref="glMap2"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void glMapGrid2f(int un, float u1, float u2, int vn, float v1, float v2) {
            var _F = _GetProc<GLNativeDelegate.FNglMapGrid2f>("glMapGrid2f");
            _F(un, u1, u2, vn, v1, v2);
        }
        /// <summary>
        /// evaluate enabled one- and two-dimensional maps
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glEvalCoord1d(GLdouble u);</para>
        /// </summary>
        /// <param name="u">
        /// <para>
        /// Specifies a value that is the domain coordinate 
        /// u   
        /// to the basis function
        /// defined in a previous  <see cref="glMap1"/>  or  <see cref="glMap2"/>  command.
        /// </para>
        /// </param>
        /// <seealso cref="glBegin"/>
        /// <seealso cref="glColor"/>
        /// <seealso cref="glEnable"/>
        /// <seealso cref="glEvalMesh"/>
        /// <seealso cref="glEvalPoint"/>
        /// <seealso cref="glIndex"/>
        /// <seealso cref="glMap1"/>
        /// <seealso cref="glMap2"/>
        /// <seealso cref="glMapGrid"/>
        /// <seealso cref="glNormal"/>
        /// <seealso cref="glTexCoord"/>
        /// <seealso cref="glVertex"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void glEvalCoord1d(double u) {
            var _F = _GetProc<GLNativeDelegate.FNglEvalCoord1d>("glEvalCoord1d");
            _F(u);
        }
        /// <summary>
        /// evaluate enabled one- and two-dimensional maps
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glEvalCoord1dv(const GLdouble * u);</para>
        /// </summary>
        /// <param name="u">
        /// <para>
        /// Specifies a pointer to an array containing
        /// either one or two domain coordinates.
        /// The first coordinate is 
        /// u   .
        /// The second coordinate is 
        /// v   ,
        /// which is present only in <see cref="glEvalCoord2"/> versions.
        /// </para>
        /// </param>
        /// <seealso cref="glBegin"/>
        /// <seealso cref="glColor"/>
        /// <seealso cref="glEnable"/>
        /// <seealso cref="glEvalMesh"/>
        /// <seealso cref="glEvalPoint"/>
        /// <seealso cref="glIndex"/>
        /// <seealso cref="glMap1"/>
        /// <seealso cref="glMap2"/>
        /// <seealso cref="glMapGrid"/>
        /// <seealso cref="glNormal"/>
        /// <seealso cref="glTexCoord"/>
        /// <seealso cref="glVertex"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void glEvalCoord1dv(double* u) {
            var _F = _GetProc<GLNativeDelegate.FNglEvalCoord1dv>("glEvalCoord1dv");
            _F(u);
        }
        /// <summary>
        /// evaluate enabled one- and two-dimensional maps
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glEvalCoord1f(GLfloat u);</para>
        /// </summary>
        /// <param name="u">
        /// <para>
        /// Specifies a value that is the domain coordinate 
        /// u   
        /// to the basis function
        /// defined in a previous  <see cref="glMap1"/>  or  <see cref="glMap2"/>  command.
        /// </para>
        /// </param>
        /// <seealso cref="glBegin"/>
        /// <seealso cref="glColor"/>
        /// <seealso cref="glEnable"/>
        /// <seealso cref="glEvalMesh"/>
        /// <seealso cref="glEvalPoint"/>
        /// <seealso cref="glIndex"/>
        /// <seealso cref="glMap1"/>
        /// <seealso cref="glMap2"/>
        /// <seealso cref="glMapGrid"/>
        /// <seealso cref="glNormal"/>
        /// <seealso cref="glTexCoord"/>
        /// <seealso cref="glVertex"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void glEvalCoord1f(float u) {
            var _F = _GetProc<GLNativeDelegate.FNglEvalCoord1f>("glEvalCoord1f");
            _F(u);
        }
        /// <summary>
        /// evaluate enabled one- and two-dimensional maps
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glEvalCoord1fv(const GLfloat * u);</para>
        /// </summary>
        /// <param name="u">
        /// <para>
        /// Specifies a pointer to an array containing
        /// either one or two domain coordinates.
        /// The first coordinate is 
        /// u   .
        /// The second coordinate is 
        /// v   ,
        /// which is present only in <see cref="glEvalCoord2"/> versions.
        /// </para>
        /// </param>
        /// <seealso cref="glBegin"/>
        /// <seealso cref="glColor"/>
        /// <seealso cref="glEnable"/>
        /// <seealso cref="glEvalMesh"/>
        /// <seealso cref="glEvalPoint"/>
        /// <seealso cref="glIndex"/>
        /// <seealso cref="glMap1"/>
        /// <seealso cref="glMap2"/>
        /// <seealso cref="glMapGrid"/>
        /// <seealso cref="glNormal"/>
        /// <seealso cref="glTexCoord"/>
        /// <seealso cref="glVertex"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void glEvalCoord1fv(float* u) {
            var _F = _GetProc<GLNativeDelegate.FNglEvalCoord1fv>("glEvalCoord1fv");
            _F(u);
        }
        /// <summary>
        /// evaluate enabled one- and two-dimensional maps
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glEvalCoord2d(GLdouble u, GLdouble v);</para>
        /// </summary>
        /// <param name="u">
        /// <para>
        /// Specifies a value that is the domain coordinate 
        /// u   
        /// to the basis function
        /// defined in a previous  <see cref="glMap1"/>  or  <see cref="glMap2"/>  command.
        /// </para>
        /// </param>
        /// <param name="v">
        /// <para>
        /// Specifies a value that is the domain coordinate 
        /// v   
        /// to the basis function
        /// defined in a previous  <see cref="glMap2"/>  command.
        /// This argument is not present in a <see cref="glEvalCoord1"/> command.
        /// </para>
        /// </param>
        /// <seealso cref="glBegin"/>
        /// <seealso cref="glColor"/>
        /// <seealso cref="glEnable"/>
        /// <seealso cref="glEvalMesh"/>
        /// <seealso cref="glEvalPoint"/>
        /// <seealso cref="glIndex"/>
        /// <seealso cref="glMap1"/>
        /// <seealso cref="glMap2"/>
        /// <seealso cref="glMapGrid"/>
        /// <seealso cref="glNormal"/>
        /// <seealso cref="glTexCoord"/>
        /// <seealso cref="glVertex"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void glEvalCoord2d(double u, double v) {
            var _F = _GetProc<GLNativeDelegate.FNglEvalCoord2d>("glEvalCoord2d");
            _F(u, v);
        }
        /// <summary>
        /// evaluate enabled one- and two-dimensional maps
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glEvalCoord2dv(const GLdouble * u);</para>
        /// </summary>
        /// <param name="u">
        /// <para>
        /// Specifies a pointer to an array containing
        /// either one or two domain coordinates.
        /// The first coordinate is 
        /// u   .
        /// The second coordinate is 
        /// v   ,
        /// which is present only in <see cref="glEvalCoord2"/> versions.
        /// </para>
        /// </param>
        /// <seealso cref="glBegin"/>
        /// <seealso cref="glColor"/>
        /// <seealso cref="glEnable"/>
        /// <seealso cref="glEvalMesh"/>
        /// <seealso cref="glEvalPoint"/>
        /// <seealso cref="glIndex"/>
        /// <seealso cref="glMap1"/>
        /// <seealso cref="glMap2"/>
        /// <seealso cref="glMapGrid"/>
        /// <seealso cref="glNormal"/>
        /// <seealso cref="glTexCoord"/>
        /// <seealso cref="glVertex"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void glEvalCoord2dv(double* u) {
            var _F = _GetProc<GLNativeDelegate.FNglEvalCoord2dv>("glEvalCoord2dv");
            _F(u);
        }
        /// <summary>
        /// evaluate enabled one- and two-dimensional maps
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glEvalCoord2f(GLfloat u, GLfloat v);</para>
        /// </summary>
        /// <param name="u">
        /// <para>
        /// Specifies a value that is the domain coordinate 
        /// u   
        /// to the basis function
        /// defined in a previous  <see cref="glMap1"/>  or  <see cref="glMap2"/>  command.
        /// </para>
        /// </param>
        /// <param name="v">
        /// <para>
        /// Specifies a value that is the domain coordinate 
        /// v   
        /// to the basis function
        /// defined in a previous  <see cref="glMap2"/>  command.
        /// This argument is not present in a <see cref="glEvalCoord1"/> command.
        /// </para>
        /// </param>
        /// <seealso cref="glBegin"/>
        /// <seealso cref="glColor"/>
        /// <seealso cref="glEnable"/>
        /// <seealso cref="glEvalMesh"/>
        /// <seealso cref="glEvalPoint"/>
        /// <seealso cref="glIndex"/>
        /// <seealso cref="glMap1"/>
        /// <seealso cref="glMap2"/>
        /// <seealso cref="glMapGrid"/>
        /// <seealso cref="glNormal"/>
        /// <seealso cref="glTexCoord"/>
        /// <seealso cref="glVertex"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void glEvalCoord2f(float u, float v) {
            var _F = _GetProc<GLNativeDelegate.FNglEvalCoord2f>("glEvalCoord2f");
            _F(u, v);
        }
        /// <summary>
        /// evaluate enabled one- and two-dimensional maps
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glEvalCoord2fv(const GLfloat * u);</para>
        /// </summary>
        /// <param name="u">
        /// <para>
        /// Specifies a pointer to an array containing
        /// either one or two domain coordinates.
        /// The first coordinate is 
        /// u   .
        /// The second coordinate is 
        /// v   ,
        /// which is present only in <see cref="glEvalCoord2"/> versions.
        /// </para>
        /// </param>
        /// <seealso cref="glBegin"/>
        /// <seealso cref="glColor"/>
        /// <seealso cref="glEnable"/>
        /// <seealso cref="glEvalMesh"/>
        /// <seealso cref="glEvalPoint"/>
        /// <seealso cref="glIndex"/>
        /// <seealso cref="glMap1"/>
        /// <seealso cref="glMap2"/>
        /// <seealso cref="glMapGrid"/>
        /// <seealso cref="glNormal"/>
        /// <seealso cref="glTexCoord"/>
        /// <seealso cref="glVertex"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void glEvalCoord2fv(float* u) {
            var _F = _GetProc<GLNativeDelegate.FNglEvalCoord2fv>("glEvalCoord2fv");
            _F(u);
        }
        /// <summary>
        /// compute a one- or two-dimensional grid of points or lines
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="mode"/> is not an accepted value.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glEvalMesh"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glEvalMesh1(GLenum mode, GLint i1, GLint i2);</para>
        /// </summary>
        /// <param name="mode">
        /// <para>
        /// In <see cref="glEvalMesh1"/>, specifies whether to compute a one-dimensional mesh of points or lines.
        /// Symbolic constants
        /// <code>GL_POINT</code> and
        /// <code>GL_LINE</code> are accepted.
        /// </para>
        /// </param>
        /// <param name="i1">
        /// <para>
        /// Specify the first and last integer values for grid domain variable 
        /// i   .
        /// </para>
        /// </param>
        /// <param name="i2">
        /// <para>
        /// Specify the first and last integer values for grid domain variable 
        /// i   .
        /// </para>
        /// </param>
        /// <seealso cref="glBegin"/>
        /// <seealso cref="glEvalCoord"/>
        /// <seealso cref="glEvalPoint"/>
        /// <seealso cref="glMap1"/>
        /// <seealso cref="glMap2"/>
        /// <seealso cref="glMapGrid"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void glEvalMesh1(uint mode, int i1, int i2) {
            var _F = _GetProc<GLNativeDelegate.FNglEvalMesh1>("glEvalMesh1");
            _F(mode, i1, i2);
        }
        /// <summary>
        /// generate and evaluate a single point in a mesh
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glEvalPoint1(GLint i);</para>
        /// </summary>
        /// <param name="i">
        /// <para>
        /// Specifies the integer value for grid domain variable 
        /// i   .
        /// </para>
        /// </param>
        /// <seealso cref="glEvalCoord"/>
        /// <seealso cref="glEvalMesh"/>
        /// <seealso cref="glMap1"/>
        /// <seealso cref="glMap2"/>
        /// <seealso cref="glMapGrid"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void glEvalPoint1(int i) {
            var _F = _GetProc<GLNativeDelegate.FNglEvalPoint1>("glEvalPoint1");
            _F(i);
        }
        /// <summary>
        /// compute a one- or two-dimensional grid of points or lines
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="mode"/> is not an accepted value.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glEvalMesh"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glEvalMesh2(GLenum mode, GLint i1, GLint i2, GLint j1, GLint j2);</para>
        /// </summary>
        /// <param name="mode">
        /// <para>
        /// In <see cref="glEvalMesh2"/>, specifies whether to compute a two-dimensional mesh of points, lines,
        /// or polygons.
        /// Symbolic constants
        /// <code>GL_POINT</code>,
        /// <code>GL_LINE</code>, and
        /// <code>GL_FILL</code> are accepted.
        /// </para>
        /// </param>
        /// <param name="i1">
        /// <para>
        /// Specify the first and last integer values for grid domain variable 
        /// i   .
        /// </para>
        /// </param>
        /// <param name="i2">
        /// <para>
        /// Specify the first and last integer values for grid domain variable 
        /// i   .
        /// </para>
        /// </param>
        /// <param name="j1">
        /// <para>
        /// Specify the first and last integer values for grid domain variable 
        /// j   .
        /// </para>
        /// </param>
        /// <param name="j2">
        /// <para>
        /// Specify the first and last integer values for grid domain variable 
        /// j   .
        /// </para>
        /// </param>
        /// <seealso cref="glBegin"/>
        /// <seealso cref="glEvalCoord"/>
        /// <seealso cref="glEvalPoint"/>
        /// <seealso cref="glMap1"/>
        /// <seealso cref="glMap2"/>
        /// <seealso cref="glMapGrid"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void glEvalMesh2(uint mode, int i1, int i2, int j1, int j2) {
            var _F = _GetProc<GLNativeDelegate.FNglEvalMesh2>("glEvalMesh2");
            _F(mode, i1, i2, j1, j2);
        }
        /// <summary>
        /// generate and evaluate a single point in a mesh
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glEvalPoint2(GLint i, GLint j);</para>
        /// </summary>
        /// <param name="i">
        /// <para>
        /// Specifies the integer value for grid domain variable 
        /// i   .
        /// </para>
        /// </param>
        /// <param name="j">
        /// <para>
        /// Specifies the integer value for grid domain variable 
        /// j   
        /// (<see cref="glEvalPoint2"/> only).
        /// </para>
        /// </param>
        /// <seealso cref="glEvalCoord"/>
        /// <seealso cref="glEvalMesh"/>
        /// <seealso cref="glMap1"/>
        /// <seealso cref="glMap2"/>
        /// <seealso cref="glMapGrid"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void glEvalPoint2(int i, int j) {
            var _F = _GetProc<GLNativeDelegate.FNglEvalPoint2>("glEvalPoint2");
            _F(i, j);
        }
        /// <summary>
        /// specify the alpha test function
        /// <para>Require:</para> <para>GL_VERSION_1_0, GL_VERSION_ES_CM_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// Alpha testing is performed only in RGBA mode.
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="func"/> is not an accepted value.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glAlphaFunc"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glAlphaFunc(GLenum func, GLclampf ref);</para>
        /// </summary>
        /// <param name="func">
        /// <para>
        /// Specifies the alpha comparison function.
        /// Symbolic constants
        /// <code>GL_NEVER</code>,
        /// <code>GL_LESS</code>,
        /// <code>GL_EQUAL</code>,
        /// <code>GL_LEQUAL</code>,
        /// <code>GL_GREATER</code>,
        /// <code>GL_NOTEQUAL</code>,
        /// <code>GL_GEQUAL</code>, and
        /// <code>GL_ALWAYS</code> are accepted. The initial value is <code>GL_ALWAYS</code>.
        /// </para>
        /// </param>
        /// <param name="r">
        /// <para>
        /// Specifies the reference value that incoming alpha values are compared to.
        /// This value is clamped to the range 
        /// 0 
        /// 1 
        /// ,
        /// where 0 represents the lowest possible alpha value
        /// and 1 the highest possible value.
        /// The initial reference value is 0.
        /// </para>
        /// </param>
        /// <seealso cref="glBlendFunc"/>
        /// <seealso cref="glClear"/>
        /// <seealso cref="glDepthFunc"/>
        /// <seealso cref="glEnable"/>
        /// <seealso cref="glStencilFunc"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void glAlphaFunc(uint func, float r) {
            var _F = _GetProc<GLNativeDelegate.FNglAlphaFunc>("glAlphaFunc");
            _F(func, r);
        }
        /// <summary>
        /// specify the pixel zoom factors
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glPixelZoom"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glPixelZoom(GLfloat xfactor, GLfloat yfactor);</para>
        /// </summary>
        /// <param name="xfactor">
        /// <para>
        /// Specify the 
        /// x   
        /// and 
        /// y   
        /// zoom factors for pixel write operations.
        /// </para>
        /// </param>
        /// <param name="yfactor">
        /// <para>
        /// Specify the 
        /// x   
        /// and 
        /// y   
        /// zoom factors for pixel write operations.
        /// </para>
        /// </param>
        /// <seealso cref="glCopyPixels"/>
        /// <seealso cref="glDrawPixels"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void glPixelZoom(float xfactor, float yfactor) {
            var _F = _GetProc<GLNativeDelegate.FNglPixelZoom>("glPixelZoom");
            _F(xfactor, yfactor);
        }
        /// <summary>
        /// set pixel transfer modes
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// If a
        /// <see cref="glColorTable"/> ,
        /// <see cref="glColorSubTable"/> ,
        /// <see cref="glConvolutionFilter1D"/> ,
        /// <see cref="glConvolutionFilter2D"/> ,
        /// <see cref="glCopyPixels"/> ,
        /// <see cref="glCopyTexImage1D"/> ,
        /// <see cref="glCopyTexImage2D"/> ,
        /// <see cref="glCopyTexSubImage1D"/> ,
        /// <see cref="glCopyTexSubImage2D"/> ,
        /// <see cref="glCopyTexSubImage3D"/> ,
        /// <see cref="glDrawPixels"/> ,
        /// <see cref="glReadPixels"/> ,
        /// <see cref="glSeparableFilter2D"/> ,
        /// <see cref="glTexImage1D"/> ,
        /// <see cref="glTexImage2D"/> ,
        /// <see cref="glTexImage3D"/> ,
        /// <see cref="glTexSubImage1D"/> ,
        /// <see cref="glTexSubImage2D"/> , or
        /// <see cref="glTexSubImage3D"/> 
        /// command is placed in a display list
        /// (see  <see cref="glNewList"/>  and  <see cref="glCallList"/> ),
        /// the pixel transfer mode settings in effect when the display list is
        /// executed 
        /// are the ones that are used.
        /// They may be different from the settings when the command was compiled
        /// into the display list.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="pname"/> is not an accepted value.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glPixelTransfer"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glPixelTransferf(GLenum pname, GLfloat param);</para>
        /// </summary>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of the pixel transfer parameter to be set.
        /// Must be one of the following:
        /// <code>GL_MAP_COLOR</code>,
        /// <code>GL_MAP_STENCIL</code>,
        /// <code>GL_INDEX_SHIFT</code>,
        /// <code>GL_INDEX_OFFSET</code>,
        /// <code>GL_RED_SCALE</code>,
        /// <code>GL_RED_BIAS</code>,
        /// <code>GL_GREEN_SCALE</code>,
        /// <code>GL_GREEN_BIAS</code>,
        /// <code>GL_BLUE_SCALE</code>,
        /// <code>GL_BLUE_BIAS</code>,
        /// <code>GL_ALPHA_SCALE</code>,
        /// <code>GL_ALPHA_BIAS</code>,
        /// <code>GL_DEPTH_SCALE</code>, or
        /// <code>GL_DEPTH_BIAS</code>.
        /// </para>
        /// <para>
        /// Additionally, if the <code>ARB_imaging</code> extension is supported, the
        /// following symbolic names are accepted:
        /// <code>GL_POST_COLOR_MATRIX_RED_SCALE</code>,
        /// <code>GL_POST_COLOR_MATRIX_GREEN_SCALE</code>,
        /// <code>GL_POST_COLOR_MATRIX_BLUE_SCALE</code>,
        /// <code>GL_POST_COLOR_MATRIX_ALPHA_SCALE</code>,
        /// <code>GL_POST_COLOR_MATRIX_RED_BIAS</code>,
        /// <code>GL_POST_COLOR_MATRIX_GREEN_BIAS</code>,
        /// <code>GL_POST_COLOR_MATRIX_BLUE_BIAS</code>,
        /// <code>GL_POST_COLOR_MATRIX_ALPHA_BIAS</code>,
        /// <code>GL_POST_CONVOLUTION_RED_SCALE</code>,
        /// <code>GL_POST_CONVOLUTION_GREEN_SCALE</code>,
        /// <code>GL_POST_CONVOLUTION_BLUE_SCALE</code>,
        /// <code>GL_POST_CONVOLUTION_ALPHA_SCALE</code>,
        /// <code>GL_POST_CONVOLUTION_RED_BIAS</code>,
        /// <code>GL_POST_CONVOLUTION_GREEN_BIAS</code>,
        /// <code>GL_POST_CONVOLUTION_BLUE_BIAS</code>, and
        /// <code>GL_POST_CONVOLUTION_ALPHA_BIAS</code>.
        /// </para>
        /// </param>
        /// <param name="param">
        /// Specifies the value that <paramref name="pname"/> is set to.
        /// </param>
        /// <seealso cref="glCallList"/>
        /// <seealso cref="glColorTable"/>
        /// <seealso cref="glColorSubTable"/>
        /// <seealso cref="glConvolutionFilter1D"/>
        /// <seealso cref="glConvolutionFilter2D"/>
        /// <seealso cref="glCopyPixels"/>
        /// <seealso cref="glCopyTexImage1D"/>
        /// <seealso cref="glCopyTexImage2D"/>
        /// <seealso cref="glCopyTexSubImage1D"/>
        /// <seealso cref="glCopyTexSubImage2D"/>
        /// <seealso cref="glCopyTexSubImage3D"/>
        /// <seealso cref="glDrawPixels"/>
        /// <seealso cref="glNewList"/>
        /// <seealso cref="glPixelMap"/>
        /// <seealso cref="glPixelStore"/>
        /// <seealso cref="glPixelZoom"/>
        /// <seealso cref="glReadPixels"/>
        /// <seealso cref="glTexImage1D"/>
        /// <seealso cref="glTexImage2D"/>
        /// <seealso cref="glTexImage3D"/>
        /// <seealso cref="glTexSubImage1D"/>
        /// <seealso cref="glTexSubImage2D"/>
        /// <seealso cref="glTexSubImage3D"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void glPixelTransferf(uint pname, float param) {
            var _F = _GetProc<GLNativeDelegate.FNglPixelTransferf>("glPixelTransferf");
            _F(pname, param);
        }
        /// <summary>
        /// set pixel transfer modes
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// If a
        /// <see cref="glColorTable"/> ,
        /// <see cref="glColorSubTable"/> ,
        /// <see cref="glConvolutionFilter1D"/> ,
        /// <see cref="glConvolutionFilter2D"/> ,
        /// <see cref="glCopyPixels"/> ,
        /// <see cref="glCopyTexImage1D"/> ,
        /// <see cref="glCopyTexImage2D"/> ,
        /// <see cref="glCopyTexSubImage1D"/> ,
        /// <see cref="glCopyTexSubImage2D"/> ,
        /// <see cref="glCopyTexSubImage3D"/> ,
        /// <see cref="glDrawPixels"/> ,
        /// <see cref="glReadPixels"/> ,
        /// <see cref="glSeparableFilter2D"/> ,
        /// <see cref="glTexImage1D"/> ,
        /// <see cref="glTexImage2D"/> ,
        /// <see cref="glTexImage3D"/> ,
        /// <see cref="glTexSubImage1D"/> ,
        /// <see cref="glTexSubImage2D"/> , or
        /// <see cref="glTexSubImage3D"/> 
        /// command is placed in a display list
        /// (see  <see cref="glNewList"/>  and  <see cref="glCallList"/> ),
        /// the pixel transfer mode settings in effect when the display list is
        /// executed 
        /// are the ones that are used.
        /// They may be different from the settings when the command was compiled
        /// into the display list.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="pname"/> is not an accepted value.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glPixelTransfer"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glPixelTransferi(GLenum pname, GLint param);</para>
        /// </summary>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of the pixel transfer parameter to be set.
        /// Must be one of the following:
        /// <code>GL_MAP_COLOR</code>,
        /// <code>GL_MAP_STENCIL</code>,
        /// <code>GL_INDEX_SHIFT</code>,
        /// <code>GL_INDEX_OFFSET</code>,
        /// <code>GL_RED_SCALE</code>,
        /// <code>GL_RED_BIAS</code>,
        /// <code>GL_GREEN_SCALE</code>,
        /// <code>GL_GREEN_BIAS</code>,
        /// <code>GL_BLUE_SCALE</code>,
        /// <code>GL_BLUE_BIAS</code>,
        /// <code>GL_ALPHA_SCALE</code>,
        /// <code>GL_ALPHA_BIAS</code>,
        /// <code>GL_DEPTH_SCALE</code>, or
        /// <code>GL_DEPTH_BIAS</code>.
        /// </para>
        /// <para>
        /// Additionally, if the <code>ARB_imaging</code> extension is supported, the
        /// following symbolic names are accepted:
        /// <code>GL_POST_COLOR_MATRIX_RED_SCALE</code>,
        /// <code>GL_POST_COLOR_MATRIX_GREEN_SCALE</code>,
        /// <code>GL_POST_COLOR_MATRIX_BLUE_SCALE</code>,
        /// <code>GL_POST_COLOR_MATRIX_ALPHA_SCALE</code>,
        /// <code>GL_POST_COLOR_MATRIX_RED_BIAS</code>,
        /// <code>GL_POST_COLOR_MATRIX_GREEN_BIAS</code>,
        /// <code>GL_POST_COLOR_MATRIX_BLUE_BIAS</code>,
        /// <code>GL_POST_COLOR_MATRIX_ALPHA_BIAS</code>,
        /// <code>GL_POST_CONVOLUTION_RED_SCALE</code>,
        /// <code>GL_POST_CONVOLUTION_GREEN_SCALE</code>,
        /// <code>GL_POST_CONVOLUTION_BLUE_SCALE</code>,
        /// <code>GL_POST_CONVOLUTION_ALPHA_SCALE</code>,
        /// <code>GL_POST_CONVOLUTION_RED_BIAS</code>,
        /// <code>GL_POST_CONVOLUTION_GREEN_BIAS</code>,
        /// <code>GL_POST_CONVOLUTION_BLUE_BIAS</code>, and
        /// <code>GL_POST_CONVOLUTION_ALPHA_BIAS</code>.
        /// </para>
        /// </param>
        /// <param name="param">
        /// Specifies the value that <paramref name="pname"/> is set to.
        /// </param>
        /// <seealso cref="glCallList"/>
        /// <seealso cref="glColorTable"/>
        /// <seealso cref="glColorSubTable"/>
        /// <seealso cref="glConvolutionFilter1D"/>
        /// <seealso cref="glConvolutionFilter2D"/>
        /// <seealso cref="glCopyPixels"/>
        /// <seealso cref="glCopyTexImage1D"/>
        /// <seealso cref="glCopyTexImage2D"/>
        /// <seealso cref="glCopyTexSubImage1D"/>
        /// <seealso cref="glCopyTexSubImage2D"/>
        /// <seealso cref="glCopyTexSubImage3D"/>
        /// <seealso cref="glDrawPixels"/>
        /// <seealso cref="glNewList"/>
        /// <seealso cref="glPixelMap"/>
        /// <seealso cref="glPixelStore"/>
        /// <seealso cref="glPixelZoom"/>
        /// <seealso cref="glReadPixels"/>
        /// <seealso cref="glTexImage1D"/>
        /// <seealso cref="glTexImage2D"/>
        /// <seealso cref="glTexImage3D"/>
        /// <seealso cref="glTexSubImage1D"/>
        /// <seealso cref="glTexSubImage2D"/>
        /// <seealso cref="glTexSubImage3D"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void glPixelTransferi(uint pname, int param) {
            var _F = _GetProc<GLNativeDelegate.FNglPixelTransferi>("glPixelTransferi");
            _F(pname, param);
        }
        /// <summary>
        /// set up pixel transfer maps
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="map"/> is not an accepted value.
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="mapsize"/> is less than one
        /// or larger than <code>GL_MAX_PIXEL_MAP_TABLE</code>.
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="map"/> is
        /// <code>GL_PIXEL_MAP_I_TO_I</code>,
        /// <code>GL_PIXEL_MAP_S_TO_S</code>,
        /// <code>GL_PIXEL_MAP_I_TO_R</code>,
        /// <code>GL_PIXEL_MAP_I_TO_G</code>,
        /// <code>GL_PIXEL_MAP_I_TO_B</code>, or
        /// <code>GL_PIXEL_MAP_I_TO_A</code>,
        /// and <paramref name="mapsize"/> is not a power of two.
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_UNPACK_BUFFER</code> target and the buffer object's data store is currently mapped.
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_UNPACK_BUFFER</code> target and the data would be unpacked from the buffer 
        /// object such that the memory reads required would exceed the data store size.
        /// <code>GL_INVALID_OPERATION</code> is generated by <see cref="glPixelMapfv"/> if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_UNPACK_BUFFER</code> target and <paramref name="values"/> is not evenly divisible 
        /// into the number of bytes needed to store in memory a GLfloat datum.
        /// <code>GL_INVALID_OPERATION</code> is generated by <see cref="glPixelMapuiv"/> if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_UNPACK_BUFFER</code> target and <paramref name="values"/> is not evenly divisible 
        /// into the number of bytes needed to store in memory a GLuint datum.
        /// <code>GL_INVALID_OPERATION</code> is generated by <see cref="glPixelMapusv"/> if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_UNPACK_BUFFER</code> target and <paramref name="values"/> is not evenly divisible 
        /// into the number of bytes needed to store in memory a GLushort datum.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glPixelMap"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glPixelMapfv(GLenum map, GLsizei mapsize, const GLfloat * values);</para>
        /// </summary>
        /// <param name="map">
        /// <para>
        /// Specifies a symbolic map name.
        /// Must be one of the following:
        /// <code>GL_PIXEL_MAP_I_TO_I</code>,
        /// <code>GL_PIXEL_MAP_S_TO_S</code>,
        /// <code>GL_PIXEL_MAP_I_TO_R</code>,
        /// <code>GL_PIXEL_MAP_I_TO_G</code>,
        /// <code>GL_PIXEL_MAP_I_TO_B</code>,
        /// <code>GL_PIXEL_MAP_I_TO_A</code>,
        /// <code>GL_PIXEL_MAP_R_TO_R</code>,
        /// <code>GL_PIXEL_MAP_G_TO_G</code>,
        /// <code>GL_PIXEL_MAP_B_TO_B</code>, or
        /// <code>GL_PIXEL_MAP_A_TO_A</code>.
        /// </para>
        /// </param>
        /// <param name="mapsize">
        /// Specifies the size of the map being defined.
        /// </param>
        /// <param name="values">
        /// Specifies an array of <paramref name="mapsize"/> values.
        /// </param>
        /// <seealso cref="glColorTable"/>
        /// <seealso cref="glColorSubTable"/>
        /// <seealso cref="glConvolutionFilter1D"/>
        /// <seealso cref="glConvolutionFilter2D"/>
        /// <seealso cref="glCopyPixels"/>
        /// <seealso cref="glCopyTexImage1D"/>
        /// <seealso cref="glCopyTexImage2D"/>
        /// <seealso cref="glCopyTexSubImage1D"/>
        /// <seealso cref="glCopyTexSubImage2D"/>
        /// <seealso cref="glDrawPixels"/>
        /// <seealso cref="glHistogram"/>
        /// <seealso cref="glMinmax"/>
        /// <seealso cref="glPixelStore"/>
        /// <seealso cref="glPixelTransfer"/>
        /// <seealso cref="glReadPixels"/>
        /// <seealso cref="glSeparableFilter2D"/>
        /// <seealso cref="glTexImage1D"/>
        /// <seealso cref="glTexImage2D"/>
        /// <seealso cref="glTexImage3D"/>
        /// <seealso cref="glTexSubImage1D"/>
        /// <seealso cref="glTexSubImage2D"/>
        /// <seealso cref="glTexSubImage3D"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void glPixelMapfv(uint map, int mapsize, float* values) {
            var _F = _GetProc<GLNativeDelegate.FNglPixelMapfv>("glPixelMapfv");
            _F(map, mapsize, values);
        }
        /// <summary>
        /// set up pixel transfer maps
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="map"/> is not an accepted value.
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="mapsize"/> is less than one
        /// or larger than <code>GL_MAX_PIXEL_MAP_TABLE</code>.
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="map"/> is
        /// <code>GL_PIXEL_MAP_I_TO_I</code>,
        /// <code>GL_PIXEL_MAP_S_TO_S</code>,
        /// <code>GL_PIXEL_MAP_I_TO_R</code>,
        /// <code>GL_PIXEL_MAP_I_TO_G</code>,
        /// <code>GL_PIXEL_MAP_I_TO_B</code>, or
        /// <code>GL_PIXEL_MAP_I_TO_A</code>,
        /// and <paramref name="mapsize"/> is not a power of two.
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_UNPACK_BUFFER</code> target and the buffer object's data store is currently mapped.
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_UNPACK_BUFFER</code> target and the data would be unpacked from the buffer 
        /// object such that the memory reads required would exceed the data store size.
        /// <code>GL_INVALID_OPERATION</code> is generated by <see cref="glPixelMapfv"/> if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_UNPACK_BUFFER</code> target and <paramref name="values"/> is not evenly divisible 
        /// into the number of bytes needed to store in memory a GLfloat datum.
        /// <code>GL_INVALID_OPERATION</code> is generated by <see cref="glPixelMapuiv"/> if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_UNPACK_BUFFER</code> target and <paramref name="values"/> is not evenly divisible 
        /// into the number of bytes needed to store in memory a GLuint datum.
        /// <code>GL_INVALID_OPERATION</code> is generated by <see cref="glPixelMapusv"/> if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_UNPACK_BUFFER</code> target and <paramref name="values"/> is not evenly divisible 
        /// into the number of bytes needed to store in memory a GLushort datum.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glPixelMap"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glPixelMapuiv(GLenum map, GLsizei mapsize, const GLuint * values);</para>
        /// </summary>
        /// <param name="map">
        /// <para>
        /// Specifies a symbolic map name.
        /// Must be one of the following:
        /// <code>GL_PIXEL_MAP_I_TO_I</code>,
        /// <code>GL_PIXEL_MAP_S_TO_S</code>,
        /// <code>GL_PIXEL_MAP_I_TO_R</code>,
        /// <code>GL_PIXEL_MAP_I_TO_G</code>,
        /// <code>GL_PIXEL_MAP_I_TO_B</code>,
        /// <code>GL_PIXEL_MAP_I_TO_A</code>,
        /// <code>GL_PIXEL_MAP_R_TO_R</code>,
        /// <code>GL_PIXEL_MAP_G_TO_G</code>,
        /// <code>GL_PIXEL_MAP_B_TO_B</code>, or
        /// <code>GL_PIXEL_MAP_A_TO_A</code>.
        /// </para>
        /// </param>
        /// <param name="mapsize">
        /// Specifies the size of the map being defined.
        /// </param>
        /// <param name="values">
        /// Specifies an array of <paramref name="mapsize"/> values.
        /// </param>
        /// <seealso cref="glColorTable"/>
        /// <seealso cref="glColorSubTable"/>
        /// <seealso cref="glConvolutionFilter1D"/>
        /// <seealso cref="glConvolutionFilter2D"/>
        /// <seealso cref="glCopyPixels"/>
        /// <seealso cref="glCopyTexImage1D"/>
        /// <seealso cref="glCopyTexImage2D"/>
        /// <seealso cref="glCopyTexSubImage1D"/>
        /// <seealso cref="glCopyTexSubImage2D"/>
        /// <seealso cref="glDrawPixels"/>
        /// <seealso cref="glHistogram"/>
        /// <seealso cref="glMinmax"/>
        /// <seealso cref="glPixelStore"/>
        /// <seealso cref="glPixelTransfer"/>
        /// <seealso cref="glReadPixels"/>
        /// <seealso cref="glSeparableFilter2D"/>
        /// <seealso cref="glTexImage1D"/>
        /// <seealso cref="glTexImage2D"/>
        /// <seealso cref="glTexImage3D"/>
        /// <seealso cref="glTexSubImage1D"/>
        /// <seealso cref="glTexSubImage2D"/>
        /// <seealso cref="glTexSubImage3D"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void glPixelMapuiv(uint map, int mapsize, uint* values) {
            var _F = _GetProc<GLNativeDelegate.FNglPixelMapuiv>("glPixelMapuiv");
            _F(map, mapsize, values);
        }
        /// <summary>
        /// set up pixel transfer maps
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="map"/> is not an accepted value.
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="mapsize"/> is less than one
        /// or larger than <code>GL_MAX_PIXEL_MAP_TABLE</code>.
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="map"/> is
        /// <code>GL_PIXEL_MAP_I_TO_I</code>,
        /// <code>GL_PIXEL_MAP_S_TO_S</code>,
        /// <code>GL_PIXEL_MAP_I_TO_R</code>,
        /// <code>GL_PIXEL_MAP_I_TO_G</code>,
        /// <code>GL_PIXEL_MAP_I_TO_B</code>, or
        /// <code>GL_PIXEL_MAP_I_TO_A</code>,
        /// and <paramref name="mapsize"/> is not a power of two.
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_UNPACK_BUFFER</code> target and the buffer object's data store is currently mapped.
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_UNPACK_BUFFER</code> target and the data would be unpacked from the buffer 
        /// object such that the memory reads required would exceed the data store size.
        /// <code>GL_INVALID_OPERATION</code> is generated by <see cref="glPixelMapfv"/> if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_UNPACK_BUFFER</code> target and <paramref name="values"/> is not evenly divisible 
        /// into the number of bytes needed to store in memory a GLfloat datum.
        /// <code>GL_INVALID_OPERATION</code> is generated by <see cref="glPixelMapuiv"/> if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_UNPACK_BUFFER</code> target and <paramref name="values"/> is not evenly divisible 
        /// into the number of bytes needed to store in memory a GLuint datum.
        /// <code>GL_INVALID_OPERATION</code> is generated by <see cref="glPixelMapusv"/> if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_UNPACK_BUFFER</code> target and <paramref name="values"/> is not evenly divisible 
        /// into the number of bytes needed to store in memory a GLushort datum.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glPixelMap"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glPixelMapusv(GLenum map, GLsizei mapsize, const GLushort * values);</para>
        /// </summary>
        /// <param name="map">
        /// <para>
        /// Specifies a symbolic map name.
        /// Must be one of the following:
        /// <code>GL_PIXEL_MAP_I_TO_I</code>,
        /// <code>GL_PIXEL_MAP_S_TO_S</code>,
        /// <code>GL_PIXEL_MAP_I_TO_R</code>,
        /// <code>GL_PIXEL_MAP_I_TO_G</code>,
        /// <code>GL_PIXEL_MAP_I_TO_B</code>,
        /// <code>GL_PIXEL_MAP_I_TO_A</code>,
        /// <code>GL_PIXEL_MAP_R_TO_R</code>,
        /// <code>GL_PIXEL_MAP_G_TO_G</code>,
        /// <code>GL_PIXEL_MAP_B_TO_B</code>, or
        /// <code>GL_PIXEL_MAP_A_TO_A</code>.
        /// </para>
        /// </param>
        /// <param name="mapsize">
        /// Specifies the size of the map being defined.
        /// </param>
        /// <param name="values">
        /// Specifies an array of <paramref name="mapsize"/> values.
        /// </param>
        /// <seealso cref="glColorTable"/>
        /// <seealso cref="glColorSubTable"/>
        /// <seealso cref="glConvolutionFilter1D"/>
        /// <seealso cref="glConvolutionFilter2D"/>
        /// <seealso cref="glCopyPixels"/>
        /// <seealso cref="glCopyTexImage1D"/>
        /// <seealso cref="glCopyTexImage2D"/>
        /// <seealso cref="glCopyTexSubImage1D"/>
        /// <seealso cref="glCopyTexSubImage2D"/>
        /// <seealso cref="glDrawPixels"/>
        /// <seealso cref="glHistogram"/>
        /// <seealso cref="glMinmax"/>
        /// <seealso cref="glPixelStore"/>
        /// <seealso cref="glPixelTransfer"/>
        /// <seealso cref="glReadPixels"/>
        /// <seealso cref="glSeparableFilter2D"/>
        /// <seealso cref="glTexImage1D"/>
        /// <seealso cref="glTexImage2D"/>
        /// <seealso cref="glTexImage3D"/>
        /// <seealso cref="glTexSubImage1D"/>
        /// <seealso cref="glTexSubImage2D"/>
        /// <seealso cref="glTexSubImage3D"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void glPixelMapusv(uint map, int mapsize, ushort* values) {
            var _F = _GetProc<GLNativeDelegate.FNglPixelMapusv>("glPixelMapusv");
            _F(map, mapsize, values);
        }
        /// <summary>
        /// copy pixels in the frame buffer
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// Modes specified by  <see cref="glPixelStore"/>  have no effect on the operation
        /// of <see cref="glCopyPixels"/>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="type"/> is not an accepted value.
        /// <code>GL_INVALID_VALUE</code> is generated if either <paramref name="width"/> or <paramref name="height"/> is negative.
        /// <code>GL_INVALID_OPERATION</code> is generated if <paramref name="type"/> is <code>GL_DEPTH</code>
        /// and there is no depth buffer.
        /// <code>GL_INVALID_OPERATION</code> is generated if <paramref name="type"/> is <code>GL_STENCIL</code>
        /// and there is no stencil buffer.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glCopyPixels"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glCopyPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum type);</para>
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify the window coordinates of the lower left corner
        /// of the rectangular region of pixels to be copied.
        /// </para>
        /// </param>
        /// <param name="y">
        /// <para>
        /// Specify the window coordinates of the lower left corner
        /// of the rectangular region of pixels to be copied.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// Specify the dimensions of the rectangular region of pixels to be copied.
        /// Both must be nonnegative.
        /// </para>
        /// </param>
        /// <param name="height">
        /// <para>
        /// Specify the dimensions of the rectangular region of pixels to be copied.
        /// Both must be nonnegative.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies whether color values,
        /// depth values,
        /// or stencil values are to be copied.
        /// Symbolic constants
        /// <code>GL_COLOR</code>,
        /// <code>GL_DEPTH</code>,
        /// and <code>GL_STENCIL</code> are accepted.
        /// </para>
        /// </param>
        /// <seealso cref="glColorTable"/>
        /// <seealso cref="glConvolutionFilter1D"/>
        /// <seealso cref="glConvolutionFilter2D"/>
        /// <seealso cref="glDepthFunc"/>
        /// <seealso cref="glDrawBuffer"/>
        /// <seealso cref="glDrawPixels"/>
        /// <seealso cref="glMatrixMode"/>
        /// <seealso cref="glPixelMap"/>
        /// <seealso cref="glPixelTransfer"/>
        /// <seealso cref="glPixelZoom"/>
        /// <seealso cref="glRasterPos"/>
        /// <seealso cref="glReadBuffer"/>
        /// <seealso cref="glReadPixels"/>
        /// <seealso cref="glSeparableFilter2D"/>
        /// <seealso cref="glStencilFunc"/>
        /// <seealso cref="glWindowPos"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void glCopyPixels(int x, int y, int width, int height, uint type) {
            var _F = _GetProc<GLNativeDelegate.FNglCopyPixels>("glCopyPixels");
            _F(x, y, width, height, type);
        }
        /// <summary>
        /// write a block of pixels to the frame buffer
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <code>GL_BGR</code> and <code>GL_BGRA</code> are only valid for <paramref name="format"/> if the GL
        /// version is 1.2 or greater.
        /// <code>GL_UNSIGNED_BYTE_3_3_2</code>,
        /// <code>GL_UNSIGNED_BYTE_2_3_3_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_5_6_5</code>,
        /// <code>GL_UNSIGNED_SHORT_5_6_5_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_4_4_4_4</code>,
        /// <code>GL_UNSIGNED_SHORT_4_4_4_4_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_5_5_5_1</code>,
        /// <code>GL_UNSIGNED_SHORT_1_5_5_5_REV</code>,
        /// <code>GL_UNSIGNED_INT_8_8_8_8</code>,
        /// <code>GL_UNSIGNED_INT_8_8_8_8_REV</code>,
        /// <code>GL_UNSIGNED_INT_10_10_10_2</code>, and
        /// <code>GL_UNSIGNED_INT_2_10_10_10_REV</code> are only valid for <paramref name="type"/> if the
        /// GL version is 1.2 or greater.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="format"/> or <paramref name="type"/> is not one of
        /// the accepted values.
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="type"/> is <code>GL_BITMAP</code> and
        /// <paramref name="format"/> is not either <code>GL_COLOR_INDEX</code> or <code>GL_STENCIL_INDEX</code>.
        /// <code>GL_INVALID_VALUE</code> is generated if either <paramref name="width"/> or <paramref name="height"/> is negative.
        /// <code>GL_INVALID_OPERATION</code> is generated if <paramref name="format"/> is <code>GL_STENCIL_INDEX</code>
        /// and there is no stencil buffer.
        /// <code>GL_INVALID_OPERATION</code> is generated if <paramref name="format"/> is
        /// <code>GL_RED</code>,
        /// <code>GL_GREEN</code>,
        /// <code>GL_BLUE</code>,
        /// <code>GL_ALPHA</code>,
        /// <code>GL_RGB</code>,
        /// <code>GL_RGBA</code>,
        /// <code>GL_BGR</code>,
        /// <code>GL_BGRA</code>,
        /// <code>GL_LUMINANCE</code>,
        /// or
        /// <code>GL_LUMINANCE_ALPHA</code>,
        /// and the GL is in color index mode.
        /// <code>GL_INVALID_OPERATION</code> is generated if <paramref name="format"/> is one of
        /// <code>GL_UNSIGNED_BYTE_3_3_2</code>,
        /// <code>GL_UNSIGNED_BYTE_2_3_3_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_5_6_5</code>, or
        /// <code>GL_UNSIGNED_SHORT_5_6_5_REV</code>
        /// and <paramref name="format"/> is not <code>GL_RGB</code>.
        /// <code>GL_INVALID_OPERATION</code> is generated if <paramref name="format"/> is one of
        /// <code>GL_UNSIGNED_SHORT_4_4_4_4</code>,
        /// <code>GL_UNSIGNED_SHORT_4_4_4_4_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_5_5_5_1</code>,
        /// <code>GL_UNSIGNED_SHORT_1_5_5_5_REV</code>,
        /// <code>GL_UNSIGNED_INT_8_8_8_8</code>,
        /// <code>GL_UNSIGNED_INT_8_8_8_8_REV</code>,
        /// <code>GL_UNSIGNED_INT_10_10_10_2</code>, or
        /// <code>GL_UNSIGNED_INT_2_10_10_10_REV</code>
        /// and <paramref name="format"/> is neither <code>GL_RGBA</code> nor <code>GL_BGRA</code>.
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_UNPACK_BUFFER</code> target and the buffer object's data store is currently mapped.
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_UNPACK_BUFFER</code> target and the data would be unpacked from the buffer 
        /// object such that the memory reads required would exceed the data store size.
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_UNPACK_BUFFER</code> target and <paramref name="data"/> is not evenly divisible 
        /// into the number of bytes needed to store in memory a datum indicated by <paramref name="type"/>.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glDrawPixels"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glDrawPixels(GLsizei width, GLsizei height, GLenum format, GLenum type, const void * data);</para>
        /// </summary>
        /// <param name="width">
        /// <para>
        /// Specify the dimensions of the pixel rectangle to be written
        /// into the frame buffer.
        /// </para>
        /// </param>
        /// <param name="height">
        /// <para>
        /// Specify the dimensions of the pixel rectangle to be written
        /// into the frame buffer.
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// Specifies the format of the pixel data.
        /// Symbolic constants
        /// <code>GL_COLOR_INDEX</code>,
        /// <code>GL_STENCIL_INDEX</code>,
        /// <code>GL_DEPTH_COMPONENT</code>,
        /// <code>GL_RGB</code>,
        /// <code>GL_BGR</code>,
        /// <code>GL_RGBA</code>,
        /// <code>GL_BGRA</code>,
        /// <code>GL_RED</code>,
        /// <code>GL_GREEN</code>,
        /// <code>GL_BLUE</code>,
        /// <code>GL_ALPHA</code>,
        /// <code>GL_LUMINANCE</code>, and
        /// <code>GL_LUMINANCE_ALPHA</code> are accepted.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the data type for <paramref name="data"/>.
        /// Symbolic constants
        /// <code>GL_UNSIGNED_BYTE</code>,
        /// <code>GL_BYTE</code>,
        /// <code>GL_BITMAP</code>,
        /// <code>GL_UNSIGNED_SHORT</code>,
        /// <code>GL_SHORT</code>,
        /// <code>GL_UNSIGNED_INT</code>,
        /// <code>GL_INT</code>,
        /// <code>GL_FLOAT</code>,
        /// <code>GL_UNSIGNED_BYTE_3_3_2</code>,
        /// <code>GL_UNSIGNED_BYTE_2_3_3_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_5_6_5</code>,
        /// <code>GL_UNSIGNED_SHORT_5_6_5_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_4_4_4_4</code>,
        /// <code>GL_UNSIGNED_SHORT_4_4_4_4_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_5_5_5_1</code>,
        /// <code>GL_UNSIGNED_SHORT_1_5_5_5_REV</code>,
        /// <code>GL_UNSIGNED_INT_8_8_8_8</code>,
        /// <code>GL_UNSIGNED_INT_8_8_8_8_REV</code>,
        /// <code>GL_UNSIGNED_INT_10_10_10_2</code>, and
        /// <code>GL_UNSIGNED_INT_2_10_10_10_REV</code>
        /// are accepted.
        /// </para>
        /// </param>
        /// <param name="data">
        /// Specifies a pointer to the pixel data.
        /// </param>
        /// <seealso cref="glAlphaFunc"/>
        /// <seealso cref="glBlendFunc"/>
        /// <seealso cref="glCopyPixels"/>
        /// <seealso cref="glDepthFunc"/>
        /// <seealso cref="glLogicOp"/>
        /// <seealso cref="glPixelMap"/>
        /// <seealso cref="glPixelStore"/>
        /// <seealso cref="glPixelTransfer"/>
        /// <seealso cref="glPixelZoom"/>
        /// <seealso cref="glRasterPos"/>
        /// <seealso cref="glReadPixels"/>
        /// <seealso cref="glScissor"/>
        /// <seealso cref="glStencilFunc"/>
        /// <seealso cref="glWindowPos"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void glDrawPixels(int width, int height, uint format, uint type, void* data) {
            var _F = _GetProc<GLNativeDelegate.FNglDrawPixels>("glDrawPixels");
            _F(width, height, format, type, data);
        }
        /// <summary>
        /// return the coefficients of the specified clipping plane
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// It is always the case that <code>GL_CLIP_PLANE</code>
        /// i   
        /// = <code>GL_CLIP_PLANE0</code> + 
        /// i   .
        /// If an error is generated,
        /// no change is made to the contents of <paramref name="equation"/>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="plane"/> is not an accepted value.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glGetClipPlane"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glGetClipPlane(GLenum plane, GLdouble * equation);</para>
        /// </summary>
        /// <param name="plane">
        /// <para>
        /// Specifies a clipping plane.
        /// The number of clipping planes depends on the implementation,
        /// but at least six clipping planes are supported.
        /// They are identified by symbolic names of the form <code>GL_CLIP_PLANE</code>
        /// i   
        /// where i ranges from 0 to the value of <code>GL_MAX_CLIP_PLANES</code> - 1.
        /// </para>
        /// </param>
        /// <param name="equation">
        /// <para>
        /// Returns four double-precision values that are the coefficients of the plane equation of <paramref name="plane"/> in eye coordinates.
        /// The initial value is (0, 0, 0, 0).
        /// </para>
        /// </param>
        /// <seealso cref="glClipPlane"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void glGetClipPlane(uint plane, double* equation) {
            var _F = _GetProc<GLNativeDelegate.FNglGetClipPlane>("glGetClipPlane");
            _F(plane, equation);
        }
        /// <summary>
        /// return light source parameter values
        /// <para>Require:</para> <para>GL_VERSION_1_0, GL_VERSION_ES_CM_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// It is always the case that <code>GL_LIGHT</code>
        /// i   
        /// = <code>GL_LIGHT0</code> + 
        /// i   .
        /// If an error is generated,
        /// no change is made to the contents of <paramref name="ps"/>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="light"/> or <paramref name="pname"/> is not an
        /// accepted value.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glGetLight"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glGetLightfv(GLenum light, GLenum pname, GLfloat * params);</para>
        /// </summary>
        /// <param name="light">
        /// <para>
        /// Specifies a light source.
        /// The number of possible lights depends on the implementation,
        /// but at least eight lights are supported.
        /// They are identified by symbolic names of the form <code>GL_LIGHT</code>
        /// i   
        /// where 
        /// i   
        /// ranges from 0 to the value of <code>GL_MAX_LIGHTS</code> - 1.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies a light source parameter for <paramref name="light"/>.
        /// Accepted symbolic names are
        /// <code>GL_AMBIENT</code>,
        /// <code>GL_DIFFUSE</code>,
        /// <code>GL_SPECULAR</code>,
        /// <code>GL_POSITION</code>,
        /// <code>GL_SPOT_DIRECTION</code>,
        /// <code>GL_SPOT_EXPONENT</code>,
        /// <code>GL_SPOT_CUTOFF</code>,
        /// <code>GL_CONSTANT_ATTENUATION</code>,
        /// <code>GL_LINEAR_ATTENUATION</code>, and
        /// <code>GL_QUADRATIC_ATTENUATION</code>.
        /// </para>
        /// </param>
        /// <param name="ps">
        /// Returns the requested data.
        /// </param>
        /// <seealso cref="glLight"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void glGetLightfv(uint light, uint pname, float* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetLightfv>("glGetLightfv");
            _F(light, pname, ps);
        }
        /// <summary>
        /// return light source parameter values
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// It is always the case that <code>GL_LIGHT</code>
        /// i   
        /// = <code>GL_LIGHT0</code> + 
        /// i   .
        /// If an error is generated,
        /// no change is made to the contents of <paramref name="ps"/>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="light"/> or <paramref name="pname"/> is not an
        /// accepted value.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glGetLight"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glGetLightiv(GLenum light, GLenum pname, GLint * params);</para>
        /// </summary>
        /// <param name="light">
        /// <para>
        /// Specifies a light source.
        /// The number of possible lights depends on the implementation,
        /// but at least eight lights are supported.
        /// They are identified by symbolic names of the form <code>GL_LIGHT</code>
        /// i   
        /// where 
        /// i   
        /// ranges from 0 to the value of <code>GL_MAX_LIGHTS</code> - 1.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies a light source parameter for <paramref name="light"/>.
        /// Accepted symbolic names are
        /// <code>GL_AMBIENT</code>,
        /// <code>GL_DIFFUSE</code>,
        /// <code>GL_SPECULAR</code>,
        /// <code>GL_POSITION</code>,
        /// <code>GL_SPOT_DIRECTION</code>,
        /// <code>GL_SPOT_EXPONENT</code>,
        /// <code>GL_SPOT_CUTOFF</code>,
        /// <code>GL_CONSTANT_ATTENUATION</code>,
        /// <code>GL_LINEAR_ATTENUATION</code>, and
        /// <code>GL_QUADRATIC_ATTENUATION</code>.
        /// </para>
        /// </param>
        /// <param name="ps">
        /// Returns the requested data.
        /// </param>
        /// <seealso cref="glLight"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void glGetLightiv(uint light, uint pname, int* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetLightiv>("glGetLightiv");
            _F(light, pname, ps);
        }
        /// <summary>
        /// return evaluator parameters
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// If an error is generated,
        /// no change is made to the contents of <paramref name="v"/>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if either <paramref name="target"/> or <paramref name="query"/> is not
        /// an accepted value.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glGetMap"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glGetMapdv(GLenum target, GLenum query, GLdouble * v);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the symbolic name of a map.
        /// Accepted values are
        /// <code>GL_MAP1_COLOR_4</code>,
        /// <code>GL_MAP1_INDEX</code>,
        /// <code>GL_MAP1_NORMAL</code>,
        /// <code>GL_MAP1_TEXTURE_COORD_1</code>,
        /// <code>GL_MAP1_TEXTURE_COORD_2</code>,
        /// <code>GL_MAP1_TEXTURE_COORD_3</code>,
        /// <code>GL_MAP1_TEXTURE_COORD_4</code>,
        /// <code>GL_MAP1_VERTEX_3</code>,
        /// <code>GL_MAP1_VERTEX_4</code>,
        /// <code>GL_MAP2_COLOR_4</code>,
        /// <code>GL_MAP2_INDEX</code>,
        /// <code>GL_MAP2_NORMAL</code>,
        /// <code>GL_MAP2_TEXTURE_COORD_1</code>,
        /// <code>GL_MAP2_TEXTURE_COORD_2</code>,
        /// <code>GL_MAP2_TEXTURE_COORD_3</code>,
        /// <code>GL_MAP2_TEXTURE_COORD_4</code>,
        /// <code>GL_MAP2_VERTEX_3</code>, and
        /// <code>GL_MAP2_VERTEX_4</code>.
        /// </para>
        /// </param>
        /// <param name="query">
        /// <para>
        /// Specifies which parameter to return.
        /// Symbolic names
        /// <code>GL_COEFF</code>,
        /// <code>GL_ORDER</code>, and
        /// <code>GL_DOMAIN</code> are accepted.
        /// </para>
        /// </param>
        /// <param name="v">
        /// Returns the requested data.
        /// </param>
        /// <seealso cref="glEvalCoord"/>
        /// <seealso cref="glMap1"/>
        /// <seealso cref="glMap2"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void glGetMapdv(uint target, uint query, double* v) {
            var _F = _GetProc<GLNativeDelegate.FNglGetMapdv>("glGetMapdv");
            _F(target, query, v);
        }
        /// <summary>
        /// return evaluator parameters
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// If an error is generated,
        /// no change is made to the contents of <paramref name="v"/>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if either <paramref name="target"/> or <paramref name="query"/> is not
        /// an accepted value.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glGetMap"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glGetMapfv(GLenum target, GLenum query, GLfloat * v);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the symbolic name of a map.
        /// Accepted values are
        /// <code>GL_MAP1_COLOR_4</code>,
        /// <code>GL_MAP1_INDEX</code>,
        /// <code>GL_MAP1_NORMAL</code>,
        /// <code>GL_MAP1_TEXTURE_COORD_1</code>,
        /// <code>GL_MAP1_TEXTURE_COORD_2</code>,
        /// <code>GL_MAP1_TEXTURE_COORD_3</code>,
        /// <code>GL_MAP1_TEXTURE_COORD_4</code>,
        /// <code>GL_MAP1_VERTEX_3</code>,
        /// <code>GL_MAP1_VERTEX_4</code>,
        /// <code>GL_MAP2_COLOR_4</code>,
        /// <code>GL_MAP2_INDEX</code>,
        /// <code>GL_MAP2_NORMAL</code>,
        /// <code>GL_MAP2_TEXTURE_COORD_1</code>,
        /// <code>GL_MAP2_TEXTURE_COORD_2</code>,
        /// <code>GL_MAP2_TEXTURE_COORD_3</code>,
        /// <code>GL_MAP2_TEXTURE_COORD_4</code>,
        /// <code>GL_MAP2_VERTEX_3</code>, and
        /// <code>GL_MAP2_VERTEX_4</code>.
        /// </para>
        /// </param>
        /// <param name="query">
        /// <para>
        /// Specifies which parameter to return.
        /// Symbolic names
        /// <code>GL_COEFF</code>,
        /// <code>GL_ORDER</code>, and
        /// <code>GL_DOMAIN</code> are accepted.
        /// </para>
        /// </param>
        /// <param name="v">
        /// Returns the requested data.
        /// </param>
        /// <seealso cref="glEvalCoord"/>
        /// <seealso cref="glMap1"/>
        /// <seealso cref="glMap2"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void glGetMapfv(uint target, uint query, float* v) {
            var _F = _GetProc<GLNativeDelegate.FNglGetMapfv>("glGetMapfv");
            _F(target, query, v);
        }
        /// <summary>
        /// return evaluator parameters
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// If an error is generated,
        /// no change is made to the contents of <paramref name="v"/>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if either <paramref name="target"/> or <paramref name="query"/> is not
        /// an accepted value.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glGetMap"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glGetMapiv(GLenum target, GLenum query, GLint * v);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the symbolic name of a map.
        /// Accepted values are
        /// <code>GL_MAP1_COLOR_4</code>,
        /// <code>GL_MAP1_INDEX</code>,
        /// <code>GL_MAP1_NORMAL</code>,
        /// <code>GL_MAP1_TEXTURE_COORD_1</code>,
        /// <code>GL_MAP1_TEXTURE_COORD_2</code>,
        /// <code>GL_MAP1_TEXTURE_COORD_3</code>,
        /// <code>GL_MAP1_TEXTURE_COORD_4</code>,
        /// <code>GL_MAP1_VERTEX_3</code>,
        /// <code>GL_MAP1_VERTEX_4</code>,
        /// <code>GL_MAP2_COLOR_4</code>,
        /// <code>GL_MAP2_INDEX</code>,
        /// <code>GL_MAP2_NORMAL</code>,
        /// <code>GL_MAP2_TEXTURE_COORD_1</code>,
        /// <code>GL_MAP2_TEXTURE_COORD_2</code>,
        /// <code>GL_MAP2_TEXTURE_COORD_3</code>,
        /// <code>GL_MAP2_TEXTURE_COORD_4</code>,
        /// <code>GL_MAP2_VERTEX_3</code>, and
        /// <code>GL_MAP2_VERTEX_4</code>.
        /// </para>
        /// </param>
        /// <param name="query">
        /// <para>
        /// Specifies which parameter to return.
        /// Symbolic names
        /// <code>GL_COEFF</code>,
        /// <code>GL_ORDER</code>, and
        /// <code>GL_DOMAIN</code> are accepted.
        /// </para>
        /// </param>
        /// <param name="v">
        /// Returns the requested data.
        /// </param>
        /// <seealso cref="glEvalCoord"/>
        /// <seealso cref="glMap1"/>
        /// <seealso cref="glMap2"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void glGetMapiv(uint target, uint query, int* v) {
            var _F = _GetProc<GLNativeDelegate.FNglGetMapiv>("glGetMapiv");
            _F(target, query, v);
        }
        /// <summary>
        /// return material parameters
        /// <para>Require:</para> <para>GL_VERSION_1_0, GL_VERSION_ES_CM_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// If an error is generated,
        /// no change is made to the contents of <paramref name="ps"/>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="face"/> or <paramref name="pname"/> is not an
        /// accepted value.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glGetMaterial"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glGetMaterialfv(GLenum face, GLenum pname, GLfloat * params);</para>
        /// </summary>
        /// <param name="face">
        /// <para>
        /// Specifies which of the two materials is being queried.
        /// <code>GL_FRONT</code> or <code>GL_BACK</code> are accepted,
        /// representing the front and back materials,
        /// respectively.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the material parameter to return.
        /// <code>GL_AMBIENT</code>,
        /// <code>GL_DIFFUSE</code>,
        /// <code>GL_SPECULAR</code>,
        /// <code>GL_EMISSION</code>,
        /// <code>GL_SHININESS</code>, and
        /// <code>GL_COLOR_INDEXES</code>
        /// are accepted.
        /// </para>
        /// </param>
        /// <param name="ps">
        /// Returns the requested data.
        /// </param>
        /// <seealso cref="glMaterial"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void glGetMaterialfv(uint face, uint pname, float* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetMaterialfv>("glGetMaterialfv");
            _F(face, pname, ps);
        }
        /// <summary>
        /// return material parameters
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// If an error is generated,
        /// no change is made to the contents of <paramref name="ps"/>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="face"/> or <paramref name="pname"/> is not an
        /// accepted value.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glGetMaterial"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glGetMaterialiv(GLenum face, GLenum pname, GLint * params);</para>
        /// </summary>
        /// <param name="face">
        /// <para>
        /// Specifies which of the two materials is being queried.
        /// <code>GL_FRONT</code> or <code>GL_BACK</code> are accepted,
        /// representing the front and back materials,
        /// respectively.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the material parameter to return.
        /// <code>GL_AMBIENT</code>,
        /// <code>GL_DIFFUSE</code>,
        /// <code>GL_SPECULAR</code>,
        /// <code>GL_EMISSION</code>,
        /// <code>GL_SHININESS</code>, and
        /// <code>GL_COLOR_INDEXES</code>
        /// are accepted.
        /// </para>
        /// </param>
        /// <param name="ps">
        /// Returns the requested data.
        /// </param>
        /// <seealso cref="glMaterial"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void glGetMaterialiv(uint face, uint pname, int* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetMaterialiv>("glGetMaterialiv");
            _F(face, pname, ps);
        }
        /// <summary>
        /// return the specified pixel map
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// If an error is generated,
        /// no change is made to the contents of <paramref name="data"/>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="map"/> is not an accepted value.
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_PACK_BUFFER</code> target and the buffer object's data store is currently mapped.
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_PACK_BUFFER</code> target and the data would be packed to the buffer 
        /// object such that the memory writes required would exceed the data store size.
        /// <code>GL_INVALID_OPERATION</code> is generated by <see cref="glGetPixelMapfv"/> if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_PACK_BUFFER</code> target and <paramref name="data"/> is not evenly divisible 
        /// into the number of bytes needed to store in memory a GLfloat datum.
        /// <code>GL_INVALID_OPERATION</code> is generated by <see cref="glGetPixelMapuiv"/> if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_PACK_BUFFER</code> target and <paramref name="data"/> is not evenly divisible 
        /// into the number of bytes needed to store in memory a GLuint datum.
        /// <code>GL_INVALID_OPERATION</code> is generated by <see cref="glGetPixelMapusv"/> if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_PACK_BUFFER</code> target and <paramref name="data"/> is not evenly divisible 
        /// into the number of bytes needed to store in memory a GLushort datum.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glGetPixelMap"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glGetPixelMapfv(GLenum map, GLfloat * data);</para>
        /// </summary>
        /// <param name="map">
        /// <para>
        /// Specifies the name of the pixel map to return.
        /// Accepted values are
        /// <code>GL_PIXEL_MAP_I_TO_I</code>,
        /// <code>GL_PIXEL_MAP_S_TO_S</code>,
        /// <code>GL_PIXEL_MAP_I_TO_R</code>,
        /// <code>GL_PIXEL_MAP_I_TO_G</code>,
        /// <code>GL_PIXEL_MAP_I_TO_B</code>,
        /// <code>GL_PIXEL_MAP_I_TO_A</code>,
        /// <code>GL_PIXEL_MAP_R_TO_R</code>,
        /// <code>GL_PIXEL_MAP_G_TO_G</code>,
        /// <code>GL_PIXEL_MAP_B_TO_B</code>, and
        /// <code>GL_PIXEL_MAP_A_TO_A</code>.
        /// </para>
        /// </param>
        /// <param name="data">
        /// Returns the pixel map contents.
        /// </param>
        /// <seealso cref="glColorSubTable"/>
        /// <seealso cref="glColorTable"/>
        /// <seealso cref="glConvolutionFilter1D"/>
        /// <seealso cref="glConvolutionFilter2D"/>
        /// <seealso cref="glCopyColorSubTable"/>
        /// <seealso cref="glCopyColorTable"/>
        /// <seealso cref="glCopyPixels"/>
        /// <seealso cref="glCopyTexImage1D"/>
        /// <seealso cref="glCopyTexImage2D"/>
        /// <seealso cref="glCopyTexSubImage1D"/>
        /// <seealso cref="glCopyTexSubImage2D"/>
        /// <seealso cref="glCopyTexSubImage3D"/>
        /// <seealso cref="glDrawPixels"/>
        /// <seealso cref="glGetHistogram"/>
        /// <seealso cref="glGetMinmax"/>
        /// <seealso cref="glGetTexImage"/>
        /// <seealso cref="glPixelMap"/>
        /// <seealso cref="glPixelTransfer"/>
        /// <seealso cref="glReadPixels"/>
        /// <seealso cref="glSeparableFilter2D"/>
        /// <seealso cref="glTexImage1D"/>
        /// <seealso cref="glTexImage1D"/>
        /// <seealso cref="glTexImage2D"/>
        /// <seealso cref="glTexImage2D"/>
        /// <seealso cref="glTexImage3D"/>
        /// <seealso cref="glTexSubImage1D"/>
        /// <seealso cref="glTexSubImage2D"/>
        /// <seealso cref="glTexSubImage3D"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void glGetPixelMapfv(uint map, float* data) {
            var _F = _GetProc<GLNativeDelegate.FNglGetPixelMapfv>("glGetPixelMapfv");
            _F(map, data);
        }
        /// <summary>
        /// return the specified pixel map
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// If an error is generated,
        /// no change is made to the contents of <paramref name="data"/>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="map"/> is not an accepted value.
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_PACK_BUFFER</code> target and the buffer object's data store is currently mapped.
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_PACK_BUFFER</code> target and the data would be packed to the buffer 
        /// object such that the memory writes required would exceed the data store size.
        /// <code>GL_INVALID_OPERATION</code> is generated by <see cref="glGetPixelMapfv"/> if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_PACK_BUFFER</code> target and <paramref name="data"/> is not evenly divisible 
        /// into the number of bytes needed to store in memory a GLfloat datum.
        /// <code>GL_INVALID_OPERATION</code> is generated by <see cref="glGetPixelMapuiv"/> if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_PACK_BUFFER</code> target and <paramref name="data"/> is not evenly divisible 
        /// into the number of bytes needed to store in memory a GLuint datum.
        /// <code>GL_INVALID_OPERATION</code> is generated by <see cref="glGetPixelMapusv"/> if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_PACK_BUFFER</code> target and <paramref name="data"/> is not evenly divisible 
        /// into the number of bytes needed to store in memory a GLushort datum.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glGetPixelMap"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glGetPixelMapuiv(GLenum map, GLuint * data);</para>
        /// </summary>
        /// <param name="map">
        /// <para>
        /// Specifies the name of the pixel map to return.
        /// Accepted values are
        /// <code>GL_PIXEL_MAP_I_TO_I</code>,
        /// <code>GL_PIXEL_MAP_S_TO_S</code>,
        /// <code>GL_PIXEL_MAP_I_TO_R</code>,
        /// <code>GL_PIXEL_MAP_I_TO_G</code>,
        /// <code>GL_PIXEL_MAP_I_TO_B</code>,
        /// <code>GL_PIXEL_MAP_I_TO_A</code>,
        /// <code>GL_PIXEL_MAP_R_TO_R</code>,
        /// <code>GL_PIXEL_MAP_G_TO_G</code>,
        /// <code>GL_PIXEL_MAP_B_TO_B</code>, and
        /// <code>GL_PIXEL_MAP_A_TO_A</code>.
        /// </para>
        /// </param>
        /// <param name="data">
        /// Returns the pixel map contents.
        /// </param>
        /// <seealso cref="glColorSubTable"/>
        /// <seealso cref="glColorTable"/>
        /// <seealso cref="glConvolutionFilter1D"/>
        /// <seealso cref="glConvolutionFilter2D"/>
        /// <seealso cref="glCopyColorSubTable"/>
        /// <seealso cref="glCopyColorTable"/>
        /// <seealso cref="glCopyPixels"/>
        /// <seealso cref="glCopyTexImage1D"/>
        /// <seealso cref="glCopyTexImage2D"/>
        /// <seealso cref="glCopyTexSubImage1D"/>
        /// <seealso cref="glCopyTexSubImage2D"/>
        /// <seealso cref="glCopyTexSubImage3D"/>
        /// <seealso cref="glDrawPixels"/>
        /// <seealso cref="glGetHistogram"/>
        /// <seealso cref="glGetMinmax"/>
        /// <seealso cref="glGetTexImage"/>
        /// <seealso cref="glPixelMap"/>
        /// <seealso cref="glPixelTransfer"/>
        /// <seealso cref="glReadPixels"/>
        /// <seealso cref="glSeparableFilter2D"/>
        /// <seealso cref="glTexImage1D"/>
        /// <seealso cref="glTexImage1D"/>
        /// <seealso cref="glTexImage2D"/>
        /// <seealso cref="glTexImage2D"/>
        /// <seealso cref="glTexImage3D"/>
        /// <seealso cref="glTexSubImage1D"/>
        /// <seealso cref="glTexSubImage2D"/>
        /// <seealso cref="glTexSubImage3D"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void glGetPixelMapuiv(uint map, uint* data) {
            var _F = _GetProc<GLNativeDelegate.FNglGetPixelMapuiv>("glGetPixelMapuiv");
            _F(map, data);
        }
        /// <summary>
        /// return the specified pixel map
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// If an error is generated,
        /// no change is made to the contents of <paramref name="data"/>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="map"/> is not an accepted value.
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_PACK_BUFFER</code> target and the buffer object's data store is currently mapped.
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_PACK_BUFFER</code> target and the data would be packed to the buffer 
        /// object such that the memory writes required would exceed the data store size.
        /// <code>GL_INVALID_OPERATION</code> is generated by <see cref="glGetPixelMapfv"/> if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_PACK_BUFFER</code> target and <paramref name="data"/> is not evenly divisible 
        /// into the number of bytes needed to store in memory a GLfloat datum.
        /// <code>GL_INVALID_OPERATION</code> is generated by <see cref="glGetPixelMapuiv"/> if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_PACK_BUFFER</code> target and <paramref name="data"/> is not evenly divisible 
        /// into the number of bytes needed to store in memory a GLuint datum.
        /// <code>GL_INVALID_OPERATION</code> is generated by <see cref="glGetPixelMapusv"/> if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_PACK_BUFFER</code> target and <paramref name="data"/> is not evenly divisible 
        /// into the number of bytes needed to store in memory a GLushort datum.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glGetPixelMap"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glGetPixelMapusv(GLenum map, GLushort * data);</para>
        /// </summary>
        /// <param name="map">
        /// <para>
        /// Specifies the name of the pixel map to return.
        /// Accepted values are
        /// <code>GL_PIXEL_MAP_I_TO_I</code>,
        /// <code>GL_PIXEL_MAP_S_TO_S</code>,
        /// <code>GL_PIXEL_MAP_I_TO_R</code>,
        /// <code>GL_PIXEL_MAP_I_TO_G</code>,
        /// <code>GL_PIXEL_MAP_I_TO_B</code>,
        /// <code>GL_PIXEL_MAP_I_TO_A</code>,
        /// <code>GL_PIXEL_MAP_R_TO_R</code>,
        /// <code>GL_PIXEL_MAP_G_TO_G</code>,
        /// <code>GL_PIXEL_MAP_B_TO_B</code>, and
        /// <code>GL_PIXEL_MAP_A_TO_A</code>.
        /// </para>
        /// </param>
        /// <param name="data">
        /// Returns the pixel map contents.
        /// </param>
        /// <seealso cref="glColorSubTable"/>
        /// <seealso cref="glColorTable"/>
        /// <seealso cref="glConvolutionFilter1D"/>
        /// <seealso cref="glConvolutionFilter2D"/>
        /// <seealso cref="glCopyColorSubTable"/>
        /// <seealso cref="glCopyColorTable"/>
        /// <seealso cref="glCopyPixels"/>
        /// <seealso cref="glCopyTexImage1D"/>
        /// <seealso cref="glCopyTexImage2D"/>
        /// <seealso cref="glCopyTexSubImage1D"/>
        /// <seealso cref="glCopyTexSubImage2D"/>
        /// <seealso cref="glCopyTexSubImage3D"/>
        /// <seealso cref="glDrawPixels"/>
        /// <seealso cref="glGetHistogram"/>
        /// <seealso cref="glGetMinmax"/>
        /// <seealso cref="glGetTexImage"/>
        /// <seealso cref="glPixelMap"/>
        /// <seealso cref="glPixelTransfer"/>
        /// <seealso cref="glReadPixels"/>
        /// <seealso cref="glSeparableFilter2D"/>
        /// <seealso cref="glTexImage1D"/>
        /// <seealso cref="glTexImage1D"/>
        /// <seealso cref="glTexImage2D"/>
        /// <seealso cref="glTexImage2D"/>
        /// <seealso cref="glTexImage3D"/>
        /// <seealso cref="glTexSubImage1D"/>
        /// <seealso cref="glTexSubImage2D"/>
        /// <seealso cref="glTexSubImage3D"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void glGetPixelMapusv(uint map, ushort* data) {
            var _F = _GetProc<GLNativeDelegate.FNglGetPixelMapusv>("glGetPixelMapusv");
            _F(map, data);
        }
        /// <summary>
        /// return the polygon stipple pattern
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// If an error is generated,
        /// no change is made to the contents of <paramref name="pattern"/>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_PACK_BUFFER</code> target and the buffer object's data store is currently mapped.
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_PACK_BUFFER</code> target and the data would be packed to the buffer 
        /// object such that the memory writes required would exceed the data store size.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glGetPolygonStipple"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glGetPolygonStipple(GLubyte * pattern);</para>
        /// </summary>
        /// <param name="pattern">
        /// Returns the stipple pattern. The initial value is all 1's.
        /// </param>
        /// <seealso cref="glPixelStore"/>
        /// <seealso cref="glPixelTransfer"/>
        /// <seealso cref="glPolygonStipple"/>
        /// <seealso cref="glReadPixels"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void glGetPolygonStipple(byte* pattern) {
            var _F = _GetProc<GLNativeDelegate.FNglGetPolygonStipple>("glGetPolygonStipple");
            _F(pattern);
        }
        /// <summary>
        /// return texture environment parameters
        /// <para>Require:</para> <para>GL_VERSION_1_0, GL_VERSION_ES_CM_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// If an error is generated,
        /// no change is made to the contents of <paramref name="ps"/>.
        /// For OpenGL versions 1.3 and greater, or when the <code>ARB_multitexture</code> extension is supported, <see cref="glGetTexEnv"/> returns
        /// the texture environment parameters for the active texture unit.
        /// <code>GL_COMBINE_RGB</code>,
        /// <code>GL_COMBINE_ALPHA</code>,
        /// <code>GL_SRC0_RGB</code>,
        /// <code>GL_SRC1_RGB</code>,
        /// <code>GL_SRC2_RGB</code>,
        /// <code>GL_SRC0_ALPHA</code>,
        /// <code>GL_SRC1_ALPHA</code>,
        /// <code>GL_SRC2_ALPHA</code>,
        /// <code>GL_OPERAND0_RGB</code>,
        /// <code>GL_OPERAND1_RGB</code>,
        /// <code>GL_OPERAND2_RGB</code>,
        /// <code>GL_OPERAND0_ALPHA</code>,
        /// <code>GL_OPERAND1_ALPHA</code>,
        /// <code>GL_OPERAND2_ALPHA</code>,
        /// <code>GL_RGB_SCALE</code>, and
        /// <code>GL_ALPHA_SCALE</code> are available only if the GL version is 1.3 or greater.
        /// <code>GL_TEXTURE_FILTER_CONTROL</code> and <code>GL_TEXTURE_LOD_BIAS</code> are available
        /// only if the GL version is 1.4 or greater.
        /// <code>GL_POINT_SPRITE</code> and <code>GL_COORD_REPLACE</code> are available
        /// only if the GL version is 2.0 or greater.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="target"/> or <paramref name="pname"/> is not an
        /// accepted value.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glGetTexEnv"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glGetTexEnvfv(GLenum target, GLenum pname, GLfloat * params);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies a texture environment. May be
        /// <code>GL_TEXTURE_ENV</code>,
        /// <code>GL_TEXTURE_FILTER_CONTROL</code>, or
        /// <code>GL_POINT_SPRITE</code>.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of a texture environment parameter.
        /// Accepted values are <code>GL_TEXTURE_ENV_MODE</code>, <code>GL_TEXTURE_ENV_COLOR</code>,
        /// <code>GL_TEXTURE_LOD_BIAS</code>,
        /// <code>GL_COMBINE_RGB</code>,
        /// <code>GL_COMBINE_ALPHA</code>,
        /// <code>GL_SRC0_RGB</code>,
        /// <code>GL_SRC1_RGB</code>,
        /// <code>GL_SRC2_RGB</code>,
        /// <code>GL_SRC0_ALPHA</code>,
        /// <code>GL_SRC1_ALPHA</code>,
        /// <code>GL_SRC2_ALPHA</code>,
        /// <code>GL_OPERAND0_RGB</code>,
        /// <code>GL_OPERAND1_RGB</code>,
        /// <code>GL_OPERAND2_RGB</code>,
        /// <code>GL_OPERAND0_ALPHA</code>,
        /// <code>GL_OPERAND1_ALPHA</code>,
        /// <code>GL_OPERAND2_ALPHA</code>,
        /// <code>GL_RGB_SCALE</code>,
        /// <code>GL_ALPHA_SCALE</code>, or
        /// <code>GL_COORD_REPLACE</code>.
        /// </para>
        /// </param>
        /// <param name="ps">
        /// Returns the requested data.
        /// </param>
        /// <seealso cref="glActiveTexture"/>
        /// <seealso cref="glTexEnv"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void glGetTexEnvfv(uint target, uint pname, float* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetTexEnvfv>("glGetTexEnvfv");
            _F(target, pname, ps);
        }
        /// <summary>
        /// return texture environment parameters
        /// <para>Require:</para> <para>GL_VERSION_1_0, GL_VERSION_ES_CM_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// If an error is generated,
        /// no change is made to the contents of <paramref name="ps"/>.
        /// For OpenGL versions 1.3 and greater, or when the <code>ARB_multitexture</code> extension is supported, <see cref="glGetTexEnv"/> returns
        /// the texture environment parameters for the active texture unit.
        /// <code>GL_COMBINE_RGB</code>,
        /// <code>GL_COMBINE_ALPHA</code>,
        /// <code>GL_SRC0_RGB</code>,
        /// <code>GL_SRC1_RGB</code>,
        /// <code>GL_SRC2_RGB</code>,
        /// <code>GL_SRC0_ALPHA</code>,
        /// <code>GL_SRC1_ALPHA</code>,
        /// <code>GL_SRC2_ALPHA</code>,
        /// <code>GL_OPERAND0_RGB</code>,
        /// <code>GL_OPERAND1_RGB</code>,
        /// <code>GL_OPERAND2_RGB</code>,
        /// <code>GL_OPERAND0_ALPHA</code>,
        /// <code>GL_OPERAND1_ALPHA</code>,
        /// <code>GL_OPERAND2_ALPHA</code>,
        /// <code>GL_RGB_SCALE</code>, and
        /// <code>GL_ALPHA_SCALE</code> are available only if the GL version is 1.3 or greater.
        /// <code>GL_TEXTURE_FILTER_CONTROL</code> and <code>GL_TEXTURE_LOD_BIAS</code> are available
        /// only if the GL version is 1.4 or greater.
        /// <code>GL_POINT_SPRITE</code> and <code>GL_COORD_REPLACE</code> are available
        /// only if the GL version is 2.0 or greater.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="target"/> or <paramref name="pname"/> is not an
        /// accepted value.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glGetTexEnv"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glGetTexEnviv(GLenum target, GLenum pname, GLint * params);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies a texture environment. May be
        /// <code>GL_TEXTURE_ENV</code>,
        /// <code>GL_TEXTURE_FILTER_CONTROL</code>, or
        /// <code>GL_POINT_SPRITE</code>.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of a texture environment parameter.
        /// Accepted values are <code>GL_TEXTURE_ENV_MODE</code>, <code>GL_TEXTURE_ENV_COLOR</code>,
        /// <code>GL_TEXTURE_LOD_BIAS</code>,
        /// <code>GL_COMBINE_RGB</code>,
        /// <code>GL_COMBINE_ALPHA</code>,
        /// <code>GL_SRC0_RGB</code>,
        /// <code>GL_SRC1_RGB</code>,
        /// <code>GL_SRC2_RGB</code>,
        /// <code>GL_SRC0_ALPHA</code>,
        /// <code>GL_SRC1_ALPHA</code>,
        /// <code>GL_SRC2_ALPHA</code>,
        /// <code>GL_OPERAND0_RGB</code>,
        /// <code>GL_OPERAND1_RGB</code>,
        /// <code>GL_OPERAND2_RGB</code>,
        /// <code>GL_OPERAND0_ALPHA</code>,
        /// <code>GL_OPERAND1_ALPHA</code>,
        /// <code>GL_OPERAND2_ALPHA</code>,
        /// <code>GL_RGB_SCALE</code>,
        /// <code>GL_ALPHA_SCALE</code>, or
        /// <code>GL_COORD_REPLACE</code>.
        /// </para>
        /// </param>
        /// <param name="ps">
        /// Returns the requested data.
        /// </param>
        /// <seealso cref="glActiveTexture"/>
        /// <seealso cref="glTexEnv"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void glGetTexEnviv(uint target, uint pname, int* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetTexEnviv>("glGetTexEnviv");
            _F(target, pname, ps);
        }
        /// <summary>
        /// return texture coordinate generation parameters
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// If an error is generated,
        /// no change is made to the contents of <paramref name="ps"/>.
        /// For OpenGL versions 1.3 and greater, or when the <code>ARB_multitexture</code> extension is supported, <see cref="glGetTexGen"/> returns
        /// the texture coordinate generation parameters for the active texture unit.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="coord"/> or <paramref name="pname"/> is not an
        /// accepted value.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glGetTexGen"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glGetTexGendv(GLenum coord, GLenum pname, GLdouble * params);</para>
        /// </summary>
        /// <param name="coord">
        /// <para>
        /// Specifies a texture coordinate.
        /// Must be
        /// <code>GL_S</code>,
        /// <code>GL_T</code>,
        /// <code>GL_R</code>, or
        /// <code>GL_Q</code>.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of the value(s) to be returned.
        /// Must be either <code>GL_TEXTURE_GEN_MODE</code>
        /// or the name of one of the texture generation plane equations:
        /// <code>GL_OBJECT_PLANE</code> or <code>GL_EYE_PLANE</code>.
        /// </para>
        /// </param>
        /// <param name="ps">
        /// Returns the requested data.
        /// </param>
        /// <seealso cref="glActiveTexture"/>
        /// <seealso cref="glTexGen"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void glGetTexGendv(uint coord, uint pname, double* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetTexGendv>("glGetTexGendv");
            _F(coord, pname, ps);
        }
        /// <summary>
        /// return texture coordinate generation parameters
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// If an error is generated,
        /// no change is made to the contents of <paramref name="ps"/>.
        /// For OpenGL versions 1.3 and greater, or when the <code>ARB_multitexture</code> extension is supported, <see cref="glGetTexGen"/> returns
        /// the texture coordinate generation parameters for the active texture unit.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="coord"/> or <paramref name="pname"/> is not an
        /// accepted value.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glGetTexGen"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glGetTexGenfv(GLenum coord, GLenum pname, GLfloat * params);</para>
        /// </summary>
        /// <param name="coord">
        /// <para>
        /// Specifies a texture coordinate.
        /// Must be
        /// <code>GL_S</code>,
        /// <code>GL_T</code>,
        /// <code>GL_R</code>, or
        /// <code>GL_Q</code>.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of the value(s) to be returned.
        /// Must be either <code>GL_TEXTURE_GEN_MODE</code>
        /// or the name of one of the texture generation plane equations:
        /// <code>GL_OBJECT_PLANE</code> or <code>GL_EYE_PLANE</code>.
        /// </para>
        /// </param>
        /// <param name="ps">
        /// Returns the requested data.
        /// </param>
        /// <seealso cref="glActiveTexture"/>
        /// <seealso cref="glTexGen"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void glGetTexGenfv(uint coord, uint pname, float* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetTexGenfv>("glGetTexGenfv");
            _F(coord, pname, ps);
        }
        /// <summary>
        /// return texture coordinate generation parameters
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// If an error is generated,
        /// no change is made to the contents of <paramref name="ps"/>.
        /// For OpenGL versions 1.3 and greater, or when the <code>ARB_multitexture</code> extension is supported, <see cref="glGetTexGen"/> returns
        /// the texture coordinate generation parameters for the active texture unit.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="coord"/> or <paramref name="pname"/> is not an
        /// accepted value.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glGetTexGen"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glGetTexGeniv(GLenum coord, GLenum pname, GLint * params);</para>
        /// </summary>
        /// <param name="coord">
        /// <para>
        /// Specifies a texture coordinate.
        /// Must be
        /// <code>GL_S</code>,
        /// <code>GL_T</code>,
        /// <code>GL_R</code>, or
        /// <code>GL_Q</code>.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of the value(s) to be returned.
        /// Must be either <code>GL_TEXTURE_GEN_MODE</code>
        /// or the name of one of the texture generation plane equations:
        /// <code>GL_OBJECT_PLANE</code> or <code>GL_EYE_PLANE</code>.
        /// </para>
        /// </param>
        /// <param name="ps">
        /// Returns the requested data.
        /// </param>
        /// <seealso cref="glActiveTexture"/>
        /// <seealso cref="glTexGen"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void glGetTexGeniv(uint coord, uint pname, int* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetTexGeniv>("glGetTexGeniv");
            _F(coord, pname, ps);
        }
        /// <summary>
        /// determine if a name corresponds to a display list
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glIsList"/>
        /// is executed between the execution of
        /// <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>GLboolean glIsList(GLuint list);</para>
        /// </summary>
        /// <param name="list">
        /// Specifies a potential display list name.
        /// </param>
        /// <seealso cref="glCallList"/>
        /// <seealso cref="glCallLists"/>
        /// <seealso cref="glDeleteLists"/>
        /// <seealso cref="glGenLists"/>
        /// <seealso cref="glNewList"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static bool glIsList(uint list) {
            var _F = _GetProc<GLNativeDelegate.FNglIsList>("glIsList");
            return _F(list);
        }
        /// <summary>
        /// multiply the current matrix by a perspective matrix
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// Depth buffer precision is affected by the values specified for
        /// <paramref name="nearVal"/> and <paramref name="farVal"/>.
        /// The greater the ratio of <paramref name="farVal"/> to <paramref name="nearVal"/> is,
        /// the less effective the depth buffer will be at distinguishing between
        /// surfaces that are near each other.
        /// If
        /// r 
        /// = 
        /// farVal 
        /// nearVal 
        /// roughly 
        /// log 
        /// 2 
        /// &af; 
        /// r 
        /// bits of depth buffer precision are lost.
        /// Because 
        /// r   
        /// approaches infinity as <paramref name="nearVal"/> approaches 0,
        /// <paramref name="nearVal"/> must never be set to 0.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="nearVal"/> or <paramref name="farVal"/> is not
        /// positive, or if <paramref name="left"/> = <paramref name="right"/>, or <paramref name="bottom"/> = <paramref name="top"/>,
        /// or <paramref name="near"/> = <paramref name="far"/>.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glFrustum"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glFrustum(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble nearVal, GLdouble farVal);</para>
        /// </summary>
        /// <param name="left">
        /// Specify the coordinates for the left and right vertical clipping planes.
        /// </param>
        /// <param name="right">
        /// Specify the coordinates for the left and right vertical clipping planes.
        /// </param>
        /// <param name="bottom">
        /// Specify the coordinates for the bottom and top horizontal clipping planes.
        /// </param>
        /// <param name="top">
        /// Specify the coordinates for the bottom and top horizontal clipping planes.
        /// </param>
        /// <param name="nearVal">
        /// <para>
        /// Specify the distances to the near and far depth clipping planes.
        /// Both distances must be positive.
        /// </para>
        /// </param>
        /// <param name="farVal">
        /// <para>
        /// Specify the distances to the near and far depth clipping planes.
        /// Both distances must be positive.
        /// </para>
        /// </param>
        /// <seealso cref="glOrtho"/>
        /// <seealso cref="glMatrixMode"/>
        /// <seealso cref="glMultMatrix"/>
        /// <seealso cref="glPushMatrix"/>
        /// <seealso cref="glViewport"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void glFrustum(double left, double right, double bottom, double top, double nearVal, double farVal) {
            var _F = _GetProc<GLNativeDelegate.FNglFrustum>("glFrustum");
            _F(left, right, bottom, top, nearVal, farVal);
        }
        /// <summary>
        /// replace the current matrix with the identity matrix
        /// <para>Require:</para> <para>GL_VERSION_1_0, GL_VERSION_ES_CM_1_0</para>
        /// Supported: <para>GL</para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glLoadIdentity"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glLoadIdentity();</para>
        /// </summary>
        /// <seealso cref="glLoadMatrix"/>
        /// <seealso cref="glLoadTransposeMatrix"/>
        /// <seealso cref="glMatrixMode"/>
        /// <seealso cref="glMultMatrix"/>
        /// <seealso cref="glMultTransposeMatrix"/>
        /// <seealso cref="glPushMatrix"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void glLoadIdentity() {
            var _F = _GetProc<GLNativeDelegate.FNglLoadIdentity>("glLoadIdentity");
            _F();
        }
        /// <summary>
        /// replace the current matrix with the specified matrix
        /// <para>Require:</para> <para>GL_VERSION_1_0, GL_VERSION_ES_CM_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// While the elements of the matrix may be specified with
        /// single or double precision, the GL implementation may
        /// store or operate on these values in less than single
        /// precision.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glLoadMatrix"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glLoadMatrixf(const GLfloat * m);</para>
        /// </summary>
        /// <param name="m">
        /// <para>
        /// Specifies a pointer to 16 consecutive values, which are used as the
        /// elements of a 
        /// 4 
        /// &times; 
        /// 4 
        /// column-major matrix.
        /// </para>
        /// </param>
        /// <seealso cref="glLoadIdentity"/>
        /// <seealso cref="glMatrixMode"/>
        /// <seealso cref="glMultMatrix"/>
        /// <seealso cref="glMultTransposeMatrix"/>
        /// <seealso cref="glPushMatrix"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void glLoadMatrixf(float* m) {
            var _F = _GetProc<GLNativeDelegate.FNglLoadMatrixf>("glLoadMatrixf");
            _F(m);
        }
        /// <summary>
        /// replace the current matrix with the specified matrix
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// While the elements of the matrix may be specified with
        /// single or double precision, the GL implementation may
        /// store or operate on these values in less than single
        /// precision.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glLoadMatrix"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glLoadMatrixd(const GLdouble * m);</para>
        /// </summary>
        /// <param name="m">
        /// <para>
        /// Specifies a pointer to 16 consecutive values, which are used as the
        /// elements of a 
        /// 4 
        /// &times; 
        /// 4 
        /// column-major matrix.
        /// </para>
        /// </param>
        /// <seealso cref="glLoadIdentity"/>
        /// <seealso cref="glMatrixMode"/>
        /// <seealso cref="glMultMatrix"/>
        /// <seealso cref="glMultTransposeMatrix"/>
        /// <seealso cref="glPushMatrix"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void glLoadMatrixd(double* m) {
            var _F = _GetProc<GLNativeDelegate.FNglLoadMatrixd>("glLoadMatrixd");
            _F(m);
        }
        /// <summary>
        /// specify which matrix is the current matrix
        /// <para>Require:</para> <para>GL_VERSION_1_0, GL_VERSION_ES_CM_1_0</para>
        /// Supported: <para>GL</para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="mode"/> is not an accepted value.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glMatrixMode"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glMatrixMode(GLenum mode);</para>
        /// </summary>
        /// <param name="mode">
        /// <para>
        /// Specifies which matrix stack is the target
        /// for subsequent matrix operations.
        /// Three values are accepted:
        /// <code>GL_MODELVIEW</code>,
        /// <code>GL_PROJECTION</code>, and
        /// <code>GL_TEXTURE</code>.
        /// The initial value is <code>GL_MODELVIEW</code>.
        /// Additionally, if the <code>ARB_imaging</code> extension is supported,
        /// <code>GL_COLOR</code> is also accepted.
        /// </para>
        /// </param>
        /// <seealso cref="glLoadMatrix"/>
        /// <seealso cref="glLoadTransposeMatrix"/>
        /// <seealso cref="glMultMatrix"/>
        /// <seealso cref="glMultTransposeMatrix"/>
        /// <seealso cref="glPopMatrix"/>
        /// <seealso cref="glPushMatrix"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void glMatrixMode(uint mode) {
            var _F = _GetProc<GLNativeDelegate.FNglMatrixMode>("glMatrixMode");
            _F(mode);
        }
        /// <summary>
        /// multiply the current matrix with the specified matrix
        /// <para>Require:</para> <para>GL_VERSION_1_0, GL_VERSION_ES_CM_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// While the elements of the matrix may be specified with
        /// single or double precision, the GL may store or operate on these
        /// values in less-than-single precision.
        /// In many computer languages, 
        /// 4 
        /// &times; 
        /// 4 
        /// arrays are represented
        /// in row-major order. The transformations just described
        /// represent these matrices in column-major order.
        /// The order of the multiplication is important. For example, if the current
        /// transformation is a rotation, and <see cref="glMultMatrix"/> is called with a translation matrix,
        /// the translation is done directly on the coordinates to be transformed,
        /// while the rotation is done on the results of that translation.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glMultMatrix"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glMultMatrixf(const GLfloat * m);</para>
        /// </summary>
        /// <param name="m">
        /// <para>
        /// Points to 16 consecutive values that are used as the elements of
        /// a 
        /// 4 
        /// &times; 
        /// 4 
        /// column-major matrix.
        /// </para>
        /// </param>
        /// <seealso cref="glLoadIdentity"/>
        /// <seealso cref="glLoadMatrix"/>
        /// <seealso cref="glLoadTransposeMatrix"/>
        /// <seealso cref="glMatrixMode"/>
        /// <seealso cref="glMultTransposeMatrix"/>
        /// <seealso cref="glPushMatrix"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void glMultMatrixf(float* m) {
            var _F = _GetProc<GLNativeDelegate.FNglMultMatrixf>("glMultMatrixf");
            _F(m);
        }
        /// <summary>
        /// multiply the current matrix with the specified matrix
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// While the elements of the matrix may be specified with
        /// single or double precision, the GL may store or operate on these
        /// values in less-than-single precision.
        /// In many computer languages, 
        /// 4 
        /// &times; 
        /// 4 
        /// arrays are represented
        /// in row-major order. The transformations just described
        /// represent these matrices in column-major order.
        /// The order of the multiplication is important. For example, if the current
        /// transformation is a rotation, and <see cref="glMultMatrix"/> is called with a translation matrix,
        /// the translation is done directly on the coordinates to be transformed,
        /// while the rotation is done on the results of that translation.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glMultMatrix"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glMultMatrixd(const GLdouble * m);</para>
        /// </summary>
        /// <param name="m">
        /// <para>
        /// Points to 16 consecutive values that are used as the elements of
        /// a 
        /// 4 
        /// &times; 
        /// 4 
        /// column-major matrix.
        /// </para>
        /// </param>
        /// <seealso cref="glLoadIdentity"/>
        /// <seealso cref="glLoadMatrix"/>
        /// <seealso cref="glLoadTransposeMatrix"/>
        /// <seealso cref="glMatrixMode"/>
        /// <seealso cref="glMultTransposeMatrix"/>
        /// <seealso cref="glPushMatrix"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public unsafe static void glMultMatrixd(double* m) {
            var _F = _GetProc<GLNativeDelegate.FNglMultMatrixd>("glMultMatrixd");
            _F(m);
        }
        /// <summary>
        /// multiply the current matrix with an orthographic matrix
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="left"/> = <paramref name="right"/>, or
        /// <paramref name="bottom"/> = <paramref name="top"/>, or
        /// <paramref name="near"/> = <paramref name="far"/>.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glOrtho"/>
        /// is executed between the execution of
        /// <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glOrtho(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble nearVal, GLdouble farVal);</para>
        /// </summary>
        /// <param name="left">
        /// Specify the coordinates for the left and right vertical clipping planes.
        /// </param>
        /// <param name="right">
        /// Specify the coordinates for the left and right vertical clipping planes.
        /// </param>
        /// <param name="bottom">
        /// Specify the coordinates for the bottom and top horizontal clipping planes.
        /// </param>
        /// <param name="top">
        /// Specify the coordinates for the bottom and top horizontal clipping planes.
        /// </param>
        /// <param name="nearVal">
        /// <para>
        /// Specify the distances to the nearer and farther depth clipping planes.
        /// These values are negative if the plane is to be behind the viewer.
        /// </para>
        /// </param>
        /// <param name="farVal">
        /// <para>
        /// Specify the distances to the nearer and farther depth clipping planes.
        /// These values are negative if the plane is to be behind the viewer.
        /// </para>
        /// </param>
        /// <seealso cref="glFrustum"/>
        /// <seealso cref="glMatrixMode"/>
        /// <seealso cref="glMultMatrix"/>
        /// <seealso cref="glPushMatrix"/>
        /// <seealso cref="glViewport"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void glOrtho(double left, double right, double bottom, double top, double nearVal, double farVal) {
            var _F = _GetProc<GLNativeDelegate.FNglOrtho>("glOrtho");
            _F(left, right, bottom, top, nearVal, farVal);
        }
        /// <summary>
        /// push and pop the current matrix stack
        /// <para>Require:</para> <para>GL_VERSION_1_0, GL_VERSION_ES_CM_1_0</para>
        /// Supported: <para>GL</para>
        /// Errors: 
        /// <para>
        /// <code>GL_STACK_OVERFLOW</code> is generated if <see cref="glPushMatrix"/> is called while
        /// the current matrix stack is full.
        /// <code>GL_STACK_UNDERFLOW</code> is generated if  <see cref="glPopMatrix"/>  is called while
        /// the current matrix stack contains only a single matrix.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glPushMatrix"/> or  <see cref="glPopMatrix"/> 
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glPopMatrix();</para>
        /// </summary>
        /// <seealso cref="glFrustum"/>
        /// <seealso cref="glLoadIdentity"/>
        /// <seealso cref="glLoadMatrix"/>
        /// <seealso cref="glLoadTransposeMatrix"/>
        /// <seealso cref="glMatrixMode"/>
        /// <seealso cref="glMultMatrix"/>
        /// <seealso cref="glMultTransposeMatrix"/>
        /// <seealso cref="glOrtho"/>
        /// <seealso cref="glRotate"/>
        /// <seealso cref="glScale"/>
        /// <seealso cref="glTranslate"/>
        /// <seealso cref="glViewport"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void glPopMatrix() {
            var _F = _GetProc<GLNativeDelegate.FNglPopMatrix>("glPopMatrix");
            _F();
        }
        /// <summary>
        /// push and pop the current matrix stack
        /// <para>Require:</para> <para>GL_VERSION_1_0, GL_VERSION_ES_CM_1_0</para>
        /// Supported: <para>GL</para>
        /// Errors: 
        /// <para>
        /// <code>GL_STACK_OVERFLOW</code> is generated if <see cref="glPushMatrix"/> is called while
        /// the current matrix stack is full.
        /// <code>GL_STACK_UNDERFLOW</code> is generated if  <see cref="glPopMatrix"/>  is called while
        /// the current matrix stack contains only a single matrix.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glPushMatrix"/> or  <see cref="glPopMatrix"/> 
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glPushMatrix();</para>
        /// </summary>
        /// <seealso cref="glFrustum"/>
        /// <seealso cref="glLoadIdentity"/>
        /// <seealso cref="glLoadMatrix"/>
        /// <seealso cref="glLoadTransposeMatrix"/>
        /// <seealso cref="glMatrixMode"/>
        /// <seealso cref="glMultMatrix"/>
        /// <seealso cref="glMultTransposeMatrix"/>
        /// <seealso cref="glOrtho"/>
        /// <seealso cref="glRotate"/>
        /// <seealso cref="glScale"/>
        /// <seealso cref="glTranslate"/>
        /// <seealso cref="glViewport"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void glPushMatrix() {
            var _F = _GetProc<GLNativeDelegate.FNglPushMatrix>("glPushMatrix");
            _F();
        }
        /// <summary>
        /// multiply the current matrix by a rotation matrix
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// This rotation follows the right-hand rule, so
        /// if the vector 
        /// x 
        /// y 
        /// z 
        /// points toward the
        /// user, the rotation will be counterclockwise.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glRotate"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glRotated(GLdouble angle, GLdouble x, GLdouble y, GLdouble z);</para>
        /// </summary>
        /// <param name="angle">
        /// Specifies the angle of rotation, in degrees.
        /// </param>
        /// <param name="x">
        /// Specify the  x ,  y , and  z  coordinates of a vector, respectively.
        /// </param>
        /// <param name="y">
        /// Specify the  x ,  y , and  z  coordinates of a vector, respectively.
        /// </param>
        /// <param name="z">
        /// Specify the  x ,  y , and  z  coordinates of a vector, respectively.
        /// </param>
        /// <seealso cref="glMatrixMode"/>
        /// <seealso cref="glMultMatrix"/>
        /// <seealso cref="glPushMatrix"/>
        /// <seealso cref="glScale"/>
        /// <seealso cref="glTranslate"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void glRotated(double angle, double x, double y, double z) {
            var _F = _GetProc<GLNativeDelegate.FNglRotated>("glRotated");
            _F(angle, x, y, z);
        }
        /// <summary>
        /// multiply the current matrix by a rotation matrix
        /// <para>Require:</para> <para>GL_VERSION_1_0, GL_VERSION_ES_CM_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// This rotation follows the right-hand rule, so
        /// if the vector 
        /// x 
        /// y 
        /// z 
        /// points toward the
        /// user, the rotation will be counterclockwise.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glRotate"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glRotatef(GLfloat angle, GLfloat x, GLfloat y, GLfloat z);</para>
        /// </summary>
        /// <param name="angle">
        /// Specifies the angle of rotation, in degrees.
        /// </param>
        /// <param name="x">
        /// Specify the  x ,  y , and  z  coordinates of a vector, respectively.
        /// </param>
        /// <param name="y">
        /// Specify the  x ,  y , and  z  coordinates of a vector, respectively.
        /// </param>
        /// <param name="z">
        /// Specify the  x ,  y , and  z  coordinates of a vector, respectively.
        /// </param>
        /// <seealso cref="glMatrixMode"/>
        /// <seealso cref="glMultMatrix"/>
        /// <seealso cref="glPushMatrix"/>
        /// <seealso cref="glScale"/>
        /// <seealso cref="glTranslate"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void glRotatef(float angle, float x, float y, float z) {
            var _F = _GetProc<GLNativeDelegate.FNglRotatef>("glRotatef");
            _F(angle, x, y, z);
        }
        /// <summary>
        /// multiply the current matrix by a general scaling matrix
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// If scale factors other than 1 are applied to the modelview matrix
        /// and lighting is enabled, lighting often appears wrong.
        /// In that case, enable automatic normalization of normals by
        /// calling  <see cref="glEnable"/>  with the argument <code>GL_NORMALIZE</code>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glScale"/>
        /// is executed between the execution of
        /// <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glScaled(GLdouble x, GLdouble y, GLdouble z);</para>
        /// </summary>
        /// <param name="x">
        /// Specify scale factors along the  x ,  y , and  z  axes, respectively.
        /// </param>
        /// <param name="y">
        /// Specify scale factors along the  x ,  y , and  z  axes, respectively.
        /// </param>
        /// <param name="z">
        /// Specify scale factors along the  x ,  y , and  z  axes, respectively.
        /// </param>
        /// <seealso cref="glMatrixMode"/>
        /// <seealso cref="glMultMatrix"/>
        /// <seealso cref="glPushMatrix"/>
        /// <seealso cref="glRotate"/>
        /// <seealso cref="glTranslate"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void glScaled(double x, double y, double z) {
            var _F = _GetProc<GLNativeDelegate.FNglScaled>("glScaled");
            _F(x, y, z);
        }
        /// <summary>
        /// multiply the current matrix by a general scaling matrix
        /// <para>Require:</para> <para>GL_VERSION_1_0, GL_VERSION_ES_CM_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// If scale factors other than 1 are applied to the modelview matrix
        /// and lighting is enabled, lighting often appears wrong.
        /// In that case, enable automatic normalization of normals by
        /// calling  <see cref="glEnable"/>  with the argument <code>GL_NORMALIZE</code>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glScale"/>
        /// is executed between the execution of
        /// <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glScalef(GLfloat x, GLfloat y, GLfloat z);</para>
        /// </summary>
        /// <param name="x">
        /// Specify scale factors along the  x ,  y , and  z  axes, respectively.
        /// </param>
        /// <param name="y">
        /// Specify scale factors along the  x ,  y , and  z  axes, respectively.
        /// </param>
        /// <param name="z">
        /// Specify scale factors along the  x ,  y , and  z  axes, respectively.
        /// </param>
        /// <seealso cref="glMatrixMode"/>
        /// <seealso cref="glMultMatrix"/>
        /// <seealso cref="glPushMatrix"/>
        /// <seealso cref="glRotate"/>
        /// <seealso cref="glTranslate"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void glScalef(float x, float y, float z) {
            var _F = _GetProc<GLNativeDelegate.FNglScalef>("glScalef");
            _F(x, y, z);
        }
        /// <summary>
        /// multiply the current matrix by a translation matrix
        /// <para>Require:</para> <para>GL_VERSION_1_0</para>
        /// Supported: <para>GL</para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glTranslate"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glTranslated(GLdouble x, GLdouble y, GLdouble z);</para>
        /// </summary>
        /// <param name="x">
        /// Specify the  x ,  y , and  z  coordinates of a translation vector.
        /// </param>
        /// <param name="y">
        /// Specify the  x ,  y , and  z  coordinates of a translation vector.
        /// </param>
        /// <param name="z">
        /// Specify the  x ,  y , and  z  coordinates of a translation vector.
        /// </param>
        /// <seealso cref="glMatrixMode"/>
        /// <seealso cref="glMultMatrix"/>
        /// <seealso cref="glPushMatrix"/>
        /// <seealso cref="glRotate"/>
        /// <seealso cref="glScale"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void glTranslated(double x, double y, double z) {
            var _F = _GetProc<GLNativeDelegate.FNglTranslated>("glTranslated");
            _F(x, y, z);
        }
        /// <summary>
        /// multiply the current matrix by a translation matrix
        /// <para>Require:</para> <para>GL_VERSION_1_0, GL_VERSION_ES_CM_1_0</para>
        /// Supported: <para>GL</para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glTranslate"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glTranslatef(GLfloat x, GLfloat y, GLfloat z);</para>
        /// </summary>
        /// <param name="x">
        /// Specify the  x ,  y , and  z  coordinates of a translation vector.
        /// </param>
        /// <param name="y">
        /// Specify the  x ,  y , and  z  coordinates of a translation vector.
        /// </param>
        /// <param name="z">
        /// Specify the  x ,  y , and  z  coordinates of a translation vector.
        /// </param>
        /// <seealso cref="glMatrixMode"/>
        /// <seealso cref="glMultMatrix"/>
        /// <seealso cref="glPushMatrix"/>
        /// <seealso cref="glRotate"/>
        /// <seealso cref="glScale"/>
        [Obsolete("Compatibility-only GL 1.0 features removed from GL 3.2")]
        public static void glTranslatef(float x, float y, float z) {
            var _F = _GetProc<GLNativeDelegate.FNglTranslatef>("glTranslatef");
            _F(x, y, z);
        }

        #endregion GL_VERSION_1_0

        #region GL_VERSION_1_1

        /// <summary>
        /// render primitives from array data
        /// <para>Require:</para> <para>GL_VERSION_1_1, GL_VERSION_ES_CM_1_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glDrawArrays"/> is available only if the GL version is 1.1 or greater.
        /// <see cref="glDrawArrays"/> is included in display lists. If <see cref="glDrawArrays"/> is entered into a
        /// display list,
        /// the necessary array data (determined by the array pointers and
        /// enables) is also
        /// entered into the display list. Because the array pointers and
        /// enables are client-side state, their values affect display lists
        /// when the lists are created, not when the lists are executed.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="mode"/> is not an accepted value.
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="count"/> is negative.
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to an
        /// enabled array and the buffer object's data store is currently mapped.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glDrawArrays"/> is executed between
        /// the execution of  <see cref="glBegin"/>  and the corresponding  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glDrawArrays(GLenum mode, GLint first, GLsizei count);</para>
        /// </summary>
        /// <param name="mode">
        /// <para>
        /// Specifies what kind of primitives to render.
        /// Symbolic constants
        /// <code>GL_POINTS</code>,
        /// <code>GL_LINE_STRIP</code>,
        /// <code>GL_LINE_LOOP</code>,
        /// <code>GL_LINES</code>,
        /// <code>GL_TRIANGLE_STRIP</code>,
        /// <code>GL_TRIANGLE_FAN</code>,
        /// <code>GL_TRIANGLES</code>,
        /// <code>GL_QUAD_STRIP</code>,
        /// <code>GL_QUADS</code>,
        /// and <code>GL_POLYGON</code> are accepted.
        /// </para>
        /// </param>
        /// <param name="first">
        /// Specifies the starting index in the enabled arrays.
        /// </param>
        /// <param name="count">
        /// Specifies the number of indices to be rendered.
        /// </param>
        /// <seealso cref="glArrayElement"/>
        /// <seealso cref="glColorPointer"/>
        /// <seealso cref="glDrawElements"/>
        /// <seealso cref="glDrawRangeElements"/>
        /// <seealso cref="glEdgeFlagPointer"/>
        /// <seealso cref="glFogCoordPointer"/>
        /// <seealso cref="glGetPointerv"/>
        /// <seealso cref="glIndexPointer"/>
        /// <seealso cref="glInterleavedArrays"/>
        /// <seealso cref="glNormalPointer"/>
        /// <seealso cref="glSecondaryColorPointer"/>
        /// <seealso cref="glTexCoordPointer"/>
        /// <seealso cref="glVertexPointer"/>
        public static void glDrawArrays(uint mode, int first, int count) {
            var _F = _GetProc<GLNativeDelegate.FNglDrawArrays>("glDrawArrays");
            _F(mode, first, count);
        }
        /// <summary>
        /// render primitives from array data
        /// <para>Require:</para> <para>GL_VERSION_1_1, GL_VERSION_ES_CM_1_0, GL_ES_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glDrawElements"/> is available only if the GL version is 1.1 or greater.
        /// <see cref="glDrawElements"/> is included in display lists. If <see cref="glDrawElements"/> is entered into a
        /// display list,
        /// the necessary array data (determined by the array pointers and
        /// enables) is also
        /// entered into the display list. Because the array pointers and
        /// enables are client-side state, their values affect display lists
        /// when the lists are created, not when the lists are executed.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="mode"/> is not an accepted value.
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="count"/> is negative.
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to an
        /// enabled array or the element array and the buffer object's data store is currently mapped.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glDrawElements"/> is executed between
        /// the execution of  <see cref="glBegin"/>  and the corresponding  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glDrawElements(GLenum mode, GLsizei count, GLenum type, const void * indices);</para>
        /// </summary>
        /// <param name="mode">
        /// <para>
        /// Specifies what kind of primitives to render.
        /// Symbolic constants
        /// <code>GL_POINTS</code>,
        /// <code>GL_LINE_STRIP</code>,
        /// <code>GL_LINE_LOOP</code>,
        /// <code>GL_LINES</code>,
        /// <code>GL_TRIANGLE_STRIP</code>,
        /// <code>GL_TRIANGLE_FAN</code>,
        /// <code>GL_TRIANGLES</code>,
        /// <code>GL_QUAD_STRIP</code>,
        /// <code>GL_QUADS</code>,
        /// and <code>GL_POLYGON</code> are accepted.
        /// </para>
        /// </param>
        /// <param name="count">
        /// Specifies the number of elements to be rendered.
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the type of the values in <paramref name="indices"/>. Must be one of
        /// <code>GL_UNSIGNED_BYTE</code>, <code>GL_UNSIGNED_SHORT</code>, or
        /// <code>GL_UNSIGNED_INT</code>.
        /// </para>
        /// </param>
        /// <param name="indices">
        /// Specifies a pointer to the location where the indices are stored.
        /// </param>
        /// <seealso cref="glArrayElement"/>
        /// <seealso cref="glColorPointer"/>
        /// <seealso cref="glDrawArrays"/>
        /// <seealso cref="glDrawRangeElements"/>
        /// <seealso cref="glEdgeFlagPointer"/>
        /// <seealso cref="glFogCoordPointer"/>
        /// <seealso cref="glGetPointerv"/>
        /// <seealso cref="glIndexPointer"/>
        /// <seealso cref="glInterleavedArrays"/>
        /// <seealso cref="glNormalPointer"/>
        /// <seealso cref="glSecondaryColorPointer"/>
        /// <seealso cref="glTexCoordPointer"/>
        /// <seealso cref="glVertexPointer"/>
        public unsafe static void glDrawElements(uint mode, int count, uint type, void* indices) {
            var _F = _GetProc<GLNativeDelegate.FNglDrawElements>("glDrawElements");
            _F(mode, count, type, indices);
        }
        /// <summary>
        /// return the address of the specified pointer
        /// <para>Require:</para> <para>GL_VERSION_1_1, GL_VERSION_4_3, GL_VERSION_ES_CM_1_0, GL_ES_VERSION_3_2, GL_KHR_debug</para>
        /// Supported: <para>gl, glcore, gles1, gles2</para>
        /// Notes: 
        /// <para>
        /// <see cref="glGetPointerv"/> is available only if the GL version is 1.1 or greater.
        /// <code>GL_FOG_COORD_ARRAY_POINTER</code> and <code>GL_SECONDARY_COLOR_ARRAY_POINTER</code> 
        /// are available only if the GL version is 1.4 or greater.
        /// The pointers are all client-side state.
        /// The initial value for each pointer is 0.
        /// For OpenGL versions 1.3 and greater, or when the <code>ARB_multitexture</code>
        /// extension is supported, querying the <code>GL_TEXTURE_COORD_ARRAY_POINTER</code>
        /// returns the value for the active client texture unit.
        /// </para>
        /// Errors: 
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="pname"/> is not an accepted value.
        /// Original: <para>void glGetPointerv(GLenum pname, void ** params);</para>
        /// </summary>
        /// <param name="pname">
        /// <para>
        /// Specifies the array or buffer pointer to be returned.
        /// Symbolic constants
        /// <code>GL_COLOR_ARRAY_POINTER</code>,
        /// <code>GL_EDGE_FLAG_ARRAY_POINTER</code>,
        /// <code>GL_FOG_COORD_ARRAY_POINTER</code>,
        /// <code>GL_FEEDBACK_BUFFER_POINTER</code>,
        /// <code>GL_INDEX_ARRAY_POINTER</code>,
        /// <code>GL_NORMAL_ARRAY_POINTER</code>,
        /// <code>GL_SECONDARY_COLOR_ARRAY_POINTER</code>,
        /// <code>GL_SELECTION_BUFFER_POINTER</code>,
        /// <code>GL_TEXTURE_COORD_ARRAY_POINTER</code>,
        /// or
        /// <code>GL_VERTEX_ARRAY_POINTER</code>
        /// are accepted.
        /// </para>
        /// </param>
        /// <param name="ps">
        /// Returns the pointer value specified by <paramref name="pname"/>.
        /// </param>
        /// <seealso cref="glBindBuffer"/>
        /// <seealso cref="glClientActiveTexture"/>
        /// <seealso cref="glColorPointer"/>
        /// <seealso cref="glEdgeFlagPointer"/>
        /// <seealso cref="glFogCoordPointer"/>
        /// <seealso cref="glFeedbackBuffer"/>
        /// <seealso cref="glGetVertexAttribPointerv"/>
        /// <seealso cref="glIndexPointer"/>
        /// <seealso cref="glNormalPointer"/>
        /// <seealso cref="glSecondaryColorPointer"/>
        /// <seealso cref="glSelectBuffer"/>
        /// <seealso cref="glTexCoordPointer"/>
        /// <seealso cref="glVertexAttribPointer"/>
        /// <seealso cref="glVertexPointer"/>
        [Obsolete("Compatibility-only GL 1.1 features removed from GL 3.2")]
        public unsafe static void glGetPointerv(uint pname, void** ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetPointerv>("glGetPointerv");
            _F(pname, ps);
        }
        /// <summary>
        /// set the scale and units used to calculate depth values
        /// <para>Require:</para> <para>GL_VERSION_1_1, GL_VERSION_ES_CM_1_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glPolygonOffset"/> is available only if the GL version is 1.1 or greater.
        /// <see cref="glPolygonOffset"/> has no effect on depth coordinates placed in the
        /// feedback buffer.
        /// <see cref="glPolygonOffset"/> has no effect on selection.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glPolygonOffset"/> is executed
        /// between the execution of  <see cref="glBegin"/>  and the corresponding
        /// execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glPolygonOffset(GLfloat factor, GLfloat units);</para>
        /// </summary>
        /// <param name="factor">
        /// <para>
        /// Specifies a scale factor that is used to create a variable
        /// depth offset for each polygon. The initial value is 0.
        /// </para>
        /// </param>
        /// <param name="units">
        /// <para>
        /// Is multiplied by an implementation-specific value to
        /// create a constant depth offset. The initial value is 0.
        /// </para>
        /// </param>
        /// <seealso cref="glDepthFunc"/>
        /// <seealso cref="glEnable"/>
        /// <seealso cref="glGet"/>
        /// <seealso cref="glIsEnabled"/>
        public static void glPolygonOffset(float factor, float units) {
            var _F = _GetProc<GLNativeDelegate.FNglPolygonOffset>("glPolygonOffset");
            _F(factor, units);
        }
        /// <summary>
        /// copy pixels into a 1D texture image
        /// <para>Require:</para> <para>GL_VERSION_1_1</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glCopyTexImage1D"/> is available only if the GL version is 1.1 or greater.
        /// Texturing has no effect in color index mode.
        /// 1, 2, 3, and 4 are not accepted values for <paramref name="internalformat"/>.
        /// An image with 0 width indicates a NULL texture.
        /// When the <code>ARB_imaging</code> extension is supported, the RGBA components copied from the framebuffer may be processed by the imaging pipeline.  See  <see cref="glTexImage1D"/>  for specific details.
        /// <code>GL_DEPTH_COMPONENT</code>, <code>GL_DEPTH_COMPONENT16</code>,
        /// <code>GL_DEPTH_COMPONENT24</code>, and <code>GL_DEPTH_COMPONENT32</code> are available only
        /// if the GL version is 1.4 or greater.
        /// Non-power-of-two textures are supported if the GL version is 2.0 or greater, or if the implementation exports the <code>GL_ARB_texture_non_power_of_two</code> extension.
        /// The 
        /// <code>GL_SRGB</code>,
        /// <code>GL_SRGB8</code>,
        /// <code>GL_SRGB_ALPHA</code>,
        /// <code>GL_SRGB8_ALPHA8</code>,
        /// <code>GL_SLUMINANCE</code>,
        /// <code>GL_SLUMINANCE8</code>,
        /// <code>GL_SLUMINANCE_ALPHA</code>, and
        /// <code>GL_SLUMINANCE8_ALPHA8</code>
        /// internal formats are only available if the GL version is 2.1 or greater.  See  <see cref="glTexImage1D"/>  for specific details about sRGB conversion.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="target"/> is not one of the allowable values.
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="level"/> is less than 0.
        /// <code>GL_INVALID_VALUE</code> may be generated if <paramref name="level"/> is greater
        /// than 
        /// log 
        /// 2 
        /// &it; 
        /// max 
        /// ,
        /// where
        /// max   
        /// is the returned value of <code>GL_MAX_TEXTURE_SIZE</code>.
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="internalformat"/> is not an allowable value.
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="width"/> is less than 0 or greater than
        /// 2 + <code>GL_MAX_TEXTURE_SIZE</code>.
        /// <code>GL_INVALID_VALUE</code> is generated if non-power-of-two textures are not supported and the <paramref name="width"/> cannot be represented as 
        /// 2 
        /// n 
        /// + 
        /// 2 
        /// &af; 
        /// border 
        /// for some integer value of  n .
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="border"/> is not 0 or 1.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glCopyTexImage1D"/> is executed between the execution of  <see cref="glBegin"/>  and the corresponding execution of  <see cref="glEnd"/> .
        /// <code>GL_INVALID_OPERATION</code> is generated if <paramref name="internalformat"/> is
        /// <code>GL_DEPTH_COMPONENT</code>, <code>GL_DEPTH_COMPONENT16</code>,
        /// <code>GL_DEPTH_COMPONENT24</code>, or <code>GL_DEPTH_COMPONENT32</code> and there is no depth
        /// buffer.
        /// </para>
        /// Original: <para>void glCopyTexImage1D(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target texture.
        /// Must be <code>GL_TEXTURE_1D</code>.
        /// </para>
        /// </param>
        /// <param name="level">
        /// <para>
        /// Specifies the level-of-detail number.
        /// Level 0 is the base image level.
        /// Level  n  is the  n th mipmap reduction image.
        /// </para>
        /// </param>
        /// <param name="internalformat">
        /// <para>
        /// Specifies the internal format of the texture.
        /// Must be one of the following symbolic constants:
        /// <code>GL_ALPHA</code>,
        /// <code>GL_ALPHA4</code>,
        /// <code>GL_ALPHA8</code>,
        /// <code>GL_ALPHA12</code>,
        /// <code>GL_ALPHA16</code>,
        /// <code>GL_COMPRESSED_ALPHA</code>,
        /// <code>GL_COMPRESSED_LUMINANCE</code>,
        /// <code>GL_COMPRESSED_LUMINANCE_ALPHA</code>,
        /// <code>GL_COMPRESSED_INTENSITY</code>,
        /// <code>GL_COMPRESSED_RGB</code>,
        /// <code>GL_COMPRESSED_RGBA</code>,
        /// <code>GL_DEPTH_COMPONENT</code>,
        /// <code>GL_DEPTH_COMPONENT16</code>,
        /// <code>GL_DEPTH_COMPONENT24</code>,
        /// <code>GL_DEPTH_COMPONENT32</code>,
        /// <code>GL_LUMINANCE</code>,
        /// <code>GL_LUMINANCE4</code>,
        /// <code>GL_LUMINANCE8</code>,
        /// <code>GL_LUMINANCE12</code>,
        /// <code>GL_LUMINANCE16</code>,
        /// <code>GL_LUMINANCE_ALPHA</code>,
        /// <code>GL_LUMINANCE4_ALPHA4</code>,
        /// <code>GL_LUMINANCE6_ALPHA2</code>,
        /// <code>GL_LUMINANCE8_ALPHA8</code>,
        /// <code>GL_LUMINANCE12_ALPHA4</code>,
        /// <code>GL_LUMINANCE12_ALPHA12</code>,
        /// <code>GL_LUMINANCE16_ALPHA16</code>,
        /// <code>GL_INTENSITY</code>,
        /// <code>GL_INTENSITY4</code>,
        /// <code>GL_INTENSITY8</code>,
        /// <code>GL_INTENSITY12</code>,
        /// <code>GL_INTENSITY16</code>,
        /// <code>GL_RGB</code>,
        /// <code>GL_R3_G3_B2</code>,
        /// <code>GL_RGB4</code>,
        /// <code>GL_RGB5</code>,
        /// <code>GL_RGB8</code>,
        /// <code>GL_RGB10</code>,
        /// <code>GL_RGB12</code>,
        /// <code>GL_RGB16</code>,
        /// <code>GL_RGBA</code>,
        /// <code>GL_RGBA2</code>,
        /// <code>GL_RGBA4</code>,
        /// <code>GL_RGB5_A1</code>,
        /// <code>GL_RGBA8</code>,
        /// <code>GL_RGB10_A2</code>,
        /// <code>GL_RGBA12</code>,
        /// <code>GL_RGBA16</code>,
        /// <code>GL_SLUMINANCE</code>,
        /// <code>GL_SLUMINANCE8</code>,
        /// <code>GL_SLUMINANCE_ALPHA</code>,
        /// <code>GL_SLUMINANCE8_ALPHA8</code>,
        /// <code>GL_SRGB</code>,
        /// <code>GL_SRGB8</code>,
        /// <code>GL_SRGB_ALPHA</code>, or 
        /// <code>GL_SRGB8_ALPHA8</code>.
        /// </para>
        /// </param>
        /// <param name="x">
        /// <para>
        /// Specify the window coordinates of the left corner
        /// of the row of pixels to be copied.
        /// </para>
        /// </param>
        /// <param name="y">
        /// <para>
        /// Specify the window coordinates of the left corner
        /// of the row of pixels to be copied.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// Specifies the width of the texture image.
        /// Must be 0 or 
        /// 2 
        /// n 
        /// + 
        /// 2 
        /// &af; 
        /// border 
        /// for some integer 
        /// n   .
        /// The height of the texture image is 1.
        /// </para>
        /// </param>
        /// <param name="border">
        /// <para>
        /// Specifies the width of the border.
        /// Must be either 0 or 1.
        /// </para>
        /// </param>
        /// <seealso cref="glCopyPixels"/>
        /// <seealso cref="glCopyTexImage2D"/>
        /// <seealso cref="glCopyTexSubImage1D"/>
        /// <seealso cref="glCopyTexSubImage2D"/>
        /// <seealso cref="glPixelStore"/>
        /// <seealso cref="glPixelTransfer"/>
        /// <seealso cref="glTexEnv"/>
        /// <seealso cref="glTexGen"/>
        /// <seealso cref="glTexImage1D"/>
        /// <seealso cref="glTexImage2D"/>
        /// <seealso cref="glTexSubImage1D"/>
        /// <seealso cref="glTexSubImage2D"/>
        /// <seealso cref="glTexParameter"/>
        public static void glCopyTexImage1D(uint target, int level, uint internalformat, int x, int y, int width, int border) {
            var _F = _GetProc<GLNativeDelegate.FNglCopyTexImage1D>("glCopyTexImage1D");
            _F(target, level, internalformat, x, y, width, border);
        }
        /// <summary>
        /// copy pixels into a 2D texture image
        /// <para>Require:</para> <para>GL_VERSION_1_1, GL_VERSION_ES_CM_1_0, GL_ES_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glCopyTexImage2D"/> is available only if the GL version is 1.1 or greater.
        /// Texturing has no effect in color index mode.
        /// 1, 2, 3, and 4 are not accepted values for <paramref name="internalformat"/>.
        /// An image with height or width of 0 indicates a NULL texture.
        /// When the <code>ARB_imaging</code> extension is supported, the RGBA components read from the framebuffer may be processed by the imaging pipeline.  See  <see cref="glTexImage1D"/>  for specific details.
        /// <code>GL_TEXTURE_CUBE_MAP_POSITIVE_X</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_NEGATIVE_X</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_POSITIVE_Y</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_NEGATIVE_Y</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_POSITIVE_Z</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_NEGATIVE_Z</code>, or
        /// <code>GL_PROXY_TEXTURE_CUBE_MAP</code> are available only if the GL version is 1.3
        /// or greater.
        /// <code>GL_DEPTH_COMPONENT</code>, <code>GL_DEPTH_COMPONENT16</code>, <code>GL_DEPTH_COMPONENT24</code>,
        /// and <code>GL_DEPTH_COMPONENT32</code> are available only if the GL version is 1.4
        /// or greater.
        /// The 
        /// <code>GL_SRGB</code>,
        /// <code>GL_SRGB8</code>,
        /// <code>GL_SRGB_ALPHA</code>,
        /// <code>GL_SRGB8_ALPHA8</code>,
        /// <code>GL_SLUMINANCE</code>,
        /// <code>GL_SLUMINANCE8</code>,
        /// <code>GL_SLUMINANCE_ALPHA</code>, and
        /// <code>GL_SLUMINANCE8_ALPHA8</code>
        /// internal formats are only available if the GL version is 2.1 or greater.  See  <see cref="glTexImage2D"/>  for specific details about sRGB conversion.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="target"/> is not <code>GL_TEXTURE_2D</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_POSITIVE_X</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_NEGATIVE_X</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_POSITIVE_Y</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_NEGATIVE_Y</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_POSITIVE_Z</code>, or
        /// <code>GL_TEXTURE_CUBE_MAP_NEGATIVE_Z</code>.
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="level"/> is less than 0.
        /// <code>GL_INVALID_VALUE</code> may be generated if <paramref name="level"/> is greater
        /// than 
        /// log 
        /// 2 
        /// &it; 
        /// max 
        /// ,
        /// where 
        /// max   
        /// is the returned value of <code>GL_MAX_TEXTURE_SIZE</code>.
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="width"/> is less than 0
        /// or greater than
        /// 2 + <code>GL_MAX_TEXTURE_SIZE</code>.
        /// <code>GL_INVALID_VALUE</code> is generated if non-power-of-two textures are not supported and the <paramref name="width"/> or <paramref name="depth"/> cannot be represented as  
        /// 2 
        /// k 
        /// + 
        /// 2 
        /// &af; 
        /// border 
        /// for some integer 
        /// k   .
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="border"/> is not 0 or 1.
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="internalformat"/> is not an
        /// accepted format.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glCopyTexImage2D"/> is executed
        /// between the execution of  <see cref="glBegin"/>  and the corresponding
        /// execution of  <see cref="glEnd"/> .
        /// <code>GL_INVALID_OPERATION</code> is generated if <paramref name="internalformat"/> is
        /// <code>GL_DEPTH_COMPONENT</code>, <code>GL_DEPTH_COMPONENT16</code>,
        /// <code>GL_DEPTH_COMPONENT24</code>, or <code>GL_DEPTH_COMPONENT32</code> and there is no depth
        /// buffer.
        /// </para>
        /// Original: <para>void glCopyTexImage2D(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target texture.
        /// Must be <code>GL_TEXTURE_2D</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_POSITIVE_X</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_NEGATIVE_X</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_POSITIVE_Y</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_NEGATIVE_Y</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_POSITIVE_Z</code>, or
        /// <code>GL_TEXTURE_CUBE_MAP_NEGATIVE_Z</code>.
        /// </para>
        /// </param>
        /// <param name="level">
        /// <para>
        /// Specifies the level-of-detail number.
        /// Level 0 is the base image level.
        /// Level  n  is the  n th mipmap reduction image.
        /// </para>
        /// </param>
        /// <param name="internalformat">
        /// <para>
        /// Specifies the internal format of the texture.
        /// Must be one of the following symbolic constants:
        /// <code>GL_ALPHA</code>,
        /// <code>GL_ALPHA4</code>,
        /// <code>GL_ALPHA8</code>,
        /// <code>GL_ALPHA12</code>,
        /// <code>GL_ALPHA16</code>,
        /// <code>GL_COMPRESSED_ALPHA</code>,
        /// <code>GL_COMPRESSED_LUMINANCE</code>,
        /// <code>GL_COMPRESSED_LUMINANCE_ALPHA</code>,
        /// <code>GL_COMPRESSED_INTENSITY</code>,
        /// <code>GL_COMPRESSED_RGB</code>,
        /// <code>GL_COMPRESSED_RGBA</code>,
        /// <code>GL_DEPTH_COMPONENT</code>,
        /// <code>GL_DEPTH_COMPONENT16</code>,
        /// <code>GL_DEPTH_COMPONENT24</code>,
        /// <code>GL_DEPTH_COMPONENT32</code>,
        /// <code>GL_LUMINANCE</code>,
        /// <code>GL_LUMINANCE4</code>,
        /// <code>GL_LUMINANCE8</code>,
        /// <code>GL_LUMINANCE12</code>,
        /// <code>GL_LUMINANCE16</code>,
        /// <code>GL_LUMINANCE_ALPHA</code>,
        /// <code>GL_LUMINANCE4_ALPHA4</code>,
        /// <code>GL_LUMINANCE6_ALPHA2</code>,
        /// <code>GL_LUMINANCE8_ALPHA8</code>,
        /// <code>GL_LUMINANCE12_ALPHA4</code>,
        /// <code>GL_LUMINANCE12_ALPHA12</code>,
        /// <code>GL_LUMINANCE16_ALPHA16</code>,
        /// <code>GL_INTENSITY</code>,
        /// <code>GL_INTENSITY4</code>,
        /// <code>GL_INTENSITY8</code>,
        /// <code>GL_INTENSITY12</code>,
        /// <code>GL_INTENSITY16</code>,
        /// <code>GL_RGB</code>,
        /// <code>GL_R3_G3_B2</code>,
        /// <code>GL_RGB4</code>,
        /// <code>GL_RGB5</code>,
        /// <code>GL_RGB8</code>,
        /// <code>GL_RGB10</code>,
        /// <code>GL_RGB12</code>,
        /// <code>GL_RGB16</code>,
        /// <code>GL_RGBA</code>,
        /// <code>GL_RGBA2</code>,
        /// <code>GL_RGBA4</code>,
        /// <code>GL_RGB5_A1</code>,
        /// <code>GL_RGBA8</code>,
        /// <code>GL_RGB10_A2</code>,
        /// <code>GL_RGBA12</code>,
        /// <code>GL_RGBA16</code>,
        /// <code>GL_SLUMINANCE</code>,
        /// <code>GL_SLUMINANCE8</code>,
        /// <code>GL_SLUMINANCE_ALPHA</code>,
        /// <code>GL_SLUMINANCE8_ALPHA8</code>,
        /// <code>GL_SRGB</code>,
        /// <code>GL_SRGB8</code>,
        /// <code>GL_SRGB_ALPHA</code>, or 
        /// <code>GL_SRGB8_ALPHA8</code>.
        /// </para>
        /// </param>
        /// <param name="x">
        /// <para>
        /// Specify the window coordinates of the lower left corner
        /// of the rectangular region of pixels to be copied.
        /// </para>
        /// </param>
        /// <param name="y">
        /// <para>
        /// Specify the window coordinates of the lower left corner
        /// of the rectangular region of pixels to be copied.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// Specifies the width of the texture image.
        /// Must be 0 or 
        /// 2 
        /// n 
        /// + 
        /// 2 
        /// &af; 
        /// border 
        /// for some integer 
        /// n   .
        /// </para>
        /// </param>
        /// <param name="height">
        /// <para>
        /// Specifies the height of the texture image.
        /// Must be 0 or 
        /// 2 
        /// m 
        /// + 
        /// 2 
        /// &af; 
        /// border 
        /// for some integer 
        /// m   .
        /// </para>
        /// </param>
        /// <param name="border">
        /// <para>
        /// Specifies the width of the border.
        /// Must be either 0 or 1.
        /// </para>
        /// </param>
        /// <seealso cref="glCopyPixels"/>
        /// <seealso cref="glCopyTexImage1D"/>
        /// <seealso cref="glCopyTexSubImage1D"/>
        /// <seealso cref="glCopyTexSubImage2D"/>
        /// <seealso cref="glPixelStore"/>
        /// <seealso cref="glPixelTransfer"/>
        /// <seealso cref="glTexEnv"/>
        /// <seealso cref="glTexGen"/>
        /// <seealso cref="glTexImage1D"/>
        /// <seealso cref="glTexImage2D"/>
        /// <seealso cref="glTexSubImage1D"/>
        /// <seealso cref="glTexSubImage2D"/>
        /// <seealso cref="glTexParameter"/>
        public static void glCopyTexImage2D(uint target, int level, uint internalformat, int x, int y, int width, int height, int border) {
            var _F = _GetProc<GLNativeDelegate.FNglCopyTexImage2D>("glCopyTexImage2D");
            _F(target, level, internalformat, x, y, width, height, border);
        }
        /// <summary>
        /// copy a one-dimensional texture subimage
        /// <para>Require:</para> <para>GL_VERSION_1_1</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glCopyTexSubImage1D"/> is available only if the GL version is 1.1 or greater.
        /// Texturing has no effect in color index mode.
        /// <see cref="glPixelStore"/>  and  <see cref="glPixelTransfer"/>  modes affect texture images
        /// in exactly the way they affect  <see cref="glDrawPixels"/> .
        /// When the <code>ARB_imaging</code> extension is supported, the RGBA components
        /// copied from the framebuffer may be processed by the imaging pipeline.  See
        /// <see cref="glTexImage1D"/>  for specific details.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if /<paramref name="target"/> is not <code>GL_TEXTURE_1D</code>.
        /// <code>GL_INVALID_OPERATION</code> is generated if the texture array has not
        /// been defined by a previous  <see cref="glTexImage1D"/>  or  <see cref="glCopyTexImage1D"/>  operation.
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="level"/> is less than 0.
        /// <code>GL_INVALID_VALUE</code> may be generated if 
        /// log sub 2(max):-->
        /// level 
        /// &gt; 
        /// log 
        /// 2 
        /// &af; 
        /// max 
        /// ,
        /// where  max  is the returned value of <code>GL_MAX_TEXTURE_SIZE</code>.
        /// <code>GL_INVALID_VALUE</code> is generated if 
        /// xoffset 
        /// &lt; 
        /// - 
        /// b 
        /// ,
        /// or
        /// (w-b):-->
        /// xoffset 
        /// + 
        /// width 
        /// &gt; 
        /// w 
        /// - 
        /// b 
        /// ,
        /// where 
        /// w   
        /// is the <code>GL_TEXTURE_WIDTH</code> and 
        /// b   
        /// is the <code>GL_TEXTURE_BORDER</code>
        /// of the texture image being modified.
        /// Note that 
        /// w   
        /// includes twice the border width.
        /// </para>
        /// Original: <para>void glCopyTexSubImage1D(GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target texture.
        /// Must be <code>GL_TEXTURE_1D</code>.
        /// </para>
        /// </param>
        /// <param name="level">
        /// <para>
        /// Specifies the level-of-detail number.
        /// Level 0 is the base image level.
        /// Level  n  is the  n th mipmap reduction image.
        /// </para>
        /// </param>
        /// <param name="xoffset">
        /// Specifies the texel offset within the texture array.
        /// </param>
        /// <param name="x">
        /// <para>
        /// Specify the window coordinates of the left corner
        /// of the row of pixels to be copied.
        /// </para>
        /// </param>
        /// <param name="y">
        /// <para>
        /// Specify the window coordinates of the left corner
        /// of the row of pixels to be copied.
        /// </para>
        /// </param>
        /// <param name="width">
        /// Specifies the width of the texture subimage.
        /// </param>
        /// <seealso cref="glCopyPixels"/>
        /// <seealso cref="glCopyTexImage1D"/>
        /// <seealso cref="glCopyTexImage2D"/>
        /// <seealso cref="glCopyTexSubImage2D"/>
        /// <seealso cref="glCopyTexSubImage3D"/>
        /// <seealso cref="glPixelStore"/>
        /// <seealso cref="glPixelTransfer"/>
        /// <seealso cref="glReadBuffer"/>
        /// <seealso cref="glTexEnv"/>
        /// <seealso cref="glTexGen"/>
        /// <seealso cref="glTexImage1D"/>
        /// <seealso cref="glTexImage2D"/>
        /// <seealso cref="glTexImage3D"/>
        /// <seealso cref="glTexParameter"/>
        /// <seealso cref="glTexSubImage1D"/>
        /// <seealso cref="glTexSubImage2D"/>
        /// <seealso cref="glTexSubImage3D"/>
        public static void glCopyTexSubImage1D(uint target, int level, int xoffset, int x, int y, int width) {
            var _F = _GetProc<GLNativeDelegate.FNglCopyTexSubImage1D>("glCopyTexSubImage1D");
            _F(target, level, xoffset, x, y, width);
        }
        /// <summary>
        /// copy a two-dimensional texture subimage
        /// <para>Require:</para> <para>GL_VERSION_1_1, GL_VERSION_ES_CM_1_0, GL_ES_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glCopyTexSubImage2D"/> is available only if the GL version is 1.1 or greater.
        /// <code>GL_TEXTURE_CUBE_MAP_POSITIVE_X</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_NEGATIVE_X</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_POSITIVE_Y</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_NEGATIVE_Y</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_POSITIVE_Z</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_NEGATIVE_Z</code>, or
        /// <code>GL_PROXY_TEXTURE_CUBE_MAP</code> are available only if the GL version is 1.3
        /// or greater.
        /// Texturing has no effect in color index mode.
        /// <see cref="glPixelStore"/>  and  <see cref="glPixelTransfer"/>  modes affect texture images
        /// in exactly the way they affect  <see cref="glDrawPixels"/> .
        /// When the <code>ARB_imaging</code> extension is supported, the RGBA components
        /// read from the framebuffer may be processed by the imaging pipeline.  See
        /// <see cref="glTexImage1D"/>  for specific details.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="target"/> is not <code>GL_TEXTURE_2D</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_POSITIVE_X</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_NEGATIVE_X</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_POSITIVE_Y</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_NEGATIVE_Y</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_POSITIVE_Z</code>, or
        /// <code>GL_TEXTURE_CUBE_MAP_NEGATIVE_Z</code>.
        /// <code>GL_INVALID_OPERATION</code> is generated if the texture array has not been
        /// defined by a previous  <see cref="glTexImage2D"/>  or  <see cref="glCopyTexImage2D"/>  operation.
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="level"/> is less than 0.
        /// <code>GL_INVALID_VALUE</code> may be generated if 
        /// log sub 2(max):-->
        /// level 
        /// &gt; 
        /// log 
        /// 2 
        /// &af; 
        /// max 
        /// ,
        /// where 
        /// max   
        /// is the returned value of <code>GL_MAX_TEXTURE_SIZE</code>.
        /// <code>GL_INVALID_VALUE</code> is generated if 
        /// xoffset 
        /// &lt; 
        /// - 
        /// b 
        /// ,
        /// (w  -  b):-->
        /// xoffset 
        /// + 
        /// width 
        /// &gt; 
        /// w 
        /// - 
        /// b 
        /// ,
        /// yoffset 
        /// &lt; 
        /// - 
        /// b 
        /// ,
        /// or
        /// (h  - b):-->
        /// yoffset 
        /// + 
        /// height 
        /// &gt; 
        /// h 
        /// - 
        /// b 
        /// ,
        /// where 
        /// w   
        /// is the <code>GL_TEXTURE_WIDTH</code>,
        /// h   
        /// is the <code>GL_TEXTURE_HEIGHT</code>,
        /// and 
        /// b   
        /// is the <code>GL_TEXTURE_BORDER</code>
        /// of the texture image being modified.
        /// Note that 
        /// w   
        /// and 
        /// h   
        /// include twice the border width.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glCopyTexSubImage2D"/> is executed
        /// between the execution of  <see cref="glBegin"/>  and the corresponding
        /// execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glCopyTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target texture.
        /// Must be <code>GL_TEXTURE_2D</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_POSITIVE_X</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_NEGATIVE_X</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_POSITIVE_Y</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_NEGATIVE_Y</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_POSITIVE_Z</code>, or
        /// <code>GL_TEXTURE_CUBE_MAP_NEGATIVE_Z</code>.
        /// </para>
        /// </param>
        /// <param name="level">
        /// <para>
        /// Specifies the level-of-detail number.
        /// Level 0 is the base image level.
        /// Level  n  is the  n th mipmap reduction image.
        /// </para>
        /// </param>
        /// <param name="xoffset">
        /// Specifies a texel offset in the x direction within the texture array.
        /// </param>
        /// <param name="yoffset">
        /// Specifies a texel offset in the y direction within the texture array.
        /// </param>
        /// <param name="x">
        /// <para>
        /// Specify the window coordinates of the lower left corner
        /// of the rectangular region of pixels to be copied.
        /// </para>
        /// </param>
        /// <param name="y">
        /// <para>
        /// Specify the window coordinates of the lower left corner
        /// of the rectangular region of pixels to be copied.
        /// </para>
        /// </param>
        /// <param name="width">
        /// Specifies the width of the texture subimage.
        /// </param>
        /// <param name="height">
        /// Specifies the height of the texture subimage.
        /// </param>
        /// <seealso cref="glCopyPixels"/>
        /// <seealso cref="glCopyTexImage1D"/>
        /// <seealso cref="glCopyTexImage2D"/>
        /// <seealso cref="glCopyTexSubImage1D"/>
        /// <seealso cref="glCopyTexSubImage3D"/>
        /// <seealso cref="glPixelStore"/>
        /// <seealso cref="glPixelTransfer"/>
        /// <seealso cref="glReadBuffer"/>
        /// <seealso cref="glTexEnv"/>
        /// <seealso cref="glTexGen"/>
        /// <seealso cref="glTexImage1D"/>
        /// <seealso cref="glTexImage2D"/>
        /// <seealso cref="glTexImage3D"/>
        /// <seealso cref="glTexParameter"/>
        /// <seealso cref="glTexSubImage1D"/>
        /// <seealso cref="glTexSubImage2D"/>
        /// <seealso cref="glTexSubImage3D"/>
        public static void glCopyTexSubImage2D(uint target, int level, int xoffset, int yoffset, int x, int y, int width, int height) {
            var _F = _GetProc<GLNativeDelegate.FNglCopyTexSubImage2D>("glCopyTexSubImage2D");
            _F(target, level, xoffset, yoffset, x, y, width, height);
        }
        /// <summary>
        /// specify a one-dimensional texture subimage
        /// <para>Require:</para> <para>GL_VERSION_1_1</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glTexSubImage1D"/> is available only if the GL version is 1.1 or greater.
        /// Texturing has no effect in color index mode.
        /// <see cref="glPixelStore"/>  and  <see cref="glPixelTransfer"/>  modes affect texture images
        /// in exactly the way they affect  <see cref="glDrawPixels"/> .
        /// Formats <code>GL_BGR</code>, and <code>GL_BGRA</code> and types
        /// <code>GL_UNSIGNED_BYTE_3_3_2</code>,
        /// <code>GL_UNSIGNED_BYTE_2_3_3_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_5_6_5</code>,
        /// <code>GL_UNSIGNED_SHORT_5_6_5_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_4_4_4_4</code>,
        /// <code>GL_UNSIGNED_SHORT_4_4_4_4_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_5_5_5_1</code>,
        /// <code>GL_UNSIGNED_SHORT_1_5_5_5_REV</code>,
        /// <code>GL_UNSIGNED_INT_8_8_8_8</code>,
        /// <code>GL_UNSIGNED_INT_8_8_8_8_REV</code>,
        /// <code>GL_UNSIGNED_INT_10_10_10_2</code>, and
        /// <code>GL_UNSIGNED_INT_2_10_10_10_REV</code> are available only if the GL version
        /// is 1.2 or greater.
        /// For OpenGL versions 1.3 and greater, or when the <code>ARB_multitexture</code> extension is supported, <see cref="glTexSubImage1D"/>
        /// specifies a one-dimensional subtexture for the current texture unit,
        /// specified with  <see cref="glActiveTexture"/> .
        /// When the <code>ARB_imaging</code> extension is supported, the RGBA components
        /// specified in <paramref name="data"/> may be processed by the imaging pipeline.  See
        /// <see cref="glTexImage1D"/>  for specific details.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="target"/> is not one of the
        /// allowable values.
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="format"/> is not an accepted
        /// format constant.
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="type"/> is not a type constant.
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="type"/> is <code>GL_BITMAP</code> and
        /// <paramref name="format"/> is not <code>GL_COLOR_INDEX</code>.
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="level"/> is less than 0.
        /// <code>GL_INVALID_VALUE</code> may be generated if <paramref name="level"/> is greater
        /// than 
        /// log 
        /// 2 
        /// max ,
        /// where  max  is the returned value of <code>GL_MAX_TEXTURE_SIZE</code>.
        /// <code>GL_INVALID_VALUE</code> is generated if 
        /// xoffset 
        /// &lt; 
        /// - 
        /// b 
        /// ,
        /// or if 
        /// (w  -  b):-->
        /// xoffset 
        /// + 
        /// width 
        /// &gt; 
        /// w 
        /// - 
        /// b 
        /// ,
        /// where 
        /// w   
        /// is the <code>GL_TEXTURE_WIDTH</code>, and 
        /// b   
        /// is
        /// the width of the <code>GL_TEXTURE_BORDER</code>
        /// of the texture image being modified.
        /// Note that 
        /// w   
        /// includes twice the border width.
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="width"/> is less than 0.
        /// <code>GL_INVALID_OPERATION</code> is generated if the texture array has not
        /// been defined by a previous  <see cref="glTexImage1D"/>  operation.
        /// <code>GL_INVALID_OPERATION</code> is generated if <paramref name="type"/> is one of
        /// <code>GL_UNSIGNED_BYTE_3_3_2</code>,
        /// <code>GL_UNSIGNED_BYTE_2_3_3_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_5_6_5</code>, or
        /// <code>GL_UNSIGNED_SHORT_5_6_5_REV</code>
        /// and <paramref name="format"/> is not <code>GL_RGB</code>.
        /// <code>GL_INVALID_OPERATION</code> is generated if <paramref name="type"/> is one of
        /// <code>GL_UNSIGNED_SHORT_4_4_4_4</code>,
        /// <code>GL_UNSIGNED_SHORT_4_4_4_4_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_5_5_5_1</code>,
        /// <code>GL_UNSIGNED_SHORT_1_5_5_5_REV</code>,
        /// <code>GL_UNSIGNED_INT_8_8_8_8</code>,
        /// <code>GL_UNSIGNED_INT_8_8_8_8_REV</code>,
        /// <code>GL_UNSIGNED_INT_10_10_10_2</code>, or
        /// <code>GL_UNSIGNED_INT_2_10_10_10_REV</code>
        /// and <paramref name="format"/> is neither <code>GL_RGBA</code> nor <code>GL_BGRA</code>.
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_UNPACK_BUFFER</code> target and the buffer object's data store is currently mapped.
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_UNPACK_BUFFER</code> target and the data would be unpacked from the buffer 
        /// object such that the memory reads required would exceed the data store size.
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_UNPACK_BUFFER</code> target and <paramref name="data"/> is not evenly divisible 
        /// into the number of bytes needed to store in memory a datum indicated by <paramref name="type"/>.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glTexSubImage1D"/> is executed
        /// between the execution of  <see cref="glBegin"/>  and the corresponding
        /// execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glTexSubImage1D(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const void * data);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target texture.
        /// Must be <code>GL_TEXTURE_1D</code>.
        /// </para>
        /// </param>
        /// <param name="level">
        /// <para>
        /// Specifies the level-of-detail number.
        /// Level 0 is the base image level.
        /// Level  n  is the  n th mipmap reduction image.
        /// </para>
        /// </param>
        /// <param name="xoffset">
        /// Specifies a texel offset in the x direction within the texture array.
        /// </param>
        /// <param name="width">
        /// Specifies the width of the texture subimage.
        /// </param>
        /// <param name="format">
        /// <para>
        /// Specifies the format of the pixel data.
        /// The following symbolic values are accepted:
        /// <code>GL_COLOR_INDEX</code>,
        /// <code>GL_RED</code>,
        /// <code>GL_GREEN</code>,
        /// <code>GL_BLUE</code>,
        /// <code>GL_ALPHA</code>,
        /// <code>GL_RGB</code>,
        /// <code>GL_BGR</code>,
        /// <code>GL_RGBA</code>,
        /// <code>GL_BGRA</code>,
        /// <code>GL_LUMINANCE</code>, and
        /// <code>GL_LUMINANCE_ALPHA</code>.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the data type of the pixel data.
        /// The following symbolic values are accepted:
        /// <code>GL_UNSIGNED_BYTE</code>,
        /// <code>GL_BYTE</code>,
        /// <code>GL_BITMAP</code>,
        /// <code>GL_UNSIGNED_SHORT</code>,
        /// <code>GL_SHORT</code>,
        /// <code>GL_UNSIGNED_INT</code>,
        /// <code>GL_INT</code>,
        /// <code>GL_FLOAT</code>,
        /// <code>GL_UNSIGNED_BYTE_3_3_2</code>,
        /// <code>GL_UNSIGNED_BYTE_2_3_3_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_5_6_5</code>,
        /// <code>GL_UNSIGNED_SHORT_5_6_5_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_4_4_4_4</code>,
        /// <code>GL_UNSIGNED_SHORT_4_4_4_4_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_5_5_5_1</code>,
        /// <code>GL_UNSIGNED_SHORT_1_5_5_5_REV</code>,
        /// <code>GL_UNSIGNED_INT_8_8_8_8</code>,
        /// <code>GL_UNSIGNED_INT_8_8_8_8_REV</code>,
        /// <code>GL_UNSIGNED_INT_10_10_10_2</code>, and
        /// <code>GL_UNSIGNED_INT_2_10_10_10_REV</code>.
        /// </para>
        /// </param>
        /// <param name="data">
        /// Specifies a pointer to the image data in memory.
        /// </param>
        /// <seealso cref="glActiveTexture"/>
        /// <seealso cref="glCopyTexImage1D"/>
        /// <seealso cref="glCopyTexImage2D"/>
        /// <seealso cref="glCopyTexSubImage1D"/>
        /// <seealso cref="glCopyTexSubImage2D"/>
        /// <seealso cref="glCopyTexSubImage3D"/>
        /// <seealso cref="glDrawPixels"/>
        /// <seealso cref="glPixelStore"/>
        /// <seealso cref="glPixelTransfer"/>
        /// <seealso cref="glTexEnv"/>
        /// <seealso cref="glTexGen"/>
        /// <seealso cref="glTexImage1D"/>
        /// <seealso cref="glTexImage2D"/>
        /// <seealso cref="glTexImage3D"/>
        /// <seealso cref="glTexParameter"/>
        /// <seealso cref="glTexSubImage2D"/>
        /// <seealso cref="glTexSubImage3D"/>
        public unsafe static void glTexSubImage1D(uint target, int level, int xoffset, int width, uint format, uint type, void* data) {
            var _F = _GetProc<GLNativeDelegate.FNglTexSubImage1D>("glTexSubImage1D");
            _F(target, level, xoffset, width, format, type, data);
        }
        /// <summary>
        /// specify a two-dimensional texture subimage
        /// <para>Require:</para> <para>GL_VERSION_1_1, GL_VERSION_ES_CM_1_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glTexSubImage2D"/> is available only if the GL version is 1.1 or greater.
        /// Texturing has no effect in color index mode.
        /// <see cref="glPixelStore"/>  and  <see cref="glPixelTransfer"/>  modes affect texture images
        /// in exactly the way they affect  <see cref="glDrawPixels"/> .
        /// Formats <code>GL_BGR</code>, and <code>GL_BGRA</code> and types
        /// <code>GL_UNSIGNED_BYTE_3_3_2</code>,
        /// <code>GL_UNSIGNED_BYTE_2_3_3_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_5_6_5</code>,
        /// <code>GL_UNSIGNED_SHORT_5_6_5_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_4_4_4_4</code>,
        /// <code>GL_UNSIGNED_SHORT_4_4_4_4_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_5_5_5_1</code>,
        /// <code>GL_UNSIGNED_SHORT_1_5_5_5_REV</code>,
        /// <code>GL_UNSIGNED_INT_8_8_8_8</code>,
        /// <code>GL_UNSIGNED_INT_8_8_8_8_REV</code>,
        /// <code>GL_UNSIGNED_INT_10_10_10_2</code>, and
        /// <code>GL_UNSIGNED_INT_2_10_10_10_REV</code> are available only if the GL version
        /// is 1.2 or greater.
        /// For OpenGL versions 1.3 and greater, or when the <code>ARB_multitexture</code> extension is supported, <see cref="glTexSubImage2D"/>
        /// specifies a two-dimensional subtexture for the current texture unit,
        /// specified with  <see cref="glActiveTexture"/> .
        /// When the <code>ARB_imaging</code> extension is supported, the RGBA components
        /// specified in <paramref name="data"/> may be processed by the imaging pipeline.  See
        /// <see cref="glTexImage1D"/>  for specific details.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="target"/> is not <code>GL_TEXTURE_2D</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_POSITIVE_X</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_NEGATIVE_X</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_POSITIVE_Y</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_NEGATIVE_Y</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_POSITIVE_Z</code>, or
        /// <code>GL_TEXTURE_CUBE_MAP_NEGATIVE_Z</code>.
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="format"/> is not an accepted
        /// format constant.
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="type"/> is not a type constant.
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="type"/> is <code>GL_BITMAP</code> and
        /// <paramref name="format"/> is not <code>GL_COLOR_INDEX</code>.
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="level"/> is less than 0.
        /// <code>GL_INVALID_VALUE</code> may be generated if <paramref name="level"/> is greater
        /// than 
        /// log 
        /// 2 
        /// max ,
        /// where  max  is the returned value of <code>GL_MAX_TEXTURE_SIZE</code>.
        /// <code>GL_INVALID_VALUE</code> is generated if 
        /// xoffset 
        /// &lt; 
        /// - 
        /// b 
        /// ,
        /// (w - b):-->
        /// xoffset 
        /// + 
        /// width 
        /// &gt; 
        /// w 
        /// - 
        /// b 
        /// ,
        /// yoffset 
        /// &lt; 
        /// - 
        /// b 
        /// ,
        /// or 
        /// (h - b):-->
        /// yoffset 
        /// + 
        /// height 
        /// &gt; 
        /// h 
        /// - 
        /// b 
        /// ,
        /// where 
        /// w   
        /// is the <code>GL_TEXTURE_WIDTH</code>,
        /// h   
        /// is the <code>GL_TEXTURE_HEIGHT</code>, and 
        /// b   
        /// is the border width
        /// of the texture image being modified.
        /// Note that 
        /// w   
        /// and 
        /// h   
        /// include twice the border width.
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="width"/> or <paramref name="height"/> is less than 0.
        /// <code>GL_INVALID_OPERATION</code> is generated if the texture array has not
        /// been defined by a previous  <see cref="glTexImage2D"/>  operation.
        /// <code>GL_INVALID_OPERATION</code> is generated if <paramref name="type"/> is one of
        /// <code>GL_UNSIGNED_BYTE_3_3_2</code>,
        /// <code>GL_UNSIGNED_BYTE_2_3_3_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_5_6_5</code>, or
        /// <code>GL_UNSIGNED_SHORT_5_6_5_REV</code>
        /// and <paramref name="format"/> is not <code>GL_RGB</code>.
        /// <code>GL_INVALID_OPERATION</code> is generated if <paramref name="type"/> is one of
        /// <code>GL_UNSIGNED_SHORT_4_4_4_4</code>,
        /// <code>GL_UNSIGNED_SHORT_4_4_4_4_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_5_5_5_1</code>,
        /// <code>GL_UNSIGNED_SHORT_1_5_5_5_REV</code>,
        /// <code>GL_UNSIGNED_INT_8_8_8_8</code>,
        /// <code>GL_UNSIGNED_INT_8_8_8_8_REV</code>,
        /// <code>GL_UNSIGNED_INT_10_10_10_2</code>, or
        /// <code>GL_UNSIGNED_INT_2_10_10_10_REV</code>
        /// and <paramref name="format"/> is neither <code>GL_RGBA</code> nor <code>GL_BGRA</code>.
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_UNPACK_BUFFER</code> target and the buffer object's data store is currently mapped.
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_UNPACK_BUFFER</code> target and the data would be unpacked from the buffer 
        /// object such that the memory reads required would exceed the data store size.
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_UNPACK_BUFFER</code> target and <paramref name="data"/> is not evenly divisible 
        /// into the number of bytes needed to store in memory a datum indicated by <paramref name="type"/>.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glTexSubImage2D"/> is executed
        /// between the execution of  <see cref="glBegin"/>  and the corresponding
        /// execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const void * data);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target texture.
        /// Must be <code>GL_TEXTURE_2D</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_POSITIVE_X</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_NEGATIVE_X</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_POSITIVE_Y</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_NEGATIVE_Y</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_POSITIVE_Z</code>, or
        /// <code>GL_TEXTURE_CUBE_MAP_NEGATIVE_Z</code>.
        /// </para>
        /// </param>
        /// <param name="level">
        /// <para>
        /// Specifies the level-of-detail number.
        /// Level 0 is the base image level.
        /// Level  n  is the  n th mipmap reduction image.
        /// </para>
        /// </param>
        /// <param name="xoffset">
        /// Specifies a texel offset in the x direction within the texture array.
        /// </param>
        /// <param name="yoffset">
        /// Specifies a texel offset in the y direction within the texture array.
        /// </param>
        /// <param name="width">
        /// Specifies the width of the texture subimage.
        /// </param>
        /// <param name="height">
        /// Specifies the height of the texture subimage.
        /// </param>
        /// <param name="format">
        /// <para>
        /// Specifies the format of the pixel data.
        /// The following symbolic values are accepted:
        /// <code>GL_COLOR_INDEX</code>,
        /// <code>GL_RED</code>,
        /// <code>GL_GREEN</code>,
        /// <code>GL_BLUE</code>,
        /// <code>GL_ALPHA</code>,
        /// <code>GL_RGB</code>,
        /// <code>GL_BGR</code>,
        /// <code>GL_RGBA</code>,
        /// <code>GL_BGRA</code>,
        /// <code>GL_LUMINANCE</code>, and
        /// <code>GL_LUMINANCE_ALPHA</code>.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the data type of the pixel data.
        /// The following symbolic values are accepted:
        /// <code>GL_UNSIGNED_BYTE</code>,
        /// <code>GL_BYTE</code>,
        /// <code>GL_BITMAP</code>,
        /// <code>GL_UNSIGNED_SHORT</code>,
        /// <code>GL_SHORT</code>,
        /// <code>GL_UNSIGNED_INT</code>,
        /// <code>GL_INT</code>,
        /// <code>GL_FLOAT</code>,
        /// <code>GL_UNSIGNED_BYTE_3_3_2</code>,
        /// <code>GL_UNSIGNED_BYTE_2_3_3_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_5_6_5</code>,
        /// <code>GL_UNSIGNED_SHORT_5_6_5_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_4_4_4_4</code>,
        /// <code>GL_UNSIGNED_SHORT_4_4_4_4_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_5_5_5_1</code>,
        /// <code>GL_UNSIGNED_SHORT_1_5_5_5_REV</code>,
        /// <code>GL_UNSIGNED_INT_8_8_8_8</code>,
        /// <code>GL_UNSIGNED_INT_8_8_8_8_REV</code>,
        /// <code>GL_UNSIGNED_INT_10_10_10_2</code>, and
        /// <code>GL_UNSIGNED_INT_2_10_10_10_REV</code>.
        /// </para>
        /// </param>
        /// <param name="data">
        /// Specifies a pointer to the image data in memory.
        /// </param>
        /// <seealso cref="glActiveTexture"/>
        /// <seealso cref="glCopyTexImage1D"/>
        /// <seealso cref="glCopyTexImage2D"/>
        /// <seealso cref="glCopyTexSubImage1D"/>
        /// <seealso cref="glCopyTexSubImage2D"/>
        /// <seealso cref="glCopyTexSubImage3D"/>
        /// <seealso cref="glDrawPixels"/>
        /// <seealso cref="glPixelStore"/>
        /// <seealso cref="glPixelTransfer"/>
        /// <seealso cref="glTexEnv"/>
        /// <seealso cref="glTexGen"/>
        /// <seealso cref="glTexImage1D"/>
        /// <seealso cref="glTexImage2D"/>
        /// <seealso cref="glTexImage3D"/>
        /// <seealso cref="glTexSubImage1D"/>
        /// <seealso cref="glTexSubImage3D"/>
        /// <seealso cref="glTexParameter"/>
        public unsafe static void glTexSubImage2D(uint target, int level, int xoffset, int yoffset, int width, int height, uint format, uint type, void* data) {
            var _F = _GetProc<GLNativeDelegate.FNglTexSubImage2D>("glTexSubImage2D");
            _F(target, level, xoffset, yoffset, width, height, format, type, data);
        }
        /// <summary>
        /// bind a named texture to a texturing target
        /// <para>Require:</para> <para>GL_VERSION_1_1, GL_VERSION_ES_CM_1_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glBindTexture"/> is available only if the GL version is 1.1 or greater.
        /// <code>GL_TEXTURE_CUBE_MAP</code> is available only if the GL version is 1.3 or greater.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="target"/> is not one of the allowable
        /// values.
        /// <code>GL_INVALID_OPERATION</code> is generated if <paramref name="texture"/> was previously created with a target
        /// that doesn't match that of <paramref name="target"/>.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glBindTexture"/> is executed
        /// between the execution of  <see cref="glBegin"/>  and the corresponding
        /// execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glBindTexture(GLenum target, GLuint texture);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target to which the texture is bound.
        /// Must be either
        /// <code>GL_TEXTURE_1D</code>,
        /// <code>GL_TEXTURE_2D</code>,
        /// <code>GL_TEXTURE_3D</code>, or
        /// <code>GL_TEXTURE_CUBE_MAP</code>.
        /// </para>
        /// </param>
        /// <param name="texture">
        /// Specifies the name of a texture.
        /// </param>
        /// <seealso cref="glAreTexturesResident"/>
        /// <seealso cref="glDeleteTextures"/>
        /// <seealso cref="glGenTextures"/>
        /// <seealso cref="glGet"/>
        /// <seealso cref="glGetTexParameter"/>
        /// <seealso cref="glIsTexture"/>
        /// <seealso cref="glPrioritizeTextures"/>
        /// <seealso cref="glTexImage1D"/>
        /// <seealso cref="glTexImage2D"/>
        /// <seealso cref="glTexParameter"/>
        public static void glBindTexture(uint target, uint texture) {
            var _F = _GetProc<GLNativeDelegate.FNglBindTexture>("glBindTexture");
            _F(target, texture);
        }
        /// <summary>
        /// delete named textures
        /// <para>Require:</para> <para>GL_VERSION_1_1, GL_VERSION_ES_CM_1_0, GL_ES_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <see cref="glDeleteTextures"/> is available only if the GL version is 1.1 or greater.
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="n"/> is negative.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glDeleteTextures"/> is executed
        /// between the execution of  <see cref="glBegin"/>  and the corresponding
        /// execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glDeleteTextures(GLsizei n, const GLuint * textures);</para>
        /// </summary>
        /// <param name="n">
        /// Specifies the number of textures to be deleted.
        /// </param>
        /// <param name="textures">
        /// Specifies an array of textures to be deleted.
        /// </param>
        /// <seealso cref="glAreTexturesResident"/>
        /// <seealso cref="glBindTexture"/>
        /// <seealso cref="glCopyTexImage1D"/>
        /// <seealso cref="glCopyTexImage2D"/>
        /// <seealso cref="glGenTextures"/>
        /// <seealso cref="glGet"/>
        /// <seealso cref="glGetTexParameter"/>
        /// <seealso cref="glPrioritizeTextures"/>
        /// <seealso cref="glTexImage1D"/>
        /// <seealso cref="glTexImage2D"/>
        /// <seealso cref="glTexParameter"/>
        public unsafe static void glDeleteTextures(int n, uint* textures) {
            var _F = _GetProc<GLNativeDelegate.FNglDeleteTextures>("glDeleteTextures");
            _F(n, textures);
        }
        /// <summary>
        /// generate texture names
        /// <para>Require:</para> <para>GL_VERSION_1_1, GL_VERSION_ES_CM_1_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <see cref="glGenTextures"/> is available only if the GL version is 1.1 or greater.
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="n"/> is negative.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glGenTextures"/> is executed
        /// between the execution of  <see cref="glBegin"/>  and the corresponding
        /// execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glGenTextures(GLsizei n, GLuint * textures);</para>
        /// </summary>
        /// <param name="n">
        /// Specifies the number of texture names to be generated.
        /// </param>
        /// <param name="textures">
        /// Specifies an array in which the generated texture names are stored.
        /// </param>
        /// <seealso cref="glBindTexture"/>
        /// <seealso cref="glCopyTexImage1D"/>
        /// <seealso cref="glCopyTexImage2D"/>
        /// <seealso cref="glDeleteTextures"/>
        /// <seealso cref="glGet"/>
        /// <seealso cref="glGetTexParameter"/>
        /// <seealso cref="glTexImage1D"/>
        /// <seealso cref="glTexImage2D"/>
        /// <seealso cref="glTexImage3D"/>
        /// <seealso cref="glTexParameter"/>
        public unsafe static void glGenTextures(int n, uint* textures) {
            var _F = _GetProc<GLNativeDelegate.FNglGenTextures>("glGenTextures");
            _F(n, textures);
        }
        /// <summary>
        /// determine if a name corresponds to a texture
        /// <para>Require:</para> <para>GL_VERSION_1_1, GL_VERSION_ES_CM_1_0, GL_ES_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <see cref="glIsTexture"/> is available only if the GL version is 1.1 or greater.
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glIsTexture"/> is executed
        /// between the execution of  <see cref="glBegin"/>  and the corresponding
        /// execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>GLboolean glIsTexture(GLuint texture);</para>
        /// </summary>
        /// <param name="texture">
        /// Specifies a value that may be the name of a texture.
        /// </param>
        /// <seealso cref="glBindTexture"/>
        /// <seealso cref="glCopyTexImage1D"/>
        /// <seealso cref="glCopyTexImage2D"/>
        /// <seealso cref="glDeleteTextures"/>
        /// <seealso cref="glGenTextures"/>
        /// <seealso cref="glGet"/>
        /// <seealso cref="glGetTexParameter"/>
        /// <seealso cref="glTexImage1D"/>
        /// <seealso cref="glTexImage2D"/>
        /// <seealso cref="glTexImage3D"/>
        /// <seealso cref="glTexParameter"/>
        public static bool glIsTexture(uint texture) {
            var _F = _GetProc<GLNativeDelegate.FNglIsTexture>("glIsTexture");
            return _F(texture);
        }
        /// <summary>
        /// render a vertex using the specified vertex array element
        /// <para>Require:</para> <para>GL_VERSION_1_1</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glArrayElement"/> is available only if the GL version is 1.1 or greater.
        /// <see cref="glArrayElement"/> is included in display lists. If <see cref="glArrayElement"/> is entered into a
        /// display list, the necessary array data (determined by the array
        /// pointers and enables) is also entered into the display list. Because
        /// the array pointers and enables are client-side state, their values
        /// affect display lists when the lists are created, not when the lists
        /// are executed.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> may be generated if <paramref name="i"/> is negative.
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to an
        /// enabled array and the buffer object's data store is currently mapped.
        /// </para>
        /// Original: <para>void glArrayElement(GLint i);</para>
        /// </summary>
        /// <param name="i">
        /// Specifies an index into the enabled vertex data arrays.
        /// </param>
        /// <seealso cref="glClientActiveTexture"/>
        /// <seealso cref="glColorPointer"/>
        /// <seealso cref="glDrawArrays"/>
        /// <seealso cref="glEdgeFlagPointer"/>
        /// <seealso cref="glFogCoordPointer"/>
        /// <seealso cref="glGetPointerv"/>
        /// <seealso cref="glIndexPointer"/>
        /// <seealso cref="glInterleavedArrays"/>
        /// <seealso cref="glNormalPointer"/>
        /// <seealso cref="glSecondaryColorPointer"/>
        /// <seealso cref="glTexCoordPointer"/>
        /// <seealso cref="glVertexPointer"/>
        [Obsolete("Compatibility-only GL 1.1 features removed from GL 3.2")]
        public static void glArrayElement(int i) {
            var _F = _GetProc<GLNativeDelegate.FNglArrayElement>("glArrayElement");
            _F(i);
        }
        /// <summary>
        /// define an array of colors
        /// <para>Require:</para> <para>GL_VERSION_1_1, GL_VERSION_ES_CM_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glColorPointer"/> is available only if the GL version is 1.1 or greater.
        /// The color array is initially disabled and isn't accessed when
        /// <see cref="glArrayElement"/> ,  <see cref="glDrawElements"/> ,  <see cref="glDrawRangeElements"/> ,
        /// <see cref="glDrawArrays"/> ,  <see cref="glMultiDrawArrays"/> , or  <see cref="glMultiDrawElements"/> 
        /// is called.
        /// Execution of <see cref="glColorPointer"/> is not allowed between the execution of
        /// <see cref="glBegin"/>  and the corresponding execution of  <see cref="glEnd"/> ,
        /// but an error may or may not be generated. If no error is generated,
        /// the operation is undefined.
        /// <see cref="glColorPointer"/> is typically implemented on the client side.
        /// Color array parameters are client-side state and are therefore not saved
        /// or restored by  <see cref="glPushAttrib"/>  and  <see cref="glPopAttrib"/> .
        /// Use  <see cref="glPushClientAttrib"/>  and  <see cref="glPopClientAttrib"/>  instead.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="size"/> is not 3 or 4.
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="type"/> is not an accepted value.
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="stride"/> is negative.
        /// </para>
        /// Original: <para>void glColorPointer(GLint size, GLenum type, GLsizei stride, const void * pointer);</para>
        /// </summary>
        /// <param name="size">
        /// <para>
        /// Specifies the number of components per color. Must be 3 or 4.
        /// The initial value is 4.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the data type of each color component in the array.
        /// Symbolic constants
        /// <code>GL_BYTE</code>,
        /// <code>GL_UNSIGNED_BYTE</code>,
        /// <code>GL_SHORT</code>,
        /// <code>GL_UNSIGNED_SHORT</code>,
        /// <code>GL_INT</code>,
        /// <code>GL_UNSIGNED_INT</code>,
        /// <code>GL_FLOAT</code>,
        /// and
        /// <code>GL_DOUBLE</code>
        /// are accepted.
        /// The initial value is <code>GL_FLOAT</code>.
        /// </para>
        /// </param>
        /// <param name="stride">
        /// <para>
        /// Specifies the byte offset between consecutive colors.
        /// If <paramref name="stride"/> is 0, the colors are understood to be
        /// tightly packed in the array. The initial value is 0.
        /// </para>
        /// </param>
        /// <param name="pointer">
        /// <para>
        /// Specifies a pointer to the first component of the first color element
        /// in the array. The initial value is 0.
        /// </para>
        /// </param>
        /// <seealso cref="glArrayElement"/>
        /// <seealso cref="glBindBuffer"/>
        /// <seealso cref="glColor"/>
        /// <seealso cref="glDisableClientState"/>
        /// <seealso cref="glDrawArrays"/>
        /// <seealso cref="glDrawElements"/>
        /// <seealso cref="glDrawRangeElements"/>
        /// <seealso cref="glEdgeFlagPointer"/>
        /// <seealso cref="glEnableClientState"/>
        /// <seealso cref="glFogCoordPointer"/>
        /// <seealso cref="glIndexPointer"/>
        /// <seealso cref="glInterleavedArrays"/>
        /// <seealso cref="glMultiDrawArrays"/>
        /// <seealso cref="glMultiDrawElements"/>
        /// <seealso cref="glNormalPointer"/>
        /// <seealso cref="glPopClientAttrib"/>
        /// <seealso cref="glPushClientAttrib"/>
        /// <seealso cref="glSecondaryColorPointer"/>
        /// <seealso cref="glTexCoordPointer"/>
        /// <seealso cref="glVertexAttribPointer"/>
        /// <seealso cref="glVertexPointer"/>
        [Obsolete("Compatibility-only GL 1.1 features removed from GL 3.2")]
        public unsafe static void glColorPointer(int size, uint type, int stride, void* pointer) {
            var _F = _GetProc<GLNativeDelegate.FNglColorPointer>("glColorPointer");
            _F(size, type, stride, pointer);
        }
        /// <summary>
        /// enable or disable client-side capability
        /// <para>Require:</para> <para>GL_VERSION_1_1, GL_VERSION_ES_CM_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glEnableClientState"/> is available only if the GL version is 1.1 or greater.
        /// <code>GL_FOG_COORD_ARRAY</code> and <code>GL_SECONDARY_COLOR_ARRAY</code> are available only if the GL version is 1.4 or
        /// greater.
        /// For OpenGL versions 1.3 and greater, or when <code>ARB_multitexture</code> is supported, enabling and disabling
        /// <code>GL_TEXTURE_COORD_ARRAY</code> affects the active client texture unit.
        /// The active client texture unit is controlled with
        /// <see cref="glClientActiveTexture"/> .
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="cap"/> is not an accepted value.
        /// <see cref="glEnableClientState"/> is not allowed between the execution of  <see cref="glBegin"/>  and the
        /// corresponding  <see cref="glEnd"/> , but an error may or may not be generated. If
        /// no error is generated, the behavior is undefined.
        /// </para>
        /// Original: <para>void glDisableClientState(GLenum cap);</para>
        /// </summary>
        /// <param name="cap">
        /// Specifies the capability to disable.
        /// </param>
        /// <seealso cref="glArrayElement"/>
        /// <seealso cref="glClientActiveTexture"/>
        /// <seealso cref="glColorPointer"/>
        /// <seealso cref="glDrawArrays"/>
        /// <seealso cref="glDrawElements"/>
        /// <seealso cref="glEdgeFlagPointer"/>
        /// <seealso cref="glFogCoordPointer"/>
        /// <seealso cref="glEnable"/>
        /// <seealso cref="glGetPointerv"/>
        /// <seealso cref="glIndexPointer"/>
        /// <seealso cref="glInterleavedArrays"/>
        /// <seealso cref="glNormalPointer"/>
        /// <seealso cref="glSecondaryColorPointer"/>
        /// <seealso cref="glTexCoordPointer"/>
        /// <seealso cref="glVertexPointer"/>
        [Obsolete("Compatibility-only GL 1.1 features removed from GL 3.2")]
        public static void glDisableClientState(uint cap) {
            var _F = _GetProc<GLNativeDelegate.FNglDisableClientState>("glDisableClientState");
            _F(cap);
        }
        /// <summary>
        /// define an array of edge flags
        /// <para>Require:</para> <para>GL_VERSION_1_1</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glEdgeFlagPointer"/> is available only if the GL version is 1.1 or greater.
        /// Edge flags are not supported for interleaved vertex array formats
        /// (see  <see cref="glInterleavedArrays"/> ).
        /// The edge flag array is initially disabled and isn't accessed when
        /// <see cref="glArrayElement"/> ,  <see cref="glDrawElements"/> ,  <see cref="glDrawRangeElements"/> ,
        /// <see cref="glDrawArrays"/> ,  <see cref="glMultiDrawArrays"/> , or  <see cref="glMultiDrawElements"/> 
        /// is called.
        /// Execution of <see cref="glEdgeFlagPointer"/> is not allowed between the execution of
        /// <see cref="glBegin"/>  and the corresponding execution of  <see cref="glEnd"/> ,
        /// but an error may or may not be generated. If no error is generated,
        /// the operation is undefined.
        /// <see cref="glEdgeFlagPointer"/> is typically implemented on the client side.
        /// Edge flag array parameters are client-side state and are therefore
        /// not saved or restored by  <see cref="glPushAttrib"/>  and  <see cref="glPopAttrib"/> .
        /// Use  <see cref="glPushClientAttrib"/>  and
        /// <see cref="glPopClientAttrib"/>  instead.
        /// </para>
        /// Errors: 
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="stride"/> is negative.
        /// Original: <para>void glEdgeFlagPointer(GLsizei stride, const void * pointer);</para>
        /// </summary>
        /// <param name="stride">
        /// <para>
        /// Specifies the byte offset between consecutive edge flags.
        /// If <paramref name="stride"/> is 0, the edge flags are understood
        /// to be tightly packed in the array. The initial value is 0.
        /// </para>
        /// </param>
        /// <param name="pointer">
        /// <para>
        /// Specifies a pointer to the first edge flag in the array. The initial
        /// value is 0.
        /// </para>
        /// </param>
        /// <seealso cref="glArrayElement"/>
        /// <seealso cref="glBindBuffer"/>
        /// <seealso cref="glColorPointer"/>
        /// <seealso cref="glDisableClientState"/>
        /// <seealso cref="glDrawArrays"/>
        /// <seealso cref="glDrawElements"/>
        /// <seealso cref="glDrawRangeElements"/>
        /// <seealso cref="glEdgeFlag"/>
        /// <seealso cref="glEnableClientState"/>
        /// <seealso cref="glFogCoordPointer"/>
        /// <seealso cref="glIndexPointer"/>
        /// <seealso cref="glInterleavedArrays"/>
        /// <seealso cref="glMultiDrawArrays"/>
        /// <seealso cref="glMultiDrawElements"/>
        /// <seealso cref="glNormalPointer"/>
        /// <seealso cref="glPopClientAttrib"/>
        /// <seealso cref="glPushClientAttrib"/>
        /// <seealso cref="glSecondaryColorPointer"/>
        /// <seealso cref="glTexCoordPointer"/>
        /// <seealso cref="glVertexAttribPointer"/>
        /// <seealso cref="glVertexPointer"/>
        [Obsolete("Compatibility-only GL 1.1 features removed from GL 3.2")]
        public unsafe static void glEdgeFlagPointer(int stride, void* pointer) {
            var _F = _GetProc<GLNativeDelegate.FNglEdgeFlagPointer>("glEdgeFlagPointer");
            _F(stride, pointer);
        }
        /// <summary>
        /// enable or disable client-side capability
        /// <para>Require:</para> <para>GL_VERSION_1_1, GL_VERSION_ES_CM_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glEnableClientState"/> is available only if the GL version is 1.1 or greater.
        /// <code>GL_FOG_COORD_ARRAY</code> and <code>GL_SECONDARY_COLOR_ARRAY</code> are available only if the GL version is 1.4 or
        /// greater.
        /// For OpenGL versions 1.3 and greater, or when <code>ARB_multitexture</code> is supported, enabling and disabling
        /// <code>GL_TEXTURE_COORD_ARRAY</code> affects the active client texture unit.
        /// The active client texture unit is controlled with
        /// <see cref="glClientActiveTexture"/> .
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="cap"/> is not an accepted value.
        /// <see cref="glEnableClientState"/> is not allowed between the execution of  <see cref="glBegin"/>  and the
        /// corresponding  <see cref="glEnd"/> , but an error may or may not be generated. If
        /// no error is generated, the behavior is undefined.
        /// </para>
        /// Original: <para>void glEnableClientState(GLenum cap);</para>
        /// </summary>
        /// <param name="cap">
        /// <para>
        /// Specifies the capability to enable.
        /// Symbolic constants
        /// <code>GL_COLOR_ARRAY</code>,
        /// <code>GL_EDGE_FLAG_ARRAY</code>,
        /// <code>GL_FOG_COORD_ARRAY</code>,
        /// <code>GL_INDEX_ARRAY</code>,
        /// <code>GL_NORMAL_ARRAY</code>,
        /// <code>GL_SECONDARY_COLOR_ARRAY</code>,
        /// <code>GL_TEXTURE_COORD_ARRAY</code>, and
        /// <code>GL_VERTEX_ARRAY</code>
        /// are accepted.
        /// </para>
        /// </param>
        /// <seealso cref="glArrayElement"/>
        /// <seealso cref="glClientActiveTexture"/>
        /// <seealso cref="glColorPointer"/>
        /// <seealso cref="glDrawArrays"/>
        /// <seealso cref="glDrawElements"/>
        /// <seealso cref="glEdgeFlagPointer"/>
        /// <seealso cref="glFogCoordPointer"/>
        /// <seealso cref="glEnable"/>
        /// <seealso cref="glGetPointerv"/>
        /// <seealso cref="glIndexPointer"/>
        /// <seealso cref="glInterleavedArrays"/>
        /// <seealso cref="glNormalPointer"/>
        /// <seealso cref="glSecondaryColorPointer"/>
        /// <seealso cref="glTexCoordPointer"/>
        /// <seealso cref="glVertexPointer"/>
        [Obsolete("Compatibility-only GL 1.1 features removed from GL 3.2")]
        public static void glEnableClientState(uint cap) {
            var _F = _GetProc<GLNativeDelegate.FNglEnableClientState>("glEnableClientState");
            _F(cap);
        }
        /// <summary>
        /// define an array of color indexes
        /// <para>Require:</para> <para>GL_VERSION_1_1</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glIndexPointer"/> is available only if the GL version is 1.1 or greater.
        /// Color indexes are not supported for interleaved vertex array formats
        /// (see  <see cref="glInterleavedArrays"/> ).
        /// The color index array is initially disabled and isn't accessed when
        /// <see cref="glArrayElement"/> ,  <see cref="glDrawElements"/> ,  <see cref="glDrawRangeElements"/> ,
        /// <see cref="glDrawArrays"/> ,  <see cref="glMultiDrawArrays"/> , or  <see cref="glMultiDrawElements"/> 
        /// is called.
        /// Execution of <see cref="glIndexPointer"/> is not allowed between
        /// <see cref="glBegin"/>  and the corresponding  <see cref="glEnd"/> ,
        /// but an error may or may not be generated. If an error is not generated,
        /// the operation is undefined.
        /// <see cref="glIndexPointer"/> is typically implemented on the client side.
        /// Color index array parameters are client-side state and are
        /// therefore not saved or restored by  <see cref="glPushAttrib"/>  and  <see cref="glPopAttrib"/> .
        /// Use  <see cref="glPushClientAttrib"/>  and
        /// <see cref="glPopClientAttrib"/>  instead.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="type"/> is not an accepted value.
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="stride"/> is negative.
        /// </para>
        /// Original: <para>void glIndexPointer(GLenum type, GLsizei stride, const void * pointer);</para>
        /// </summary>
        /// <param name="type">
        /// <para>
        /// Specifies the data type of each color index in the array.
        /// Symbolic constants
        /// <code>GL_UNSIGNED_BYTE</code>,
        /// <code>GL_SHORT</code>,
        /// <code>GL_INT</code>,
        /// <code>GL_FLOAT</code>,
        /// and <code>GL_DOUBLE</code>
        /// are accepted. The initial value is <code>GL_FLOAT</code>.
        /// </para>
        /// </param>
        /// <param name="stride">
        /// <para>
        /// Specifies the byte offset between consecutive color indexes.
        /// If <paramref name="stride"/> is 0, the color indexes are understood to
        /// be tightly packed in the array. The initial value is 0.
        /// </para>
        /// </param>
        /// <param name="pointer">
        /// <para>
        /// Specifies a pointer to the first index in the array.
        /// The initial value is 0.
        /// </para>
        /// </param>
        /// <seealso cref="glArrayElement"/>
        /// <seealso cref="glBindBuffer"/>
        /// <seealso cref="glColorPointer"/>
        /// <seealso cref="glDisableClientState"/>
        /// <seealso cref="glDrawArrays"/>
        /// <seealso cref="glDrawElements"/>
        /// <seealso cref="glDrawRangeElements"/>
        /// <seealso cref="glEdgeFlagPointer"/>
        /// <seealso cref="glEnableClientState"/>
        /// <seealso cref="glFogCoordPointer"/>
        /// <seealso cref="glIndex"/>
        /// <seealso cref="glInterleavedArrays"/>
        /// <seealso cref="glMultiDrawArrays"/>
        /// <seealso cref="glMultiDrawElements"/>
        /// <seealso cref="glNormalPointer"/>
        /// <seealso cref="glPopClientAttrib"/>
        /// <seealso cref="glPushClientAttrib"/>
        /// <seealso cref="glSecondaryColorPointer"/>
        /// <seealso cref="glTexCoordPointer"/>
        /// <seealso cref="glVertexAttribPointer"/>
        /// <seealso cref="glVertexPointer"/>
        [Obsolete("Compatibility-only GL 1.1 features removed from GL 3.2")]
        public unsafe static void glIndexPointer(uint type, int stride, void* pointer) {
            var _F = _GetProc<GLNativeDelegate.FNglIndexPointer>("glIndexPointer");
            _F(type, stride, pointer);
        }
        /// <summary>
        /// simultaneously specify and enable several interleaved arrays
        /// <para>Require:</para> <para>GL_VERSION_1_1</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glInterleavedArrays"/> is available only if the GL version is 1.1 or greater.
        /// If <see cref="glInterleavedArrays"/> is called while compiling a display list, it is not
        /// compiled into the list, and it is executed immediately.
        /// Execution of <see cref="glInterleavedArrays"/> is not allowed between the execution of
        /// <see cref="glBegin"/>  and the corresponding execution of  <see cref="glEnd"/> ,
        /// but an error may or may not be generated. If no error is generated,
        /// the operation is undefined.
        /// <see cref="glInterleavedArrays"/> is typically implemented on the client side.
        /// Vertex array parameters are client-side state and are therefore not
        /// saved or restored by  <see cref="glPushAttrib"/>  and  <see cref="glPopAttrib"/> .
        /// Use  <see cref="glPushClientAttrib"/>  and  <see cref="glPopClientAttrib"/>  instead.
        /// For OpenGL versions 1.3 and greater, or when the <code>ARB_multitexture</code> extension is supported, <see cref="glInterleavedArrays"/>
        /// only updates the texture coordinate array for the client active texture
        /// unit. The texture coordinate state for other client texture units is not
        /// updated, regardless of whether the client texture unit is enabled or not.
        /// Secondary color values are not supported in interleaved vertex array formats.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="format"/> is not an accepted value.
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="stride"/> is negative.
        /// </para>
        /// Original: <para>void glInterleavedArrays(GLenum format, GLsizei stride, const void * pointer);</para>
        /// </summary>
        /// <param name="format">
        /// <para>
        /// Specifies the type of array to enable. Symbolic constants
        /// <code>GL_V2F</code>,
        /// <code>GL_V3F</code>,
        /// <code>GL_C4UB_V2F</code>,
        /// <code>GL_C4UB_V3F</code>,
        /// <code>GL_C3F_V3F</code>,
        /// <code>GL_N3F_V3F</code>,
        /// <code>GL_C4F_N3F_V3F</code>,
        /// <code>GL_T2F_V3F</code>,
        /// <code>GL_T4F_V4F</code>,
        /// <code>GL_T2F_C4UB_V3F</code>,
        /// <code>GL_T2F_C3F_V3F</code>,
        /// <code>GL_T2F_N3F_V3F</code>,
        /// <code>GL_T2F_C4F_N3F_V3F</code>,
        /// and
        /// <code>GL_T4F_C4F_N3F_V4F</code>
        /// are accepted.
        /// </para>
        /// </param>
        /// <param name="stride">
        /// Specifies the offset in bytes between each aggregate array element.
        /// </param>
        /// <seealso cref="glArrayElement"/>
        /// <seealso cref="glClientActiveTexture"/>
        /// <seealso cref="glColorPointer"/>
        /// <seealso cref="glDrawArrays"/>
        /// <seealso cref="glDrawElements"/>
        /// <seealso cref="glEdgeFlagPointer"/>
        /// <seealso cref="glEnableClientState"/>
        /// <seealso cref="glGetPointerv"/>
        /// <seealso cref="glIndexPointer"/>
        /// <seealso cref="glNormalPointer"/>
        /// <seealso cref="glSecondaryColorPointer"/>
        /// <seealso cref="glTexCoordPointer"/>
        /// <seealso cref="glVertexPointer"/>
        [Obsolete("Compatibility-only GL 1.1 features removed from GL 3.2")]
        public unsafe static void glInterleavedArrays(uint format, int stride, void* pointer) {
            var _F = _GetProc<GLNativeDelegate.FNglInterleavedArrays>("glInterleavedArrays");
            _F(format, stride, pointer);
        }
        /// <summary>
        /// define an array of normals
        /// <para>Require:</para> <para>GL_VERSION_1_1, GL_VERSION_ES_CM_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glNormalPointer"/> is available only if the GL version is 1.1 or greater.
        /// The normal array is initially disabled and isn't accessed when
        /// <see cref="glArrayElement"/> ,  <see cref="glDrawElements"/> ,  <see cref="glDrawRangeElements"/> ,
        /// <see cref="glDrawArrays"/> ,  <see cref="glMultiDrawArrays"/> , or  <see cref="glMultiDrawElements"/> 
        /// is called.
        /// Execution of <see cref="glNormalPointer"/> is not allowed between
        /// <see cref="glBegin"/>  and the corresponding  <see cref="glEnd"/> ,
        /// but an error may or may not be generated. If an error is not generated,
        /// the operation is undefined.
        /// <see cref="glNormalPointer"/> is typically implemented on the client side.
        /// Normal array parameters are client-side state and are therefore not
        /// saved or restored by  <see cref="glPushAttrib"/>  and  <see cref="glPopAttrib"/> .
        /// Use  <see cref="glPushClientAttrib"/>  and
        /// <see cref="glPopClientAttrib"/>  instead.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="type"/> is not an accepted value.
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="stride"/> is negative.
        /// </para>
        /// Original: <para>void glNormalPointer(GLenum type, GLsizei stride, const void * pointer);</para>
        /// </summary>
        /// <param name="type">
        /// <para>
        /// Specifies the data type of each coordinate in the array.
        /// Symbolic constants
        /// <code>GL_BYTE</code>,
        /// <code>GL_SHORT</code>,
        /// <code>GL_INT</code>,
        /// <code>GL_FLOAT</code>, and
        /// <code>GL_DOUBLE</code>
        /// are accepted. The initial value is <code>GL_FLOAT</code>.
        /// </para>
        /// </param>
        /// <param name="stride">
        /// <para>
        /// Specifies the byte offset between consecutive normals. If <paramref name="stride"/> is
        /// 0, the normals are understood to be tightly packed in
        /// the array. The initial value is 0.
        /// </para>
        /// </param>
        /// <param name="pointer">
        /// <para>
        /// Specifies a pointer to the first coordinate of the first normal in the
        /// array. The initial value is 0.
        /// </para>
        /// </param>
        /// <seealso cref="glArrayElement"/>
        /// <seealso cref="glBindBuffer"/>
        /// <seealso cref="glColorPointer"/>
        /// <seealso cref="glDisableClientState"/>
        /// <seealso cref="glDrawArrays"/>
        /// <seealso cref="glDrawElements"/>
        /// <seealso cref="glDrawRangeElements"/>
        /// <seealso cref="glEdgeFlagPointer"/>
        /// <seealso cref="glEnableClientState"/>
        /// <seealso cref="glFogCoordPointer"/>
        /// <seealso cref="glIndexPointer"/>
        /// <seealso cref="glInterleavedArrays"/>
        /// <seealso cref="glMultiDrawArrays"/>
        /// <seealso cref="glMultiDrawElements"/>
        /// <seealso cref="glNormal"/>
        /// <seealso cref="glPopClientAttrib"/>
        /// <seealso cref="glPushClientAttrib"/>
        /// <seealso cref="glSecondaryColorPointer"/>
        /// <seealso cref="glTexCoordPointer"/>
        /// <seealso cref="glVertexAttribPointer"/>
        /// <seealso cref="glVertexPointer"/>
        [Obsolete("Compatibility-only GL 1.1 features removed from GL 3.2")]
        public unsafe static void glNormalPointer(uint type, int stride, void* pointer) {
            var _F = _GetProc<GLNativeDelegate.FNglNormalPointer>("glNormalPointer");
            _F(type, stride, pointer);
        }
        /// <summary>
        /// define an array of texture coordinates
        /// <para>Require:</para> <para>GL_VERSION_1_1, GL_VERSION_ES_CM_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glTexCoordPointer"/> is available only if the GL version is 1.1 or greater.
        /// For OpenGL versions 1.3 and greater, or when the <code>ARB_multitexture</code>
        /// extension is supported, <see cref="glTexCoordPointer"/> updates the
        /// texture coordinate array state of the active client texture unit,
        /// specified with  <see cref="glClientActiveTexture"/> .
        /// Each texture coordinate array is initially disabled and isn't accessed when
        /// <see cref="glArrayElement"/> ,  <see cref="glDrawElements"/> ,  <see cref="glDrawRangeElements"/> ,
        /// <see cref="glDrawArrays"/> ,  <see cref="glMultiDrawArrays"/> , or  <see cref="glMultiDrawElements"/> 
        /// is called.
        /// Execution of <see cref="glTexCoordPointer"/> is not allowed between the execution of
        /// <see cref="glBegin"/>  and the corresponding execution of  <see cref="glEnd"/> ,
        /// but an error may or may not be generated. If no error is generated,
        /// the operation is undefined.
        /// <see cref="glTexCoordPointer"/> is typically implemented on the client side.
        /// Texture coordinate array parameters are client-side state and are therefore
        /// not saved or restored by  <see cref="glPushAttrib"/>  and  <see cref="glPopAttrib"/> .
        /// Use  <see cref="glPushClientAttrib"/>  and
        /// <see cref="glPopClientAttrib"/>  instead.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="size"/> is not 1, 2, 3, or 4.
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="type"/> is not an accepted value.
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="stride"/> is negative.
        /// </para>
        /// Original: <para>void glTexCoordPointer(GLint size, GLenum type, GLsizei stride, const void * pointer);</para>
        /// </summary>
        /// <param name="size">
        /// <para>
        /// Specifies the number of coordinates per array element. Must be 1, 2, 3,
        /// or 4. The initial value is 4.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the data type of each texture coordinate.
        /// Symbolic constants
        /// <code>GL_SHORT</code>,
        /// <code>GL_INT</code>,
        /// <code>GL_FLOAT</code>,
        /// or <code>GL_DOUBLE</code>
        /// are accepted. The initial value is <code>GL_FLOAT</code>.
        /// </para>
        /// </param>
        /// <param name="stride">
        /// <para>
        /// Specifies the byte offset between consecutive texture coordinate sets.
        /// If <paramref name="stride"/> is 0, the array elements are understood
        /// to be tightly packed. The initial value is 0.
        /// </para>
        /// </param>
        /// <param name="pointer">
        /// <para>
        /// Specifies a pointer to the first coordinate of the first texture coordinate set in the
        /// array. The initial value is 0.
        /// </para>
        /// </param>
        /// <seealso cref="glArrayElement"/>
        /// <seealso cref="glBindBuffer"/>
        /// <seealso cref="glClientActiveTexture"/>
        /// <seealso cref="glColorPointer"/>
        /// <seealso cref="glDisableClientState"/>
        /// <seealso cref="glDrawArrays"/>
        /// <seealso cref="glDrawElements"/>
        /// <seealso cref="glDrawRangeElements"/>
        /// <seealso cref="glEdgeFlagPointer"/>
        /// <seealso cref="glEnableClientState"/>
        /// <seealso cref="glFogCoordPointer"/>
        /// <seealso cref="glIndexPointer"/>
        /// <seealso cref="glInterleavedArrays"/>
        /// <seealso cref="glMultiDrawArrays"/>
        /// <seealso cref="glMultiDrawElements"/>
        /// <seealso cref="glMultiTexCoord"/>
        /// <seealso cref="glNormalPointer"/>
        /// <seealso cref="glPopClientAttrib"/>
        /// <seealso cref="glPushClientAttrib"/>
        /// <seealso cref="glSecondaryColorPointer"/>
        /// <seealso cref="glTexCoord"/>
        /// <seealso cref="glVertexAttribPointer"/>
        /// <seealso cref="glVertexPointer"/>
        [Obsolete("Compatibility-only GL 1.1 features removed from GL 3.2")]
        public unsafe static void glTexCoordPointer(int size, uint type, int stride, void* pointer) {
            var _F = _GetProc<GLNativeDelegate.FNglTexCoordPointer>("glTexCoordPointer");
            _F(size, type, stride, pointer);
        }
        /// <summary>
        /// define an array of vertex data
        /// <para>Require:</para> <para>GL_VERSION_1_1, GL_VERSION_ES_CM_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glVertexPointer"/> is available only if the GL version is 1.1 or greater.
        /// The vertex array is initially disabled and isn't accessed when
        /// <see cref="glArrayElement"/> ,  <see cref="glDrawElements"/> ,  <see cref="glDrawRangeElements"/> ,
        /// <see cref="glDrawArrays"/> ,  <see cref="glMultiDrawArrays"/> , or  <see cref="glMultiDrawElements"/> 
        /// is called.
        /// Execution of <see cref="glVertexPointer"/> is not allowed between the execution of
        /// <see cref="glBegin"/>  and the corresponding execution of  <see cref="glEnd"/> ,
        /// but an error may or may not be generated. If no error is generated,
        /// the operation is undefined.
        /// <see cref="glVertexPointer"/> is typically implemented on the client side.
        /// Vertex array parameters are client-side state and are therefore not
        /// saved or restored by  <see cref="glPushAttrib"/>  and  <see cref="glPopAttrib"/> .
        /// Use  <see cref="glPushClientAttrib"/>  and  <see cref="glPopClientAttrib"/>  instead.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="size"/> is not 2, 3, or 4.
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="type"/> is not an accepted value.
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="stride"/> is negative.
        /// </para>
        /// Original: <para>void glVertexPointer(GLint size, GLenum type, GLsizei stride, const void * pointer);</para>
        /// </summary>
        /// <param name="size">
        /// <para>
        /// Specifies the number of coordinates per vertex. Must be 2, 3, or
        /// 4. The initial value is 4.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the data type of each coordinate in the array.
        /// Symbolic constants
        /// <code>GL_SHORT</code>,
        /// <code>GL_INT</code>,
        /// <code>GL_FLOAT</code>,
        /// or <code>GL_DOUBLE</code>
        /// are accepted. The initial value is <code>GL_FLOAT</code>.
        /// </para>
        /// </param>
        /// <param name="stride">
        /// <para>
        /// Specifies the byte offset between consecutive
        /// vertices. If <paramref name="stride"/> is 0, the vertices are understood to be tightly packed in
        /// the array. The initial value
        /// is 0.
        /// </para>
        /// </param>
        /// <param name="pointer">
        /// <para>
        /// Specifies a pointer to the first coordinate of the first vertex in the
        /// array. The initial value is 0.
        /// </para>
        /// </param>
        /// <seealso cref="glArrayElement"/>
        /// <seealso cref="glBindBuffer"/>
        /// <seealso cref="glColorPointer"/>
        /// <seealso cref="glDisableClientState"/>
        /// <seealso cref="glDrawArrays"/>
        /// <seealso cref="glDrawElements"/>
        /// <seealso cref="glDrawRangeElements"/>
        /// <seealso cref="glEdgeFlagPointer"/>
        /// <seealso cref="glEnableClientState"/>
        /// <seealso cref="glFogCoordPointer"/>
        /// <seealso cref="glIndexPointer"/>
        /// <seealso cref="glInterleavedArrays"/>
        /// <seealso cref="glMultiDrawArrays"/>
        /// <seealso cref="glMultiDrawElements"/>
        /// <seealso cref="glNormalPointer"/>
        /// <seealso cref="glPopClientAttrib"/>
        /// <seealso cref="glPushClientAttrib"/>
        /// <seealso cref="glSecondaryColorPointer"/>
        /// <seealso cref="glTexCoordPointer"/>
        /// <seealso cref="glVertex"/>
        /// <seealso cref="glVertexAttribPointer"/>
        [Obsolete("Compatibility-only GL 1.1 features removed from GL 3.2")]
        public unsafe static void glVertexPointer(int size, uint type, int stride, void* pointer) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexPointer>("glVertexPointer");
            _F(size, type, stride, pointer);
        }
        /// <summary>
        /// determine if textures are loaded in texture memory
        /// <para>Require:</para> <para>GL_VERSION_1_1</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glAreTexturesResident"/> is available only if the GL version is 1.1 or greater.
        /// <see cref="glAreTexturesResident"/> returns the residency status of the textures at the time of
        /// invocation. It does not guarantee that the textures will remain
        /// resident at any other time.
        /// If textures reside in virtual memory (there is no texture memory), they
        /// are considered always resident.
        /// Some implementations may not load a texture until the first use of
        /// that texture.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="n"/> is negative.
        /// <code>GL_INVALID_VALUE</code> is generated if any element in <paramref name="textures"/>
        /// is 0 or does not name a texture. In that case, the function returns
        /// <code>GL_FALSE</code> and the contents of <paramref name="residences"/> is indeterminate.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glAreTexturesResident"/> is executed
        /// between the execution of  <see cref="glBegin"/>  and the corresponding
        /// execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>GLboolean glAreTexturesResident(GLsizei n, const GLuint * textures, GLboolean * residences);</para>
        /// </summary>
        /// <param name="n">
        /// Specifies the number of textures to be queried.
        /// </param>
        /// <param name="textures">
        /// Specifies an array containing the names of the textures to be queried.
        /// </param>
        /// <param name="residences">
        /// <para>
        /// Specifies an array in which the texture residence status is returned.
        /// The residence status of a texture named by an element of <paramref name="textures"/> is
        /// returned in the corresponding element of <paramref name="residences"/>.
        /// </para>
        /// </param>
        /// <seealso cref="glBindTexture"/>
        /// <seealso cref="glGetTexParameter"/>
        /// <seealso cref="glPrioritizeTextures"/>
        /// <seealso cref="glTexImage1D"/>
        /// <seealso cref="glTexImage2D"/>
        /// <seealso cref="glTexImage3D"/>
        /// <seealso cref="glTexParameter"/>
        [Obsolete("Compatibility-only GL 1.1 features removed from GL 3.2")]
        public unsafe static bool glAreTexturesResident(int n, uint* textures, bool* residences) {
            var _F = _GetProc<GLNativeDelegate.FNglAreTexturesResident>("glAreTexturesResident");
            return _F(n, textures, residences);
        }
        /// <summary>
        /// set texture residence priority
        /// <para>Require:</para> <para>GL_VERSION_1_1</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <see cref="glPrioritizeTextures"/> is available only if the GL version is 1.1 or greater.
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="n"/> is negative.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glPrioritizeTextures"/> is executed
        /// between the execution of  <see cref="glBegin"/>  and the corresponding
        /// execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glPrioritizeTextures(GLsizei n, const GLuint * textures, const GLclampf * priorities);</para>
        /// </summary>
        /// <param name="n">
        /// Specifies the number of textures to be prioritized.
        /// </param>
        /// <param name="textures">
        /// Specifies an array containing the names of the textures to be prioritized.
        /// </param>
        /// <param name="priorities">
        /// <para>
        /// Specifies an array containing the texture priorities.
        /// A priority given in an element of <paramref name="priorities"/> applies to the texture
        /// named by the corresponding element of <paramref name="textures"/>.
        /// </para>
        /// </param>
        /// <seealso cref="glAreTexturesResident"/>
        /// <seealso cref="glBindTexture"/>
        /// <seealso cref="glCopyTexImage1D"/>
        /// <seealso cref="glCopyTexImage2D"/>
        /// <seealso cref="glTexImage1D"/>
        /// <seealso cref="glTexImage2D"/>
        /// <seealso cref="glTexImage3D"/>
        /// <seealso cref="glTexParameter"/>
        [Obsolete("Compatibility-only GL 1.1 features removed from GL 3.2")]
        public unsafe static void glPrioritizeTextures(int n, uint* textures, float* priorities) {
            var _F = _GetProc<GLNativeDelegate.FNglPrioritizeTextures>("glPrioritizeTextures");
            _F(n, textures, priorities);
        }
        /// <summary>
        /// set the current color index
        /// <para>Require:</para> <para>GL_VERSION_1_1</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glIndexub"/> and <see cref="glIndexubv"/> are available only if the GL version is
        /// 1.1 or greater.
        /// The current index can be updated at any time.
        /// In particular,
        /// <see cref="glIndex"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glIndexub(GLubyte c);</para>
        /// </summary>
        /// <param name="c">
        /// Specifies the new value for the current color index.
        /// </param>
        /// <seealso cref="glColor"/>
        /// <seealso cref="glIndexPointer"/>
        [Obsolete("Compatibility-only GL 1.1 features removed from GL 3.2")]
        public static void glIndexub(byte c) {
            var _F = _GetProc<GLNativeDelegate.FNglIndexub>("glIndexub");
            _F(c);
        }
        /// <summary>
        /// set the current color index
        /// <para>Require:</para> <para>GL_VERSION_1_1</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glIndexub"/> and <see cref="glIndexubv"/> are available only if the GL version is
        /// 1.1 or greater.
        /// The current index can be updated at any time.
        /// In particular,
        /// <see cref="glIndex"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glIndexubv(const GLubyte * c);</para>
        /// </summary>
        /// <param name="c">
        /// <para>
        /// Specifies a pointer to a one-element array that contains
        /// the new value for the current color index.
        /// </para>
        /// </param>
        /// <seealso cref="glColor"/>
        /// <seealso cref="glIndexPointer"/>
        [Obsolete("Compatibility-only GL 1.1 features removed from GL 3.2")]
        public unsafe static void glIndexubv(byte* c) {
            var _F = _GetProc<GLNativeDelegate.FNglIndexubv>("glIndexubv");
            _F(c);
        }
        /// <summary>
        /// push and pop the client attribute stack
        /// <para>Require:</para> <para>GL_VERSION_1_1</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glPushClientAttrib"/> is available only if the GL version is 1.1 or greater.
        /// Not all values for GL client state can be saved on the attribute stack.
        /// For example, select and feedback state cannot be saved.
        /// The depth of the attribute stack depends on the implementation,
        /// but it must be at least 16.
        /// Use  <see cref="glPushAttrib"/>  and  <see cref="glPopAttrib"/>  to push and restore
        /// state that is kept on the server. Only pixel storage modes and
        /// vertex array state may be pushed and popped with
        /// <see cref="glPushClientAttrib"/> and  <see cref="glPopClientAttrib"/> .
        /// For OpenGL versions 1.3 and greater, or when the <code>ARB_multitexture</code> extension is supported, pushing and
        /// popping client vertex array state applies to all supported texture units,
        /// and the active client texture state.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_STACK_OVERFLOW</code> is generated if <see cref="glPushClientAttrib"/> is called while
        /// the attribute stack is full.
        /// <code>GL_STACK_UNDERFLOW</code> is generated if  <see cref="glPopClientAttrib"/>  is called while
        /// the attribute stack is empty.
        /// </para>
        /// Original: <para>void glPopClientAttrib();</para>
        /// </summary>
        /// <seealso cref="glColorPointer"/>
        /// <seealso cref="glDisableClientState"/>
        /// <seealso cref="glEdgeFlagPointer"/>
        /// <seealso cref="glEnableClientState"/>
        /// <seealso cref="glFogCoordPointer"/>
        /// <seealso cref="glGet"/>
        /// <seealso cref="glGetError"/>
        /// <seealso cref="glIndexPointer"/>
        /// <seealso cref="glNormalPointer"/>
        /// <seealso cref="glNewList"/>
        /// <seealso cref="glPixelStore"/>
        /// <seealso cref="glPushAttrib"/>
        /// <seealso cref="glTexCoordPointer"/>
        /// <seealso cref="glVertexPointer"/>
        [Obsolete("Compatibility-only GL 1.1 features removed from GL 3.2")]
        public static void glPopClientAttrib() {
            var _F = _GetProc<GLNativeDelegate.FNglPopClientAttrib>("glPopClientAttrib");
            _F();
        }
        /// <summary>
        /// push and pop the client attribute stack
        /// <para>Require:</para> <para>GL_VERSION_1_1</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glPushClientAttrib"/> is available only if the GL version is 1.1 or greater.
        /// Not all values for GL client state can be saved on the attribute stack.
        /// For example, select and feedback state cannot be saved.
        /// The depth of the attribute stack depends on the implementation,
        /// but it must be at least 16.
        /// Use  <see cref="glPushAttrib"/>  and  <see cref="glPopAttrib"/>  to push and restore
        /// state that is kept on the server. Only pixel storage modes and
        /// vertex array state may be pushed and popped with
        /// <see cref="glPushClientAttrib"/> and  <see cref="glPopClientAttrib"/> .
        /// For OpenGL versions 1.3 and greater, or when the <code>ARB_multitexture</code> extension is supported, pushing and
        /// popping client vertex array state applies to all supported texture units,
        /// and the active client texture state.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_STACK_OVERFLOW</code> is generated if <see cref="glPushClientAttrib"/> is called while
        /// the attribute stack is full.
        /// <code>GL_STACK_UNDERFLOW</code> is generated if  <see cref="glPopClientAttrib"/>  is called while
        /// the attribute stack is empty.
        /// </para>
        /// Original: <para>void glPushClientAttrib(GLbitfield mask);</para>
        /// </summary>
        /// <param name="mask">
        /// <para>
        /// Specifies a mask that indicates which attributes to save.  Values for
        /// <paramref name="mask"/> are listed below.
        /// </para>
        /// </param>
        /// <seealso cref="glColorPointer"/>
        /// <seealso cref="glDisableClientState"/>
        /// <seealso cref="glEdgeFlagPointer"/>
        /// <seealso cref="glEnableClientState"/>
        /// <seealso cref="glFogCoordPointer"/>
        /// <seealso cref="glGet"/>
        /// <seealso cref="glGetError"/>
        /// <seealso cref="glIndexPointer"/>
        /// <seealso cref="glNormalPointer"/>
        /// <seealso cref="glNewList"/>
        /// <seealso cref="glPixelStore"/>
        /// <seealso cref="glPushAttrib"/>
        /// <seealso cref="glTexCoordPointer"/>
        /// <seealso cref="glVertexPointer"/>
        [Obsolete("Compatibility-only GL 1.1 features removed from GL 3.2")]
        public static void glPushClientAttrib(uint mask) {
            var _F = _GetProc<GLNativeDelegate.FNglPushClientAttrib>("glPushClientAttrib");
            _F(mask);
        }

        #endregion GL_VERSION_1_1

        #region GL_VERSION_1_2

        /// <summary>
        /// render primitives from array data
        /// <para>Require:</para> <para>GL_VERSION_1_2, GL_ES_VERSION_3_0, GL_SC_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glDrawRangeElements"/> is available only if the GL version is 1.2 or greater.
        /// <see cref="glDrawRangeElements"/> is included in display lists. If <see cref="glDrawRangeElements"/> is entered into a
        /// display list,
        /// the necessary array data (determined by the array pointers and
        /// enables) is also
        /// entered into the display list. Because the array pointers and
        /// enables are client-side state, their values affect display lists
        /// when the lists are created, not when the lists are executed.
        /// </para>
        /// Errors: 
        /// <para>
        /// It is an error for indices to lie outside the range 
        /// start 
        /// end 
        /// ,
        /// but implementations may not check for this situation. Such indices
        /// cause implementation-dependent behavior.
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="mode"/> is not an accepted value.
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="count"/> is negative.
        /// <code>GL_INVALID_VALUE</code> is generated if 
        /// end 
        /// &lt; 
        /// start 
        /// .
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to an
        /// enabled array or the element array and the buffer object's data store is currently mapped.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glDrawRangeElements"/> is executed between
        /// the execution of  <see cref="glBegin"/>  and the corresponding  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glDrawRangeElements(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const void * indices);</para>
        /// </summary>
        /// <param name="mode">
        /// <para>
        /// Specifies what kind of primitives to render.
        /// Symbolic constants
        /// <code>GL_POINTS</code>,
        /// <code>GL_LINE_STRIP</code>,
        /// <code>GL_LINE_LOOP</code>,
        /// <code>GL_LINES</code>,
        /// <code>GL_TRIANGLE_STRIP</code>,
        /// <code>GL_TRIANGLE_FAN</code>,
        /// <code>GL_TRIANGLES</code>,
        /// <code>GL_QUAD_STRIP</code>,
        /// <code>GL_QUADS</code>,
        /// and <code>GL_POLYGON</code> are accepted.
        /// </para>
        /// </param>
        /// <param name="start">
        /// Specifies the minimum array index contained in <paramref name="indices"/>.
        /// </param>
        /// <param name="end">
        /// Specifies the maximum array index contained in <paramref name="indices"/>.
        /// </param>
        /// <param name="count">
        /// Specifies the number of elements to be rendered.
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the type of the values in <paramref name="indices"/>. Must be one of
        /// <code>GL_UNSIGNED_BYTE</code>, <code>GL_UNSIGNED_SHORT</code>, or
        /// <code>GL_UNSIGNED_INT</code>.
        /// </para>
        /// </param>
        /// <param name="indices">
        /// Specifies a pointer to the location where the indices are stored.
        /// </param>
        /// <seealso cref="glArrayElement"/>
        /// <seealso cref="glColorPointer"/>
        /// <seealso cref="glDrawArrays"/>
        /// <seealso cref="glDrawElements"/>
        /// <seealso cref="glEdgeFlagPointer"/>
        /// <seealso cref="glGetPointerv"/>
        /// <seealso cref="glIndexPointer"/>
        /// <seealso cref="glInterleavedArrays"/>
        /// <seealso cref="glNormalPointer"/>
        /// <seealso cref="glSecondaryColorPointer"/>
        /// <seealso cref="glTexCoordPointer"/>
        /// <seealso cref="glVertexPointer"/>
        public unsafe static void glDrawRangeElements(uint mode, uint start, uint end, int count, uint type, void* indices) {
            var _F = _GetProc<GLNativeDelegate.FNglDrawRangeElements>("glDrawRangeElements");
            _F(mode, start, end, count, type, indices);
        }
        /// <summary>
        /// specify a three-dimensional texture image
        /// <para>Require:</para> <para>GL_VERSION_1_2, GL_ES_VERSION_3_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// Texturing has no effect in color index mode.
        /// The texture image can be represented by the same data formats
        /// as the pixels in a  <see cref="glDrawPixels"/>  command,
        /// except that <code>GL_STENCIL_INDEX</code> and <code>GL_DEPTH_COMPONENT</code>
        /// cannot be used.
        /// <see cref="glPixelStore"/>  and  <see cref="glPixelTransfer"/>  modes affect texture images
        /// in exactly the way they affect  <see cref="glDrawPixels"/> .
        /// <see cref="glTexImage3D"/> is available only if the GL version is 1.2 or greater.
        /// Internal formats other than 1, 2, 3, or 4 may be used only if the GL
        /// version is 1.1 or greater.
        /// <paramref name="data"/> may be a null pointer.
        /// In this case texture memory is
        /// allocated to accommodate a texture of width <paramref name="width"/>, height <paramref name="height"/>,
        /// and depth <paramref name="depth"/>.
        /// You can then download subtextures to initialize this
        /// texture memory.
        /// The image is undefined if the user tries to apply
        /// an uninitialized portion of the texture image to a primitive.
        /// Formats <code>GL_BGR</code>, and <code>GL_BGRA</code> and types
        /// <code>GL_UNSIGNED_BYTE_3_3_2</code>,
        /// <code>GL_UNSIGNED_BYTE_2_3_3_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_5_6_5</code>,
        /// <code>GL_UNSIGNED_SHORT_5_6_5_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_4_4_4_4</code>,
        /// <code>GL_UNSIGNED_SHORT_4_4_4_4_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_5_5_5_1</code>,
        /// <code>GL_UNSIGNED_SHORT_1_5_5_5_REV</code>,
        /// <code>GL_UNSIGNED_INT_8_8_8_8</code>,
        /// <code>GL_UNSIGNED_INT_8_8_8_8_REV</code>,
        /// <code>GL_UNSIGNED_INT_10_10_10_2</code>, and
        /// <code>GL_UNSIGNED_INT_2_10_10_10_REV</code> are available only if the GL version
        /// is 1.2 or greater.
        /// For OpenGL versions 1.3 and greater, or when the <code>ARB_multitexture</code> extension is supported, <see cref="glTexImage3D"/>
        /// specifies the three-dimensional texture for the current texture unit,
        /// specified with  <see cref="glActiveTexture"/> .
        /// If the <code>ARB_imaging</code> extension is supported, RGBA elements may
        /// also be processed by the imaging pipeline.  The following stages may be
        /// applied to an RGBA color before color component clamping to the range
        /// 0 
        /// 1 
        /// :
        /// 1. Color component replacement by the color table specified for 
        /// <code>GL_COLOR_TABLE</code>, if enabled. See  <see cref="glColorTable"/> .
        /// 2. Color component replacement by the color table specified for 
        /// <code>GL_POST_CONVOLUTION_COLOR_TABLE</code>, if enabled.  See  <see cref="glColorTable"/> .
        /// 3. Transformation by the color matrix.  See  <see cref="glMatrixMode"/> . 
        /// 4. RGBA components may be multiplied by <code>GL_POST_COLOR_MATRIX_c_SCALE</code>, 
        /// and added to <code>GL_POST_COLOR_MATRIX_c_BIAS</code>, if enabled.  See
        /// <see cref="glPixelTransfer"/> .
        /// 5. Color component replacement by the color table specified for 
        /// <code>GL_POST_COLOR_MATRIX_COLOR_TABLE</code>, if enabled.  See
        /// <see cref="glColorTable"/> .
        /// Non-power-of-two textures are supported if the GL version is 2.0 or greater, or if the implementation exports the <code>GL_ARB_texture_non_power_of_two</code> extension.
        /// The 
        /// <code>GL_SRGB</code>,
        /// <code>GL_SRGB8</code>,
        /// <code>GL_SRGB_ALPHA</code>,
        /// <code>GL_SRGB8_ALPHA8</code>,
        /// <code>GL_SLUMINANCE</code>,
        /// <code>GL_SLUMINANCE8</code>,
        /// <code>GL_SLUMINANCE_ALPHA</code>, and
        /// <code>GL_SLUMINANCE8_ALPHA8</code>
        /// internal formats are only available if the GL version is 2.1 or greater.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="target"/> is not <code>GL_TEXTURE_3D</code>
        /// or <code>GL_PROXY_TEXTURE_3D</code>.
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="format"/> is not an accepted
        /// format constant.  Format constants other than <code>GL_STENCIL_INDEX</code> and <code>GL_DEPTH_COMPONENT</code>
        /// are accepted.
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="type"/> is not a type constant.
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="type"/> is <code>GL_BITMAP</code> and
        /// <paramref name="format"/> is not <code>GL_COLOR_INDEX</code>.
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="level"/> is less than 0.
        /// <code>GL_INVALID_VALUE</code> may be generated if <paramref name="level"/> is greater than 
        /// log 
        /// 2 
        /// &af; 
        /// max 
        /// ,
        /// where  max  is the returned value of <code>GL_MAX_TEXTURE_SIZE</code>.
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="internalFormat"/> is not 1, 2, 3, 4, or one of the
        /// accepted resolution and format symbolic constants.
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="width"/>, <paramref name="height"/>, or <paramref name="depth"/> is less than 0 or greater than 2 + <code>GL_MAX_TEXTURE_SIZE</code>.
        /// <code>GL_INVALID_VALUE</code> is generated if non-power-of-two textures are not supported and the <paramref name="width"/>, <paramref name="height"/>, or <paramref name="depth"/> cannot be represented as 
        /// 2 
        /// k 
        /// + 
        /// 2 
        /// &af; 
        /// border 
        /// for some
        /// integer value of  k .
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="border"/> is not 0 or 1.
        /// <code>GL_INVALID_OPERATION</code> is generated if <paramref name="type"/> is one of
        /// <code>GL_UNSIGNED_BYTE_3_3_2</code>,
        /// <code>GL_UNSIGNED_BYTE_2_3_3_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_5_6_5</code>, or
        /// <code>GL_UNSIGNED_SHORT_5_6_5_REV</code>
        /// and <paramref name="format"/> is not <code>GL_RGB</code>.
        /// <code>GL_INVALID_OPERATION</code> is generated if <paramref name="type"/> is one of
        /// <code>GL_UNSIGNED_SHORT_4_4_4_4</code>,
        /// <code>GL_UNSIGNED_SHORT_4_4_4_4_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_5_5_5_1</code>,
        /// <code>GL_UNSIGNED_SHORT_1_5_5_5_REV</code>,
        /// <code>GL_UNSIGNED_INT_8_8_8_8</code>,
        /// <code>GL_UNSIGNED_INT_8_8_8_8_REV</code>,
        /// <code>GL_UNSIGNED_INT_10_10_10_2</code>, or
        /// <code>GL_UNSIGNED_INT_2_10_10_10_REV</code>
        /// and <paramref name="format"/> is neither <code>GL_RGBA</code> nor <code>GL_BGRA</code>.
        /// <code>GL_INVALID_OPERATION</code> is generated if <paramref name="format"/> or <paramref name="internalFormat"/> is
        /// <code>GL_DEPTH_COMPONENT</code>, <code>GL_DEPTH_COMPONENT16</code>,
        /// <code>GL_DEPTH_COMPONENT24</code>, or <code>GL_DEPTH_COMPONENT32</code>.
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_UNPACK_BUFFER</code> target and the buffer object's data store is currently mapped.
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_UNPACK_BUFFER</code> target and the data would be unpacked from the buffer 
        /// object such that the memory reads required would exceed the data store size.
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_UNPACK_BUFFER</code> target and <paramref name="data"/> is not evenly divisible 
        /// into the number of bytes needed to store in memory a datum indicated by <paramref name="type"/>.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glTexImage3D"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glTexImage3D(GLenum target, GLint level, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const void * data);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target texture.
        /// Must be <code>GL_TEXTURE_3D</code> or <code>GL_PROXY_TEXTURE_3D</code>.
        /// </para>
        /// </param>
        /// <param name="level">
        /// <para>
        /// Specifies the level-of-detail number.
        /// Level 0 is the base image level.
        /// Level 
        /// n   
        /// is the 
        /// n 
        /// th 
        /// mipmap reduction image.
        /// </para>
        /// </param>
        /// <param name="internalFormat">
        /// <para>
        /// Specifies the number of color components in the texture.
        /// Must be 1, 2, 3, or 4, or one of the following symbolic constants:
        /// <code>GL_ALPHA</code>,
        /// <code>GL_ALPHA4</code>,
        /// <code>GL_ALPHA8</code>,
        /// <code>GL_ALPHA12</code>,
        /// <code>GL_ALPHA16</code>,
        /// <code>GL_COMPRESSED_ALPHA</code>,
        /// <code>GL_COMPRESSED_LUMINANCE</code>,
        /// <code>GL_COMPRESSED_LUMINANCE_ALPHA</code>,
        /// <code>GL_COMPRESSED_INTENSITY</code>,
        /// <code>GL_COMPRESSED_RGB</code>,
        /// <code>GL_COMPRESSED_RGBA</code>,
        /// <code>GL_LUMINANCE</code>,
        /// <code>GL_LUMINANCE4</code>,
        /// <code>GL_LUMINANCE8</code>,
        /// <code>GL_LUMINANCE12</code>,
        /// <code>GL_LUMINANCE16</code>,
        /// <code>GL_LUMINANCE_ALPHA</code>,
        /// <code>GL_LUMINANCE4_ALPHA4</code>,
        /// <code>GL_LUMINANCE6_ALPHA2</code>,
        /// <code>GL_LUMINANCE8_ALPHA8</code>,
        /// <code>GL_LUMINANCE12_ALPHA4</code>,
        /// <code>GL_LUMINANCE12_ALPHA12</code>,
        /// <code>GL_LUMINANCE16_ALPHA16</code>,
        /// <code>GL_INTENSITY</code>,
        /// <code>GL_INTENSITY4</code>,
        /// <code>GL_INTENSITY8</code>,
        /// <code>GL_INTENSITY12</code>,
        /// <code>GL_INTENSITY16</code>,
        /// <code>GL_R3_G3_B2</code>,
        /// <code>GL_RGB</code>,
        /// <code>GL_RGB4</code>,
        /// <code>GL_RGB5</code>,
        /// <code>GL_RGB8</code>,
        /// <code>GL_RGB10</code>,
        /// <code>GL_RGB12</code>,
        /// <code>GL_RGB16</code>,
        /// <code>GL_RGBA</code>,
        /// <code>GL_RGBA2</code>,
        /// <code>GL_RGBA4</code>,
        /// <code>GL_RGB5_A1</code>,
        /// <code>GL_RGBA8</code>,
        /// <code>GL_RGB10_A2</code>,
        /// <code>GL_RGBA12</code>,
        /// <code>GL_RGBA16</code>,
        /// <code>GL_SLUMINANCE</code>,
        /// <code>GL_SLUMINANCE8</code>,
        /// <code>GL_SLUMINANCE_ALPHA</code>,
        /// <code>GL_SLUMINANCE8_ALPHA8</code>,
        /// <code>GL_SRGB</code>,
        /// <code>GL_SRGB8</code>,
        /// <code>GL_SRGB_ALPHA</code>, or 
        /// <code>GL_SRGB8_ALPHA8</code>.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// Specifies the width of the texture image including the border if any. If the GL version does not support non-power-of-two sizes, this value must be 
        /// 2 
        /// n 
        /// + 
        /// 2 
        /// &af; 
        /// border 
        /// for some integer 
        /// n   .
        /// All
        /// implementations support 3D texture images that are at least 16 texels
        /// wide.
        /// </para>
        /// </param>
        /// <param name="height">
        /// <para>
        /// Specifies the height of the texture image including the border if any. If the GL version does not support non-power-of-two sizes, this value must be 
        /// 2 
        /// m 
        /// + 
        /// 2 
        /// &af; 
        /// border 
        /// for some integer 
        /// m   .
        /// All
        /// implementations support 3D texture images that are at least 16 texels
        /// high.
        /// </para>
        /// </param>
        /// <param name="depth">
        /// <para>
        /// Specifies the depth of the texture image including the border if any. If the GL version does not support non-power-of-two sizes, this value must be 
        /// 2 
        /// k 
        /// + 
        /// 2 
        /// &af; 
        /// border 
        /// for some integer 
        /// k   .
        /// All
        /// implementations support 3D texture images that are at least 16 texels
        /// deep.
        /// </para>
        /// </param>
        /// <param name="border">
        /// <para>
        /// Specifies the width of the border.
        /// Must be either 0 or 1.
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// Specifies the format of the pixel data.
        /// The following symbolic values are accepted:
        /// <code>GL_COLOR_INDEX</code>,
        /// <code>GL_RED</code>,
        /// <code>GL_GREEN</code>,
        /// <code>GL_BLUE</code>,
        /// <code>GL_ALPHA</code>,
        /// <code>GL_RGB</code>,
        /// <code>GL_BGR</code>,
        /// <code>GL_RGBA</code>,
        /// <code>GL_BGRA</code>,
        /// <code>GL_LUMINANCE</code>, and
        /// <code>GL_LUMINANCE_ALPHA</code>.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the data type of the pixel data.
        /// The following symbolic values are accepted:
        /// <code>GL_UNSIGNED_BYTE</code>,
        /// <code>GL_BYTE</code>,
        /// <code>GL_BITMAP</code>,
        /// <code>GL_UNSIGNED_SHORT</code>,
        /// <code>GL_SHORT</code>,
        /// <code>GL_UNSIGNED_INT</code>,
        /// <code>GL_INT</code>,
        /// <code>GL_FLOAT</code>,
        /// <code>GL_UNSIGNED_BYTE_3_3_2</code>,
        /// <code>GL_UNSIGNED_BYTE_2_3_3_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_5_6_5</code>,
        /// <code>GL_UNSIGNED_SHORT_5_6_5_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_4_4_4_4</code>,
        /// <code>GL_UNSIGNED_SHORT_4_4_4_4_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_5_5_5_1</code>,
        /// <code>GL_UNSIGNED_SHORT_1_5_5_5_REV</code>,
        /// <code>GL_UNSIGNED_INT_8_8_8_8</code>,
        /// <code>GL_UNSIGNED_INT_8_8_8_8_REV</code>,
        /// <code>GL_UNSIGNED_INT_10_10_10_2</code>, and
        /// <code>GL_UNSIGNED_INT_2_10_10_10_REV</code>.
        /// </para>
        /// </param>
        /// <param name="data">
        /// Specifies a pointer to the image data in memory.
        /// </param>
        /// <seealso cref="glActiveTexture"/>
        /// <seealso cref="glColorTable"/>
        /// <seealso cref="glCompressedTexImage1D"/>
        /// <seealso cref="glCompressedTexImage2D"/>
        /// <seealso cref="glCompressedTexImage3D"/>
        /// <seealso cref="glCompressedTexSubImage1D"/>
        /// <seealso cref="glCompressedTexSubImage2D"/>
        /// <seealso cref="glCompressedTexSubImage3D"/>
        /// <seealso cref="glCopyPixels"/>
        /// <seealso cref="glCopyTexImage1D"/>
        /// <seealso cref="glCopyTexImage2D"/>
        /// <seealso cref="glCopyTexSubImage1D"/>
        /// <seealso cref="glCopyTexSubImage2D"/>
        /// <seealso cref="glCopyTexSubImage3D"/>
        /// <seealso cref="glDrawPixels"/>
        /// <seealso cref="glGetCompressedTexImage"/>
        /// <seealso cref="glMatrixMode"/>
        /// <seealso cref="glPixelStore"/>
        /// <seealso cref="glPixelTransfer"/>
        /// <seealso cref="glTexEnv"/>
        /// <seealso cref="glTexGen"/>
        /// <seealso cref="glTexImage1D"/>
        /// <seealso cref="glTexImage2D"/>
        /// <seealso cref="glTexSubImage1D"/>
        /// <seealso cref="glTexSubImage2D"/>
        /// <seealso cref="glTexSubImage3D"/>
        /// <seealso cref="glTexParameter"/>
        public unsafe static void glTexImage3D(uint target, int level, int internalFormat, int width, int height, int depth, int border, uint format, uint type, void* data) {
            var _F = _GetProc<GLNativeDelegate.FNglTexImage3D>("glTexImage3D");
            _F(target, level, internalFormat, width, height, depth, border, format, type, data);
        }
        /// <summary>
        /// specify a three-dimensional texture subimage
        /// <para>Require:</para> <para>GL_VERSION_1_2, GL_ES_VERSION_3_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glTexSubImage3D"/> is available only if the GL version is 1.2 or greater.
        /// Texturing has no effect in color index mode.
        /// <see cref="glPixelStore"/>  and  <see cref="glPixelTransfer"/>  modes affect texture images
        /// in exactly the way they affect  <see cref="glDrawPixels"/> .
        /// Formats <code>GL_BGR</code>, and <code>GL_BGRA</code> and types
        /// <code>GL_UNSIGNED_BYTE_3_3_2</code>,
        /// <code>GL_UNSIGNED_BYTE_2_3_3_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_5_6_5</code>,
        /// <code>GL_UNSIGNED_SHORT_5_6_5_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_4_4_4_4</code>,
        /// <code>GL_UNSIGNED_SHORT_4_4_4_4_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_5_5_5_1</code>,
        /// <code>GL_UNSIGNED_SHORT_1_5_5_5_REV</code>,
        /// <code>GL_UNSIGNED_INT_8_8_8_8</code>,
        /// <code>GL_UNSIGNED_INT_8_8_8_8_REV</code>,
        /// <code>GL_UNSIGNED_INT_10_10_10_2</code>, and
        /// <code>GL_UNSIGNED_INT_2_10_10_10_REV</code> are available only if the GL version
        /// is 1.2 or greater.
        /// For OpenGL versions 1.3 and greater, or when the <code>ARB_multitexture</code> extension is supported, <see cref="glTexSubImage3D"/>
        /// specifies a three-dimensional subtexture for the current texture unit,
        /// specified with  <see cref="glActiveTexture"/> .
        /// When the <code>ARB_imaging</code> extension is supported, the RGBA components
        /// specified in <paramref name="data"/> may be processed by the imaging pipeline.  See
        /// <see cref="glTexImage3D"/>  for specific details.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if /<paramref name="target"/> is not <code>GL_TEXTURE_3D</code>.
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="format"/> is not an accepted
        /// format constant.
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="type"/> is not a type constant.
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="type"/> is <code>GL_BITMAP</code> and
        /// <paramref name="format"/> is not <code>GL_COLOR_INDEX</code>.
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="level"/> is less than 0.
        /// <code>GL_INVALID_VALUE</code> may be generated if <paramref name="level"/> is greater
        /// than 
        /// log 
        /// 2 
        /// max ,
        /// where  max  is the returned value of <code>GL_MAX_TEXTURE_SIZE</code>.
        /// <code>GL_INVALID_VALUE</code> is generated if 
        /// xoffset 
        /// &lt; 
        /// - 
        /// b 
        /// ,
        /// (w - b):-->
        /// xoffset 
        /// + 
        /// width 
        /// &gt; 
        /// w 
        /// - 
        /// b 
        /// ,
        /// yoffset 
        /// &lt; 
        /// - 
        /// b 
        /// ,
        /// or 
        /// (h - b):-->
        /// yoffset 
        /// + 
        /// height 
        /// &gt; 
        /// h 
        /// - 
        /// b 
        /// ,
        /// or 
        /// zoffset 
        /// &lt; 
        /// - 
        /// b 
        /// ,
        /// or 
        /// (d - b):-->
        /// zoffset 
        /// + 
        /// depth 
        /// &gt; 
        /// d 
        /// - 
        /// b 
        /// ,
        /// where 
        /// w   
        /// is the <code>GL_TEXTURE_WIDTH</code>,
        /// h   
        /// is the <code>GL_TEXTURE_HEIGHT</code>, 
        /// d   
        /// is the <code>GL_TEXTURE_DEPTH</code>
        /// and 
        /// b   
        /// is the border width of the texture image being modified.
        /// Note that 
        /// w   ,
        /// h   ,
        /// and 
        /// d   
        /// include twice the border width.
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="width"/>, <paramref name="height"/>, or <paramref name="depth"/>
        /// is less than 0.
        /// <code>GL_INVALID_OPERATION</code> is generated if the texture array has not
        /// been defined by a previous  <see cref="glTexImage3D"/>  operation.
        /// <code>GL_INVALID_OPERATION</code> is generated if <paramref name="type"/> is one of
        /// <code>GL_UNSIGNED_BYTE_3_3_2</code>,
        /// <code>GL_UNSIGNED_BYTE_2_3_3_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_5_6_5</code>, or
        /// <code>GL_UNSIGNED_SHORT_5_6_5_REV</code>
        /// and <paramref name="format"/> is not <code>GL_RGB</code>.
        /// <code>GL_INVALID_OPERATION</code> is generated if <paramref name="type"/> is one of
        /// <code>GL_UNSIGNED_SHORT_4_4_4_4</code>,
        /// <code>GL_UNSIGNED_SHORT_4_4_4_4_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_5_5_5_1</code>,
        /// <code>GL_UNSIGNED_SHORT_1_5_5_5_REV</code>,
        /// <code>GL_UNSIGNED_INT_8_8_8_8</code>,
        /// <code>GL_UNSIGNED_INT_8_8_8_8_REV</code>,
        /// <code>GL_UNSIGNED_INT_10_10_10_2</code>, or
        /// <code>GL_UNSIGNED_INT_2_10_10_10_REV</code>
        /// and <paramref name="format"/> is neither <code>GL_RGBA</code> nor <code>GL_BGRA</code>.
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_UNPACK_BUFFER</code> target and the buffer object's data store is currently mapped.
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_UNPACK_BUFFER</code> target and the data would be unpacked from the buffer 
        /// object such that the memory reads required would exceed the data store size.
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_UNPACK_BUFFER</code> target and <paramref name="data"/> is not evenly divisible 
        /// into the number of bytes needed to store in memory a datum indicated by <paramref name="type"/>.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glTexSubImage3D"/> is executed
        /// between the execution of  <see cref="glBegin"/>  and the corresponding
        /// execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void * data);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target texture.
        /// Must be <code>GL_TEXTURE_3D</code>.
        /// </para>
        /// </param>
        /// <param name="level">
        /// <para>
        /// Specifies the level-of-detail number.
        /// Level 0 is the base image level.
        /// Level  n  is the  n th mipmap reduction image.
        /// </para>
        /// </param>
        /// <param name="xoffset">
        /// Specifies a texel offset in the x direction within the texture array.
        /// </param>
        /// <param name="yoffset">
        /// Specifies a texel offset in the y direction within the texture array.
        /// </param>
        /// <param name="zoffset">
        /// Specifies a texel offset in the z direction within the texture array.
        /// </param>
        /// <param name="width">
        /// Specifies the width of the texture subimage.
        /// </param>
        /// <param name="height">
        /// Specifies the height of the texture subimage.
        /// </param>
        /// <param name="depth">
        /// Specifies the depth of the texture subimage.
        /// </param>
        /// <param name="format">
        /// <para>
        /// Specifies the format of the pixel data.
        /// The following symbolic values are accepted:
        /// <code>GL_COLOR_INDEX</code>,
        /// <code>GL_RED</code>,
        /// <code>GL_GREEN</code>,
        /// <code>GL_BLUE</code>,
        /// <code>GL_ALPHA</code>,
        /// <code>GL_RGB</code>,
        /// <code>GL_BGR</code>,
        /// <code>GL_RGBA</code>,
        /// <code>GL_BGRA</code>,
        /// <code>GL_LUMINANCE</code>, and
        /// <code>GL_LUMINANCE_ALPHA</code>.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the data type of the pixel data.
        /// The following symbolic values are accepted:
        /// <code>GL_UNSIGNED_BYTE</code>,
        /// <code>GL_BYTE</code>,
        /// <code>GL_BITMAP</code>,
        /// <code>GL_UNSIGNED_SHORT</code>,
        /// <code>GL_SHORT</code>,
        /// <code>GL_UNSIGNED_INT</code>,
        /// <code>GL_INT</code>,
        /// <code>GL_FLOAT</code>,
        /// <code>GL_UNSIGNED_BYTE_3_3_2</code>,
        /// <code>GL_UNSIGNED_BYTE_2_3_3_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_5_6_5</code>,
        /// <code>GL_UNSIGNED_SHORT_5_6_5_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_4_4_4_4</code>,
        /// <code>GL_UNSIGNED_SHORT_4_4_4_4_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_5_5_5_1</code>,
        /// <code>GL_UNSIGNED_SHORT_1_5_5_5_REV</code>,
        /// <code>GL_UNSIGNED_INT_8_8_8_8</code>,
        /// <code>GL_UNSIGNED_INT_8_8_8_8_REV</code>,
        /// <code>GL_UNSIGNED_INT_10_10_10_2</code>, and
        /// <code>GL_UNSIGNED_INT_2_10_10_10_REV</code>.
        /// </para>
        /// </param>
        /// <param name="data">
        /// Specifies a pointer to the image data in memory.
        /// </param>
        /// <seealso cref="glActiveTexture"/>
        /// <seealso cref="glCopyTexImage1D"/>
        /// <seealso cref="glCopyTexImage2D"/>
        /// <seealso cref="glCopyTexSubImage1D"/>
        /// <seealso cref="glCopyTexSubImage2D"/>
        /// <seealso cref="glCopyTexSubImage3D"/>
        /// <seealso cref="glDrawPixels"/>
        /// <seealso cref="glPixelStore"/>
        /// <seealso cref="glPixelTransfer"/>
        /// <seealso cref="glTexEnv"/>
        /// <seealso cref="glTexGen"/>
        /// <seealso cref="glTexImage1D"/>
        /// <seealso cref="glTexImage2D"/>
        /// <seealso cref="glTexImage3D"/>
        /// <seealso cref="glTexSubImage1D"/>
        /// <seealso cref="glTexSubImage2D"/>
        /// <seealso cref="glTexParameter"/>
        public unsafe static void glTexSubImage3D(uint target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, uint format, uint type, void* data) {
            var _F = _GetProc<GLNativeDelegate.FNglTexSubImage3D>("glTexSubImage3D");
            _F(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, data);
        }
        /// <summary>
        /// copy a three-dimensional texture subimage
        /// <para>Require:</para> <para>GL_VERSION_1_2, GL_ES_VERSION_3_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glCopyTexSubImage3D"/> is available only if the GL version is 1.2 or greater.
        /// Texturing has no effect in color index mode.
        /// <see cref="glPixelStore"/>  and  <see cref="glPixelTransfer"/>  modes affect texture images
        /// in exactly the way they affect  <see cref="glDrawPixels"/> .
        /// When the <code>ARB_imaging</code> extension is supported, the RGBA components
        /// copied from the framebuffer may be processed by the imaging pipeline, as
        /// if they were a two-dimensional texture.  See  <see cref="glTexImage2D"/>  for
        /// specific details.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if /<paramref name="target"/> is not <code>GL_TEXTURE_3D</code>.
        /// <code>GL_INVALID_OPERATION</code> is generated if the texture array has not
        /// been defined by a previous  <see cref="glTexImage3D"/>  operation.
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="level"/> is less than 0.
        /// <code>GL_INVALID_VALUE</code> may be generated if 
        /// log sub 2(max):-->
        /// level 
        /// &gt; 
        /// log 
        /// 2 
        /// &af; 
        /// max 
        /// ,
        /// where 
        /// max   
        /// is the returned value of <code>GL_MAX_3D_TEXTURE_SIZE</code>.
        /// <code>GL_INVALID_VALUE</code> is generated if 
        /// xoffset 
        /// &lt; 
        /// - 
        /// b 
        /// ,
        /// (w  - b):-->
        /// xoffset 
        /// + 
        /// width 
        /// &gt; 
        /// w 
        /// - 
        /// b 
        /// ,
        /// yoffset 
        /// &lt; 
        /// - 
        /// b 
        /// ,
        /// (h  - b):-->
        /// yoffset 
        /// + 
        /// height 
        /// &gt; 
        /// h 
        /// - 
        /// b 
        /// ,
        /// zoffset 
        /// &lt; 
        /// - 
        /// b 
        /// ,
        /// or 
        /// (d  - b):-->
        /// zoffset 
        /// + 
        /// 1 
        /// &gt; 
        /// d 
        /// - 
        /// b 
        /// ,
        /// where 
        /// w   
        /// is the <code>GL_TEXTURE_WIDTH</code>,
        /// h   
        /// is the <code>GL_TEXTURE_HEIGHT</code>,
        /// d   
        /// is the <code>GL_TEXTURE_DEPTH</code>,
        /// and 
        /// b   
        /// is the <code>GL_TEXTURE_BORDER</code>
        /// of the texture image being modified.
        /// Note that 
        /// w   , 
        /// h   ,
        /// and 
        /// d   
        /// include twice the border width.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glCopyTexSubImage3D"/> is executed
        /// between the execution of  <see cref="glBegin"/>  and the corresponding
        /// execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glCopyTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target texture.
        /// Must be <code>GL_TEXTURE_3D</code>
        /// </para>
        /// </param>
        /// <param name="level">
        /// <para>
        /// Specifies the level-of-detail number.
        /// Level 0 is the base image level.
        /// Level  n  is the  n th mipmap reduction image.
        /// </para>
        /// </param>
        /// <param name="xoffset">
        /// Specifies a texel offset in the x direction within the texture array.
        /// </param>
        /// <param name="yoffset">
        /// Specifies a texel offset in the y direction within the texture array.
        /// </param>
        /// <param name="zoffset">
        /// Specifies a texel offset in the z direction within the texture array.
        /// </param>
        /// <param name="x">
        /// <para>
        /// Specify the window coordinates of the lower left corner
        /// of the rectangular region of pixels to be copied.
        /// </para>
        /// </param>
        /// <param name="y">
        /// <para>
        /// Specify the window coordinates of the lower left corner
        /// of the rectangular region of pixels to be copied.
        /// </para>
        /// </param>
        /// <param name="width">
        /// Specifies the width of the texture subimage.
        /// </param>
        /// <param name="height">
        /// Specifies the height of the texture subimage.
        /// </param>
        /// <seealso cref="glCopyPixels"/>
        /// <seealso cref="glCopyTexImage1D"/>
        /// <seealso cref="glCopyTexImage2D"/>
        /// <seealso cref="glCopyTexSubImage1D"/>
        /// <seealso cref="glCopyTexSubImage2D"/>
        /// <seealso cref="glPixelStore"/>
        /// <seealso cref="glPixelTransfer"/>
        /// <seealso cref="glReadBuffer"/>
        /// <seealso cref="glTexEnv"/>
        /// <seealso cref="glTexGen"/>
        /// <seealso cref="glTexImage1D"/>
        /// <seealso cref="glTexImage2D"/>
        /// <seealso cref="glTexImage3D"/>
        /// <seealso cref="glTexParameter"/>
        /// <seealso cref="glTexSubImage1D"/>
        /// <seealso cref="glTexSubImage2D"/>
        /// <seealso cref="glTexSubImage3D"/>
        public static void glCopyTexSubImage3D(uint target, int level, int xoffset, int yoffset, int zoffset, int x, int y, int width, int height) {
            var _F = _GetProc<GLNativeDelegate.FNglCopyTexSubImage3D>("glCopyTexSubImage3D");
            _F(target, level, xoffset, yoffset, zoffset, x, y, width, height);
        }

        #endregion GL_VERSION_1_2

        #region GL_VERSION_1_3

        /// <summary>
        /// select active texture unit
        /// <para>Require:</para> <para>GL_VERSION_1_3, GL_VERSION_ES_CM_1_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glActiveTexture"/> is only supported if the GL version is 1.3 or greater, or if
        /// <code>ARB_multitexture</code> is included in the string returned by
        /// <see cref="glGetString"/>  when called with the argument <code>GL_EXTENSIONS</code>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="texture"/> is not one of
        /// <code>GL_TEXTURE</code>   i   ,
        /// where i ranges from 0 to the larger of (<code>GL_MAX_TEXTURE_COORDS</code> - 1)
        /// and (<code>GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS</code> - 1).
        /// </para>
        /// Original: <para>void glActiveTexture(GLenum texture);</para>
        /// </summary>
        /// <param name="texture">
        /// <para>
        /// Specifies which texture unit to make active. The number
        /// of texture units is implementation dependent, but must be at least
        /// two. <paramref name="texture"/> must be one of 
        /// <code>GL_TEXTURE</code>   i   ,
        /// where
        /// i ranges from 0 to the larger of (<code>GL_MAX_TEXTURE_COORDS</code> - 1)
        /// and (<code>GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS</code> - 1). 
        /// The initial value is <code>GL_TEXTURE0</code>.
        /// </para>
        /// </param>
        /// <seealso cref="glClientActiveTexture"/>
        /// <seealso cref="glMultiTexCoord"/>
        /// <seealso cref="glTexParameter"/>
        public static void glActiveTexture(uint texture) {
            var _F = _GetProc<GLNativeDelegate.FNglActiveTexture>("glActiveTexture");
            _F(texture);
        }
        /// <summary>
        /// specify multisample coverage parameters
        /// <para>Require:</para> <para>GL_VERSION_1_3, GL_VERSION_ES_CM_1_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <see cref="glSampleCoverage"/> is available only if the GL version is 1.3 or greater.
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glSampleCoverage"/> is executed between the
        /// execution of  <see cref="glBegin"/>  and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glSampleCoverage(GLclampf value, GLboolean invert);</para>
        /// </summary>
        /// <param name="value">
        /// <para>
        /// Specify a single floating-point sample coverage value.  The value is
        /// clamped to the range 
        /// 0 
        /// 1 
        /// .
        /// The initial value is 1.0.
        /// </para>
        /// </param>
        /// <param name="invert">
        /// <para>
        /// Specify a single boolean value representing if the coverage masks should be
        /// inverted.  <code>GL_TRUE</code> and <code>GL_FALSE</code> are accepted.  The initial value
        /// is <code>GL_FALSE</code>.
        /// </para>
        /// </param>
        /// <seealso cref="glEnable"/>
        /// <seealso cref="glPushAttrib"/>
        public static void glSampleCoverage(float value, bool invert) {
            var _F = _GetProc<GLNativeDelegate.FNglSampleCoverage>("glSampleCoverage");
            _F(value, invert);
        }
        /// <summary>
        /// specify a three-dimensional texture image in a compressed format
        /// <para>Require:</para> <para>GL_VERSION_1_3, GL_ES_VERSION_3_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glCompressedTexImage3D"/> is available only if the GL version is 1.3 or greater.
        /// Non-power-of-two textures are supported if the GL version is 2.0 or greater, or if the implementation exports the <code>GL_ARB_texture_non_power_of_two</code> extension.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="internalformat"/> is one of the generic compressed internal formats: <code>GL_COMPRESSED_ALPHA</code>,
        /// <code>GL_COMPRESSED_LUMINANCE</code>, <code>GL_COMPRESSED_LUMINANCE_ALPHA</code>,
        /// <code>GL_COMPRESSED_INTENSITY</code>, <code>GL_COMPRESSED_RGB</code>, or
        /// <code>GL_COMPRESSED_RGBA</code>.
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="imageSize"/> is not consistent with
        /// the format, dimensions, and contents of the specified compressed image data.
        /// <code>GL_INVALID_OPERATION</code> is generated if parameter combinations are not
        /// supported by the specific compressed internal format as specified in the
        /// specific texture compression extension.
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_UNPACK_BUFFER</code> target and the buffer object's data store is currently mapped.
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_UNPACK_BUFFER</code> target and the data would be unpacked from the buffer 
        /// object such that the memory reads required would exceed the data store size.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glCompressedTexImage3D"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// Undefined results, including abnormal program termination, are generated if <paramref name="data"/> is not encoded in a manner consistent with the extension specification defining the internal compression format.
        /// </para>
        /// Original: <para>void glCompressedTexImage3D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const void * data);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target texture.
        /// Must be <code>GL_TEXTURE_3D</code> or <code>GL_PROXY_TEXTURE_3D</code>.
        /// </para>
        /// </param>
        /// <param name="level">
        /// <para>
        /// Specifies the level-of-detail number.
        /// Level 0 is the base image level.
        /// Level  n  is the  n th mipmap reduction image.
        /// </para>
        /// </param>
        /// <param name="internalformat">
        /// Specifies the format of the compressed image data stored at address <paramref name="data"/>.
        /// </param>
        /// <param name="width">
        /// <para>
        /// Specifies the width of the texture image including the border if any. If the GL version does not support non-power-of-two sizes, this value must be 
        /// 2 
        /// n 
        /// + 
        /// 2 
        /// &af; 
        /// border 
        /// for some integer 
        /// n   .
        /// All
        /// implementations support 3D texture images that are at least 16 texels
        /// wide.
        /// </para>
        /// </param>
        /// <param name="height">
        /// <para>
        /// Specifies the height of the texture image including the border if any. If the GL version does not support non-power-of-two sizes, this value must be 
        /// 2 
        /// n 
        /// + 
        /// 2 
        /// &af; 
        /// border 
        /// for some integer 
        /// n   .
        /// All
        /// implementations support 3D texture images that are at least 16 texels
        /// high.
        /// </para>
        /// </param>
        /// <param name="depth">
        /// <para>
        /// Specifies the depth of the texture image including the border if any. If the GL version does not support non-power-of-two sizes, this value must be 
        /// 2 
        /// n 
        /// + 
        /// 2 
        /// &af; 
        /// border 
        /// for some integer 
        /// n   .
        /// All
        /// implementations support 3D texture images that are at least 16 texels
        /// deep.
        /// </para>
        /// </param>
        /// <param name="border">
        /// <para>
        /// Specifies the width of the border.
        /// Must be either 0 or 1.
        /// </para>
        /// </param>
        /// <param name="imageSize">
        /// <para>
        /// Specifies the number of unsigned bytes of image data starting at the
        /// address specified by <paramref name="data"/>.
        /// </para>
        /// </param>
        /// <param name="data">
        /// Specifies a pointer to the compressed image data in memory.
        /// </param>
        /// <seealso cref="glActiveTexture"/>
        /// <seealso cref="glColorTable"/>
        /// <seealso cref="glCompressedTexImage1D"/>
        /// <seealso cref="glCompressedTexImage2D"/>
        /// <seealso cref="glCompressedTexSubImage1D"/>
        /// <seealso cref="glCompressedTexSubImage2D"/>
        /// <seealso cref="glCompressedTexSubImage3D"/>
        /// <seealso cref="glConvolutionFilter1D"/>
        /// <seealso cref="glCopyPixels"/>
        /// <seealso cref="glCopyTexImage1D"/>
        /// <seealso cref="glCopyTexSubImage1D"/>
        /// <seealso cref="glCopyTexSubImage2D"/>
        /// <seealso cref="glCopyTexSubImage3D"/>
        /// <seealso cref="glDrawPixels"/>
        /// <seealso cref="glMatrixMode"/>
        /// <seealso cref="glPixelStore"/>
        /// <seealso cref="glPixelTransfer"/>
        /// <seealso cref="glTexEnv"/>
        /// <seealso cref="glTexGen"/>
        /// <seealso cref="glTexImage1D"/>
        /// <seealso cref="glTexImage2D"/>
        /// <seealso cref="glTexSubImage1D"/>
        /// <seealso cref="glTexSubImage2D"/>
        /// <seealso cref="glTexSubImage3D"/>
        /// <seealso cref="glTexParameter"/>
        public unsafe static void glCompressedTexImage3D(uint target, int level, uint internalformat, int width, int height, int depth, int border, int imageSize, void* data) {
            var _F = _GetProc<GLNativeDelegate.FNglCompressedTexImage3D>("glCompressedTexImage3D");
            _F(target, level, internalformat, width, height, depth, border, imageSize, data);
        }
        /// <summary>
        /// specify a two-dimensional texture image in a compressed format
        /// <para>Require:</para> <para>GL_VERSION_1_3, GL_VERSION_ES_CM_1_0, GL_ES_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glCompressedTexImage2D"/> is available only if the GL version is 1.3 or greater.
        /// Non-power-of-two textures are supported if the GL version is 2.0 or greater, or if the implementation exports the <code>GL_ARB_texture_non_power_of_two</code> extension.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="internalformat"/> is one of the generic compressed internal formats: <code>GL_COMPRESSED_ALPHA</code>,
        /// <code>GL_COMPRESSED_LUMINANCE</code>, <code>GL_COMPRESSED_LUMINANCE_ALPHA</code>,
        /// <code>GL_COMPRESSED_INTENSITY</code>, <code>GL_COMPRESSED_RGB</code>, or
        /// <code>GL_COMPRESSED_RGBA</code>.
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="imageSize"/> is not consistent with
        /// the format, dimensions, and contents of the specified compressed image
        /// data.
        /// <code>GL_INVALID_OPERATION</code> is generated if parameter combinations are not
        /// supported by the specific compressed internal format as specified in the
        /// specific texture compression extension.
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_UNPACK_BUFFER</code> target and the buffer object's data store is currently mapped.
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_UNPACK_BUFFER</code> target and the data would be unpacked from the buffer 
        /// object such that the memory reads required would exceed the data store size.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glCompressedTexImage2D"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// Undefined results, including abnormal program termination, are generated if
        /// <paramref name="data"/> is not encoded in a manner consistent with the extension
        /// specification defining the internal compression format.
        /// </para>
        /// Original: <para>void glCompressedTexImage2D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const void * data);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target texture.
        /// Must be <code>GL_TEXTURE_2D</code>, <code>GL_PROXY_TEXTURE_2D</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_POSITIVE_X</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_NEGATIVE_X</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_POSITIVE_Y</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_NEGATIVE_Y</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_POSITIVE_Z</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_NEGATIVE_Z</code>, or
        /// <code>GL_PROXY_TEXTURE_CUBE_MAP</code>.
        /// </para>
        /// </param>
        /// <param name="level">
        /// <para>
        /// Specifies the level-of-detail number.
        /// Level 0 is the base image level.
        /// Level  n  is the  n th mipmap reduction image.
        /// </para>
        /// </param>
        /// <param name="internalformat">
        /// Specifies the format of the compressed image data stored at address <paramref name="data"/>.
        /// </param>
        /// <param name="width">
        /// <para>
        /// Specifies the width of the texture image including the border if any. If the GL version does not support non-power-of-two sizes, this value must be 
        /// 2 
        /// n 
        /// + 
        /// 2 
        /// &af; 
        /// border 
        /// for some integer 
        /// n   .
        /// All
        /// implementations support 2D texture images that are at least 64 texels
        /// wide and cube-mapped texture images that are at least 16 texels wide.
        /// </para>
        /// </param>
        /// <param name="height">
        /// <para>
        /// Specifies the height of the texture image including the border if any. If the GL version does not support non-power-of-two sizes, this value must be 
        /// Must be 
        /// 2 
        /// n 
        /// + 
        /// 2 
        /// &af; 
        /// border 
        /// for some integer 
        /// n   .
        /// All
        /// implementations support 2D texture images that are at least 64 texels
        /// high and cube-mapped texture images that are at least 16 texels high.
        /// </para>
        /// </param>
        /// <param name="border">
        /// <para>
        /// Specifies the width of the border.
        /// Must be either 0 or 1.
        /// </para>
        /// </param>
        /// <param name="imageSize">
        /// <para>
        /// Specifies the number of unsigned bytes of image data starting at the
        /// address specified by <paramref name="data"/>.
        /// </para>
        /// </param>
        /// <param name="data">
        /// Specifies a pointer to the compressed image data in memory.
        /// </param>
        /// <seealso cref="glActiveTexture"/>
        /// <seealso cref="glColorTable"/>
        /// <seealso cref="glCompressedTexImage1D"/>
        /// <seealso cref="glCompressedTexImage3D"/>
        /// <seealso cref="glCompressedTexSubImage1D"/>
        /// <seealso cref="glCompressedTexSubImage2D"/>
        /// <seealso cref="glCompressedTexSubImage3D"/>
        /// <seealso cref="glConvolutionFilter1D"/>
        /// <seealso cref="glCopyPixels"/>
        /// <seealso cref="glCopyTexImage1D"/>
        /// <seealso cref="glCopyTexSubImage1D"/>
        /// <seealso cref="glCopyTexSubImage2D"/>
        /// <seealso cref="glCopyTexSubImage3D"/>
        /// <seealso cref="glDrawPixels"/>
        /// <seealso cref="glMatrixMode"/>
        /// <seealso cref="glPixelStore"/>
        /// <seealso cref="glPixelTransfer"/>
        /// <seealso cref="glTexEnv"/>
        /// <seealso cref="glTexGen"/>
        /// <seealso cref="glTexImage2D"/>
        /// <seealso cref="glTexImage3D"/>
        /// <seealso cref="glTexSubImage1D"/>
        /// <seealso cref="glTexSubImage2D"/>
        /// <seealso cref="glTexSubImage3D"/>
        /// <seealso cref="glTexParameter"/>
        public unsafe static void glCompressedTexImage2D(uint target, int level, uint internalformat, int width, int height, int border, int imageSize, void* data) {
            var _F = _GetProc<GLNativeDelegate.FNglCompressedTexImage2D>("glCompressedTexImage2D");
            _F(target, level, internalformat, width, height, border, imageSize, data);
        }
        /// <summary>
        /// specify a one-dimensional texture image in a compressed format
        /// <para>Require:</para> <para>GL_VERSION_1_3</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glCompressedTexImage1D"/> is available only if the GL version is 1.3 or greater.
        /// Non-power-of-two textures are supported if the GL version is 2.0 or greater, or if the implementation exports the <code>GL_ARB_texture_non_power_of_two</code> extension.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="internalformat"/> is one of the generic compressed internal formats: <code>GL_COMPRESSED_ALPHA</code>,
        /// <code>GL_COMPRESSED_LUMINANCE</code>, <code>GL_COMPRESSED_LUMINANCE_ALPHA</code>,
        /// <code>GL_COMPRESSED_INTENSITY</code>, <code>GL_COMPRESSED_RGB</code>, or
        /// <code>GL_COMPRESSED_RGBA</code>.
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="imageSize"/> is not consistent with
        /// the format, dimensions, and contents of the specified compressed image
        /// data.
        /// <code>GL_INVALID_OPERATION</code> is generated if parameter combinations are not
        /// supported by the specific compressed internal format as specified in the
        /// specific texture compression extension.
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_UNPACK_BUFFER</code> target and the buffer object's data store is currently mapped.
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_UNPACK_BUFFER</code> target and the data would be unpacked from the buffer 
        /// object such that the memory reads required would exceed the data store size.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glCompressedTexImage1D"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// Undefined results, including abnormal program termination, are generated if
        /// <paramref name="data"/> is not encoded in a manner consistent with the extension
        /// specification defining the internal compression format.
        /// </para>
        /// Original: <para>void glCompressedTexImage1D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const void * data);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target texture.
        /// Must be <code>GL_TEXTURE_1D</code> or <code>GL_PROXY_TEXTURE_1D</code>.
        /// </para>
        /// </param>
        /// <param name="level">
        /// <para>
        /// Specifies the level-of-detail number.
        /// Level 0 is the base image level.
        /// Level  n  is the  n th mipmap reduction image.
        /// </para>
        /// </param>
        /// <param name="internalformat">
        /// Specifies the format of the compressed image data stored at address <paramref name="data"/>.
        /// </param>
        /// <param name="width">
        /// <para>
        /// Specifies the width of the texture image including the border if any. If the GL version does not support non-power-of-two sizes, this value must be 
        /// 2 
        /// n 
        /// + 
        /// 2 
        /// &af; 
        /// border 
        /// for some integer 
        /// n   .
        /// All implementations support texture images that are at least 64 texels wide. The height of the 1D texture image is 1.
        /// </para>
        /// </param>
        /// <param name="border">
        /// Specifies the width of the border. Must be either 0 or 1.
        /// </param>
        /// <param name="imageSize">
        /// Specifies the number of unsigned bytes of image data starting at the address specified by <paramref name="data"/>.
        /// </param>
        /// <param name="data">
        /// Specifies a pointer to the compressed image data in memory.
        /// </param>
        /// <seealso cref="glActiveTexture"/>
        /// <seealso cref="glColorTable"/>
        /// <seealso cref="glCompressedTexImage2D"/>
        /// <seealso cref="glCompressedTexImage3D"/>
        /// <seealso cref="glCompressedTexSubImage1D"/>
        /// <seealso cref="glCompressedTexSubImage2D"/>
        /// <seealso cref="glCompressedTexSubImage3D"/>
        /// <seealso cref="glConvolutionFilter1D"/>
        /// <seealso cref="glCopyPixels"/>
        /// <seealso cref="glCopyTexImage1D"/>
        /// <seealso cref="glCopyTexImage2D"/>
        /// <seealso cref="glCopyTexSubImage1D"/>
        /// <seealso cref="glCopyTexSubImage2D"/>
        /// <seealso cref="glCopyTexSubImage3D"/>
        /// <seealso cref="glDrawPixels"/>
        /// <seealso cref="glMatrixMode"/>
        /// <seealso cref="glPixelStore"/>
        /// <seealso cref="glPixelTransfer"/>
        /// <seealso cref="glTexEnv"/>
        /// <seealso cref="glTexGen"/>
        /// <seealso cref="glTexImage2D"/>
        /// <seealso cref="glTexImage3D"/>
        /// <seealso cref="glTexSubImage1D"/>
        /// <seealso cref="glTexSubImage2D"/>
        /// <seealso cref="glTexSubImage3D"/>
        /// <seealso cref="glTexParameter"/>
        public unsafe static void glCompressedTexImage1D(uint target, int level, uint internalformat, int width, int border, int imageSize, void* data) {
            var _F = _GetProc<GLNativeDelegate.FNglCompressedTexImage1D>("glCompressedTexImage1D");
            _F(target, level, internalformat, width, border, imageSize, data);
        }
        /// <summary>
        /// specify a three-dimensional texture subimage in a compressed format
        /// <para>Require:</para> <para>GL_VERSION_1_3, GL_ES_VERSION_3_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <see cref="glCompressedTexSubImage3D"/> is available only if the GL version is 1.3 or greater.
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="format"/> is one of these generic compressed internal formats: 
        /// <code>GL_COMPRESSED_ALPHA</code>,
        /// <code>GL_COMPRESSED_LUMINANCE</code>, 
        /// <code>GL_COMPRESSED_LUMINANCE_ALPHA</code>,
        /// <code>GL_COMPRESSED_INTENSITY</code>,             
        /// <code>GL_COMPRESSED_RGB</code>,
        /// <code>GL_COMPRESSED_RGBA</code>,
        /// <code>GL_COMPRESSED_SLUMINANCE</code>,
        /// <code>GL_COMPRESSED_SLUMINANCE_ALPHA</code>,
        /// <code>GL_COMPRESSED_SRGB</code>,
        /// <code>GL_COMPRESSED_SRGBA</code>, or
        /// <code>GL_COMPRESSED_SRGB_ALPHA</code>.
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="imageSize"/> is not consistent with
        /// the format, dimensions, and contents of the specified compressed image
        /// data.
        /// <code>GL_INVALID_OPERATION</code> is generated if parameter combinations are not
        /// supported by the specific compressed internal format as specified in the
        /// specific texture compression extension.
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_UNPACK_BUFFER</code> target and the buffer object's data store is currently mapped.
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_UNPACK_BUFFER</code> target and the data would be unpacked from the buffer 
        /// object such that the memory reads required would exceed the data store size.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glCompressedTexSubImage3D"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// Undefined results, including abnormal program termination, are generated if
        /// <paramref name="data"/> is not encoded in a manner consistent with the extension
        /// specification defining the internal compression format.
        /// </para>
        /// Original: <para>void glCompressedTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void * data);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target texture.
        /// Must be <code>GL_TEXTURE_3D</code>.
        /// </para>
        /// </param>
        /// <param name="level">
        /// <para>
        /// Specifies the level-of-detail number.
        /// Level 0 is the base image level.
        /// Level  n  is the  n th mipmap reduction image.
        /// </para>
        /// </param>
        /// <param name="xoffset">
        /// Specifies a texel offset in the x direction within the texture array.
        /// </param>
        /// <param name="yoffset">
        /// Specifies a texel offset in the y direction within the texture array.
        /// </param>
        /// <param name="width">
        /// Specifies the width of the texture subimage.
        /// </param>
        /// <param name="height">
        /// Specifies the height of the texture subimage.
        /// </param>
        /// <param name="depth">
        /// Specifies the depth of the texture subimage.
        /// </param>
        /// <param name="format">
        /// Specifies the format of the compressed image data stored at address <paramref name="data"/>.
        /// </param>
        /// <param name="imageSize">
        /// <para>
        /// Specifies the number of unsigned bytes of image data starting at the
        /// address specified by <paramref name="data"/>.
        /// </para>
        /// </param>
        /// <param name="data">
        /// Specifies a pointer to the compressed image data in memory.
        /// </param>
        /// <seealso cref="glActiveTexture"/>
        /// <seealso cref="glColorTable"/>
        /// <seealso cref="glCompressedTexImage1D"/>
        /// <seealso cref="glCompressedTexImage2D"/>
        /// <seealso cref="glCompressedTexImage3D"/>
        /// <seealso cref="glCompressedTexSubImage1D"/>
        /// <seealso cref="glCompressedTexSubImage2D"/>
        /// <seealso cref="glConvolutionFilter1D"/>
        /// <seealso cref="glCopyPixels"/>
        /// <seealso cref="glCopyTexImage1D"/>
        /// <seealso cref="glCopyTexImage2D"/>
        /// <seealso cref="glCopyTexSubImage1D"/>
        /// <seealso cref="glCopyTexSubImage2D"/>
        /// <seealso cref="glCopyTexSubImage3D"/>
        /// <seealso cref="glDrawPixels"/>
        /// <seealso cref="glMatrixMode"/>
        /// <seealso cref="glPixelStore"/>
        /// <seealso cref="glPixelTransfer"/>
        /// <seealso cref="glTexEnv"/>
        /// <seealso cref="glTexGen"/>
        /// <seealso cref="glTexImage2D"/>
        /// <seealso cref="glTexImage3D"/>
        /// <seealso cref="glTexSubImage1D"/>
        /// <seealso cref="glTexSubImage2D"/>
        /// <seealso cref="glTexSubImage3D"/>
        /// <seealso cref="glTexParameter"/>
        public unsafe static void glCompressedTexSubImage3D(uint target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, uint format, int imageSize, void* data) {
            var _F = _GetProc<GLNativeDelegate.FNglCompressedTexSubImage3D>("glCompressedTexSubImage3D");
            _F(target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data);
        }
        /// <summary>
        /// specify a two-dimensional texture subimage in a compressed format
        /// <para>Require:</para> <para>GL_VERSION_1_3, GL_VERSION_ES_CM_1_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glCompressedTexSubImage2D"/> is available only if the GL version is 1.3 or greater.
        /// <code>GL_TEXTURE_CUBE_MAP_POSITIVE_X</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_NEGATIVE_X</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_POSITIVE_Y</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_NEGATIVE_Y</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_POSITIVE_Z</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_NEGATIVE_Z</code>, or
        /// <code>GL_PROXY_TEXTURE_CUBE_MAP</code> are available only if the GL version is 1.3
        /// or greater.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="format"/> is one of these generic compressed internal formats: 
        /// <code>GL_COMPRESSED_ALPHA</code>,
        /// <code>GL_COMPRESSED_LUMINANCE</code>, 
        /// <code>GL_COMPRESSED_LUMINANCE_ALPHA</code>,
        /// <code>GL_COMPRESSED_INTENSITY</code>,             
        /// <code>GL_COMPRESSED_RGB</code>,
        /// <code>GL_COMPRESSED_RGBA</code>,
        /// <code>GL_COMPRESSED_SLUMINANCE</code>,
        /// <code>GL_COMPRESSED_SLUMINANCE_ALPHA</code>,
        /// <code>GL_COMPRESSED_SRGB</code>,
        /// <code>GL_COMPRESSED_SRGBA</code>, or
        /// <code>GL_COMPRESSED_SRGB_ALPHA</code>.
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="imageSize"/> is not consistent with
        /// the format, dimensions, and contents of the specified compressed image
        /// data.
        /// <code>GL_INVALID_OPERATION</code> is generated if parameter combinations are not
        /// supported by the specific compressed internal format as specified in the
        /// specific texture compression extension.
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_UNPACK_BUFFER</code> target and the buffer object's data store is currently mapped.
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_UNPACK_BUFFER</code> target and the data would be unpacked from the buffer 
        /// object such that the memory reads required would exceed the data store size.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glCompressedTexSubImage2D"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// Undefined results, including abnormal program termination, are generated if
        /// <paramref name="data"/> is not encoded in a manner consistent with the extension
        /// specification defining the internal compression format.
        /// </para>
        /// Original: <para>void glCompressedTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void * data);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target texture.
        /// Must be <code>GL_TEXTURE_2D</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_POSITIVE_X</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_NEGATIVE_X</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_POSITIVE_Y</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_NEGATIVE_Y</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_POSITIVE_Z</code>, or
        /// <code>GL_TEXTURE_CUBE_MAP_NEGATIVE_Z</code>.
        /// </para>
        /// </param>
        /// <param name="level">
        /// <para>
        /// Specifies the level-of-detail number.
        /// Level 0 is the base image level.
        /// Level  n  is the  n th mipmap reduction image.
        /// </para>
        /// </param>
        /// <param name="xoffset">
        /// Specifies a texel offset in the x direction within the texture array.
        /// </param>
        /// <param name="yoffset">
        /// Specifies a texel offset in the y direction within the texture array.
        /// </param>
        /// <param name="width">
        /// Specifies the width of the texture subimage.
        /// </param>
        /// <param name="height">
        /// Specifies the height of the texture subimage.
        /// </param>
        /// <param name="format">
        /// Specifies the format of the compressed image data stored at address <paramref name="data"/>.
        /// </param>
        /// <param name="imageSize">
        /// <para>
        /// Specifies the number of unsigned bytes of image data starting at the
        /// address specified by <paramref name="data"/>.
        /// </para>
        /// </param>
        /// <param name="data">
        /// Specifies a pointer to the compressed image data in memory.
        /// </param>
        /// <seealso cref="glActiveTexture"/>
        /// <seealso cref="glColorTable"/>
        /// <seealso cref="glCompressedTexImage1D"/>
        /// <seealso cref="glCompressedTexImage2D"/>
        /// <seealso cref="glCompressedTexImage3D"/>
        /// <seealso cref="glCompressedTexSubImage1D"/>
        /// <seealso cref="glCompressedTexSubImage3D"/>
        /// <seealso cref="glConvolutionFilter1D"/>
        /// <seealso cref="glCopyPixels"/>
        /// <seealso cref="glCopyTexImage1D"/>
        /// <seealso cref="glCopyTexImage2D"/>
        /// <seealso cref="glCopyTexSubImage1D"/>
        /// <seealso cref="glCopyTexSubImage2D"/>
        /// <seealso cref="glCopyTexSubImage3D"/>
        /// <seealso cref="glDrawPixels"/>
        /// <seealso cref="glMatrixMode"/>
        /// <seealso cref="glPixelStore"/>
        /// <seealso cref="glPixelTransfer"/>
        /// <seealso cref="glTexEnv"/>
        /// <seealso cref="glTexGen"/>
        /// <seealso cref="glTexImage2D"/>
        /// <seealso cref="glTexImage3D"/>
        /// <seealso cref="glTexSubImage1D"/>
        /// <seealso cref="glTexSubImage2D"/>
        /// <seealso cref="glTexSubImage3D"/>
        /// <seealso cref="glTexParameter"/>
        public unsafe static void glCompressedTexSubImage2D(uint target, int level, int xoffset, int yoffset, int width, int height, uint format, int imageSize, void* data) {
            var _F = _GetProc<GLNativeDelegate.FNglCompressedTexSubImage2D>("glCompressedTexSubImage2D");
            _F(target, level, xoffset, yoffset, width, height, format, imageSize, data);
        }
        /// <summary>
        /// specify a one-dimensional texture subimage in a compressed format
        /// <para>Require:</para> <para>GL_VERSION_1_3</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <see cref="glCompressedTexSubImage1D"/> is available only if the GL version is 1.3 or greater.
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="format"/> is one of these generic compressed internal formats: 
        /// <code>GL_COMPRESSED_ALPHA</code>,
        /// <code>GL_COMPRESSED_LUMINANCE</code>, 
        /// <code>GL_COMPRESSED_LUMINANCE_ALPHA</code>,
        /// <code>GL_COMPRESSED_INTENSITY</code>,             
        /// <code>GL_COMPRESSED_RGB</code>,
        /// <code>GL_COMPRESSED_RGBA</code>,
        /// <code>GL_COMPRESSED_SLUMINANCE</code>,
        /// <code>GL_COMPRESSED_SLUMINANCE_ALPHA</code>,
        /// <code>GL_COMPRESSED_SRGB</code>,
        /// <code>GL_COMPRESSED_SRGBA</code>, or
        /// <code>GL_COMPRESSED_SRGB_ALPHA</code>.
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="imageSize"/> is not consistent with
        /// the format, dimensions, and contents of the specified compressed image
        /// data.
        /// <code>GL_INVALID_OPERATION</code> is generated if parameter combinations are not
        /// supported by the specific compressed internal format as specified in the
        /// specific texture compression extension.
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_UNPACK_BUFFER</code> target and the buffer object's data store is currently mapped.
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_UNPACK_BUFFER</code> target and the data would be unpacked from the buffer 
        /// object such that the memory reads required would exceed the data store size.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glCompressedTexSubImage1D"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// Undefined results, including abnormal program termination, are generated if
        /// <paramref name="data"/> is not encoded in a manner consistent with the extension
        /// specification defining the internal compression format.
        /// </para>
        /// Original: <para>void glCompressedTexSubImage1D(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const void * data);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target texture.
        /// Must be <code>GL_TEXTURE_1D</code>.
        /// </para>
        /// </param>
        /// <param name="level">
        /// <para>
        /// Specifies the level-of-detail number.
        /// Level 0 is the base image level.
        /// Level  n  is the  n th mipmap reduction image.
        /// </para>
        /// </param>
        /// <param name="xoffset">
        /// Specifies a texel offset in the x direction within the texture array.
        /// </param>
        /// <param name="width">
        /// Specifies the width of the texture subimage.
        /// </param>
        /// <param name="format">
        /// Specifies the format of the compressed image data stored at address <paramref name="data"/>.
        /// </param>
        /// <param name="imageSize">
        /// <para>
        /// Specifies the number of unsigned bytes of image data starting at the
        /// address specified by <paramref name="data"/>.
        /// </para>
        /// </param>
        /// <param name="data">
        /// Specifies a pointer to the compressed image data in memory.
        /// </param>
        /// <seealso cref="glActiveTexture"/>
        /// <seealso cref="glColorTable"/>
        /// <seealso cref="glCompressedTexImage1D"/>
        /// <seealso cref="glCompressedTexImage2D"/>
        /// <seealso cref="glCompressedTexImage3D"/>
        /// <seealso cref="glCompressedTexSubImage2D"/>
        /// <seealso cref="glCompressedTexSubImage3D"/>
        /// <seealso cref="glConvolutionFilter1D"/>
        /// <seealso cref="glCopyPixels"/>
        /// <seealso cref="glCopyTexImage1D"/>
        /// <seealso cref="glCopyTexImage2D"/>
        /// <seealso cref="glCopyTexSubImage1D"/>
        /// <seealso cref="glCopyTexSubImage2D"/>
        /// <seealso cref="glCopyTexSubImage3D"/>
        /// <seealso cref="glDrawPixels"/>
        /// <seealso cref="glMatrixMode"/>
        /// <seealso cref="glPixelStore"/>
        /// <seealso cref="glPixelTransfer"/>
        /// <seealso cref="glTexEnv"/>
        /// <seealso cref="glTexGen"/>
        /// <seealso cref="glTexImage2D"/>
        /// <seealso cref="glTexImage3D"/>
        /// <seealso cref="glTexSubImage1D"/>
        /// <seealso cref="glTexSubImage2D"/>
        /// <seealso cref="glTexSubImage3D"/>
        /// <seealso cref="glTexParameter"/>
        public unsafe static void glCompressedTexSubImage1D(uint target, int level, int xoffset, int width, uint format, int imageSize, void* data) {
            var _F = _GetProc<GLNativeDelegate.FNglCompressedTexSubImage1D>("glCompressedTexSubImage1D");
            _F(target, level, xoffset, width, format, imageSize, data);
        }
        /// <summary>
        /// return a compressed texture image
        /// <para>Require:</para> <para>GL_VERSION_1_3</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <see cref="glGetCompressedTexImage"/> is available only if the GL version is 1.3 or greater.
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="lod"/> is less than zero or greater
        /// than the maximum number of LODs permitted by the implementation.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glGetCompressedTexImage"/> is used to retrieve a
        /// texture that is in an uncompressed internal format.
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_PACK_BUFFER</code> target and the buffer object's data store is currently mapped.
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_PACK_BUFFER</code> target and the data would be packed to the buffer 
        /// object such that the memory writes required would exceed the data store size.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glGetCompressedTexImage"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glGetCompressedTexImage(GLenum target, GLint lod, void * img);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies which texture is to be obtained.
        /// <code>GL_TEXTURE_1D</code>, <code>GL_TEXTURE_2D</code>, and <code>GL_TEXTURE_3D</code>
        /// <code>GL_TEXTURE_CUBE_MAP_POSITIVE_X</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_NEGATIVE_X</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_POSITIVE_Y</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_NEGATIVE_Y</code>,
        /// <code>GL_TEXTURE_CUBE_MAP_POSITIVE_Z</code>, and
        /// <code>GL_TEXTURE_CUBE_MAP_NEGATIVE_Z</code>
        /// are accepted.
        /// </para>
        /// </param>
        /// <param name="lod">
        /// <para>
        /// Specifies the level-of-detail number of the desired image.
        /// Level 0 is the base image level.
        /// Level 
        /// n   
        /// is the 
        /// n   th
        /// mipmap reduction image.
        /// </para>
        /// </param>
        /// <param name="img">
        /// Returns the compressed texture image.
        /// </param>
        /// <seealso cref="glActiveTexture"/>
        /// <seealso cref="glCompressedTexImage1D"/>
        /// <seealso cref="glCompressedTexImage2D"/>
        /// <seealso cref="glCompressedTexImage3D"/>
        /// <seealso cref="glCompressedTexSubImage1D"/>
        /// <seealso cref="glCompressedTexSubImage2D"/>
        /// <seealso cref="glCompressedTexSubImage3D"/>
        /// <seealso cref="glDrawPixels"/>
        /// <seealso cref="glReadPixels"/>
        /// <seealso cref="glTexEnv"/>
        /// <seealso cref="glTexGen"/>
        /// <seealso cref="glTexImage1D"/>
        /// <seealso cref="glTexImage2D"/>
        /// <seealso cref="glTexImage3D"/>
        /// <seealso cref="glTexParameter"/>
        /// <seealso cref="glTexSubImage1D"/>
        /// <seealso cref="glTexSubImage2D"/>
        /// <seealso cref="glTexSubImage3D"/>
        public unsafe static void glGetCompressedTexImage(uint target, int lod, void* img) {
            var _F = _GetProc<GLNativeDelegate.FNglGetCompressedTexImage>("glGetCompressedTexImage");
            _F(target, lod, img);
        }
        /// <summary>
        /// select active texture unit
        /// <para>Require:</para> <para>GL_VERSION_1_3, GL_VERSION_ES_CM_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glClientActiveTexture"/> is supported only if the GL version is 1.3 or greater, or
        /// <code>ARB_multitexture</code> is included in the string returned by
        /// <see cref="glGetString"/>  when called with the argument <code>GL_EXTENSIONS</code>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="texture"/> is not one of
        /// <code>GL_TEXTURE</code>   i   ,
        /// where
        /// i ranges from 0 to the value of <code>GL_MAX_TEXTURE_COORDS</code> - 1.
        /// </para>
        /// Original: <para>void glClientActiveTexture(GLenum texture);</para>
        /// </summary>
        /// <param name="texture">
        /// <para>
        /// Specifies which texture unit to make active. The number
        /// of texture units is implementation dependent, but must be at least
        /// two. <paramref name="texture"/> must be one of 
        /// <code>GL_TEXTURE</code>   i   ,
        /// where i ranges from 0 to the value of <code>GL_MAX_TEXTURE_COORDS</code> - 1, which is an
        /// implementation-dependent value.  The initial value is
        /// <code>GL_TEXTURE0</code>.
        /// </para>
        /// </param>
        /// <seealso cref="glActiveTexture"/>
        /// <seealso cref="glDisableClientState"/>
        /// <seealso cref="glEnableClientState"/>
        /// <seealso cref="glMultiTexCoord"/>
        /// <seealso cref="glTexCoordPointer"/>
        [Obsolete("Compatibility-only GL 1.3 features removed from GL 3.2")]
        public static void glClientActiveTexture(uint texture) {
            var _F = _GetProc<GLNativeDelegate.FNglClientActiveTexture>("glClientActiveTexture");
            _F(texture);
        }
        /// <summary>
        /// set the current texture coordinates
        /// <para>Require:</para> <para>GL_VERSION_1_3</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glMultiTexCoord"/> is only supported if the GL version is 1.3 or greater, or if
        /// <code>ARB_multitexture</code> is included in the string returned by
        /// <see cref="glGetString"/>  when called with the argument <code>GL_EXTENSIONS</code>.
        /// The current texture coordinates can be updated at any time.
        /// In particular,
        /// <see cref="glMultiTexCoord"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// It is always the case that <code>GL_TEXTURE</code>
        /// i   
        /// = <code>GL_TEXTURE0</code> + 
        /// i   .
        /// </para>
        /// Original: <para>void glMultiTexCoord1d(GLenum target, GLdouble s);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the texture unit whose coordinates should be modified. The number
        /// of texture units is implementation dependent, but must be at least
        /// two. Symbolic constant must be one of 
        /// <code>GL_TEXTURE</code>   i   ,
        /// where i ranges from 0 to <code>GL_MAX_TEXTURE_COORDS</code> - 1,
        /// which is an implementation-dependent value.
        /// </para>
        /// </param>
        /// <param name="s">
        /// <para>
        /// Specify <paramref name="s"/>, <paramref name="t"/>, <paramref name="r"/>, and <paramref name="q"/> texture coordinates for
        /// <paramref name="target"/> texture unit. Not all parameters are present in all forms
        /// of the command.
        /// </para>
        /// </param>
        /// <seealso cref="glActiveTexture"/>
        /// <seealso cref="glClientActiveTexture"/>
        /// <seealso cref="glTexCoord"/>
        /// <seealso cref="glTexCoordPointer"/>
        /// <seealso cref="glVertex"/>
        [Obsolete("Compatibility-only GL 1.3 features removed from GL 3.2")]
        public static void glMultiTexCoord1d(uint target, double s) {
            var _F = _GetProc<GLNativeDelegate.FNglMultiTexCoord1d>("glMultiTexCoord1d");
            _F(target, s);
        }
        /// <summary>
        /// set the current texture coordinates
        /// <para>Require:</para> <para>GL_VERSION_1_3</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glMultiTexCoord"/> is only supported if the GL version is 1.3 or greater, or if
        /// <code>ARB_multitexture</code> is included in the string returned by
        /// <see cref="glGetString"/>  when called with the argument <code>GL_EXTENSIONS</code>.
        /// The current texture coordinates can be updated at any time.
        /// In particular,
        /// <see cref="glMultiTexCoord"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// It is always the case that <code>GL_TEXTURE</code>
        /// i   
        /// = <code>GL_TEXTURE0</code> + 
        /// i   .
        /// </para>
        /// Original: <para>void glMultiTexCoord1dv(GLenum target, const GLdouble * v);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the texture unit whose coordinates should be modified. The number
        /// of texture units is implementation dependent, but must be at least
        /// two. Symbolic constant must be one of 
        /// <code>GL_TEXTURE</code>   i   ,
        /// where i ranges from 0 to <code>GL_MAX_TEXTURE_COORDS</code> - 1,
        /// which is an implementation-dependent value.
        /// </para>
        /// </param>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array of one, two, three, or four elements,
        /// which in turn specify the 
        /// s   ,
        /// t   ,
        /// r   ,
        /// and 
        /// q   
        /// texture coordinates.
        /// </para>
        /// </param>
        /// <seealso cref="glActiveTexture"/>
        /// <seealso cref="glClientActiveTexture"/>
        /// <seealso cref="glTexCoord"/>
        /// <seealso cref="glTexCoordPointer"/>
        /// <seealso cref="glVertex"/>
        [Obsolete("Compatibility-only GL 1.3 features removed from GL 3.2")]
        public unsafe static void glMultiTexCoord1dv(uint target, double* v) {
            var _F = _GetProc<GLNativeDelegate.FNglMultiTexCoord1dv>("glMultiTexCoord1dv");
            _F(target, v);
        }
        /// <summary>
        /// set the current texture coordinates
        /// <para>Require:</para> <para>GL_VERSION_1_3</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glMultiTexCoord"/> is only supported if the GL version is 1.3 or greater, or if
        /// <code>ARB_multitexture</code> is included in the string returned by
        /// <see cref="glGetString"/>  when called with the argument <code>GL_EXTENSIONS</code>.
        /// The current texture coordinates can be updated at any time.
        /// In particular,
        /// <see cref="glMultiTexCoord"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// It is always the case that <code>GL_TEXTURE</code>
        /// i   
        /// = <code>GL_TEXTURE0</code> + 
        /// i   .
        /// </para>
        /// Original: <para>void glMultiTexCoord1f(GLenum target, GLfloat s);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the texture unit whose coordinates should be modified. The number
        /// of texture units is implementation dependent, but must be at least
        /// two. Symbolic constant must be one of 
        /// <code>GL_TEXTURE</code>   i   ,
        /// where i ranges from 0 to <code>GL_MAX_TEXTURE_COORDS</code> - 1,
        /// which is an implementation-dependent value.
        /// </para>
        /// </param>
        /// <param name="s">
        /// <para>
        /// Specify <paramref name="s"/>, <paramref name="t"/>, <paramref name="r"/>, and <paramref name="q"/> texture coordinates for
        /// <paramref name="target"/> texture unit. Not all parameters are present in all forms
        /// of the command.
        /// </para>
        /// </param>
        /// <seealso cref="glActiveTexture"/>
        /// <seealso cref="glClientActiveTexture"/>
        /// <seealso cref="glTexCoord"/>
        /// <seealso cref="glTexCoordPointer"/>
        /// <seealso cref="glVertex"/>
        [Obsolete("Compatibility-only GL 1.3 features removed from GL 3.2")]
        public static void glMultiTexCoord1f(uint target, float s) {
            var _F = _GetProc<GLNativeDelegate.FNglMultiTexCoord1f>("glMultiTexCoord1f");
            _F(target, s);
        }
        /// <summary>
        /// set the current texture coordinates
        /// <para>Require:</para> <para>GL_VERSION_1_3</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glMultiTexCoord"/> is only supported if the GL version is 1.3 or greater, or if
        /// <code>ARB_multitexture</code> is included in the string returned by
        /// <see cref="glGetString"/>  when called with the argument <code>GL_EXTENSIONS</code>.
        /// The current texture coordinates can be updated at any time.
        /// In particular,
        /// <see cref="glMultiTexCoord"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// It is always the case that <code>GL_TEXTURE</code>
        /// i   
        /// = <code>GL_TEXTURE0</code> + 
        /// i   .
        /// </para>
        /// Original: <para>void glMultiTexCoord1fv(GLenum target, const GLfloat * v);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the texture unit whose coordinates should be modified. The number
        /// of texture units is implementation dependent, but must be at least
        /// two. Symbolic constant must be one of 
        /// <code>GL_TEXTURE</code>   i   ,
        /// where i ranges from 0 to <code>GL_MAX_TEXTURE_COORDS</code> - 1,
        /// which is an implementation-dependent value.
        /// </para>
        /// </param>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array of one, two, three, or four elements,
        /// which in turn specify the 
        /// s   ,
        /// t   ,
        /// r   ,
        /// and 
        /// q   
        /// texture coordinates.
        /// </para>
        /// </param>
        /// <seealso cref="glActiveTexture"/>
        /// <seealso cref="glClientActiveTexture"/>
        /// <seealso cref="glTexCoord"/>
        /// <seealso cref="glTexCoordPointer"/>
        /// <seealso cref="glVertex"/>
        [Obsolete("Compatibility-only GL 1.3 features removed from GL 3.2")]
        public unsafe static void glMultiTexCoord1fv(uint target, float* v) {
            var _F = _GetProc<GLNativeDelegate.FNglMultiTexCoord1fv>("glMultiTexCoord1fv");
            _F(target, v);
        }
        /// <summary>
        /// set the current texture coordinates
        /// <para>Require:</para> <para>GL_VERSION_1_3</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glMultiTexCoord"/> is only supported if the GL version is 1.3 or greater, or if
        /// <code>ARB_multitexture</code> is included in the string returned by
        /// <see cref="glGetString"/>  when called with the argument <code>GL_EXTENSIONS</code>.
        /// The current texture coordinates can be updated at any time.
        /// In particular,
        /// <see cref="glMultiTexCoord"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// It is always the case that <code>GL_TEXTURE</code>
        /// i   
        /// = <code>GL_TEXTURE0</code> + 
        /// i   .
        /// </para>
        /// Original: <para>void glMultiTexCoord1i(GLenum target, GLint s);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the texture unit whose coordinates should be modified. The number
        /// of texture units is implementation dependent, but must be at least
        /// two. Symbolic constant must be one of 
        /// <code>GL_TEXTURE</code>   i   ,
        /// where i ranges from 0 to <code>GL_MAX_TEXTURE_COORDS</code> - 1,
        /// which is an implementation-dependent value.
        /// </para>
        /// </param>
        /// <param name="s">
        /// <para>
        /// Specify <paramref name="s"/>, <paramref name="t"/>, <paramref name="r"/>, and <paramref name="q"/> texture coordinates for
        /// <paramref name="target"/> texture unit. Not all parameters are present in all forms
        /// of the command.
        /// </para>
        /// </param>
        /// <seealso cref="glActiveTexture"/>
        /// <seealso cref="glClientActiveTexture"/>
        /// <seealso cref="glTexCoord"/>
        /// <seealso cref="glTexCoordPointer"/>
        /// <seealso cref="glVertex"/>
        [Obsolete("Compatibility-only GL 1.3 features removed from GL 3.2")]
        public static void glMultiTexCoord1i(uint target, int s) {
            var _F = _GetProc<GLNativeDelegate.FNglMultiTexCoord1i>("glMultiTexCoord1i");
            _F(target, s);
        }
        /// <summary>
        /// set the current texture coordinates
        /// <para>Require:</para> <para>GL_VERSION_1_3</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glMultiTexCoord"/> is only supported if the GL version is 1.3 or greater, or if
        /// <code>ARB_multitexture</code> is included in the string returned by
        /// <see cref="glGetString"/>  when called with the argument <code>GL_EXTENSIONS</code>.
        /// The current texture coordinates can be updated at any time.
        /// In particular,
        /// <see cref="glMultiTexCoord"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// It is always the case that <code>GL_TEXTURE</code>
        /// i   
        /// = <code>GL_TEXTURE0</code> + 
        /// i   .
        /// </para>
        /// Original: <para>void glMultiTexCoord1iv(GLenum target, const GLint * v);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the texture unit whose coordinates should be modified. The number
        /// of texture units is implementation dependent, but must be at least
        /// two. Symbolic constant must be one of 
        /// <code>GL_TEXTURE</code>   i   ,
        /// where i ranges from 0 to <code>GL_MAX_TEXTURE_COORDS</code> - 1,
        /// which is an implementation-dependent value.
        /// </para>
        /// </param>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array of one, two, three, or four elements,
        /// which in turn specify the 
        /// s   ,
        /// t   ,
        /// r   ,
        /// and 
        /// q   
        /// texture coordinates.
        /// </para>
        /// </param>
        /// <seealso cref="glActiveTexture"/>
        /// <seealso cref="glClientActiveTexture"/>
        /// <seealso cref="glTexCoord"/>
        /// <seealso cref="glTexCoordPointer"/>
        /// <seealso cref="glVertex"/>
        [Obsolete("Compatibility-only GL 1.3 features removed from GL 3.2")]
        public unsafe static void glMultiTexCoord1iv(uint target, int* v) {
            var _F = _GetProc<GLNativeDelegate.FNglMultiTexCoord1iv>("glMultiTexCoord1iv");
            _F(target, v);
        }
        /// <summary>
        /// set the current texture coordinates
        /// <para>Require:</para> <para>GL_VERSION_1_3</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glMultiTexCoord"/> is only supported if the GL version is 1.3 or greater, or if
        /// <code>ARB_multitexture</code> is included in the string returned by
        /// <see cref="glGetString"/>  when called with the argument <code>GL_EXTENSIONS</code>.
        /// The current texture coordinates can be updated at any time.
        /// In particular,
        /// <see cref="glMultiTexCoord"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// It is always the case that <code>GL_TEXTURE</code>
        /// i   
        /// = <code>GL_TEXTURE0</code> + 
        /// i   .
        /// </para>
        /// Original: <para>void glMultiTexCoord1s(GLenum target, GLshort s);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the texture unit whose coordinates should be modified. The number
        /// of texture units is implementation dependent, but must be at least
        /// two. Symbolic constant must be one of 
        /// <code>GL_TEXTURE</code>   i   ,
        /// where i ranges from 0 to <code>GL_MAX_TEXTURE_COORDS</code> - 1,
        /// which is an implementation-dependent value.
        /// </para>
        /// </param>
        /// <param name="s">
        /// <para>
        /// Specify <paramref name="s"/>, <paramref name="t"/>, <paramref name="r"/>, and <paramref name="q"/> texture coordinates for
        /// <paramref name="target"/> texture unit. Not all parameters are present in all forms
        /// of the command.
        /// </para>
        /// </param>
        /// <seealso cref="glActiveTexture"/>
        /// <seealso cref="glClientActiveTexture"/>
        /// <seealso cref="glTexCoord"/>
        /// <seealso cref="glTexCoordPointer"/>
        /// <seealso cref="glVertex"/>
        [Obsolete("Compatibility-only GL 1.3 features removed from GL 3.2")]
        public static void glMultiTexCoord1s(uint target, short s) {
            var _F = _GetProc<GLNativeDelegate.FNglMultiTexCoord1s>("glMultiTexCoord1s");
            _F(target, s);
        }
        /// <summary>
        /// set the current texture coordinates
        /// <para>Require:</para> <para>GL_VERSION_1_3</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glMultiTexCoord"/> is only supported if the GL version is 1.3 or greater, or if
        /// <code>ARB_multitexture</code> is included in the string returned by
        /// <see cref="glGetString"/>  when called with the argument <code>GL_EXTENSIONS</code>.
        /// The current texture coordinates can be updated at any time.
        /// In particular,
        /// <see cref="glMultiTexCoord"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// It is always the case that <code>GL_TEXTURE</code>
        /// i   
        /// = <code>GL_TEXTURE0</code> + 
        /// i   .
        /// </para>
        /// Original: <para>void glMultiTexCoord1sv(GLenum target, const GLshort * v);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the texture unit whose coordinates should be modified. The number
        /// of texture units is implementation dependent, but must be at least
        /// two. Symbolic constant must be one of 
        /// <code>GL_TEXTURE</code>   i   ,
        /// where i ranges from 0 to <code>GL_MAX_TEXTURE_COORDS</code> - 1,
        /// which is an implementation-dependent value.
        /// </para>
        /// </param>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array of one, two, three, or four elements,
        /// which in turn specify the 
        /// s   ,
        /// t   ,
        /// r   ,
        /// and 
        /// q   
        /// texture coordinates.
        /// </para>
        /// </param>
        /// <seealso cref="glActiveTexture"/>
        /// <seealso cref="glClientActiveTexture"/>
        /// <seealso cref="glTexCoord"/>
        /// <seealso cref="glTexCoordPointer"/>
        /// <seealso cref="glVertex"/>
        [Obsolete("Compatibility-only GL 1.3 features removed from GL 3.2")]
        public unsafe static void glMultiTexCoord1sv(uint target, short* v) {
            var _F = _GetProc<GLNativeDelegate.FNglMultiTexCoord1sv>("glMultiTexCoord1sv");
            _F(target, v);
        }
        /// <summary>
        /// set the current texture coordinates
        /// <para>Require:</para> <para>GL_VERSION_1_3</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glMultiTexCoord"/> is only supported if the GL version is 1.3 or greater, or if
        /// <code>ARB_multitexture</code> is included in the string returned by
        /// <see cref="glGetString"/>  when called with the argument <code>GL_EXTENSIONS</code>.
        /// The current texture coordinates can be updated at any time.
        /// In particular,
        /// <see cref="glMultiTexCoord"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// It is always the case that <code>GL_TEXTURE</code>
        /// i   
        /// = <code>GL_TEXTURE0</code> + 
        /// i   .
        /// </para>
        /// Original: <para>void glMultiTexCoord2d(GLenum target, GLdouble s, GLdouble t);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the texture unit whose coordinates should be modified. The number
        /// of texture units is implementation dependent, but must be at least
        /// two. Symbolic constant must be one of 
        /// <code>GL_TEXTURE</code>   i   ,
        /// where i ranges from 0 to <code>GL_MAX_TEXTURE_COORDS</code> - 1,
        /// which is an implementation-dependent value.
        /// </para>
        /// </param>
        /// <param name="s">
        /// <para>
        /// Specify <paramref name="s"/>, <paramref name="t"/>, <paramref name="r"/>, and <paramref name="q"/> texture coordinates for
        /// <paramref name="target"/> texture unit. Not all parameters are present in all forms
        /// of the command.
        /// </para>
        /// </param>
        /// <param name="t">
        /// <para>
        /// Specify <paramref name="s"/>, <paramref name="t"/>, <paramref name="r"/>, and <paramref name="q"/> texture coordinates for
        /// <paramref name="target"/> texture unit. Not all parameters are present in all forms
        /// of the command.
        /// </para>
        /// </param>
        /// <seealso cref="glActiveTexture"/>
        /// <seealso cref="glClientActiveTexture"/>
        /// <seealso cref="glTexCoord"/>
        /// <seealso cref="glTexCoordPointer"/>
        /// <seealso cref="glVertex"/>
        [Obsolete("Compatibility-only GL 1.3 features removed from GL 3.2")]
        public static void glMultiTexCoord2d(uint target, double s, double t) {
            var _F = _GetProc<GLNativeDelegate.FNglMultiTexCoord2d>("glMultiTexCoord2d");
            _F(target, s, t);
        }
        /// <summary>
        /// set the current texture coordinates
        /// <para>Require:</para> <para>GL_VERSION_1_3</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glMultiTexCoord"/> is only supported if the GL version is 1.3 or greater, or if
        /// <code>ARB_multitexture</code> is included in the string returned by
        /// <see cref="glGetString"/>  when called with the argument <code>GL_EXTENSIONS</code>.
        /// The current texture coordinates can be updated at any time.
        /// In particular,
        /// <see cref="glMultiTexCoord"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// It is always the case that <code>GL_TEXTURE</code>
        /// i   
        /// = <code>GL_TEXTURE0</code> + 
        /// i   .
        /// </para>
        /// Original: <para>void glMultiTexCoord2dv(GLenum target, const GLdouble * v);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the texture unit whose coordinates should be modified. The number
        /// of texture units is implementation dependent, but must be at least
        /// two. Symbolic constant must be one of 
        /// <code>GL_TEXTURE</code>   i   ,
        /// where i ranges from 0 to <code>GL_MAX_TEXTURE_COORDS</code> - 1,
        /// which is an implementation-dependent value.
        /// </para>
        /// </param>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array of one, two, three, or four elements,
        /// which in turn specify the 
        /// s   ,
        /// t   ,
        /// r   ,
        /// and 
        /// q   
        /// texture coordinates.
        /// </para>
        /// </param>
        /// <seealso cref="glActiveTexture"/>
        /// <seealso cref="glClientActiveTexture"/>
        /// <seealso cref="glTexCoord"/>
        /// <seealso cref="glTexCoordPointer"/>
        /// <seealso cref="glVertex"/>
        [Obsolete("Compatibility-only GL 1.3 features removed from GL 3.2")]
        public unsafe static void glMultiTexCoord2dv(uint target, double* v) {
            var _F = _GetProc<GLNativeDelegate.FNglMultiTexCoord2dv>("glMultiTexCoord2dv");
            _F(target, v);
        }
        /// <summary>
        /// set the current texture coordinates
        /// <para>Require:</para> <para>GL_VERSION_1_3</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glMultiTexCoord"/> is only supported if the GL version is 1.3 or greater, or if
        /// <code>ARB_multitexture</code> is included in the string returned by
        /// <see cref="glGetString"/>  when called with the argument <code>GL_EXTENSIONS</code>.
        /// The current texture coordinates can be updated at any time.
        /// In particular,
        /// <see cref="glMultiTexCoord"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// It is always the case that <code>GL_TEXTURE</code>
        /// i   
        /// = <code>GL_TEXTURE0</code> + 
        /// i   .
        /// </para>
        /// Original: <para>void glMultiTexCoord2f(GLenum target, GLfloat s, GLfloat t);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the texture unit whose coordinates should be modified. The number
        /// of texture units is implementation dependent, but must be at least
        /// two. Symbolic constant must be one of 
        /// <code>GL_TEXTURE</code>   i   ,
        /// where i ranges from 0 to <code>GL_MAX_TEXTURE_COORDS</code> - 1,
        /// which is an implementation-dependent value.
        /// </para>
        /// </param>
        /// <param name="s">
        /// <para>
        /// Specify <paramref name="s"/>, <paramref name="t"/>, <paramref name="r"/>, and <paramref name="q"/> texture coordinates for
        /// <paramref name="target"/> texture unit. Not all parameters are present in all forms
        /// of the command.
        /// </para>
        /// </param>
        /// <param name="t">
        /// <para>
        /// Specify <paramref name="s"/>, <paramref name="t"/>, <paramref name="r"/>, and <paramref name="q"/> texture coordinates for
        /// <paramref name="target"/> texture unit. Not all parameters are present in all forms
        /// of the command.
        /// </para>
        /// </param>
        /// <seealso cref="glActiveTexture"/>
        /// <seealso cref="glClientActiveTexture"/>
        /// <seealso cref="glTexCoord"/>
        /// <seealso cref="glTexCoordPointer"/>
        /// <seealso cref="glVertex"/>
        [Obsolete("Compatibility-only GL 1.3 features removed from GL 3.2")]
        public static void glMultiTexCoord2f(uint target, float s, float t) {
            var _F = _GetProc<GLNativeDelegate.FNglMultiTexCoord2f>("glMultiTexCoord2f");
            _F(target, s, t);
        }
        /// <summary>
        /// set the current texture coordinates
        /// <para>Require:</para> <para>GL_VERSION_1_3</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glMultiTexCoord"/> is only supported if the GL version is 1.3 or greater, or if
        /// <code>ARB_multitexture</code> is included in the string returned by
        /// <see cref="glGetString"/>  when called with the argument <code>GL_EXTENSIONS</code>.
        /// The current texture coordinates can be updated at any time.
        /// In particular,
        /// <see cref="glMultiTexCoord"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// It is always the case that <code>GL_TEXTURE</code>
        /// i   
        /// = <code>GL_TEXTURE0</code> + 
        /// i   .
        /// </para>
        /// Original: <para>void glMultiTexCoord2fv(GLenum target, const GLfloat * v);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the texture unit whose coordinates should be modified. The number
        /// of texture units is implementation dependent, but must be at least
        /// two. Symbolic constant must be one of 
        /// <code>GL_TEXTURE</code>   i   ,
        /// where i ranges from 0 to <code>GL_MAX_TEXTURE_COORDS</code> - 1,
        /// which is an implementation-dependent value.
        /// </para>
        /// </param>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array of one, two, three, or four elements,
        /// which in turn specify the 
        /// s   ,
        /// t   ,
        /// r   ,
        /// and 
        /// q   
        /// texture coordinates.
        /// </para>
        /// </param>
        /// <seealso cref="glActiveTexture"/>
        /// <seealso cref="glClientActiveTexture"/>
        /// <seealso cref="glTexCoord"/>
        /// <seealso cref="glTexCoordPointer"/>
        /// <seealso cref="glVertex"/>
        [Obsolete("Compatibility-only GL 1.3 features removed from GL 3.2")]
        public unsafe static void glMultiTexCoord2fv(uint target, float* v) {
            var _F = _GetProc<GLNativeDelegate.FNglMultiTexCoord2fv>("glMultiTexCoord2fv");
            _F(target, v);
        }
        /// <summary>
        /// set the current texture coordinates
        /// <para>Require:</para> <para>GL_VERSION_1_3</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glMultiTexCoord"/> is only supported if the GL version is 1.3 or greater, or if
        /// <code>ARB_multitexture</code> is included in the string returned by
        /// <see cref="glGetString"/>  when called with the argument <code>GL_EXTENSIONS</code>.
        /// The current texture coordinates can be updated at any time.
        /// In particular,
        /// <see cref="glMultiTexCoord"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// It is always the case that <code>GL_TEXTURE</code>
        /// i   
        /// = <code>GL_TEXTURE0</code> + 
        /// i   .
        /// </para>
        /// Original: <para>void glMultiTexCoord2i(GLenum target, GLint s, GLint t);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the texture unit whose coordinates should be modified. The number
        /// of texture units is implementation dependent, but must be at least
        /// two. Symbolic constant must be one of 
        /// <code>GL_TEXTURE</code>   i   ,
        /// where i ranges from 0 to <code>GL_MAX_TEXTURE_COORDS</code> - 1,
        /// which is an implementation-dependent value.
        /// </para>
        /// </param>
        /// <param name="s">
        /// <para>
        /// Specify <paramref name="s"/>, <paramref name="t"/>, <paramref name="r"/>, and <paramref name="q"/> texture coordinates for
        /// <paramref name="target"/> texture unit. Not all parameters are present in all forms
        /// of the command.
        /// </para>
        /// </param>
        /// <param name="t">
        /// <para>
        /// Specify <paramref name="s"/>, <paramref name="t"/>, <paramref name="r"/>, and <paramref name="q"/> texture coordinates for
        /// <paramref name="target"/> texture unit. Not all parameters are present in all forms
        /// of the command.
        /// </para>
        /// </param>
        /// <seealso cref="glActiveTexture"/>
        /// <seealso cref="glClientActiveTexture"/>
        /// <seealso cref="glTexCoord"/>
        /// <seealso cref="glTexCoordPointer"/>
        /// <seealso cref="glVertex"/>
        [Obsolete("Compatibility-only GL 1.3 features removed from GL 3.2")]
        public static void glMultiTexCoord2i(uint target, int s, int t) {
            var _F = _GetProc<GLNativeDelegate.FNglMultiTexCoord2i>("glMultiTexCoord2i");
            _F(target, s, t);
        }
        /// <summary>
        /// set the current texture coordinates
        /// <para>Require:</para> <para>GL_VERSION_1_3</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glMultiTexCoord"/> is only supported if the GL version is 1.3 or greater, or if
        /// <code>ARB_multitexture</code> is included in the string returned by
        /// <see cref="glGetString"/>  when called with the argument <code>GL_EXTENSIONS</code>.
        /// The current texture coordinates can be updated at any time.
        /// In particular,
        /// <see cref="glMultiTexCoord"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// It is always the case that <code>GL_TEXTURE</code>
        /// i   
        /// = <code>GL_TEXTURE0</code> + 
        /// i   .
        /// </para>
        /// Original: <para>void glMultiTexCoord2iv(GLenum target, const GLint * v);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the texture unit whose coordinates should be modified. The number
        /// of texture units is implementation dependent, but must be at least
        /// two. Symbolic constant must be one of 
        /// <code>GL_TEXTURE</code>   i   ,
        /// where i ranges from 0 to <code>GL_MAX_TEXTURE_COORDS</code> - 1,
        /// which is an implementation-dependent value.
        /// </para>
        /// </param>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array of one, two, three, or four elements,
        /// which in turn specify the 
        /// s   ,
        /// t   ,
        /// r   ,
        /// and 
        /// q   
        /// texture coordinates.
        /// </para>
        /// </param>
        /// <seealso cref="glActiveTexture"/>
        /// <seealso cref="glClientActiveTexture"/>
        /// <seealso cref="glTexCoord"/>
        /// <seealso cref="glTexCoordPointer"/>
        /// <seealso cref="glVertex"/>
        [Obsolete("Compatibility-only GL 1.3 features removed from GL 3.2")]
        public unsafe static void glMultiTexCoord2iv(uint target, int* v) {
            var _F = _GetProc<GLNativeDelegate.FNglMultiTexCoord2iv>("glMultiTexCoord2iv");
            _F(target, v);
        }
        /// <summary>
        /// set the current texture coordinates
        /// <para>Require:</para> <para>GL_VERSION_1_3</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glMultiTexCoord"/> is only supported if the GL version is 1.3 or greater, or if
        /// <code>ARB_multitexture</code> is included in the string returned by
        /// <see cref="glGetString"/>  when called with the argument <code>GL_EXTENSIONS</code>.
        /// The current texture coordinates can be updated at any time.
        /// In particular,
        /// <see cref="glMultiTexCoord"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// It is always the case that <code>GL_TEXTURE</code>
        /// i   
        /// = <code>GL_TEXTURE0</code> + 
        /// i   .
        /// </para>
        /// Original: <para>void glMultiTexCoord2s(GLenum target, GLshort s, GLshort t);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the texture unit whose coordinates should be modified. The number
        /// of texture units is implementation dependent, but must be at least
        /// two. Symbolic constant must be one of 
        /// <code>GL_TEXTURE</code>   i   ,
        /// where i ranges from 0 to <code>GL_MAX_TEXTURE_COORDS</code> - 1,
        /// which is an implementation-dependent value.
        /// </para>
        /// </param>
        /// <param name="s">
        /// <para>
        /// Specify <paramref name="s"/>, <paramref name="t"/>, <paramref name="r"/>, and <paramref name="q"/> texture coordinates for
        /// <paramref name="target"/> texture unit. Not all parameters are present in all forms
        /// of the command.
        /// </para>
        /// </param>
        /// <param name="t">
        /// <para>
        /// Specify <paramref name="s"/>, <paramref name="t"/>, <paramref name="r"/>, and <paramref name="q"/> texture coordinates for
        /// <paramref name="target"/> texture unit. Not all parameters are present in all forms
        /// of the command.
        /// </para>
        /// </param>
        /// <seealso cref="glActiveTexture"/>
        /// <seealso cref="glClientActiveTexture"/>
        /// <seealso cref="glTexCoord"/>
        /// <seealso cref="glTexCoordPointer"/>
        /// <seealso cref="glVertex"/>
        [Obsolete("Compatibility-only GL 1.3 features removed from GL 3.2")]
        public static void glMultiTexCoord2s(uint target, short s, short t) {
            var _F = _GetProc<GLNativeDelegate.FNglMultiTexCoord2s>("glMultiTexCoord2s");
            _F(target, s, t);
        }
        /// <summary>
        /// set the current texture coordinates
        /// <para>Require:</para> <para>GL_VERSION_1_3</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glMultiTexCoord"/> is only supported if the GL version is 1.3 or greater, or if
        /// <code>ARB_multitexture</code> is included in the string returned by
        /// <see cref="glGetString"/>  when called with the argument <code>GL_EXTENSIONS</code>.
        /// The current texture coordinates can be updated at any time.
        /// In particular,
        /// <see cref="glMultiTexCoord"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// It is always the case that <code>GL_TEXTURE</code>
        /// i   
        /// = <code>GL_TEXTURE0</code> + 
        /// i   .
        /// </para>
        /// Original: <para>void glMultiTexCoord2sv(GLenum target, const GLshort * v);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the texture unit whose coordinates should be modified. The number
        /// of texture units is implementation dependent, but must be at least
        /// two. Symbolic constant must be one of 
        /// <code>GL_TEXTURE</code>   i   ,
        /// where i ranges from 0 to <code>GL_MAX_TEXTURE_COORDS</code> - 1,
        /// which is an implementation-dependent value.
        /// </para>
        /// </param>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array of one, two, three, or four elements,
        /// which in turn specify the 
        /// s   ,
        /// t   ,
        /// r   ,
        /// and 
        /// q   
        /// texture coordinates.
        /// </para>
        /// </param>
        /// <seealso cref="glActiveTexture"/>
        /// <seealso cref="glClientActiveTexture"/>
        /// <seealso cref="glTexCoord"/>
        /// <seealso cref="glTexCoordPointer"/>
        /// <seealso cref="glVertex"/>
        [Obsolete("Compatibility-only GL 1.3 features removed from GL 3.2")]
        public unsafe static void glMultiTexCoord2sv(uint target, short* v) {
            var _F = _GetProc<GLNativeDelegate.FNglMultiTexCoord2sv>("glMultiTexCoord2sv");
            _F(target, v);
        }
        /// <summary>
        /// set the current texture coordinates
        /// <para>Require:</para> <para>GL_VERSION_1_3</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glMultiTexCoord"/> is only supported if the GL version is 1.3 or greater, or if
        /// <code>ARB_multitexture</code> is included in the string returned by
        /// <see cref="glGetString"/>  when called with the argument <code>GL_EXTENSIONS</code>.
        /// The current texture coordinates can be updated at any time.
        /// In particular,
        /// <see cref="glMultiTexCoord"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// It is always the case that <code>GL_TEXTURE</code>
        /// i   
        /// = <code>GL_TEXTURE0</code> + 
        /// i   .
        /// </para>
        /// Original: <para>void glMultiTexCoord3d(GLenum target, GLdouble s, GLdouble t, GLdouble r);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the texture unit whose coordinates should be modified. The number
        /// of texture units is implementation dependent, but must be at least
        /// two. Symbolic constant must be one of 
        /// <code>GL_TEXTURE</code>   i   ,
        /// where i ranges from 0 to <code>GL_MAX_TEXTURE_COORDS</code> - 1,
        /// which is an implementation-dependent value.
        /// </para>
        /// </param>
        /// <param name="s">
        /// <para>
        /// Specify <paramref name="s"/>, <paramref name="t"/>, <paramref name="r"/>, and <paramref name="q"/> texture coordinates for
        /// <paramref name="target"/> texture unit. Not all parameters are present in all forms
        /// of the command.
        /// </para>
        /// </param>
        /// <param name="t">
        /// <para>
        /// Specify <paramref name="s"/>, <paramref name="t"/>, <paramref name="r"/>, and <paramref name="q"/> texture coordinates for
        /// <paramref name="target"/> texture unit. Not all parameters are present in all forms
        /// of the command.
        /// </para>
        /// </param>
        /// <param name="r">
        /// <para>
        /// Specify <paramref name="s"/>, <paramref name="t"/>, <paramref name="r"/>, and <paramref name="q"/> texture coordinates for
        /// <paramref name="target"/> texture unit. Not all parameters are present in all forms
        /// of the command.
        /// </para>
        /// </param>
        /// <seealso cref="glActiveTexture"/>
        /// <seealso cref="glClientActiveTexture"/>
        /// <seealso cref="glTexCoord"/>
        /// <seealso cref="glTexCoordPointer"/>
        /// <seealso cref="glVertex"/>
        [Obsolete("Compatibility-only GL 1.3 features removed from GL 3.2")]
        public static void glMultiTexCoord3d(uint target, double s, double t, double r) {
            var _F = _GetProc<GLNativeDelegate.FNglMultiTexCoord3d>("glMultiTexCoord3d");
            _F(target, s, t, r);
        }
        /// <summary>
        /// set the current texture coordinates
        /// <para>Require:</para> <para>GL_VERSION_1_3</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glMultiTexCoord"/> is only supported if the GL version is 1.3 or greater, or if
        /// <code>ARB_multitexture</code> is included in the string returned by
        /// <see cref="glGetString"/>  when called with the argument <code>GL_EXTENSIONS</code>.
        /// The current texture coordinates can be updated at any time.
        /// In particular,
        /// <see cref="glMultiTexCoord"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// It is always the case that <code>GL_TEXTURE</code>
        /// i   
        /// = <code>GL_TEXTURE0</code> + 
        /// i   .
        /// </para>
        /// Original: <para>void glMultiTexCoord3dv(GLenum target, const GLdouble * v);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the texture unit whose coordinates should be modified. The number
        /// of texture units is implementation dependent, but must be at least
        /// two. Symbolic constant must be one of 
        /// <code>GL_TEXTURE</code>   i   ,
        /// where i ranges from 0 to <code>GL_MAX_TEXTURE_COORDS</code> - 1,
        /// which is an implementation-dependent value.
        /// </para>
        /// </param>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array of one, two, three, or four elements,
        /// which in turn specify the 
        /// s   ,
        /// t   ,
        /// r   ,
        /// and 
        /// q   
        /// texture coordinates.
        /// </para>
        /// </param>
        /// <seealso cref="glActiveTexture"/>
        /// <seealso cref="glClientActiveTexture"/>
        /// <seealso cref="glTexCoord"/>
        /// <seealso cref="glTexCoordPointer"/>
        /// <seealso cref="glVertex"/>
        [Obsolete("Compatibility-only GL 1.3 features removed from GL 3.2")]
        public unsafe static void glMultiTexCoord3dv(uint target, double* v) {
            var _F = _GetProc<GLNativeDelegate.FNglMultiTexCoord3dv>("glMultiTexCoord3dv");
            _F(target, v);
        }
        /// <summary>
        /// set the current texture coordinates
        /// <para>Require:</para> <para>GL_VERSION_1_3</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glMultiTexCoord"/> is only supported if the GL version is 1.3 or greater, or if
        /// <code>ARB_multitexture</code> is included in the string returned by
        /// <see cref="glGetString"/>  when called with the argument <code>GL_EXTENSIONS</code>.
        /// The current texture coordinates can be updated at any time.
        /// In particular,
        /// <see cref="glMultiTexCoord"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// It is always the case that <code>GL_TEXTURE</code>
        /// i   
        /// = <code>GL_TEXTURE0</code> + 
        /// i   .
        /// </para>
        /// Original: <para>void glMultiTexCoord3f(GLenum target, GLfloat s, GLfloat t, GLfloat r);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the texture unit whose coordinates should be modified. The number
        /// of texture units is implementation dependent, but must be at least
        /// two. Symbolic constant must be one of 
        /// <code>GL_TEXTURE</code>   i   ,
        /// where i ranges from 0 to <code>GL_MAX_TEXTURE_COORDS</code> - 1,
        /// which is an implementation-dependent value.
        /// </para>
        /// </param>
        /// <param name="s">
        /// <para>
        /// Specify <paramref name="s"/>, <paramref name="t"/>, <paramref name="r"/>, and <paramref name="q"/> texture coordinates for
        /// <paramref name="target"/> texture unit. Not all parameters are present in all forms
        /// of the command.
        /// </para>
        /// </param>
        /// <param name="t">
        /// <para>
        /// Specify <paramref name="s"/>, <paramref name="t"/>, <paramref name="r"/>, and <paramref name="q"/> texture coordinates for
        /// <paramref name="target"/> texture unit. Not all parameters are present in all forms
        /// of the command.
        /// </para>
        /// </param>
        /// <param name="r">
        /// <para>
        /// Specify <paramref name="s"/>, <paramref name="t"/>, <paramref name="r"/>, and <paramref name="q"/> texture coordinates for
        /// <paramref name="target"/> texture unit. Not all parameters are present in all forms
        /// of the command.
        /// </para>
        /// </param>
        /// <seealso cref="glActiveTexture"/>
        /// <seealso cref="glClientActiveTexture"/>
        /// <seealso cref="glTexCoord"/>
        /// <seealso cref="glTexCoordPointer"/>
        /// <seealso cref="glVertex"/>
        [Obsolete("Compatibility-only GL 1.3 features removed from GL 3.2")]
        public static void glMultiTexCoord3f(uint target, float s, float t, float r) {
            var _F = _GetProc<GLNativeDelegate.FNglMultiTexCoord3f>("glMultiTexCoord3f");
            _F(target, s, t, r);
        }
        /// <summary>
        /// set the current texture coordinates
        /// <para>Require:</para> <para>GL_VERSION_1_3</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glMultiTexCoord"/> is only supported if the GL version is 1.3 or greater, or if
        /// <code>ARB_multitexture</code> is included in the string returned by
        /// <see cref="glGetString"/>  when called with the argument <code>GL_EXTENSIONS</code>.
        /// The current texture coordinates can be updated at any time.
        /// In particular,
        /// <see cref="glMultiTexCoord"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// It is always the case that <code>GL_TEXTURE</code>
        /// i   
        /// = <code>GL_TEXTURE0</code> + 
        /// i   .
        /// </para>
        /// Original: <para>void glMultiTexCoord3fv(GLenum target, const GLfloat * v);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the texture unit whose coordinates should be modified. The number
        /// of texture units is implementation dependent, but must be at least
        /// two. Symbolic constant must be one of 
        /// <code>GL_TEXTURE</code>   i   ,
        /// where i ranges from 0 to <code>GL_MAX_TEXTURE_COORDS</code> - 1,
        /// which is an implementation-dependent value.
        /// </para>
        /// </param>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array of one, two, three, or four elements,
        /// which in turn specify the 
        /// s   ,
        /// t   ,
        /// r   ,
        /// and 
        /// q   
        /// texture coordinates.
        /// </para>
        /// </param>
        /// <seealso cref="glActiveTexture"/>
        /// <seealso cref="glClientActiveTexture"/>
        /// <seealso cref="glTexCoord"/>
        /// <seealso cref="glTexCoordPointer"/>
        /// <seealso cref="glVertex"/>
        [Obsolete("Compatibility-only GL 1.3 features removed from GL 3.2")]
        public unsafe static void glMultiTexCoord3fv(uint target, float* v) {
            var _F = _GetProc<GLNativeDelegate.FNglMultiTexCoord3fv>("glMultiTexCoord3fv");
            _F(target, v);
        }
        /// <summary>
        /// set the current texture coordinates
        /// <para>Require:</para> <para>GL_VERSION_1_3</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glMultiTexCoord"/> is only supported if the GL version is 1.3 or greater, or if
        /// <code>ARB_multitexture</code> is included in the string returned by
        /// <see cref="glGetString"/>  when called with the argument <code>GL_EXTENSIONS</code>.
        /// The current texture coordinates can be updated at any time.
        /// In particular,
        /// <see cref="glMultiTexCoord"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// It is always the case that <code>GL_TEXTURE</code>
        /// i   
        /// = <code>GL_TEXTURE0</code> + 
        /// i   .
        /// </para>
        /// Original: <para>void glMultiTexCoord3i(GLenum target, GLint s, GLint t, GLint r);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the texture unit whose coordinates should be modified. The number
        /// of texture units is implementation dependent, but must be at least
        /// two. Symbolic constant must be one of 
        /// <code>GL_TEXTURE</code>   i   ,
        /// where i ranges from 0 to <code>GL_MAX_TEXTURE_COORDS</code> - 1,
        /// which is an implementation-dependent value.
        /// </para>
        /// </param>
        /// <param name="s">
        /// <para>
        /// Specify <paramref name="s"/>, <paramref name="t"/>, <paramref name="r"/>, and <paramref name="q"/> texture coordinates for
        /// <paramref name="target"/> texture unit. Not all parameters are present in all forms
        /// of the command.
        /// </para>
        /// </param>
        /// <param name="t">
        /// <para>
        /// Specify <paramref name="s"/>, <paramref name="t"/>, <paramref name="r"/>, and <paramref name="q"/> texture coordinates for
        /// <paramref name="target"/> texture unit. Not all parameters are present in all forms
        /// of the command.
        /// </para>
        /// </param>
        /// <param name="r">
        /// <para>
        /// Specify <paramref name="s"/>, <paramref name="t"/>, <paramref name="r"/>, and <paramref name="q"/> texture coordinates for
        /// <paramref name="target"/> texture unit. Not all parameters are present in all forms
        /// of the command.
        /// </para>
        /// </param>
        /// <seealso cref="glActiveTexture"/>
        /// <seealso cref="glClientActiveTexture"/>
        /// <seealso cref="glTexCoord"/>
        /// <seealso cref="glTexCoordPointer"/>
        /// <seealso cref="glVertex"/>
        [Obsolete("Compatibility-only GL 1.3 features removed from GL 3.2")]
        public static void glMultiTexCoord3i(uint target, int s, int t, int r) {
            var _F = _GetProc<GLNativeDelegate.FNglMultiTexCoord3i>("glMultiTexCoord3i");
            _F(target, s, t, r);
        }
        /// <summary>
        /// set the current texture coordinates
        /// <para>Require:</para> <para>GL_VERSION_1_3</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glMultiTexCoord"/> is only supported if the GL version is 1.3 or greater, or if
        /// <code>ARB_multitexture</code> is included in the string returned by
        /// <see cref="glGetString"/>  when called with the argument <code>GL_EXTENSIONS</code>.
        /// The current texture coordinates can be updated at any time.
        /// In particular,
        /// <see cref="glMultiTexCoord"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// It is always the case that <code>GL_TEXTURE</code>
        /// i   
        /// = <code>GL_TEXTURE0</code> + 
        /// i   .
        /// </para>
        /// Original: <para>void glMultiTexCoord3iv(GLenum target, const GLint * v);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the texture unit whose coordinates should be modified. The number
        /// of texture units is implementation dependent, but must be at least
        /// two. Symbolic constant must be one of 
        /// <code>GL_TEXTURE</code>   i   ,
        /// where i ranges from 0 to <code>GL_MAX_TEXTURE_COORDS</code> - 1,
        /// which is an implementation-dependent value.
        /// </para>
        /// </param>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array of one, two, three, or four elements,
        /// which in turn specify the 
        /// s   ,
        /// t   ,
        /// r   ,
        /// and 
        /// q   
        /// texture coordinates.
        /// </para>
        /// </param>
        /// <seealso cref="glActiveTexture"/>
        /// <seealso cref="glClientActiveTexture"/>
        /// <seealso cref="glTexCoord"/>
        /// <seealso cref="glTexCoordPointer"/>
        /// <seealso cref="glVertex"/>
        [Obsolete("Compatibility-only GL 1.3 features removed from GL 3.2")]
        public unsafe static void glMultiTexCoord3iv(uint target, int* v) {
            var _F = _GetProc<GLNativeDelegate.FNglMultiTexCoord3iv>("glMultiTexCoord3iv");
            _F(target, v);
        }
        /// <summary>
        /// set the current texture coordinates
        /// <para>Require:</para> <para>GL_VERSION_1_3</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glMultiTexCoord"/> is only supported if the GL version is 1.3 or greater, or if
        /// <code>ARB_multitexture</code> is included in the string returned by
        /// <see cref="glGetString"/>  when called with the argument <code>GL_EXTENSIONS</code>.
        /// The current texture coordinates can be updated at any time.
        /// In particular,
        /// <see cref="glMultiTexCoord"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// It is always the case that <code>GL_TEXTURE</code>
        /// i   
        /// = <code>GL_TEXTURE0</code> + 
        /// i   .
        /// </para>
        /// Original: <para>void glMultiTexCoord3s(GLenum target, GLshort s, GLshort t, GLshort r);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the texture unit whose coordinates should be modified. The number
        /// of texture units is implementation dependent, but must be at least
        /// two. Symbolic constant must be one of 
        /// <code>GL_TEXTURE</code>   i   ,
        /// where i ranges from 0 to <code>GL_MAX_TEXTURE_COORDS</code> - 1,
        /// which is an implementation-dependent value.
        /// </para>
        /// </param>
        /// <param name="s">
        /// <para>
        /// Specify <paramref name="s"/>, <paramref name="t"/>, <paramref name="r"/>, and <paramref name="q"/> texture coordinates for
        /// <paramref name="target"/> texture unit. Not all parameters are present in all forms
        /// of the command.
        /// </para>
        /// </param>
        /// <param name="t">
        /// <para>
        /// Specify <paramref name="s"/>, <paramref name="t"/>, <paramref name="r"/>, and <paramref name="q"/> texture coordinates for
        /// <paramref name="target"/> texture unit. Not all parameters are present in all forms
        /// of the command.
        /// </para>
        /// </param>
        /// <param name="r">
        /// <para>
        /// Specify <paramref name="s"/>, <paramref name="t"/>, <paramref name="r"/>, and <paramref name="q"/> texture coordinates for
        /// <paramref name="target"/> texture unit. Not all parameters are present in all forms
        /// of the command.
        /// </para>
        /// </param>
        /// <seealso cref="glActiveTexture"/>
        /// <seealso cref="glClientActiveTexture"/>
        /// <seealso cref="glTexCoord"/>
        /// <seealso cref="glTexCoordPointer"/>
        /// <seealso cref="glVertex"/>
        [Obsolete("Compatibility-only GL 1.3 features removed from GL 3.2")]
        public static void glMultiTexCoord3s(uint target, short s, short t, short r) {
            var _F = _GetProc<GLNativeDelegate.FNglMultiTexCoord3s>("glMultiTexCoord3s");
            _F(target, s, t, r);
        }
        /// <summary>
        /// set the current texture coordinates
        /// <para>Require:</para> <para>GL_VERSION_1_3</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glMultiTexCoord"/> is only supported if the GL version is 1.3 or greater, or if
        /// <code>ARB_multitexture</code> is included in the string returned by
        /// <see cref="glGetString"/>  when called with the argument <code>GL_EXTENSIONS</code>.
        /// The current texture coordinates can be updated at any time.
        /// In particular,
        /// <see cref="glMultiTexCoord"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// It is always the case that <code>GL_TEXTURE</code>
        /// i   
        /// = <code>GL_TEXTURE0</code> + 
        /// i   .
        /// </para>
        /// Original: <para>void glMultiTexCoord3sv(GLenum target, const GLshort * v);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the texture unit whose coordinates should be modified. The number
        /// of texture units is implementation dependent, but must be at least
        /// two. Symbolic constant must be one of 
        /// <code>GL_TEXTURE</code>   i   ,
        /// where i ranges from 0 to <code>GL_MAX_TEXTURE_COORDS</code> - 1,
        /// which is an implementation-dependent value.
        /// </para>
        /// </param>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array of one, two, three, or four elements,
        /// which in turn specify the 
        /// s   ,
        /// t   ,
        /// r   ,
        /// and 
        /// q   
        /// texture coordinates.
        /// </para>
        /// </param>
        /// <seealso cref="glActiveTexture"/>
        /// <seealso cref="glClientActiveTexture"/>
        /// <seealso cref="glTexCoord"/>
        /// <seealso cref="glTexCoordPointer"/>
        /// <seealso cref="glVertex"/>
        [Obsolete("Compatibility-only GL 1.3 features removed from GL 3.2")]
        public unsafe static void glMultiTexCoord3sv(uint target, short* v) {
            var _F = _GetProc<GLNativeDelegate.FNglMultiTexCoord3sv>("glMultiTexCoord3sv");
            _F(target, v);
        }
        /// <summary>
        /// set the current texture coordinates
        /// <para>Require:</para> <para>GL_VERSION_1_3</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glMultiTexCoord"/> is only supported if the GL version is 1.3 or greater, or if
        /// <code>ARB_multitexture</code> is included in the string returned by
        /// <see cref="glGetString"/>  when called with the argument <code>GL_EXTENSIONS</code>.
        /// The current texture coordinates can be updated at any time.
        /// In particular,
        /// <see cref="glMultiTexCoord"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// It is always the case that <code>GL_TEXTURE</code>
        /// i   
        /// = <code>GL_TEXTURE0</code> + 
        /// i   .
        /// </para>
        /// Original: <para>void glMultiTexCoord4d(GLenum target, GLdouble s, GLdouble t, GLdouble r, GLdouble q);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the texture unit whose coordinates should be modified. The number
        /// of texture units is implementation dependent, but must be at least
        /// two. Symbolic constant must be one of 
        /// <code>GL_TEXTURE</code>   i   ,
        /// where i ranges from 0 to <code>GL_MAX_TEXTURE_COORDS</code> - 1,
        /// which is an implementation-dependent value.
        /// </para>
        /// </param>
        /// <param name="s">
        /// <para>
        /// Specify <paramref name="s"/>, <paramref name="t"/>, <paramref name="r"/>, and <paramref name="q"/> texture coordinates for
        /// <paramref name="target"/> texture unit. Not all parameters are present in all forms
        /// of the command.
        /// </para>
        /// </param>
        /// <param name="t">
        /// <para>
        /// Specify <paramref name="s"/>, <paramref name="t"/>, <paramref name="r"/>, and <paramref name="q"/> texture coordinates for
        /// <paramref name="target"/> texture unit. Not all parameters are present in all forms
        /// of the command.
        /// </para>
        /// </param>
        /// <param name="r">
        /// <para>
        /// Specify <paramref name="s"/>, <paramref name="t"/>, <paramref name="r"/>, and <paramref name="q"/> texture coordinates for
        /// <paramref name="target"/> texture unit. Not all parameters are present in all forms
        /// of the command.
        /// </para>
        /// </param>
        /// <param name="q">
        /// <para>
        /// Specify <paramref name="s"/>, <paramref name="t"/>, <paramref name="r"/>, and <paramref name="q"/> texture coordinates for
        /// <paramref name="target"/> texture unit. Not all parameters are present in all forms
        /// of the command.
        /// </para>
        /// </param>
        /// <seealso cref="glActiveTexture"/>
        /// <seealso cref="glClientActiveTexture"/>
        /// <seealso cref="glTexCoord"/>
        /// <seealso cref="glTexCoordPointer"/>
        /// <seealso cref="glVertex"/>
        [Obsolete("Compatibility-only GL 1.3 features removed from GL 3.2")]
        public static void glMultiTexCoord4d(uint target, double s, double t, double r, double q) {
            var _F = _GetProc<GLNativeDelegate.FNglMultiTexCoord4d>("glMultiTexCoord4d");
            _F(target, s, t, r, q);
        }
        /// <summary>
        /// set the current texture coordinates
        /// <para>Require:</para> <para>GL_VERSION_1_3</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glMultiTexCoord"/> is only supported if the GL version is 1.3 or greater, or if
        /// <code>ARB_multitexture</code> is included in the string returned by
        /// <see cref="glGetString"/>  when called with the argument <code>GL_EXTENSIONS</code>.
        /// The current texture coordinates can be updated at any time.
        /// In particular,
        /// <see cref="glMultiTexCoord"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// It is always the case that <code>GL_TEXTURE</code>
        /// i   
        /// = <code>GL_TEXTURE0</code> + 
        /// i   .
        /// </para>
        /// Original: <para>void glMultiTexCoord4dv(GLenum target, const GLdouble * v);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the texture unit whose coordinates should be modified. The number
        /// of texture units is implementation dependent, but must be at least
        /// two. Symbolic constant must be one of 
        /// <code>GL_TEXTURE</code>   i   ,
        /// where i ranges from 0 to <code>GL_MAX_TEXTURE_COORDS</code> - 1,
        /// which is an implementation-dependent value.
        /// </para>
        /// </param>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array of one, two, three, or four elements,
        /// which in turn specify the 
        /// s   ,
        /// t   ,
        /// r   ,
        /// and 
        /// q   
        /// texture coordinates.
        /// </para>
        /// </param>
        /// <seealso cref="glActiveTexture"/>
        /// <seealso cref="glClientActiveTexture"/>
        /// <seealso cref="glTexCoord"/>
        /// <seealso cref="glTexCoordPointer"/>
        /// <seealso cref="glVertex"/>
        [Obsolete("Compatibility-only GL 1.3 features removed from GL 3.2")]
        public unsafe static void glMultiTexCoord4dv(uint target, double* v) {
            var _F = _GetProc<GLNativeDelegate.FNglMultiTexCoord4dv>("glMultiTexCoord4dv");
            _F(target, v);
        }
        /// <summary>
        /// set the current texture coordinates
        /// <para>Require:</para> <para>GL_VERSION_1_3, GL_VERSION_ES_CM_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glMultiTexCoord"/> is only supported if the GL version is 1.3 or greater, or if
        /// <code>ARB_multitexture</code> is included in the string returned by
        /// <see cref="glGetString"/>  when called with the argument <code>GL_EXTENSIONS</code>.
        /// The current texture coordinates can be updated at any time.
        /// In particular,
        /// <see cref="glMultiTexCoord"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// It is always the case that <code>GL_TEXTURE</code>
        /// i   
        /// = <code>GL_TEXTURE0</code> + 
        /// i   .
        /// </para>
        /// Original: <para>void glMultiTexCoord4f(GLenum target, GLfloat s, GLfloat t, GLfloat r, GLfloat q);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the texture unit whose coordinates should be modified. The number
        /// of texture units is implementation dependent, but must be at least
        /// two. Symbolic constant must be one of 
        /// <code>GL_TEXTURE</code>   i   ,
        /// where i ranges from 0 to <code>GL_MAX_TEXTURE_COORDS</code> - 1,
        /// which is an implementation-dependent value.
        /// </para>
        /// </param>
        /// <param name="s">
        /// <para>
        /// Specify <paramref name="s"/>, <paramref name="t"/>, <paramref name="r"/>, and <paramref name="q"/> texture coordinates for
        /// <paramref name="target"/> texture unit. Not all parameters are present in all forms
        /// of the command.
        /// </para>
        /// </param>
        /// <param name="t">
        /// <para>
        /// Specify <paramref name="s"/>, <paramref name="t"/>, <paramref name="r"/>, and <paramref name="q"/> texture coordinates for
        /// <paramref name="target"/> texture unit. Not all parameters are present in all forms
        /// of the command.
        /// </para>
        /// </param>
        /// <param name="r">
        /// <para>
        /// Specify <paramref name="s"/>, <paramref name="t"/>, <paramref name="r"/>, and <paramref name="q"/> texture coordinates for
        /// <paramref name="target"/> texture unit. Not all parameters are present in all forms
        /// of the command.
        /// </para>
        /// </param>
        /// <param name="q">
        /// <para>
        /// Specify <paramref name="s"/>, <paramref name="t"/>, <paramref name="r"/>, and <paramref name="q"/> texture coordinates for
        /// <paramref name="target"/> texture unit. Not all parameters are present in all forms
        /// of the command.
        /// </para>
        /// </param>
        /// <seealso cref="glActiveTexture"/>
        /// <seealso cref="glClientActiveTexture"/>
        /// <seealso cref="glTexCoord"/>
        /// <seealso cref="glTexCoordPointer"/>
        /// <seealso cref="glVertex"/>
        [Obsolete("Compatibility-only GL 1.3 features removed from GL 3.2")]
        public static void glMultiTexCoord4f(uint target, float s, float t, float r, float q) {
            var _F = _GetProc<GLNativeDelegate.FNglMultiTexCoord4f>("glMultiTexCoord4f");
            _F(target, s, t, r, q);
        }
        /// <summary>
        /// set the current texture coordinates
        /// <para>Require:</para> <para>GL_VERSION_1_3</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glMultiTexCoord"/> is only supported if the GL version is 1.3 or greater, or if
        /// <code>ARB_multitexture</code> is included in the string returned by
        /// <see cref="glGetString"/>  when called with the argument <code>GL_EXTENSIONS</code>.
        /// The current texture coordinates can be updated at any time.
        /// In particular,
        /// <see cref="glMultiTexCoord"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// It is always the case that <code>GL_TEXTURE</code>
        /// i   
        /// = <code>GL_TEXTURE0</code> + 
        /// i   .
        /// </para>
        /// Original: <para>void glMultiTexCoord4fv(GLenum target, const GLfloat * v);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the texture unit whose coordinates should be modified. The number
        /// of texture units is implementation dependent, but must be at least
        /// two. Symbolic constant must be one of 
        /// <code>GL_TEXTURE</code>   i   ,
        /// where i ranges from 0 to <code>GL_MAX_TEXTURE_COORDS</code> - 1,
        /// which is an implementation-dependent value.
        /// </para>
        /// </param>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array of one, two, three, or four elements,
        /// which in turn specify the 
        /// s   ,
        /// t   ,
        /// r   ,
        /// and 
        /// q   
        /// texture coordinates.
        /// </para>
        /// </param>
        /// <seealso cref="glActiveTexture"/>
        /// <seealso cref="glClientActiveTexture"/>
        /// <seealso cref="glTexCoord"/>
        /// <seealso cref="glTexCoordPointer"/>
        /// <seealso cref="glVertex"/>
        [Obsolete("Compatibility-only GL 1.3 features removed from GL 3.2")]
        public unsafe static void glMultiTexCoord4fv(uint target, float* v) {
            var _F = _GetProc<GLNativeDelegate.FNglMultiTexCoord4fv>("glMultiTexCoord4fv");
            _F(target, v);
        }
        /// <summary>
        /// set the current texture coordinates
        /// <para>Require:</para> <para>GL_VERSION_1_3</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glMultiTexCoord"/> is only supported if the GL version is 1.3 or greater, or if
        /// <code>ARB_multitexture</code> is included in the string returned by
        /// <see cref="glGetString"/>  when called with the argument <code>GL_EXTENSIONS</code>.
        /// The current texture coordinates can be updated at any time.
        /// In particular,
        /// <see cref="glMultiTexCoord"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// It is always the case that <code>GL_TEXTURE</code>
        /// i   
        /// = <code>GL_TEXTURE0</code> + 
        /// i   .
        /// </para>
        /// Original: <para>void glMultiTexCoord4i(GLenum target, GLint s, GLint t, GLint r, GLint q);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the texture unit whose coordinates should be modified. The number
        /// of texture units is implementation dependent, but must be at least
        /// two. Symbolic constant must be one of 
        /// <code>GL_TEXTURE</code>   i   ,
        /// where i ranges from 0 to <code>GL_MAX_TEXTURE_COORDS</code> - 1,
        /// which is an implementation-dependent value.
        /// </para>
        /// </param>
        /// <param name="s">
        /// <para>
        /// Specify <paramref name="s"/>, <paramref name="t"/>, <paramref name="r"/>, and <paramref name="q"/> texture coordinates for
        /// <paramref name="target"/> texture unit. Not all parameters are present in all forms
        /// of the command.
        /// </para>
        /// </param>
        /// <param name="t">
        /// <para>
        /// Specify <paramref name="s"/>, <paramref name="t"/>, <paramref name="r"/>, and <paramref name="q"/> texture coordinates for
        /// <paramref name="target"/> texture unit. Not all parameters are present in all forms
        /// of the command.
        /// </para>
        /// </param>
        /// <param name="r">
        /// <para>
        /// Specify <paramref name="s"/>, <paramref name="t"/>, <paramref name="r"/>, and <paramref name="q"/> texture coordinates for
        /// <paramref name="target"/> texture unit. Not all parameters are present in all forms
        /// of the command.
        /// </para>
        /// </param>
        /// <param name="q">
        /// <para>
        /// Specify <paramref name="s"/>, <paramref name="t"/>, <paramref name="r"/>, and <paramref name="q"/> texture coordinates for
        /// <paramref name="target"/> texture unit. Not all parameters are present in all forms
        /// of the command.
        /// </para>
        /// </param>
        /// <seealso cref="glActiveTexture"/>
        /// <seealso cref="glClientActiveTexture"/>
        /// <seealso cref="glTexCoord"/>
        /// <seealso cref="glTexCoordPointer"/>
        /// <seealso cref="glVertex"/>
        [Obsolete("Compatibility-only GL 1.3 features removed from GL 3.2")]
        public static void glMultiTexCoord4i(uint target, int s, int t, int r, int q) {
            var _F = _GetProc<GLNativeDelegate.FNglMultiTexCoord4i>("glMultiTexCoord4i");
            _F(target, s, t, r, q);
        }
        /// <summary>
        /// set the current texture coordinates
        /// <para>Require:</para> <para>GL_VERSION_1_3</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glMultiTexCoord"/> is only supported if the GL version is 1.3 or greater, or if
        /// <code>ARB_multitexture</code> is included in the string returned by
        /// <see cref="glGetString"/>  when called with the argument <code>GL_EXTENSIONS</code>.
        /// The current texture coordinates can be updated at any time.
        /// In particular,
        /// <see cref="glMultiTexCoord"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// It is always the case that <code>GL_TEXTURE</code>
        /// i   
        /// = <code>GL_TEXTURE0</code> + 
        /// i   .
        /// </para>
        /// Original: <para>void glMultiTexCoord4iv(GLenum target, const GLint * v);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the texture unit whose coordinates should be modified. The number
        /// of texture units is implementation dependent, but must be at least
        /// two. Symbolic constant must be one of 
        /// <code>GL_TEXTURE</code>   i   ,
        /// where i ranges from 0 to <code>GL_MAX_TEXTURE_COORDS</code> - 1,
        /// which is an implementation-dependent value.
        /// </para>
        /// </param>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array of one, two, three, or four elements,
        /// which in turn specify the 
        /// s   ,
        /// t   ,
        /// r   ,
        /// and 
        /// q   
        /// texture coordinates.
        /// </para>
        /// </param>
        /// <seealso cref="glActiveTexture"/>
        /// <seealso cref="glClientActiveTexture"/>
        /// <seealso cref="glTexCoord"/>
        /// <seealso cref="glTexCoordPointer"/>
        /// <seealso cref="glVertex"/>
        [Obsolete("Compatibility-only GL 1.3 features removed from GL 3.2")]
        public unsafe static void glMultiTexCoord4iv(uint target, int* v) {
            var _F = _GetProc<GLNativeDelegate.FNglMultiTexCoord4iv>("glMultiTexCoord4iv");
            _F(target, v);
        }
        /// <summary>
        /// set the current texture coordinates
        /// <para>Require:</para> <para>GL_VERSION_1_3</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glMultiTexCoord"/> is only supported if the GL version is 1.3 or greater, or if
        /// <code>ARB_multitexture</code> is included in the string returned by
        /// <see cref="glGetString"/>  when called with the argument <code>GL_EXTENSIONS</code>.
        /// The current texture coordinates can be updated at any time.
        /// In particular,
        /// <see cref="glMultiTexCoord"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// It is always the case that <code>GL_TEXTURE</code>
        /// i   
        /// = <code>GL_TEXTURE0</code> + 
        /// i   .
        /// </para>
        /// Original: <para>void glMultiTexCoord4s(GLenum target, GLshort s, GLshort t, GLshort r, GLshort q);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the texture unit whose coordinates should be modified. The number
        /// of texture units is implementation dependent, but must be at least
        /// two. Symbolic constant must be one of 
        /// <code>GL_TEXTURE</code>   i   ,
        /// where i ranges from 0 to <code>GL_MAX_TEXTURE_COORDS</code> - 1,
        /// which is an implementation-dependent value.
        /// </para>
        /// </param>
        /// <param name="s">
        /// <para>
        /// Specify <paramref name="s"/>, <paramref name="t"/>, <paramref name="r"/>, and <paramref name="q"/> texture coordinates for
        /// <paramref name="target"/> texture unit. Not all parameters are present in all forms
        /// of the command.
        /// </para>
        /// </param>
        /// <param name="t">
        /// <para>
        /// Specify <paramref name="s"/>, <paramref name="t"/>, <paramref name="r"/>, and <paramref name="q"/> texture coordinates for
        /// <paramref name="target"/> texture unit. Not all parameters are present in all forms
        /// of the command.
        /// </para>
        /// </param>
        /// <param name="r">
        /// <para>
        /// Specify <paramref name="s"/>, <paramref name="t"/>, <paramref name="r"/>, and <paramref name="q"/> texture coordinates for
        /// <paramref name="target"/> texture unit. Not all parameters are present in all forms
        /// of the command.
        /// </para>
        /// </param>
        /// <param name="q">
        /// <para>
        /// Specify <paramref name="s"/>, <paramref name="t"/>, <paramref name="r"/>, and <paramref name="q"/> texture coordinates for
        /// <paramref name="target"/> texture unit. Not all parameters are present in all forms
        /// of the command.
        /// </para>
        /// </param>
        /// <seealso cref="glActiveTexture"/>
        /// <seealso cref="glClientActiveTexture"/>
        /// <seealso cref="glTexCoord"/>
        /// <seealso cref="glTexCoordPointer"/>
        /// <seealso cref="glVertex"/>
        [Obsolete("Compatibility-only GL 1.3 features removed from GL 3.2")]
        public static void glMultiTexCoord4s(uint target, short s, short t, short r, short q) {
            var _F = _GetProc<GLNativeDelegate.FNglMultiTexCoord4s>("glMultiTexCoord4s");
            _F(target, s, t, r, q);
        }
        /// <summary>
        /// set the current texture coordinates
        /// <para>Require:</para> <para>GL_VERSION_1_3</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glMultiTexCoord"/> is only supported if the GL version is 1.3 or greater, or if
        /// <code>ARB_multitexture</code> is included in the string returned by
        /// <see cref="glGetString"/>  when called with the argument <code>GL_EXTENSIONS</code>.
        /// The current texture coordinates can be updated at any time.
        /// In particular,
        /// <see cref="glMultiTexCoord"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// It is always the case that <code>GL_TEXTURE</code>
        /// i   
        /// = <code>GL_TEXTURE0</code> + 
        /// i   .
        /// </para>
        /// Original: <para>void glMultiTexCoord4sv(GLenum target, const GLshort * v);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the texture unit whose coordinates should be modified. The number
        /// of texture units is implementation dependent, but must be at least
        /// two. Symbolic constant must be one of 
        /// <code>GL_TEXTURE</code>   i   ,
        /// where i ranges from 0 to <code>GL_MAX_TEXTURE_COORDS</code> - 1,
        /// which is an implementation-dependent value.
        /// </para>
        /// </param>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array of one, two, three, or four elements,
        /// which in turn specify the 
        /// s   ,
        /// t   ,
        /// r   ,
        /// and 
        /// q   
        /// texture coordinates.
        /// </para>
        /// </param>
        /// <seealso cref="glActiveTexture"/>
        /// <seealso cref="glClientActiveTexture"/>
        /// <seealso cref="glTexCoord"/>
        /// <seealso cref="glTexCoordPointer"/>
        /// <seealso cref="glVertex"/>
        [Obsolete("Compatibility-only GL 1.3 features removed from GL 3.2")]
        public unsafe static void glMultiTexCoord4sv(uint target, short* v) {
            var _F = _GetProc<GLNativeDelegate.FNglMultiTexCoord4sv>("glMultiTexCoord4sv");
            _F(target, v);
        }
        /// <summary>
        /// replace the current matrix with the specified row-major ordered matrix
        /// <para>Require:</para> <para>GL_VERSION_1_3</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glLoadTransposeMatrix"/> is available only if the GL version is 1.3 or greater.
        /// While the elements of the matrix may be specified with
        /// single or double precision, the GL implementation may
        /// store or operate on these values in less than single
        /// precision.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glLoadTransposeMatrix"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glLoadTransposeMatrixf(const GLfloat * m);</para>
        /// </summary>
        /// <param name="m">
        /// <para>
        /// Specifies a pointer to 16 consecutive values, which are used as the
        /// elements of a 
        /// 4 
        /// &times; 
        /// 4 
        /// row-major matrix.
        /// </para>
        /// </param>
        /// <seealso cref="glLoadIdentity"/>
        /// <seealso cref="glLoadMatrix"/>
        /// <seealso cref="glMatrixMode"/>
        /// <seealso cref="glMultMatrix"/>
        /// <seealso cref="glMultTransposeMatrix"/>
        /// <seealso cref="glPushMatrix"/>
        [Obsolete("Compatibility-only GL 1.3 features removed from GL 3.2")]
        public unsafe static void glLoadTransposeMatrixf(float* m) {
            var _F = _GetProc<GLNativeDelegate.FNglLoadTransposeMatrixf>("glLoadTransposeMatrixf");
            _F(m);
        }
        /// <summary>
        /// replace the current matrix with the specified row-major ordered matrix
        /// <para>Require:</para> <para>GL_VERSION_1_3</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glLoadTransposeMatrix"/> is available only if the GL version is 1.3 or greater.
        /// While the elements of the matrix may be specified with
        /// single or double precision, the GL implementation may
        /// store or operate on these values in less than single
        /// precision.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glLoadTransposeMatrix"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glLoadTransposeMatrixd(const GLdouble * m);</para>
        /// </summary>
        /// <param name="m">
        /// <para>
        /// Specifies a pointer to 16 consecutive values, which are used as the
        /// elements of a 
        /// 4 
        /// &times; 
        /// 4 
        /// row-major matrix.
        /// </para>
        /// </param>
        /// <seealso cref="glLoadIdentity"/>
        /// <seealso cref="glLoadMatrix"/>
        /// <seealso cref="glMatrixMode"/>
        /// <seealso cref="glMultMatrix"/>
        /// <seealso cref="glMultTransposeMatrix"/>
        /// <seealso cref="glPushMatrix"/>
        [Obsolete("Compatibility-only GL 1.3 features removed from GL 3.2")]
        public unsafe static void glLoadTransposeMatrixd(double* m) {
            var _F = _GetProc<GLNativeDelegate.FNglLoadTransposeMatrixd>("glLoadTransposeMatrixd");
            _F(m);
        }
        /// <summary>
        /// multiply the current matrix with the specified row-major ordered matrix
        /// <para>Require:</para> <para>GL_VERSION_1_3</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glMultTransposeMatrix"/> is available only if the GL version is 1.3 or greater.
        /// While the elements of the matrix may be specified with
        /// single or double precision, the GL may store or operate on these
        /// values in less-than-single precision.
        /// The order of the multiplication is important. For example, if the current
        /// transformation is a rotation, and <see cref="glMultTransposeMatrix"/> is called with a translation matrix,
        /// the translation is done directly on the coordinates to be transformed,
        /// while the rotation is done on the results of that translation.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glMultTransposeMatrix"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glMultTransposeMatrixf(const GLfloat * m);</para>
        /// </summary>
        /// <param name="m">
        /// <para>
        /// Points to 16 consecutive values that are used as the elements of
        /// a 
        /// 4 
        /// &times; 
        /// 4 
        /// row-major matrix.
        /// </para>
        /// </param>
        /// <seealso cref="glLoadIdentity"/>
        /// <seealso cref="glLoadMatrix"/>
        /// <seealso cref="glLoadTransposeMatrix"/>
        /// <seealso cref="glMatrixMode"/>
        /// <seealso cref="glPushMatrix"/>
        [Obsolete("Compatibility-only GL 1.3 features removed from GL 3.2")]
        public unsafe static void glMultTransposeMatrixf(float* m) {
            var _F = _GetProc<GLNativeDelegate.FNglMultTransposeMatrixf>("glMultTransposeMatrixf");
            _F(m);
        }
        /// <summary>
        /// multiply the current matrix with the specified row-major ordered matrix
        /// <para>Require:</para> <para>GL_VERSION_1_3</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glMultTransposeMatrix"/> is available only if the GL version is 1.3 or greater.
        /// While the elements of the matrix may be specified with
        /// single or double precision, the GL may store or operate on these
        /// values in less-than-single precision.
        /// The order of the multiplication is important. For example, if the current
        /// transformation is a rotation, and <see cref="glMultTransposeMatrix"/> is called with a translation matrix,
        /// the translation is done directly on the coordinates to be transformed,
        /// while the rotation is done on the results of that translation.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glMultTransposeMatrix"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glMultTransposeMatrixd(const GLdouble * m);</para>
        /// </summary>
        /// <param name="m">
        /// <para>
        /// Points to 16 consecutive values that are used as the elements of
        /// a 
        /// 4 
        /// &times; 
        /// 4 
        /// row-major matrix.
        /// </para>
        /// </param>
        /// <seealso cref="glLoadIdentity"/>
        /// <seealso cref="glLoadMatrix"/>
        /// <seealso cref="glLoadTransposeMatrix"/>
        /// <seealso cref="glMatrixMode"/>
        /// <seealso cref="glPushMatrix"/>
        [Obsolete("Compatibility-only GL 1.3 features removed from GL 3.2")]
        public unsafe static void glMultTransposeMatrixd(double* m) {
            var _F = _GetProc<GLNativeDelegate.FNglMultTransposeMatrixd>("glMultTransposeMatrixd");
            _F(m);
        }

        #endregion GL_VERSION_1_3

        #region GL_VERSION_1_4

        /// <summary>
        /// specify pixel arithmetic for RGB and alpha components separately
        /// <para>Require:</para> <para>GL_VERSION_1_4, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glBlendFuncSeparate"/> is available only if the GL version is 1.4 or greater.
        /// Incoming (source) alpha is correctly thought of as a material opacity,
        /// ranging from 1.0 
        /// (  
        /// K 
        /// A 
        /// ),
        /// representing complete opacity,
        /// to 0.0 (0), representing complete
        /// transparency.
        /// When more than one color buffer is enabled for drawing,
        /// the GL performs blending separately for each enabled buffer,
        /// using the contents of that buffer for destination color.
        /// (See  <see cref="glDrawBuffer"/> .)
        /// Blending affects only RGBA rendering.
        /// It is ignored by color index renderers.
        /// <code>GL_CONSTANT_COLOR</code>, <code>GL_ONE_MINUS_CONSTANT_COLOR</code>,
        /// <code>GL_CONSTANT_ALPHA</code>, <code>GL_ONE_MINUS_CONSTANT_ALPHA</code> are available only
        /// if the GL version is 1.4 or greater or if the <code>ARB_imaging</code> is
        /// supported by your implementation.
        /// <code>GL_SRC_COLOR</code> and <code>GL_ONE_MINUS_SRC_COLOR</code> are valid only for
        /// <paramref name="srcRGB"/> if the GL version is 1.4 or greater.
        /// <code>GL_DST_COLOR</code> and <code>GL_ONE_MINUS_DST_COLOR</code> are valid only for
        /// <paramref name="dstRGB"/> if the GL version is 1.4 or greater.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if either <paramref name="srcRGB"/> or <paramref name="dstRGB"/> is not an
        /// accepted value.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glBlendFuncSeparate"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glBlendFuncSeparate(GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha);</para>
        /// </summary>
        /// <param name="srcRGB">
        /// <para>
        /// Specifies how the red, green, and blue blending factors are computed.
        /// The following symbolic constants are accepted:
        /// <code>GL_ZERO</code>,
        /// <code>GL_ONE</code>,
        /// <code>GL_SRC_COLOR</code>,
        /// <code>GL_ONE_MINUS_SRC_COLOR</code>,
        /// <code>GL_DST_COLOR</code>,
        /// <code>GL_ONE_MINUS_DST_COLOR</code>,
        /// <code>GL_SRC_ALPHA</code>,
        /// <code>GL_ONE_MINUS_SRC_ALPHA</code>,
        /// <code>GL_DST_ALPHA</code>,
        /// <code>GL_ONE_MINUS_DST_ALPHA</code>,
        /// <code>GL_CONSTANT_COLOR</code>,
        /// <code>GL_ONE_MINUS_CONSTANT_COLOR</code>,
        /// <code>GL_CONSTANT_ALPHA</code>,
        /// <code>GL_ONE_MINUS_CONSTANT_ALPHA</code>, and
        /// <code>GL_SRC_ALPHA_SATURATE</code>.
        /// The initial value is <code>GL_ONE</code>.
        /// </para>
        /// </param>
        /// <param name="dstRGB">
        /// <para>
        /// Specifies how the red, green, and blue destination blending factors are
        /// computed. The following symbolic constants are accepted:
        /// <code>GL_ZERO</code>,
        /// <code>GL_ONE</code>,
        /// <code>GL_SRC_COLOR</code>,
        /// <code>GL_ONE_MINUS_SRC_COLOR</code>,
        /// <code>GL_DST_COLOR</code>,
        /// <code>GL_ONE_MINUS_DST_COLOR</code>,
        /// <code>GL_SRC_ALPHA</code>,
        /// <code>GL_ONE_MINUS_SRC_ALPHA</code>,
        /// <code>GL_DST_ALPHA</code>,
        /// <code>GL_ONE_MINUS_DST_ALPHA</code>.
        /// <code>GL_CONSTANT_COLOR</code>,
        /// <code>GL_ONE_MINUS_CONSTANT_COLOR</code>,
        /// <code>GL_CONSTANT_ALPHA</code>, and
        /// <code>GL_ONE_MINUS_CONSTANT_ALPHA</code>.
        /// The initial value is <code>GL_ZERO</code>.
        /// </para>
        /// </param>
        /// <param name="srcAlpha">
        /// <para>
        /// Specified how the alpha source blending factor is computed.  The same
        /// symbolic constants are accepted as for <paramref name="srcRGB"/>.
        /// The initial value is <code>GL_ONE</code>.
        /// </para>
        /// </param>
        /// <param name="dstAlpha">
        /// <para>
        /// Specified how the alpha destination blending factor is computed.  The same
        /// symbolic constants are accepted as for <paramref name="dstRGB"/>.
        /// The initial value is <code>GL_ZERO</code>.
        /// </para>
        /// </param>
        /// <seealso cref="glAlphaFunc"/>
        /// <seealso cref="glBlendColor"/>
        /// <seealso cref="glBlendFunc"/>
        /// <seealso cref="glBlendEquation"/>
        /// <seealso cref="glClear"/>
        /// <seealso cref="glDrawBuffer"/>
        /// <seealso cref="glEnable"/>
        /// <seealso cref="glLogicOp"/>
        /// <seealso cref="glStencilFunc"/>
        public static void glBlendFuncSeparate(uint srcRGB, uint dstRGB, uint srcAlpha, uint dstAlpha) {
            var _F = _GetProc<GLNativeDelegate.FNglBlendFuncSeparate>("glBlendFuncSeparate");
            _F(srcRGB, dstRGB, srcAlpha, dstAlpha);
        }
        /// <summary>
        /// render multiple sets of primitives from array data
        /// <para>Require:</para> <para>GL_VERSION_1_4</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glMultiDrawArrays"/> is available only if the GL version is 1.4 or greater.
        /// <see cref="glMultiDrawArrays"/> is included in display lists. If <see cref="glMultiDrawArrays"/> is entered into a
        /// display list,
        /// the necessary array data (determined by the array pointers and
        /// enables) is also
        /// entered into the display list. Because the array pointers and
        /// enables are client-side state, their values affect display lists
        /// when the lists are created, not when the lists are executed.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="mode"/> is not an accepted value.
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="primcount"/> is negative.
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to an
        /// enabled array and the buffer object's data store is currently mapped.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glMultiDrawArrays"/> is executed between
        /// the execution of  <see cref="glBegin"/>  and the corresponding  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glMultiDrawArrays(GLenum mode, GLint * first, GLsizei * count, GLsizei primcount);</para>
        /// </summary>
        /// <param name="mode">
        /// <para>
        /// Specifies what kind of primitives to render.
        /// Symbolic constants
        /// <code>GL_POINTS</code>,
        /// <code>GL_LINE_STRIP</code>,
        /// <code>GL_LINE_LOOP</code>,
        /// <code>GL_LINES</code>,
        /// <code>GL_TRIANGLE_STRIP</code>,
        /// <code>GL_TRIANGLE_FAN</code>,
        /// <code>GL_TRIANGLES</code>,
        /// <code>GL_QUAD_STRIP</code>,
        /// <code>GL_QUADS</code>,
        /// and <code>GL_POLYGON</code> are accepted.
        /// </para>
        /// </param>
        /// <param name="first">
        /// Points to an array of starting indices in the enabled arrays.
        /// </param>
        /// <param name="count">
        /// Points to an array of the number of indices to be rendered.
        /// </param>
        /// <param name="primcount">
        /// Specifies the size of the first and count
        /// </param>
        /// <seealso cref="glArrayElement"/>
        /// <seealso cref="glColorPointer"/>
        /// <seealso cref="glDrawElements"/>
        /// <seealso cref="glDrawRangeElements"/>
        /// <seealso cref="glEdgeFlagPointer"/>
        /// <seealso cref="glFogCoordPointer"/>
        /// <seealso cref="glGetPointerv"/>
        /// <seealso cref="glIndexPointer"/>
        /// <seealso cref="glInterleavedArrays"/>
        /// <seealso cref="glNormalPointer"/>
        /// <seealso cref="glSecondaryColorPointer"/>
        /// <seealso cref="glTexCoordPointer"/>
        /// <seealso cref="glVertexPointer"/>
        public unsafe static void glMultiDrawArrays(uint mode, int* first, int* count, int primcount) {
            var _F = _GetProc<GLNativeDelegate.FNglMultiDrawArrays>("glMultiDrawArrays");
            _F(mode, first, count, primcount);
        }
        /// <summary>
        /// render multiple sets of primitives by specifying indices of array data elements
        /// <para>Require:</para> <para>GL_VERSION_1_4</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glMultiDrawElements"/> is available only if the GL version is 1.4 or greater.
        /// <see cref="glMultiDrawElements"/> is included in display lists. If <see cref="glMultiDrawElements"/> is entered into a
        /// display list,
        /// the necessary array data (determined by the array pointers and
        /// enables) is also
        /// entered into the display list. Because the array pointers and
        /// enables are client-side state, their values affect display lists
        /// when the lists are created, not when the lists are executed.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="mode"/> is not an accepted value.
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="primcount"/> is negative.
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to an
        /// enabled array or the element array and the buffer object's data store is currently mapped.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glMultiDrawElements"/> is executed between
        /// the execution of  <see cref="glBegin"/>  and the corresponding  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glMultiDrawElements(GLenum mode, const GLsizei * count, GLenum type, const void ** indices, GLsizei primcount);</para>
        /// </summary>
        /// <param name="mode">
        /// <para>
        /// Specifies what kind of primitives to render.
        /// Symbolic constants
        /// <code>GL_POINTS</code>,
        /// <code>GL_LINE_STRIP</code>,
        /// <code>GL_LINE_LOOP</code>,
        /// <code>GL_LINES</code>,
        /// <code>GL_TRIANGLE_STRIP</code>,
        /// <code>GL_TRIANGLE_FAN</code>,
        /// <code>GL_TRIANGLES</code>,
        /// <code>GL_QUAD_STRIP</code>,
        /// <code>GL_QUADS</code>,
        /// and <code>GL_POLYGON</code> are accepted.
        /// </para>
        /// </param>
        /// <param name="count">
        /// Points to an array of the elements counts.
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the type of the values in <paramref name="indices"/>. Must be one of
        /// <code>GL_UNSIGNED_BYTE</code>, <code>GL_UNSIGNED_SHORT</code>, or
        /// <code>GL_UNSIGNED_INT</code>.
        /// </para>
        /// </param>
        /// <param name="indices">
        /// Specifies a pointer to the location where the indices are stored.
        /// </param>
        /// <param name="primcount">
        /// Specifies the size of the <paramref name="count"/> array.
        /// </param>
        /// <seealso cref="glArrayElement"/>
        /// <seealso cref="glColorPointer"/>
        /// <seealso cref="glDrawArrays"/>
        /// <seealso cref="glDrawRangeElements"/>
        /// <seealso cref="glEdgeFlagPointer"/>
        /// <seealso cref="glFogCoordPointer"/>
        /// <seealso cref="glGetPointerv"/>
        /// <seealso cref="glIndexPointer"/>
        /// <seealso cref="glInterleavedArrays"/>
        /// <seealso cref="glNormalPointer"/>
        /// <seealso cref="glSecondaryColorPointer"/>
        /// <seealso cref="glTexCoordPointer"/>
        /// <seealso cref="glVertexPointer"/>
        public unsafe static void glMultiDrawElements(uint mode, int* count, uint type, void** indices, int primcount) {
            var _F = _GetProc<GLNativeDelegate.FNglMultiDrawElements>("glMultiDrawElements");
            _F(mode, count, type, indices, primcount);
        }
        /// <summary>
        /// specify point parameters
        /// <para>Require:</para> <para>GL_VERSION_1_4, GL_VERSION_ES_CM_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glPointParameter"/> is available only if the GL version is 1.4 or greater.
        /// <code>GL_POINT_SPRITE_COORD_ORIGIN</code> is available only if the GL version is 2.0 or greater.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated If the value specified for
        /// <code>GL_POINT_SIZE_MIN</code>, <code>GL_POINT_SIZE_MAX</code>, or
        /// <code>GL_POINT_FADE_THRESHOLD_SIZE</code> is less than zero.
        /// <code>GL_INVALID_ENUM</code> is generated If the value specified for
        /// <code>GL_POINT_SPRITE_COORD_ORIGIN</code> is not <code>GL_LOWER_LEFT</code> or <code>GL_UPPER_LEFT</code>.
        /// If the value for <code>GL_POINT_SIZE_MIN</code> is greater than
        /// <code>GL_POINT_SIZE_MAX</code>, the point size after clamping is undefined, but no
        /// error is generated.
        /// </para>
        /// Original: <para>void glPointParameterf(GLenum pname, GLfloat param);</para>
        /// </summary>
        /// <param name="pname">
        /// <para>
        /// Specifies a single-valued point parameter.
        /// <code>GL_POINT_SIZE_MIN</code>,
        /// <code>GL_POINT_SIZE_MAX</code>,
        /// <code>GL_POINT_FADE_THRESHOLD_SIZE</code>, and
        /// <code>GL_POINT_SPRITE_COORD_ORIGIN</code>
        /// are accepted.
        /// </para>
        /// </param>
        /// <param name="param">
        /// Specifies the value that <paramref name="pname"/> will be set to.
        /// </param>
        /// <seealso cref="glPointSize"/>
        public static void glPointParameterf(uint pname, float param) {
            var _F = _GetProc<GLNativeDelegate.FNglPointParameterf>("glPointParameterf");
            _F(pname, param);
        }
        /// <summary>
        /// specify point parameters
        /// <para>Require:</para> <para>GL_VERSION_1_4, GL_VERSION_ES_CM_1_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glPointParameter"/> is available only if the GL version is 1.4 or greater.
        /// <code>GL_POINT_SPRITE_COORD_ORIGIN</code> is available only if the GL version is 2.0 or greater.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated If the value specified for
        /// <code>GL_POINT_SIZE_MIN</code>, <code>GL_POINT_SIZE_MAX</code>, or
        /// <code>GL_POINT_FADE_THRESHOLD_SIZE</code> is less than zero.
        /// <code>GL_INVALID_ENUM</code> is generated If the value specified for
        /// <code>GL_POINT_SPRITE_COORD_ORIGIN</code> is not <code>GL_LOWER_LEFT</code> or <code>GL_UPPER_LEFT</code>.
        /// If the value for <code>GL_POINT_SIZE_MIN</code> is greater than
        /// <code>GL_POINT_SIZE_MAX</code>, the point size after clamping is undefined, but no
        /// error is generated.
        /// </para>
        /// Original: <para>void glPointParameterfv(GLenum pname, const GLfloat * params);</para>
        /// </summary>
        /// <param name="pname">
        /// <para>
        /// Specifies a point parameter.
        /// <code>GL_POINT_SIZE_MIN</code>,
        /// <code>GL_POINT_SIZE_MAX</code>,
        /// <code>GL_POINT_DISTANCE_ATTENUATION</code>,
        /// <code>GL_POINT_FADE_THRESHOLD_SIZE</code>, and
        /// <code>GL_POINT_SPRITE_COORD_ORIGIN</code>
        /// are accepted.
        /// </para>
        /// </param>
        /// <param name="ps">
        /// <para>
        /// Specifies the value or values to be assigned to <paramref name="pname"/>.
        /// <code>GL_POINT_DISTANCE_ATTENUATION</code> requires an array of three values.
        /// All other parameters accept an array containing only a single value.
        /// </para>
        /// </param>
        /// <seealso cref="glPointSize"/>
        public unsafe static void glPointParameterfv(uint pname, float* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglPointParameterfv>("glPointParameterfv");
            _F(pname, ps);
        }
        /// <summary>
        /// specify point parameters
        /// <para>Require:</para> <para>GL_VERSION_1_4</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glPointParameter"/> is available only if the GL version is 1.4 or greater.
        /// <code>GL_POINT_SPRITE_COORD_ORIGIN</code> is available only if the GL version is 2.0 or greater.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated If the value specified for
        /// <code>GL_POINT_SIZE_MIN</code>, <code>GL_POINT_SIZE_MAX</code>, or
        /// <code>GL_POINT_FADE_THRESHOLD_SIZE</code> is less than zero.
        /// <code>GL_INVALID_ENUM</code> is generated If the value specified for
        /// <code>GL_POINT_SPRITE_COORD_ORIGIN</code> is not <code>GL_LOWER_LEFT</code> or <code>GL_UPPER_LEFT</code>.
        /// If the value for <code>GL_POINT_SIZE_MIN</code> is greater than
        /// <code>GL_POINT_SIZE_MAX</code>, the point size after clamping is undefined, but no
        /// error is generated.
        /// </para>
        /// Original: <para>void glPointParameteri(GLenum pname, GLint param);</para>
        /// </summary>
        /// <param name="pname">
        /// <para>
        /// Specifies a single-valued point parameter.
        /// <code>GL_POINT_SIZE_MIN</code>,
        /// <code>GL_POINT_SIZE_MAX</code>,
        /// <code>GL_POINT_FADE_THRESHOLD_SIZE</code>, and
        /// <code>GL_POINT_SPRITE_COORD_ORIGIN</code>
        /// are accepted.
        /// </para>
        /// </param>
        /// <param name="param">
        /// Specifies the value that <paramref name="pname"/> will be set to.
        /// </param>
        /// <seealso cref="glPointSize"/>
        public static void glPointParameteri(uint pname, int param) {
            var _F = _GetProc<GLNativeDelegate.FNglPointParameteri>("glPointParameteri");
            _F(pname, param);
        }
        /// <summary>
        /// specify point parameters
        /// <para>Require:</para> <para>GL_VERSION_1_4</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glPointParameter"/> is available only if the GL version is 1.4 or greater.
        /// <code>GL_POINT_SPRITE_COORD_ORIGIN</code> is available only if the GL version is 2.0 or greater.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated If the value specified for
        /// <code>GL_POINT_SIZE_MIN</code>, <code>GL_POINT_SIZE_MAX</code>, or
        /// <code>GL_POINT_FADE_THRESHOLD_SIZE</code> is less than zero.
        /// <code>GL_INVALID_ENUM</code> is generated If the value specified for
        /// <code>GL_POINT_SPRITE_COORD_ORIGIN</code> is not <code>GL_LOWER_LEFT</code> or <code>GL_UPPER_LEFT</code>.
        /// If the value for <code>GL_POINT_SIZE_MIN</code> is greater than
        /// <code>GL_POINT_SIZE_MAX</code>, the point size after clamping is undefined, but no
        /// error is generated.
        /// </para>
        /// Original: <para>void glPointParameteriv(GLenum pname, const GLint * params);</para>
        /// </summary>
        /// <param name="pname">
        /// <para>
        /// Specifies a point parameter.
        /// <code>GL_POINT_SIZE_MIN</code>,
        /// <code>GL_POINT_SIZE_MAX</code>,
        /// <code>GL_POINT_DISTANCE_ATTENUATION</code>,
        /// <code>GL_POINT_FADE_THRESHOLD_SIZE</code>, and
        /// <code>GL_POINT_SPRITE_COORD_ORIGIN</code>
        /// are accepted.
        /// </para>
        /// </param>
        /// <param name="ps">
        /// <para>
        /// Specifies the value or values to be assigned to <paramref name="pname"/>.
        /// <code>GL_POINT_DISTANCE_ATTENUATION</code> requires an array of three values.
        /// All other parameters accept an array containing only a single value.
        /// </para>
        /// </param>
        /// <seealso cref="glPointSize"/>
        public unsafe static void glPointParameteriv(uint pname, int* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglPointParameteriv>("glPointParameteriv");
            _F(pname, ps);
        }
        /// <summary>
        /// set the current fog coordinates
        /// <para>Require:</para> <para>GL_VERSION_1_4</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glFogCoord"/> is available only if the GL version is 1.4 or greater.
        /// The current fog coordinate can be updated at any time.  In particular,
        /// <see cref="glFogCoord"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glFogCoordf(GLfloat coord);</para>
        /// </summary>
        /// <param name="coord">
        /// Specify the fog distance.
        /// </param>
        /// <seealso cref="glFog"/>
        /// <seealso cref="glFogCoordPointer"/>
        /// <seealso cref="glVertex"/>
        [Obsolete("Compatibility-only GL 1.4 features removed from GL 3.2")]
        public static void glFogCoordf(float coord) {
            var _F = _GetProc<GLNativeDelegate.FNglFogCoordf>("glFogCoordf");
            _F(coord);
        }
        /// <summary>
        /// set the current fog coordinates
        /// <para>Require:</para> <para>GL_VERSION_1_4</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glFogCoord"/> is available only if the GL version is 1.4 or greater.
        /// The current fog coordinate can be updated at any time.  In particular,
        /// <see cref="glFogCoord"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glFogCoordfv(GLfloat * coord);</para>
        /// </summary>
        /// <param name="coord">
        /// <para>
        /// Specifies a pointer to an array containing a single value representing the
        /// fog distance.
        /// </para>
        /// </param>
        /// <seealso cref="glFog"/>
        /// <seealso cref="glFogCoordPointer"/>
        /// <seealso cref="glVertex"/>
        [Obsolete("Compatibility-only GL 1.4 features removed from GL 3.2")]
        public unsafe static void glFogCoordfv(float* coord) {
            var _F = _GetProc<GLNativeDelegate.FNglFogCoordfv>("glFogCoordfv");
            _F(coord);
        }
        /// <summary>
        /// set the current fog coordinates
        /// <para>Require:</para> <para>GL_VERSION_1_4</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glFogCoord"/> is available only if the GL version is 1.4 or greater.
        /// The current fog coordinate can be updated at any time.  In particular,
        /// <see cref="glFogCoord"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glFogCoordd(GLdouble coord);</para>
        /// </summary>
        /// <param name="coord">
        /// Specify the fog distance.
        /// </param>
        /// <seealso cref="glFog"/>
        /// <seealso cref="glFogCoordPointer"/>
        /// <seealso cref="glVertex"/>
        [Obsolete("Compatibility-only GL 1.4 features removed from GL 3.2")]
        public static void glFogCoordd(double coord) {
            var _F = _GetProc<GLNativeDelegate.FNglFogCoordd>("glFogCoordd");
            _F(coord);
        }
        /// <summary>
        /// set the current fog coordinates
        /// <para>Require:</para> <para>GL_VERSION_1_4</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glFogCoord"/> is available only if the GL version is 1.4 or greater.
        /// The current fog coordinate can be updated at any time.  In particular,
        /// <see cref="glFogCoord"/> can be called between a call to  <see cref="glBegin"/>  and the corresponding
        /// call to  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glFogCoorddv(GLdouble * coord);</para>
        /// </summary>
        /// <param name="coord">
        /// <para>
        /// Specifies a pointer to an array containing a single value representing the
        /// fog distance.
        /// </para>
        /// </param>
        /// <seealso cref="glFog"/>
        /// <seealso cref="glFogCoordPointer"/>
        /// <seealso cref="glVertex"/>
        [Obsolete("Compatibility-only GL 1.4 features removed from GL 3.2")]
        public unsafe static void glFogCoorddv(double* coord) {
            var _F = _GetProc<GLNativeDelegate.FNglFogCoorddv>("glFogCoorddv");
            _F(coord);
        }
        /// <summary>
        /// define an array of fog coordinates
        /// <para>Require:</para> <para>GL_VERSION_1_4</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glFogCoordPointer"/> is available only if the GL version is 1.4 or greater.
        /// Fog coordinates are not supported for interleaved vertex array formats
        /// (see  <see cref="glInterleavedArrays"/> ).
        /// The fog coordinate array is initially disabled and isn't accessed when
        /// <see cref="glArrayElement"/> ,  <see cref="glDrawElements"/> ,  <see cref="glDrawRangeElements"/> ,
        /// <see cref="glDrawArrays"/> ,  <see cref="glMultiDrawArrays"/> , or  <see cref="glMultiDrawElements"/> 
        /// is called.
        /// Execution of <see cref="glFogCoordPointer"/> is not allowed between the execution of
        /// <see cref="glBegin"/>  and the corresponding execution of  <see cref="glEnd"/> ,
        /// but an error may or may not be generated. If no error is generated,
        /// the operation is undefined.
        /// <see cref="glFogCoordPointer"/> is typically implemented on the client side with no protocol.
        /// Fog coordinate array parameters are client-side state and are
        /// therefore not saved or restored by  <see cref="glPushAttrib"/>  and  <see cref="glPopAttrib"/> .
        /// Use  <see cref="glPushClientAttrib"/>  and
        /// <see cref="glPopClientAttrib"/>  instead.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="type"/> is not either <code>GL_FLOAT</code>
        /// or <code>GL_DOUBLE</code>.
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="stride"/> is negative.
        /// </para>
        /// Original: <para>void glFogCoordPointer(GLenum type, GLsizei stride, void * pointer);</para>
        /// </summary>
        /// <param name="type">
        /// <para>
        /// Specifies the data type of each fog coordinate.
        /// Symbolic constants
        /// <code>GL_FLOAT</code>,
        /// or <code>GL_DOUBLE</code>
        /// are accepted. The initial value is <code>GL_FLOAT</code>.
        /// </para>
        /// </param>
        /// <param name="stride">
        /// <para>
        /// Specifies the byte offset between consecutive fog coordinates.
        /// If <paramref name="stride"/> is 0, the array elements are understood
        /// to be tightly packed. The initial value is 0.
        /// </para>
        /// </param>
        /// <param name="pointer">
        /// <para>
        /// Specifies a pointer to the first coordinate of the first fog coordinate in the
        /// array. The initial value is 0.
        /// </para>
        /// </param>
        /// <seealso cref="glArrayElement"/>
        /// <seealso cref="glBindBuffer"/>
        /// <seealso cref="glColorPointer"/>
        /// <seealso cref="glDisableClientState"/>
        /// <seealso cref="glDrawArrays"/>
        /// <seealso cref="glDrawElements"/>
        /// <seealso cref="glDrawRangeElements"/>
        /// <seealso cref="glEdgeFlagPointer"/>
        /// <seealso cref="glEnableClientState"/>
        /// <seealso cref="glFogCoord"/>
        /// <seealso cref="glIndexPointer"/>
        /// <seealso cref="glInterleavedArrays"/>
        /// <seealso cref="glMultiDrawArrays"/>
        /// <seealso cref="glMultiDrawElements"/>
        /// <seealso cref="glNormalPointer"/>
        /// <seealso cref="glPopClientAttrib"/>
        /// <seealso cref="glPushClientAttrib"/>
        /// <seealso cref="glSecondaryColorPointer"/>
        /// <seealso cref="glTexCoordPointer"/>
        /// <seealso cref="glVertexAttribPointer"/>
        /// <seealso cref="glVertexPointer"/>
        [Obsolete("Compatibility-only GL 1.4 features removed from GL 3.2")]
        public unsafe static void glFogCoordPointer(uint type, int stride, void* pointer) {
            var _F = _GetProc<GLNativeDelegate.FNglFogCoordPointer>("glFogCoordPointer");
            _F(type, stride, pointer);
        }
        /// <summary>
        /// set the current secondary color
        /// <para>Require:</para> <para>GL_VERSION_1_4</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glSecondaryColor"/> is available only if the GL version is 1.4 or greater.
        /// The initial value for the secondary color is (0, 0, 0, 0).
        /// The secondary color can be updated at any time.  In particular, <see cref="glSecondaryColor"/> can
        /// be called between a call to  <see cref="glBegin"/>  and the corresponding call to
        /// <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glSecondaryColor3b(GLbyte red, GLbyte green, GLbyte blue);</para>
        /// </summary>
        /// <param name="red">
        /// Specify new red, green, and blue values for the current secondary color.
        /// </param>
        /// <param name="green">
        /// Specify new red, green, and blue values for the current secondary color.
        /// </param>
        /// <param name="blue">
        /// Specify new red, green, and blue values for the current secondary color.
        /// </param>
        /// <seealso cref="glColor"/>
        /// <seealso cref="glIndex"/>
        /// <seealso cref="glIsEnabled"/>
        /// <seealso cref="glLightModel"/>
        /// <seealso cref="glSecondaryColorPointer"/>
        [Obsolete("Compatibility-only GL 1.4 features removed from GL 3.2")]
        public static void glSecondaryColor3b(byte red, byte green, byte blue) {
            var _F = _GetProc<GLNativeDelegate.FNglSecondaryColor3b>("glSecondaryColor3b");
            _F(red, green, blue);
        }
        /// <summary>
        /// set the current secondary color
        /// <para>Require:</para> <para>GL_VERSION_1_4</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glSecondaryColor"/> is available only if the GL version is 1.4 or greater.
        /// The initial value for the secondary color is (0, 0, 0, 0).
        /// The secondary color can be updated at any time.  In particular, <see cref="glSecondaryColor"/> can
        /// be called between a call to  <see cref="glBegin"/>  and the corresponding call to
        /// <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glSecondaryColor3bv(const GLbyte * v);</para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array that contains red, green, blue.
        /// </param>
        /// <seealso cref="glColor"/>
        /// <seealso cref="glIndex"/>
        /// <seealso cref="glIsEnabled"/>
        /// <seealso cref="glLightModel"/>
        /// <seealso cref="glSecondaryColorPointer"/>
        [Obsolete("Compatibility-only GL 1.4 features removed from GL 3.2")]
        public unsafe static void glSecondaryColor3bv(byte* v) {
            var _F = _GetProc<GLNativeDelegate.FNglSecondaryColor3bv>("glSecondaryColor3bv");
            _F(v);
        }
        /// <summary>
        /// set the current secondary color
        /// <para>Require:</para> <para>GL_VERSION_1_4</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glSecondaryColor"/> is available only if the GL version is 1.4 or greater.
        /// The initial value for the secondary color is (0, 0, 0, 0).
        /// The secondary color can be updated at any time.  In particular, <see cref="glSecondaryColor"/> can
        /// be called between a call to  <see cref="glBegin"/>  and the corresponding call to
        /// <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glSecondaryColor3d(GLdouble red, GLdouble green, GLdouble blue);</para>
        /// </summary>
        /// <param name="red">
        /// Specify new red, green, and blue values for the current secondary color.
        /// </param>
        /// <param name="green">
        /// Specify new red, green, and blue values for the current secondary color.
        /// </param>
        /// <param name="blue">
        /// Specify new red, green, and blue values for the current secondary color.
        /// </param>
        /// <seealso cref="glColor"/>
        /// <seealso cref="glIndex"/>
        /// <seealso cref="glIsEnabled"/>
        /// <seealso cref="glLightModel"/>
        /// <seealso cref="glSecondaryColorPointer"/>
        [Obsolete("Compatibility-only GL 1.4 features removed from GL 3.2")]
        public static void glSecondaryColor3d(double red, double green, double blue) {
            var _F = _GetProc<GLNativeDelegate.FNglSecondaryColor3d>("glSecondaryColor3d");
            _F(red, green, blue);
        }
        /// <summary>
        /// set the current secondary color
        /// <para>Require:</para> <para>GL_VERSION_1_4</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glSecondaryColor"/> is available only if the GL version is 1.4 or greater.
        /// The initial value for the secondary color is (0, 0, 0, 0).
        /// The secondary color can be updated at any time.  In particular, <see cref="glSecondaryColor"/> can
        /// be called between a call to  <see cref="glBegin"/>  and the corresponding call to
        /// <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glSecondaryColor3dv(const GLdouble * v);</para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array that contains red, green, blue.
        /// </param>
        /// <seealso cref="glColor"/>
        /// <seealso cref="glIndex"/>
        /// <seealso cref="glIsEnabled"/>
        /// <seealso cref="glLightModel"/>
        /// <seealso cref="glSecondaryColorPointer"/>
        [Obsolete("Compatibility-only GL 1.4 features removed from GL 3.2")]
        public unsafe static void glSecondaryColor3dv(double* v) {
            var _F = _GetProc<GLNativeDelegate.FNglSecondaryColor3dv>("glSecondaryColor3dv");
            _F(v);
        }
        /// <summary>
        /// set the current secondary color
        /// <para>Require:</para> <para>GL_VERSION_1_4</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glSecondaryColor"/> is available only if the GL version is 1.4 or greater.
        /// The initial value for the secondary color is (0, 0, 0, 0).
        /// The secondary color can be updated at any time.  In particular, <see cref="glSecondaryColor"/> can
        /// be called between a call to  <see cref="glBegin"/>  and the corresponding call to
        /// <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glSecondaryColor3f(GLfloat red, GLfloat green, GLfloat blue);</para>
        /// </summary>
        /// <param name="red">
        /// Specify new red, green, and blue values for the current secondary color.
        /// </param>
        /// <param name="green">
        /// Specify new red, green, and blue values for the current secondary color.
        /// </param>
        /// <param name="blue">
        /// Specify new red, green, and blue values for the current secondary color.
        /// </param>
        /// <seealso cref="glColor"/>
        /// <seealso cref="glIndex"/>
        /// <seealso cref="glIsEnabled"/>
        /// <seealso cref="glLightModel"/>
        /// <seealso cref="glSecondaryColorPointer"/>
        [Obsolete("Compatibility-only GL 1.4 features removed from GL 3.2")]
        public static void glSecondaryColor3f(float red, float green, float blue) {
            var _F = _GetProc<GLNativeDelegate.FNglSecondaryColor3f>("glSecondaryColor3f");
            _F(red, green, blue);
        }
        /// <summary>
        /// set the current secondary color
        /// <para>Require:</para> <para>GL_VERSION_1_4</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glSecondaryColor"/> is available only if the GL version is 1.4 or greater.
        /// The initial value for the secondary color is (0, 0, 0, 0).
        /// The secondary color can be updated at any time.  In particular, <see cref="glSecondaryColor"/> can
        /// be called between a call to  <see cref="glBegin"/>  and the corresponding call to
        /// <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glSecondaryColor3fv(const GLfloat * v);</para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array that contains red, green, blue.
        /// </param>
        /// <seealso cref="glColor"/>
        /// <seealso cref="glIndex"/>
        /// <seealso cref="glIsEnabled"/>
        /// <seealso cref="glLightModel"/>
        /// <seealso cref="glSecondaryColorPointer"/>
        [Obsolete("Compatibility-only GL 1.4 features removed from GL 3.2")]
        public unsafe static void glSecondaryColor3fv(float* v) {
            var _F = _GetProc<GLNativeDelegate.FNglSecondaryColor3fv>("glSecondaryColor3fv");
            _F(v);
        }
        /// <summary>
        /// set the current secondary color
        /// <para>Require:</para> <para>GL_VERSION_1_4</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glSecondaryColor"/> is available only if the GL version is 1.4 or greater.
        /// The initial value for the secondary color is (0, 0, 0, 0).
        /// The secondary color can be updated at any time.  In particular, <see cref="glSecondaryColor"/> can
        /// be called between a call to  <see cref="glBegin"/>  and the corresponding call to
        /// <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glSecondaryColor3i(GLint red, GLint green, GLint blue);</para>
        /// </summary>
        /// <param name="red">
        /// Specify new red, green, and blue values for the current secondary color.
        /// </param>
        /// <param name="green">
        /// Specify new red, green, and blue values for the current secondary color.
        /// </param>
        /// <param name="blue">
        /// Specify new red, green, and blue values for the current secondary color.
        /// </param>
        /// <seealso cref="glColor"/>
        /// <seealso cref="glIndex"/>
        /// <seealso cref="glIsEnabled"/>
        /// <seealso cref="glLightModel"/>
        /// <seealso cref="glSecondaryColorPointer"/>
        [Obsolete("Compatibility-only GL 1.4 features removed from GL 3.2")]
        public static void glSecondaryColor3i(int red, int green, int blue) {
            var _F = _GetProc<GLNativeDelegate.FNglSecondaryColor3i>("glSecondaryColor3i");
            _F(red, green, blue);
        }
        /// <summary>
        /// set the current secondary color
        /// <para>Require:</para> <para>GL_VERSION_1_4</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glSecondaryColor"/> is available only if the GL version is 1.4 or greater.
        /// The initial value for the secondary color is (0, 0, 0, 0).
        /// The secondary color can be updated at any time.  In particular, <see cref="glSecondaryColor"/> can
        /// be called between a call to  <see cref="glBegin"/>  and the corresponding call to
        /// <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glSecondaryColor3iv(const GLint * v);</para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array that contains red, green, blue.
        /// </param>
        /// <seealso cref="glColor"/>
        /// <seealso cref="glIndex"/>
        /// <seealso cref="glIsEnabled"/>
        /// <seealso cref="glLightModel"/>
        /// <seealso cref="glSecondaryColorPointer"/>
        [Obsolete("Compatibility-only GL 1.4 features removed from GL 3.2")]
        public unsafe static void glSecondaryColor3iv(int* v) {
            var _F = _GetProc<GLNativeDelegate.FNglSecondaryColor3iv>("glSecondaryColor3iv");
            _F(v);
        }
        /// <summary>
        /// set the current secondary color
        /// <para>Require:</para> <para>GL_VERSION_1_4</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glSecondaryColor"/> is available only if the GL version is 1.4 or greater.
        /// The initial value for the secondary color is (0, 0, 0, 0).
        /// The secondary color can be updated at any time.  In particular, <see cref="glSecondaryColor"/> can
        /// be called between a call to  <see cref="glBegin"/>  and the corresponding call to
        /// <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glSecondaryColor3s(GLshort red, GLshort green, GLshort blue);</para>
        /// </summary>
        /// <param name="red">
        /// Specify new red, green, and blue values for the current secondary color.
        /// </param>
        /// <param name="green">
        /// Specify new red, green, and blue values for the current secondary color.
        /// </param>
        /// <param name="blue">
        /// Specify new red, green, and blue values for the current secondary color.
        /// </param>
        /// <seealso cref="glColor"/>
        /// <seealso cref="glIndex"/>
        /// <seealso cref="glIsEnabled"/>
        /// <seealso cref="glLightModel"/>
        /// <seealso cref="glSecondaryColorPointer"/>
        [Obsolete("Compatibility-only GL 1.4 features removed from GL 3.2")]
        public static void glSecondaryColor3s(short red, short green, short blue) {
            var _F = _GetProc<GLNativeDelegate.FNglSecondaryColor3s>("glSecondaryColor3s");
            _F(red, green, blue);
        }
        /// <summary>
        /// set the current secondary color
        /// <para>Require:</para> <para>GL_VERSION_1_4</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glSecondaryColor"/> is available only if the GL version is 1.4 or greater.
        /// The initial value for the secondary color is (0, 0, 0, 0).
        /// The secondary color can be updated at any time.  In particular, <see cref="glSecondaryColor"/> can
        /// be called between a call to  <see cref="glBegin"/>  and the corresponding call to
        /// <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glSecondaryColor3sv(const GLshort * v);</para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array that contains red, green, blue.
        /// </param>
        /// <seealso cref="glColor"/>
        /// <seealso cref="glIndex"/>
        /// <seealso cref="glIsEnabled"/>
        /// <seealso cref="glLightModel"/>
        /// <seealso cref="glSecondaryColorPointer"/>
        [Obsolete("Compatibility-only GL 1.4 features removed from GL 3.2")]
        public unsafe static void glSecondaryColor3sv(short* v) {
            var _F = _GetProc<GLNativeDelegate.FNglSecondaryColor3sv>("glSecondaryColor3sv");
            _F(v);
        }
        /// <summary>
        /// set the current secondary color
        /// <para>Require:</para> <para>GL_VERSION_1_4</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glSecondaryColor"/> is available only if the GL version is 1.4 or greater.
        /// The initial value for the secondary color is (0, 0, 0, 0).
        /// The secondary color can be updated at any time.  In particular, <see cref="glSecondaryColor"/> can
        /// be called between a call to  <see cref="glBegin"/>  and the corresponding call to
        /// <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glSecondaryColor3ub(GLubyte red, GLubyte green, GLubyte blue);</para>
        /// </summary>
        /// <param name="red">
        /// Specify new red, green, and blue values for the current secondary color.
        /// </param>
        /// <param name="green">
        /// Specify new red, green, and blue values for the current secondary color.
        /// </param>
        /// <param name="blue">
        /// Specify new red, green, and blue values for the current secondary color.
        /// </param>
        /// <seealso cref="glColor"/>
        /// <seealso cref="glIndex"/>
        /// <seealso cref="glIsEnabled"/>
        /// <seealso cref="glLightModel"/>
        /// <seealso cref="glSecondaryColorPointer"/>
        [Obsolete("Compatibility-only GL 1.4 features removed from GL 3.2")]
        public static void glSecondaryColor3ub(byte red, byte green, byte blue) {
            var _F = _GetProc<GLNativeDelegate.FNglSecondaryColor3ub>("glSecondaryColor3ub");
            _F(red, green, blue);
        }
        /// <summary>
        /// set the current secondary color
        /// <para>Require:</para> <para>GL_VERSION_1_4</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glSecondaryColor"/> is available only if the GL version is 1.4 or greater.
        /// The initial value for the secondary color is (0, 0, 0, 0).
        /// The secondary color can be updated at any time.  In particular, <see cref="glSecondaryColor"/> can
        /// be called between a call to  <see cref="glBegin"/>  and the corresponding call to
        /// <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glSecondaryColor3ubv(const GLubyte * v);</para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array that contains red, green, blue.
        /// </param>
        /// <seealso cref="glColor"/>
        /// <seealso cref="glIndex"/>
        /// <seealso cref="glIsEnabled"/>
        /// <seealso cref="glLightModel"/>
        /// <seealso cref="glSecondaryColorPointer"/>
        [Obsolete("Compatibility-only GL 1.4 features removed from GL 3.2")]
        public unsafe static void glSecondaryColor3ubv(byte* v) {
            var _F = _GetProc<GLNativeDelegate.FNglSecondaryColor3ubv>("glSecondaryColor3ubv");
            _F(v);
        }
        /// <summary>
        /// set the current secondary color
        /// <para>Require:</para> <para>GL_VERSION_1_4</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glSecondaryColor"/> is available only if the GL version is 1.4 or greater.
        /// The initial value for the secondary color is (0, 0, 0, 0).
        /// The secondary color can be updated at any time.  In particular, <see cref="glSecondaryColor"/> can
        /// be called between a call to  <see cref="glBegin"/>  and the corresponding call to
        /// <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glSecondaryColor3ui(GLuint red, GLuint green, GLuint blue);</para>
        /// </summary>
        /// <param name="red">
        /// Specify new red, green, and blue values for the current secondary color.
        /// </param>
        /// <param name="green">
        /// Specify new red, green, and blue values for the current secondary color.
        /// </param>
        /// <param name="blue">
        /// Specify new red, green, and blue values for the current secondary color.
        /// </param>
        /// <seealso cref="glColor"/>
        /// <seealso cref="glIndex"/>
        /// <seealso cref="glIsEnabled"/>
        /// <seealso cref="glLightModel"/>
        /// <seealso cref="glSecondaryColorPointer"/>
        [Obsolete("Compatibility-only GL 1.4 features removed from GL 3.2")]
        public static void glSecondaryColor3ui(uint red, uint green, uint blue) {
            var _F = _GetProc<GLNativeDelegate.FNglSecondaryColor3ui>("glSecondaryColor3ui");
            _F(red, green, blue);
        }
        /// <summary>
        /// set the current secondary color
        /// <para>Require:</para> <para>GL_VERSION_1_4</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glSecondaryColor"/> is available only if the GL version is 1.4 or greater.
        /// The initial value for the secondary color is (0, 0, 0, 0).
        /// The secondary color can be updated at any time.  In particular, <see cref="glSecondaryColor"/> can
        /// be called between a call to  <see cref="glBegin"/>  and the corresponding call to
        /// <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glSecondaryColor3uiv(const GLuint * v);</para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array that contains red, green, blue.
        /// </param>
        /// <seealso cref="glColor"/>
        /// <seealso cref="glIndex"/>
        /// <seealso cref="glIsEnabled"/>
        /// <seealso cref="glLightModel"/>
        /// <seealso cref="glSecondaryColorPointer"/>
        [Obsolete("Compatibility-only GL 1.4 features removed from GL 3.2")]
        public unsafe static void glSecondaryColor3uiv(uint* v) {
            var _F = _GetProc<GLNativeDelegate.FNglSecondaryColor3uiv>("glSecondaryColor3uiv");
            _F(v);
        }
        /// <summary>
        /// set the current secondary color
        /// <para>Require:</para> <para>GL_VERSION_1_4</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glSecondaryColor"/> is available only if the GL version is 1.4 or greater.
        /// The initial value for the secondary color is (0, 0, 0, 0).
        /// The secondary color can be updated at any time.  In particular, <see cref="glSecondaryColor"/> can
        /// be called between a call to  <see cref="glBegin"/>  and the corresponding call to
        /// <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glSecondaryColor3us(GLushort red, GLushort green, GLushort blue);</para>
        /// </summary>
        /// <param name="red">
        /// Specify new red, green, and blue values for the current secondary color.
        /// </param>
        /// <param name="green">
        /// Specify new red, green, and blue values for the current secondary color.
        /// </param>
        /// <param name="blue">
        /// Specify new red, green, and blue values for the current secondary color.
        /// </param>
        /// <seealso cref="glColor"/>
        /// <seealso cref="glIndex"/>
        /// <seealso cref="glIsEnabled"/>
        /// <seealso cref="glLightModel"/>
        /// <seealso cref="glSecondaryColorPointer"/>
        [Obsolete("Compatibility-only GL 1.4 features removed from GL 3.2")]
        public static void glSecondaryColor3us(ushort red, ushort green, ushort blue) {
            var _F = _GetProc<GLNativeDelegate.FNglSecondaryColor3us>("glSecondaryColor3us");
            _F(red, green, blue);
        }
        /// <summary>
        /// set the current secondary color
        /// <para>Require:</para> <para>GL_VERSION_1_4</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glSecondaryColor"/> is available only if the GL version is 1.4 or greater.
        /// The initial value for the secondary color is (0, 0, 0, 0).
        /// The secondary color can be updated at any time.  In particular, <see cref="glSecondaryColor"/> can
        /// be called between a call to  <see cref="glBegin"/>  and the corresponding call to
        /// <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glSecondaryColor3usv(const GLushort * v);</para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array that contains red, green, blue.
        /// </param>
        /// <seealso cref="glColor"/>
        /// <seealso cref="glIndex"/>
        /// <seealso cref="glIsEnabled"/>
        /// <seealso cref="glLightModel"/>
        /// <seealso cref="glSecondaryColorPointer"/>
        [Obsolete("Compatibility-only GL 1.4 features removed from GL 3.2")]
        public unsafe static void glSecondaryColor3usv(ushort* v) {
            var _F = _GetProc<GLNativeDelegate.FNglSecondaryColor3usv>("glSecondaryColor3usv");
            _F(v);
        }
        /// <summary>
        /// define an array of secondary colors
        /// <para>Require:</para> <para>GL_VERSION_1_4</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glSecondaryColorPointer"/> is available only if the GL version is 1.4 or greater.
        /// Secondary colors are not supported for interleaved vertex array formats
        /// (see  <see cref="glInterleavedArrays"/> ).
        /// The secondary color array is initially disabled and isn't accessed when
        /// <see cref="glArrayElement"/> ,  <see cref="glDrawElements"/> ,  <see cref="glDrawRangeElements"/> ,
        /// <see cref="glDrawArrays"/> ,  <see cref="glMultiDrawArrays"/> , or  <see cref="glMultiDrawElements"/> 
        /// is called.
        /// Execution of <see cref="glSecondaryColorPointer"/> is not allowed between the execution of
        /// <see cref="glBegin"/>  and the corresponding execution of  <see cref="glEnd"/> ,
        /// but an error may or may not be generated. If no error is generated,
        /// the operation is undefined.
        /// <see cref="glSecondaryColorPointer"/> is typically implemented on the client side.
        /// Secondary color array parameters are client-side state and are therefore
        /// not saved or restored by  <see cref="glPushAttrib"/>  and  <see cref="glPopAttrib"/> .  Use
        /// <see cref="glPushClientAttrib"/>  and  <see cref="glPopClientAttrib"/>  instead.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="size"/> is not 3.
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="type"/> is not an accepted value.
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="stride"/> is negative.
        /// </para>
        /// Original: <para>void glSecondaryColorPointer(GLint size, GLenum type, GLsizei stride, const void * pointer);</para>
        /// </summary>
        /// <param name="size">
        /// Specifies the number of components per color. Must be 3.
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the data type of each color component in the array.
        /// Symbolic constants
        /// <code>GL_BYTE</code>,
        /// <code>GL_UNSIGNED_BYTE</code>,
        /// <code>GL_SHORT</code>,
        /// <code>GL_UNSIGNED_SHORT</code>,
        /// <code>GL_INT</code>,
        /// <code>GL_UNSIGNED_INT</code>,
        /// <code>GL_FLOAT</code>,
        /// or
        /// <code>GL_DOUBLE</code>
        /// are accepted.
        /// The initial value is <code>GL_FLOAT</code>.
        /// </para>
        /// </param>
        /// <param name="stride">
        /// <para>
        /// Specifies the byte offset between consecutive colors.
        /// If <paramref name="stride"/> is 0, the colors are understood to be
        /// tightly packed in the array. The initial value is 0.
        /// </para>
        /// </param>
        /// <param name="pointer">
        /// <para>
        /// Specifies a pointer to the first component of the first color element
        /// in the array. The initial value is 0.
        /// </para>
        /// </param>
        /// <seealso cref="glArrayElement"/>
        /// <seealso cref="glBindBuffer"/>
        /// <seealso cref="glColorPointer"/>
        /// <seealso cref="glDisableClientState"/>
        /// <seealso cref="glDrawArrays"/>
        /// <seealso cref="glDrawElements"/>
        /// <seealso cref="glDrawRangeElements"/>
        /// <seealso cref="glEdgeFlagPointer"/>
        /// <seealso cref="glEnableClientState"/>
        /// <seealso cref="glFogCoordPointer"/>
        /// <seealso cref="glIndexPointer"/>
        /// <seealso cref="glInterleavedArrays"/>
        /// <seealso cref="glMultiDrawArrays"/>
        /// <seealso cref="glMultiDrawElements"/>
        /// <seealso cref="glNormalPointer"/>
        /// <seealso cref="glPopClientAttrib"/>
        /// <seealso cref="glPushClientAttrib"/>
        /// <seealso cref="glSecondaryColor"/>
        /// <seealso cref="glTexCoordPointer"/>
        /// <seealso cref="glVertexAttribPointer"/>
        /// <seealso cref="glVertexPointer"/>
        [Obsolete("Compatibility-only GL 1.4 features removed from GL 3.2")]
        public unsafe static void glSecondaryColorPointer(int size, uint type, int stride, void* pointer) {
            var _F = _GetProc<GLNativeDelegate.FNglSecondaryColorPointer>("glSecondaryColorPointer");
            _F(size, type, stride, pointer);
        }
        /// <summary>
        /// specify the raster position in window coordinates for pixel operations
        /// <para>Require:</para> <para>GL_VERSION_1_4</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glWindowPos"/> is available only if the GL version is 1.4 or greater.
        /// The raster position is modified by  <see cref="glRasterPos"/> ,  <see cref="glBitmap"/> , and
        /// <see cref="glWindowPos"/>.
        /// Calling  <see cref="glDrawElements"/> , or  <see cref="glDrawRangeElements"/>  may leave the
        /// current color or index indeterminate.
        /// If <see cref="glWindowPos"/> is executed while the current color or index is indeterminate, the
        /// current raster color or current raster index remains indeterminate.
        /// There are distinct raster texture coordinates for each texture unit. Each
        /// texture unit's current raster texture coordinates are updated by <see cref="glWindowPos"/>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glWindowPos"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glWindowPos2d(GLdouble x, GLdouble y);</para>
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify the 
        /// x   ,
        /// y   ,
        /// z   
        /// coordinates for the raster position.
        /// </para>
        /// </param>
        /// <param name="y">
        /// <para>
        /// Specify the 
        /// x   ,
        /// y   ,
        /// z   
        /// coordinates for the raster position.
        /// </para>
        /// </param>
        /// <seealso cref="glBitmap"/>
        /// <seealso cref="glCopyPixels"/>
        /// <seealso cref="glDrawArrays"/>
        /// <seealso cref="glDrawElements"/>
        /// <seealso cref="glDrawRangeElements"/>
        /// <seealso cref="glDrawPixels"/>
        /// <seealso cref="glMultiTexCoord"/>
        /// <seealso cref="glRasterPos"/>
        /// <seealso cref="glTexCoord"/>
        /// <seealso cref="glTexGen"/>
        /// <seealso cref="glVertex"/>
        [Obsolete("Compatibility-only GL 1.4 features removed from GL 3.2")]
        public static void glWindowPos2d(double x, double y) {
            var _F = _GetProc<GLNativeDelegate.FNglWindowPos2d>("glWindowPos2d");
            _F(x, y);
        }
        /// <summary>
        /// specify the raster position in window coordinates for pixel operations
        /// <para>Require:</para> <para>GL_VERSION_1_4</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glWindowPos"/> is available only if the GL version is 1.4 or greater.
        /// The raster position is modified by  <see cref="glRasterPos"/> ,  <see cref="glBitmap"/> , and
        /// <see cref="glWindowPos"/>.
        /// Calling  <see cref="glDrawElements"/> , or  <see cref="glDrawRangeElements"/>  may leave the
        /// current color or index indeterminate.
        /// If <see cref="glWindowPos"/> is executed while the current color or index is indeterminate, the
        /// current raster color or current raster index remains indeterminate.
        /// There are distinct raster texture coordinates for each texture unit. Each
        /// texture unit's current raster texture coordinates are updated by <see cref="glWindowPos"/>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glWindowPos"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glWindowPos2dv(const GLdouble * v);</para>
        /// </summary>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array of two or three elements,
        /// specifying 
        /// x   ,
        /// y   ,
        /// z   
        /// coordinates, respectively.
        /// </para>
        /// </param>
        /// <seealso cref="glBitmap"/>
        /// <seealso cref="glCopyPixels"/>
        /// <seealso cref="glDrawArrays"/>
        /// <seealso cref="glDrawElements"/>
        /// <seealso cref="glDrawRangeElements"/>
        /// <seealso cref="glDrawPixels"/>
        /// <seealso cref="glMultiTexCoord"/>
        /// <seealso cref="glRasterPos"/>
        /// <seealso cref="glTexCoord"/>
        /// <seealso cref="glTexGen"/>
        /// <seealso cref="glVertex"/>
        [Obsolete("Compatibility-only GL 1.4 features removed from GL 3.2")]
        public unsafe static void glWindowPos2dv(double* v) {
            var _F = _GetProc<GLNativeDelegate.FNglWindowPos2dv>("glWindowPos2dv");
            _F(v);
        }
        /// <summary>
        /// specify the raster position in window coordinates for pixel operations
        /// <para>Require:</para> <para>GL_VERSION_1_4</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glWindowPos"/> is available only if the GL version is 1.4 or greater.
        /// The raster position is modified by  <see cref="glRasterPos"/> ,  <see cref="glBitmap"/> , and
        /// <see cref="glWindowPos"/>.
        /// Calling  <see cref="glDrawElements"/> , or  <see cref="glDrawRangeElements"/>  may leave the
        /// current color or index indeterminate.
        /// If <see cref="glWindowPos"/> is executed while the current color or index is indeterminate, the
        /// current raster color or current raster index remains indeterminate.
        /// There are distinct raster texture coordinates for each texture unit. Each
        /// texture unit's current raster texture coordinates are updated by <see cref="glWindowPos"/>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glWindowPos"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glWindowPos2f(GLfloat x, GLfloat y);</para>
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify the 
        /// x   ,
        /// y   ,
        /// z   
        /// coordinates for the raster position.
        /// </para>
        /// </param>
        /// <param name="y">
        /// <para>
        /// Specify the 
        /// x   ,
        /// y   ,
        /// z   
        /// coordinates for the raster position.
        /// </para>
        /// </param>
        /// <seealso cref="glBitmap"/>
        /// <seealso cref="glCopyPixels"/>
        /// <seealso cref="glDrawArrays"/>
        /// <seealso cref="glDrawElements"/>
        /// <seealso cref="glDrawRangeElements"/>
        /// <seealso cref="glDrawPixels"/>
        /// <seealso cref="glMultiTexCoord"/>
        /// <seealso cref="glRasterPos"/>
        /// <seealso cref="glTexCoord"/>
        /// <seealso cref="glTexGen"/>
        /// <seealso cref="glVertex"/>
        [Obsolete("Compatibility-only GL 1.4 features removed from GL 3.2")]
        public static void glWindowPos2f(float x, float y) {
            var _F = _GetProc<GLNativeDelegate.FNglWindowPos2f>("glWindowPos2f");
            _F(x, y);
        }
        /// <summary>
        /// specify the raster position in window coordinates for pixel operations
        /// <para>Require:</para> <para>GL_VERSION_1_4</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glWindowPos"/> is available only if the GL version is 1.4 or greater.
        /// The raster position is modified by  <see cref="glRasterPos"/> ,  <see cref="glBitmap"/> , and
        /// <see cref="glWindowPos"/>.
        /// Calling  <see cref="glDrawElements"/> , or  <see cref="glDrawRangeElements"/>  may leave the
        /// current color or index indeterminate.
        /// If <see cref="glWindowPos"/> is executed while the current color or index is indeterminate, the
        /// current raster color or current raster index remains indeterminate.
        /// There are distinct raster texture coordinates for each texture unit. Each
        /// texture unit's current raster texture coordinates are updated by <see cref="glWindowPos"/>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glWindowPos"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glWindowPos2fv(const GLfloat * v);</para>
        /// </summary>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array of two or three elements,
        /// specifying 
        /// x   ,
        /// y   ,
        /// z   
        /// coordinates, respectively.
        /// </para>
        /// </param>
        /// <seealso cref="glBitmap"/>
        /// <seealso cref="glCopyPixels"/>
        /// <seealso cref="glDrawArrays"/>
        /// <seealso cref="glDrawElements"/>
        /// <seealso cref="glDrawRangeElements"/>
        /// <seealso cref="glDrawPixels"/>
        /// <seealso cref="glMultiTexCoord"/>
        /// <seealso cref="glRasterPos"/>
        /// <seealso cref="glTexCoord"/>
        /// <seealso cref="glTexGen"/>
        /// <seealso cref="glVertex"/>
        [Obsolete("Compatibility-only GL 1.4 features removed from GL 3.2")]
        public unsafe static void glWindowPos2fv(float* v) {
            var _F = _GetProc<GLNativeDelegate.FNglWindowPos2fv>("glWindowPos2fv");
            _F(v);
        }
        /// <summary>
        /// specify the raster position in window coordinates for pixel operations
        /// <para>Require:</para> <para>GL_VERSION_1_4</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glWindowPos"/> is available only if the GL version is 1.4 or greater.
        /// The raster position is modified by  <see cref="glRasterPos"/> ,  <see cref="glBitmap"/> , and
        /// <see cref="glWindowPos"/>.
        /// Calling  <see cref="glDrawElements"/> , or  <see cref="glDrawRangeElements"/>  may leave the
        /// current color or index indeterminate.
        /// If <see cref="glWindowPos"/> is executed while the current color or index is indeterminate, the
        /// current raster color or current raster index remains indeterminate.
        /// There are distinct raster texture coordinates for each texture unit. Each
        /// texture unit's current raster texture coordinates are updated by <see cref="glWindowPos"/>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glWindowPos"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glWindowPos2i(GLint x, GLint y);</para>
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify the 
        /// x   ,
        /// y   ,
        /// z   
        /// coordinates for the raster position.
        /// </para>
        /// </param>
        /// <param name="y">
        /// <para>
        /// Specify the 
        /// x   ,
        /// y   ,
        /// z   
        /// coordinates for the raster position.
        /// </para>
        /// </param>
        /// <seealso cref="glBitmap"/>
        /// <seealso cref="glCopyPixels"/>
        /// <seealso cref="glDrawArrays"/>
        /// <seealso cref="glDrawElements"/>
        /// <seealso cref="glDrawRangeElements"/>
        /// <seealso cref="glDrawPixels"/>
        /// <seealso cref="glMultiTexCoord"/>
        /// <seealso cref="glRasterPos"/>
        /// <seealso cref="glTexCoord"/>
        /// <seealso cref="glTexGen"/>
        /// <seealso cref="glVertex"/>
        [Obsolete("Compatibility-only GL 1.4 features removed from GL 3.2")]
        public static void glWindowPos2i(int x, int y) {
            var _F = _GetProc<GLNativeDelegate.FNglWindowPos2i>("glWindowPos2i");
            _F(x, y);
        }
        /// <summary>
        /// specify the raster position in window coordinates for pixel operations
        /// <para>Require:</para> <para>GL_VERSION_1_4</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glWindowPos"/> is available only if the GL version is 1.4 or greater.
        /// The raster position is modified by  <see cref="glRasterPos"/> ,  <see cref="glBitmap"/> , and
        /// <see cref="glWindowPos"/>.
        /// Calling  <see cref="glDrawElements"/> , or  <see cref="glDrawRangeElements"/>  may leave the
        /// current color or index indeterminate.
        /// If <see cref="glWindowPos"/> is executed while the current color or index is indeterminate, the
        /// current raster color or current raster index remains indeterminate.
        /// There are distinct raster texture coordinates for each texture unit. Each
        /// texture unit's current raster texture coordinates are updated by <see cref="glWindowPos"/>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glWindowPos"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glWindowPos2iv(const GLint * v);</para>
        /// </summary>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array of two or three elements,
        /// specifying 
        /// x   ,
        /// y   ,
        /// z   
        /// coordinates, respectively.
        /// </para>
        /// </param>
        /// <seealso cref="glBitmap"/>
        /// <seealso cref="glCopyPixels"/>
        /// <seealso cref="glDrawArrays"/>
        /// <seealso cref="glDrawElements"/>
        /// <seealso cref="glDrawRangeElements"/>
        /// <seealso cref="glDrawPixels"/>
        /// <seealso cref="glMultiTexCoord"/>
        /// <seealso cref="glRasterPos"/>
        /// <seealso cref="glTexCoord"/>
        /// <seealso cref="glTexGen"/>
        /// <seealso cref="glVertex"/>
        [Obsolete("Compatibility-only GL 1.4 features removed from GL 3.2")]
        public unsafe static void glWindowPos2iv(int* v) {
            var _F = _GetProc<GLNativeDelegate.FNglWindowPos2iv>("glWindowPos2iv");
            _F(v);
        }
        /// <summary>
        /// specify the raster position in window coordinates for pixel operations
        /// <para>Require:</para> <para>GL_VERSION_1_4</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glWindowPos"/> is available only if the GL version is 1.4 or greater.
        /// The raster position is modified by  <see cref="glRasterPos"/> ,  <see cref="glBitmap"/> , and
        /// <see cref="glWindowPos"/>.
        /// Calling  <see cref="glDrawElements"/> , or  <see cref="glDrawRangeElements"/>  may leave the
        /// current color or index indeterminate.
        /// If <see cref="glWindowPos"/> is executed while the current color or index is indeterminate, the
        /// current raster color or current raster index remains indeterminate.
        /// There are distinct raster texture coordinates for each texture unit. Each
        /// texture unit's current raster texture coordinates are updated by <see cref="glWindowPos"/>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glWindowPos"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glWindowPos2s(GLshort x, GLshort y);</para>
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify the 
        /// x   ,
        /// y   ,
        /// z   
        /// coordinates for the raster position.
        /// </para>
        /// </param>
        /// <param name="y">
        /// <para>
        /// Specify the 
        /// x   ,
        /// y   ,
        /// z   
        /// coordinates for the raster position.
        /// </para>
        /// </param>
        /// <seealso cref="glBitmap"/>
        /// <seealso cref="glCopyPixels"/>
        /// <seealso cref="glDrawArrays"/>
        /// <seealso cref="glDrawElements"/>
        /// <seealso cref="glDrawRangeElements"/>
        /// <seealso cref="glDrawPixels"/>
        /// <seealso cref="glMultiTexCoord"/>
        /// <seealso cref="glRasterPos"/>
        /// <seealso cref="glTexCoord"/>
        /// <seealso cref="glTexGen"/>
        /// <seealso cref="glVertex"/>
        [Obsolete("Compatibility-only GL 1.4 features removed from GL 3.2")]
        public static void glWindowPos2s(short x, short y) {
            var _F = _GetProc<GLNativeDelegate.FNglWindowPos2s>("glWindowPos2s");
            _F(x, y);
        }
        /// <summary>
        /// specify the raster position in window coordinates for pixel operations
        /// <para>Require:</para> <para>GL_VERSION_1_4</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glWindowPos"/> is available only if the GL version is 1.4 or greater.
        /// The raster position is modified by  <see cref="glRasterPos"/> ,  <see cref="glBitmap"/> , and
        /// <see cref="glWindowPos"/>.
        /// Calling  <see cref="glDrawElements"/> , or  <see cref="glDrawRangeElements"/>  may leave the
        /// current color or index indeterminate.
        /// If <see cref="glWindowPos"/> is executed while the current color or index is indeterminate, the
        /// current raster color or current raster index remains indeterminate.
        /// There are distinct raster texture coordinates for each texture unit. Each
        /// texture unit's current raster texture coordinates are updated by <see cref="glWindowPos"/>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glWindowPos"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glWindowPos2sv(const GLshort * v);</para>
        /// </summary>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array of two or three elements,
        /// specifying 
        /// x   ,
        /// y   ,
        /// z   
        /// coordinates, respectively.
        /// </para>
        /// </param>
        /// <seealso cref="glBitmap"/>
        /// <seealso cref="glCopyPixels"/>
        /// <seealso cref="glDrawArrays"/>
        /// <seealso cref="glDrawElements"/>
        /// <seealso cref="glDrawRangeElements"/>
        /// <seealso cref="glDrawPixels"/>
        /// <seealso cref="glMultiTexCoord"/>
        /// <seealso cref="glRasterPos"/>
        /// <seealso cref="glTexCoord"/>
        /// <seealso cref="glTexGen"/>
        /// <seealso cref="glVertex"/>
        [Obsolete("Compatibility-only GL 1.4 features removed from GL 3.2")]
        public unsafe static void glWindowPos2sv(short* v) {
            var _F = _GetProc<GLNativeDelegate.FNglWindowPos2sv>("glWindowPos2sv");
            _F(v);
        }
        /// <summary>
        /// specify the raster position in window coordinates for pixel operations
        /// <para>Require:</para> <para>GL_VERSION_1_4</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glWindowPos"/> is available only if the GL version is 1.4 or greater.
        /// The raster position is modified by  <see cref="glRasterPos"/> ,  <see cref="glBitmap"/> , and
        /// <see cref="glWindowPos"/>.
        /// Calling  <see cref="glDrawElements"/> , or  <see cref="glDrawRangeElements"/>  may leave the
        /// current color or index indeterminate.
        /// If <see cref="glWindowPos"/> is executed while the current color or index is indeterminate, the
        /// current raster color or current raster index remains indeterminate.
        /// There are distinct raster texture coordinates for each texture unit. Each
        /// texture unit's current raster texture coordinates are updated by <see cref="glWindowPos"/>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glWindowPos"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glWindowPos3d(GLdouble x, GLdouble y, GLdouble z);</para>
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify the 
        /// x   ,
        /// y   ,
        /// z   
        /// coordinates for the raster position.
        /// </para>
        /// </param>
        /// <param name="y">
        /// <para>
        /// Specify the 
        /// x   ,
        /// y   ,
        /// z   
        /// coordinates for the raster position.
        /// </para>
        /// </param>
        /// <param name="z">
        /// <para>
        /// Specify the 
        /// x   ,
        /// y   ,
        /// z   
        /// coordinates for the raster position.
        /// </para>
        /// </param>
        /// <seealso cref="glBitmap"/>
        /// <seealso cref="glCopyPixels"/>
        /// <seealso cref="glDrawArrays"/>
        /// <seealso cref="glDrawElements"/>
        /// <seealso cref="glDrawRangeElements"/>
        /// <seealso cref="glDrawPixels"/>
        /// <seealso cref="glMultiTexCoord"/>
        /// <seealso cref="glRasterPos"/>
        /// <seealso cref="glTexCoord"/>
        /// <seealso cref="glTexGen"/>
        /// <seealso cref="glVertex"/>
        [Obsolete("Compatibility-only GL 1.4 features removed from GL 3.2")]
        public static void glWindowPos3d(double x, double y, double z) {
            var _F = _GetProc<GLNativeDelegate.FNglWindowPos3d>("glWindowPos3d");
            _F(x, y, z);
        }
        /// <summary>
        /// specify the raster position in window coordinates for pixel operations
        /// <para>Require:</para> <para>GL_VERSION_1_4</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glWindowPos"/> is available only if the GL version is 1.4 or greater.
        /// The raster position is modified by  <see cref="glRasterPos"/> ,  <see cref="glBitmap"/> , and
        /// <see cref="glWindowPos"/>.
        /// Calling  <see cref="glDrawElements"/> , or  <see cref="glDrawRangeElements"/>  may leave the
        /// current color or index indeterminate.
        /// If <see cref="glWindowPos"/> is executed while the current color or index is indeterminate, the
        /// current raster color or current raster index remains indeterminate.
        /// There are distinct raster texture coordinates for each texture unit. Each
        /// texture unit's current raster texture coordinates are updated by <see cref="glWindowPos"/>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glWindowPos"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glWindowPos3dv(const GLdouble * v);</para>
        /// </summary>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array of two or three elements,
        /// specifying 
        /// x   ,
        /// y   ,
        /// z   
        /// coordinates, respectively.
        /// </para>
        /// </param>
        /// <seealso cref="glBitmap"/>
        /// <seealso cref="glCopyPixels"/>
        /// <seealso cref="glDrawArrays"/>
        /// <seealso cref="glDrawElements"/>
        /// <seealso cref="glDrawRangeElements"/>
        /// <seealso cref="glDrawPixels"/>
        /// <seealso cref="glMultiTexCoord"/>
        /// <seealso cref="glRasterPos"/>
        /// <seealso cref="glTexCoord"/>
        /// <seealso cref="glTexGen"/>
        /// <seealso cref="glVertex"/>
        [Obsolete("Compatibility-only GL 1.4 features removed from GL 3.2")]
        public unsafe static void glWindowPos3dv(double* v) {
            var _F = _GetProc<GLNativeDelegate.FNglWindowPos3dv>("glWindowPos3dv");
            _F(v);
        }
        /// <summary>
        /// specify the raster position in window coordinates for pixel operations
        /// <para>Require:</para> <para>GL_VERSION_1_4</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glWindowPos"/> is available only if the GL version is 1.4 or greater.
        /// The raster position is modified by  <see cref="glRasterPos"/> ,  <see cref="glBitmap"/> , and
        /// <see cref="glWindowPos"/>.
        /// Calling  <see cref="glDrawElements"/> , or  <see cref="glDrawRangeElements"/>  may leave the
        /// current color or index indeterminate.
        /// If <see cref="glWindowPos"/> is executed while the current color or index is indeterminate, the
        /// current raster color or current raster index remains indeterminate.
        /// There are distinct raster texture coordinates for each texture unit. Each
        /// texture unit's current raster texture coordinates are updated by <see cref="glWindowPos"/>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glWindowPos"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glWindowPos3f(GLfloat x, GLfloat y, GLfloat z);</para>
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify the 
        /// x   ,
        /// y   ,
        /// z   
        /// coordinates for the raster position.
        /// </para>
        /// </param>
        /// <param name="y">
        /// <para>
        /// Specify the 
        /// x   ,
        /// y   ,
        /// z   
        /// coordinates for the raster position.
        /// </para>
        /// </param>
        /// <param name="z">
        /// <para>
        /// Specify the 
        /// x   ,
        /// y   ,
        /// z   
        /// coordinates for the raster position.
        /// </para>
        /// </param>
        /// <seealso cref="glBitmap"/>
        /// <seealso cref="glCopyPixels"/>
        /// <seealso cref="glDrawArrays"/>
        /// <seealso cref="glDrawElements"/>
        /// <seealso cref="glDrawRangeElements"/>
        /// <seealso cref="glDrawPixels"/>
        /// <seealso cref="glMultiTexCoord"/>
        /// <seealso cref="glRasterPos"/>
        /// <seealso cref="glTexCoord"/>
        /// <seealso cref="glTexGen"/>
        /// <seealso cref="glVertex"/>
        [Obsolete("Compatibility-only GL 1.4 features removed from GL 3.2")]
        public static void glWindowPos3f(float x, float y, float z) {
            var _F = _GetProc<GLNativeDelegate.FNglWindowPos3f>("glWindowPos3f");
            _F(x, y, z);
        }
        /// <summary>
        /// specify the raster position in window coordinates for pixel operations
        /// <para>Require:</para> <para>GL_VERSION_1_4</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glWindowPos"/> is available only if the GL version is 1.4 or greater.
        /// The raster position is modified by  <see cref="glRasterPos"/> ,  <see cref="glBitmap"/> , and
        /// <see cref="glWindowPos"/>.
        /// Calling  <see cref="glDrawElements"/> , or  <see cref="glDrawRangeElements"/>  may leave the
        /// current color or index indeterminate.
        /// If <see cref="glWindowPos"/> is executed while the current color or index is indeterminate, the
        /// current raster color or current raster index remains indeterminate.
        /// There are distinct raster texture coordinates for each texture unit. Each
        /// texture unit's current raster texture coordinates are updated by <see cref="glWindowPos"/>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glWindowPos"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glWindowPos3fv(const GLfloat * v);</para>
        /// </summary>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array of two or three elements,
        /// specifying 
        /// x   ,
        /// y   ,
        /// z   
        /// coordinates, respectively.
        /// </para>
        /// </param>
        /// <seealso cref="glBitmap"/>
        /// <seealso cref="glCopyPixels"/>
        /// <seealso cref="glDrawArrays"/>
        /// <seealso cref="glDrawElements"/>
        /// <seealso cref="glDrawRangeElements"/>
        /// <seealso cref="glDrawPixels"/>
        /// <seealso cref="glMultiTexCoord"/>
        /// <seealso cref="glRasterPos"/>
        /// <seealso cref="glTexCoord"/>
        /// <seealso cref="glTexGen"/>
        /// <seealso cref="glVertex"/>
        [Obsolete("Compatibility-only GL 1.4 features removed from GL 3.2")]
        public unsafe static void glWindowPos3fv(float* v) {
            var _F = _GetProc<GLNativeDelegate.FNglWindowPos3fv>("glWindowPos3fv");
            _F(v);
        }
        /// <summary>
        /// specify the raster position in window coordinates for pixel operations
        /// <para>Require:</para> <para>GL_VERSION_1_4</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glWindowPos"/> is available only if the GL version is 1.4 or greater.
        /// The raster position is modified by  <see cref="glRasterPos"/> ,  <see cref="glBitmap"/> , and
        /// <see cref="glWindowPos"/>.
        /// Calling  <see cref="glDrawElements"/> , or  <see cref="glDrawRangeElements"/>  may leave the
        /// current color or index indeterminate.
        /// If <see cref="glWindowPos"/> is executed while the current color or index is indeterminate, the
        /// current raster color or current raster index remains indeterminate.
        /// There are distinct raster texture coordinates for each texture unit. Each
        /// texture unit's current raster texture coordinates are updated by <see cref="glWindowPos"/>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glWindowPos"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glWindowPos3i(GLint x, GLint y, GLint z);</para>
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify the 
        /// x   ,
        /// y   ,
        /// z   
        /// coordinates for the raster position.
        /// </para>
        /// </param>
        /// <param name="y">
        /// <para>
        /// Specify the 
        /// x   ,
        /// y   ,
        /// z   
        /// coordinates for the raster position.
        /// </para>
        /// </param>
        /// <param name="z">
        /// <para>
        /// Specify the 
        /// x   ,
        /// y   ,
        /// z   
        /// coordinates for the raster position.
        /// </para>
        /// </param>
        /// <seealso cref="glBitmap"/>
        /// <seealso cref="glCopyPixels"/>
        /// <seealso cref="glDrawArrays"/>
        /// <seealso cref="glDrawElements"/>
        /// <seealso cref="glDrawRangeElements"/>
        /// <seealso cref="glDrawPixels"/>
        /// <seealso cref="glMultiTexCoord"/>
        /// <seealso cref="glRasterPos"/>
        /// <seealso cref="glTexCoord"/>
        /// <seealso cref="glTexGen"/>
        /// <seealso cref="glVertex"/>
        [Obsolete("Compatibility-only GL 1.4 features removed from GL 3.2")]
        public static void glWindowPos3i(int x, int y, int z) {
            var _F = _GetProc<GLNativeDelegate.FNglWindowPos3i>("glWindowPos3i");
            _F(x, y, z);
        }
        /// <summary>
        /// specify the raster position in window coordinates for pixel operations
        /// <para>Require:</para> <para>GL_VERSION_1_4</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glWindowPos"/> is available only if the GL version is 1.4 or greater.
        /// The raster position is modified by  <see cref="glRasterPos"/> ,  <see cref="glBitmap"/> , and
        /// <see cref="glWindowPos"/>.
        /// Calling  <see cref="glDrawElements"/> , or  <see cref="glDrawRangeElements"/>  may leave the
        /// current color or index indeterminate.
        /// If <see cref="glWindowPos"/> is executed while the current color or index is indeterminate, the
        /// current raster color or current raster index remains indeterminate.
        /// There are distinct raster texture coordinates for each texture unit. Each
        /// texture unit's current raster texture coordinates are updated by <see cref="glWindowPos"/>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glWindowPos"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glWindowPos3iv(const GLint * v);</para>
        /// </summary>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array of two or three elements,
        /// specifying 
        /// x   ,
        /// y   ,
        /// z   
        /// coordinates, respectively.
        /// </para>
        /// </param>
        /// <seealso cref="glBitmap"/>
        /// <seealso cref="glCopyPixels"/>
        /// <seealso cref="glDrawArrays"/>
        /// <seealso cref="glDrawElements"/>
        /// <seealso cref="glDrawRangeElements"/>
        /// <seealso cref="glDrawPixels"/>
        /// <seealso cref="glMultiTexCoord"/>
        /// <seealso cref="glRasterPos"/>
        /// <seealso cref="glTexCoord"/>
        /// <seealso cref="glTexGen"/>
        /// <seealso cref="glVertex"/>
        [Obsolete("Compatibility-only GL 1.4 features removed from GL 3.2")]
        public unsafe static void glWindowPos3iv(int* v) {
            var _F = _GetProc<GLNativeDelegate.FNglWindowPos3iv>("glWindowPos3iv");
            _F(v);
        }
        /// <summary>
        /// specify the raster position in window coordinates for pixel operations
        /// <para>Require:</para> <para>GL_VERSION_1_4</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glWindowPos"/> is available only if the GL version is 1.4 or greater.
        /// The raster position is modified by  <see cref="glRasterPos"/> ,  <see cref="glBitmap"/> , and
        /// <see cref="glWindowPos"/>.
        /// Calling  <see cref="glDrawElements"/> , or  <see cref="glDrawRangeElements"/>  may leave the
        /// current color or index indeterminate.
        /// If <see cref="glWindowPos"/> is executed while the current color or index is indeterminate, the
        /// current raster color or current raster index remains indeterminate.
        /// There are distinct raster texture coordinates for each texture unit. Each
        /// texture unit's current raster texture coordinates are updated by <see cref="glWindowPos"/>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glWindowPos"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glWindowPos3s(GLshort x, GLshort y, GLshort z);</para>
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify the 
        /// x   ,
        /// y   ,
        /// z   
        /// coordinates for the raster position.
        /// </para>
        /// </param>
        /// <param name="y">
        /// <para>
        /// Specify the 
        /// x   ,
        /// y   ,
        /// z   
        /// coordinates for the raster position.
        /// </para>
        /// </param>
        /// <param name="z">
        /// <para>
        /// Specify the 
        /// x   ,
        /// y   ,
        /// z   
        /// coordinates for the raster position.
        /// </para>
        /// </param>
        /// <seealso cref="glBitmap"/>
        /// <seealso cref="glCopyPixels"/>
        /// <seealso cref="glDrawArrays"/>
        /// <seealso cref="glDrawElements"/>
        /// <seealso cref="glDrawRangeElements"/>
        /// <seealso cref="glDrawPixels"/>
        /// <seealso cref="glMultiTexCoord"/>
        /// <seealso cref="glRasterPos"/>
        /// <seealso cref="glTexCoord"/>
        /// <seealso cref="glTexGen"/>
        /// <seealso cref="glVertex"/>
        [Obsolete("Compatibility-only GL 1.4 features removed from GL 3.2")]
        public static void glWindowPos3s(short x, short y, short z) {
            var _F = _GetProc<GLNativeDelegate.FNglWindowPos3s>("glWindowPos3s");
            _F(x, y, z);
        }
        /// <summary>
        /// specify the raster position in window coordinates for pixel operations
        /// <para>Require:</para> <para>GL_VERSION_1_4</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glWindowPos"/> is available only if the GL version is 1.4 or greater.
        /// The raster position is modified by  <see cref="glRasterPos"/> ,  <see cref="glBitmap"/> , and
        /// <see cref="glWindowPos"/>.
        /// Calling  <see cref="glDrawElements"/> , or  <see cref="glDrawRangeElements"/>  may leave the
        /// current color or index indeterminate.
        /// If <see cref="glWindowPos"/> is executed while the current color or index is indeterminate, the
        /// current raster color or current raster index remains indeterminate.
        /// There are distinct raster texture coordinates for each texture unit. Each
        /// texture unit's current raster texture coordinates are updated by <see cref="glWindowPos"/>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glWindowPos"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glWindowPos3sv(const GLshort * v);</para>
        /// </summary>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array of two or three elements,
        /// specifying 
        /// x   ,
        /// y   ,
        /// z   
        /// coordinates, respectively.
        /// </para>
        /// </param>
        /// <seealso cref="glBitmap"/>
        /// <seealso cref="glCopyPixels"/>
        /// <seealso cref="glDrawArrays"/>
        /// <seealso cref="glDrawElements"/>
        /// <seealso cref="glDrawRangeElements"/>
        /// <seealso cref="glDrawPixels"/>
        /// <seealso cref="glMultiTexCoord"/>
        /// <seealso cref="glRasterPos"/>
        /// <seealso cref="glTexCoord"/>
        /// <seealso cref="glTexGen"/>
        /// <seealso cref="glVertex"/>
        [Obsolete("Compatibility-only GL 1.4 features removed from GL 3.2")]
        public unsafe static void glWindowPos3sv(short* v) {
            var _F = _GetProc<GLNativeDelegate.FNglWindowPos3sv>("glWindowPos3sv");
            _F(v);
        }

        #region Promoted from ARB_imaging subset to core

        /// <summary>
        /// set the blend color
        /// <para>Require:</para> <para>GL_VERSION_1_4, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0, GL_ARB_imaging</para>
        /// Supported: <para>gl, glcore</para>
        /// Notes: 
        /// <para>
        /// <see cref="glBlendColor"/> is part of the <code>ARB_imaging</code> subset. <see cref="glBlendColor"/> is present only
        /// if <code>ARB_imaging</code> is returned when  <see cref="glGetString"/>  is called with
        /// <code>GL_EXTENSIONS</code> as its argument.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glBlendColor"/> is executed
        /// between the execution of  <see cref="glBegin"/>  and the corresponding
        /// execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glBlendColor(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha);</para>
        /// </summary>
        /// <param name="red">
        /// specify the components of <code>GL_BLEND_COLOR</code>
        /// </param>
        /// <param name="green">
        /// specify the components of <code>GL_BLEND_COLOR</code>
        /// </param>
        /// <param name="blue">
        /// specify the components of <code>GL_BLEND_COLOR</code>
        /// </param>
        /// <param name="alpha">
        /// specify the components of <code>GL_BLEND_COLOR</code>
        /// </param>
        /// <seealso cref="glBlendEquation"/>
        /// <seealso cref="glBlendFunc"/>
        /// <seealso cref="glGetString"/>
        public static void glBlendColor(float red, float green, float blue, float alpha) {
            var _F = _GetProc<GLNativeDelegate.FNglBlendColor>("glBlendColor");
            _F(red, green, blue, alpha);
        }
        /// <summary>
        /// specify the equation used for both the RGB blend equation and the Alpha blend equation
        /// <para>Require:</para> <para>GL_VERSION_1_4, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0, GL_ARB_imaging</para>
        /// Supported: <para>gl, glcore</para>
        /// Notes: 
        /// <para>
        /// The <code>GL_MIN</code>, and <code>GL_MAX</code> equations do not use
        /// the source or destination factors, only the source and destination colors.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="mode"/> is not one of
        /// <code>GL_FUNC_ADD</code>, <code>GL_FUNC_SUBTRACT</code>, <code>GL_FUNC_REVERSE_SUBTRACT</code>,
        /// <code>GL_MAX</code>, or <code>GL_MIN</code>.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glBlendEquation"/> is executed
        /// between the execution of  <see cref="glBegin"/>  and the corresponding
        /// execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glBlendEquation(GLenum mode);</para>
        /// </summary>
        /// <param name="mode">
        /// <para>
        /// specifies how source and destination colors are combined.
        /// It must be <code>GL_FUNC_ADD</code>, <code>GL_FUNC_SUBTRACT</code>,
        /// <code>GL_FUNC_REVERSE_SUBTRACT</code>, <code>GL_MIN</code>, <code>GL_MAX</code>.
        /// </para>
        /// </param>
        /// <seealso cref="glGetString"/>
        /// <seealso cref="glBlendColor"/>
        /// <seealso cref="glBlendFunc"/>
        /// <seealso cref="glBlendFuncSeparate"/>
        public static void glBlendEquation(uint mode) {
            var _F = _GetProc<GLNativeDelegate.FNglBlendEquation>("glBlendEquation");
            _F(mode);
        }

        #endregion Promoted from ARB_imaging subset to core

        #endregion GL_VERSION_1_4

        #region GL_VERSION_1_5

        /// <summary>
        /// generate query object names
        /// <para>Require:</para> <para>GL_VERSION_1_5, GL_ES_VERSION_3_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <see cref="glGenQueries"/> is available only if the GL version is 1.5 or greater.
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="n"/> is negative.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glGenQueries"/> is executed
        /// between the execution of  <see cref="glBegin"/>  and the corresponding
        /// execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glGenQueries(GLsizei n, GLuint * ids);</para>
        /// </summary>
        /// <param name="n">
        /// Specifies the number of query object names to be generated.
        /// </param>
        /// <param name="ids">
        /// Specifies an array in which the generated query object names are stored.
        /// </param>
        /// <seealso cref="glBeginQuery"/>
        /// <seealso cref="glDeleteQueries"/>
        /// <seealso cref="glEndQuery"/>
        public unsafe static void glGenQueries(int n, uint* ids) {
            var _F = _GetProc<GLNativeDelegate.FNglGenQueries>("glGenQueries");
            _F(n, ids);
        }
        /// <summary>
        /// delete named query objects
        /// <para>Require:</para> <para>GL_VERSION_1_5, GL_ES_VERSION_3_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <see cref="glDeleteQueries"/> is available only if the GL version is 1.5 or greater.
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="n"/> is negative.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glDeleteQueries"/> is executed
        /// between the execution of  <see cref="glBegin"/>  and the corresponding
        /// execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glDeleteQueries(GLsizei n, const GLuint * ids);</para>
        /// </summary>
        /// <param name="n">
        /// Specifies the number of query objects to be deleted.
        /// </param>
        /// <param name="ids">
        /// Specifies an array of query objects to be deleted.
        /// </param>
        /// <seealso cref="glBeginQuery"/>
        /// <seealso cref="glEndQuery"/>
        /// <seealso cref="glGenQueries"/>
        /// <seealso cref="glGetQueryiv"/>
        /// <seealso cref="glGetQueryObject"/>
        public unsafe static void glDeleteQueries(int n, uint* ids) {
            var _F = _GetProc<GLNativeDelegate.FNglDeleteQueries>("glDeleteQueries");
            _F(n, ids);
        }
        /// <summary>
        /// determine if a name corresponds to a query object
        /// <para>Require:</para> <para>GL_VERSION_1_5, GL_ES_VERSION_3_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <see cref="glIsQuery"/> is available only if the GL version is 1.5 or greater.
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glIsQuery"/> is executed
        /// between the execution of  <see cref="glBegin"/>  and the corresponding
        /// execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>GLboolean glIsQuery(GLuint id);</para>
        /// </summary>
        /// <param name="id">
        /// Specifies a value that may be the name of a query object.
        /// </param>
        /// <seealso cref="glBeginQuery"/>
        /// <seealso cref="glDeleteQueries"/>
        /// <seealso cref="glEndQuery"/>
        /// <seealso cref="glGenQueries"/>
        public static bool glIsQuery(uint id) {
            var _F = _GetProc<GLNativeDelegate.FNglIsQuery>("glIsQuery");
            return _F(id);
        }
        /// <summary>
        /// delimit the boundaries of a query object
        /// <para>Require:</para> <para>GL_VERSION_1_5, GL_ES_VERSION_3_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// If the samples-passed count exceeds the maximum value representable in the number of available bits, as reported by
        /// <see cref="glGetQueryiv"/>  with <paramref name="pname"/>
        /// <code>GL_QUERY_COUNTER_BITS</code>, the count becomes undefined.
        /// An implementation may support 0 bits in its samples-passed counter, in which case query results are always undefined
        /// and essentially useless.
        /// When <code>GL_SAMPLE_BUFFERS</code> is 0, the samples-passed counter will increment once for each fragment that passes
        /// the depth test.  When <code>GL_SAMPLE_BUFFERS</code> is 1, an implementation may either increment the samples-passed
        /// counter individually for each sample of a fragment that passes the depth test, or it may choose to increment the counter for
        /// all samples of a fragment if any one of them passes the depth test.
        /// <see cref="glBeginQuery"/> and  <see cref="glEndQuery"/> 
        /// are available only if the GL version is 1.5 or greater.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="target"/> is not <code>GL_SAMPLES_PASSED</code>.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glBeginQuery"/> is executed while
        /// a query object of the same <paramref name="target"/> is already active.
        /// <code>GL_INVALID_OPERATION</code> is generated if  <see cref="glEndQuery"/> 
        /// is executed when a query object of the same <paramref name="target"/> is not active.
        /// <code>GL_INVALID_OPERATION</code> is generated if <paramref name="id"/> is 0.
        /// <code>GL_INVALID_OPERATION</code> is generated if <paramref name="id"/> is the name of an already active query object.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glBeginQuery"/> or
        /// <see cref="glEndQuery"/>  is executed between the execution of
        /// <see cref="glBegin"/>  and the corresponding execution of
        /// <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glBeginQuery(GLenum target, GLuint id);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target type of query object established between
        /// <see cref="glBeginQuery"/> and the subsequent  <see cref="glEndQuery"/> .
        /// The symbolic constant must be <code>GL_SAMPLES_PASSED</code>.
        /// </para>
        /// </param>
        /// <param name="id">
        /// Specifies the name of a query object.
        /// </param>
        /// <seealso cref="glDeleteQueries"/>
        /// <seealso cref="glGenQueries"/>
        /// <seealso cref="glGetQueryiv"/>
        /// <seealso cref="glGetQueryObject"/>
        /// <seealso cref="glIsQuery"/>
        public static void glBeginQuery(uint target, uint id) {
            var _F = _GetProc<GLNativeDelegate.FNglBeginQuery>("glBeginQuery");
            _F(target, id);
        }
        /// <summary>
        /// delimit the boundaries of a query object
        /// <para>Require:</para> <para>GL_VERSION_1_5, GL_ES_VERSION_3_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// If the samples-passed count exceeds the maximum value representable in the number of available bits, as reported by
        /// <see cref="glGetQueryiv"/>  with <paramref name="pname"/>
        /// <code>GL_QUERY_COUNTER_BITS</code>, the count becomes undefined.
        /// An implementation may support 0 bits in its samples-passed counter, in which case query results are always undefined
        /// and essentially useless.
        /// When <code>GL_SAMPLE_BUFFERS</code> is 0, the samples-passed counter will increment once for each fragment that passes
        /// the depth test.  When <code>GL_SAMPLE_BUFFERS</code> is 1, an implementation may either increment the samples-passed
        /// counter individually for each sample of a fragment that passes the depth test, or it may choose to increment the counter for
        /// all samples of a fragment if any one of them passes the depth test.
        /// <see cref="glBeginQuery"/> and  <see cref="glEndQuery"/> 
        /// are available only if the GL version is 1.5 or greater.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="target"/> is not <code>GL_SAMPLES_PASSED</code>.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glBeginQuery"/> is executed while
        /// a query object of the same <paramref name="target"/> is already active.
        /// <code>GL_INVALID_OPERATION</code> is generated if  <see cref="glEndQuery"/> 
        /// is executed when a query object of the same <paramref name="target"/> is not active.
        /// <code>GL_INVALID_OPERATION</code> is generated if <paramref name="id"/> is 0.
        /// <code>GL_INVALID_OPERATION</code> is generated if <paramref name="id"/> is the name of an already active query object.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glBeginQuery"/> or
        /// <see cref="glEndQuery"/>  is executed between the execution of
        /// <see cref="glBegin"/>  and the corresponding execution of
        /// <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glEndQuery(GLenum target);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target type of query object to be concluded.
        /// The symbolic constant must be <code>GL_SAMPLES_PASSED</code>.
        /// </para>
        /// </param>
        /// <seealso cref="glDeleteQueries"/>
        /// <seealso cref="glGenQueries"/>
        /// <seealso cref="glGetQueryiv"/>
        /// <seealso cref="glGetQueryObject"/>
        /// <seealso cref="glIsQuery"/>
        public static void glEndQuery(uint target) {
            var _F = _GetProc<GLNativeDelegate.FNglEndQuery>("glEndQuery");
            _F(target);
        }
        /// <summary>
        /// return parameters of a query object target
        /// <para>Require:</para> <para>GL_VERSION_1_5, GL_ES_VERSION_3_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// If an error is generated,
        /// no change is made to the contents of <paramref name="ps"/>.
        /// <see cref="glGetQueryiv"/> is available only if the GL version is 1.5 or greater.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="target"/> or <paramref name="pname"/> is not an
        /// accepted value.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glGetQueryiv"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glGetQueryiv(GLenum target, GLenum pname, GLint * params);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies a query object target.
        /// Must be <code>GL_SAMPLES_PASSED</code>.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of a query object target parameter.
        /// Accepted values are <code>GL_CURRENT_QUERY</code> or <code>GL_QUERY_COUNTER_BITS</code>.
        /// </para>
        /// </param>
        /// <param name="ps">
        /// Returns the requested data.
        /// </param>
        /// <seealso cref="glGetQueryObject"/>
        /// <seealso cref="glIsQuery"/>
        public unsafe static void glGetQueryiv(uint target, uint pname, int* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetQueryiv>("glGetQueryiv");
            _F(target, pname, ps);
        }
        /// <summary>
        /// return parameters of a query object
        /// <para>Require:</para> <para>GL_VERSION_1_5</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// If an error is generated,
        /// no change is made to the contents of <paramref name="ps"/>.
        /// <see cref="glGetQueryObject"/> implicitly flushes the GL pipeline so that any incomplete rendering
        /// delimited by the occlusion query completes in finite time.
        /// If multiple queries are issued using the same query object <paramref name="id"/> before calling 
        /// <see cref="glGetQueryObject"/>, the results of the most recent query will be returned.  In this case,
        /// when issuing a new query, the results of the previous query are discarded.
        /// <see cref="glGetQueryObject"/> is available only if the GL version is 1.5 or greater.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="pname"/> is not an accepted value.
        /// <code>GL_INVALID_OPERATION</code> is generated if <paramref name="id"/> is not the name of a query object.
        /// <code>GL_INVALID_OPERATION</code> is generated if <paramref name="id"/> is the name of a currently active 
        /// query object.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glGetQueryObject"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glGetQueryObjectiv(GLuint id, GLenum pname, GLint * params);</para>
        /// </summary>
        /// <param name="id">
        /// Specifies the name of a query object.
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of a query object parameter.
        /// Accepted values are <code>GL_QUERY_RESULT</code> or <code>GL_QUERY_RESULT_AVAILABLE</code>.
        /// </para>
        /// </param>
        /// <param name="ps">
        /// Returns the requested data.
        /// </param>
        /// <seealso cref="glBeginQuery"/>
        /// <seealso cref="glEndQuery"/>
        /// <seealso cref="glGetQueryiv"/>
        /// <seealso cref="glIsQuery"/>
        public unsafe static void glGetQueryObjectiv(uint id, uint pname, int* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetQueryObjectiv>("glGetQueryObjectiv");
            _F(id, pname, ps);
        }
        /// <summary>
        /// return parameters of a query object
        /// <para>Require:</para> <para>GL_VERSION_1_5, GL_ES_VERSION_3_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// If an error is generated,
        /// no change is made to the contents of <paramref name="ps"/>.
        /// <see cref="glGetQueryObject"/> implicitly flushes the GL pipeline so that any incomplete rendering
        /// delimited by the occlusion query completes in finite time.
        /// If multiple queries are issued using the same query object <paramref name="id"/> before calling 
        /// <see cref="glGetQueryObject"/>, the results of the most recent query will be returned.  In this case,
        /// when issuing a new query, the results of the previous query are discarded.
        /// <see cref="glGetQueryObject"/> is available only if the GL version is 1.5 or greater.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="pname"/> is not an accepted value.
        /// <code>GL_INVALID_OPERATION</code> is generated if <paramref name="id"/> is not the name of a query object.
        /// <code>GL_INVALID_OPERATION</code> is generated if <paramref name="id"/> is the name of a currently active 
        /// query object.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glGetQueryObject"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glGetQueryObjectuiv(GLuint id, GLenum pname, GLuint * params);</para>
        /// </summary>
        /// <param name="id">
        /// Specifies the name of a query object.
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of a query object parameter.
        /// Accepted values are <code>GL_QUERY_RESULT</code> or <code>GL_QUERY_RESULT_AVAILABLE</code>.
        /// </para>
        /// </param>
        /// <param name="ps">
        /// Returns the requested data.
        /// </param>
        /// <seealso cref="glBeginQuery"/>
        /// <seealso cref="glEndQuery"/>
        /// <seealso cref="glGetQueryiv"/>
        /// <seealso cref="glIsQuery"/>
        public unsafe static void glGetQueryObjectuiv(uint id, uint pname, uint* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetQueryObjectuiv>("glGetQueryObjectuiv");
            _F(id, pname, ps);
        }
        /// <summary>
        /// bind a named buffer object
        /// <para>Require:</para> <para>GL_VERSION_1_5, GL_VERSION_ES_CM_1_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glBindBuffer"/> is available only if the GL version is 1.5 or greater.
        /// <code>GL_PIXEL_PACK_BUFFER</code> and <code>GL_PIXEL_UNPACK_BUFFER</code> are 
        /// available only if the GL version is 2.1 or greater.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="target"/> is not one of the allowable
        /// values.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glBindBuffer"/> is executed
        /// between the execution of  <see cref="glBegin"/>  and the corresponding
        /// execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glBindBuffer(GLenum target, GLuint buffer);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target to which the buffer object is bound.
        /// The symbolic constant must be
        /// <code>GL_ARRAY_BUFFER</code>,
        /// <code>GL_ELEMENT_ARRAY_BUFFER</code>,
        /// <code>GL_PIXEL_PACK_BUFFER</code>, or
        /// <code>GL_PIXEL_UNPACK_BUFFER</code>.
        /// </para>
        /// </param>
        /// <param name="buffer">
        /// Specifies the name of a buffer object.
        /// </param>
        /// <seealso cref="glDeleteBuffers"/>
        /// <seealso cref="glGenBuffers"/>
        /// <seealso cref="glGet"/>
        /// <seealso cref="glIsBuffer"/>
        public static void glBindBuffer(uint target, uint buffer) {
            var _F = _GetProc<GLNativeDelegate.FNglBindBuffer>("glBindBuffer");
            _F(target, buffer);
        }
        /// <summary>
        /// delete named buffer objects
        /// <para>Require:</para> <para>GL_VERSION_1_5, GL_VERSION_ES_CM_1_0, GL_ES_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <see cref="glDeleteBuffers"/> is available only if the GL version is 1.5 or greater.
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="n"/> is negative.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glDeleteBuffers"/> is executed
        /// between the execution of  <see cref="glBegin"/>  and the corresponding
        /// execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glDeleteBuffers(GLsizei n, const GLuint * buffers);</para>
        /// </summary>
        /// <param name="n">
        /// Specifies the number of buffer objects to be deleted.
        /// </param>
        /// <param name="buffers">
        /// Specifies an array of buffer objects to be deleted.
        /// </param>
        /// <seealso cref="glBindBuffer"/>
        /// <seealso cref="glGenBuffers"/>
        /// <seealso cref="glGet"/>
        public unsafe static void glDeleteBuffers(int n, uint* buffers) {
            var _F = _GetProc<GLNativeDelegate.FNglDeleteBuffers>("glDeleteBuffers");
            _F(n, buffers);
        }
        /// <summary>
        /// generate buffer object names
        /// <para>Require:</para> <para>GL_VERSION_1_5, GL_VERSION_ES_CM_1_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <see cref="glGenBuffers"/> is available only if the GL version is 1.5 or greater.
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="n"/> is negative.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glGenBuffers"/> is executed
        /// between the execution of  <see cref="glBegin"/>  and the corresponding
        /// execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glGenBuffers(GLsizei n, GLuint * buffers);</para>
        /// </summary>
        /// <param name="n">
        /// Specifies the number of buffer object names to be generated.
        /// </param>
        /// <param name="buffers">
        /// Specifies an array in which the generated buffer object names are stored.
        /// </param>
        /// <seealso cref="glBindBuffer"/>
        /// <seealso cref="glDeleteBuffers"/>
        /// <seealso cref="glGet"/>
        public unsafe static void glGenBuffers(int n, uint* buffers) {
            var _F = _GetProc<GLNativeDelegate.FNglGenBuffers>("glGenBuffers");
            _F(n, buffers);
        }
        /// <summary>
        /// determine if a name corresponds to a buffer object
        /// <para>Require:</para> <para>GL_VERSION_1_5, GL_VERSION_ES_CM_1_0, GL_ES_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <see cref="glIsBuffer"/> is available only if the GL version is 1.5 or greater.
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glIsBuffer"/> is executed
        /// between the execution of  <see cref="glBegin"/>  and the corresponding
        /// execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>GLboolean glIsBuffer(GLuint buffer);</para>
        /// </summary>
        /// <param name="buffer">
        /// Specifies a value that may be the name of a buffer object.
        /// </param>
        /// <seealso cref="glBindBuffer"/>
        /// <seealso cref="glDeleteBuffers"/>
        /// <seealso cref="glGenBuffers"/>
        /// <seealso cref="glGet"/>
        public static bool glIsBuffer(uint buffer) {
            var _F = _GetProc<GLNativeDelegate.FNglIsBuffer>("glIsBuffer");
            return _F(buffer);
        }
        /// <summary>
        /// creates and initializes a buffer object's data store
        /// <para>Require:</para> <para>GL_VERSION_1_5, GL_VERSION_ES_CM_1_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glBufferData"/> is available only if the GL version is 1.5 or greater.
        /// Targets <code>GL_PIXEL_PACK_BUFFER</code> and <code>GL_PIXEL_UNPACK_BUFFER</code> are available 
        /// only if the GL version is 2.1 or greater.
        /// If <paramref name="data"/> is <code>NULL</code>, a data store of the specified size is still created,
        /// but its contents remain uninitialized and thus undefined.
        /// Clients must align data elements consistent with the requirements of the client
        /// platform, with an additional base-level requirement that an offset within a buffer to
        /// a datum comprising    N  bytes be a 
        /// multiple of  N   .
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="target"/> is not 
        /// <code>GL_ARRAY_BUFFER</code>, <code>GL_ELEMENT_ARRAY_BUFFER</code>, 
        /// <code>GL_PIXEL_PACK_BUFFER</code>, or <code>GL_PIXEL_UNPACK_BUFFER</code>.
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="usage"/> is not 
        /// <code>GL_STREAM_DRAW</code>, <code>GL_STREAM_READ</code>, <code>GL_STREAM_COPY</code>, 
        /// <code>GL_STATIC_DRAW</code>, <code>GL_STATIC_READ</code>, <code>GL_STATIC_COPY</code>, 
        /// <code>GL_DYNAMIC_DRAW</code>, <code>GL_DYNAMIC_READ</code>, or <code>GL_DYNAMIC_COPY</code>.
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="size"/> is negative.
        /// <code>GL_INVALID_OPERATION</code> is generated if the reserved buffer object name 0 is bound to <paramref name="target"/>.
        /// <code>GL_OUT_OF_MEMORY</code> is generated if the GL is unable to create a data store with the specified <paramref name="size"/>.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glBufferData"/>
        /// is executed between the execution of
        /// <see cref="glBegin"/>  and the corresponding execution of
        /// <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glBufferData(GLenum target, GLsizeiptr size, const void * data, GLenum usage);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target buffer object.
        /// The symbolic constant must be <code>GL_ARRAY_BUFFER</code>, 
        /// <code>GL_ELEMENT_ARRAY_BUFFER</code>,
        /// <code>GL_PIXEL_PACK_BUFFER</code>, or
        /// <code>GL_PIXEL_UNPACK_BUFFER</code>.
        /// </para>
        /// </param>
        /// <param name="size">
        /// Specifies the size in bytes of the buffer object's new data store.
        /// </param>
        /// <param name="data">
        /// <para>
        /// Specifies a pointer to data that will be copied into the data store for initialization,
        /// or <code>NULL</code> if no data is to be copied.
        /// </para>
        /// </param>
        /// <param name="usage">
        /// <para>
        /// Specifies the expected usage pattern of the data store. The symbolic constant must be
        /// <code>GL_STREAM_DRAW</code>, <code>GL_STREAM_READ</code>, <code>GL_STREAM_COPY</code>, 
        /// <code>GL_STATIC_DRAW</code>, <code>GL_STATIC_READ</code>, <code>GL_STATIC_COPY</code>, 
        /// <code>GL_DYNAMIC_DRAW</code>, <code>GL_DYNAMIC_READ</code>, or <code>GL_DYNAMIC_COPY</code>.
        /// </para>
        /// </param>
        /// <seealso cref="glBindBuffer"/>
        /// <seealso cref="glBufferSubData"/>
        /// <seealso cref="glMapBuffer"/>
        /// <seealso cref="glUnmapBuffer"/>
        public unsafe static void glBufferData(uint target, IntPtr size, void* data, uint usage) {
            var _F = _GetProc<GLNativeDelegate.FNglBufferData>("glBufferData");
            _F(target, size, data, usage);
        }
        /// <summary>
        /// updates a subset of a buffer object's data store
        /// <para>Require:</para> <para>GL_VERSION_1_5, GL_VERSION_ES_CM_1_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glBufferSubData"/> is available only if the GL version is 1.5 or greater.
        /// Targets <code>GL_PIXEL_PACK_BUFFER</code> and <code>GL_PIXEL_UNPACK_BUFFER</code> are available 
        /// only if the GL version is 2.1 or greater.
        /// When replacing the entire data store, consider using <see cref="glBufferSubData"/> rather
        /// than completely recreating the data store with <see cref="glBufferData"/>.  This avoids the cost of
        /// reallocating the data store.
        /// Consider using multiple buffer objects to avoid stalling the rendering pipeline during data store updates.
        /// If any rendering in the pipeline makes reference to data in the buffer object being updated by 
        /// <see cref="glBufferSubData"/>, especially from the specific region being updated, that rendering must 
        /// drain from the pipeline before the data store can be updated.
        /// Clients must align data elements consistent with the requirements of the client
        /// platform, with an additional base-level requirement that an offset within a buffer to
        /// a datum comprising    N  bytes be a 
        /// multiple of  N   .
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="target"/> is not 
        /// <code>GL_ARRAY_BUFFER</code>, <code>GL_ELEMENT_ARRAY_BUFFER</code>, 
        /// <code>GL_PIXEL_PACK_BUFFER</code>, or <code>GL_PIXEL_UNPACK_BUFFER</code>.
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="offset"/> or 
        /// <paramref name="size"/> is negative, or if together they define a region of memory
        /// that extends beyond the buffer object's allocated data store.
        /// <code>GL_INVALID_OPERATION</code> is generated if the reserved buffer object name 0 is bound to <paramref name="target"/>.
        /// <code>GL_INVALID_OPERATION</code> is generated if the buffer object being updated is mapped.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glBufferSubData"/>
        /// is executed between the execution of
        /// <see cref="glBegin"/>  and the corresponding execution of
        /// <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glBufferSubData(GLenum target, GLintptr offset, GLsizeiptr size, const void * data);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target buffer object.
        /// The symbolic constant must be <code>GL_ARRAY_BUFFER</code>, 
        /// <code>GL_ELEMENT_ARRAY_BUFFER</code>,
        /// <code>GL_PIXEL_PACK_BUFFER</code>, or
        /// <code>GL_PIXEL_UNPACK_BUFFER</code>.
        /// </para>
        /// </param>
        /// <param name="offset">
        /// <para>
        /// Specifies the offset into the buffer object's data store where data replacement will begin,
        /// measured in bytes.
        /// </para>
        /// </param>
        /// <param name="size">
        /// Specifies the size in bytes of the data store region being replaced.
        /// </param>
        /// <param name="data">
        /// Specifies a pointer to the new data that will be copied into the data store.
        /// </param>
        /// <seealso cref="glBindBuffer"/>
        /// <seealso cref="glBufferData"/>
        /// <seealso cref="glMapBuffer"/>
        /// <seealso cref="glUnmapBuffer"/>
        public unsafe static void glBufferSubData(uint target, IntPtr offset, IntPtr size, void* data) {
            var _F = _GetProc<GLNativeDelegate.FNglBufferSubData>("glBufferSubData");
            _F(target, offset, size, data);
        }
        /// <summary>
        /// returns a subset of a buffer object's data store
        /// <para>Require:</para> <para>GL_VERSION_1_5</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// If an error is generated,
        /// no change is made to the contents of <paramref name="data"/>.
        /// <see cref="glGetBufferSubData"/> is available only if the GL version is 1.5 or greater.
        /// Targets <code>GL_PIXEL_PACK_BUFFER</code> and <code>GL_PIXEL_UNPACK_BUFFER</code> are available 
        /// only if the GL version is 2.1 or greater.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="target"/> is not 
        /// <code>GL_ARRAY_BUFFER</code>, <code>GL_ELEMENT_ARRAY_BUFFER</code>, 
        /// <code>GL_PIXEL_PACK_BUFFER</code>, or <code>GL_PIXEL_UNPACK_BUFFER</code>.
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="offset"/> or 
        /// <paramref name="size"/> is negative, or if together they define a region of memory
        /// that extends beyond the buffer object's allocated data store.
        /// <code>GL_INVALID_OPERATION</code> is generated if the reserved buffer object name 0 is bound to <paramref name="target"/>.
        /// <code>GL_INVALID_OPERATION</code> is generated if the buffer object being queried is mapped.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glGetBufferSubData"/>
        /// is executed between the execution of
        /// <see cref="glBegin"/>  and the corresponding execution of
        /// <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glGetBufferSubData(GLenum target, GLintptr offset, GLsizeiptr size, void * data);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target buffer object.
        /// The symbolic constant must be <code>GL_ARRAY_BUFFER</code>, 
        /// <code>GL_ELEMENT_ARRAY_BUFFER</code>,
        /// <code>GL_PIXEL_PACK_BUFFER</code>, or
        /// <code>GL_PIXEL_UNPACK_BUFFER</code>.
        /// </para>
        /// </param>
        /// <param name="offset">
        /// <para>
        /// Specifies the offset into the buffer object's data store from which data will be returned,
        /// measured in bytes.
        /// </para>
        /// </param>
        /// <param name="size">
        /// Specifies the size in bytes of the data store region being returned.
        /// </param>
        /// <param name="data">
        /// Specifies a pointer to the location where buffer object data is returned.
        /// </param>
        /// <seealso cref="glBindBuffer"/>
        /// <seealso cref="glBufferData"/>
        /// <seealso cref="glBufferSubData"/>
        /// <seealso cref="glMapBuffer"/>
        /// <seealso cref="glUnmapBuffer"/>
        public unsafe static void glGetBufferSubData(uint target, IntPtr offset, IntPtr size, void* data) {
            var _F = _GetProc<GLNativeDelegate.FNglGetBufferSubData>("glGetBufferSubData");
            _F(target, offset, size, data);
        }
        /// <summary>
        /// map a buffer object's data store
        /// <para>Require:</para> <para>GL_VERSION_1_5</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// If an error is generated, <see cref="glMapBuffer"/> returns <code>NULL</code>, and
        /// <see cref="glUnmapBuffer"/> returns <code>GL_FALSE</code>.
        /// <see cref="glMapBuffer"/> and <see cref="glUnmapBuffer"/> are available only if the GL version is 1.5 or greater.
        /// <code>GL_PIXEL_PACK_BUFFER</code> and <code>GL_PIXEL_UNPACK_BUFFER</code> are 
        /// available only if the GL version is 2.1 or greater.
        /// Parameter values passed to GL commands may not be sourced from the returned pointer. No error will be generated,
        /// but results will be undefined and will likely vary across GL implementations.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="target"/> is not 
        /// <code>GL_ARRAY_BUFFER</code>, <code>GL_ELEMENT_ARRAY_BUFFER</code>, 
        /// <code>GL_PIXEL_PACK_BUFFER</code>, or <code>GL_PIXEL_UNPACK_BUFFER</code>.
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="access"/> is not 
        /// <code>GL_READ_ONLY</code>, <code>GL_WRITE_ONLY</code>, or <code>GL_READ_WRITE</code>.
        /// <code>GL_OUT_OF_MEMORY</code> is generated when <see cref="glMapBuffer"/> is executed
        /// if the GL is unable to map the buffer object's data store. This may occur for a variety of system-specific 
        /// reasons, such as the absence of sufficient remaining virtual memory.
        /// <code>GL_INVALID_OPERATION</code> is generated if the reserved buffer object name 0 is bound to <paramref name="target"/>.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glMapBuffer"/> is executed for
        /// a buffer object whose data store is already mapped.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glUnmapBuffer"/> is executed for
        /// a buffer object whose data store is not currently mapped.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glMapBuffer"/> or <see cref="glUnmapBuffer"/> is executed
        /// between the execution of  <see cref="glBegin"/>  and the corresponding
        /// execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void * glMapBuffer(GLenum target, GLenum access);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target buffer object being mapped.
        /// The symbolic constant must be
        /// <code>GL_ARRAY_BUFFER</code>,
        /// <code>GL_ELEMENT_ARRAY_BUFFER</code>,
        /// <code>GL_PIXEL_PACK_BUFFER</code>, or
        /// <code>GL_PIXEL_UNPACK_BUFFER</code>.
        /// </para>
        /// </param>
        /// <param name="access">
        /// <para>
        /// Specifies the access policy, indicating whether it will be possible to read from, write to,
        /// or both read from and write to the buffer object's mapped data store. The symbolic constant must be
        /// <code>GL_READ_ONLY</code>, <code>GL_WRITE_ONLY</code>, or <code>GL_READ_WRITE</code>.
        /// </para>
        /// </param>
        /// <seealso cref="glBindBuffer"/>
        /// <seealso cref="glBufferData"/>
        /// <seealso cref="glBufferSubData"/>
        /// <seealso cref="glDeleteBuffers"/>
        public unsafe static void* glMapBuffer(uint target, uint access) {
            var _F = _GetProc<GLNativeDelegate.FNglMapBuffer>("glMapBuffer");
            return _F(target, access);
        }
        /// <summary>
        /// map a buffer object's data store
        /// <para>Require:</para> <para>GL_VERSION_1_5, GL_ES_VERSION_3_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// If an error is generated, <see cref="glMapBuffer"/> returns <code>NULL</code>, and
        /// <see cref="glUnmapBuffer"/> returns <code>GL_FALSE</code>.
        /// <see cref="glMapBuffer"/> and <see cref="glUnmapBuffer"/> are available only if the GL version is 1.5 or greater.
        /// <code>GL_PIXEL_PACK_BUFFER</code> and <code>GL_PIXEL_UNPACK_BUFFER</code> are 
        /// available only if the GL version is 2.1 or greater.
        /// Parameter values passed to GL commands may not be sourced from the returned pointer. No error will be generated,
        /// but results will be undefined and will likely vary across GL implementations.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="target"/> is not 
        /// <code>GL_ARRAY_BUFFER</code>, <code>GL_ELEMENT_ARRAY_BUFFER</code>, 
        /// <code>GL_PIXEL_PACK_BUFFER</code>, or <code>GL_PIXEL_UNPACK_BUFFER</code>.
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="access"/> is not 
        /// <code>GL_READ_ONLY</code>, <code>GL_WRITE_ONLY</code>, or <code>GL_READ_WRITE</code>.
        /// <code>GL_OUT_OF_MEMORY</code> is generated when <see cref="glMapBuffer"/> is executed
        /// if the GL is unable to map the buffer object's data store. This may occur for a variety of system-specific 
        /// reasons, such as the absence of sufficient remaining virtual memory.
        /// <code>GL_INVALID_OPERATION</code> is generated if the reserved buffer object name 0 is bound to <paramref name="target"/>.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glMapBuffer"/> is executed for
        /// a buffer object whose data store is already mapped.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glUnmapBuffer"/> is executed for
        /// a buffer object whose data store is not currently mapped.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glMapBuffer"/> or <see cref="glUnmapBuffer"/> is executed
        /// between the execution of  <see cref="glBegin"/>  and the corresponding
        /// execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>GLboolean glUnmapBuffer(GLenum target);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target buffer object being unmapped.
        /// The symbolic constant must be
        /// <code>GL_ARRAY_BUFFER</code>,
        /// <code>GL_ELEMENT_ARRAY_BUFFER</code>,
        /// <code>GL_PIXEL_PACK_BUFFER</code>, or
        /// <code>GL_PIXEL_UNPACK_BUFFER</code>.
        /// </para>
        /// </param>
        /// <seealso cref="glBindBuffer"/>
        /// <seealso cref="glBufferData"/>
        /// <seealso cref="glBufferSubData"/>
        /// <seealso cref="glDeleteBuffers"/>
        public static bool glUnmapBuffer(uint target) {
            var _F = _GetProc<GLNativeDelegate.FNglUnmapBuffer>("glUnmapBuffer");
            return _F(target);
        }
        /// <summary>
        /// return parameters of a buffer object
        /// <para>Require:</para> <para>GL_VERSION_1_5, GL_VERSION_ES_CM_1_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// If an error is generated,
        /// no change is made to the contents of <paramref name="data"/>.
        /// <see cref="glGetBufferParameteriv"/> is available only if the GL version is 1.5 or greater.
        /// Targets <code>GL_PIXEL_PACK_BUFFER</code> and <code>GL_PIXEL_UNPACK_BUFFER</code> are available 
        /// only if the GL version is 2.1 or greater.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="target"/> or <paramref name="value"/> is not an
        /// accepted value.
        /// <code>GL_INVALID_OPERATION</code> is generated if the reserved buffer object name 0 is bound to <paramref name="target"/>.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glGetBufferParameteriv"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glGetBufferParameteriv(GLenum target, GLenum value, GLint * data);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target buffer object.
        /// The symbolic constant must be <code>GL_ARRAY_BUFFER</code>, 
        /// <code>GL_ELEMENT_ARRAY_BUFFER</code>,
        /// <code>GL_PIXEL_PACK_BUFFER</code>, or
        /// <code>GL_PIXEL_UNPACK_BUFFER</code>.
        /// </para>
        /// </param>
        /// <param name="value">
        /// <para>
        /// Specifies the symbolic name of a buffer object parameter.
        /// Accepted values are <code>GL_BUFFER_ACCESS</code>, <code>GL_BUFFER_MAPPED</code>, 
        /// <code>GL_BUFFER_SIZE</code>, or <code>GL_BUFFER_USAGE</code>.
        /// </para>
        /// </param>
        /// <param name="data">
        /// Returns the requested parameter.
        /// </param>
        /// <seealso cref="glBindBuffer"/>
        /// <seealso cref="glBufferData"/>
        /// <seealso cref="glMapBuffer"/>
        /// <seealso cref="glUnmapBuffer"/>
        public unsafe static void glGetBufferParameteriv(uint target, uint value, int* data) {
            var _F = _GetProc<GLNativeDelegate.FNglGetBufferParameteriv>("glGetBufferParameteriv");
            _F(target, value, data);
        }
        /// <summary>
        /// return the pointer to a mapped buffer object's data store
        /// <para>Require:</para> <para>GL_VERSION_1_5, GL_ES_VERSION_3_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// If an error is generated,
        /// no change is made to the contents of <paramref name="ps"/>.
        /// <see cref="glGetBufferPointerv"/> is available only if the GL version is 1.5 or greater.
        /// Targets <code>GL_PIXEL_PACK_BUFFER</code> and <code>GL_PIXEL_UNPACK_BUFFER</code> are available 
        /// only if the GL version is 2.1 or greater.
        /// The initial value for the pointer is <code>NULL</code>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="target"/> or <paramref name="pname"/> is not an
        /// accepted value.
        /// <code>GL_INVALID_OPERATION</code> is generated if the reserved buffer object name 0 is bound to <paramref name="target"/>.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glGetBufferPointerv"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glGetBufferPointerv(GLenum target, GLenum pname, void ** params);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target buffer object.
        /// The symbolic constant must be <code>GL_ARRAY_BUFFER</code>, 
        /// <code>GL_ELEMENT_ARRAY_BUFFER</code>,
        /// <code>GL_PIXEL_PACK_BUFFER</code>, or
        /// <code>GL_PIXEL_UNPACK_BUFFER</code>.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// Specifies the pointer to be returned.  The symbolic constant must be <code>GL_BUFFER_MAP_POINTER</code>.
        /// </param>
        /// <param name="ps">
        /// Returns the pointer value specified by <paramref name="pname"/>.
        /// </param>
        /// <seealso cref="glBindBuffer"/>
        /// <seealso cref="glMapBuffer"/>
        public unsafe static void glGetBufferPointerv(uint target, uint pname, void** ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetBufferPointerv>("glGetBufferPointerv");
            _F(target, pname, ps);
        }

        #endregion GL_VERSION_1_5

        #region GL_VERSION_2_0

        /// <summary>
        /// set the RGB blend equation and the alpha blend equation separately
        /// <para>Require:</para> <para>GL_VERSION_2_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glBlendEquationSeparate"/> is available only if the GL version is 2.0 or greater.
        /// The <code>GL_MIN</code>, and <code>GL_MAX</code> equations do not use
        /// the source or destination factors, only the source and destination colors.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if either <paramref name="modeRGB"/> or <paramref name="modeAlpha"/> is not one of
        /// <code>GL_FUNC_ADD</code>, <code>GL_FUNC_SUBTRACT</code>, <code>GL_FUNC_REVERSE_SUBTRACT</code>,
        /// <code>GL_MAX</code>, or <code>GL_MIN</code>.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glBlendEquationSeparate"/> is executed
        /// between the execution of  <see cref="glBegin"/>  and the corresponding
        /// execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glBlendEquationSeparate(GLenum modeRGB, GLenum modeAlpha);</para>
        /// </summary>
        /// <param name="modeRGB">
        /// <para>
        /// specifies the RGB blend equation, how the red, green, and blue components of the source and destination colors are combined.
        /// It must be <code>GL_FUNC_ADD</code>, <code>GL_FUNC_SUBTRACT</code>,
        /// <code>GL_FUNC_REVERSE_SUBTRACT</code>, <code>GL_MIN</code>, <code>GL_MAX</code>.
        /// </para>
        /// </param>
        /// <param name="modeAlpha">
        /// <para>
        /// specifies the alpha blend equation, how the alpha component of the source and destination colors are combined.
        /// It must be <code>GL_FUNC_ADD</code>, <code>GL_FUNC_SUBTRACT</code>,
        /// <code>GL_FUNC_REVERSE_SUBTRACT</code>, <code>GL_MIN</code>, <code>GL_MAX</code>.
        /// </para>
        /// </param>
        /// <seealso cref="glGetString"/>
        /// <seealso cref="glBlendColor"/>
        /// <seealso cref="glBlendFunc"/>
        /// <seealso cref="glBlendFuncSeparate"/>
        public static void glBlendEquationSeparate(uint modeRGB, uint modeAlpha) {
            var _F = _GetProc<GLNativeDelegate.FNglBlendEquationSeparate>("glBlendEquationSeparate");
            _F(modeRGB, modeAlpha);
        }
        /// <summary>
        /// Specifies a list of color buffers to be drawn into
        /// <para>Require:</para> <para>GL_VERSION_2_0, GL_ES_VERSION_3_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glDrawBuffers"/> is available only if
        /// the GL version is 2.0 or greater. 
        /// It is always the case that <code>GL_AUXi</code> =
        /// <code>GL_AUX0</code> + <code>i</code>. 
        /// The symbolic constants <code>GL_FRONT</code>,
        /// <code>GL_BACK</code>, <code>GL_LEFT</code>,
        /// <code>GL_RIGHT</code>, and
        /// <code>GL_FRONT_AND_BACK</code> are not allowed in the
        /// <paramref name="bufs"/> array since they may refer to
        /// multiple buffers. 
        /// If a fragment shader writes to neither
        /// <code>gl_FragColor</code> nor
        /// <code>gl_FragData</code>, the values of the fragment
        /// colors following shader execution are undefined. For each
        /// fragment generated in this situation, a different value may be
        /// written into each of the buffers specified by
        /// <paramref name="bufs"/>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if one of the
        /// values in <paramref name="bufs"/> is not an accepted
        /// value. 
        /// <code>GL_INVALID_ENUM</code> is generated if
        /// <paramref name="n"/> is less than 0. 
        /// <code>GL_INVALID_OPERATION</code> is generated if a
        /// symbolic constant other than <code>GL_NONE</code>
        /// appears more than once in <paramref name="bufs"/>. 
        /// <code>GL_INVALID_OPERATION</code> is generated if any of
        /// the entries in <paramref name="bufs"/> (other than
        /// <code>GL_NONE</code> ) indicates a color buffer that
        /// does not exist in the current GL context. 
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="n"/> is greater than
        /// <code>GL_MAX_DRAW_BUFFERS</code>. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <see cref="glDrawBuffers"/> is executed between the
        /// execution of
        /// <see cref="glBegin"/> 
        /// and the corresponding execution of
        /// <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glDrawBuffers(GLsizei n, const GLenum * bufs);</para>
        /// </summary>
        /// <param name="n">
        /// <para>
        /// Specifies the number of buffers in
        /// <paramref name="bufs"/>.
        /// </para>
        /// </param>
        /// <param name="bufs">
        /// <para>
        /// Points to an array of symbolic constants
        /// specifying the buffers into which fragment colors or
        /// data values will be written.
        /// </para>
        /// </param>
        /// <seealso cref="glBlendFunc"/>
        /// <seealso cref="glColorMask"/>
        /// <seealso cref="glDrawBuffers"/>
        /// <seealso cref="glIndexMask"/>
        /// <seealso cref="glLogicOp"/>
        /// <seealso cref="glReadBuffer"/>
        public unsafe static void glDrawBuffers(int n, uint* bufs) {
            var _F = _GetProc<GLNativeDelegate.FNglDrawBuffers>("glDrawBuffers");
            _F(n, bufs);
        }
        /// <summary>
        /// set front and/or back stencil test actions
        /// <para>Require:</para> <para>GL_VERSION_2_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glStencilOpSeparate"/> is available only if
        /// the GL version is 2.0 or greater.
        /// Initially the stencil test is disabled.
        /// If there is no stencil buffer,
        /// no stencil modification can occur
        /// and it is as if the stencil test always passes.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="face"/> is any value 
        /// other than <code>GL_FRONT</code>, <code>GL_BACK</code>, or <code>GL_FRONT_AND_BACK</code>.
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="sfail"/>,
        /// <paramref name="dpfail"/>, or <paramref name="dppass"/> is any value other than the eight defined constant values.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glStencilOpSeparate"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glStencilOpSeparate(GLenum face, GLenum sfail, GLenum dpfail, GLenum dppass);</para>
        /// </summary>
        /// <param name="face">
        /// <para>
        /// Specifies whether front and/or back stencil state is updated.
        /// Three symbolic constants are valid:
        /// <code>GL_FRONT</code>,
        /// <code>GL_BACK</code>, and
        /// <code>GL_FRONT_AND_BACK</code>.
        /// </para>
        /// </param>
        /// <param name="sfail">
        /// <para>
        /// Specifies the action to take when the stencil test fails.
        /// Eight symbolic constants are accepted:
        /// <code>GL_KEEP</code>,
        /// <code>GL_ZERO</code>,
        /// <code>GL_REPLACE</code>,
        /// <code>GL_INCR</code>,
        /// <code>GL_INCR_WRAP</code>,
        /// <code>GL_DECR</code>,
        /// <code>GL_DECR_WRAP</code>, and
        /// <code>GL_INVERT</code>. The initial value is <code>GL_KEEP</code>.
        /// </para>
        /// </param>
        /// <param name="dpfail">
        /// <para>
        /// Specifies the stencil action when the stencil test passes,
        /// but the depth test fails.
        /// <paramref name="dpfail"/> accepts the same symbolic constants as <paramref name="sfail"/>. The initial value
        /// is <code>GL_KEEP</code>.
        /// </para>
        /// </param>
        /// <param name="dppass">
        /// <para>
        /// Specifies the stencil action when both the stencil test and the depth
        /// test pass, or when the stencil test passes and either there is no
        /// depth buffer or depth testing is not enabled.
        /// <paramref name="dppass"/> accepts the same symbolic constants as <paramref name="sfail"/>. The initial value
        /// is <code>GL_KEEP</code>.
        /// </para>
        /// </param>
        /// <seealso cref="glAlphaFunc"/>
        /// <seealso cref="glBlendFunc"/>
        /// <seealso cref="glDepthFunc"/>
        /// <seealso cref="glEnable"/>
        /// <seealso cref="glLogicOp"/>
        /// <seealso cref="glStencilFunc"/>
        /// <seealso cref="glStencilFuncSeparate"/>
        /// <seealso cref="glStencilMask"/>
        /// <seealso cref="glStencilMaskSeparate"/>
        /// <seealso cref="glStencilOp"/>
        public static void glStencilOpSeparate(uint face, uint sfail, uint dpfail, uint dppass) {
            var _F = _GetProc<GLNativeDelegate.FNglStencilOpSeparate>("glStencilOpSeparate");
            _F(face, sfail, dpfail, dppass);
        }
        /// <summary>
        /// set front and/or back function and reference value for stencil testing
        /// <para>Require:</para> <para>GL_VERSION_2_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glStencilFuncSeparate"/> is available only if
        /// the GL version is 2.0 or greater.
        /// Initially, the stencil test is disabled.
        /// If there is no stencil buffer,
        /// no stencil modification can occur and it is as if
        /// the stencil test always passes.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="func"/> is not one of the eight
        /// accepted values.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glStencilFuncSeparate"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glStencilFuncSeparate(GLenum face, GLenum func, GLint ref, GLuint mask);</para>
        /// </summary>
        /// <param name="face">
        /// <para>
        /// Specifies whether front and/or back stencil state is updated.
        /// Three symbolic constants are valid:
        /// <code>GL_FRONT</code>,
        /// <code>GL_BACK</code>, and
        /// <code>GL_FRONT_AND_BACK</code>.
        /// </para>
        /// </param>
        /// <param name="func">
        /// <para>
        /// Specifies the test function.
        /// Eight symbolic constants are valid:
        /// <code>GL_NEVER</code>,
        /// <code>GL_LESS</code>,
        /// <code>GL_LEQUAL</code>,
        /// <code>GL_GREATER</code>,
        /// <code>GL_GEQUAL</code>,
        /// <code>GL_EQUAL</code>,
        /// <code>GL_NOTEQUAL</code>, and
        /// <code>GL_ALWAYS</code>. The initial value is <code>GL_ALWAYS</code>.
        /// </para>
        /// </param>
        /// <param name="r">
        /// <para>
        /// Specifies the reference value for the stencil test.
        /// <paramref name="r"/> is clamped to the range 
        /// 0 
        /// 2 
        /// n 
        /// - 
        /// 1 
        /// ,
        /// where 
        /// n   
        /// is the number of bitplanes in the stencil buffer. The
        /// initial value is 0.
        /// </para>
        /// </param>
        /// <param name="mask">
        /// <para>
        /// Specifies a mask that is ANDed with both the reference value
        /// and the stored stencil value when the test is done. The initial value
        /// is all 1's.
        /// </para>
        /// </param>
        /// <seealso cref="glAlphaFunc"/>
        /// <seealso cref="glBlendFunc"/>
        /// <seealso cref="glDepthFunc"/>
        /// <seealso cref="glEnable"/>
        /// <seealso cref="glLogicOp"/>
        /// <seealso cref="glStencilFunc"/>
        /// <seealso cref="glStencilMask"/>
        /// <seealso cref="glStencilMaskSeparate"/>
        /// <seealso cref="glStencilOp"/>
        /// <seealso cref="glStencilOpSeparate"/>
        public static void glStencilFuncSeparate(uint face, uint func, int r, uint mask) {
            var _F = _GetProc<GLNativeDelegate.FNglStencilFuncSeparate>("glStencilFuncSeparate");
            _F(face, func, r, mask);
        }
        /// <summary>
        /// control the front and/or back writing of individual bits in the stencil planes
        /// <para>Require:</para> <para>GL_VERSION_2_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glStencilMaskSeparate"/> is available only if
        /// the GL version is 2.0 or greater.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glStencilMaskSeparate"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glStencilMaskSeparate(GLenum face, GLuint mask);</para>
        /// </summary>
        /// <param name="face">
        /// <para>
        /// Specifies whether the front and/or back stencil writemask is updated.
        /// Three symbolic constants are valid:
        /// <code>GL_FRONT</code>,
        /// <code>GL_BACK</code>, and
        /// <code>GL_FRONT_AND_BACK</code>.
        /// </para>
        /// </param>
        /// <param name="mask">
        /// <para>
        /// Specifies a bit mask to enable and disable writing of individual bits
        /// in the stencil planes.
        /// Initially, the mask is all 1's.
        /// </para>
        /// </param>
        /// <seealso cref="glColorMask"/>
        /// <seealso cref="glDepthMask"/>
        /// <seealso cref="glIndexMask"/>
        /// <seealso cref="glStencilFunc"/>
        /// <seealso cref="glStencilFuncSeparate"/>
        /// <seealso cref="glStencilMask"/>
        /// <seealso cref="glStencilOp"/>
        /// <seealso cref="glStencilOpSeparate"/>
        public static void glStencilMaskSeparate(uint face, uint mask) {
            var _F = _GetProc<GLNativeDelegate.FNglStencilMaskSeparate>("glStencilMaskSeparate");
            _F(face, mask);
        }
        /// <summary>
        /// Attaches a shader object to a program object
        /// <para>Require:</para> <para>GL_VERSION_2_0, GL_ES_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glAttachShader"/>
        /// is available only if the GL version is 2.0 or greater.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if either
        /// <paramref name="program"/> or <paramref name="shader"/>
        /// is not a value generated by OpenGL. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <paramref name="program"/> is not a program object. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <paramref name="shader"/> is not a shader object. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <paramref name="shader"/> is already attached to
        /// <paramref name="program"/>. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <see cref="glAttachShader"/> is executed between the
        /// execution of
        /// <see cref="glBegin"/> 
        /// and the corresponding execution of
        /// <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glAttachShader(GLuint program, GLuint shader);</para>
        /// </summary>
        /// <param name="program">
        /// <para>
        /// Specifies the program object to which a shader
        /// object will be attached.
        /// </para>
        /// </param>
        /// <param name="shader">
        /// Specifies the shader object that is to be attached.
        /// </param>
        /// <seealso cref="glCompileShader"/>
        /// <seealso cref="glDetachShader"/>
        /// <seealso cref="glLinkProgram"/>
        /// <seealso cref="glShaderSource"/>
        public static void glAttachShader(uint program, uint shader) {
            var _F = _GetProc<GLNativeDelegate.FNglAttachShader>("glAttachShader");
            _F(program, shader);
        }
        /// <summary>
        /// Associates a generic vertex attribute index with a named attribute variable
        /// <para>Require:</para> <para>GL_VERSION_2_0, GL_ES_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glBindAttribLocation"/> is available
        /// only if the GL version is 2.0 or greater. 
        /// <see cref="glBindAttribLocation"/> can be called
        /// before any vertex shader objects are bound to the specified
        /// program object. It is also permissible to bind a generic
        /// attribute index to an attribute variable name that is never used
        /// in a vertex shader. 
        /// If <paramref name="name"/> was bound previously, that
        /// information is lost. Thus you cannot bind one user-defined
        /// attribute variable to multiple indices, but you can bind
        /// multiple user-defined attribute variables to the same
        /// index. 
        /// Applications are allowed to bind more than one
        /// user-defined attribute variable to the same generic vertex
        /// attribute index. This is called  aliasing ,
        /// and it is allowed only if just one of the aliased attributes is
        /// active in the executable program, or if no path through the
        /// shader consumes more than one attribute of a set of attributes
        /// aliased to the same location. The compiler and linker are
        /// allowed to assume that no aliasing is done and are free to
        /// employ optimizations that work only in the absence of aliasing.
        /// OpenGL implementations are not required to do error checking to
        /// detect aliasing. Because there is no way to bind standard
        /// attributes, it is not possible to alias generic attributes with
        /// conventional ones (except for generic attribute 0). 
        /// Active attributes that are not explicitly bound will be
        /// bound by the linker when
        /// <see cref="glLinkProgram"/> 
        /// is called. The locations assigned can be queried by calling
        /// <see cref="glGetAttribLocation"/> . 
        /// OpenGL copies the <paramref name="name"/> string when
        /// <see cref="glBindAttribLocation"/> is called, so an
        /// application may free its copy of the <paramref name="name"/>
        /// string immediately after the function returns.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="index"/> is greater than or equal to
        /// <code>GL_MAX_VERTEX_ATTRIBS</code>. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <paramref name="name"/> starts with the reserved prefix
        /// &quot;gl_&quot;. 
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="program"/> is not a value generated by
        /// OpenGL. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <paramref name="program"/> is not a program object. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <see cref="glBindAttribLocation"/> is executed between
        /// the execution of
        /// <see cref="glBegin"/> 
        /// and the corresponding execution of
        /// <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glBindAttribLocation(GLuint program, GLuint index, const GLchar * name);</para>
        /// </summary>
        /// <param name="program">
        /// <para>
        /// Specifies the handle of the program object in
        /// which the association is to be made.
        /// </para>
        /// </param>
        /// <param name="index">
        /// <para>
        /// Specifies the index of the generic vertex
        /// attribute to be bound.
        /// </para>
        /// </param>
        /// <param name="name">
        /// <para>
        /// Specifies a null terminated string containing
        /// the name of the vertex shader attribute variable to
        /// which <paramref name="index"/> is to be
        /// bound.
        /// </para>
        /// </param>
        /// <seealso cref="glDisableVertexAttribArray"/>
        /// <seealso cref="glEnableVertexAttribArray"/>
        /// <seealso cref="glUseProgram"/>
        /// <seealso cref="glVertexAttrib"/>
        /// <seealso cref="glVertexAttribPointer"/>
        public unsafe static void glBindAttribLocation(uint program, uint index, byte* name) {
            var _F = _GetProc<GLNativeDelegate.FNglBindAttribLocation>("glBindAttribLocation");
            _F(program, index, name);
        }
        /// <summary>
        /// Compiles a shader object
        /// <para>Require:</para> <para>GL_VERSION_2_0, GL_ES_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glCompileShader"/>
        /// is available only if the GL version is 2.0 or greater.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="shader"/> is not a value generated by
        /// OpenGL. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <paramref name="shader"/> is not a shader object. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <see cref="glCompileShader"/> is executed between the
        /// execution of
        /// <see cref="glBegin"/> 
        /// and the corresponding execution of
        /// <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glCompileShader(GLuint shader);</para>
        /// </summary>
        /// <param name="shader">
        /// <para>
        /// Specifies the shader object to be
        /// compiled.
        /// </para>
        /// </param>
        /// <seealso cref="glCreateShader"/>
        /// <seealso cref="glLinkProgram"/>
        /// <seealso cref="glShaderSource"/>
        public static void glCompileShader(uint shader) {
            var _F = _GetProc<GLNativeDelegate.FNglCompileShader>("glCompileShader");
            _F(shader);
        }
        /// <summary>
        /// Creates a program object
        /// <para>Require:</para> <para>GL_VERSION_2_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glCreateProgram"/> is available only if
        /// the GL version is 2.0 or greater. 
        /// Like display lists and texture objects, the name space for
        /// program objects may be shared across a set of contexts, as long
        /// as the server sides of the contexts share the same address
        /// space. If the name space is shared across contexts, any attached
        /// objects and the data associated with those attached objects are
        /// shared as well. 
        /// Applications are responsible for providing the
        /// synchronization across API calls when objects are accessed from
        /// different execution threads.
        /// </para>
        /// Errors: 
        /// <para>
        /// This function returns 0 if an error occurs creating the program object. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <see cref="glCreateProgram"/> is executed between the
        /// execution of
        /// <see cref="glBegin"/> 
        /// and the corresponding execution of
        /// <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>GLuint glCreateProgram();</para>
        /// </summary>
        /// <seealso cref="glAttachShader"/>
        /// <seealso cref="glBindAttribLocation"/>
        /// <seealso cref="glCreateShader"/>
        /// <seealso cref="glDeleteProgram"/>
        /// <seealso cref="glDetachShader"/>
        /// <seealso cref="glLinkProgram"/>
        /// <seealso cref="glUniform"/>
        /// <seealso cref="glUseProgram"/>
        /// <seealso cref="glValidateProgram"/>
        public static uint glCreateProgram() {
            var _F = _GetProc<GLNativeDelegate.FNglCreateProgram>("glCreateProgram");
            return _F();
        }
        /// <summary>
        /// Creates a shader object
        /// <para>Require:</para> <para>GL_VERSION_2_0, GL_ES_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glCreateShader"/> is available only if
        /// the GL version is 2.0 or greater. 
        /// Like display lists and texture objects, the name space for
        /// shader objects may be shared across a set of contexts, as long
        /// as the server sides of the contexts share the same address
        /// space. If the name space is shared across contexts, any attached
        /// objects and the data associated with those attached objects are
        /// shared as well. 
        /// Applications are responsible for providing the
        /// synchronization across API calls when objects are accessed from
        /// different execution threads.
        /// </para>
        /// Errors: 
        /// <para>
        /// This function returns 0 if an error occurs creating the
        /// shader object. 
        /// <code>GL_INVALID_ENUM</code> is generated if
        /// <paramref name="shaderType"/> is not an accepted value. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <see cref="glCreateShader"/> is executed between the
        /// execution of
        /// <see cref="glBegin"/> 
        /// and the corresponding execution of
        /// <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>GLuint glCreateShader(GLenum shaderType);</para>
        /// </summary>
        /// <param name="shaderType">
        /// <para>
        /// Specifies the type of shader to be created.
        /// Must be either <code>GL_VERTEX_SHADER</code>
        /// or <code>GL_FRAGMENT_SHADER</code>.
        /// </para>
        /// </param>
        /// <seealso cref="glAttachShader"/>
        /// <seealso cref="glCompileShader"/>
        /// <seealso cref="glDeleteShader"/>
        /// <seealso cref="glDetachShader"/>
        /// <seealso cref="glShaderSource"/>
        public static uint glCreateShader(uint shaderType) {
            var _F = _GetProc<GLNativeDelegate.FNglCreateShader>("glCreateShader");
            return _F(shaderType);
        }
        /// <summary>
        /// Deletes a program object
        /// <para>Require:</para> <para>GL_VERSION_2_0, GL_ES_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glDeleteProgram"/> is available only if
        /// the GL version is 2.0 or greater.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="program"/> is not a value generated by
        /// OpenGL. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <see cref="glDeleteProgram"/> is executed between the
        /// execution of
        /// <see cref="glBegin"/> 
        /// and the corresponding execution of
        /// <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glDeleteProgram(GLuint program);</para>
        /// </summary>
        /// <param name="program">
        /// <para>
        /// Specifies the program object to be
        /// deleted.
        /// </para>
        /// </param>
        /// <seealso cref="glCreateShader"/>
        /// <seealso cref="glDetachShader"/>
        /// <seealso cref="glUseProgram"/>
        public static void glDeleteProgram(uint program) {
            var _F = _GetProc<GLNativeDelegate.FNglDeleteProgram>("glDeleteProgram");
            _F(program);
        }
        /// <summary>
        /// Deletes a shader object
        /// <para>Require:</para> <para>GL_VERSION_2_0, GL_ES_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glDeleteShader"/> is available only if
        /// the GL version is 2.0 or greater.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="shader"/> is not a value generated by
        /// OpenGL. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <see cref="glDeleteShader"/> is executed between the
        /// execution of
        /// <see cref="glBegin"/> 
        /// and the corresponding execution of
        /// <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glDeleteShader(GLuint shader);</para>
        /// </summary>
        /// <param name="shader">
        /// Specifies the shader object to be deleted.
        /// </param>
        /// <seealso cref="glCreateProgram"/>
        /// <seealso cref="glCreateShader"/>
        /// <seealso cref="glDetachShader"/>
        /// <seealso cref="glUseProgram"/>
        public static void glDeleteShader(uint shader) {
            var _F = _GetProc<GLNativeDelegate.FNglDeleteShader>("glDeleteShader");
            _F(shader);
        }
        /// <summary>
        /// Detaches a shader object from a program object to which it is attached
        /// <para>Require:</para> <para>GL_VERSION_2_0, GL_ES_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glDetachShader"/> is available only if
        /// the GL version is 2.0 or greater.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if either
        /// <paramref name="program"/> or <paramref name="shader"/>
        /// is a value that was not generated by OpenGL. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <paramref name="program"/> is not a program object. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <paramref name="shader"/> is not a shader object. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <paramref name="shader"/> is not attached to
        /// <paramref name="program"/>. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <see cref="glDetachShader"/> is executed between the
        /// execution of
        /// <see cref="glBegin"/> 
        /// and the corresponding execution of
        /// <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glDetachShader(GLuint program, GLuint shader);</para>
        /// </summary>
        /// <param name="program">
        /// <para>
        /// Specifies the program object from which to
        /// detach the shader object.
        /// </para>
        /// </param>
        /// <param name="shader">
        /// <para>
        /// Specifies the shader object to be
        /// detached.
        /// </para>
        /// </param>
        /// <seealso cref="glAttachShader"/>
        public static void glDetachShader(uint program, uint shader) {
            var _F = _GetProc<GLNativeDelegate.FNglDetachShader>("glDetachShader");
            _F(program, shader);
        }
        /// <summary>
        /// Enable or disable a generic vertex attribute array
        /// <para>Require:</para> <para>GL_VERSION_2_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glEnableVertexAttribArray"/> and
        /// <see cref="glDisableVertexAttribArray "/> are available
        /// only if the GL version is 2.0 or greater.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="index"/> is greater than or equal to
        /// <code>GL_MAX_VERTEX_ATTRIBS</code>. 
        /// <code>GL_INVALID_OPERATION</code> is generated if either
        /// <see cref="glEnableVertexAttribArray "/> or
        /// <see cref="glDisableVertexAttribArray "/> is executed
        /// between the execution of
        /// <see cref="glBegin"/> 
        /// and the corresponding execution of
        /// <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glDisableVertexAttribArray(GLuint index);</para>
        /// </summary>
        /// <param name="index">
        /// <para>
        /// Specifies the index of the generic vertex
        /// attribute to be enabled or disabled.
        /// </para>
        /// </param>
        /// <seealso cref="glArrayElement"/>
        /// <seealso cref="glBindAttribLocation"/>
        /// <seealso cref="glDrawArrays"/>
        /// <seealso cref="glDrawElements"/>
        /// <seealso cref="glDrawRangeElements"/>
        /// <seealso cref="glMultiDrawElements"/>
        /// <seealso cref="glPopClientAttrib"/>
        /// <seealso cref="glPushClientAttrib"/>
        /// <seealso cref="glVertexAttrib"/>
        /// <seealso cref="glVertexAttribPointer"/>
        public static void glDisableVertexAttribArray(uint index) {
            var _F = _GetProc<GLNativeDelegate.FNglDisableVertexAttribArray>("glDisableVertexAttribArray");
            _F(index);
        }
        /// <summary>
        /// Enable or disable a generic vertex attribute array
        /// <para>Require:</para> <para>GL_VERSION_2_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glEnableVertexAttribArray"/> and
        /// <see cref="glDisableVertexAttribArray "/> are available
        /// only if the GL version is 2.0 or greater.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="index"/> is greater than or equal to
        /// <code>GL_MAX_VERTEX_ATTRIBS</code>. 
        /// <code>GL_INVALID_OPERATION</code> is generated if either
        /// <see cref="glEnableVertexAttribArray "/> or
        /// <see cref="glDisableVertexAttribArray "/> is executed
        /// between the execution of
        /// <see cref="glBegin"/> 
        /// and the corresponding execution of
        /// <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glEnableVertexAttribArray(GLuint index);</para>
        /// </summary>
        /// <param name="index">
        /// <para>
        /// Specifies the index of the generic vertex
        /// attribute to be enabled or disabled.
        /// </para>
        /// </param>
        /// <seealso cref="glArrayElement"/>
        /// <seealso cref="glBindAttribLocation"/>
        /// <seealso cref="glDrawArrays"/>
        /// <seealso cref="glDrawElements"/>
        /// <seealso cref="glDrawRangeElements"/>
        /// <seealso cref="glMultiDrawElements"/>
        /// <seealso cref="glPopClientAttrib"/>
        /// <seealso cref="glPushClientAttrib"/>
        /// <seealso cref="glVertexAttrib"/>
        /// <seealso cref="glVertexAttribPointer"/>
        public static void glEnableVertexAttribArray(uint index) {
            var _F = _GetProc<GLNativeDelegate.FNglEnableVertexAttribArray>("glEnableVertexAttribArray");
            _F(index);
        }
        /// <summary>
        /// Returns information about an active attribute variable for the specified program object
        /// <para>Require:</para> <para>GL_VERSION_2_0, GL_ES_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glGetActiveAttrib"/>
        /// is available only if the GL version is 2.0 or greater. 
        /// <code>GL_FLOAT_MAT2x3</code>,
        /// <code>GL_FLOAT_MAT2x4</code>,
        /// <code>GL_FLOAT_MAT3x2</code>,
        /// <code>GL_FLOAT_MAT3x4</code>,
        /// <code>GL_FLOAT_MAT4x2</code>, and
        /// <code>GL_FLOAT_MAT4x3</code>
        /// will only be returned as a <paramref name="type"/>
        /// if the GL version is 2.1 or greater.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="program"/> is not a value generated by
        /// OpenGL. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <paramref name="program"/> is not a program object. 
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="index"/> is greater than or equal to the
        /// number of active attribute variables in
        /// <paramref name="program"/>. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <see cref="glGetActiveAttrib"/> is executed between the
        /// execution of
        /// <see cref="glBegin"/> 
        /// and the corresponding execution of
        /// <see cref="glEnd"/> . 
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="bufSize"/> is less than 0.
        /// </para>
        /// Original: <para>void glGetActiveAttrib(GLuint program, GLuint index, GLsizei bufSize, GLsizei * length, GLint * size, GLenum * type, GLchar * name);</para>
        /// </summary>
        /// <param name="program">
        /// <para>
        /// Specifies the program object to be
        /// queried.
        /// </para>
        /// </param>
        /// <param name="index">
        /// <para>
        /// Specifies the index of the attribute variable
        /// to be queried.
        /// </para>
        /// </param>
        /// <param name="bufSize">
        /// <para>
        /// Specifies the maximum number of characters
        /// OpenGL is allowed to write in the character buffer
        /// indicated by <paramref name="name"/>.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// Returns the number of characters actually
        /// written by OpenGL in the string indicated by
        /// <paramref name="name"/> (excluding the null
        /// terminator) if a value other than
        /// <code>NULL</code> is passed.
        /// </para>
        /// </param>
        /// <param name="size">
        /// <para>
        /// Returns the size of the attribute
        /// variable.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Returns the data type of the attribute
        /// variable.
        /// </para>
        /// </param>
        /// <param name="name">
        /// <para>
        /// Returns a null terminated string containing
        /// the name of the attribute variable.
        /// </para>
        /// </param>
        /// <seealso cref="glBindAttribLocation"/>
        /// <seealso cref="glLinkProgram"/>
        /// <seealso cref="glVertexAttrib"/>
        /// <seealso cref="glVertexAttribPointer"/>
        public unsafe static void glGetActiveAttrib(uint program, uint index, int bufSize, int* length, int* size, uint* type, byte* name) {
            var _F = _GetProc<GLNativeDelegate.FNglGetActiveAttrib>("glGetActiveAttrib");
            _F(program, index, bufSize, length, size, type, name);
        }
        /// <summary>
        /// Returns information about an active uniform variable for the specified program object
        /// <para>Require:</para> <para>GL_VERSION_2_0, GL_ES_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glGetActiveUniform"/> is available only
        /// if the GL version is 2.0 or greater. 
        /// <code>GL_FLOAT_MAT2x3</code>,
        /// <code>GL_FLOAT_MAT2x4</code>,
        /// <code>GL_FLOAT_MAT3x2</code>,
        /// <code>GL_FLOAT_MAT3x4</code>,
        /// <code>GL_FLOAT_MAT4x2</code>, and
        /// <code>GL_FLOAT_MAT4x3</code>
        /// will only be returned as a <paramref name="type"/>
        /// if the GL version is 2.1 or greater.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="program"/> is not a value generated by
        /// OpenGL. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <paramref name="program"/> is not a program object. 
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="index"/> is greater than or equal to the
        /// number of active uniform variables in
        /// <paramref name="program"/>. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <see cref="glGetActiveUniform"/> is executed between the
        /// execution of
        /// <see cref="glBegin"/> 
        /// and the corresponding execution of
        /// <see cref="glEnd"/> . 
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="bufSize"/> is less than 0.
        /// </para>
        /// Original: <para>void glGetActiveUniform(GLuint program, GLuint index, GLsizei bufSize, GLsizei * length, GLint * size, GLenum * type, GLchar * name);</para>
        /// </summary>
        /// <param name="program">
        /// <para>
        /// Specifies the program object to be
        /// queried.
        /// </para>
        /// </param>
        /// <param name="index">
        /// <para>
        /// Specifies the index of the uniform variable to
        /// be queried.
        /// </para>
        /// </param>
        /// <param name="bufSize">
        /// <para>
        /// Specifies the maximum number of characters
        /// OpenGL is allowed to write in the character buffer
        /// indicated by <paramref name="name"/>.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// Returns the number of characters actually
        /// written by OpenGL in the string indicated by
        /// <paramref name="name"/> (excluding the null
        /// terminator) if a value other than
        /// <code>NULL</code> is passed.
        /// </para>
        /// </param>
        /// <param name="size">
        /// <para>
        /// Returns the size of the uniform
        /// variable.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Returns the data type of the uniform
        /// variable.
        /// </para>
        /// </param>
        /// <param name="name">
        /// <para>
        /// Returns a null terminated string containing
        /// the name of the uniform variable.
        /// </para>
        /// </param>
        /// <seealso cref="glGetUniform"/>
        /// <seealso cref="glGetUniformLocation"/>
        /// <seealso cref="glLinkProgram"/>
        /// <seealso cref="glUniform"/>
        /// <seealso cref="glUseProgram"/>
        public unsafe static void glGetActiveUniform(uint program, uint index, int bufSize, int* length, int* size, uint* type, byte* name) {
            var _F = _GetProc<GLNativeDelegate.FNglGetActiveUniform>("glGetActiveUniform");
            _F(program, index, bufSize, length, size, type, name);
        }
        /// <summary>
        /// Returns the handles of the shader objects attached to a program object
        /// <para>Require:</para> <para>GL_VERSION_2_0, GL_ES_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glGetAttachedShaders"/>
        /// is available only if the GL version is 2.0 or greater.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="program"/> is not a value generated by
        /// OpenGL. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <paramref name="program"/> is not a program object. 
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="maxCount"/> is less than 0. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <see cref="glGetAttachedShaders"/> 
        /// is executed between the execution of
        /// <see cref="glBegin"/> 
        /// and the corresponding execution of
        /// <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glGetAttachedShaders(GLuint program, GLsizei maxCount, GLsizei * count, GLuint * shaders);</para>
        /// </summary>
        /// <param name="program">
        /// <para>
        /// Specifies the program object to be
        /// queried.
        /// </para>
        /// </param>
        /// <param name="maxCount">
        /// <para>
        /// Specifies the size of the array for storing
        /// the returned object names.
        /// </para>
        /// </param>
        /// <param name="count">
        /// <para>
        /// Returns the number of names actually returned
        /// in <paramref name="shaders"/>.
        /// </para>
        /// </param>
        /// <param name="shaders">
        /// <para>
        /// Specifies an array that is used to return the
        /// names of attached shader objects.
        /// </para>
        /// </param>
        /// <seealso cref="glAttachShader"/>
        /// <seealso cref="glDetachShader"/>
        public unsafe static void glGetAttachedShaders(uint program, int maxCount, int* count, uint* shaders) {
            var _F = _GetProc<GLNativeDelegate.FNglGetAttachedShaders>("glGetAttachedShaders");
            _F(program, maxCount, count, shaders);
        }
        /// <summary>
        /// Returns the location of an attribute variable
        /// <para>Require:</para> <para>GL_VERSION_2_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glGetAttribLocation"/> is available only
        /// if the GL version is 2.0 or greater.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <paramref name="program"/> is not a value generated by
        /// OpenGL. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <paramref name="program"/> is not a program object. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <paramref name="program"/> has not been successfully
        /// linked. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <see cref="glGetAttribLocation"/> is executed between the
        /// execution of
        /// <see cref="glBegin"/> 
        /// and the corresponding execution of
        /// <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>GLint glGetAttribLocation(GLuint program, const GLchar * name);</para>
        /// </summary>
        /// <param name="program">
        /// <para>
        /// Specifies the program object to be
        /// queried.
        /// </para>
        /// </param>
        /// <param name="name">
        /// <para>
        /// Points to a null terminated string containing
        /// the name of the attribute variable whose location is
        /// to be queried.
        /// </para>
        /// </param>
        /// <seealso cref="glBindAttribLocation"/>
        /// <seealso cref="glLinkProgram"/>
        /// <seealso cref="glVertexAttrib"/>
        /// <seealso cref="glVertexAttribPointer"/>
        public unsafe static int glGetAttribLocation(uint program, byte* name) {
            var _F = _GetProc<GLNativeDelegate.FNglGetAttribLocation>("glGetAttribLocation");
            return _F(program, name);
        }
        /// <summary>
        /// Returns a parameter from a program object
        /// <para>Require:</para> <para>GL_VERSION_2_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glGetProgram"/> is available only if the
        /// GL version is 2.0 or greater. 
        /// If an error is generated, no change is made to the
        /// contents of <paramref name="ps"/>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code>
        /// is generated if <paramref name="program"/>
        /// is not a value generated by OpenGL. 
        /// <code>GL_INVALID_OPERATION</code>
        /// is generated if <paramref name="program"/>
        /// does not refer to a program object. 
        /// <code>GL_INVALID_ENUM</code>
        /// is generated if <paramref name="pname"/>
        /// is not an accepted value. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <see cref="glGetProgram"/> is executed between the
        /// execution of
        /// <see cref="glBegin"/> 
        /// and the corresponding execution of
        /// <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glGetProgramiv(GLuint program, GLenum pname, GLint * params);</para>
        /// </summary>
        /// <param name="program">
        /// <para>
        /// Specifies the program object to be
        /// queried.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the object parameter. Accepted
        /// symbolic names are
        /// <code>GL_DELETE_STATUS</code>,
        /// <code>GL_LINK_STATUS</code>,
        /// <code>GL_VALIDATE_STATUS</code>,
        /// <code>GL_INFO_LOG_LENGTH</code>,
        /// <code>GL_ATTACHED_SHADERS</code>,
        /// <code>GL_ACTIVE_ATTRIBUTES</code>,
        /// <code>GL_ACTIVE_ATTRIBUTE_MAX_LENGTH</code>,
        /// <code>GL_ACTIVE_UNIFORMS</code>,
        /// <code>GL_ACTIVE_UNIFORM_MAX_LENGTH</code>.
        /// </para>
        /// </param>
        /// <param name="ps">
        /// Returns the requested object parameter.
        /// </param>
        /// <seealso cref="glAttachShader"/>
        /// <seealso cref="glCreateProgram"/>
        /// <seealso cref="glDeleteProgram"/>
        /// <seealso cref="glGetShader"/>
        /// <seealso cref="glLinkProgram"/>
        /// <seealso cref="glValidateProgram"/>
        public unsafe static void glGetProgramiv(uint program, uint pname, int* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetProgramiv>("glGetProgramiv");
            _F(program, pname, ps);
        }
        /// <summary>
        /// Returns the information log for a program object
        /// <para>Require:</para> <para>GL_VERSION_2_0, GL_ES_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glGetProgramInfoLog"/> is available only
        /// if the GL version is 2.0 or greater. 
        /// The information log for a program object is the OpenGL
        /// implementer's primary mechanism for conveying information about
        /// linking and validating. Therefore, the information log can be
        /// helpful to application developers during the development
        /// process, even when these operations are successful. Application
        /// developers should not expect different OpenGL implementations to
        /// produce identical information logs.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="program"/> is not a value generated by
        /// OpenGL. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <paramref name="program"/> is not a program object. 
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="maxLength"/> is less than 0. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <see cref="glGetProgramInfoLog"/> is executed between the
        /// execution of
        /// <see cref="glBegin"/> 
        /// and the corresponding execution of
        /// <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glGetProgramInfoLog(GLuint program, GLsizei maxLength, GLsizei * length, GLchar * infoLog);</para>
        /// </summary>
        /// <param name="program">
        /// <para>
        /// Specifies the program object whose information
        /// log is to be queried.
        /// </para>
        /// </param>
        /// <param name="maxLength">
        /// <para>
        /// Specifies the size of the character buffer for
        /// storing the returned information log.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// Returns the length of the string returned in
        /// <paramref name="infoLog"/> (excluding the null
        /// terminator).
        /// </para>
        /// </param>
        /// <param name="infoLog">
        /// <para>
        /// Specifies an array of characters that is used
        /// to return the information log.
        /// </para>
        /// </param>
        /// <seealso cref="glCompileShader"/>
        /// <seealso cref="glGetShaderInfoLog"/>
        /// <seealso cref="glLinkProgram"/>
        /// <seealso cref="glValidateProgram"/>
        public unsafe static void glGetProgramInfoLog(uint program, int maxLength, int* length, byte* infoLog) {
            var _F = _GetProc<GLNativeDelegate.FNglGetProgramInfoLog>("glGetProgramInfoLog");
            _F(program, maxLength, length, infoLog);
        }
        /// <summary>
        /// Returns a parameter from a shader object
        /// <para>Require:</para> <para>GL_VERSION_2_0, GL_ES_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glGetShader"/> is available only if the
        /// GL version is 2.0 or greater. 
        /// If an error is generated, no change is made to the
        /// contents of <paramref name="ps"/>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="shader"/> is not a value generated by
        /// OpenGL. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <paramref name="shader"/> does not refer to a shader
        /// object. 
        /// <code>GL_INVALID_ENUM</code> is generated if
        /// <paramref name="pname"/> is not an accepted value. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <see cref="glGetShader"/> is executed between the
        /// execution of
        /// <see cref="glBegin"/> 
        /// and the corresponding execution of
        /// <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glGetShaderiv(GLuint shader, GLenum pname, GLint * params);</para>
        /// </summary>
        /// <param name="shader">
        /// <para>
        /// Specifies the shader object to be
        /// queried.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the object parameter. Accepted
        /// symbolic names are
        /// <code>GL_SHADER_TYPE</code>,
        /// <code>GL_DELETE_STATUS</code>,
        /// <code>GL_COMPILE_STATUS</code>,
        /// <code>GL_INFO_LOG_LENGTH</code>,
        /// <code>GL_SHADER_SOURCE_LENGTH</code>.
        /// </para>
        /// </param>
        /// <param name="ps">
        /// Returns the requested object parameter.
        /// </param>
        /// <seealso cref="glCompileShader"/>
        /// <seealso cref="glCreateShader"/>
        /// <seealso cref="glDeleteShader"/>
        /// <seealso cref="glGetProgram"/>
        /// <seealso cref="glShaderSource"/>
        public unsafe static void glGetShaderiv(uint shader, uint pname, int* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetShaderiv>("glGetShaderiv");
            _F(shader, pname, ps);
        }
        /// <summary>
        /// Returns the information log for a shader object
        /// <para>Require:</para> <para>GL_VERSION_2_0, GL_ES_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glGetShaderInfoLog"/> is available only
        /// if the GL version is 2.0 or greater. 
        /// The information log for a shader object is the OpenGL
        /// implementer's primary mechanism for conveying information about
        /// the compilation process. Therefore, the information log can be
        /// helpful to application developers during the development
        /// process, even when compilation is successful. Application
        /// developers should not expect different OpenGL implementations to
        /// produce identical information logs.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="shader"/> is not a value generated by
        /// OpenGL. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <paramref name="shader"/> is not a shader object. 
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="maxLength"/> is less than 0. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <see cref="glGetShaderInfoLog"/> is executed between the
        /// execution of
        /// <see cref="glBegin"/> 
        /// and the corresponding execution of
        /// <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glGetShaderInfoLog(GLuint shader, GLsizei maxLength, GLsizei * length, GLchar * infoLog);</para>
        /// </summary>
        /// <param name="shader">
        /// <para>
        /// Specifies the shader object whose information
        /// log is to be queried.
        /// </para>
        /// </param>
        /// <param name="maxLength">
        /// <para>
        /// Specifies the size of the character buffer for
        /// storing the returned information log.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// Returns the length of the string returned in
        /// <paramref name="infoLog"/> (excluding the null
        /// terminator).
        /// </para>
        /// </param>
        /// <param name="infoLog">
        /// <para>
        /// Specifies an array of characters that is used
        /// to return the information log.
        /// </para>
        /// </param>
        /// <seealso cref="glCompileShader"/>
        /// <seealso cref="glGetProgramInfoLog"/>
        /// <seealso cref="glLinkProgram"/>
        /// <seealso cref="glValidateProgram"/>
        public unsafe static void glGetShaderInfoLog(uint shader, int maxLength, int* length, byte* infoLog) {
            var _F = _GetProc<GLNativeDelegate.FNglGetShaderInfoLog>("glGetShaderInfoLog");
            _F(shader, maxLength, length, infoLog);
        }
        /// <summary>
        /// Returns the source code string from a shader object
        /// <para>Require:</para> <para>GL_VERSION_2_0, GL_ES_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glGetShaderSource"/> is available only
        /// if the GL version is 2.0 or greater.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="shader"/> is not a value generated by
        /// OpenGL. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <paramref name="shader"/> is not a shader object. 
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="bufSize"/> is less than 0. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <see cref="glGetShaderSource"/> is executed between the
        /// execution of
        /// <see cref="glBegin"/> 
        /// and the corresponding execution of
        /// <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glGetShaderSource(GLuint shader, GLsizei bufSize, GLsizei * length, GLchar * source);</para>
        /// </summary>
        /// <param name="shader">
        /// <para>
        /// Specifies the shader object to be
        /// queried.
        /// </para>
        /// </param>
        /// <param name="bufSize">
        /// <para>
        /// Specifies the size of the character buffer for
        /// storing the returned source code string.
        /// </para>
        /// </param>
        /// <param name="length">
        /// <para>
        /// Returns the length of the string returned in
        /// <paramref name="source"/> (excluding the null
        /// terminator).
        /// </para>
        /// </param>
        /// <param name="source">
        /// <para>
        /// Specifies an array of characters that is used
        /// to return the source code string.
        /// </para>
        /// </param>
        /// <seealso cref="glCreateShader"/>
        /// <seealso cref="glShaderSource"/>
        public unsafe static void glGetShaderSource(uint shader, int bufSize, int* length, byte* source) {
            var _F = _GetProc<GLNativeDelegate.FNglGetShaderSource>("glGetShaderSource");
            _F(shader, bufSize, length, source);
        }
        /// <summary>
        /// Returns the location of a uniform variable
        /// <para>Require:</para> <para>GL_VERSION_2_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glGetUniformLocation"/> is available
        /// only if the GL version is 2.0 or greater.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="program"/> is not a value generated by
        /// OpenGL. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <paramref name="program"/> is not a program object. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <paramref name="program"/> has not been successfully
        /// linked. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <see cref="glGetUniformLocation"/> is executed between
        /// the execution of
        /// <see cref="glBegin"/> 
        /// and the corresponding execution of
        /// <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>GLint glGetUniformLocation(GLuint program, const GLchar * name);</para>
        /// </summary>
        /// <param name="program">
        /// <para>
        /// Specifies the program object to be
        /// queried.
        /// </para>
        /// </param>
        /// <param name="name">
        /// <para>
        /// Points to a null terminated string containing
        /// the name of the uniform variable whose location is
        /// to be queried.
        /// </para>
        /// </param>
        /// <seealso cref="glLinkProgram"/>
        /// <seealso cref="glUniform"/>
        public unsafe static int glGetUniformLocation(uint program, byte* name) {
            var _F = _GetProc<GLNativeDelegate.FNglGetUniformLocation>("glGetUniformLocation");
            return _F(program, name);
        }
        /// <summary>
        /// Returns the value of a uniform variable
        /// <para>Require:</para> <para>GL_VERSION_2_0, GL_ES_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glGetUniform"/> is available only if the
        /// GL version is 2.0 or greater. 
        /// If an error is generated, no change is made to the
        /// contents of <paramref name="ps"/>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="program"/> is not a value generated by
        /// OpenGL. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <paramref name="program"/> is not a program object. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <paramref name="program"/> has not been successfully
        /// linked. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <paramref name="location"/> does not correspond to a valid
        /// uniform variable location for the specified program object. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <see cref="glGetUniform"/> is executed between the
        /// execution of
        /// <see cref="glBegin"/> 
        /// and the corresponding execution of
        /// <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glGetUniformfv(GLuint program, GLint location, GLfloat * params);</para>
        /// </summary>
        /// <param name="program">
        /// <para>
        /// Specifies the program object to be
        /// queried.
        /// </para>
        /// </param>
        /// <param name="location">
        /// <para>
        /// Specifies the location of the uniform variable
        /// to be queried.
        /// </para>
        /// </param>
        /// <param name="ps">
        /// <para>
        /// Returns the value of the specified uniform
        /// variable.
        /// </para>
        /// </param>
        /// <seealso cref="glCreateProgram"/>
        /// <seealso cref="glLinkProgram"/>
        /// <seealso cref="glUniform"/>
        public unsafe static void glGetUniformfv(uint program, int location, float* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetUniformfv>("glGetUniformfv");
            _F(program, location, ps);
        }
        /// <summary>
        /// Returns the value of a uniform variable
        /// <para>Require:</para> <para>GL_VERSION_2_0, GL_ES_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glGetUniform"/> is available only if the
        /// GL version is 2.0 or greater. 
        /// If an error is generated, no change is made to the
        /// contents of <paramref name="ps"/>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="program"/> is not a value generated by
        /// OpenGL. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <paramref name="program"/> is not a program object. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <paramref name="program"/> has not been successfully
        /// linked. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <paramref name="location"/> does not correspond to a valid
        /// uniform variable location for the specified program object. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <see cref="glGetUniform"/> is executed between the
        /// execution of
        /// <see cref="glBegin"/> 
        /// and the corresponding execution of
        /// <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glGetUniformiv(GLuint program, GLint location, GLint * params);</para>
        /// </summary>
        /// <param name="program">
        /// <para>
        /// Specifies the program object to be
        /// queried.
        /// </para>
        /// </param>
        /// <param name="location">
        /// <para>
        /// Specifies the location of the uniform variable
        /// to be queried.
        /// </para>
        /// </param>
        /// <param name="ps">
        /// <para>
        /// Returns the value of the specified uniform
        /// variable.
        /// </para>
        /// </param>
        /// <seealso cref="glCreateProgram"/>
        /// <seealso cref="glLinkProgram"/>
        /// <seealso cref="glUniform"/>
        public unsafe static void glGetUniformiv(uint program, int location, int* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetUniformiv>("glGetUniformiv");
            _F(program, location, ps);
        }
        /// <summary>
        /// Return a generic vertex attribute parameter
        /// <para>Require:</para> <para>GL_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glGetVertexAttrib"/> is available only
        /// if the GL version is 2.0 or greater. 
        /// If an error is generated, no change is made to the
        /// contents of <paramref name="ps"/>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="index"/> is greater than or equal to
        /// <code>GL_MAX_VERTEX_ATTRIBS</code>. 
        /// <code>GL_INVALID_ENUM</code> is generated if
        /// <paramref name="pname"/> is not an accepted value. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <paramref name="index"/> is 0 and
        /// <paramref name="pname"/> is
        /// <code>GL_CURRENT_VERTEX_ATTRIB</code>.
        /// </para>
        /// Original: <para>void glGetVertexAttribdv(GLuint index, GLenum pname, GLdouble * params);</para>
        /// </summary>
        /// <param name="index">
        /// <para>
        /// Specifies the generic vertex attribute
        /// parameter to be queried.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of the vertex
        /// attribute parameter to be queried. Accepted values are
        /// <code>GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING</code>,
        /// <code>GL_VERTEX_ATTRIB_ARRAY_ENABLED</code>,
        /// <code>GL_VERTEX_ATTRIB_ARRAY_SIZE</code>,
        /// <code>GL_VERTEX_ATTRIB_ARRAY_STRIDE</code>,
        /// <code>GL_VERTEX_ATTRIB_ARRAY_TYPE</code>,
        /// <code>GL_VERTEX_ATTRIB_ARRAY_NORMALIZED</code>, or
        /// <code>GL_CURRENT_VERTEX_ATTRIB</code>.
        /// </para>
        /// </param>
        /// <param name="ps">
        /// Returns the requested data.
        /// </param>
        /// <seealso cref="glBindAttribLocation"/>
        /// <seealso cref="glBindBuffer"/>
        /// <seealso cref="glDisableVertexAttribArray"/>
        /// <seealso cref="glEnableVertexAttribArray"/>
        /// <seealso cref="glVertexAttrib"/>
        /// <seealso cref="glVertexAttribPointer"/>
        public unsafe static void glGetVertexAttribdv(uint index, uint pname, double* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetVertexAttribdv>("glGetVertexAttribdv");
            _F(index, pname, ps);
        }
        /// <summary>
        /// Return a generic vertex attribute parameter
        /// <para>Require:</para> <para>GL_VERSION_2_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glGetVertexAttrib"/> is available only
        /// if the GL version is 2.0 or greater. 
        /// If an error is generated, no change is made to the
        /// contents of <paramref name="ps"/>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="index"/> is greater than or equal to
        /// <code>GL_MAX_VERTEX_ATTRIBS</code>. 
        /// <code>GL_INVALID_ENUM</code> is generated if
        /// <paramref name="pname"/> is not an accepted value. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <paramref name="index"/> is 0 and
        /// <paramref name="pname"/> is
        /// <code>GL_CURRENT_VERTEX_ATTRIB</code>.
        /// </para>
        /// Original: <para>void glGetVertexAttribfv(GLuint index, GLenum pname, GLfloat * params);</para>
        /// </summary>
        /// <param name="index">
        /// <para>
        /// Specifies the generic vertex attribute
        /// parameter to be queried.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of the vertex
        /// attribute parameter to be queried. Accepted values are
        /// <code>GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING</code>,
        /// <code>GL_VERTEX_ATTRIB_ARRAY_ENABLED</code>,
        /// <code>GL_VERTEX_ATTRIB_ARRAY_SIZE</code>,
        /// <code>GL_VERTEX_ATTRIB_ARRAY_STRIDE</code>,
        /// <code>GL_VERTEX_ATTRIB_ARRAY_TYPE</code>,
        /// <code>GL_VERTEX_ATTRIB_ARRAY_NORMALIZED</code>, or
        /// <code>GL_CURRENT_VERTEX_ATTRIB</code>.
        /// </para>
        /// </param>
        /// <param name="ps">
        /// Returns the requested data.
        /// </param>
        /// <seealso cref="glBindAttribLocation"/>
        /// <seealso cref="glBindBuffer"/>
        /// <seealso cref="glDisableVertexAttribArray"/>
        /// <seealso cref="glEnableVertexAttribArray"/>
        /// <seealso cref="glVertexAttrib"/>
        /// <seealso cref="glVertexAttribPointer"/>
        public unsafe static void glGetVertexAttribfv(uint index, uint pname, float* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetVertexAttribfv>("glGetVertexAttribfv");
            _F(index, pname, ps);
        }
        /// <summary>
        /// Return a generic vertex attribute parameter
        /// <para>Require:</para> <para>GL_VERSION_2_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glGetVertexAttrib"/> is available only
        /// if the GL version is 2.0 or greater. 
        /// If an error is generated, no change is made to the
        /// contents of <paramref name="ps"/>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="index"/> is greater than or equal to
        /// <code>GL_MAX_VERTEX_ATTRIBS</code>. 
        /// <code>GL_INVALID_ENUM</code> is generated if
        /// <paramref name="pname"/> is not an accepted value. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <paramref name="index"/> is 0 and
        /// <paramref name="pname"/> is
        /// <code>GL_CURRENT_VERTEX_ATTRIB</code>.
        /// </para>
        /// Original: <para>void glGetVertexAttribiv(GLuint index, GLenum pname, GLint * params);</para>
        /// </summary>
        /// <param name="index">
        /// <para>
        /// Specifies the generic vertex attribute
        /// parameter to be queried.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of the vertex
        /// attribute parameter to be queried. Accepted values are
        /// <code>GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING</code>,
        /// <code>GL_VERTEX_ATTRIB_ARRAY_ENABLED</code>,
        /// <code>GL_VERTEX_ATTRIB_ARRAY_SIZE</code>,
        /// <code>GL_VERTEX_ATTRIB_ARRAY_STRIDE</code>,
        /// <code>GL_VERTEX_ATTRIB_ARRAY_TYPE</code>,
        /// <code>GL_VERTEX_ATTRIB_ARRAY_NORMALIZED</code>, or
        /// <code>GL_CURRENT_VERTEX_ATTRIB</code>.
        /// </para>
        /// </param>
        /// <param name="ps">
        /// Returns the requested data.
        /// </param>
        /// <seealso cref="glBindAttribLocation"/>
        /// <seealso cref="glBindBuffer"/>
        /// <seealso cref="glDisableVertexAttribArray"/>
        /// <seealso cref="glEnableVertexAttribArray"/>
        /// <seealso cref="glVertexAttrib"/>
        /// <seealso cref="glVertexAttribPointer"/>
        public unsafe static void glGetVertexAttribiv(uint index, uint pname, int* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetVertexAttribiv>("glGetVertexAttribiv");
            _F(index, pname, ps);
        }
        /// <summary>
        /// return the address of the specified generic vertex attribute pointer
        /// <para>Require:</para> <para>GL_VERSION_2_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glGetVertexAttribPointerv"/>
        /// is available only if the GL version is 2.0 or greater. 
        /// The pointer returned is client-side state. 
        /// The initial value for each pointer is 0.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code>
        /// is generated if <paramref name="index"/>
        /// is greater than or equal to <code>GL_MAX_VERTEX_ATTRIBS</code>. 
        /// <code>GL_INVALID_ENUM</code>
        /// is generated if <paramref name="pname"/>
        /// is not an accepted value.
        /// </para>
        /// Original: <para>void glGetVertexAttribPointerv(GLuint index, GLenum pname, void ** pointer);</para>
        /// </summary>
        /// <param name="index">
        /// <para>
        /// Specifies the generic vertex attribute
        /// parameter to be returned.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of the generic
        /// vertex attribute parameter to be returned. Must be
        /// <code>GL_VERTEX_ATTRIB_ARRAY_POINTER</code>.
        /// </para>
        /// </param>
        /// <param name="pointer">
        /// Returns the pointer value.
        /// </param>
        /// <seealso cref="glGetVertexAttrib"/>
        /// <seealso cref="glVertexAttribPointer"/>
        public unsafe static void glGetVertexAttribPointerv(uint index, uint pname, void** pointer) {
            var _F = _GetProc<GLNativeDelegate.FNglGetVertexAttribPointerv>("glGetVertexAttribPointerv");
            _F(index, pname, pointer);
        }
        /// <summary>
        /// Determines if a name corresponds to a program object
        /// <para>Require:</para> <para>GL_VERSION_2_0, GL_ES_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glIsProgram"/> is available only if the
        /// GL version is 2.0 or greater. 
        /// No error is generated if <paramref name="program"/> is
        /// not a valid program object name. 
        /// A program object marked for deletion with  <see cref="glDeleteProgram"/> 
        /// but still in use as part of current rendering state is still considered 
        /// a program object and <see cref="glIsProgram"/> will return <code>GL_TRUE</code>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <see cref="glIsProgram"/> is executed between the
        /// execution of
        /// <see cref="glBegin"/> 
        /// and the corresponding execution of
        /// <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>GLboolean glIsProgram(GLuint program);</para>
        /// </summary>
        /// <param name="program">
        /// Specifies a potential program object.
        /// </param>
        /// <seealso cref="glAttachShader"/>
        /// <seealso cref="glBindAttribLocation"/>
        /// <seealso cref="glCreateProgram"/>
        /// <seealso cref="glDeleteProgram"/>
        /// <seealso cref="glDetachShader"/>
        /// <seealso cref="glLinkProgram"/>
        /// <seealso cref="glUniform"/>
        /// <seealso cref="glUseProgram"/>
        /// <seealso cref="glValidateProgram"/>
        public static bool glIsProgram(uint program) {
            var _F = _GetProc<GLNativeDelegate.FNglIsProgram>("glIsProgram");
            return _F(program);
        }
        /// <summary>
        /// Determines if a name corresponds to a shader object
        /// <para>Require:</para> <para>GL_VERSION_2_0, GL_ES_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glIsShader"/> is available only if the
        /// GL version is 2.0 or greater. 
        /// No error is generated if <paramref name="shader"/> is
        /// not a valid shader object name. 
        /// A shader object marked for deletion with  <see cref="glDeleteShader"/> 
        /// but still attached to a program object is still considered 
        /// a shader object and <see cref="glIsShader"/> will return <code>GL_TRUE</code>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <see cref="glIsShader"/> is executed between the
        /// execution of
        /// <see cref="glBegin"/> 
        /// and the corresponding execution of
        /// <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>GLboolean glIsShader(GLuint shader);</para>
        /// </summary>
        /// <param name="shader">
        /// Specifies a potential shader object.
        /// </param>
        /// <seealso cref="glAttachShader"/>
        /// <seealso cref="glCompileShader"/>
        /// <seealso cref="glCreateShader"/>
        /// <seealso cref="glDeleteShader"/>
        /// <seealso cref="glDetachShader"/>
        /// <seealso cref="glLinkProgram"/>
        /// <seealso cref="glShaderSource"/>
        public static bool glIsShader(uint shader) {
            var _F = _GetProc<GLNativeDelegate.FNglIsShader>("glIsShader");
            return _F(shader);
        }
        /// <summary>
        /// Links a program object
        /// <para>Require:</para> <para>GL_VERSION_2_0, GL_ES_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glLinkProgram"/>
        /// is available only if the GL version is 2.0 or greater. 
        /// If the link operation is unsuccessful, any information about a previous link operation on <paramref name="program"/>
        /// is lost (i.e., a failed link does not restore the old state of <paramref name="program"/>
        /// ). Certain information can still be retrieved from <paramref name="program"/>
        /// even after an unsuccessful link operation. See for instance  <see cref="glGetActiveAttrib"/> 
        /// and  <see cref="glGetActiveUniform"/> .
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code>
        /// is generated if <paramref name="program"/>
        /// is not a value generated by OpenGL. 
        /// <code>GL_INVALID_OPERATION</code>
        /// is generated if <paramref name="program"/>
        /// is not a program object. 
        /// <code>GL_INVALID_OPERATION</code>
        /// is generated if <see cref="glLinkProgram"/>
        /// is executed between the execution of  <see cref="glBegin"/> 
        /// and the corresponding execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glLinkProgram(GLuint program);</para>
        /// </summary>
        /// <param name="program">
        /// Specifies the handle of the program object to be linked.
        /// </param>
        /// <seealso cref="glAttachShader"/>
        /// <seealso cref="glBindAttribLocation"/>
        /// <seealso cref="glCompileShader"/>
        /// <seealso cref="glCreateProgram"/>
        /// <seealso cref="glDeleteProgram"/>
        /// <seealso cref="glDetachShader"/>
        /// <seealso cref="glUniform"/>
        /// <seealso cref="glUseProgram"/>
        /// <seealso cref="glValidateProgram"/>
        public static void glLinkProgram(uint program) {
            var _F = _GetProc<GLNativeDelegate.FNglLinkProgram>("glLinkProgram");
            _F(program);
        }
        /// <summary>
        /// Replaces the source code in a shader object
        /// <para>Require:</para> <para>GL_VERSION_2_0, GL_ES_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glShaderSource"/> is available only if
        /// the GL version is 2.0 or greater. 
        /// OpenGL copies the shader source code strings when
        /// <see cref="glShaderSource"/> is called, so an application
        /// may free its copy of the source code strings immediately after
        /// the function returns.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="shader"/> is not a value generated by
        /// OpenGL. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <paramref name="shader"/> is not a shader object. 
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="count"/> is less than 0. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <see cref="glShaderSource"/> is executed between the
        /// execution of
        /// <see cref="glBegin"/> 
        /// and the corresponding execution of
        /// <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glShaderSource(GLuint shader, GLsizei count, const GLchar ** string, const GLint * length);</para>
        /// </summary>
        /// <param name="shader">
        /// <para>
        /// Specifies the handle of the shader object
        /// whose source code is to be replaced.
        /// </para>
        /// </param>
        /// <param name="count">
        /// <para>
        /// Specifies the number of elements in the
        /// <paramref name="str"/> and
        /// <paramref name="length"/>
        /// arrays.
        /// </para>
        /// </param>
        /// <param name="str">
        /// <para>
        /// Specifies an array of pointers to strings
        /// containing the source code to be loaded into the
        /// shader.
        /// </para>
        /// </param>
        /// <param name="length">
        /// Specifies an array of string lengths.
        /// </param>
        /// <seealso cref="glCompileShader"/>
        /// <seealso cref="glCreateShader"/>
        /// <seealso cref="glDeleteShader"/>
        public unsafe static void glShaderSource(uint shader, int count, byte** str, int* length) {
            var _F = _GetProc<GLNativeDelegate.FNglShaderSource>("glShaderSource");
            _F(shader, count, str, length);
        }
        /// <summary>
        /// Installs a program object as part of current rendering state
        /// <para>Require:</para> <para>GL_VERSION_2_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glUseProgram"/> is available only if the
        /// GL version is 2.0 or greater. 
        /// While a program object is in use, the state that controls
        /// the disabled fixed functionality may also be updated using the
        /// normal OpenGL calls. 
        /// Like display lists and texture objects, the name space for
        /// program objects may be shared across a set of contexts, as long
        /// as the server sides of the contexts share the same address
        /// space. If the name space is shared across contexts, any attached
        /// objects and the data associated with those attached objects are
        /// shared as well. 
        /// Applications are responsible for providing the
        /// synchronization across API calls when objects are accessed from
        /// different execution threads.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="program"/> is neither 0 nor a value
        /// generated by OpenGL. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <paramref name="program"/> is not a program object. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <paramref name="program"/> could not be made part of current
        /// state. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <see cref="glUseProgram"/> is executed between the
        /// execution of
        /// <see cref="glBegin"/> 
        /// and the corresponding execution of
        /// <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glUseProgram(GLuint program);</para>
        /// </summary>
        /// <param name="program">
        /// <para>
        /// Specifies the handle of the program object
        /// whose executables are to be used as part of current
        /// rendering state.
        /// </para>
        /// </param>
        /// <seealso cref="gllAttachShader"/>
        /// <seealso cref="glBindAttribLocation"/>
        /// <seealso cref="glCompileShader"/>
        /// <seealso cref="glCreateProgram"/>
        /// <seealso cref="glDeleteProgram"/>
        /// <seealso cref="glDetachShader"/>
        /// <seealso cref="glLinkProgram"/>
        /// <seealso cref="glUniform"/>
        /// <seealso cref="glValidateProgram"/>
        /// <seealso cref="glVertexAttrib"/>
        public static void glUseProgram(uint program) {
            var _F = _GetProc<GLNativeDelegate.FNglUseProgram>("glUseProgram");
            _F(program);
        }
        /// <summary>
        /// Specify the value of a uniform variable for the current program object
        /// <para>Require:</para> <para>GL_VERSION_2_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glUniform"/> is available only if the GL
        /// version is 2.0 or greater. 
        /// <see cref="glUniformMatrix{2x3|3x2|2x4|4x2|3x4|4x3}fv"/> 
        /// is available only if the GL version is 2.1 or greater. 
        /// <see cref="glUniform1i"/> and
        /// <see cref="glUniform1iv"/> are the only two functions
        /// that may be used to load uniform variables defined as sampler
        /// types. Loading samplers with any other function will result in a
        /// <code>GL_INVALID_OPERATION</code> error. 
        /// If <paramref name="count"/> is greater than 1 and the
        /// indicated uniform variable is not an array, a
        /// <code>GL_INVALID_OPERATION</code> error is generated and the
        /// specified uniform variable will remain unchanged. 
        /// Other than the preceding exceptions, if the type and size
        /// of the uniform variable as defined in the shader do not match
        /// the type and size specified in the name of the command used to
        /// load its value, a <code>GL_INVALID_OPERATION</code> error will
        /// be generated and the specified uniform variable will remain
        /// unchanged. 
        /// If <paramref name="location"/> is a value other than
        /// -1 and it does not represent a valid uniform variable location
        /// in the current program object, an error will be generated, and
        /// no changes will be made to the uniform variable storage of the
        /// current program object. If <paramref name="location"/> is
        /// equal to -1, the data passed in will be silently ignored and the
        /// specified uniform variable will not be changed.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if there
        /// is no current program object. 
        /// <code>GL_INVALID_OPERATION</code> is generated if the
        /// size of the uniform variable declared in the shader does not
        /// match the size indicated by the <see cref="glUniform"/>
        /// command. 
        /// <code>GL_INVALID_OPERATION</code> is generated if one of
        /// the integer variants of this function is used to load a uniform
        /// variable of type float, vec2, vec3, vec4, or an array of these,
        /// or if one of the floating-point variants of this function is
        /// used to load a uniform variable of type int, ivec2, ivec3, or
        /// ivec4, or an array of these. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <paramref name="location"/> is an invalid uniform location
        /// for the current program object and
        /// <paramref name="location"/> is not equal to -1. 
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="count"/> is less than 0. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <paramref name="count"/> is greater than 1 and the indicated
        /// uniform variable is not an array variable. 
        /// <code>GL_INVALID_OPERATION</code> is generated if a
        /// sampler is loaded using a command other than
        /// <see cref="glUniform1i"/> and
        /// <see cref="glUniform1iv"/>. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <see cref="glUniform"/> is executed between the execution
        /// of
        /// <see cref="glBegin"/> 
        /// and the corresponding execution of
        /// <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glUniform1f(GLint location, GLfloat v0);</para>
        /// </summary>
        /// <param name="location">
        /// <para>
        /// Specifies the location of the uniform variable
        /// to be modified.
        /// </para>
        /// </param>
        /// <seealso cref="glLinkProgram"/>
        /// <seealso cref="glUseProgram"/>
        public static void glUniform1f(int location, float v0) {
            var _F = _GetProc<GLNativeDelegate.FNglUniform1f>("glUniform1f");
            _F(location, v0);
        }
        /// <summary>
        /// Specify the value of a uniform variable for the current program object
        /// <para>Require:</para> <para>GL_VERSION_2_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glUniform"/> is available only if the GL
        /// version is 2.0 or greater. 
        /// <see cref="glUniformMatrix{2x3|3x2|2x4|4x2|3x4|4x3}fv"/> 
        /// is available only if the GL version is 2.1 or greater. 
        /// <see cref="glUniform1i"/> and
        /// <see cref="glUniform1iv"/> are the only two functions
        /// that may be used to load uniform variables defined as sampler
        /// types. Loading samplers with any other function will result in a
        /// <code>GL_INVALID_OPERATION</code> error. 
        /// If <paramref name="count"/> is greater than 1 and the
        /// indicated uniform variable is not an array, a
        /// <code>GL_INVALID_OPERATION</code> error is generated and the
        /// specified uniform variable will remain unchanged. 
        /// Other than the preceding exceptions, if the type and size
        /// of the uniform variable as defined in the shader do not match
        /// the type and size specified in the name of the command used to
        /// load its value, a <code>GL_INVALID_OPERATION</code> error will
        /// be generated and the specified uniform variable will remain
        /// unchanged. 
        /// If <paramref name="location"/> is a value other than
        /// -1 and it does not represent a valid uniform variable location
        /// in the current program object, an error will be generated, and
        /// no changes will be made to the uniform variable storage of the
        /// current program object. If <paramref name="location"/> is
        /// equal to -1, the data passed in will be silently ignored and the
        /// specified uniform variable will not be changed.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if there
        /// is no current program object. 
        /// <code>GL_INVALID_OPERATION</code> is generated if the
        /// size of the uniform variable declared in the shader does not
        /// match the size indicated by the <see cref="glUniform"/>
        /// command. 
        /// <code>GL_INVALID_OPERATION</code> is generated if one of
        /// the integer variants of this function is used to load a uniform
        /// variable of type float, vec2, vec3, vec4, or an array of these,
        /// or if one of the floating-point variants of this function is
        /// used to load a uniform variable of type int, ivec2, ivec3, or
        /// ivec4, or an array of these. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <paramref name="location"/> is an invalid uniform location
        /// for the current program object and
        /// <paramref name="location"/> is not equal to -1. 
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="count"/> is less than 0. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <paramref name="count"/> is greater than 1 and the indicated
        /// uniform variable is not an array variable. 
        /// <code>GL_INVALID_OPERATION</code> is generated if a
        /// sampler is loaded using a command other than
        /// <see cref="glUniform1i"/> and
        /// <see cref="glUniform1iv"/>. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <see cref="glUniform"/> is executed between the execution
        /// of
        /// <see cref="glBegin"/> 
        /// and the corresponding execution of
        /// <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glUniform2f(GLint location, GLfloat v0, GLfloat v1);</para>
        /// </summary>
        /// <param name="location">
        /// <para>
        /// Specifies the location of the uniform variable
        /// to be modified.
        /// </para>
        /// </param>
        /// <seealso cref="glLinkProgram"/>
        /// <seealso cref="glUseProgram"/>
        public static void glUniform2f(int location, float v0, float v1) {
            var _F = _GetProc<GLNativeDelegate.FNglUniform2f>("glUniform2f");
            _F(location, v0, v1);
        }
        /// <summary>
        /// Specify the value of a uniform variable for the current program object
        /// <para>Require:</para> <para>GL_VERSION_2_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glUniform"/> is available only if the GL
        /// version is 2.0 or greater. 
        /// <see cref="glUniformMatrix{2x3|3x2|2x4|4x2|3x4|4x3}fv"/> 
        /// is available only if the GL version is 2.1 or greater. 
        /// <see cref="glUniform1i"/> and
        /// <see cref="glUniform1iv"/> are the only two functions
        /// that may be used to load uniform variables defined as sampler
        /// types. Loading samplers with any other function will result in a
        /// <code>GL_INVALID_OPERATION</code> error. 
        /// If <paramref name="count"/> is greater than 1 and the
        /// indicated uniform variable is not an array, a
        /// <code>GL_INVALID_OPERATION</code> error is generated and the
        /// specified uniform variable will remain unchanged. 
        /// Other than the preceding exceptions, if the type and size
        /// of the uniform variable as defined in the shader do not match
        /// the type and size specified in the name of the command used to
        /// load its value, a <code>GL_INVALID_OPERATION</code> error will
        /// be generated and the specified uniform variable will remain
        /// unchanged. 
        /// If <paramref name="location"/> is a value other than
        /// -1 and it does not represent a valid uniform variable location
        /// in the current program object, an error will be generated, and
        /// no changes will be made to the uniform variable storage of the
        /// current program object. If <paramref name="location"/> is
        /// equal to -1, the data passed in will be silently ignored and the
        /// specified uniform variable will not be changed.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if there
        /// is no current program object. 
        /// <code>GL_INVALID_OPERATION</code> is generated if the
        /// size of the uniform variable declared in the shader does not
        /// match the size indicated by the <see cref="glUniform"/>
        /// command. 
        /// <code>GL_INVALID_OPERATION</code> is generated if one of
        /// the integer variants of this function is used to load a uniform
        /// variable of type float, vec2, vec3, vec4, or an array of these,
        /// or if one of the floating-point variants of this function is
        /// used to load a uniform variable of type int, ivec2, ivec3, or
        /// ivec4, or an array of these. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <paramref name="location"/> is an invalid uniform location
        /// for the current program object and
        /// <paramref name="location"/> is not equal to -1. 
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="count"/> is less than 0. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <paramref name="count"/> is greater than 1 and the indicated
        /// uniform variable is not an array variable. 
        /// <code>GL_INVALID_OPERATION</code> is generated if a
        /// sampler is loaded using a command other than
        /// <see cref="glUniform1i"/> and
        /// <see cref="glUniform1iv"/>. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <see cref="glUniform"/> is executed between the execution
        /// of
        /// <see cref="glBegin"/> 
        /// and the corresponding execution of
        /// <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glUniform3f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2);</para>
        /// </summary>
        /// <param name="location">
        /// <para>
        /// Specifies the location of the uniform variable
        /// to be modified.
        /// </para>
        /// </param>
        /// <seealso cref="glLinkProgram"/>
        /// <seealso cref="glUseProgram"/>
        public static void glUniform3f(int location, float v0, float v1, float v2) {
            var _F = _GetProc<GLNativeDelegate.FNglUniform3f>("glUniform3f");
            _F(location, v0, v1, v2);
        }
        /// <summary>
        /// Specify the value of a uniform variable for the current program object
        /// <para>Require:</para> <para>GL_VERSION_2_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glUniform"/> is available only if the GL
        /// version is 2.0 or greater. 
        /// <see cref="glUniformMatrix{2x3|3x2|2x4|4x2|3x4|4x3}fv"/> 
        /// is available only if the GL version is 2.1 or greater. 
        /// <see cref="glUniform1i"/> and
        /// <see cref="glUniform1iv"/> are the only two functions
        /// that may be used to load uniform variables defined as sampler
        /// types. Loading samplers with any other function will result in a
        /// <code>GL_INVALID_OPERATION</code> error. 
        /// If <paramref name="count"/> is greater than 1 and the
        /// indicated uniform variable is not an array, a
        /// <code>GL_INVALID_OPERATION</code> error is generated and the
        /// specified uniform variable will remain unchanged. 
        /// Other than the preceding exceptions, if the type and size
        /// of the uniform variable as defined in the shader do not match
        /// the type and size specified in the name of the command used to
        /// load its value, a <code>GL_INVALID_OPERATION</code> error will
        /// be generated and the specified uniform variable will remain
        /// unchanged. 
        /// If <paramref name="location"/> is a value other than
        /// -1 and it does not represent a valid uniform variable location
        /// in the current program object, an error will be generated, and
        /// no changes will be made to the uniform variable storage of the
        /// current program object. If <paramref name="location"/> is
        /// equal to -1, the data passed in will be silently ignored and the
        /// specified uniform variable will not be changed.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if there
        /// is no current program object. 
        /// <code>GL_INVALID_OPERATION</code> is generated if the
        /// size of the uniform variable declared in the shader does not
        /// match the size indicated by the <see cref="glUniform"/>
        /// command. 
        /// <code>GL_INVALID_OPERATION</code> is generated if one of
        /// the integer variants of this function is used to load a uniform
        /// variable of type float, vec2, vec3, vec4, or an array of these,
        /// or if one of the floating-point variants of this function is
        /// used to load a uniform variable of type int, ivec2, ivec3, or
        /// ivec4, or an array of these. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <paramref name="location"/> is an invalid uniform location
        /// for the current program object and
        /// <paramref name="location"/> is not equal to -1. 
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="count"/> is less than 0. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <paramref name="count"/> is greater than 1 and the indicated
        /// uniform variable is not an array variable. 
        /// <code>GL_INVALID_OPERATION</code> is generated if a
        /// sampler is loaded using a command other than
        /// <see cref="glUniform1i"/> and
        /// <see cref="glUniform1iv"/>. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <see cref="glUniform"/> is executed between the execution
        /// of
        /// <see cref="glBegin"/> 
        /// and the corresponding execution of
        /// <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glUniform4f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3);</para>
        /// </summary>
        /// <param name="location">
        /// <para>
        /// Specifies the location of the uniform variable
        /// to be modified.
        /// </para>
        /// </param>
        /// <seealso cref="glLinkProgram"/>
        /// <seealso cref="glUseProgram"/>
        public static void glUniform4f(int location, float v0, float v1, float v2, float v3) {
            var _F = _GetProc<GLNativeDelegate.FNglUniform4f>("glUniform4f");
            _F(location, v0, v1, v2, v3);
        }
        /// <summary>
        /// Specify the value of a uniform variable for the current program object
        /// <para>Require:</para> <para>GL_VERSION_2_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glUniform"/> is available only if the GL
        /// version is 2.0 or greater. 
        /// <see cref="glUniformMatrix{2x3|3x2|2x4|4x2|3x4|4x3}fv"/> 
        /// is available only if the GL version is 2.1 or greater. 
        /// <see cref="glUniform1i"/> and
        /// <see cref="glUniform1iv"/> are the only two functions
        /// that may be used to load uniform variables defined as sampler
        /// types. Loading samplers with any other function will result in a
        /// <code>GL_INVALID_OPERATION</code> error. 
        /// If <paramref name="count"/> is greater than 1 and the
        /// indicated uniform variable is not an array, a
        /// <code>GL_INVALID_OPERATION</code> error is generated and the
        /// specified uniform variable will remain unchanged. 
        /// Other than the preceding exceptions, if the type and size
        /// of the uniform variable as defined in the shader do not match
        /// the type and size specified in the name of the command used to
        /// load its value, a <code>GL_INVALID_OPERATION</code> error will
        /// be generated and the specified uniform variable will remain
        /// unchanged. 
        /// If <paramref name="location"/> is a value other than
        /// -1 and it does not represent a valid uniform variable location
        /// in the current program object, an error will be generated, and
        /// no changes will be made to the uniform variable storage of the
        /// current program object. If <paramref name="location"/> is
        /// equal to -1, the data passed in will be silently ignored and the
        /// specified uniform variable will not be changed.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if there
        /// is no current program object. 
        /// <code>GL_INVALID_OPERATION</code> is generated if the
        /// size of the uniform variable declared in the shader does not
        /// match the size indicated by the <see cref="glUniform"/>
        /// command. 
        /// <code>GL_INVALID_OPERATION</code> is generated if one of
        /// the integer variants of this function is used to load a uniform
        /// variable of type float, vec2, vec3, vec4, or an array of these,
        /// or if one of the floating-point variants of this function is
        /// used to load a uniform variable of type int, ivec2, ivec3, or
        /// ivec4, or an array of these. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <paramref name="location"/> is an invalid uniform location
        /// for the current program object and
        /// <paramref name="location"/> is not equal to -1. 
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="count"/> is less than 0. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <paramref name="count"/> is greater than 1 and the indicated
        /// uniform variable is not an array variable. 
        /// <code>GL_INVALID_OPERATION</code> is generated if a
        /// sampler is loaded using a command other than
        /// <see cref="glUniform1i"/> and
        /// <see cref="glUniform1iv"/>. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <see cref="glUniform"/> is executed between the execution
        /// of
        /// <see cref="glBegin"/> 
        /// and the corresponding execution of
        /// <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glUniform1i(GLint location, GLint v0);</para>
        /// </summary>
        /// <param name="location">
        /// <para>
        /// Specifies the location of the uniform variable
        /// to be modified.
        /// </para>
        /// </param>
        /// <seealso cref="glLinkProgram"/>
        /// <seealso cref="glUseProgram"/>
        public static void glUniform1i(int location, int v0) {
            var _F = _GetProc<GLNativeDelegate.FNglUniform1i>("glUniform1i");
            _F(location, v0);
        }
        /// <summary>
        /// Specify the value of a uniform variable for the current program object
        /// <para>Require:</para> <para>GL_VERSION_2_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glUniform"/> is available only if the GL
        /// version is 2.0 or greater. 
        /// <see cref="glUniformMatrix{2x3|3x2|2x4|4x2|3x4|4x3}fv"/> 
        /// is available only if the GL version is 2.1 or greater. 
        /// <see cref="glUniform1i"/> and
        /// <see cref="glUniform1iv"/> are the only two functions
        /// that may be used to load uniform variables defined as sampler
        /// types. Loading samplers with any other function will result in a
        /// <code>GL_INVALID_OPERATION</code> error. 
        /// If <paramref name="count"/> is greater than 1 and the
        /// indicated uniform variable is not an array, a
        /// <code>GL_INVALID_OPERATION</code> error is generated and the
        /// specified uniform variable will remain unchanged. 
        /// Other than the preceding exceptions, if the type and size
        /// of the uniform variable as defined in the shader do not match
        /// the type and size specified in the name of the command used to
        /// load its value, a <code>GL_INVALID_OPERATION</code> error will
        /// be generated and the specified uniform variable will remain
        /// unchanged. 
        /// If <paramref name="location"/> is a value other than
        /// -1 and it does not represent a valid uniform variable location
        /// in the current program object, an error will be generated, and
        /// no changes will be made to the uniform variable storage of the
        /// current program object. If <paramref name="location"/> is
        /// equal to -1, the data passed in will be silently ignored and the
        /// specified uniform variable will not be changed.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if there
        /// is no current program object. 
        /// <code>GL_INVALID_OPERATION</code> is generated if the
        /// size of the uniform variable declared in the shader does not
        /// match the size indicated by the <see cref="glUniform"/>
        /// command. 
        /// <code>GL_INVALID_OPERATION</code> is generated if one of
        /// the integer variants of this function is used to load a uniform
        /// variable of type float, vec2, vec3, vec4, or an array of these,
        /// or if one of the floating-point variants of this function is
        /// used to load a uniform variable of type int, ivec2, ivec3, or
        /// ivec4, or an array of these. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <paramref name="location"/> is an invalid uniform location
        /// for the current program object and
        /// <paramref name="location"/> is not equal to -1. 
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="count"/> is less than 0. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <paramref name="count"/> is greater than 1 and the indicated
        /// uniform variable is not an array variable. 
        /// <code>GL_INVALID_OPERATION</code> is generated if a
        /// sampler is loaded using a command other than
        /// <see cref="glUniform1i"/> and
        /// <see cref="glUniform1iv"/>. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <see cref="glUniform"/> is executed between the execution
        /// of
        /// <see cref="glBegin"/> 
        /// and the corresponding execution of
        /// <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glUniform2i(GLint location, GLint v0, GLint v1);</para>
        /// </summary>
        /// <param name="location">
        /// <para>
        /// Specifies the location of the uniform variable
        /// to be modified.
        /// </para>
        /// </param>
        /// <seealso cref="glLinkProgram"/>
        /// <seealso cref="glUseProgram"/>
        public static void glUniform2i(int location, int v0, int v1) {
            var _F = _GetProc<GLNativeDelegate.FNglUniform2i>("glUniform2i");
            _F(location, v0, v1);
        }
        /// <summary>
        /// Specify the value of a uniform variable for the current program object
        /// <para>Require:</para> <para>GL_VERSION_2_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glUniform"/> is available only if the GL
        /// version is 2.0 or greater. 
        /// <see cref="glUniformMatrix{2x3|3x2|2x4|4x2|3x4|4x3}fv"/> 
        /// is available only if the GL version is 2.1 or greater. 
        /// <see cref="glUniform1i"/> and
        /// <see cref="glUniform1iv"/> are the only two functions
        /// that may be used to load uniform variables defined as sampler
        /// types. Loading samplers with any other function will result in a
        /// <code>GL_INVALID_OPERATION</code> error. 
        /// If <paramref name="count"/> is greater than 1 and the
        /// indicated uniform variable is not an array, a
        /// <code>GL_INVALID_OPERATION</code> error is generated and the
        /// specified uniform variable will remain unchanged. 
        /// Other than the preceding exceptions, if the type and size
        /// of the uniform variable as defined in the shader do not match
        /// the type and size specified in the name of the command used to
        /// load its value, a <code>GL_INVALID_OPERATION</code> error will
        /// be generated and the specified uniform variable will remain
        /// unchanged. 
        /// If <paramref name="location"/> is a value other than
        /// -1 and it does not represent a valid uniform variable location
        /// in the current program object, an error will be generated, and
        /// no changes will be made to the uniform variable storage of the
        /// current program object. If <paramref name="location"/> is
        /// equal to -1, the data passed in will be silently ignored and the
        /// specified uniform variable will not be changed.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if there
        /// is no current program object. 
        /// <code>GL_INVALID_OPERATION</code> is generated if the
        /// size of the uniform variable declared in the shader does not
        /// match the size indicated by the <see cref="glUniform"/>
        /// command. 
        /// <code>GL_INVALID_OPERATION</code> is generated if one of
        /// the integer variants of this function is used to load a uniform
        /// variable of type float, vec2, vec3, vec4, or an array of these,
        /// or if one of the floating-point variants of this function is
        /// used to load a uniform variable of type int, ivec2, ivec3, or
        /// ivec4, or an array of these. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <paramref name="location"/> is an invalid uniform location
        /// for the current program object and
        /// <paramref name="location"/> is not equal to -1. 
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="count"/> is less than 0. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <paramref name="count"/> is greater than 1 and the indicated
        /// uniform variable is not an array variable. 
        /// <code>GL_INVALID_OPERATION</code> is generated if a
        /// sampler is loaded using a command other than
        /// <see cref="glUniform1i"/> and
        /// <see cref="glUniform1iv"/>. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <see cref="glUniform"/> is executed between the execution
        /// of
        /// <see cref="glBegin"/> 
        /// and the corresponding execution of
        /// <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glUniform3i(GLint location, GLint v0, GLint v1, GLint v2);</para>
        /// </summary>
        /// <param name="location">
        /// <para>
        /// Specifies the location of the uniform variable
        /// to be modified.
        /// </para>
        /// </param>
        /// <seealso cref="glLinkProgram"/>
        /// <seealso cref="glUseProgram"/>
        public static void glUniform3i(int location, int v0, int v1, int v2) {
            var _F = _GetProc<GLNativeDelegate.FNglUniform3i>("glUniform3i");
            _F(location, v0, v1, v2);
        }
        /// <summary>
        /// Specify the value of a uniform variable for the current program object
        /// <para>Require:</para> <para>GL_VERSION_2_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glUniform"/> is available only if the GL
        /// version is 2.0 or greater. 
        /// <see cref="glUniformMatrix{2x3|3x2|2x4|4x2|3x4|4x3}fv"/> 
        /// is available only if the GL version is 2.1 or greater. 
        /// <see cref="glUniform1i"/> and
        /// <see cref="glUniform1iv"/> are the only two functions
        /// that may be used to load uniform variables defined as sampler
        /// types. Loading samplers with any other function will result in a
        /// <code>GL_INVALID_OPERATION</code> error. 
        /// If <paramref name="count"/> is greater than 1 and the
        /// indicated uniform variable is not an array, a
        /// <code>GL_INVALID_OPERATION</code> error is generated and the
        /// specified uniform variable will remain unchanged. 
        /// Other than the preceding exceptions, if the type and size
        /// of the uniform variable as defined in the shader do not match
        /// the type and size specified in the name of the command used to
        /// load its value, a <code>GL_INVALID_OPERATION</code> error will
        /// be generated and the specified uniform variable will remain
        /// unchanged. 
        /// If <paramref name="location"/> is a value other than
        /// -1 and it does not represent a valid uniform variable location
        /// in the current program object, an error will be generated, and
        /// no changes will be made to the uniform variable storage of the
        /// current program object. If <paramref name="location"/> is
        /// equal to -1, the data passed in will be silently ignored and the
        /// specified uniform variable will not be changed.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if there
        /// is no current program object. 
        /// <code>GL_INVALID_OPERATION</code> is generated if the
        /// size of the uniform variable declared in the shader does not
        /// match the size indicated by the <see cref="glUniform"/>
        /// command. 
        /// <code>GL_INVALID_OPERATION</code> is generated if one of
        /// the integer variants of this function is used to load a uniform
        /// variable of type float, vec2, vec3, vec4, or an array of these,
        /// or if one of the floating-point variants of this function is
        /// used to load a uniform variable of type int, ivec2, ivec3, or
        /// ivec4, or an array of these. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <paramref name="location"/> is an invalid uniform location
        /// for the current program object and
        /// <paramref name="location"/> is not equal to -1. 
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="count"/> is less than 0. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <paramref name="count"/> is greater than 1 and the indicated
        /// uniform variable is not an array variable. 
        /// <code>GL_INVALID_OPERATION</code> is generated if a
        /// sampler is loaded using a command other than
        /// <see cref="glUniform1i"/> and
        /// <see cref="glUniform1iv"/>. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <see cref="glUniform"/> is executed between the execution
        /// of
        /// <see cref="glBegin"/> 
        /// and the corresponding execution of
        /// <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glUniform4i(GLint location, GLint v0, GLint v1, GLint v2, GLint v3);</para>
        /// </summary>
        /// <param name="location">
        /// <para>
        /// Specifies the location of the uniform variable
        /// to be modified.
        /// </para>
        /// </param>
        /// <seealso cref="glLinkProgram"/>
        /// <seealso cref="glUseProgram"/>
        public static void glUniform4i(int location, int v0, int v1, int v2, int v3) {
            var _F = _GetProc<GLNativeDelegate.FNglUniform4i>("glUniform4i");
            _F(location, v0, v1, v2, v3);
        }
        /// <summary>
        /// Specify the value of a uniform variable for the current program object
        /// <para>Require:</para> <para>GL_VERSION_2_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glUniform"/> is available only if the GL
        /// version is 2.0 or greater. 
        /// <see cref="glUniformMatrix{2x3|3x2|2x4|4x2|3x4|4x3}fv"/> 
        /// is available only if the GL version is 2.1 or greater. 
        /// <see cref="glUniform1i"/> and
        /// <see cref="glUniform1iv"/> are the only two functions
        /// that may be used to load uniform variables defined as sampler
        /// types. Loading samplers with any other function will result in a
        /// <code>GL_INVALID_OPERATION</code> error. 
        /// If <paramref name="count"/> is greater than 1 and the
        /// indicated uniform variable is not an array, a
        /// <code>GL_INVALID_OPERATION</code> error is generated and the
        /// specified uniform variable will remain unchanged. 
        /// Other than the preceding exceptions, if the type and size
        /// of the uniform variable as defined in the shader do not match
        /// the type and size specified in the name of the command used to
        /// load its value, a <code>GL_INVALID_OPERATION</code> error will
        /// be generated and the specified uniform variable will remain
        /// unchanged. 
        /// If <paramref name="location"/> is a value other than
        /// -1 and it does not represent a valid uniform variable location
        /// in the current program object, an error will be generated, and
        /// no changes will be made to the uniform variable storage of the
        /// current program object. If <paramref name="location"/> is
        /// equal to -1, the data passed in will be silently ignored and the
        /// specified uniform variable will not be changed.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if there
        /// is no current program object. 
        /// <code>GL_INVALID_OPERATION</code> is generated if the
        /// size of the uniform variable declared in the shader does not
        /// match the size indicated by the <see cref="glUniform"/>
        /// command. 
        /// <code>GL_INVALID_OPERATION</code> is generated if one of
        /// the integer variants of this function is used to load a uniform
        /// variable of type float, vec2, vec3, vec4, or an array of these,
        /// or if one of the floating-point variants of this function is
        /// used to load a uniform variable of type int, ivec2, ivec3, or
        /// ivec4, or an array of these. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <paramref name="location"/> is an invalid uniform location
        /// for the current program object and
        /// <paramref name="location"/> is not equal to -1. 
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="count"/> is less than 0. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <paramref name="count"/> is greater than 1 and the indicated
        /// uniform variable is not an array variable. 
        /// <code>GL_INVALID_OPERATION</code> is generated if a
        /// sampler is loaded using a command other than
        /// <see cref="glUniform1i"/> and
        /// <see cref="glUniform1iv"/>. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <see cref="glUniform"/> is executed between the execution
        /// of
        /// <see cref="glBegin"/> 
        /// and the corresponding execution of
        /// <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glUniform1fv(GLint location, GLsizei count, const GLfloat * value);</para>
        /// </summary>
        /// <param name="location">
        /// <para>
        /// Specifies the location of the uniform value to
        /// be modified.
        /// </para>
        /// </param>
        /// <param name="count">
        /// <para>
        /// Specifies the number of elements that are to
        /// be modified. This should be 1 if the targeted
        /// uniform variable is not an array, and 1 or more if it is
        /// an array.
        /// </para>
        /// </param>
        /// <param name="value">
        /// <para>
        /// Specifies a pointer to an array of
        /// <paramref name="count"/> values that will be
        /// used to update the specified uniform
        /// variable.
        /// </para>
        /// </param>
        /// <seealso cref="glLinkProgram"/>
        /// <seealso cref="glUseProgram"/>
        public unsafe static void glUniform1fv(int location, int count, float* value) {
            var _F = _GetProc<GLNativeDelegate.FNglUniform1fv>("glUniform1fv");
            _F(location, count, value);
        }
        /// <summary>
        /// Specify the value of a uniform variable for the current program object
        /// <para>Require:</para> <para>GL_VERSION_2_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glUniform"/> is available only if the GL
        /// version is 2.0 or greater. 
        /// <see cref="glUniformMatrix{2x3|3x2|2x4|4x2|3x4|4x3}fv"/> 
        /// is available only if the GL version is 2.1 or greater. 
        /// <see cref="glUniform1i"/> and
        /// <see cref="glUniform1iv"/> are the only two functions
        /// that may be used to load uniform variables defined as sampler
        /// types. Loading samplers with any other function will result in a
        /// <code>GL_INVALID_OPERATION</code> error. 
        /// If <paramref name="count"/> is greater than 1 and the
        /// indicated uniform variable is not an array, a
        /// <code>GL_INVALID_OPERATION</code> error is generated and the
        /// specified uniform variable will remain unchanged. 
        /// Other than the preceding exceptions, if the type and size
        /// of the uniform variable as defined in the shader do not match
        /// the type and size specified in the name of the command used to
        /// load its value, a <code>GL_INVALID_OPERATION</code> error will
        /// be generated and the specified uniform variable will remain
        /// unchanged. 
        /// If <paramref name="location"/> is a value other than
        /// -1 and it does not represent a valid uniform variable location
        /// in the current program object, an error will be generated, and
        /// no changes will be made to the uniform variable storage of the
        /// current program object. If <paramref name="location"/> is
        /// equal to -1, the data passed in will be silently ignored and the
        /// specified uniform variable will not be changed.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if there
        /// is no current program object. 
        /// <code>GL_INVALID_OPERATION</code> is generated if the
        /// size of the uniform variable declared in the shader does not
        /// match the size indicated by the <see cref="glUniform"/>
        /// command. 
        /// <code>GL_INVALID_OPERATION</code> is generated if one of
        /// the integer variants of this function is used to load a uniform
        /// variable of type float, vec2, vec3, vec4, or an array of these,
        /// or if one of the floating-point variants of this function is
        /// used to load a uniform variable of type int, ivec2, ivec3, or
        /// ivec4, or an array of these. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <paramref name="location"/> is an invalid uniform location
        /// for the current program object and
        /// <paramref name="location"/> is not equal to -1. 
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="count"/> is less than 0. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <paramref name="count"/> is greater than 1 and the indicated
        /// uniform variable is not an array variable. 
        /// <code>GL_INVALID_OPERATION</code> is generated if a
        /// sampler is loaded using a command other than
        /// <see cref="glUniform1i"/> and
        /// <see cref="glUniform1iv"/>. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <see cref="glUniform"/> is executed between the execution
        /// of
        /// <see cref="glBegin"/> 
        /// and the corresponding execution of
        /// <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glUniform2fv(GLint location, GLsizei count, const GLfloat * value);</para>
        /// </summary>
        /// <param name="location">
        /// <para>
        /// Specifies the location of the uniform value to
        /// be modified.
        /// </para>
        /// </param>
        /// <param name="count">
        /// <para>
        /// Specifies the number of elements that are to
        /// be modified. This should be 1 if the targeted
        /// uniform variable is not an array, and 1 or more if it is
        /// an array.
        /// </para>
        /// </param>
        /// <param name="value">
        /// <para>
        /// Specifies a pointer to an array of
        /// <paramref name="count"/> values that will be
        /// used to update the specified uniform
        /// variable.
        /// </para>
        /// </param>
        /// <seealso cref="glLinkProgram"/>
        /// <seealso cref="glUseProgram"/>
        public unsafe static void glUniform2fv(int location, int count, float* value) {
            var _F = _GetProc<GLNativeDelegate.FNglUniform2fv>("glUniform2fv");
            _F(location, count, value);
        }
        /// <summary>
        /// Specify the value of a uniform variable for the current program object
        /// <para>Require:</para> <para>GL_VERSION_2_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glUniform"/> is available only if the GL
        /// version is 2.0 or greater. 
        /// <see cref="glUniformMatrix{2x3|3x2|2x4|4x2|3x4|4x3}fv"/> 
        /// is available only if the GL version is 2.1 or greater. 
        /// <see cref="glUniform1i"/> and
        /// <see cref="glUniform1iv"/> are the only two functions
        /// that may be used to load uniform variables defined as sampler
        /// types. Loading samplers with any other function will result in a
        /// <code>GL_INVALID_OPERATION</code> error. 
        /// If <paramref name="count"/> is greater than 1 and the
        /// indicated uniform variable is not an array, a
        /// <code>GL_INVALID_OPERATION</code> error is generated and the
        /// specified uniform variable will remain unchanged. 
        /// Other than the preceding exceptions, if the type and size
        /// of the uniform variable as defined in the shader do not match
        /// the type and size specified in the name of the command used to
        /// load its value, a <code>GL_INVALID_OPERATION</code> error will
        /// be generated and the specified uniform variable will remain
        /// unchanged. 
        /// If <paramref name="location"/> is a value other than
        /// -1 and it does not represent a valid uniform variable location
        /// in the current program object, an error will be generated, and
        /// no changes will be made to the uniform variable storage of the
        /// current program object. If <paramref name="location"/> is
        /// equal to -1, the data passed in will be silently ignored and the
        /// specified uniform variable will not be changed.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if there
        /// is no current program object. 
        /// <code>GL_INVALID_OPERATION</code> is generated if the
        /// size of the uniform variable declared in the shader does not
        /// match the size indicated by the <see cref="glUniform"/>
        /// command. 
        /// <code>GL_INVALID_OPERATION</code> is generated if one of
        /// the integer variants of this function is used to load a uniform
        /// variable of type float, vec2, vec3, vec4, or an array of these,
        /// or if one of the floating-point variants of this function is
        /// used to load a uniform variable of type int, ivec2, ivec3, or
        /// ivec4, or an array of these. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <paramref name="location"/> is an invalid uniform location
        /// for the current program object and
        /// <paramref name="location"/> is not equal to -1. 
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="count"/> is less than 0. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <paramref name="count"/> is greater than 1 and the indicated
        /// uniform variable is not an array variable. 
        /// <code>GL_INVALID_OPERATION</code> is generated if a
        /// sampler is loaded using a command other than
        /// <see cref="glUniform1i"/> and
        /// <see cref="glUniform1iv"/>. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <see cref="glUniform"/> is executed between the execution
        /// of
        /// <see cref="glBegin"/> 
        /// and the corresponding execution of
        /// <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glUniform3fv(GLint location, GLsizei count, const GLfloat * value);</para>
        /// </summary>
        /// <param name="location">
        /// <para>
        /// Specifies the location of the uniform value to
        /// be modified.
        /// </para>
        /// </param>
        /// <param name="count">
        /// <para>
        /// Specifies the number of elements that are to
        /// be modified. This should be 1 if the targeted
        /// uniform variable is not an array, and 1 or more if it is
        /// an array.
        /// </para>
        /// </param>
        /// <param name="value">
        /// <para>
        /// Specifies a pointer to an array of
        /// <paramref name="count"/> values that will be
        /// used to update the specified uniform
        /// variable.
        /// </para>
        /// </param>
        /// <seealso cref="glLinkProgram"/>
        /// <seealso cref="glUseProgram"/>
        public unsafe static void glUniform3fv(int location, int count, float* value) {
            var _F = _GetProc<GLNativeDelegate.FNglUniform3fv>("glUniform3fv");
            _F(location, count, value);
        }
        /// <summary>
        /// Specify the value of a uniform variable for the current program object
        /// <para>Require:</para> <para>GL_VERSION_2_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glUniform"/> is available only if the GL
        /// version is 2.0 or greater. 
        /// <see cref="glUniformMatrix{2x3|3x2|2x4|4x2|3x4|4x3}fv"/> 
        /// is available only if the GL version is 2.1 or greater. 
        /// <see cref="glUniform1i"/> and
        /// <see cref="glUniform1iv"/> are the only two functions
        /// that may be used to load uniform variables defined as sampler
        /// types. Loading samplers with any other function will result in a
        /// <code>GL_INVALID_OPERATION</code> error. 
        /// If <paramref name="count"/> is greater than 1 and the
        /// indicated uniform variable is not an array, a
        /// <code>GL_INVALID_OPERATION</code> error is generated and the
        /// specified uniform variable will remain unchanged. 
        /// Other than the preceding exceptions, if the type and size
        /// of the uniform variable as defined in the shader do not match
        /// the type and size specified in the name of the command used to
        /// load its value, a <code>GL_INVALID_OPERATION</code> error will
        /// be generated and the specified uniform variable will remain
        /// unchanged. 
        /// If <paramref name="location"/> is a value other than
        /// -1 and it does not represent a valid uniform variable location
        /// in the current program object, an error will be generated, and
        /// no changes will be made to the uniform variable storage of the
        /// current program object. If <paramref name="location"/> is
        /// equal to -1, the data passed in will be silently ignored and the
        /// specified uniform variable will not be changed.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if there
        /// is no current program object. 
        /// <code>GL_INVALID_OPERATION</code> is generated if the
        /// size of the uniform variable declared in the shader does not
        /// match the size indicated by the <see cref="glUniform"/>
        /// command. 
        /// <code>GL_INVALID_OPERATION</code> is generated if one of
        /// the integer variants of this function is used to load a uniform
        /// variable of type float, vec2, vec3, vec4, or an array of these,
        /// or if one of the floating-point variants of this function is
        /// used to load a uniform variable of type int, ivec2, ivec3, or
        /// ivec4, or an array of these. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <paramref name="location"/> is an invalid uniform location
        /// for the current program object and
        /// <paramref name="location"/> is not equal to -1. 
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="count"/> is less than 0. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <paramref name="count"/> is greater than 1 and the indicated
        /// uniform variable is not an array variable. 
        /// <code>GL_INVALID_OPERATION</code> is generated if a
        /// sampler is loaded using a command other than
        /// <see cref="glUniform1i"/> and
        /// <see cref="glUniform1iv"/>. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <see cref="glUniform"/> is executed between the execution
        /// of
        /// <see cref="glBegin"/> 
        /// and the corresponding execution of
        /// <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glUniform4fv(GLint location, GLsizei count, const GLfloat * value);</para>
        /// </summary>
        /// <param name="location">
        /// <para>
        /// Specifies the location of the uniform value to
        /// be modified.
        /// </para>
        /// </param>
        /// <param name="count">
        /// <para>
        /// Specifies the number of elements that are to
        /// be modified. This should be 1 if the targeted
        /// uniform variable is not an array, and 1 or more if it is
        /// an array.
        /// </para>
        /// </param>
        /// <param name="value">
        /// <para>
        /// Specifies a pointer to an array of
        /// <paramref name="count"/> values that will be
        /// used to update the specified uniform
        /// variable.
        /// </para>
        /// </param>
        /// <seealso cref="glLinkProgram"/>
        /// <seealso cref="glUseProgram"/>
        public unsafe static void glUniform4fv(int location, int count, float* value) {
            var _F = _GetProc<GLNativeDelegate.FNglUniform4fv>("glUniform4fv");
            _F(location, count, value);
        }
        /// <summary>
        /// Specify the value of a uniform variable for the current program object
        /// <para>Require:</para> <para>GL_VERSION_2_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glUniform"/> is available only if the GL
        /// version is 2.0 or greater. 
        /// <see cref="glUniformMatrix{2x3|3x2|2x4|4x2|3x4|4x3}fv"/> 
        /// is available only if the GL version is 2.1 or greater. 
        /// <see cref="glUniform1i"/> and
        /// <see cref="glUniform1iv"/> are the only two functions
        /// that may be used to load uniform variables defined as sampler
        /// types. Loading samplers with any other function will result in a
        /// <code>GL_INVALID_OPERATION</code> error. 
        /// If <paramref name="count"/> is greater than 1 and the
        /// indicated uniform variable is not an array, a
        /// <code>GL_INVALID_OPERATION</code> error is generated and the
        /// specified uniform variable will remain unchanged. 
        /// Other than the preceding exceptions, if the type and size
        /// of the uniform variable as defined in the shader do not match
        /// the type and size specified in the name of the command used to
        /// load its value, a <code>GL_INVALID_OPERATION</code> error will
        /// be generated and the specified uniform variable will remain
        /// unchanged. 
        /// If <paramref name="location"/> is a value other than
        /// -1 and it does not represent a valid uniform variable location
        /// in the current program object, an error will be generated, and
        /// no changes will be made to the uniform variable storage of the
        /// current program object. If <paramref name="location"/> is
        /// equal to -1, the data passed in will be silently ignored and the
        /// specified uniform variable will not be changed.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if there
        /// is no current program object. 
        /// <code>GL_INVALID_OPERATION</code> is generated if the
        /// size of the uniform variable declared in the shader does not
        /// match the size indicated by the <see cref="glUniform"/>
        /// command. 
        /// <code>GL_INVALID_OPERATION</code> is generated if one of
        /// the integer variants of this function is used to load a uniform
        /// variable of type float, vec2, vec3, vec4, or an array of these,
        /// or if one of the floating-point variants of this function is
        /// used to load a uniform variable of type int, ivec2, ivec3, or
        /// ivec4, or an array of these. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <paramref name="location"/> is an invalid uniform location
        /// for the current program object and
        /// <paramref name="location"/> is not equal to -1. 
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="count"/> is less than 0. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <paramref name="count"/> is greater than 1 and the indicated
        /// uniform variable is not an array variable. 
        /// <code>GL_INVALID_OPERATION</code> is generated if a
        /// sampler is loaded using a command other than
        /// <see cref="glUniform1i"/> and
        /// <see cref="glUniform1iv"/>. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <see cref="glUniform"/> is executed between the execution
        /// of
        /// <see cref="glBegin"/> 
        /// and the corresponding execution of
        /// <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glUniform1iv(GLint location, GLsizei count, const GLint * value);</para>
        /// </summary>
        /// <param name="location">
        /// <para>
        /// Specifies the location of the uniform value to
        /// be modified.
        /// </para>
        /// </param>
        /// <param name="count">
        /// <para>
        /// Specifies the number of elements that are to
        /// be modified. This should be 1 if the targeted
        /// uniform variable is not an array, and 1 or more if it is
        /// an array.
        /// </para>
        /// </param>
        /// <param name="value">
        /// <para>
        /// Specifies a pointer to an array of
        /// <paramref name="count"/> values that will be
        /// used to update the specified uniform
        /// variable.
        /// </para>
        /// </param>
        /// <seealso cref="glLinkProgram"/>
        /// <seealso cref="glUseProgram"/>
        public unsafe static void glUniform1iv(int location, int count, int* value) {
            var _F = _GetProc<GLNativeDelegate.FNglUniform1iv>("glUniform1iv");
            _F(location, count, value);
        }
        /// <summary>
        /// Specify the value of a uniform variable for the current program object
        /// <para>Require:</para> <para>GL_VERSION_2_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glUniform"/> is available only if the GL
        /// version is 2.0 or greater. 
        /// <see cref="glUniformMatrix{2x3|3x2|2x4|4x2|3x4|4x3}fv"/> 
        /// is available only if the GL version is 2.1 or greater. 
        /// <see cref="glUniform1i"/> and
        /// <see cref="glUniform1iv"/> are the only two functions
        /// that may be used to load uniform variables defined as sampler
        /// types. Loading samplers with any other function will result in a
        /// <code>GL_INVALID_OPERATION</code> error. 
        /// If <paramref name="count"/> is greater than 1 and the
        /// indicated uniform variable is not an array, a
        /// <code>GL_INVALID_OPERATION</code> error is generated and the
        /// specified uniform variable will remain unchanged. 
        /// Other than the preceding exceptions, if the type and size
        /// of the uniform variable as defined in the shader do not match
        /// the type and size specified in the name of the command used to
        /// load its value, a <code>GL_INVALID_OPERATION</code> error will
        /// be generated and the specified uniform variable will remain
        /// unchanged. 
        /// If <paramref name="location"/> is a value other than
        /// -1 and it does not represent a valid uniform variable location
        /// in the current program object, an error will be generated, and
        /// no changes will be made to the uniform variable storage of the
        /// current program object. If <paramref name="location"/> is
        /// equal to -1, the data passed in will be silently ignored and the
        /// specified uniform variable will not be changed.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if there
        /// is no current program object. 
        /// <code>GL_INVALID_OPERATION</code> is generated if the
        /// size of the uniform variable declared in the shader does not
        /// match the size indicated by the <see cref="glUniform"/>
        /// command. 
        /// <code>GL_INVALID_OPERATION</code> is generated if one of
        /// the integer variants of this function is used to load a uniform
        /// variable of type float, vec2, vec3, vec4, or an array of these,
        /// or if one of the floating-point variants of this function is
        /// used to load a uniform variable of type int, ivec2, ivec3, or
        /// ivec4, or an array of these. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <paramref name="location"/> is an invalid uniform location
        /// for the current program object and
        /// <paramref name="location"/> is not equal to -1. 
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="count"/> is less than 0. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <paramref name="count"/> is greater than 1 and the indicated
        /// uniform variable is not an array variable. 
        /// <code>GL_INVALID_OPERATION</code> is generated if a
        /// sampler is loaded using a command other than
        /// <see cref="glUniform1i"/> and
        /// <see cref="glUniform1iv"/>. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <see cref="glUniform"/> is executed between the execution
        /// of
        /// <see cref="glBegin"/> 
        /// and the corresponding execution of
        /// <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glUniform2iv(GLint location, GLsizei count, const GLint * value);</para>
        /// </summary>
        /// <param name="location">
        /// <para>
        /// Specifies the location of the uniform value to
        /// be modified.
        /// </para>
        /// </param>
        /// <param name="count">
        /// <para>
        /// Specifies the number of elements that are to
        /// be modified. This should be 1 if the targeted
        /// uniform variable is not an array, and 1 or more if it is
        /// an array.
        /// </para>
        /// </param>
        /// <param name="value">
        /// <para>
        /// Specifies a pointer to an array of
        /// <paramref name="count"/> values that will be
        /// used to update the specified uniform
        /// variable.
        /// </para>
        /// </param>
        /// <seealso cref="glLinkProgram"/>
        /// <seealso cref="glUseProgram"/>
        public unsafe static void glUniform2iv(int location, int count, int* value) {
            var _F = _GetProc<GLNativeDelegate.FNglUniform2iv>("glUniform2iv");
            _F(location, count, value);
        }
        /// <summary>
        /// Specify the value of a uniform variable for the current program object
        /// <para>Require:</para> <para>GL_VERSION_2_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glUniform"/> is available only if the GL
        /// version is 2.0 or greater. 
        /// <see cref="glUniformMatrix{2x3|3x2|2x4|4x2|3x4|4x3}fv"/> 
        /// is available only if the GL version is 2.1 or greater. 
        /// <see cref="glUniform1i"/> and
        /// <see cref="glUniform1iv"/> are the only two functions
        /// that may be used to load uniform variables defined as sampler
        /// types. Loading samplers with any other function will result in a
        /// <code>GL_INVALID_OPERATION</code> error. 
        /// If <paramref name="count"/> is greater than 1 and the
        /// indicated uniform variable is not an array, a
        /// <code>GL_INVALID_OPERATION</code> error is generated and the
        /// specified uniform variable will remain unchanged. 
        /// Other than the preceding exceptions, if the type and size
        /// of the uniform variable as defined in the shader do not match
        /// the type and size specified in the name of the command used to
        /// load its value, a <code>GL_INVALID_OPERATION</code> error will
        /// be generated and the specified uniform variable will remain
        /// unchanged. 
        /// If <paramref name="location"/> is a value other than
        /// -1 and it does not represent a valid uniform variable location
        /// in the current program object, an error will be generated, and
        /// no changes will be made to the uniform variable storage of the
        /// current program object. If <paramref name="location"/> is
        /// equal to -1, the data passed in will be silently ignored and the
        /// specified uniform variable will not be changed.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if there
        /// is no current program object. 
        /// <code>GL_INVALID_OPERATION</code> is generated if the
        /// size of the uniform variable declared in the shader does not
        /// match the size indicated by the <see cref="glUniform"/>
        /// command. 
        /// <code>GL_INVALID_OPERATION</code> is generated if one of
        /// the integer variants of this function is used to load a uniform
        /// variable of type float, vec2, vec3, vec4, or an array of these,
        /// or if one of the floating-point variants of this function is
        /// used to load a uniform variable of type int, ivec2, ivec3, or
        /// ivec4, or an array of these. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <paramref name="location"/> is an invalid uniform location
        /// for the current program object and
        /// <paramref name="location"/> is not equal to -1. 
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="count"/> is less than 0. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <paramref name="count"/> is greater than 1 and the indicated
        /// uniform variable is not an array variable. 
        /// <code>GL_INVALID_OPERATION</code> is generated if a
        /// sampler is loaded using a command other than
        /// <see cref="glUniform1i"/> and
        /// <see cref="glUniform1iv"/>. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <see cref="glUniform"/> is executed between the execution
        /// of
        /// <see cref="glBegin"/> 
        /// and the corresponding execution of
        /// <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glUniform3iv(GLint location, GLsizei count, const GLint * value);</para>
        /// </summary>
        /// <param name="location">
        /// <para>
        /// Specifies the location of the uniform value to
        /// be modified.
        /// </para>
        /// </param>
        /// <param name="count">
        /// <para>
        /// Specifies the number of elements that are to
        /// be modified. This should be 1 if the targeted
        /// uniform variable is not an array, and 1 or more if it is
        /// an array.
        /// </para>
        /// </param>
        /// <param name="value">
        /// <para>
        /// Specifies a pointer to an array of
        /// <paramref name="count"/> values that will be
        /// used to update the specified uniform
        /// variable.
        /// </para>
        /// </param>
        /// <seealso cref="glLinkProgram"/>
        /// <seealso cref="glUseProgram"/>
        public unsafe static void glUniform3iv(int location, int count, int* value) {
            var _F = _GetProc<GLNativeDelegate.FNglUniform3iv>("glUniform3iv");
            _F(location, count, value);
        }
        /// <summary>
        /// Specify the value of a uniform variable for the current program object
        /// <para>Require:</para> <para>GL_VERSION_2_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glUniform"/> is available only if the GL
        /// version is 2.0 or greater. 
        /// <see cref="glUniformMatrix{2x3|3x2|2x4|4x2|3x4|4x3}fv"/> 
        /// is available only if the GL version is 2.1 or greater. 
        /// <see cref="glUniform1i"/> and
        /// <see cref="glUniform1iv"/> are the only two functions
        /// that may be used to load uniform variables defined as sampler
        /// types. Loading samplers with any other function will result in a
        /// <code>GL_INVALID_OPERATION</code> error. 
        /// If <paramref name="count"/> is greater than 1 and the
        /// indicated uniform variable is not an array, a
        /// <code>GL_INVALID_OPERATION</code> error is generated and the
        /// specified uniform variable will remain unchanged. 
        /// Other than the preceding exceptions, if the type and size
        /// of the uniform variable as defined in the shader do not match
        /// the type and size specified in the name of the command used to
        /// load its value, a <code>GL_INVALID_OPERATION</code> error will
        /// be generated and the specified uniform variable will remain
        /// unchanged. 
        /// If <paramref name="location"/> is a value other than
        /// -1 and it does not represent a valid uniform variable location
        /// in the current program object, an error will be generated, and
        /// no changes will be made to the uniform variable storage of the
        /// current program object. If <paramref name="location"/> is
        /// equal to -1, the data passed in will be silently ignored and the
        /// specified uniform variable will not be changed.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if there
        /// is no current program object. 
        /// <code>GL_INVALID_OPERATION</code> is generated if the
        /// size of the uniform variable declared in the shader does not
        /// match the size indicated by the <see cref="glUniform"/>
        /// command. 
        /// <code>GL_INVALID_OPERATION</code> is generated if one of
        /// the integer variants of this function is used to load a uniform
        /// variable of type float, vec2, vec3, vec4, or an array of these,
        /// or if one of the floating-point variants of this function is
        /// used to load a uniform variable of type int, ivec2, ivec3, or
        /// ivec4, or an array of these. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <paramref name="location"/> is an invalid uniform location
        /// for the current program object and
        /// <paramref name="location"/> is not equal to -1. 
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="count"/> is less than 0. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <paramref name="count"/> is greater than 1 and the indicated
        /// uniform variable is not an array variable. 
        /// <code>GL_INVALID_OPERATION</code> is generated if a
        /// sampler is loaded using a command other than
        /// <see cref="glUniform1i"/> and
        /// <see cref="glUniform1iv"/>. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <see cref="glUniform"/> is executed between the execution
        /// of
        /// <see cref="glBegin"/> 
        /// and the corresponding execution of
        /// <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glUniform4iv(GLint location, GLsizei count, const GLint * value);</para>
        /// </summary>
        /// <param name="location">
        /// <para>
        /// Specifies the location of the uniform value to
        /// be modified.
        /// </para>
        /// </param>
        /// <param name="count">
        /// <para>
        /// Specifies the number of elements that are to
        /// be modified. This should be 1 if the targeted
        /// uniform variable is not an array, and 1 or more if it is
        /// an array.
        /// </para>
        /// </param>
        /// <param name="value">
        /// <para>
        /// Specifies a pointer to an array of
        /// <paramref name="count"/> values that will be
        /// used to update the specified uniform
        /// variable.
        /// </para>
        /// </param>
        /// <seealso cref="glLinkProgram"/>
        /// <seealso cref="glUseProgram"/>
        public unsafe static void glUniform4iv(int location, int count, int* value) {
            var _F = _GetProc<GLNativeDelegate.FNglUniform4iv>("glUniform4iv");
            _F(location, count, value);
        }
        /// <summary>
        /// Specify the value of a uniform variable for the current program object
        /// <para>Require:</para> <para>GL_VERSION_2_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glUniform"/> is available only if the GL
        /// version is 2.0 or greater. 
        /// <see cref="glUniformMatrix{2x3|3x2|2x4|4x2|3x4|4x3}fv"/> 
        /// is available only if the GL version is 2.1 or greater. 
        /// <see cref="glUniform1i"/> and
        /// <see cref="glUniform1iv"/> are the only two functions
        /// that may be used to load uniform variables defined as sampler
        /// types. Loading samplers with any other function will result in a
        /// <code>GL_INVALID_OPERATION</code> error. 
        /// If <paramref name="count"/> is greater than 1 and the
        /// indicated uniform variable is not an array, a
        /// <code>GL_INVALID_OPERATION</code> error is generated and the
        /// specified uniform variable will remain unchanged. 
        /// Other than the preceding exceptions, if the type and size
        /// of the uniform variable as defined in the shader do not match
        /// the type and size specified in the name of the command used to
        /// load its value, a <code>GL_INVALID_OPERATION</code> error will
        /// be generated and the specified uniform variable will remain
        /// unchanged. 
        /// If <paramref name="location"/> is a value other than
        /// -1 and it does not represent a valid uniform variable location
        /// in the current program object, an error will be generated, and
        /// no changes will be made to the uniform variable storage of the
        /// current program object. If <paramref name="location"/> is
        /// equal to -1, the data passed in will be silently ignored and the
        /// specified uniform variable will not be changed.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if there
        /// is no current program object. 
        /// <code>GL_INVALID_OPERATION</code> is generated if the
        /// size of the uniform variable declared in the shader does not
        /// match the size indicated by the <see cref="glUniform"/>
        /// command. 
        /// <code>GL_INVALID_OPERATION</code> is generated if one of
        /// the integer variants of this function is used to load a uniform
        /// variable of type float, vec2, vec3, vec4, or an array of these,
        /// or if one of the floating-point variants of this function is
        /// used to load a uniform variable of type int, ivec2, ivec3, or
        /// ivec4, or an array of these. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <paramref name="location"/> is an invalid uniform location
        /// for the current program object and
        /// <paramref name="location"/> is not equal to -1. 
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="count"/> is less than 0. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <paramref name="count"/> is greater than 1 and the indicated
        /// uniform variable is not an array variable. 
        /// <code>GL_INVALID_OPERATION</code> is generated if a
        /// sampler is loaded using a command other than
        /// <see cref="glUniform1i"/> and
        /// <see cref="glUniform1iv"/>. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <see cref="glUniform"/> is executed between the execution
        /// of
        /// <see cref="glBegin"/> 
        /// and the corresponding execution of
        /// <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glUniformMatrix2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);</para>
        /// </summary>
        /// <param name="location">
        /// <para>
        /// Specifies the location of the uniform value to
        /// be modified.
        /// </para>
        /// </param>
        /// <param name="count">
        /// <para>
        /// Specifies the number of matrices that are to
        /// be modified. This should be 1 if the targeted
        /// uniform variable is not an array of matrices, and 1 or more if it is
        /// an array of matrices.
        /// </para>
        /// </param>
        /// <param name="transpose">
        /// <para>
        /// Specifies whether to transpose the matrix as
        /// the values are loaded into the uniform
        /// variable.
        /// </para>
        /// </param>
        /// <param name="value">
        /// <para>
        /// Specifies a pointer to an array of
        /// <paramref name="count"/> values that will be
        /// used to update the specified uniform
        /// variable.
        /// </para>
        /// </param>
        /// <seealso cref="glLinkProgram"/>
        /// <seealso cref="glUseProgram"/>
        public unsafe static void glUniformMatrix2fv(int location, int count, bool transpose, float* value) {
            var _F = _GetProc<GLNativeDelegate.FNglUniformMatrix2fv>("glUniformMatrix2fv");
            _F(location, count, transpose, value);
        }
        /// <summary>
        /// Specify the value of a uniform variable for the current program object
        /// <para>Require:</para> <para>GL_VERSION_2_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glUniform"/> is available only if the GL
        /// version is 2.0 or greater. 
        /// <see cref="glUniformMatrix{2x3|3x2|2x4|4x2|3x4|4x3}fv"/> 
        /// is available only if the GL version is 2.1 or greater. 
        /// <see cref="glUniform1i"/> and
        /// <see cref="glUniform1iv"/> are the only two functions
        /// that may be used to load uniform variables defined as sampler
        /// types. Loading samplers with any other function will result in a
        /// <code>GL_INVALID_OPERATION</code> error. 
        /// If <paramref name="count"/> is greater than 1 and the
        /// indicated uniform variable is not an array, a
        /// <code>GL_INVALID_OPERATION</code> error is generated and the
        /// specified uniform variable will remain unchanged. 
        /// Other than the preceding exceptions, if the type and size
        /// of the uniform variable as defined in the shader do not match
        /// the type and size specified in the name of the command used to
        /// load its value, a <code>GL_INVALID_OPERATION</code> error will
        /// be generated and the specified uniform variable will remain
        /// unchanged. 
        /// If <paramref name="location"/> is a value other than
        /// -1 and it does not represent a valid uniform variable location
        /// in the current program object, an error will be generated, and
        /// no changes will be made to the uniform variable storage of the
        /// current program object. If <paramref name="location"/> is
        /// equal to -1, the data passed in will be silently ignored and the
        /// specified uniform variable will not be changed.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if there
        /// is no current program object. 
        /// <code>GL_INVALID_OPERATION</code> is generated if the
        /// size of the uniform variable declared in the shader does not
        /// match the size indicated by the <see cref="glUniform"/>
        /// command. 
        /// <code>GL_INVALID_OPERATION</code> is generated if one of
        /// the integer variants of this function is used to load a uniform
        /// variable of type float, vec2, vec3, vec4, or an array of these,
        /// or if one of the floating-point variants of this function is
        /// used to load a uniform variable of type int, ivec2, ivec3, or
        /// ivec4, or an array of these. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <paramref name="location"/> is an invalid uniform location
        /// for the current program object and
        /// <paramref name="location"/> is not equal to -1. 
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="count"/> is less than 0. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <paramref name="count"/> is greater than 1 and the indicated
        /// uniform variable is not an array variable. 
        /// <code>GL_INVALID_OPERATION</code> is generated if a
        /// sampler is loaded using a command other than
        /// <see cref="glUniform1i"/> and
        /// <see cref="glUniform1iv"/>. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <see cref="glUniform"/> is executed between the execution
        /// of
        /// <see cref="glBegin"/> 
        /// and the corresponding execution of
        /// <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glUniformMatrix3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);</para>
        /// </summary>
        /// <param name="location">
        /// <para>
        /// Specifies the location of the uniform value to
        /// be modified.
        /// </para>
        /// </param>
        /// <param name="count">
        /// <para>
        /// Specifies the number of matrices that are to
        /// be modified. This should be 1 if the targeted
        /// uniform variable is not an array of matrices, and 1 or more if it is
        /// an array of matrices.
        /// </para>
        /// </param>
        /// <param name="transpose">
        /// <para>
        /// Specifies whether to transpose the matrix as
        /// the values are loaded into the uniform
        /// variable.
        /// </para>
        /// </param>
        /// <param name="value">
        /// <para>
        /// Specifies a pointer to an array of
        /// <paramref name="count"/> values that will be
        /// used to update the specified uniform
        /// variable.
        /// </para>
        /// </param>
        /// <seealso cref="glLinkProgram"/>
        /// <seealso cref="glUseProgram"/>
        public unsafe static void glUniformMatrix3fv(int location, int count, bool transpose, float* value) {
            var _F = _GetProc<GLNativeDelegate.FNglUniformMatrix3fv>("glUniformMatrix3fv");
            _F(location, count, transpose, value);
        }
        /// <summary>
        /// Specify the value of a uniform variable for the current program object
        /// <para>Require:</para> <para>GL_VERSION_2_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glUniform"/> is available only if the GL
        /// version is 2.0 or greater. 
        /// <see cref="glUniformMatrix{2x3|3x2|2x4|4x2|3x4|4x3}fv"/> 
        /// is available only if the GL version is 2.1 or greater. 
        /// <see cref="glUniform1i"/> and
        /// <see cref="glUniform1iv"/> are the only two functions
        /// that may be used to load uniform variables defined as sampler
        /// types. Loading samplers with any other function will result in a
        /// <code>GL_INVALID_OPERATION</code> error. 
        /// If <paramref name="count"/> is greater than 1 and the
        /// indicated uniform variable is not an array, a
        /// <code>GL_INVALID_OPERATION</code> error is generated and the
        /// specified uniform variable will remain unchanged. 
        /// Other than the preceding exceptions, if the type and size
        /// of the uniform variable as defined in the shader do not match
        /// the type and size specified in the name of the command used to
        /// load its value, a <code>GL_INVALID_OPERATION</code> error will
        /// be generated and the specified uniform variable will remain
        /// unchanged. 
        /// If <paramref name="location"/> is a value other than
        /// -1 and it does not represent a valid uniform variable location
        /// in the current program object, an error will be generated, and
        /// no changes will be made to the uniform variable storage of the
        /// current program object. If <paramref name="location"/> is
        /// equal to -1, the data passed in will be silently ignored and the
        /// specified uniform variable will not be changed.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if there
        /// is no current program object. 
        /// <code>GL_INVALID_OPERATION</code> is generated if the
        /// size of the uniform variable declared in the shader does not
        /// match the size indicated by the <see cref="glUniform"/>
        /// command. 
        /// <code>GL_INVALID_OPERATION</code> is generated if one of
        /// the integer variants of this function is used to load a uniform
        /// variable of type float, vec2, vec3, vec4, or an array of these,
        /// or if one of the floating-point variants of this function is
        /// used to load a uniform variable of type int, ivec2, ivec3, or
        /// ivec4, or an array of these. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <paramref name="location"/> is an invalid uniform location
        /// for the current program object and
        /// <paramref name="location"/> is not equal to -1. 
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="count"/> is less than 0. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <paramref name="count"/> is greater than 1 and the indicated
        /// uniform variable is not an array variable. 
        /// <code>GL_INVALID_OPERATION</code> is generated if a
        /// sampler is loaded using a command other than
        /// <see cref="glUniform1i"/> and
        /// <see cref="glUniform1iv"/>. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <see cref="glUniform"/> is executed between the execution
        /// of
        /// <see cref="glBegin"/> 
        /// and the corresponding execution of
        /// <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glUniformMatrix4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);</para>
        /// </summary>
        /// <param name="location">
        /// <para>
        /// Specifies the location of the uniform value to
        /// be modified.
        /// </para>
        /// </param>
        /// <param name="count">
        /// <para>
        /// Specifies the number of matrices that are to
        /// be modified. This should be 1 if the targeted
        /// uniform variable is not an array of matrices, and 1 or more if it is
        /// an array of matrices.
        /// </para>
        /// </param>
        /// <param name="transpose">
        /// <para>
        /// Specifies whether to transpose the matrix as
        /// the values are loaded into the uniform
        /// variable.
        /// </para>
        /// </param>
        /// <param name="value">
        /// <para>
        /// Specifies a pointer to an array of
        /// <paramref name="count"/> values that will be
        /// used to update the specified uniform
        /// variable.
        /// </para>
        /// </param>
        /// <seealso cref="glLinkProgram"/>
        /// <seealso cref="glUseProgram"/>
        public unsafe static void glUniformMatrix4fv(int location, int count, bool transpose, float* value) {
            var _F = _GetProc<GLNativeDelegate.FNglUniformMatrix4fv>("glUniformMatrix4fv");
            _F(location, count, transpose, value);
        }
        /// <summary>
        /// Validates a program object
        /// <para>Require:</para> <para>GL_VERSION_2_0, GL_ES_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glValidateProgram"/> is available only
        /// if the GL version is 2.0 or greater. 
        /// This function mimics the validation operation that OpenGL
        /// implementations must perform when rendering commands are issued
        /// while programmable shaders are part of current state. The error
        /// <code>GL_INVALID_OPERATION</code> will be generated by
        /// <see cref="glBegin"/> ,
        /// <see cref="glRasterPos"/> ,
        /// or any command that performs an implicit call to
        /// <see cref="glBegin"/> 
        /// if: 
        /// any two active samplers in the current program
        /// object are of different types, but refer to the same
        /// texture image unit, 
        /// any active sampler in the current program object
        /// refers to a texture image unit where fixed-function
        /// fragment processing accesses a texture target that does
        /// not match the sampler type, or 
        /// the sum of the number of active samplers in the
        /// program and the number of texture image units enabled
        /// for fixed-function fragment processing exceeds the
        /// combined limit on the total number of texture image
        /// units allowed. 
        /// It may be difficult or cause a performance degradation for
        /// applications to catch these errors when rendering commands are
        /// issued. Therefore, applications are advised to make calls to
        /// <see cref="glValidateProgram"/> to detect these issues
        /// during application development.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="program"/> is not a value generated by
        /// OpenGL. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <paramref name="program"/> is not a program object. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <see cref="glValidateProgram"/> is executed between the
        /// execution of
        /// <see cref="glBegin"/> 
        /// and the corresponding execution of
        /// <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glValidateProgram(GLuint program);</para>
        /// </summary>
        /// <param name="program">
        /// <para>
        /// Specifies the handle of the program object to
        /// be validated.
        /// </para>
        /// </param>
        /// <seealso cref="glLinkProgram"/>
        /// <seealso cref="glUseProgram"/>
        public static void glValidateProgram(uint program) {
            var _F = _GetProc<GLNativeDelegate.FNglValidateProgram>("glValidateProgram");
            _F(program);
        }
        /// <summary>
        /// Specifies the value of a generic vertex attribute
        /// <para>Require:</para> <para>GL_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glVertexAttrib"/> is available only if
        /// the GL version is 2.0 or greater. 
        /// Generic vertex attributes can be updated at any time. In
        /// particular, <see cref="glVertexAttrib"/> can be called
        /// between a call to
        /// <see cref="glBegin"/> 
        /// and the corresponding call to
        /// <see cref="glEnd"/> . 
        /// It is possible for an application to bind more than one
        /// attribute name to the same generic vertex attribute index. This
        /// is referred to as aliasing, and it is allowed only if just one
        /// of the aliased attribute variables is active in the vertex
        /// shader, or if no path through the vertex shader consumes more
        /// than one of the attributes aliased to the same location. OpenGL
        /// implementations are not required to do error checking to detect
        /// aliasing, they are allowed to assume that aliasing will not
        /// occur, and they are allowed to employ optimizations that work
        /// only in the absence of aliasing. 
        /// There is no provision for binding standard vertex
        /// attributes; therefore, it is not possible to alias generic
        /// attributes with standard attributes.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="index"/> is greater than or equal to
        /// <code>GL_MAX_VERTEX_ATTRIBS</code>.
        /// </para>
        /// Original: <para>void glVertexAttrib1d(GLuint index, GLdouble v0);</para>
        /// </summary>
        /// <param name="index">
        /// <para>
        /// Specifies the index of the generic vertex
        /// attribute to be modified.
        /// </para>
        /// </param>
        /// <seealso cref="glBindAttribLocation"/>
        /// <seealso cref="glVertex"/>
        /// <seealso cref="glVertexAttribPointer"/>
        public static void glVertexAttrib1d(uint index, double v0) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttrib1d>("glVertexAttrib1d");
            _F(index, v0);
        }
        /// <summary>
        /// Specifies the value of a generic vertex attribute
        /// <para>Require:</para> <para>GL_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glVertexAttrib"/> is available only if
        /// the GL version is 2.0 or greater. 
        /// Generic vertex attributes can be updated at any time. In
        /// particular, <see cref="glVertexAttrib"/> can be called
        /// between a call to
        /// <see cref="glBegin"/> 
        /// and the corresponding call to
        /// <see cref="glEnd"/> . 
        /// It is possible for an application to bind more than one
        /// attribute name to the same generic vertex attribute index. This
        /// is referred to as aliasing, and it is allowed only if just one
        /// of the aliased attribute variables is active in the vertex
        /// shader, or if no path through the vertex shader consumes more
        /// than one of the attributes aliased to the same location. OpenGL
        /// implementations are not required to do error checking to detect
        /// aliasing, they are allowed to assume that aliasing will not
        /// occur, and they are allowed to employ optimizations that work
        /// only in the absence of aliasing. 
        /// There is no provision for binding standard vertex
        /// attributes; therefore, it is not possible to alias generic
        /// attributes with standard attributes.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="index"/> is greater than or equal to
        /// <code>GL_MAX_VERTEX_ATTRIBS</code>.
        /// </para>
        /// Original: <para>void glVertexAttrib1dv(GLuint index, const GLdouble * v);</para>
        /// </summary>
        /// <param name="index">
        /// <para>
        /// Specifies the index of the generic vertex
        /// attribute to be modified.
        /// </para>
        /// </param>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array of values to
        /// be used for the generic vertex attribute.
        /// </para>
        /// </param>
        /// <seealso cref="glBindAttribLocation"/>
        /// <seealso cref="glVertex"/>
        /// <seealso cref="glVertexAttribPointer"/>
        public unsafe static void glVertexAttrib1dv(uint index, double* v) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttrib1dv>("glVertexAttrib1dv");
            _F(index, v);
        }
        /// <summary>
        /// Specifies the value of a generic vertex attribute
        /// <para>Require:</para> <para>GL_VERSION_2_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glVertexAttrib"/> is available only if
        /// the GL version is 2.0 or greater. 
        /// Generic vertex attributes can be updated at any time. In
        /// particular, <see cref="glVertexAttrib"/> can be called
        /// between a call to
        /// <see cref="glBegin"/> 
        /// and the corresponding call to
        /// <see cref="glEnd"/> . 
        /// It is possible for an application to bind more than one
        /// attribute name to the same generic vertex attribute index. This
        /// is referred to as aliasing, and it is allowed only if just one
        /// of the aliased attribute variables is active in the vertex
        /// shader, or if no path through the vertex shader consumes more
        /// than one of the attributes aliased to the same location. OpenGL
        /// implementations are not required to do error checking to detect
        /// aliasing, they are allowed to assume that aliasing will not
        /// occur, and they are allowed to employ optimizations that work
        /// only in the absence of aliasing. 
        /// There is no provision for binding standard vertex
        /// attributes; therefore, it is not possible to alias generic
        /// attributes with standard attributes.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="index"/> is greater than or equal to
        /// <code>GL_MAX_VERTEX_ATTRIBS</code>.
        /// </para>
        /// Original: <para>void glVertexAttrib1f(GLuint index, GLfloat v0);</para>
        /// </summary>
        /// <param name="index">
        /// <para>
        /// Specifies the index of the generic vertex
        /// attribute to be modified.
        /// </para>
        /// </param>
        /// <seealso cref="glBindAttribLocation"/>
        /// <seealso cref="glVertex"/>
        /// <seealso cref="glVertexAttribPointer"/>
        public static void glVertexAttrib1f(uint index, float v0) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttrib1f>("glVertexAttrib1f");
            _F(index, v0);
        }
        /// <summary>
        /// Specifies the value of a generic vertex attribute
        /// <para>Require:</para> <para>GL_VERSION_2_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glVertexAttrib"/> is available only if
        /// the GL version is 2.0 or greater. 
        /// Generic vertex attributes can be updated at any time. In
        /// particular, <see cref="glVertexAttrib"/> can be called
        /// between a call to
        /// <see cref="glBegin"/> 
        /// and the corresponding call to
        /// <see cref="glEnd"/> . 
        /// It is possible for an application to bind more than one
        /// attribute name to the same generic vertex attribute index. This
        /// is referred to as aliasing, and it is allowed only if just one
        /// of the aliased attribute variables is active in the vertex
        /// shader, or if no path through the vertex shader consumes more
        /// than one of the attributes aliased to the same location. OpenGL
        /// implementations are not required to do error checking to detect
        /// aliasing, they are allowed to assume that aliasing will not
        /// occur, and they are allowed to employ optimizations that work
        /// only in the absence of aliasing. 
        /// There is no provision for binding standard vertex
        /// attributes; therefore, it is not possible to alias generic
        /// attributes with standard attributes.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="index"/> is greater than or equal to
        /// <code>GL_MAX_VERTEX_ATTRIBS</code>.
        /// </para>
        /// Original: <para>void glVertexAttrib1fv(GLuint index, const GLfloat * v);</para>
        /// </summary>
        /// <param name="index">
        /// <para>
        /// Specifies the index of the generic vertex
        /// attribute to be modified.
        /// </para>
        /// </param>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array of values to
        /// be used for the generic vertex attribute.
        /// </para>
        /// </param>
        /// <seealso cref="glBindAttribLocation"/>
        /// <seealso cref="glVertex"/>
        /// <seealso cref="glVertexAttribPointer"/>
        public unsafe static void glVertexAttrib1fv(uint index, float* v) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttrib1fv>("glVertexAttrib1fv");
            _F(index, v);
        }
        /// <summary>
        /// Specifies the value of a generic vertex attribute
        /// <para>Require:</para> <para>GL_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glVertexAttrib"/> is available only if
        /// the GL version is 2.0 or greater. 
        /// Generic vertex attributes can be updated at any time. In
        /// particular, <see cref="glVertexAttrib"/> can be called
        /// between a call to
        /// <see cref="glBegin"/> 
        /// and the corresponding call to
        /// <see cref="glEnd"/> . 
        /// It is possible for an application to bind more than one
        /// attribute name to the same generic vertex attribute index. This
        /// is referred to as aliasing, and it is allowed only if just one
        /// of the aliased attribute variables is active in the vertex
        /// shader, or if no path through the vertex shader consumes more
        /// than one of the attributes aliased to the same location. OpenGL
        /// implementations are not required to do error checking to detect
        /// aliasing, they are allowed to assume that aliasing will not
        /// occur, and they are allowed to employ optimizations that work
        /// only in the absence of aliasing. 
        /// There is no provision for binding standard vertex
        /// attributes; therefore, it is not possible to alias generic
        /// attributes with standard attributes.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="index"/> is greater than or equal to
        /// <code>GL_MAX_VERTEX_ATTRIBS</code>.
        /// </para>
        /// Original: <para>void glVertexAttrib1s(GLuint index, GLshort v0);</para>
        /// </summary>
        /// <param name="index">
        /// <para>
        /// Specifies the index of the generic vertex
        /// attribute to be modified.
        /// </para>
        /// </param>
        /// <seealso cref="glBindAttribLocation"/>
        /// <seealso cref="glVertex"/>
        /// <seealso cref="glVertexAttribPointer"/>
        public static void glVertexAttrib1s(uint index, short v0) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttrib1s>("glVertexAttrib1s");
            _F(index, v0);
        }
        /// <summary>
        /// Specifies the value of a generic vertex attribute
        /// <para>Require:</para> <para>GL_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glVertexAttrib"/> is available only if
        /// the GL version is 2.0 or greater. 
        /// Generic vertex attributes can be updated at any time. In
        /// particular, <see cref="glVertexAttrib"/> can be called
        /// between a call to
        /// <see cref="glBegin"/> 
        /// and the corresponding call to
        /// <see cref="glEnd"/> . 
        /// It is possible for an application to bind more than one
        /// attribute name to the same generic vertex attribute index. This
        /// is referred to as aliasing, and it is allowed only if just one
        /// of the aliased attribute variables is active in the vertex
        /// shader, or if no path through the vertex shader consumes more
        /// than one of the attributes aliased to the same location. OpenGL
        /// implementations are not required to do error checking to detect
        /// aliasing, they are allowed to assume that aliasing will not
        /// occur, and they are allowed to employ optimizations that work
        /// only in the absence of aliasing. 
        /// There is no provision for binding standard vertex
        /// attributes; therefore, it is not possible to alias generic
        /// attributes with standard attributes.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="index"/> is greater than or equal to
        /// <code>GL_MAX_VERTEX_ATTRIBS</code>.
        /// </para>
        /// Original: <para>void glVertexAttrib1sv(GLuint index, const GLshort * v);</para>
        /// </summary>
        /// <param name="index">
        /// <para>
        /// Specifies the index of the generic vertex
        /// attribute to be modified.
        /// </para>
        /// </param>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array of values to
        /// be used for the generic vertex attribute.
        /// </para>
        /// </param>
        /// <seealso cref="glBindAttribLocation"/>
        /// <seealso cref="glVertex"/>
        /// <seealso cref="glVertexAttribPointer"/>
        public unsafe static void glVertexAttrib1sv(uint index, short* v) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttrib1sv>("glVertexAttrib1sv");
            _F(index, v);
        }
        /// <summary>
        /// Specifies the value of a generic vertex attribute
        /// <para>Require:</para> <para>GL_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glVertexAttrib"/> is available only if
        /// the GL version is 2.0 or greater. 
        /// Generic vertex attributes can be updated at any time. In
        /// particular, <see cref="glVertexAttrib"/> can be called
        /// between a call to
        /// <see cref="glBegin"/> 
        /// and the corresponding call to
        /// <see cref="glEnd"/> . 
        /// It is possible for an application to bind more than one
        /// attribute name to the same generic vertex attribute index. This
        /// is referred to as aliasing, and it is allowed only if just one
        /// of the aliased attribute variables is active in the vertex
        /// shader, or if no path through the vertex shader consumes more
        /// than one of the attributes aliased to the same location. OpenGL
        /// implementations are not required to do error checking to detect
        /// aliasing, they are allowed to assume that aliasing will not
        /// occur, and they are allowed to employ optimizations that work
        /// only in the absence of aliasing. 
        /// There is no provision for binding standard vertex
        /// attributes; therefore, it is not possible to alias generic
        /// attributes with standard attributes.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="index"/> is greater than or equal to
        /// <code>GL_MAX_VERTEX_ATTRIBS</code>.
        /// </para>
        /// Original: <para>void glVertexAttrib2d(GLuint index, GLdouble v0, GLdouble v1);</para>
        /// </summary>
        /// <param name="index">
        /// <para>
        /// Specifies the index of the generic vertex
        /// attribute to be modified.
        /// </para>
        /// </param>
        /// <seealso cref="glBindAttribLocation"/>
        /// <seealso cref="glVertex"/>
        /// <seealso cref="glVertexAttribPointer"/>
        public static void glVertexAttrib2d(uint index, double v0, double v1) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttrib2d>("glVertexAttrib2d");
            _F(index, v0, v1);
        }
        /// <summary>
        /// Specifies the value of a generic vertex attribute
        /// <para>Require:</para> <para>GL_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glVertexAttrib"/> is available only if
        /// the GL version is 2.0 or greater. 
        /// Generic vertex attributes can be updated at any time. In
        /// particular, <see cref="glVertexAttrib"/> can be called
        /// between a call to
        /// <see cref="glBegin"/> 
        /// and the corresponding call to
        /// <see cref="glEnd"/> . 
        /// It is possible for an application to bind more than one
        /// attribute name to the same generic vertex attribute index. This
        /// is referred to as aliasing, and it is allowed only if just one
        /// of the aliased attribute variables is active in the vertex
        /// shader, or if no path through the vertex shader consumes more
        /// than one of the attributes aliased to the same location. OpenGL
        /// implementations are not required to do error checking to detect
        /// aliasing, they are allowed to assume that aliasing will not
        /// occur, and they are allowed to employ optimizations that work
        /// only in the absence of aliasing. 
        /// There is no provision for binding standard vertex
        /// attributes; therefore, it is not possible to alias generic
        /// attributes with standard attributes.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="index"/> is greater than or equal to
        /// <code>GL_MAX_VERTEX_ATTRIBS</code>.
        /// </para>
        /// Original: <para>void glVertexAttrib2dv(GLuint index, const GLdouble * v);</para>
        /// </summary>
        /// <param name="index">
        /// <para>
        /// Specifies the index of the generic vertex
        /// attribute to be modified.
        /// </para>
        /// </param>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array of values to
        /// be used for the generic vertex attribute.
        /// </para>
        /// </param>
        /// <seealso cref="glBindAttribLocation"/>
        /// <seealso cref="glVertex"/>
        /// <seealso cref="glVertexAttribPointer"/>
        public unsafe static void glVertexAttrib2dv(uint index, double* v) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttrib2dv>("glVertexAttrib2dv");
            _F(index, v);
        }
        /// <summary>
        /// Specifies the value of a generic vertex attribute
        /// <para>Require:</para> <para>GL_VERSION_2_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glVertexAttrib"/> is available only if
        /// the GL version is 2.0 or greater. 
        /// Generic vertex attributes can be updated at any time. In
        /// particular, <see cref="glVertexAttrib"/> can be called
        /// between a call to
        /// <see cref="glBegin"/> 
        /// and the corresponding call to
        /// <see cref="glEnd"/> . 
        /// It is possible for an application to bind more than one
        /// attribute name to the same generic vertex attribute index. This
        /// is referred to as aliasing, and it is allowed only if just one
        /// of the aliased attribute variables is active in the vertex
        /// shader, or if no path through the vertex shader consumes more
        /// than one of the attributes aliased to the same location. OpenGL
        /// implementations are not required to do error checking to detect
        /// aliasing, they are allowed to assume that aliasing will not
        /// occur, and they are allowed to employ optimizations that work
        /// only in the absence of aliasing. 
        /// There is no provision for binding standard vertex
        /// attributes; therefore, it is not possible to alias generic
        /// attributes with standard attributes.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="index"/> is greater than or equal to
        /// <code>GL_MAX_VERTEX_ATTRIBS</code>.
        /// </para>
        /// Original: <para>void glVertexAttrib2f(GLuint index, GLfloat v0, GLfloat v1);</para>
        /// </summary>
        /// <param name="index">
        /// <para>
        /// Specifies the index of the generic vertex
        /// attribute to be modified.
        /// </para>
        /// </param>
        /// <seealso cref="glBindAttribLocation"/>
        /// <seealso cref="glVertex"/>
        /// <seealso cref="glVertexAttribPointer"/>
        public static void glVertexAttrib2f(uint index, float v0, float v1) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttrib2f>("glVertexAttrib2f");
            _F(index, v0, v1);
        }
        /// <summary>
        /// Specifies the value of a generic vertex attribute
        /// <para>Require:</para> <para>GL_VERSION_2_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glVertexAttrib"/> is available only if
        /// the GL version is 2.0 or greater. 
        /// Generic vertex attributes can be updated at any time. In
        /// particular, <see cref="glVertexAttrib"/> can be called
        /// between a call to
        /// <see cref="glBegin"/> 
        /// and the corresponding call to
        /// <see cref="glEnd"/> . 
        /// It is possible for an application to bind more than one
        /// attribute name to the same generic vertex attribute index. This
        /// is referred to as aliasing, and it is allowed only if just one
        /// of the aliased attribute variables is active in the vertex
        /// shader, or if no path through the vertex shader consumes more
        /// than one of the attributes aliased to the same location. OpenGL
        /// implementations are not required to do error checking to detect
        /// aliasing, they are allowed to assume that aliasing will not
        /// occur, and they are allowed to employ optimizations that work
        /// only in the absence of aliasing. 
        /// There is no provision for binding standard vertex
        /// attributes; therefore, it is not possible to alias generic
        /// attributes with standard attributes.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="index"/> is greater than or equal to
        /// <code>GL_MAX_VERTEX_ATTRIBS</code>.
        /// </para>
        /// Original: <para>void glVertexAttrib2fv(GLuint index, const GLfloat * v);</para>
        /// </summary>
        /// <param name="index">
        /// <para>
        /// Specifies the index of the generic vertex
        /// attribute to be modified.
        /// </para>
        /// </param>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array of values to
        /// be used for the generic vertex attribute.
        /// </para>
        /// </param>
        /// <seealso cref="glBindAttribLocation"/>
        /// <seealso cref="glVertex"/>
        /// <seealso cref="glVertexAttribPointer"/>
        public unsafe static void glVertexAttrib2fv(uint index, float* v) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttrib2fv>("glVertexAttrib2fv");
            _F(index, v);
        }
        /// <summary>
        /// Specifies the value of a generic vertex attribute
        /// <para>Require:</para> <para>GL_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glVertexAttrib"/> is available only if
        /// the GL version is 2.0 or greater. 
        /// Generic vertex attributes can be updated at any time. In
        /// particular, <see cref="glVertexAttrib"/> can be called
        /// between a call to
        /// <see cref="glBegin"/> 
        /// and the corresponding call to
        /// <see cref="glEnd"/> . 
        /// It is possible for an application to bind more than one
        /// attribute name to the same generic vertex attribute index. This
        /// is referred to as aliasing, and it is allowed only if just one
        /// of the aliased attribute variables is active in the vertex
        /// shader, or if no path through the vertex shader consumes more
        /// than one of the attributes aliased to the same location. OpenGL
        /// implementations are not required to do error checking to detect
        /// aliasing, they are allowed to assume that aliasing will not
        /// occur, and they are allowed to employ optimizations that work
        /// only in the absence of aliasing. 
        /// There is no provision for binding standard vertex
        /// attributes; therefore, it is not possible to alias generic
        /// attributes with standard attributes.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="index"/> is greater than or equal to
        /// <code>GL_MAX_VERTEX_ATTRIBS</code>.
        /// </para>
        /// Original: <para>void glVertexAttrib2s(GLuint index, GLshort v0, GLshort v1);</para>
        /// </summary>
        /// <param name="index">
        /// <para>
        /// Specifies the index of the generic vertex
        /// attribute to be modified.
        /// </para>
        /// </param>
        /// <seealso cref="glBindAttribLocation"/>
        /// <seealso cref="glVertex"/>
        /// <seealso cref="glVertexAttribPointer"/>
        public static void glVertexAttrib2s(uint index, short v0, short v1) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttrib2s>("glVertexAttrib2s");
            _F(index, v0, v1);
        }
        /// <summary>
        /// Specifies the value of a generic vertex attribute
        /// <para>Require:</para> <para>GL_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glVertexAttrib"/> is available only if
        /// the GL version is 2.0 or greater. 
        /// Generic vertex attributes can be updated at any time. In
        /// particular, <see cref="glVertexAttrib"/> can be called
        /// between a call to
        /// <see cref="glBegin"/> 
        /// and the corresponding call to
        /// <see cref="glEnd"/> . 
        /// It is possible for an application to bind more than one
        /// attribute name to the same generic vertex attribute index. This
        /// is referred to as aliasing, and it is allowed only if just one
        /// of the aliased attribute variables is active in the vertex
        /// shader, or if no path through the vertex shader consumes more
        /// than one of the attributes aliased to the same location. OpenGL
        /// implementations are not required to do error checking to detect
        /// aliasing, they are allowed to assume that aliasing will not
        /// occur, and they are allowed to employ optimizations that work
        /// only in the absence of aliasing. 
        /// There is no provision for binding standard vertex
        /// attributes; therefore, it is not possible to alias generic
        /// attributes with standard attributes.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="index"/> is greater than or equal to
        /// <code>GL_MAX_VERTEX_ATTRIBS</code>.
        /// </para>
        /// Original: <para>void glVertexAttrib2sv(GLuint index, const GLshort * v);</para>
        /// </summary>
        /// <param name="index">
        /// <para>
        /// Specifies the index of the generic vertex
        /// attribute to be modified.
        /// </para>
        /// </param>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array of values to
        /// be used for the generic vertex attribute.
        /// </para>
        /// </param>
        /// <seealso cref="glBindAttribLocation"/>
        /// <seealso cref="glVertex"/>
        /// <seealso cref="glVertexAttribPointer"/>
        public unsafe static void glVertexAttrib2sv(uint index, short* v) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttrib2sv>("glVertexAttrib2sv");
            _F(index, v);
        }
        /// <summary>
        /// Specifies the value of a generic vertex attribute
        /// <para>Require:</para> <para>GL_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glVertexAttrib"/> is available only if
        /// the GL version is 2.0 or greater. 
        /// Generic vertex attributes can be updated at any time. In
        /// particular, <see cref="glVertexAttrib"/> can be called
        /// between a call to
        /// <see cref="glBegin"/> 
        /// and the corresponding call to
        /// <see cref="glEnd"/> . 
        /// It is possible for an application to bind more than one
        /// attribute name to the same generic vertex attribute index. This
        /// is referred to as aliasing, and it is allowed only if just one
        /// of the aliased attribute variables is active in the vertex
        /// shader, or if no path through the vertex shader consumes more
        /// than one of the attributes aliased to the same location. OpenGL
        /// implementations are not required to do error checking to detect
        /// aliasing, they are allowed to assume that aliasing will not
        /// occur, and they are allowed to employ optimizations that work
        /// only in the absence of aliasing. 
        /// There is no provision for binding standard vertex
        /// attributes; therefore, it is not possible to alias generic
        /// attributes with standard attributes.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="index"/> is greater than or equal to
        /// <code>GL_MAX_VERTEX_ATTRIBS</code>.
        /// </para>
        /// Original: <para>void glVertexAttrib3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2);</para>
        /// </summary>
        /// <param name="index">
        /// <para>
        /// Specifies the index of the generic vertex
        /// attribute to be modified.
        /// </para>
        /// </param>
        /// <seealso cref="glBindAttribLocation"/>
        /// <seealso cref="glVertex"/>
        /// <seealso cref="glVertexAttribPointer"/>
        public static void glVertexAttrib3d(uint index, double v0, double v1, double v2) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttrib3d>("glVertexAttrib3d");
            _F(index, v0, v1, v2);
        }
        /// <summary>
        /// Specifies the value of a generic vertex attribute
        /// <para>Require:</para> <para>GL_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glVertexAttrib"/> is available only if
        /// the GL version is 2.0 or greater. 
        /// Generic vertex attributes can be updated at any time. In
        /// particular, <see cref="glVertexAttrib"/> can be called
        /// between a call to
        /// <see cref="glBegin"/> 
        /// and the corresponding call to
        /// <see cref="glEnd"/> . 
        /// It is possible for an application to bind more than one
        /// attribute name to the same generic vertex attribute index. This
        /// is referred to as aliasing, and it is allowed only if just one
        /// of the aliased attribute variables is active in the vertex
        /// shader, or if no path through the vertex shader consumes more
        /// than one of the attributes aliased to the same location. OpenGL
        /// implementations are not required to do error checking to detect
        /// aliasing, they are allowed to assume that aliasing will not
        /// occur, and they are allowed to employ optimizations that work
        /// only in the absence of aliasing. 
        /// There is no provision for binding standard vertex
        /// attributes; therefore, it is not possible to alias generic
        /// attributes with standard attributes.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="index"/> is greater than or equal to
        /// <code>GL_MAX_VERTEX_ATTRIBS</code>.
        /// </para>
        /// Original: <para>void glVertexAttrib3dv(GLuint index, const GLdouble * v);</para>
        /// </summary>
        /// <param name="index">
        /// <para>
        /// Specifies the index of the generic vertex
        /// attribute to be modified.
        /// </para>
        /// </param>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array of values to
        /// be used for the generic vertex attribute.
        /// </para>
        /// </param>
        /// <seealso cref="glBindAttribLocation"/>
        /// <seealso cref="glVertex"/>
        /// <seealso cref="glVertexAttribPointer"/>
        public unsafe static void glVertexAttrib3dv(uint index, double* v) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttrib3dv>("glVertexAttrib3dv");
            _F(index, v);
        }
        /// <summary>
        /// Specifies the value of a generic vertex attribute
        /// <para>Require:</para> <para>GL_VERSION_2_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glVertexAttrib"/> is available only if
        /// the GL version is 2.0 or greater. 
        /// Generic vertex attributes can be updated at any time. In
        /// particular, <see cref="glVertexAttrib"/> can be called
        /// between a call to
        /// <see cref="glBegin"/> 
        /// and the corresponding call to
        /// <see cref="glEnd"/> . 
        /// It is possible for an application to bind more than one
        /// attribute name to the same generic vertex attribute index. This
        /// is referred to as aliasing, and it is allowed only if just one
        /// of the aliased attribute variables is active in the vertex
        /// shader, or if no path through the vertex shader consumes more
        /// than one of the attributes aliased to the same location. OpenGL
        /// implementations are not required to do error checking to detect
        /// aliasing, they are allowed to assume that aliasing will not
        /// occur, and they are allowed to employ optimizations that work
        /// only in the absence of aliasing. 
        /// There is no provision for binding standard vertex
        /// attributes; therefore, it is not possible to alias generic
        /// attributes with standard attributes.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="index"/> is greater than or equal to
        /// <code>GL_MAX_VERTEX_ATTRIBS</code>.
        /// </para>
        /// Original: <para>void glVertexAttrib3f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2);</para>
        /// </summary>
        /// <param name="index">
        /// <para>
        /// Specifies the index of the generic vertex
        /// attribute to be modified.
        /// </para>
        /// </param>
        /// <seealso cref="glBindAttribLocation"/>
        /// <seealso cref="glVertex"/>
        /// <seealso cref="glVertexAttribPointer"/>
        public static void glVertexAttrib3f(uint index, float v0, float v1, float v2) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttrib3f>("glVertexAttrib3f");
            _F(index, v0, v1, v2);
        }
        /// <summary>
        /// Specifies the value of a generic vertex attribute
        /// <para>Require:</para> <para>GL_VERSION_2_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glVertexAttrib"/> is available only if
        /// the GL version is 2.0 or greater. 
        /// Generic vertex attributes can be updated at any time. In
        /// particular, <see cref="glVertexAttrib"/> can be called
        /// between a call to
        /// <see cref="glBegin"/> 
        /// and the corresponding call to
        /// <see cref="glEnd"/> . 
        /// It is possible for an application to bind more than one
        /// attribute name to the same generic vertex attribute index. This
        /// is referred to as aliasing, and it is allowed only if just one
        /// of the aliased attribute variables is active in the vertex
        /// shader, or if no path through the vertex shader consumes more
        /// than one of the attributes aliased to the same location. OpenGL
        /// implementations are not required to do error checking to detect
        /// aliasing, they are allowed to assume that aliasing will not
        /// occur, and they are allowed to employ optimizations that work
        /// only in the absence of aliasing. 
        /// There is no provision for binding standard vertex
        /// attributes; therefore, it is not possible to alias generic
        /// attributes with standard attributes.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="index"/> is greater than or equal to
        /// <code>GL_MAX_VERTEX_ATTRIBS</code>.
        /// </para>
        /// Original: <para>void glVertexAttrib3fv(GLuint index, const GLfloat * v);</para>
        /// </summary>
        /// <param name="index">
        /// <para>
        /// Specifies the index of the generic vertex
        /// attribute to be modified.
        /// </para>
        /// </param>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array of values to
        /// be used for the generic vertex attribute.
        /// </para>
        /// </param>
        /// <seealso cref="glBindAttribLocation"/>
        /// <seealso cref="glVertex"/>
        /// <seealso cref="glVertexAttribPointer"/>
        public unsafe static void glVertexAttrib3fv(uint index, float* v) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttrib3fv>("glVertexAttrib3fv");
            _F(index, v);
        }
        /// <summary>
        /// Specifies the value of a generic vertex attribute
        /// <para>Require:</para> <para>GL_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glVertexAttrib"/> is available only if
        /// the GL version is 2.0 or greater. 
        /// Generic vertex attributes can be updated at any time. In
        /// particular, <see cref="glVertexAttrib"/> can be called
        /// between a call to
        /// <see cref="glBegin"/> 
        /// and the corresponding call to
        /// <see cref="glEnd"/> . 
        /// It is possible for an application to bind more than one
        /// attribute name to the same generic vertex attribute index. This
        /// is referred to as aliasing, and it is allowed only if just one
        /// of the aliased attribute variables is active in the vertex
        /// shader, or if no path through the vertex shader consumes more
        /// than one of the attributes aliased to the same location. OpenGL
        /// implementations are not required to do error checking to detect
        /// aliasing, they are allowed to assume that aliasing will not
        /// occur, and they are allowed to employ optimizations that work
        /// only in the absence of aliasing. 
        /// There is no provision for binding standard vertex
        /// attributes; therefore, it is not possible to alias generic
        /// attributes with standard attributes.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="index"/> is greater than or equal to
        /// <code>GL_MAX_VERTEX_ATTRIBS</code>.
        /// </para>
        /// Original: <para>void glVertexAttrib3s(GLuint index, GLshort v0, GLshort v1, GLshort v2);</para>
        /// </summary>
        /// <param name="index">
        /// <para>
        /// Specifies the index of the generic vertex
        /// attribute to be modified.
        /// </para>
        /// </param>
        /// <seealso cref="glBindAttribLocation"/>
        /// <seealso cref="glVertex"/>
        /// <seealso cref="glVertexAttribPointer"/>
        public static void glVertexAttrib3s(uint index, short v0, short v1, short v2) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttrib3s>("glVertexAttrib3s");
            _F(index, v0, v1, v2);
        }
        /// <summary>
        /// Specifies the value of a generic vertex attribute
        /// <para>Require:</para> <para>GL_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glVertexAttrib"/> is available only if
        /// the GL version is 2.0 or greater. 
        /// Generic vertex attributes can be updated at any time. In
        /// particular, <see cref="glVertexAttrib"/> can be called
        /// between a call to
        /// <see cref="glBegin"/> 
        /// and the corresponding call to
        /// <see cref="glEnd"/> . 
        /// It is possible for an application to bind more than one
        /// attribute name to the same generic vertex attribute index. This
        /// is referred to as aliasing, and it is allowed only if just one
        /// of the aliased attribute variables is active in the vertex
        /// shader, or if no path through the vertex shader consumes more
        /// than one of the attributes aliased to the same location. OpenGL
        /// implementations are not required to do error checking to detect
        /// aliasing, they are allowed to assume that aliasing will not
        /// occur, and they are allowed to employ optimizations that work
        /// only in the absence of aliasing. 
        /// There is no provision for binding standard vertex
        /// attributes; therefore, it is not possible to alias generic
        /// attributes with standard attributes.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="index"/> is greater than or equal to
        /// <code>GL_MAX_VERTEX_ATTRIBS</code>.
        /// </para>
        /// Original: <para>void glVertexAttrib3sv(GLuint index, const GLshort * v);</para>
        /// </summary>
        /// <param name="index">
        /// <para>
        /// Specifies the index of the generic vertex
        /// attribute to be modified.
        /// </para>
        /// </param>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array of values to
        /// be used for the generic vertex attribute.
        /// </para>
        /// </param>
        /// <seealso cref="glBindAttribLocation"/>
        /// <seealso cref="glVertex"/>
        /// <seealso cref="glVertexAttribPointer"/>
        public unsafe static void glVertexAttrib3sv(uint index, short* v) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttrib3sv>("glVertexAttrib3sv");
            _F(index, v);
        }
        /// <summary>
        /// Specifies the value of a generic vertex attribute
        /// <para>Require:</para> <para>GL_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glVertexAttrib"/> is available only if
        /// the GL version is 2.0 or greater. 
        /// Generic vertex attributes can be updated at any time. In
        /// particular, <see cref="glVertexAttrib"/> can be called
        /// between a call to
        /// <see cref="glBegin"/> 
        /// and the corresponding call to
        /// <see cref="glEnd"/> . 
        /// It is possible for an application to bind more than one
        /// attribute name to the same generic vertex attribute index. This
        /// is referred to as aliasing, and it is allowed only if just one
        /// of the aliased attribute variables is active in the vertex
        /// shader, or if no path through the vertex shader consumes more
        /// than one of the attributes aliased to the same location. OpenGL
        /// implementations are not required to do error checking to detect
        /// aliasing, they are allowed to assume that aliasing will not
        /// occur, and they are allowed to employ optimizations that work
        /// only in the absence of aliasing. 
        /// There is no provision for binding standard vertex
        /// attributes; therefore, it is not possible to alias generic
        /// attributes with standard attributes.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="index"/> is greater than or equal to
        /// <code>GL_MAX_VERTEX_ATTRIBS</code>.
        /// </para>
        /// Original: <para>void glVertexAttrib4Nbv(GLuint index, const GLbyte * v);</para>
        /// </summary>
        /// <param name="index">
        /// <para>
        /// Specifies the index of the generic vertex
        /// attribute to be modified.
        /// </para>
        /// </param>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array of values to
        /// be used for the generic vertex attribute.
        /// </para>
        /// </param>
        /// <seealso cref="glBindAttribLocation"/>
        /// <seealso cref="glVertex"/>
        /// <seealso cref="glVertexAttribPointer"/>
        public unsafe static void glVertexAttrib4Nbv(uint index, byte* v) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttrib4Nbv>("glVertexAttrib4Nbv");
            _F(index, v);
        }
        /// <summary>
        /// Specifies the value of a generic vertex attribute
        /// <para>Require:</para> <para>GL_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glVertexAttrib"/> is available only if
        /// the GL version is 2.0 or greater. 
        /// Generic vertex attributes can be updated at any time. In
        /// particular, <see cref="glVertexAttrib"/> can be called
        /// between a call to
        /// <see cref="glBegin"/> 
        /// and the corresponding call to
        /// <see cref="glEnd"/> . 
        /// It is possible for an application to bind more than one
        /// attribute name to the same generic vertex attribute index. This
        /// is referred to as aliasing, and it is allowed only if just one
        /// of the aliased attribute variables is active in the vertex
        /// shader, or if no path through the vertex shader consumes more
        /// than one of the attributes aliased to the same location. OpenGL
        /// implementations are not required to do error checking to detect
        /// aliasing, they are allowed to assume that aliasing will not
        /// occur, and they are allowed to employ optimizations that work
        /// only in the absence of aliasing. 
        /// There is no provision for binding standard vertex
        /// attributes; therefore, it is not possible to alias generic
        /// attributes with standard attributes.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="index"/> is greater than or equal to
        /// <code>GL_MAX_VERTEX_ATTRIBS</code>.
        /// </para>
        /// Original: <para>void glVertexAttrib4Niv(GLuint index, const GLint * v);</para>
        /// </summary>
        /// <param name="index">
        /// <para>
        /// Specifies the index of the generic vertex
        /// attribute to be modified.
        /// </para>
        /// </param>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array of values to
        /// be used for the generic vertex attribute.
        /// </para>
        /// </param>
        /// <seealso cref="glBindAttribLocation"/>
        /// <seealso cref="glVertex"/>
        /// <seealso cref="glVertexAttribPointer"/>
        public unsafe static void glVertexAttrib4Niv(uint index, int* v) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttrib4Niv>("glVertexAttrib4Niv");
            _F(index, v);
        }
        /// <summary>
        /// Specifies the value of a generic vertex attribute
        /// <para>Require:</para> <para>GL_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glVertexAttrib"/> is available only if
        /// the GL version is 2.0 or greater. 
        /// Generic vertex attributes can be updated at any time. In
        /// particular, <see cref="glVertexAttrib"/> can be called
        /// between a call to
        /// <see cref="glBegin"/> 
        /// and the corresponding call to
        /// <see cref="glEnd"/> . 
        /// It is possible for an application to bind more than one
        /// attribute name to the same generic vertex attribute index. This
        /// is referred to as aliasing, and it is allowed only if just one
        /// of the aliased attribute variables is active in the vertex
        /// shader, or if no path through the vertex shader consumes more
        /// than one of the attributes aliased to the same location. OpenGL
        /// implementations are not required to do error checking to detect
        /// aliasing, they are allowed to assume that aliasing will not
        /// occur, and they are allowed to employ optimizations that work
        /// only in the absence of aliasing. 
        /// There is no provision for binding standard vertex
        /// attributes; therefore, it is not possible to alias generic
        /// attributes with standard attributes.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="index"/> is greater than or equal to
        /// <code>GL_MAX_VERTEX_ATTRIBS</code>.
        /// </para>
        /// Original: <para>void glVertexAttrib4Nsv(GLuint index, const GLshort * v);</para>
        /// </summary>
        /// <param name="index">
        /// <para>
        /// Specifies the index of the generic vertex
        /// attribute to be modified.
        /// </para>
        /// </param>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array of values to
        /// be used for the generic vertex attribute.
        /// </para>
        /// </param>
        /// <seealso cref="glBindAttribLocation"/>
        /// <seealso cref="glVertex"/>
        /// <seealso cref="glVertexAttribPointer"/>
        public unsafe static void glVertexAttrib4Nsv(uint index, short* v) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttrib4Nsv>("glVertexAttrib4Nsv");
            _F(index, v);
        }
        /// <summary>
        /// Specifies the value of a generic vertex attribute
        /// <para>Require:</para> <para>GL_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glVertexAttrib"/> is available only if
        /// the GL version is 2.0 or greater. 
        /// Generic vertex attributes can be updated at any time. In
        /// particular, <see cref="glVertexAttrib"/> can be called
        /// between a call to
        /// <see cref="glBegin"/> 
        /// and the corresponding call to
        /// <see cref="glEnd"/> . 
        /// It is possible for an application to bind more than one
        /// attribute name to the same generic vertex attribute index. This
        /// is referred to as aliasing, and it is allowed only if just one
        /// of the aliased attribute variables is active in the vertex
        /// shader, or if no path through the vertex shader consumes more
        /// than one of the attributes aliased to the same location. OpenGL
        /// implementations are not required to do error checking to detect
        /// aliasing, they are allowed to assume that aliasing will not
        /// occur, and they are allowed to employ optimizations that work
        /// only in the absence of aliasing. 
        /// There is no provision for binding standard vertex
        /// attributes; therefore, it is not possible to alias generic
        /// attributes with standard attributes.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="index"/> is greater than or equal to
        /// <code>GL_MAX_VERTEX_ATTRIBS</code>.
        /// </para>
        /// Original: <para>void glVertexAttrib4Nub(GLuint index, GLubyte v0, GLubyte v1, GLubyte v2, GLubyte v3);</para>
        /// </summary>
        /// <param name="index">
        /// <para>
        /// Specifies the index of the generic vertex
        /// attribute to be modified.
        /// </para>
        /// </param>
        /// <seealso cref="glBindAttribLocation"/>
        /// <seealso cref="glVertex"/>
        /// <seealso cref="glVertexAttribPointer"/>
        public static void glVertexAttrib4Nub(uint index, byte v0, byte v1, byte v2, byte v3) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttrib4Nub>("glVertexAttrib4Nub");
            _F(index, v0, v1, v2, v3);
        }
        /// <summary>
        /// Specifies the value of a generic vertex attribute
        /// <para>Require:</para> <para>GL_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glVertexAttrib"/> is available only if
        /// the GL version is 2.0 or greater. 
        /// Generic vertex attributes can be updated at any time. In
        /// particular, <see cref="glVertexAttrib"/> can be called
        /// between a call to
        /// <see cref="glBegin"/> 
        /// and the corresponding call to
        /// <see cref="glEnd"/> . 
        /// It is possible for an application to bind more than one
        /// attribute name to the same generic vertex attribute index. This
        /// is referred to as aliasing, and it is allowed only if just one
        /// of the aliased attribute variables is active in the vertex
        /// shader, or if no path through the vertex shader consumes more
        /// than one of the attributes aliased to the same location. OpenGL
        /// implementations are not required to do error checking to detect
        /// aliasing, they are allowed to assume that aliasing will not
        /// occur, and they are allowed to employ optimizations that work
        /// only in the absence of aliasing. 
        /// There is no provision for binding standard vertex
        /// attributes; therefore, it is not possible to alias generic
        /// attributes with standard attributes.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="index"/> is greater than or equal to
        /// <code>GL_MAX_VERTEX_ATTRIBS</code>.
        /// </para>
        /// Original: <para>void glVertexAttrib4Nubv(GLuint index, const GLubyte * v);</para>
        /// </summary>
        /// <param name="index">
        /// <para>
        /// Specifies the index of the generic vertex
        /// attribute to be modified.
        /// </para>
        /// </param>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array of values to
        /// be used for the generic vertex attribute.
        /// </para>
        /// </param>
        /// <seealso cref="glBindAttribLocation"/>
        /// <seealso cref="glVertex"/>
        /// <seealso cref="glVertexAttribPointer"/>
        public unsafe static void glVertexAttrib4Nubv(uint index, byte* v) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttrib4Nubv>("glVertexAttrib4Nubv");
            _F(index, v);
        }
        /// <summary>
        /// Specifies the value of a generic vertex attribute
        /// <para>Require:</para> <para>GL_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glVertexAttrib"/> is available only if
        /// the GL version is 2.0 or greater. 
        /// Generic vertex attributes can be updated at any time. In
        /// particular, <see cref="glVertexAttrib"/> can be called
        /// between a call to
        /// <see cref="glBegin"/> 
        /// and the corresponding call to
        /// <see cref="glEnd"/> . 
        /// It is possible for an application to bind more than one
        /// attribute name to the same generic vertex attribute index. This
        /// is referred to as aliasing, and it is allowed only if just one
        /// of the aliased attribute variables is active in the vertex
        /// shader, or if no path through the vertex shader consumes more
        /// than one of the attributes aliased to the same location. OpenGL
        /// implementations are not required to do error checking to detect
        /// aliasing, they are allowed to assume that aliasing will not
        /// occur, and they are allowed to employ optimizations that work
        /// only in the absence of aliasing. 
        /// There is no provision for binding standard vertex
        /// attributes; therefore, it is not possible to alias generic
        /// attributes with standard attributes.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="index"/> is greater than or equal to
        /// <code>GL_MAX_VERTEX_ATTRIBS</code>.
        /// </para>
        /// Original: <para>void glVertexAttrib4Nuiv(GLuint index, const GLuint * v);</para>
        /// </summary>
        /// <param name="index">
        /// <para>
        /// Specifies the index of the generic vertex
        /// attribute to be modified.
        /// </para>
        /// </param>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array of values to
        /// be used for the generic vertex attribute.
        /// </para>
        /// </param>
        /// <seealso cref="glBindAttribLocation"/>
        /// <seealso cref="glVertex"/>
        /// <seealso cref="glVertexAttribPointer"/>
        public unsafe static void glVertexAttrib4Nuiv(uint index, uint* v) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttrib4Nuiv>("glVertexAttrib4Nuiv");
            _F(index, v);
        }
        /// <summary>
        /// Specifies the value of a generic vertex attribute
        /// <para>Require:</para> <para>GL_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glVertexAttrib"/> is available only if
        /// the GL version is 2.0 or greater. 
        /// Generic vertex attributes can be updated at any time. In
        /// particular, <see cref="glVertexAttrib"/> can be called
        /// between a call to
        /// <see cref="glBegin"/> 
        /// and the corresponding call to
        /// <see cref="glEnd"/> . 
        /// It is possible for an application to bind more than one
        /// attribute name to the same generic vertex attribute index. This
        /// is referred to as aliasing, and it is allowed only if just one
        /// of the aliased attribute variables is active in the vertex
        /// shader, or if no path through the vertex shader consumes more
        /// than one of the attributes aliased to the same location. OpenGL
        /// implementations are not required to do error checking to detect
        /// aliasing, they are allowed to assume that aliasing will not
        /// occur, and they are allowed to employ optimizations that work
        /// only in the absence of aliasing. 
        /// There is no provision for binding standard vertex
        /// attributes; therefore, it is not possible to alias generic
        /// attributes with standard attributes.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="index"/> is greater than or equal to
        /// <code>GL_MAX_VERTEX_ATTRIBS</code>.
        /// </para>
        /// Original: <para>void glVertexAttrib4Nusv(GLuint index, const GLushort * v);</para>
        /// </summary>
        /// <param name="index">
        /// <para>
        /// Specifies the index of the generic vertex
        /// attribute to be modified.
        /// </para>
        /// </param>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array of values to
        /// be used for the generic vertex attribute.
        /// </para>
        /// </param>
        /// <seealso cref="glBindAttribLocation"/>
        /// <seealso cref="glVertex"/>
        /// <seealso cref="glVertexAttribPointer"/>
        public unsafe static void glVertexAttrib4Nusv(uint index, ushort* v) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttrib4Nusv>("glVertexAttrib4Nusv");
            _F(index, v);
        }
        /// <summary>
        /// Specifies the value of a generic vertex attribute
        /// <para>Require:</para> <para>GL_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glVertexAttrib"/> is available only if
        /// the GL version is 2.0 or greater. 
        /// Generic vertex attributes can be updated at any time. In
        /// particular, <see cref="glVertexAttrib"/> can be called
        /// between a call to
        /// <see cref="glBegin"/> 
        /// and the corresponding call to
        /// <see cref="glEnd"/> . 
        /// It is possible for an application to bind more than one
        /// attribute name to the same generic vertex attribute index. This
        /// is referred to as aliasing, and it is allowed only if just one
        /// of the aliased attribute variables is active in the vertex
        /// shader, or if no path through the vertex shader consumes more
        /// than one of the attributes aliased to the same location. OpenGL
        /// implementations are not required to do error checking to detect
        /// aliasing, they are allowed to assume that aliasing will not
        /// occur, and they are allowed to employ optimizations that work
        /// only in the absence of aliasing. 
        /// There is no provision for binding standard vertex
        /// attributes; therefore, it is not possible to alias generic
        /// attributes with standard attributes.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="index"/> is greater than or equal to
        /// <code>GL_MAX_VERTEX_ATTRIBS</code>.
        /// </para>
        /// Original: <para>void glVertexAttrib4bv(GLuint index, const GLbyte * v);</para>
        /// </summary>
        /// <param name="index">
        /// <para>
        /// Specifies the index of the generic vertex
        /// attribute to be modified.
        /// </para>
        /// </param>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array of values to
        /// be used for the generic vertex attribute.
        /// </para>
        /// </param>
        /// <seealso cref="glBindAttribLocation"/>
        /// <seealso cref="glVertex"/>
        /// <seealso cref="glVertexAttribPointer"/>
        public unsafe static void glVertexAttrib4bv(uint index, byte* v) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttrib4bv>("glVertexAttrib4bv");
            _F(index, v);
        }
        /// <summary>
        /// Specifies the value of a generic vertex attribute
        /// <para>Require:</para> <para>GL_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glVertexAttrib"/> is available only if
        /// the GL version is 2.0 or greater. 
        /// Generic vertex attributes can be updated at any time. In
        /// particular, <see cref="glVertexAttrib"/> can be called
        /// between a call to
        /// <see cref="glBegin"/> 
        /// and the corresponding call to
        /// <see cref="glEnd"/> . 
        /// It is possible for an application to bind more than one
        /// attribute name to the same generic vertex attribute index. This
        /// is referred to as aliasing, and it is allowed only if just one
        /// of the aliased attribute variables is active in the vertex
        /// shader, or if no path through the vertex shader consumes more
        /// than one of the attributes aliased to the same location. OpenGL
        /// implementations are not required to do error checking to detect
        /// aliasing, they are allowed to assume that aliasing will not
        /// occur, and they are allowed to employ optimizations that work
        /// only in the absence of aliasing. 
        /// There is no provision for binding standard vertex
        /// attributes; therefore, it is not possible to alias generic
        /// attributes with standard attributes.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="index"/> is greater than or equal to
        /// <code>GL_MAX_VERTEX_ATTRIBS</code>.
        /// </para>
        /// Original: <para>void glVertexAttrib4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3);</para>
        /// </summary>
        /// <param name="index">
        /// <para>
        /// Specifies the index of the generic vertex
        /// attribute to be modified.
        /// </para>
        /// </param>
        /// <seealso cref="glBindAttribLocation"/>
        /// <seealso cref="glVertex"/>
        /// <seealso cref="glVertexAttribPointer"/>
        public static void glVertexAttrib4d(uint index, double v0, double v1, double v2, double v3) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttrib4d>("glVertexAttrib4d");
            _F(index, v0, v1, v2, v3);
        }
        /// <summary>
        /// Specifies the value of a generic vertex attribute
        /// <para>Require:</para> <para>GL_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glVertexAttrib"/> is available only if
        /// the GL version is 2.0 or greater. 
        /// Generic vertex attributes can be updated at any time. In
        /// particular, <see cref="glVertexAttrib"/> can be called
        /// between a call to
        /// <see cref="glBegin"/> 
        /// and the corresponding call to
        /// <see cref="glEnd"/> . 
        /// It is possible for an application to bind more than one
        /// attribute name to the same generic vertex attribute index. This
        /// is referred to as aliasing, and it is allowed only if just one
        /// of the aliased attribute variables is active in the vertex
        /// shader, or if no path through the vertex shader consumes more
        /// than one of the attributes aliased to the same location. OpenGL
        /// implementations are not required to do error checking to detect
        /// aliasing, they are allowed to assume that aliasing will not
        /// occur, and they are allowed to employ optimizations that work
        /// only in the absence of aliasing. 
        /// There is no provision for binding standard vertex
        /// attributes; therefore, it is not possible to alias generic
        /// attributes with standard attributes.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="index"/> is greater than or equal to
        /// <code>GL_MAX_VERTEX_ATTRIBS</code>.
        /// </para>
        /// Original: <para>void glVertexAttrib4dv(GLuint index, const GLdouble * v);</para>
        /// </summary>
        /// <param name="index">
        /// <para>
        /// Specifies the index of the generic vertex
        /// attribute to be modified.
        /// </para>
        /// </param>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array of values to
        /// be used for the generic vertex attribute.
        /// </para>
        /// </param>
        /// <seealso cref="glBindAttribLocation"/>
        /// <seealso cref="glVertex"/>
        /// <seealso cref="glVertexAttribPointer"/>
        public unsafe static void glVertexAttrib4dv(uint index, double* v) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttrib4dv>("glVertexAttrib4dv");
            _F(index, v);
        }
        /// <summary>
        /// Specifies the value of a generic vertex attribute
        /// <para>Require:</para> <para>GL_VERSION_2_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glVertexAttrib"/> is available only if
        /// the GL version is 2.0 or greater. 
        /// Generic vertex attributes can be updated at any time. In
        /// particular, <see cref="glVertexAttrib"/> can be called
        /// between a call to
        /// <see cref="glBegin"/> 
        /// and the corresponding call to
        /// <see cref="glEnd"/> . 
        /// It is possible for an application to bind more than one
        /// attribute name to the same generic vertex attribute index. This
        /// is referred to as aliasing, and it is allowed only if just one
        /// of the aliased attribute variables is active in the vertex
        /// shader, or if no path through the vertex shader consumes more
        /// than one of the attributes aliased to the same location. OpenGL
        /// implementations are not required to do error checking to detect
        /// aliasing, they are allowed to assume that aliasing will not
        /// occur, and they are allowed to employ optimizations that work
        /// only in the absence of aliasing. 
        /// There is no provision for binding standard vertex
        /// attributes; therefore, it is not possible to alias generic
        /// attributes with standard attributes.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="index"/> is greater than or equal to
        /// <code>GL_MAX_VERTEX_ATTRIBS</code>.
        /// </para>
        /// Original: <para>void glVertexAttrib4f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3);</para>
        /// </summary>
        /// <param name="index">
        /// <para>
        /// Specifies the index of the generic vertex
        /// attribute to be modified.
        /// </para>
        /// </param>
        /// <seealso cref="glBindAttribLocation"/>
        /// <seealso cref="glVertex"/>
        /// <seealso cref="glVertexAttribPointer"/>
        public static void glVertexAttrib4f(uint index, float v0, float v1, float v2, float v3) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttrib4f>("glVertexAttrib4f");
            _F(index, v0, v1, v2, v3);
        }
        /// <summary>
        /// Specifies the value of a generic vertex attribute
        /// <para>Require:</para> <para>GL_VERSION_2_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glVertexAttrib"/> is available only if
        /// the GL version is 2.0 or greater. 
        /// Generic vertex attributes can be updated at any time. In
        /// particular, <see cref="glVertexAttrib"/> can be called
        /// between a call to
        /// <see cref="glBegin"/> 
        /// and the corresponding call to
        /// <see cref="glEnd"/> . 
        /// It is possible for an application to bind more than one
        /// attribute name to the same generic vertex attribute index. This
        /// is referred to as aliasing, and it is allowed only if just one
        /// of the aliased attribute variables is active in the vertex
        /// shader, or if no path through the vertex shader consumes more
        /// than one of the attributes aliased to the same location. OpenGL
        /// implementations are not required to do error checking to detect
        /// aliasing, they are allowed to assume that aliasing will not
        /// occur, and they are allowed to employ optimizations that work
        /// only in the absence of aliasing. 
        /// There is no provision for binding standard vertex
        /// attributes; therefore, it is not possible to alias generic
        /// attributes with standard attributes.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="index"/> is greater than or equal to
        /// <code>GL_MAX_VERTEX_ATTRIBS</code>.
        /// </para>
        /// Original: <para>void glVertexAttrib4fv(GLuint index, const GLfloat * v);</para>
        /// </summary>
        /// <param name="index">
        /// <para>
        /// Specifies the index of the generic vertex
        /// attribute to be modified.
        /// </para>
        /// </param>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array of values to
        /// be used for the generic vertex attribute.
        /// </para>
        /// </param>
        /// <seealso cref="glBindAttribLocation"/>
        /// <seealso cref="glVertex"/>
        /// <seealso cref="glVertexAttribPointer"/>
        public unsafe static void glVertexAttrib4fv(uint index, float* v) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttrib4fv>("glVertexAttrib4fv");
            _F(index, v);
        }
        /// <summary>
        /// Specifies the value of a generic vertex attribute
        /// <para>Require:</para> <para>GL_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glVertexAttrib"/> is available only if
        /// the GL version is 2.0 or greater. 
        /// Generic vertex attributes can be updated at any time. In
        /// particular, <see cref="glVertexAttrib"/> can be called
        /// between a call to
        /// <see cref="glBegin"/> 
        /// and the corresponding call to
        /// <see cref="glEnd"/> . 
        /// It is possible for an application to bind more than one
        /// attribute name to the same generic vertex attribute index. This
        /// is referred to as aliasing, and it is allowed only if just one
        /// of the aliased attribute variables is active in the vertex
        /// shader, or if no path through the vertex shader consumes more
        /// than one of the attributes aliased to the same location. OpenGL
        /// implementations are not required to do error checking to detect
        /// aliasing, they are allowed to assume that aliasing will not
        /// occur, and they are allowed to employ optimizations that work
        /// only in the absence of aliasing. 
        /// There is no provision for binding standard vertex
        /// attributes; therefore, it is not possible to alias generic
        /// attributes with standard attributes.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="index"/> is greater than or equal to
        /// <code>GL_MAX_VERTEX_ATTRIBS</code>.
        /// </para>
        /// Original: <para>void glVertexAttrib4iv(GLuint index, const GLint * v);</para>
        /// </summary>
        /// <param name="index">
        /// <para>
        /// Specifies the index of the generic vertex
        /// attribute to be modified.
        /// </para>
        /// </param>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array of values to
        /// be used for the generic vertex attribute.
        /// </para>
        /// </param>
        /// <seealso cref="glBindAttribLocation"/>
        /// <seealso cref="glVertex"/>
        /// <seealso cref="glVertexAttribPointer"/>
        public unsafe static void glVertexAttrib4iv(uint index, int* v) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttrib4iv>("glVertexAttrib4iv");
            _F(index, v);
        }
        /// <summary>
        /// Specifies the value of a generic vertex attribute
        /// <para>Require:</para> <para>GL_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glVertexAttrib"/> is available only if
        /// the GL version is 2.0 or greater. 
        /// Generic vertex attributes can be updated at any time. In
        /// particular, <see cref="glVertexAttrib"/> can be called
        /// between a call to
        /// <see cref="glBegin"/> 
        /// and the corresponding call to
        /// <see cref="glEnd"/> . 
        /// It is possible for an application to bind more than one
        /// attribute name to the same generic vertex attribute index. This
        /// is referred to as aliasing, and it is allowed only if just one
        /// of the aliased attribute variables is active in the vertex
        /// shader, or if no path through the vertex shader consumes more
        /// than one of the attributes aliased to the same location. OpenGL
        /// implementations are not required to do error checking to detect
        /// aliasing, they are allowed to assume that aliasing will not
        /// occur, and they are allowed to employ optimizations that work
        /// only in the absence of aliasing. 
        /// There is no provision for binding standard vertex
        /// attributes; therefore, it is not possible to alias generic
        /// attributes with standard attributes.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="index"/> is greater than or equal to
        /// <code>GL_MAX_VERTEX_ATTRIBS</code>.
        /// </para>
        /// Original: <para>void glVertexAttrib4s(GLuint index, GLshort v0, GLshort v1, GLshort v2, GLshort v3);</para>
        /// </summary>
        /// <param name="index">
        /// <para>
        /// Specifies the index of the generic vertex
        /// attribute to be modified.
        /// </para>
        /// </param>
        /// <seealso cref="glBindAttribLocation"/>
        /// <seealso cref="glVertex"/>
        /// <seealso cref="glVertexAttribPointer"/>
        public static void glVertexAttrib4s(uint index, short v0, short v1, short v2, short v3) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttrib4s>("glVertexAttrib4s");
            _F(index, v0, v1, v2, v3);
        }
        /// <summary>
        /// Specifies the value of a generic vertex attribute
        /// <para>Require:</para> <para>GL_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glVertexAttrib"/> is available only if
        /// the GL version is 2.0 or greater. 
        /// Generic vertex attributes can be updated at any time. In
        /// particular, <see cref="glVertexAttrib"/> can be called
        /// between a call to
        /// <see cref="glBegin"/> 
        /// and the corresponding call to
        /// <see cref="glEnd"/> . 
        /// It is possible for an application to bind more than one
        /// attribute name to the same generic vertex attribute index. This
        /// is referred to as aliasing, and it is allowed only if just one
        /// of the aliased attribute variables is active in the vertex
        /// shader, or if no path through the vertex shader consumes more
        /// than one of the attributes aliased to the same location. OpenGL
        /// implementations are not required to do error checking to detect
        /// aliasing, they are allowed to assume that aliasing will not
        /// occur, and they are allowed to employ optimizations that work
        /// only in the absence of aliasing. 
        /// There is no provision for binding standard vertex
        /// attributes; therefore, it is not possible to alias generic
        /// attributes with standard attributes.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="index"/> is greater than or equal to
        /// <code>GL_MAX_VERTEX_ATTRIBS</code>.
        /// </para>
        /// Original: <para>void glVertexAttrib4sv(GLuint index, const GLshort * v);</para>
        /// </summary>
        /// <param name="index">
        /// <para>
        /// Specifies the index of the generic vertex
        /// attribute to be modified.
        /// </para>
        /// </param>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array of values to
        /// be used for the generic vertex attribute.
        /// </para>
        /// </param>
        /// <seealso cref="glBindAttribLocation"/>
        /// <seealso cref="glVertex"/>
        /// <seealso cref="glVertexAttribPointer"/>
        public unsafe static void glVertexAttrib4sv(uint index, short* v) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttrib4sv>("glVertexAttrib4sv");
            _F(index, v);
        }
        /// <summary>
        /// Specifies the value of a generic vertex attribute
        /// <para>Require:</para> <para>GL_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glVertexAttrib"/> is available only if
        /// the GL version is 2.0 or greater. 
        /// Generic vertex attributes can be updated at any time. In
        /// particular, <see cref="glVertexAttrib"/> can be called
        /// between a call to
        /// <see cref="glBegin"/> 
        /// and the corresponding call to
        /// <see cref="glEnd"/> . 
        /// It is possible for an application to bind more than one
        /// attribute name to the same generic vertex attribute index. This
        /// is referred to as aliasing, and it is allowed only if just one
        /// of the aliased attribute variables is active in the vertex
        /// shader, or if no path through the vertex shader consumes more
        /// than one of the attributes aliased to the same location. OpenGL
        /// implementations are not required to do error checking to detect
        /// aliasing, they are allowed to assume that aliasing will not
        /// occur, and they are allowed to employ optimizations that work
        /// only in the absence of aliasing. 
        /// There is no provision for binding standard vertex
        /// attributes; therefore, it is not possible to alias generic
        /// attributes with standard attributes.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="index"/> is greater than or equal to
        /// <code>GL_MAX_VERTEX_ATTRIBS</code>.
        /// </para>
        /// Original: <para>void glVertexAttrib4ubv(GLuint index, const GLubyte * v);</para>
        /// </summary>
        /// <param name="index">
        /// <para>
        /// Specifies the index of the generic vertex
        /// attribute to be modified.
        /// </para>
        /// </param>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array of values to
        /// be used for the generic vertex attribute.
        /// </para>
        /// </param>
        /// <seealso cref="glBindAttribLocation"/>
        /// <seealso cref="glVertex"/>
        /// <seealso cref="glVertexAttribPointer"/>
        public unsafe static void glVertexAttrib4ubv(uint index, byte* v) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttrib4ubv>("glVertexAttrib4ubv");
            _F(index, v);
        }
        /// <summary>
        /// Specifies the value of a generic vertex attribute
        /// <para>Require:</para> <para>GL_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glVertexAttrib"/> is available only if
        /// the GL version is 2.0 or greater. 
        /// Generic vertex attributes can be updated at any time. In
        /// particular, <see cref="glVertexAttrib"/> can be called
        /// between a call to
        /// <see cref="glBegin"/> 
        /// and the corresponding call to
        /// <see cref="glEnd"/> . 
        /// It is possible for an application to bind more than one
        /// attribute name to the same generic vertex attribute index. This
        /// is referred to as aliasing, and it is allowed only if just one
        /// of the aliased attribute variables is active in the vertex
        /// shader, or if no path through the vertex shader consumes more
        /// than one of the attributes aliased to the same location. OpenGL
        /// implementations are not required to do error checking to detect
        /// aliasing, they are allowed to assume that aliasing will not
        /// occur, and they are allowed to employ optimizations that work
        /// only in the absence of aliasing. 
        /// There is no provision for binding standard vertex
        /// attributes; therefore, it is not possible to alias generic
        /// attributes with standard attributes.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="index"/> is greater than or equal to
        /// <code>GL_MAX_VERTEX_ATTRIBS</code>.
        /// </para>
        /// Original: <para>void glVertexAttrib4uiv(GLuint index, const GLuint * v);</para>
        /// </summary>
        /// <param name="index">
        /// <para>
        /// Specifies the index of the generic vertex
        /// attribute to be modified.
        /// </para>
        /// </param>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array of values to
        /// be used for the generic vertex attribute.
        /// </para>
        /// </param>
        /// <seealso cref="glBindAttribLocation"/>
        /// <seealso cref="glVertex"/>
        /// <seealso cref="glVertexAttribPointer"/>
        public unsafe static void glVertexAttrib4uiv(uint index, uint* v) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttrib4uiv>("glVertexAttrib4uiv");
            _F(index, v);
        }
        /// <summary>
        /// Specifies the value of a generic vertex attribute
        /// <para>Require:</para> <para>GL_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glVertexAttrib"/> is available only if
        /// the GL version is 2.0 or greater. 
        /// Generic vertex attributes can be updated at any time. In
        /// particular, <see cref="glVertexAttrib"/> can be called
        /// between a call to
        /// <see cref="glBegin"/> 
        /// and the corresponding call to
        /// <see cref="glEnd"/> . 
        /// It is possible for an application to bind more than one
        /// attribute name to the same generic vertex attribute index. This
        /// is referred to as aliasing, and it is allowed only if just one
        /// of the aliased attribute variables is active in the vertex
        /// shader, or if no path through the vertex shader consumes more
        /// than one of the attributes aliased to the same location. OpenGL
        /// implementations are not required to do error checking to detect
        /// aliasing, they are allowed to assume that aliasing will not
        /// occur, and they are allowed to employ optimizations that work
        /// only in the absence of aliasing. 
        /// There is no provision for binding standard vertex
        /// attributes; therefore, it is not possible to alias generic
        /// attributes with standard attributes.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="index"/> is greater than or equal to
        /// <code>GL_MAX_VERTEX_ATTRIBS</code>.
        /// </para>
        /// Original: <para>void glVertexAttrib4usv(GLuint index, const GLushort * v);</para>
        /// </summary>
        /// <param name="index">
        /// <para>
        /// Specifies the index of the generic vertex
        /// attribute to be modified.
        /// </para>
        /// </param>
        /// <param name="v">
        /// <para>
        /// Specifies a pointer to an array of values to
        /// be used for the generic vertex attribute.
        /// </para>
        /// </param>
        /// <seealso cref="glBindAttribLocation"/>
        /// <seealso cref="glVertex"/>
        /// <seealso cref="glVertexAttribPointer"/>
        public unsafe static void glVertexAttrib4usv(uint index, ushort* v) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttrib4usv>("glVertexAttrib4usv");
            _F(index, v);
        }
        /// <summary>
        /// define an array of generic vertex attribute data
        /// <para>Require:</para> <para>GL_VERSION_2_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glVertexAttribPointer"/> is available
        /// only if the GL version is 2.0 or greater. 
        /// Each generic vertex attribute array is initially disabled
        /// and isn't accessed when
        /// <see cref="glArrayElement"/> ,  <see cref="glDrawElements"/> ,  <see cref="glDrawRangeElements"/> ,
        /// <see cref="glDrawArrays"/> ,  <see cref="glMultiDrawArrays"/> , or  <see cref="glMultiDrawElements"/> 
        /// is called. 
        /// Execution of <see cref="glVertexAttribPointer"/> is
        /// not allowed between the execution of
        /// <see cref="glBegin"/> 
        /// and the corresponding execution of
        /// <see cref="glEnd"/> ,
        /// but an error may or may not be generated. If no error is
        /// generated, the operation is undefined. 
        /// <see cref="glVertexAttribPointer"/> is typically
        /// implemented on the client side. 
        /// Generic vertex attribute array parameters are client-side
        /// state and are therefore not saved or restored by
        /// <see cref="glPushAttrib"/> 
        /// and
        /// <see cref="glPopAttrib"/> .
        /// Use
        /// <see cref="glPushClientAttrib"/> 
        /// and
        /// <see cref="glPopClientAttrib"/> 
        /// instead.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="index"/> is greater than or equal to
        /// <code>GL_MAX_VERTEX_ATTRIBS</code>. 
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="size"/> is not 1, 2, 3, or 4. 
        /// <code>GL_INVALID_ENUM</code> is generated if
        /// <paramref name="type"/> is not an accepted value. 
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="stride"/> is negative.
        /// </para>
        /// Original: <para>void glVertexAttribPointer(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const void * pointer);</para>
        /// </summary>
        /// <param name="index">
        /// <para>
        /// Specifies the index of the generic vertex
        /// attribute to be modified.
        /// </para>
        /// </param>
        /// <param name="size">
        /// <para>
        /// Specifies the number of components per
        /// generic vertex attribute. Must
        /// be 1, 2, 3, or 4. The initial value is 4.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the data type of each component in
        /// the array. Symbolic constants
        /// <code>GL_BYTE</code>,
        /// <code>GL_UNSIGNED_BYTE</code>,
        /// <code>GL_SHORT</code>,
        /// <code>GL_UNSIGNED_SHORT</code>,
        /// <code>GL_INT</code>,
        /// <code>GL_UNSIGNED_INT</code>,
        /// <code>GL_FLOAT</code>, or
        /// <code>GL_DOUBLE</code> are
        /// accepted. The initial value is <code>GL_FLOAT</code>.
        /// </para>
        /// </param>
        /// <param name="normalized">
        /// <para>
        /// Specifies whether fixed-point data values
        /// should be normalized (<code>GL_TRUE</code>)
        /// or converted directly as fixed-point values
        /// (<code>GL_FALSE</code>) when they are
        /// accessed.
        /// </para>
        /// </param>
        /// <param name="stride">
        /// <para>
        /// Specifies the byte offset between consecutive
        /// generic vertex attributes. If <paramref name="stride"/>
        /// is 0, the generic vertex attributes are
        /// understood to be tightly packed in the
        /// array. The initial value is 0.
        /// </para>
        /// </param>
        /// <param name="pointer">
        /// <para>
        /// Specifies a pointer to the first component of
        /// the first generic vertex attribute in the array. The initial value is 0.
        /// </para>
        /// </param>
        /// <seealso cref="glArrayElement"/>
        /// <seealso cref="glBindAttribLocation"/>
        /// <seealso cref="glBindBuffer"/>
        /// <seealso cref="glColorPointer"/>
        /// <seealso cref="glDisableVertexAttribArray"/>
        /// <seealso cref="glDrawArrays"/>
        /// <seealso cref="glDrawElements"/>
        /// <seealso cref="glDrawRangeElements"/>
        /// <seealso cref="glEnableVertexAttribArray"/>
        /// <seealso cref="glEdgeFlagPointer"/>
        /// <seealso cref="glFogCoordPointer"/>
        /// <seealso cref="glIndexPointer"/>
        /// <seealso cref="glInterleavedArrays"/>
        /// <seealso cref="glMultiDrawArrays"/>
        /// <seealso cref="glMultiDrawElements"/>
        /// <seealso cref="glNormalPointer"/>
        /// <seealso cref="glPopClientAttrib"/>
        /// <seealso cref="glPushClientAttrib"/>
        /// <seealso cref="glSecondaryColorPointer"/>
        /// <seealso cref="glTexCoordPointer"/>
        /// <seealso cref="glVertexAttrib"/>
        /// <seealso cref="glVertexPointer"/>
        public unsafe static void glVertexAttribPointer(uint index, int size, uint type, bool normalized, int stride, void* pointer) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttribPointer>("glVertexAttribPointer");
            _F(index, size, type, normalized, stride, pointer);
        }

        #endregion GL_VERSION_2_0

        #region GL_VERSION_2_1

        /// <summary>
        /// Specify the value of a uniform variable for the current program object
        /// <para>Require:</para> <para>GL_VERSION_2_1, GL_ES_VERSION_3_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glUniform"/> is available only if the GL
        /// version is 2.0 or greater. 
        /// <see cref="glUniformMatrix{2x3|3x2|2x4|4x2|3x4|4x3}fv"/> 
        /// is available only if the GL version is 2.1 or greater. 
        /// <see cref="glUniform1i"/> and
        /// <see cref="glUniform1iv"/> are the only two functions
        /// that may be used to load uniform variables defined as sampler
        /// types. Loading samplers with any other function will result in a
        /// <code>GL_INVALID_OPERATION</code> error. 
        /// If <paramref name="count"/> is greater than 1 and the
        /// indicated uniform variable is not an array, a
        /// <code>GL_INVALID_OPERATION</code> error is generated and the
        /// specified uniform variable will remain unchanged. 
        /// Other than the preceding exceptions, if the type and size
        /// of the uniform variable as defined in the shader do not match
        /// the type and size specified in the name of the command used to
        /// load its value, a <code>GL_INVALID_OPERATION</code> error will
        /// be generated and the specified uniform variable will remain
        /// unchanged. 
        /// If <paramref name="location"/> is a value other than
        /// -1 and it does not represent a valid uniform variable location
        /// in the current program object, an error will be generated, and
        /// no changes will be made to the uniform variable storage of the
        /// current program object. If <paramref name="location"/> is
        /// equal to -1, the data passed in will be silently ignored and the
        /// specified uniform variable will not be changed.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if there
        /// is no current program object. 
        /// <code>GL_INVALID_OPERATION</code> is generated if the
        /// size of the uniform variable declared in the shader does not
        /// match the size indicated by the <see cref="glUniform"/>
        /// command. 
        /// <code>GL_INVALID_OPERATION</code> is generated if one of
        /// the integer variants of this function is used to load a uniform
        /// variable of type float, vec2, vec3, vec4, or an array of these,
        /// or if one of the floating-point variants of this function is
        /// used to load a uniform variable of type int, ivec2, ivec3, or
        /// ivec4, or an array of these. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <paramref name="location"/> is an invalid uniform location
        /// for the current program object and
        /// <paramref name="location"/> is not equal to -1. 
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="count"/> is less than 0. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <paramref name="count"/> is greater than 1 and the indicated
        /// uniform variable is not an array variable. 
        /// <code>GL_INVALID_OPERATION</code> is generated if a
        /// sampler is loaded using a command other than
        /// <see cref="glUniform1i"/> and
        /// <see cref="glUniform1iv"/>. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <see cref="glUniform"/> is executed between the execution
        /// of
        /// <see cref="glBegin"/> 
        /// and the corresponding execution of
        /// <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glUniformMatrix2x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);</para>
        /// </summary>
        /// <param name="location">
        /// <para>
        /// Specifies the location of the uniform value to
        /// be modified.
        /// </para>
        /// </param>
        /// <param name="count">
        /// <para>
        /// Specifies the number of matrices that are to
        /// be modified. This should be 1 if the targeted
        /// uniform variable is not an array of matrices, and 1 or more if it is
        /// an array of matrices.
        /// </para>
        /// </param>
        /// <param name="transpose">
        /// <para>
        /// Specifies whether to transpose the matrix as
        /// the values are loaded into the uniform
        /// variable.
        /// </para>
        /// </param>
        /// <param name="value">
        /// <para>
        /// Specifies a pointer to an array of
        /// <paramref name="count"/> values that will be
        /// used to update the specified uniform
        /// variable.
        /// </para>
        /// </param>
        /// <seealso cref="glLinkProgram"/>
        /// <seealso cref="glUseProgram"/>
        public unsafe static void glUniformMatrix2x3fv(int location, int count, bool transpose, float* value) {
            var _F = _GetProc<GLNativeDelegate.FNglUniformMatrix2x3fv>("glUniformMatrix2x3fv");
            _F(location, count, transpose, value);
        }
        /// <summary>
        /// Specify the value of a uniform variable for the current program object
        /// <para>Require:</para> <para>GL_VERSION_2_1, GL_ES_VERSION_3_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glUniform"/> is available only if the GL
        /// version is 2.0 or greater. 
        /// <see cref="glUniformMatrix{2x3|3x2|2x4|4x2|3x4|4x3}fv"/> 
        /// is available only if the GL version is 2.1 or greater. 
        /// <see cref="glUniform1i"/> and
        /// <see cref="glUniform1iv"/> are the only two functions
        /// that may be used to load uniform variables defined as sampler
        /// types. Loading samplers with any other function will result in a
        /// <code>GL_INVALID_OPERATION</code> error. 
        /// If <paramref name="count"/> is greater than 1 and the
        /// indicated uniform variable is not an array, a
        /// <code>GL_INVALID_OPERATION</code> error is generated and the
        /// specified uniform variable will remain unchanged. 
        /// Other than the preceding exceptions, if the type and size
        /// of the uniform variable as defined in the shader do not match
        /// the type and size specified in the name of the command used to
        /// load its value, a <code>GL_INVALID_OPERATION</code> error will
        /// be generated and the specified uniform variable will remain
        /// unchanged. 
        /// If <paramref name="location"/> is a value other than
        /// -1 and it does not represent a valid uniform variable location
        /// in the current program object, an error will be generated, and
        /// no changes will be made to the uniform variable storage of the
        /// current program object. If <paramref name="location"/> is
        /// equal to -1, the data passed in will be silently ignored and the
        /// specified uniform variable will not be changed.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if there
        /// is no current program object. 
        /// <code>GL_INVALID_OPERATION</code> is generated if the
        /// size of the uniform variable declared in the shader does not
        /// match the size indicated by the <see cref="glUniform"/>
        /// command. 
        /// <code>GL_INVALID_OPERATION</code> is generated if one of
        /// the integer variants of this function is used to load a uniform
        /// variable of type float, vec2, vec3, vec4, or an array of these,
        /// or if one of the floating-point variants of this function is
        /// used to load a uniform variable of type int, ivec2, ivec3, or
        /// ivec4, or an array of these. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <paramref name="location"/> is an invalid uniform location
        /// for the current program object and
        /// <paramref name="location"/> is not equal to -1. 
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="count"/> is less than 0. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <paramref name="count"/> is greater than 1 and the indicated
        /// uniform variable is not an array variable. 
        /// <code>GL_INVALID_OPERATION</code> is generated if a
        /// sampler is loaded using a command other than
        /// <see cref="glUniform1i"/> and
        /// <see cref="glUniform1iv"/>. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <see cref="glUniform"/> is executed between the execution
        /// of
        /// <see cref="glBegin"/> 
        /// and the corresponding execution of
        /// <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glUniformMatrix3x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);</para>
        /// </summary>
        /// <param name="location">
        /// <para>
        /// Specifies the location of the uniform value to
        /// be modified.
        /// </para>
        /// </param>
        /// <param name="count">
        /// <para>
        /// Specifies the number of matrices that are to
        /// be modified. This should be 1 if the targeted
        /// uniform variable is not an array of matrices, and 1 or more if it is
        /// an array of matrices.
        /// </para>
        /// </param>
        /// <param name="transpose">
        /// <para>
        /// Specifies whether to transpose the matrix as
        /// the values are loaded into the uniform
        /// variable.
        /// </para>
        /// </param>
        /// <param name="value">
        /// <para>
        /// Specifies a pointer to an array of
        /// <paramref name="count"/> values that will be
        /// used to update the specified uniform
        /// variable.
        /// </para>
        /// </param>
        /// <seealso cref="glLinkProgram"/>
        /// <seealso cref="glUseProgram"/>
        public unsafe static void glUniformMatrix3x2fv(int location, int count, bool transpose, float* value) {
            var _F = _GetProc<GLNativeDelegate.FNglUniformMatrix3x2fv>("glUniformMatrix3x2fv");
            _F(location, count, transpose, value);
        }
        /// <summary>
        /// Specify the value of a uniform variable for the current program object
        /// <para>Require:</para> <para>GL_VERSION_2_1, GL_ES_VERSION_3_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glUniform"/> is available only if the GL
        /// version is 2.0 or greater. 
        /// <see cref="glUniformMatrix{2x3|3x2|2x4|4x2|3x4|4x3}fv"/> 
        /// is available only if the GL version is 2.1 or greater. 
        /// <see cref="glUniform1i"/> and
        /// <see cref="glUniform1iv"/> are the only two functions
        /// that may be used to load uniform variables defined as sampler
        /// types. Loading samplers with any other function will result in a
        /// <code>GL_INVALID_OPERATION</code> error. 
        /// If <paramref name="count"/> is greater than 1 and the
        /// indicated uniform variable is not an array, a
        /// <code>GL_INVALID_OPERATION</code> error is generated and the
        /// specified uniform variable will remain unchanged. 
        /// Other than the preceding exceptions, if the type and size
        /// of the uniform variable as defined in the shader do not match
        /// the type and size specified in the name of the command used to
        /// load its value, a <code>GL_INVALID_OPERATION</code> error will
        /// be generated and the specified uniform variable will remain
        /// unchanged. 
        /// If <paramref name="location"/> is a value other than
        /// -1 and it does not represent a valid uniform variable location
        /// in the current program object, an error will be generated, and
        /// no changes will be made to the uniform variable storage of the
        /// current program object. If <paramref name="location"/> is
        /// equal to -1, the data passed in will be silently ignored and the
        /// specified uniform variable will not be changed.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if there
        /// is no current program object. 
        /// <code>GL_INVALID_OPERATION</code> is generated if the
        /// size of the uniform variable declared in the shader does not
        /// match the size indicated by the <see cref="glUniform"/>
        /// command. 
        /// <code>GL_INVALID_OPERATION</code> is generated if one of
        /// the integer variants of this function is used to load a uniform
        /// variable of type float, vec2, vec3, vec4, or an array of these,
        /// or if one of the floating-point variants of this function is
        /// used to load a uniform variable of type int, ivec2, ivec3, or
        /// ivec4, or an array of these. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <paramref name="location"/> is an invalid uniform location
        /// for the current program object and
        /// <paramref name="location"/> is not equal to -1. 
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="count"/> is less than 0. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <paramref name="count"/> is greater than 1 and the indicated
        /// uniform variable is not an array variable. 
        /// <code>GL_INVALID_OPERATION</code> is generated if a
        /// sampler is loaded using a command other than
        /// <see cref="glUniform1i"/> and
        /// <see cref="glUniform1iv"/>. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <see cref="glUniform"/> is executed between the execution
        /// of
        /// <see cref="glBegin"/> 
        /// and the corresponding execution of
        /// <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glUniformMatrix2x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);</para>
        /// </summary>
        /// <param name="location">
        /// <para>
        /// Specifies the location of the uniform value to
        /// be modified.
        /// </para>
        /// </param>
        /// <param name="count">
        /// <para>
        /// Specifies the number of matrices that are to
        /// be modified. This should be 1 if the targeted
        /// uniform variable is not an array of matrices, and 1 or more if it is
        /// an array of matrices.
        /// </para>
        /// </param>
        /// <param name="transpose">
        /// <para>
        /// Specifies whether to transpose the matrix as
        /// the values are loaded into the uniform
        /// variable.
        /// </para>
        /// </param>
        /// <param name="value">
        /// <para>
        /// Specifies a pointer to an array of
        /// <paramref name="count"/> values that will be
        /// used to update the specified uniform
        /// variable.
        /// </para>
        /// </param>
        /// <seealso cref="glLinkProgram"/>
        /// <seealso cref="glUseProgram"/>
        public unsafe static void glUniformMatrix2x4fv(int location, int count, bool transpose, float* value) {
            var _F = _GetProc<GLNativeDelegate.FNglUniformMatrix2x4fv>("glUniformMatrix2x4fv");
            _F(location, count, transpose, value);
        }
        /// <summary>
        /// Specify the value of a uniform variable for the current program object
        /// <para>Require:</para> <para>GL_VERSION_2_1, GL_ES_VERSION_3_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glUniform"/> is available only if the GL
        /// version is 2.0 or greater. 
        /// <see cref="glUniformMatrix{2x3|3x2|2x4|4x2|3x4|4x3}fv"/> 
        /// is available only if the GL version is 2.1 or greater. 
        /// <see cref="glUniform1i"/> and
        /// <see cref="glUniform1iv"/> are the only two functions
        /// that may be used to load uniform variables defined as sampler
        /// types. Loading samplers with any other function will result in a
        /// <code>GL_INVALID_OPERATION</code> error. 
        /// If <paramref name="count"/> is greater than 1 and the
        /// indicated uniform variable is not an array, a
        /// <code>GL_INVALID_OPERATION</code> error is generated and the
        /// specified uniform variable will remain unchanged. 
        /// Other than the preceding exceptions, if the type and size
        /// of the uniform variable as defined in the shader do not match
        /// the type and size specified in the name of the command used to
        /// load its value, a <code>GL_INVALID_OPERATION</code> error will
        /// be generated and the specified uniform variable will remain
        /// unchanged. 
        /// If <paramref name="location"/> is a value other than
        /// -1 and it does not represent a valid uniform variable location
        /// in the current program object, an error will be generated, and
        /// no changes will be made to the uniform variable storage of the
        /// current program object. If <paramref name="location"/> is
        /// equal to -1, the data passed in will be silently ignored and the
        /// specified uniform variable will not be changed.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if there
        /// is no current program object. 
        /// <code>GL_INVALID_OPERATION</code> is generated if the
        /// size of the uniform variable declared in the shader does not
        /// match the size indicated by the <see cref="glUniform"/>
        /// command. 
        /// <code>GL_INVALID_OPERATION</code> is generated if one of
        /// the integer variants of this function is used to load a uniform
        /// variable of type float, vec2, vec3, vec4, or an array of these,
        /// or if one of the floating-point variants of this function is
        /// used to load a uniform variable of type int, ivec2, ivec3, or
        /// ivec4, or an array of these. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <paramref name="location"/> is an invalid uniform location
        /// for the current program object and
        /// <paramref name="location"/> is not equal to -1. 
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="count"/> is less than 0. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <paramref name="count"/> is greater than 1 and the indicated
        /// uniform variable is not an array variable. 
        /// <code>GL_INVALID_OPERATION</code> is generated if a
        /// sampler is loaded using a command other than
        /// <see cref="glUniform1i"/> and
        /// <see cref="glUniform1iv"/>. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <see cref="glUniform"/> is executed between the execution
        /// of
        /// <see cref="glBegin"/> 
        /// and the corresponding execution of
        /// <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glUniformMatrix4x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);</para>
        /// </summary>
        /// <param name="location">
        /// <para>
        /// Specifies the location of the uniform value to
        /// be modified.
        /// </para>
        /// </param>
        /// <param name="count">
        /// <para>
        /// Specifies the number of matrices that are to
        /// be modified. This should be 1 if the targeted
        /// uniform variable is not an array of matrices, and 1 or more if it is
        /// an array of matrices.
        /// </para>
        /// </param>
        /// <param name="transpose">
        /// <para>
        /// Specifies whether to transpose the matrix as
        /// the values are loaded into the uniform
        /// variable.
        /// </para>
        /// </param>
        /// <param name="value">
        /// <para>
        /// Specifies a pointer to an array of
        /// <paramref name="count"/> values that will be
        /// used to update the specified uniform
        /// variable.
        /// </para>
        /// </param>
        /// <seealso cref="glLinkProgram"/>
        /// <seealso cref="glUseProgram"/>
        public unsafe static void glUniformMatrix4x2fv(int location, int count, bool transpose, float* value) {
            var _F = _GetProc<GLNativeDelegate.FNglUniformMatrix4x2fv>("glUniformMatrix4x2fv");
            _F(location, count, transpose, value);
        }
        /// <summary>
        /// Specify the value of a uniform variable for the current program object
        /// <para>Require:</para> <para>GL_VERSION_2_1, GL_ES_VERSION_3_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glUniform"/> is available only if the GL
        /// version is 2.0 or greater. 
        /// <see cref="glUniformMatrix{2x3|3x2|2x4|4x2|3x4|4x3}fv"/> 
        /// is available only if the GL version is 2.1 or greater. 
        /// <see cref="glUniform1i"/> and
        /// <see cref="glUniform1iv"/> are the only two functions
        /// that may be used to load uniform variables defined as sampler
        /// types. Loading samplers with any other function will result in a
        /// <code>GL_INVALID_OPERATION</code> error. 
        /// If <paramref name="count"/> is greater than 1 and the
        /// indicated uniform variable is not an array, a
        /// <code>GL_INVALID_OPERATION</code> error is generated and the
        /// specified uniform variable will remain unchanged. 
        /// Other than the preceding exceptions, if the type and size
        /// of the uniform variable as defined in the shader do not match
        /// the type and size specified in the name of the command used to
        /// load its value, a <code>GL_INVALID_OPERATION</code> error will
        /// be generated and the specified uniform variable will remain
        /// unchanged. 
        /// If <paramref name="location"/> is a value other than
        /// -1 and it does not represent a valid uniform variable location
        /// in the current program object, an error will be generated, and
        /// no changes will be made to the uniform variable storage of the
        /// current program object. If <paramref name="location"/> is
        /// equal to -1, the data passed in will be silently ignored and the
        /// specified uniform variable will not be changed.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if there
        /// is no current program object. 
        /// <code>GL_INVALID_OPERATION</code> is generated if the
        /// size of the uniform variable declared in the shader does not
        /// match the size indicated by the <see cref="glUniform"/>
        /// command. 
        /// <code>GL_INVALID_OPERATION</code> is generated if one of
        /// the integer variants of this function is used to load a uniform
        /// variable of type float, vec2, vec3, vec4, or an array of these,
        /// or if one of the floating-point variants of this function is
        /// used to load a uniform variable of type int, ivec2, ivec3, or
        /// ivec4, or an array of these. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <paramref name="location"/> is an invalid uniform location
        /// for the current program object and
        /// <paramref name="location"/> is not equal to -1. 
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="count"/> is less than 0. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <paramref name="count"/> is greater than 1 and the indicated
        /// uniform variable is not an array variable. 
        /// <code>GL_INVALID_OPERATION</code> is generated if a
        /// sampler is loaded using a command other than
        /// <see cref="glUniform1i"/> and
        /// <see cref="glUniform1iv"/>. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <see cref="glUniform"/> is executed between the execution
        /// of
        /// <see cref="glBegin"/> 
        /// and the corresponding execution of
        /// <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glUniformMatrix3x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);</para>
        /// </summary>
        /// <param name="location">
        /// <para>
        /// Specifies the location of the uniform value to
        /// be modified.
        /// </para>
        /// </param>
        /// <param name="count">
        /// <para>
        /// Specifies the number of matrices that are to
        /// be modified. This should be 1 if the targeted
        /// uniform variable is not an array of matrices, and 1 or more if it is
        /// an array of matrices.
        /// </para>
        /// </param>
        /// <param name="transpose">
        /// <para>
        /// Specifies whether to transpose the matrix as
        /// the values are loaded into the uniform
        /// variable.
        /// </para>
        /// </param>
        /// <param name="value">
        /// <para>
        /// Specifies a pointer to an array of
        /// <paramref name="count"/> values that will be
        /// used to update the specified uniform
        /// variable.
        /// </para>
        /// </param>
        /// <seealso cref="glLinkProgram"/>
        /// <seealso cref="glUseProgram"/>
        public unsafe static void glUniformMatrix3x4fv(int location, int count, bool transpose, float* value) {
            var _F = _GetProc<GLNativeDelegate.FNglUniformMatrix3x4fv>("glUniformMatrix3x4fv");
            _F(location, count, transpose, value);
        }
        /// <summary>
        /// Specify the value of a uniform variable for the current program object
        /// <para>Require:</para> <para>GL_VERSION_2_1, GL_ES_VERSION_3_0</para>
        /// Supported: <para>GL</para>
        /// Notes: 
        /// <para>
        /// <see cref="glUniform"/> is available only if the GL
        /// version is 2.0 or greater. 
        /// <see cref="glUniformMatrix{2x3|3x2|2x4|4x2|3x4|4x3}fv"/> 
        /// is available only if the GL version is 2.1 or greater. 
        /// <see cref="glUniform1i"/> and
        /// <see cref="glUniform1iv"/> are the only two functions
        /// that may be used to load uniform variables defined as sampler
        /// types. Loading samplers with any other function will result in a
        /// <code>GL_INVALID_OPERATION</code> error. 
        /// If <paramref name="count"/> is greater than 1 and the
        /// indicated uniform variable is not an array, a
        /// <code>GL_INVALID_OPERATION</code> error is generated and the
        /// specified uniform variable will remain unchanged. 
        /// Other than the preceding exceptions, if the type and size
        /// of the uniform variable as defined in the shader do not match
        /// the type and size specified in the name of the command used to
        /// load its value, a <code>GL_INVALID_OPERATION</code> error will
        /// be generated and the specified uniform variable will remain
        /// unchanged. 
        /// If <paramref name="location"/> is a value other than
        /// -1 and it does not represent a valid uniform variable location
        /// in the current program object, an error will be generated, and
        /// no changes will be made to the uniform variable storage of the
        /// current program object. If <paramref name="location"/> is
        /// equal to -1, the data passed in will be silently ignored and the
        /// specified uniform variable will not be changed.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_OPERATION</code> is generated if there
        /// is no current program object. 
        /// <code>GL_INVALID_OPERATION</code> is generated if the
        /// size of the uniform variable declared in the shader does not
        /// match the size indicated by the <see cref="glUniform"/>
        /// command. 
        /// <code>GL_INVALID_OPERATION</code> is generated if one of
        /// the integer variants of this function is used to load a uniform
        /// variable of type float, vec2, vec3, vec4, or an array of these,
        /// or if one of the floating-point variants of this function is
        /// used to load a uniform variable of type int, ivec2, ivec3, or
        /// ivec4, or an array of these. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <paramref name="location"/> is an invalid uniform location
        /// for the current program object and
        /// <paramref name="location"/> is not equal to -1. 
        /// <code>GL_INVALID_VALUE</code> is generated if
        /// <paramref name="count"/> is less than 0. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <paramref name="count"/> is greater than 1 and the indicated
        /// uniform variable is not an array variable. 
        /// <code>GL_INVALID_OPERATION</code> is generated if a
        /// sampler is loaded using a command other than
        /// <see cref="glUniform1i"/> and
        /// <see cref="glUniform1iv"/>. 
        /// <code>GL_INVALID_OPERATION</code> is generated if
        /// <see cref="glUniform"/> is executed between the execution
        /// of
        /// <see cref="glBegin"/> 
        /// and the corresponding execution of
        /// <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glUniformMatrix4x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);</para>
        /// </summary>
        /// <param name="location">
        /// <para>
        /// Specifies the location of the uniform value to
        /// be modified.
        /// </para>
        /// </param>
        /// <param name="count">
        /// <para>
        /// Specifies the number of matrices that are to
        /// be modified. This should be 1 if the targeted
        /// uniform variable is not an array of matrices, and 1 or more if it is
        /// an array of matrices.
        /// </para>
        /// </param>
        /// <param name="transpose">
        /// <para>
        /// Specifies whether to transpose the matrix as
        /// the values are loaded into the uniform
        /// variable.
        /// </para>
        /// </param>
        /// <param name="value">
        /// <para>
        /// Specifies a pointer to an array of
        /// <paramref name="count"/> values that will be
        /// used to update the specified uniform
        /// variable.
        /// </para>
        /// </param>
        /// <seealso cref="glLinkProgram"/>
        /// <seealso cref="glUseProgram"/>
        public unsafe static void glUniformMatrix4x3fv(int location, int count, bool transpose, float* value) {
            var _F = _GetProc<GLNativeDelegate.FNglUniformMatrix4x3fv>("glUniformMatrix4x3fv");
            _F(location, count, transpose, value);
        }

        #endregion GL_VERSION_2_1

        #region GL_VERSION_3_0

        /// <summary>
        /// enable and disable writing of frame buffer color components
        /// <para>Require:</para> <para>GL_VERSION_3_0, GL_ES_VERSION_3_2</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glColorMaski(GLuint buf, GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha);</para>
        /// </summary>
        public static void glColorMaski(uint buf, bool red, bool green, bool blue, bool alpha) {
            var _F = _GetProc<GLNativeDelegate.FNglColorMaski>("glColorMaski");
            _F(buf, red, green, blue, alpha);
        }
        /// <summary>
        /// return the value or values of a selected parameter
        /// <para>Require:</para> <para>GL_VERSION_3_0, GL_ES_VERSION_3_1</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glGetBooleani_v(GLenum target, GLuint index, GLboolean * data);</para>
        /// </summary>
        public unsafe static void glGetBooleani_v(uint target, uint index, bool* data) {
            var _F = _GetProc<GLNativeDelegate.FNglGetBooleani_v>("glGetBooleani_v");
            _F(target, index, data);
        }
        /// <summary>
        /// return the value or values of a selected parameter
        /// <para>Require:</para> <para>GL_VERSION_3_0, GL_VERSION_3_1, GL_ES_VERSION_3_0, GL_ARB_uniform_buffer_object</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetIntegeri_v(GLenum target, GLuint index, GLint * data);</para>
        /// </summary>
        public unsafe static void glGetIntegeri_v(uint target, uint index, int* data) {
            var _F = _GetProc<GLNativeDelegate.FNglGetIntegeri_v>("glGetIntegeri_v");
            _F(target, index, data);
        }
        /// <summary>
        /// enable or disable server-side GL capabilities
        /// <para>Require:</para> <para>GL_VERSION_3_0, GL_ES_VERSION_3_2</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glEnablei(GLenum cap, GLuint index);</para>
        /// </summary>
        public static void glEnablei(uint cap, uint index) {
            var _F = _GetProc<GLNativeDelegate.FNglEnablei>("glEnablei");
            _F(cap, index);
        }
        /// <summary>
        /// enable or disable server-side GL capabilities
        /// <para>Require:</para> <para>GL_VERSION_3_0, GL_ES_VERSION_3_2</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glDisablei(GLenum cap, GLuint index);</para>
        /// </summary>
        public static void glDisablei(uint cap, uint index) {
            var _F = _GetProc<GLNativeDelegate.FNglDisablei>("glDisablei");
            _F(cap, index);
        }
        /// <summary>
        /// test whether a capability is enabled
        /// <para>Require:</para> <para>GL_VERSION_3_0, GL_ES_VERSION_3_2</para>
        /// Supported: <para>GL</para>
        /// Original: <para>GLboolean glIsEnabledi(GLenum cap, GLuint index);</para>
        /// </summary>
        public static bool glIsEnabledi(uint cap, uint index) {
            var _F = _GetProc<GLNativeDelegate.FNglIsEnabledi>("glIsEnabledi");
            return _F(cap, index);
        }
        /// <summary>
        /// start transform feedback operation
        /// <para>Require:</para> <para>GL_VERSION_3_0, GL_ES_VERSION_3_0</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glBeginTransformFeedback(GLenum primitiveMode);</para>
        /// </summary>
        public static void glBeginTransformFeedback(uint primitiveMode) {
            var _F = _GetProc<GLNativeDelegate.FNglBeginTransformFeedback>("glBeginTransformFeedback");
            _F(primitiveMode);
        }
        /// <summary>
        /// start transform feedback operation
        /// <para>Require:</para> <para>GL_VERSION_3_0, GL_ES_VERSION_3_0</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glEndTransformFeedback();</para>
        /// </summary>
        public static void glEndTransformFeedback() {
            var _F = _GetProc<GLNativeDelegate.FNglEndTransformFeedback>("glEndTransformFeedback");
            _F();
        }
        /// <summary>
        /// bind a range within a buffer object to an indexed buffer target
        /// <para>Require:</para> <para>GL_VERSION_3_0, GL_VERSION_3_1, GL_ES_VERSION_3_0, GL_ARB_uniform_buffer_object</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glBindBufferRange(GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size);</para>
        /// </summary>
        public static void glBindBufferRange(uint target, uint index, uint buffer, IntPtr offset, IntPtr size) {
            var _F = _GetProc<GLNativeDelegate.FNglBindBufferRange>("glBindBufferRange");
            _F(target, index, buffer, offset, size);
        }
        /// <summary>
        /// bind a buffer object to an indexed buffer target
        /// <para>Require:</para> <para>GL_VERSION_3_0, GL_VERSION_3_1, GL_ES_VERSION_3_0, GL_ARB_uniform_buffer_object</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glBindBufferBase(GLenum target, GLuint index, GLuint buffer);</para>
        /// </summary>
        public static void glBindBufferBase(uint target, uint index, uint buffer) {
            var _F = _GetProc<GLNativeDelegate.FNglBindBufferBase>("glBindBufferBase");
            _F(target, index, buffer);
        }
        /// <summary>
        /// specify values to record in transform feedback buffers
        /// <para>Require:</para> <para>GL_VERSION_3_0, GL_ES_VERSION_3_0</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glTransformFeedbackVaryings(GLuint program, GLsizei count, const char ** varyings, GLenum bufferMode);</para>
        /// </summary>
        public unsafe static void glTransformFeedbackVaryings(uint program, int count, byte** varyings, uint bufferMode) {
            var _F = _GetProc<GLNativeDelegate.FNglTransformFeedbackVaryings>("glTransformFeedbackVaryings");
            _F(program, count, varyings, bufferMode);
        }
        /// <summary>
        /// retrieve information about varying variables selected for transform feedback
        /// <para>Require:</para> <para>GL_VERSION_3_0, GL_ES_VERSION_3_0</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glGetTransformFeedbackVarying(GLuint program, GLuint index, GLsizei bufSize, GLsizei * length, GLsizei * size, GLenum * type, char * name);</para>
        /// </summary>
        public unsafe static void glGetTransformFeedbackVarying(uint program, uint index, int bufSize, int* length, int* size, uint* type, byte* name) {
            var _F = _GetProc<GLNativeDelegate.FNglGetTransformFeedbackVarying>("glGetTransformFeedbackVarying");
            _F(program, index, bufSize, length, size, type, name);
        }
        /// <summary>
        /// specify whether data read via  <see cref="glReadPixels"/>  should be clamped
        /// <para>Require:</para> <para>GL_VERSION_3_0</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glClampColor(GLenum target, GLenum clamp);</para>
        /// </summary>
        public static void glClampColor(uint target, uint clamp) {
            var _F = _GetProc<GLNativeDelegate.FNglClampColor>("glClampColor");
            _F(target, clamp);
        }
        /// <summary>
        /// start conditional rendering
        /// <para>Require:</para> <para>GL_VERSION_3_0</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glBeginConditionalRender(GLuint id, GLenum mode);</para>
        /// </summary>
        public static void glBeginConditionalRender(uint id, uint mode) {
            var _F = _GetProc<GLNativeDelegate.FNglBeginConditionalRender>("glBeginConditionalRender");
            _F(id, mode);
        }
        /// <summary>
        /// start conditional rendering
        /// <para>Require:</para> <para>GL_VERSION_3_0</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glEndConditionalRender();</para>
        /// </summary>
        public static void glEndConditionalRender() {
            var _F = _GetProc<GLNativeDelegate.FNglEndConditionalRender>("glEndConditionalRender");
            _F();
        }
        /// <summary>
        /// define an array of generic vertex attribute data
        /// <para>Require:</para> <para>GL_VERSION_3_0, GL_ES_VERSION_3_0</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glVertexAttribIPointer(GLuint index, GLint size, GLenum type, GLsizei stride, const void * pointer);</para>
        /// </summary>
        public unsafe static void glVertexAttribIPointer(uint index, int size, uint type, int stride, void* pointer) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttribIPointer>("glVertexAttribIPointer");
            _F(index, size, type, stride, pointer);
        }
        /// <summary>
        /// Return a generic vertex attribute parameter
        /// <para>Require:</para> <para>GL_VERSION_3_0, GL_ES_VERSION_3_0</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glGetVertexAttribIiv(GLuint index, GLenum pname, GLint * params);</para>
        /// </summary>
        public unsafe static void glGetVertexAttribIiv(uint index, uint pname, int* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetVertexAttribIiv>("glGetVertexAttribIiv");
            _F(index, pname, ps);
        }
        /// <summary>
        /// Return a generic vertex attribute parameter
        /// <para>Require:</para> <para>GL_VERSION_3_0, GL_ES_VERSION_3_0</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glGetVertexAttribIuiv(GLuint index, GLenum pname, GLuint * params);</para>
        /// </summary>
        public unsafe static void glGetVertexAttribIuiv(uint index, uint pname, uint* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetVertexAttribIuiv>("glGetVertexAttribIuiv");
            _F(index, pname, ps);
        }
        /// <summary>
        /// Specifies the value of a generic vertex attribute
        /// <para>Require:</para> <para>GL_VERSION_3_0</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glVertexAttribI1i(GLuint index, GLint v0);</para>
        /// </summary>
        public static void glVertexAttribI1i(uint index, int v0) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttribI1i>("glVertexAttribI1i");
            _F(index, v0);
        }
        /// <summary>
        /// Specifies the value of a generic vertex attribute
        /// <para>Require:</para> <para>GL_VERSION_3_0</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glVertexAttribI2i(GLuint index, GLint v0, GLint v1);</para>
        /// </summary>
        public static void glVertexAttribI2i(uint index, int v0, int v1) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttribI2i>("glVertexAttribI2i");
            _F(index, v0, v1);
        }
        /// <summary>
        /// Specifies the value of a generic vertex attribute
        /// <para>Require:</para> <para>GL_VERSION_3_0</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glVertexAttribI3i(GLuint index, GLint v0, GLint v1, GLint v2);</para>
        /// </summary>
        public static void glVertexAttribI3i(uint index, int v0, int v1, int v2) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttribI3i>("glVertexAttribI3i");
            _F(index, v0, v1, v2);
        }
        /// <summary>
        /// Specifies the value of a generic vertex attribute
        /// <para>Require:</para> <para>GL_VERSION_3_0, GL_ES_VERSION_3_0</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glVertexAttribI4i(GLuint index, GLint v0, GLint v1, GLint v2, GLint v3);</para>
        /// </summary>
        public static void glVertexAttribI4i(uint index, int v0, int v1, int v2, int v3) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttribI4i>("glVertexAttribI4i");
            _F(index, v0, v1, v2, v3);
        }
        /// <summary>
        /// Specifies the value of a generic vertex attribute
        /// <para>Require:</para> <para>GL_VERSION_3_0</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glVertexAttribI1ui(GLuint index, GLuint v0);</para>
        /// </summary>
        public static void glVertexAttribI1ui(uint index, uint v0) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttribI1ui>("glVertexAttribI1ui");
            _F(index, v0);
        }
        /// <summary>
        /// Specifies the value of a generic vertex attribute
        /// <para>Require:</para> <para>GL_VERSION_3_0</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glVertexAttribI2ui(GLuint index, GLuint v0, GLuint v1);</para>
        /// </summary>
        public static void glVertexAttribI2ui(uint index, uint v0, uint v1) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttribI2ui>("glVertexAttribI2ui");
            _F(index, v0, v1);
        }
        /// <summary>
        /// Specifies the value of a generic vertex attribute
        /// <para>Require:</para> <para>GL_VERSION_3_0</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glVertexAttribI3ui(GLuint index, GLuint v0, GLuint v1, GLuint v2);</para>
        /// </summary>
        public static void glVertexAttribI3ui(uint index, uint v0, uint v1, uint v2) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttribI3ui>("glVertexAttribI3ui");
            _F(index, v0, v1, v2);
        }
        /// <summary>
        /// Specifies the value of a generic vertex attribute
        /// <para>Require:</para> <para>GL_VERSION_3_0, GL_ES_VERSION_3_0</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glVertexAttribI4ui(GLuint index, GLuint v0, GLuint v1, GLuint v2, GLuint v3);</para>
        /// </summary>
        public static void glVertexAttribI4ui(uint index, uint v0, uint v1, uint v2, uint v3) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttribI4ui>("glVertexAttribI4ui");
            _F(index, v0, v1, v2, v3);
        }
        /// <summary>
        /// Specifies the value of a generic vertex attribute
        /// <para>Require:</para> <para>GL_VERSION_3_0</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glVertexAttribI1iv(GLuint index, const GLint * v);</para>
        /// </summary>
        public unsafe static void glVertexAttribI1iv(uint index, int* v) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttribI1iv>("glVertexAttribI1iv");
            _F(index, v);
        }
        /// <summary>
        /// Specifies the value of a generic vertex attribute
        /// <para>Require:</para> <para>GL_VERSION_3_0</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glVertexAttribI2iv(GLuint index, const GLint * v);</para>
        /// </summary>
        public unsafe static void glVertexAttribI2iv(uint index, int* v) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttribI2iv>("glVertexAttribI2iv");
            _F(index, v);
        }
        /// <summary>
        /// Specifies the value of a generic vertex attribute
        /// <para>Require:</para> <para>GL_VERSION_3_0</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glVertexAttribI3iv(GLuint index, const GLint * v);</para>
        /// </summary>
        public unsafe static void glVertexAttribI3iv(uint index, int* v) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttribI3iv>("glVertexAttribI3iv");
            _F(index, v);
        }
        /// <summary>
        /// Specifies the value of a generic vertex attribute
        /// <para>Require:</para> <para>GL_VERSION_3_0, GL_ES_VERSION_3_0</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glVertexAttribI4iv(GLuint index, const GLint * v);</para>
        /// </summary>
        public unsafe static void glVertexAttribI4iv(uint index, int* v) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttribI4iv>("glVertexAttribI4iv");
            _F(index, v);
        }
        /// <summary>
        /// Specifies the value of a generic vertex attribute
        /// <para>Require:</para> <para>GL_VERSION_3_0</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glVertexAttribI1uiv(GLuint index, const GLuint * v);</para>
        /// </summary>
        public unsafe static void glVertexAttribI1uiv(uint index, uint* v) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttribI1uiv>("glVertexAttribI1uiv");
            _F(index, v);
        }
        /// <summary>
        /// Specifies the value of a generic vertex attribute
        /// <para>Require:</para> <para>GL_VERSION_3_0</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glVertexAttribI2uiv(GLuint index, const GLuint * v);</para>
        /// </summary>
        public unsafe static void glVertexAttribI2uiv(uint index, uint* v) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttribI2uiv>("glVertexAttribI2uiv");
            _F(index, v);
        }
        /// <summary>
        /// Specifies the value of a generic vertex attribute
        /// <para>Require:</para> <para>GL_VERSION_3_0</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glVertexAttribI3uiv(GLuint index, const GLuint * v);</para>
        /// </summary>
        public unsafe static void glVertexAttribI3uiv(uint index, uint* v) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttribI3uiv>("glVertexAttribI3uiv");
            _F(index, v);
        }
        /// <summary>
        /// Specifies the value of a generic vertex attribute
        /// <para>Require:</para> <para>GL_VERSION_3_0, GL_ES_VERSION_3_0</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glVertexAttribI4uiv(GLuint index, const GLuint * v);</para>
        /// </summary>
        public unsafe static void glVertexAttribI4uiv(uint index, uint* v) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttribI4uiv>("glVertexAttribI4uiv");
            _F(index, v);
        }
        /// <summary>
        /// Specifies the value of a generic vertex attribute
        /// <para>Require:</para> <para>GL_VERSION_3_0</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glVertexAttribI4bv(GLuint index, const GLbyte * v);</para>
        /// </summary>
        public unsafe static void glVertexAttribI4bv(uint index, byte* v) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttribI4bv>("glVertexAttribI4bv");
            _F(index, v);
        }
        /// <summary>
        /// Specifies the value of a generic vertex attribute
        /// <para>Require:</para> <para>GL_VERSION_3_0</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glVertexAttribI4sv(GLuint index, const GLshort * v);</para>
        /// </summary>
        public unsafe static void glVertexAttribI4sv(uint index, short* v) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttribI4sv>("glVertexAttribI4sv");
            _F(index, v);
        }
        /// <summary>
        /// Specifies the value of a generic vertex attribute
        /// <para>Require:</para> <para>GL_VERSION_3_0</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glVertexAttribI4ubv(GLuint index, const GLubyte * v);</para>
        /// </summary>
        public unsafe static void glVertexAttribI4ubv(uint index, byte* v) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttribI4ubv>("glVertexAttribI4ubv");
            _F(index, v);
        }
        /// <summary>
        /// Specifies the value of a generic vertex attribute
        /// <para>Require:</para> <para>GL_VERSION_3_0</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glVertexAttribI4usv(GLuint index, const GLushort * v);</para>
        /// </summary>
        public unsafe static void glVertexAttribI4usv(uint index, ushort* v) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttribI4usv>("glVertexAttribI4usv");
            _F(index, v);
        }
        /// <summary>
        /// Returns the value of a uniform variable
        /// <para>Require:</para> <para>GL_VERSION_3_0, GL_ES_VERSION_3_0</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glGetUniformuiv(GLuint program, GLint location, GLuint * params);</para>
        /// </summary>
        public unsafe static void glGetUniformuiv(uint program, int location, uint* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetUniformuiv>("glGetUniformuiv");
            _F(program, location, ps);
        }
        /// <summary>
        /// bind a user-defined varying out variable to a fragment shader color number
        /// <para>Require:</para> <para>GL_VERSION_3_0</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glBindFragDataLocation(GLuint program, GLuint colorNumber, const char * name);</para>
        /// </summary>
        public unsafe static void glBindFragDataLocation(uint program, uint colorNumber, byte* name) {
            var _F = _GetProc<GLNativeDelegate.FNglBindFragDataLocation>("glBindFragDataLocation");
            _F(program, colorNumber, name);
        }
        /// <summary>
        /// query the bindings of color numbers to user-defined varying out variables
        /// <para>Require:</para> <para>GL_VERSION_3_0, GL_ES_VERSION_3_0</para>
        /// Supported: <para>GL</para>
        /// Original: <para>GLint glGetFragDataLocation(GLuint program, const char * name);</para>
        /// </summary>
        public unsafe static int glGetFragDataLocation(uint program, byte* name) {
            var _F = _GetProc<GLNativeDelegate.FNglGetFragDataLocation>("glGetFragDataLocation");
            return _F(program, name);
        }
        /// <summary>
        /// Specify the value of a uniform variable for the current program object
        /// <para>Require:</para> <para>GL_VERSION_3_0, GL_ES_VERSION_3_0</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glUniform1ui(GLint location, GLuint v0);</para>
        /// </summary>
        public static void glUniform1ui(int location, uint v0) {
            var _F = _GetProc<GLNativeDelegate.FNglUniform1ui>("glUniform1ui");
            _F(location, v0);
        }
        /// <summary>
        /// Specify the value of a uniform variable for the current program object
        /// <para>Require:</para> <para>GL_VERSION_3_0, GL_ES_VERSION_3_0</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glUniform2ui(GLint location, GLuint v0, GLuint v1);</para>
        /// </summary>
        public static void glUniform2ui(int location, uint v0, uint v1) {
            var _F = _GetProc<GLNativeDelegate.FNglUniform2ui>("glUniform2ui");
            _F(location, v0, v1);
        }
        /// <summary>
        /// Specify the value of a uniform variable for the current program object
        /// <para>Require:</para> <para>GL_VERSION_3_0, GL_ES_VERSION_3_0</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glUniform3ui(GLint location, GLuint v0, GLuint v1, GLuint v2);</para>
        /// </summary>
        public static void glUniform3ui(int location, uint v0, uint v1, uint v2) {
            var _F = _GetProc<GLNativeDelegate.FNglUniform3ui>("glUniform3ui");
            _F(location, v0, v1, v2);
        }
        /// <summary>
        /// Specify the value of a uniform variable for the current program object
        /// <para>Require:</para> <para>GL_VERSION_3_0, GL_ES_VERSION_3_0</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glUniform4ui(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3);</para>
        /// </summary>
        public static void glUniform4ui(int location, uint v0, uint v1, uint v2, uint v3) {
            var _F = _GetProc<GLNativeDelegate.FNglUniform4ui>("glUniform4ui");
            _F(location, v0, v1, v2, v3);
        }
        /// <summary>
        /// Specify the value of a uniform variable for the current program object
        /// <para>Require:</para> <para>GL_VERSION_3_0, GL_ES_VERSION_3_0</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glUniform1uiv(GLint location, GLsizei count, const GLuint * value);</para>
        /// </summary>
        public unsafe static void glUniform1uiv(int location, int count, uint* value) {
            var _F = _GetProc<GLNativeDelegate.FNglUniform1uiv>("glUniform1uiv");
            _F(location, count, value);
        }
        /// <summary>
        /// Specify the value of a uniform variable for the current program object
        /// <para>Require:</para> <para>GL_VERSION_3_0, GL_ES_VERSION_3_0</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glUniform2uiv(GLint location, GLsizei count, const GLuint * value);</para>
        /// </summary>
        public unsafe static void glUniform2uiv(int location, int count, uint* value) {
            var _F = _GetProc<GLNativeDelegate.FNglUniform2uiv>("glUniform2uiv");
            _F(location, count, value);
        }
        /// <summary>
        /// Specify the value of a uniform variable for the current program object
        /// <para>Require:</para> <para>GL_VERSION_3_0, GL_ES_VERSION_3_0</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glUniform3uiv(GLint location, GLsizei count, const GLuint * value);</para>
        /// </summary>
        public unsafe static void glUniform3uiv(int location, int count, uint* value) {
            var _F = _GetProc<GLNativeDelegate.FNglUniform3uiv>("glUniform3uiv");
            _F(location, count, value);
        }
        /// <summary>
        /// Specify the value of a uniform variable for the current program object
        /// <para>Require:</para> <para>GL_VERSION_3_0, GL_ES_VERSION_3_0</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glUniform4uiv(GLint location, GLsizei count, const GLuint * value);</para>
        /// </summary>
        public unsafe static void glUniform4uiv(int location, int count, uint* value) {
            var _F = _GetProc<GLNativeDelegate.FNglUniform4uiv>("glUniform4uiv");
            _F(location, count, value);
        }
        /// <summary>
        /// set texture parameters
        /// <para>Require:</para> <para>GL_VERSION_3_0, GL_ES_VERSION_3_2</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glTexParameterIiv(GLenum target, GLenum pname, const GLint * params);</para>
        /// </summary>
        public unsafe static void glTexParameterIiv(uint target, uint pname, int* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglTexParameterIiv>("glTexParameterIiv");
            _F(target, pname, ps);
        }
        /// <summary>
        /// set texture parameters
        /// <para>Require:</para> <para>GL_VERSION_3_0, GL_ES_VERSION_3_2</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glTexParameterIuiv(GLenum target, GLenum pname, const GLuint * params);</para>
        /// </summary>
        public unsafe static void glTexParameterIuiv(uint target, uint pname, uint* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglTexParameterIuiv>("glTexParameterIuiv");
            _F(target, pname, ps);
        }
        /// <summary>
        /// return texture parameter values
        /// <para>Require:</para> <para>GL_VERSION_3_0, GL_ES_VERSION_3_2</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glGetTexParameterIiv(GLenum target, GLenum pname, GLint * params);</para>
        /// </summary>
        public unsafe static void glGetTexParameterIiv(uint target, uint pname, int* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetTexParameterIiv>("glGetTexParameterIiv");
            _F(target, pname, ps);
        }
        /// <summary>
        /// return texture parameter values
        /// <para>Require:</para> <para>GL_VERSION_3_0, GL_ES_VERSION_3_2</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glGetTexParameterIuiv(GLenum target, GLenum pname, GLuint * params);</para>
        /// </summary>
        public unsafe static void glGetTexParameterIuiv(uint target, uint pname, uint* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetTexParameterIuiv>("glGetTexParameterIuiv");
            _F(target, pname, ps);
        }
        /// <summary>
        /// clear individual buffers of a framebuffer
        /// <para>Require:</para> <para>GL_VERSION_3_0, GL_ES_VERSION_3_0</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glClearBufferiv(GLenum buffer, GLint drawbuffer, const GLint * value);</para>
        /// </summary>
        public unsafe static void glClearBufferiv(uint buffer, int drawbuffer, int* value) {
            var _F = _GetProc<GLNativeDelegate.FNglClearBufferiv>("glClearBufferiv");
            _F(buffer, drawbuffer, value);
        }
        /// <summary>
        /// clear individual buffers of a framebuffer
        /// <para>Require:</para> <para>GL_VERSION_3_0, GL_ES_VERSION_3_0</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glClearBufferuiv(GLenum buffer, GLint drawbuffer, const GLuint * value);</para>
        /// </summary>
        public unsafe static void glClearBufferuiv(uint buffer, int drawbuffer, uint* value) {
            var _F = _GetProc<GLNativeDelegate.FNglClearBufferuiv>("glClearBufferuiv");
            _F(buffer, drawbuffer, value);
        }
        /// <summary>
        /// clear individual buffers of a framebuffer
        /// <para>Require:</para> <para>GL_VERSION_3_0, GL_ES_VERSION_3_0</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glClearBufferfv(GLenum buffer, GLint drawbuffer, const GLfloat * value);</para>
        /// </summary>
        public unsafe static void glClearBufferfv(uint buffer, int drawbuffer, float* value) {
            var _F = _GetProc<GLNativeDelegate.FNglClearBufferfv>("glClearBufferfv");
            _F(buffer, drawbuffer, value);
        }
        /// <summary>
        /// clear individual buffers of a framebuffer
        /// <para>Require:</para> <para>GL_VERSION_3_0, GL_ES_VERSION_3_0</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glClearBufferfi(GLenum buffer, GLint drawbuffer, GLfloat depth, GLint stencil);</para>
        /// </summary>
        public static void glClearBufferfi(uint buffer, int drawbuffer, float depth, int stencil) {
            var _F = _GetProc<GLNativeDelegate.FNglClearBufferfi>("glClearBufferfi");
            _F(buffer, drawbuffer, depth, stencil);
        }
        /// <summary>
        /// return a string describing the current GL connection
        /// <para>Require:</para> <para>GL_VERSION_3_0, GL_ES_VERSION_3_0</para>
        /// Supported: <para>GL</para>
        /// Original: <para>const GLubyte * glGetStringi(GLenum name, GLuint index);</para>
        /// </summary>
        public unsafe static byte* glGetStringi(uint name, uint index) {
            var _F = _GetProc<GLNativeDelegate.FNglGetStringi>("glGetStringi");
            return _F(name, index);
        }

        #region Reuse ARB_framebuffer_object

        /// <summary>
        /// determine if a name corresponds to a renderbuffer object
        /// <para>Require:</para> <para>GL_VERSION_3_0, GL_ES_VERSION_2_0, GL_ARB_framebuffer_object</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>GLboolean glIsRenderbuffer(GLuint renderbuffer);</para>
        /// </summary>
        public static bool glIsRenderbuffer(uint renderbuffer) {
            var _F = _GetProc<GLNativeDelegate.FNglIsRenderbuffer>("glIsRenderbuffer");
            return _F(renderbuffer);
        }
        /// <summary>
        /// bind a renderbuffer to a renderbuffer target
        /// <para>Require:</para> <para>GL_VERSION_3_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0, GL_ARB_framebuffer_object</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glBindRenderbuffer(GLenum target, GLuint renderbuffer);</para>
        /// </summary>
        public static void glBindRenderbuffer(uint target, uint renderbuffer) {
            var _F = _GetProc<GLNativeDelegate.FNglBindRenderbuffer>("glBindRenderbuffer");
            _F(target, renderbuffer);
        }
        /// <summary>
        /// delete renderbuffer objects
        /// <para>Require:</para> <para>GL_VERSION_3_0, GL_ES_VERSION_2_0, GL_ARB_framebuffer_object</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glDeleteRenderbuffers(GLsizei n, GLuint * renderbuffers);</para>
        /// </summary>
        public unsafe static void glDeleteRenderbuffers(int n, uint* renderbuffers) {
            var _F = _GetProc<GLNativeDelegate.FNglDeleteRenderbuffers>("glDeleteRenderbuffers");
            _F(n, renderbuffers);
        }
        /// <summary>
        /// generate renderbuffer object names
        /// <para>Require:</para> <para>GL_VERSION_3_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0, GL_ARB_framebuffer_object</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGenRenderbuffers(GLsizei n, GLuint * renderbuffers);</para>
        /// </summary>
        public unsafe static void glGenRenderbuffers(int n, uint* renderbuffers) {
            var _F = _GetProc<GLNativeDelegate.FNglGenRenderbuffers>("glGenRenderbuffers");
            _F(n, renderbuffers);
        }
        /// <summary>
        /// <para>
        /// establish data storage, format and dimensions of a
        /// renderbuffer object's image
        /// </para>
        /// <para>Require:</para> <para>GL_VERSION_3_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0, GL_ARB_framebuffer_object</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glRenderbufferStorage(GLenum target, GLenum internalformat, GLsizei width, GLsizei height);</para>
        /// </summary>
        public static void glRenderbufferStorage(uint target, uint internalformat, int width, int height) {
            var _F = _GetProc<GLNativeDelegate.FNglRenderbufferStorage>("glRenderbufferStorage");
            _F(target, internalformat, width, height);
        }
        /// <summary>
        /// query a named parameter of a renderbuffer object
        /// <para>Require:</para> <para>GL_VERSION_3_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0, GL_ARB_framebuffer_object</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetRenderbufferParameteriv(GLenum target, GLenum pname, GLint * params);</para>
        /// </summary>
        public unsafe static void glGetRenderbufferParameteriv(uint target, uint pname, int* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetRenderbufferParameteriv>("glGetRenderbufferParameteriv");
            _F(target, pname, ps);
        }
        /// <summary>
        /// determine if a name corresponds to a framebuffer object
        /// <para>Require:</para> <para>GL_VERSION_3_0, GL_ES_VERSION_2_0, GL_ARB_framebuffer_object</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>GLboolean glIsFramebuffer(GLuint framebuffer);</para>
        /// </summary>
        public static bool glIsFramebuffer(uint framebuffer) {
            var _F = _GetProc<GLNativeDelegate.FNglIsFramebuffer>("glIsFramebuffer");
            return _F(framebuffer);
        }
        /// <summary>
        /// bind a framebuffer to a framebuffer target
        /// <para>Require:</para> <para>GL_VERSION_3_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0, GL_ARB_framebuffer_object</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glBindFramebuffer(GLenum target, GLuint framebuffer);</para>
        /// </summary>
        public static void glBindFramebuffer(uint target, uint framebuffer) {
            var _F = _GetProc<GLNativeDelegate.FNglBindFramebuffer>("glBindFramebuffer");
            _F(target, framebuffer);
        }
        /// <summary>
        /// delete framebuffer objects
        /// <para>Require:</para> <para>GL_VERSION_3_0, GL_ES_VERSION_2_0, GL_ARB_framebuffer_object</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glDeleteFramebuffers(GLsizei n, GLuint * framebuffers);</para>
        /// </summary>
        public unsafe static void glDeleteFramebuffers(int n, uint* framebuffers) {
            var _F = _GetProc<GLNativeDelegate.FNglDeleteFramebuffers>("glDeleteFramebuffers");
            _F(n, framebuffers);
        }
        /// <summary>
        /// generate framebuffer object names
        /// <para>Require:</para> <para>GL_VERSION_3_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0, GL_ARB_framebuffer_object</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGenFramebuffers(GLsizei n, GLuint * ids);</para>
        /// </summary>
        public unsafe static void glGenFramebuffers(int n, uint* ids) {
            var _F = _GetProc<GLNativeDelegate.FNglGenFramebuffers>("glGenFramebuffers");
            _F(n, ids);
        }
        /// <summary>
        /// check the completeness status of a framebuffer
        /// <para>Require:</para> <para>GL_VERSION_3_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0, GL_ARB_framebuffer_object</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>GLenum glCheckFramebufferStatus(GLenum target);</para>
        /// </summary>
        public static uint glCheckFramebufferStatus(uint target) {
            var _F = _GetProc<GLNativeDelegate.FNglCheckFramebufferStatus>("glCheckFramebufferStatus");
            return _F(target);
        }
        /// <summary>
        /// attach a level of a texture object as a logical buffer of a framebuffer object
        /// <para>Require:</para> <para>GL_VERSION_3_0, GL_ARB_framebuffer_object</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glFramebufferTexture1D(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level);</para>
        /// </summary>
        public static void glFramebufferTexture1D(uint target, uint attachment, uint textarget, uint texture, int level) {
            var _F = _GetProc<GLNativeDelegate.FNglFramebufferTexture1D>("glFramebufferTexture1D");
            _F(target, attachment, textarget, texture, level);
        }
        /// <summary>
        /// attach a level of a texture object as a logical buffer of a framebuffer object
        /// <para>Require:</para> <para>GL_VERSION_3_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0, GL_ARB_framebuffer_object</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glFramebufferTexture2D(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level);</para>
        /// </summary>
        public static void glFramebufferTexture2D(uint target, uint attachment, uint textarget, uint texture, int level) {
            var _F = _GetProc<GLNativeDelegate.FNglFramebufferTexture2D>("glFramebufferTexture2D");
            _F(target, attachment, textarget, texture, level);
        }
        /// <summary>
        /// attach a level of a texture object as a logical buffer of a framebuffer object
        /// <para>Require:</para> <para>GL_VERSION_3_0, GL_ARB_framebuffer_object</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glFramebufferTexture3D(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint layer);</para>
        /// </summary>
        public static void glFramebufferTexture3D(uint target, uint attachment, uint textarget, uint texture, int level, int layer) {
            var _F = _GetProc<GLNativeDelegate.FNglFramebufferTexture3D>("glFramebufferTexture3D");
            _F(target, attachment, textarget, texture, level, layer);
        }
        /// <summary>
        /// attach a renderbuffer as a logical buffer of a framebuffer object
        /// <para>Require:</para> <para>GL_VERSION_3_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0, GL_ARB_framebuffer_object</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glFramebufferRenderbuffer(GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer);</para>
        /// </summary>
        public static void glFramebufferRenderbuffer(uint target, uint attachment, uint renderbuffertarget, uint renderbuffer) {
            var _F = _GetProc<GLNativeDelegate.FNglFramebufferRenderbuffer>("glFramebufferRenderbuffer");
            _F(target, attachment, renderbuffertarget, renderbuffer);
        }
        /// <summary>
        /// retrieve information about attachments of a framebuffer object
        /// <para>Require:</para> <para>GL_VERSION_3_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0, GL_ARB_framebuffer_object</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetFramebufferAttachmentParameteriv(GLenum target, GLenum attachment, GLenum pname, GLint * params);</para>
        /// </summary>
        public unsafe static void glGetFramebufferAttachmentParameteriv(uint target, uint attachment, uint pname, int* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetFramebufferAttachmentParameteriv>("glGetFramebufferAttachmentParameteriv");
            _F(target, attachment, pname, ps);
        }
        /// <summary>
        /// generate mipmaps for a specified texture object
        /// <para>Require:</para> <para>GL_VERSION_3_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0, GL_ARB_framebuffer_object</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGenerateMipmap(GLenum target);</para>
        /// </summary>
        public static void glGenerateMipmap(uint target) {
            var _F = _GetProc<GLNativeDelegate.FNglGenerateMipmap>("glGenerateMipmap");
            _F(target);
        }
        /// <summary>
        /// copy a block of pixels from one framebuffer object to another
        /// <para>Require:</para> <para>GL_VERSION_3_0, GL_ES_VERSION_3_0, GL_ARB_framebuffer_object</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glBlitFramebuffer(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter);</para>
        /// </summary>
        public static void glBlitFramebuffer(int srcX0, int srcY0, int srcX1, int srcY1, int dstX0, int dstY0, int dstX1, int dstY1, uint mask, uint filter) {
            var _F = _GetProc<GLNativeDelegate.FNglBlitFramebuffer>("glBlitFramebuffer");
            _F(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
        }
        /// <summary>
        /// <para>
        /// establish data storage, format, dimensions and sample count of
        /// a renderbuffer object's image
        /// </para>
        /// <para>Require:</para> <para>GL_VERSION_3_0, GL_ES_VERSION_3_0, GL_ARB_framebuffer_object</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glRenderbufferStorageMultisample(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height);</para>
        /// </summary>
        public static void glRenderbufferStorageMultisample(uint target, int samples, uint internalformat, int width, int height) {
            var _F = _GetProc<GLNativeDelegate.FNglRenderbufferStorageMultisample>("glRenderbufferStorageMultisample");
            _F(target, samples, internalformat, width, height);
        }
        /// <summary>
        /// attach a single layer of a texture object as a logical buffer of a framebuffer object
        /// <para>Require:</para> <para>GL_VERSION_3_0, GL_ES_VERSION_3_0, GL_ARB_framebuffer_object</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glFramebufferTextureLayer(GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer);</para>
        /// </summary>
        public static void glFramebufferTextureLayer(uint target, uint attachment, uint texture, int level, int layer) {
            var _F = _GetProc<GLNativeDelegate.FNglFramebufferTextureLayer>("glFramebufferTextureLayer");
            _F(target, attachment, texture, level, layer);
        }

        #endregion Reuse ARB_framebuffer_object

        #region Reuse ARB_map_buffer_range

        /// <summary>
        /// map all or part of a buffer object's data store into the client's address space
        /// <para>Require:</para> <para>GL_VERSION_3_0, GL_ES_VERSION_3_0, GL_ARB_map_buffer_range</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void * glMapBufferRange(GLenum target, GLintptr offset, GLsizeiptr length, GLbitfield access);</para>
        /// </summary>
        public unsafe static void* glMapBufferRange(uint target, IntPtr offset, IntPtr length, uint access) {
            var _F = _GetProc<GLNativeDelegate.FNglMapBufferRange>("glMapBufferRange");
            return _F(target, offset, length, access);
        }
        /// <summary>
        /// indicate modifications to a range of a mapped buffer
        /// <para>Require:</para> <para>GL_VERSION_3_0, GL_ES_VERSION_3_0, GL_ARB_map_buffer_range</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glFlushMappedBufferRange(GLenum target, GLintptr offset, GLsizeiptr length);</para>
        /// </summary>
        public static void glFlushMappedBufferRange(uint target, IntPtr offset, IntPtr length) {
            var _F = _GetProc<GLNativeDelegate.FNglFlushMappedBufferRange>("glFlushMappedBufferRange");
            _F(target, offset, length);
        }

        #endregion Reuse ARB_map_buffer_range

        #region Reuse ARB_vertex_array_object

        /// <summary>
        /// bind a vertex array object
        /// <para>Require:</para> <para>GL_VERSION_3_0, GL_ES_VERSION_3_0, GL_ARB_vertex_array_object</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glBindVertexArray(GLuint array);</para>
        /// </summary>
        public static void glBindVertexArray(uint array) {
            var _F = _GetProc<GLNativeDelegate.FNglBindVertexArray>("glBindVertexArray");
            _F(array);
        }
        /// <summary>
        /// delete vertex array objects
        /// <para>Require:</para> <para>GL_VERSION_3_0, GL_ES_VERSION_3_0, GL_ARB_vertex_array_object</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glDeleteVertexArrays(GLsizei n, const GLuint * arrays);</para>
        /// </summary>
        public unsafe static void glDeleteVertexArrays(int n, uint* arrays) {
            var _F = _GetProc<GLNativeDelegate.FNglDeleteVertexArrays>("glDeleteVertexArrays");
            _F(n, arrays);
        }
        /// <summary>
        /// generate vertex array object names
        /// <para>Require:</para> <para>GL_VERSION_3_0, GL_ES_VERSION_3_0, GL_ARB_vertex_array_object</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGenVertexArrays(GLsizei n, GLuint * arrays);</para>
        /// </summary>
        public unsafe static void glGenVertexArrays(int n, uint* arrays) {
            var _F = _GetProc<GLNativeDelegate.FNglGenVertexArrays>("glGenVertexArrays");
            _F(n, arrays);
        }
        /// <summary>
        /// determine if a name corresponds to a vertex array object
        /// <para>Require:</para> <para>GL_VERSION_3_0, GL_ES_VERSION_3_0, GL_ARB_vertex_array_object</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>GLboolean glIsVertexArray(GLuint array);</para>
        /// </summary>
        public static bool glIsVertexArray(uint array) {
            var _F = _GetProc<GLNativeDelegate.FNglIsVertexArray>("glIsVertexArray");
            return _F(array);
        }

        #endregion Reuse ARB_vertex_array_object

        #endregion GL_VERSION_3_0

        #region GL_VERSION_3_1

        /// <summary>
        /// draw multiple instances of a range of elements
        /// <para>Require:</para> <para>GL_VERSION_3_1, GL_ES_VERSION_3_0</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glDrawArraysInstanced(GLenum mode, GLint first, GLsizei count, GLsizei instancecount);</para>
        /// </summary>
        public static void glDrawArraysInstanced(uint mode, int first, int count, int instancecount) {
            var _F = _GetProc<GLNativeDelegate.FNglDrawArraysInstanced>("glDrawArraysInstanced");
            _F(mode, first, count, instancecount);
        }
        /// <summary>
        /// draw multiple instances of a set of elements
        /// <para>Require:</para> <para>GL_VERSION_3_1, GL_ES_VERSION_3_0</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glDrawElementsInstanced(GLenum mode, GLsizei count, GLenum type, const void * indices, GLsizei instancecount);</para>
        /// </summary>
        public unsafe static void glDrawElementsInstanced(uint mode, int count, uint type, void* indices, int instancecount) {
            var _F = _GetProc<GLNativeDelegate.FNglDrawElementsInstanced>("glDrawElementsInstanced");
            _F(mode, count, type, indices, instancecount);
        }
        /// <summary>
        /// attach a buffer object's data store to a buffer texture object
        /// <para>Require:</para> <para>GL_VERSION_3_1, GL_ES_VERSION_3_2</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glTexBuffer(GLenum target, GLenum internalformat, GLuint buffer);</para>
        /// </summary>
        public static void glTexBuffer(uint target, uint internalformat, uint buffer) {
            var _F = _GetProc<GLNativeDelegate.FNglTexBuffer>("glTexBuffer");
            _F(target, internalformat, buffer);
        }
        /// <summary>
        /// specify the primitive restart index
        /// <para>Require:</para> <para>GL_VERSION_3_1</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glPrimitiveRestartIndex(GLuint index);</para>
        /// </summary>
        public static void glPrimitiveRestartIndex(uint index) {
            var _F = _GetProc<GLNativeDelegate.FNglPrimitiveRestartIndex>("glPrimitiveRestartIndex");
            _F(index);
        }

        #region Reuse ARB_copy_buffer

        /// <summary>
        /// copy all or part of the data store of a buffer object to the data store of another buffer object
        /// <para>Require:</para> <para>GL_VERSION_3_1, GL_ES_VERSION_3_0, GL_ARB_copy_buffer</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glCopyBufferSubData(GLenum readTarget, GLenum writeTarget, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size);</para>
        /// </summary>
        public static void glCopyBufferSubData(uint readTarget, uint writeTarget, IntPtr readOffset, IntPtr writeOffset, IntPtr size) {
            var _F = _GetProc<GLNativeDelegate.FNglCopyBufferSubData>("glCopyBufferSubData");
            _F(readTarget, writeTarget, readOffset, writeOffset, size);
        }

        #endregion Reuse ARB_copy_buffer

        #region Reuse ARB_uniform_buffer_object

        /// <summary>
        /// retrieve the index of a named uniform block
        /// <para>Require:</para> <para>GL_VERSION_3_1, GL_ES_VERSION_3_0, GL_ARB_uniform_buffer_object</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetUniformIndices(GLuint program, GLsizei uniformCount, const GLchar ** uniformNames, GLuint * uniformIndices);</para>
        /// </summary>
        public unsafe static void glGetUniformIndices(uint program, int uniformCount, byte** uniformNames, uint* uniformIndices) {
            var _F = _GetProc<GLNativeDelegate.FNglGetUniformIndices>("glGetUniformIndices");
            _F(program, uniformCount, uniformNames, uniformIndices);
        }
        /// <summary>
        /// Returns information about several active uniform variables for the specified program object
        /// <para>Require:</para> <para>GL_VERSION_3_1, GL_ES_VERSION_3_0, GL_ARB_uniform_buffer_object</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetActiveUniformsiv(GLuint program, GLsizei uniformCount, const GLuint * uniformIndices, GLenum pname, GLint * params);</para>
        /// </summary>
        public unsafe static void glGetActiveUniformsiv(uint program, int uniformCount, uint* uniformIndices, uint pname, int* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetActiveUniformsiv>("glGetActiveUniformsiv");
            _F(program, uniformCount, uniformIndices, pname, ps);
        }
        /// <summary>
        /// query the name of an active uniform
        /// <para>Require:</para> <para>GL_VERSION_3_1, GL_ARB_uniform_buffer_object</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetActiveUniformName(GLuint program, GLuint uniformIndex, GLsizei bufSize, GLsizei * length, GLchar * uniformName);</para>
        /// </summary>
        public unsafe static void glGetActiveUniformName(uint program, uint uniformIndex, int bufSize, int* length, byte* uniformName) {
            var _F = _GetProc<GLNativeDelegate.FNglGetActiveUniformName>("glGetActiveUniformName");
            _F(program, uniformIndex, bufSize, length, uniformName);
        }
        /// <summary>
        /// retrieve the index of a named uniform block
        /// <para>Require:</para> <para>GL_VERSION_3_1, GL_ES_VERSION_3_0, GL_ARB_uniform_buffer_object</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>GLuint glGetUniformBlockIndex(GLuint program, const GLchar * uniformBlockName);</para>
        /// </summary>
        public unsafe static uint glGetUniformBlockIndex(uint program, byte* uniformBlockName) {
            var _F = _GetProc<GLNativeDelegate.FNglGetUniformBlockIndex>("glGetUniformBlockIndex");
            return _F(program, uniformBlockName);
        }
        /// <summary>
        /// query information about an active uniform block
        /// <para>Require:</para> <para>GL_VERSION_3_1, GL_ES_VERSION_3_0, GL_ARB_uniform_buffer_object</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetActiveUniformBlockiv(GLuint program, GLuint uniformBlockIndex, GLenum pname, GLint * params);</para>
        /// </summary>
        public unsafe static void glGetActiveUniformBlockiv(uint program, uint uniformBlockIndex, uint pname, int* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetActiveUniformBlockiv>("glGetActiveUniformBlockiv");
            _F(program, uniformBlockIndex, pname, ps);
        }
        /// <summary>
        /// retrieve the name of an active uniform block
        /// <para>Require:</para> <para>GL_VERSION_3_1, GL_ES_VERSION_3_0, GL_ARB_uniform_buffer_object</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetActiveUniformBlockName(GLuint program, GLuint uniformBlockIndex, GLsizei bufSize, GLsizei * length, GLchar * uniformBlockName);</para>
        /// </summary>
        public unsafe static void glGetActiveUniformBlockName(uint program, uint uniformBlockIndex, int bufSize, int* length, byte* uniformBlockName) {
            var _F = _GetProc<GLNativeDelegate.FNglGetActiveUniformBlockName>("glGetActiveUniformBlockName");
            _F(program, uniformBlockIndex, bufSize, length, uniformBlockName);
        }
        /// <summary>
        /// assign a binding point to an active uniform block
        /// <para>Require:</para> <para>GL_VERSION_3_1, GL_ES_VERSION_3_0, GL_ARB_uniform_buffer_object</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glUniformBlockBinding(GLuint program, GLuint uniformBlockIndex, GLuint uniformBlockBinding);</para>
        /// </summary>
        public static void glUniformBlockBinding(uint program, uint uniformBlockIndex, uint uniformBlockBinding) {
            var _F = _GetProc<GLNativeDelegate.FNglUniformBlockBinding>("glUniformBlockBinding");
            _F(program, uniformBlockIndex, uniformBlockBinding);
        }
        // void glBindBufferRange(GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size);
        // void glBindBufferBase(GLenum target, GLuint index, GLuint buffer);
        // void glGetIntegeri_v(GLenum target, GLuint index, GLint * data);

        #endregion Reuse ARB_uniform_buffer_object

        #endregion GL_VERSION_3_1

        #region GL_VERSION_3_2


        #region Reuse ARB_draw_elements_base_vertex

        /// <summary>
        /// render primitives from array data with a per-element offset
        /// <para>Require:</para> <para>GL_VERSION_3_2, GL_ES_VERSION_3_2, GL_ARB_draw_elements_base_vertex</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glDrawElementsBaseVertex(GLenum mode, GLsizei count, GLenum type, void * indices, GLint basevertex);</para>
        /// </summary>
        public unsafe static void glDrawElementsBaseVertex(uint mode, int count, uint type, void* indices, int basevertex) {
            var _F = _GetProc<GLNativeDelegate.FNglDrawElementsBaseVertex>("glDrawElementsBaseVertex");
            _F(mode, count, type, indices, basevertex);
        }
        /// <summary>
        /// render primitives from array data with a per-element offset
        /// <para>Require:</para> <para>GL_VERSION_3_2, GL_ES_VERSION_3_2, GL_ARB_draw_elements_base_vertex</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glDrawRangeElementsBaseVertex(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, void * indices, GLint basevertex);</para>
        /// </summary>
        public unsafe static void glDrawRangeElementsBaseVertex(uint mode, uint start, uint end, int count, uint type, void* indices, int basevertex) {
            var _F = _GetProc<GLNativeDelegate.FNglDrawRangeElementsBaseVertex>("glDrawRangeElementsBaseVertex");
            _F(mode, start, end, count, type, indices, basevertex);
        }
        /// <summary>
        /// render multiple instances of a set of primitives from array data with a per-element offset
        /// <para>Require:</para> <para>GL_VERSION_3_2, GL_ES_VERSION_3_2, GL_ARB_draw_elements_base_vertex</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glDrawElementsInstancedBaseVertex(GLenum mode, GLsizei count, GLenum type, void * indices, GLsizei instancecount, GLint basevertex);</para>
        /// </summary>
        public unsafe static void glDrawElementsInstancedBaseVertex(uint mode, int count, uint type, void* indices, int instancecount, int basevertex) {
            var _F = _GetProc<GLNativeDelegate.FNglDrawElementsInstancedBaseVertex>("glDrawElementsInstancedBaseVertex");
            _F(mode, count, type, indices, instancecount, basevertex);
        }
        /// <summary>
        /// render multiple sets of primitives by specifying indices of array data elements and an index to apply to each index
        /// <para>Require:</para> <para>GL_VERSION_3_2, GL_ARB_draw_elements_base_vertex</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glMultiDrawElementsBaseVertex(GLenum mode, const GLsizei * count, GLenum type, const void * const * indices, GLsizei drawcount, const GLint * basevertex);</para>
        /// </summary>
        public unsafe static void glMultiDrawElementsBaseVertex(uint mode, int* count, uint type, IntPtr indices, int drawcount, int* basevertex) {
            var _F = _GetProc<GLNativeDelegate.FNglMultiDrawElementsBaseVertex>("glMultiDrawElementsBaseVertex");
            _F(mode, count, type, indices, drawcount, basevertex);
        }

        #endregion Reuse ARB_draw_elements_base_vertex

        #region Reuse ARB_provoking_vertex

        /// <summary>
        /// specifiy the vertex to be used as the source of data for flat shaded varyings
        /// <para>Require:</para> <para>GL_VERSION_3_2, GL_ARB_provoking_vertex</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glProvokingVertex(GLenum provokeMode);</para>
        /// </summary>
        public static void glProvokingVertex(uint provokeMode) {
            var _F = _GetProc<GLNativeDelegate.FNglProvokingVertex>("glProvokingVertex");
            _F(provokeMode);
        }

        #endregion Reuse ARB_provoking_vertex

        #region Reuse ARB_sync

        /// <summary>
        /// create a new sync object and insert it into the GL command stream
        /// <para>Require:</para> <para>GL_VERSION_3_2, GL_ES_VERSION_3_0, GL_ARB_sync</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>GLsync glFenceSync(GLenum condition, GLbitfield flags);</para>
        /// </summary>
        public static IntPtr glFenceSync(uint condition, uint flags) {
            var _F = _GetProc<GLNativeDelegate.FNglFenceSync>("glFenceSync");
            return _F(condition, flags);
        }
        /// <summary>
        /// determine if a name corresponds to a sync object
        /// <para>Require:</para> <para>GL_VERSION_3_2, GL_ES_VERSION_3_0, GL_ARB_sync</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>GLboolean glIsSync(GLsync sync);</para>
        /// </summary>
        public static bool glIsSync(IntPtr sync) {
            var _F = _GetProc<GLNativeDelegate.FNglIsSync>("glIsSync");
            return _F(sync);
        }
        /// <summary>
        /// delete a sync object
        /// <para>Require:</para> <para>GL_VERSION_3_2, GL_ES_VERSION_3_0, GL_ARB_sync</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glDeleteSync(GLsync sync);</para>
        /// </summary>
        public static void glDeleteSync(IntPtr sync) {
            var _F = _GetProc<GLNativeDelegate.FNglDeleteSync>("glDeleteSync");
            _F(sync);
        }
        /// <summary>
        /// block and wait for a sync object to become signaled
        /// <para>Require:</para> <para>GL_VERSION_3_2, GL_ES_VERSION_3_0, GL_ARB_sync</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>GLenum glClientWaitSync(GLsync sync, GLbitfield flags, GLuint64 timeout);</para>
        /// </summary>
        public static uint glClientWaitSync(IntPtr sync, uint flags, UInt64 timeout) {
            var _F = _GetProc<GLNativeDelegate.FNglClientWaitSync>("glClientWaitSync");
            return _F(sync, flags, timeout);
        }
        /// <summary>
        /// instruct the GL server to block until the specified sync object becomes signaled
        /// <para>Require:</para> <para>GL_VERSION_3_2, GL_ES_VERSION_3_0, GL_ARB_sync</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glWaitSync(GLsync sync, GLbitfield flags, GLuint64 timeout);</para>
        /// </summary>
        public static void glWaitSync(IntPtr sync, uint flags, UInt64 timeout) {
            var _F = _GetProc<GLNativeDelegate.FNglWaitSync>("glWaitSync");
            _F(sync, flags, timeout);
        }
        /// <summary>
        /// return the value or values of a selected parameter
        /// <para>Require:</para> <para>GL_VERSION_3_2, GL_ES_VERSION_3_0, GL_ARB_sync</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetInteger64v(GLenum pname, GLint64 * data);</para>
        /// </summary>
        public unsafe static void glGetInteger64v(uint pname, UInt64* data) {
            var _F = _GetProc<GLNativeDelegate.FNglGetInteger64v>("glGetInteger64v");
            _F(pname, data);
        }
        /// <summary>
        /// query the properties of a sync object
        /// <para>Require:</para> <para>GL_VERSION_3_2, GL_ES_VERSION_3_0, GL_ARB_sync</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetSynciv(GLsync sync, GLenum pname, GLsizei bufSize, GLsizei * length, GLint * values);</para>
        /// </summary>
        public unsafe static void glGetSynciv(IntPtr sync, uint pname, int bufSize, int* length, int* values) {
            var _F = _GetProc<GLNativeDelegate.FNglGetSynciv>("glGetSynciv");
            _F(sync, pname, bufSize, length, values);
        }

        #endregion Reuse ARB_sync

        #region Reuse ARB_texture_multisample

        /// <summary>
        /// return the value or values of a selected parameter
        /// <para>Require:</para> <para>GL_VERSION_3_2, GL_ES_VERSION_3_0</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glGetInteger64i_v(GLenum target, GLuint index, GLint64 * data);</para>
        /// </summary>
        public unsafe static void glGetInteger64i_v(uint target, uint index, UInt64* data) {
            var _F = _GetProc<GLNativeDelegate.FNglGetInteger64i_v>("glGetInteger64i_v");
            _F(target, index, data);
        }
        /// <summary>
        /// return parameters of a buffer object
        /// <para>Require:</para> <para>GL_VERSION_3_2, GL_ES_VERSION_3_0</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glGetBufferParameteri64v(GLenum target, GLenum value, GLint64 * data);</para>
        /// </summary>
        public unsafe static void glGetBufferParameteri64v(uint target, uint value, UInt64* data) {
            var _F = _GetProc<GLNativeDelegate.FNglGetBufferParameteri64v>("glGetBufferParameteri64v");
            _F(target, value, data);
        }
        /// <summary>
        /// attach a level of a texture object as a logical buffer of a framebuffer object
        /// <para>Require:</para> <para>GL_VERSION_3_2, GL_ES_VERSION_3_2</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glFramebufferTexture(GLenum target, GLenum attachment, GLuint texture, GLint level);</para>
        /// </summary>
        public static void glFramebufferTexture(uint target, uint attachment, uint texture, int level) {
            var _F = _GetProc<GLNativeDelegate.FNglFramebufferTexture>("glFramebufferTexture");
            _F(target, attachment, texture, level);
        }
        /// <summary>
        /// establish the data storage, format, dimensions, and number of samples of a multisample texture's image
        /// <para>Require:</para> <para>GL_VERSION_3_2, GL_ARB_texture_multisample</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glTexImage2DMultisample(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations);</para>
        /// </summary>
        public static void glTexImage2DMultisample(uint target, int samples, uint internalformat, int width, int height, bool fixedsamplelocations) {
            var _F = _GetProc<GLNativeDelegate.FNglTexImage2DMultisample>("glTexImage2DMultisample");
            _F(target, samples, internalformat, width, height, fixedsamplelocations);
        }
        /// <summary>
        /// establish the data storage, format, dimensions, and number of samples of a multisample texture's image
        /// <para>Require:</para> <para>GL_VERSION_3_2, GL_ARB_texture_multisample</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glTexImage3DMultisample(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations);</para>
        /// </summary>
        public static void glTexImage3DMultisample(uint target, int samples, uint internalformat, int width, int height, int depth, bool fixedsamplelocations) {
            var _F = _GetProc<GLNativeDelegate.FNglTexImage3DMultisample>("glTexImage3DMultisample");
            _F(target, samples, internalformat, width, height, depth, fixedsamplelocations);
        }
        /// <summary>
        /// retrieve the location of a sample
        /// <para>Require:</para> <para>GL_VERSION_3_2, GL_ES_VERSION_3_1, GL_ARB_texture_multisample</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetMultisamplefv(GLenum pname, GLuint index, GLfloat * val);</para>
        /// </summary>
        public unsafe static void glGetMultisamplefv(uint pname, uint index, float* val) {
            var _F = _GetProc<GLNativeDelegate.FNglGetMultisamplefv>("glGetMultisamplefv");
            _F(pname, index, val);
        }
        /// <summary>
        /// set the value of a sub-word of the sample mask
        /// <para>Require:</para> <para>GL_VERSION_3_2, GL_ES_VERSION_3_1, GL_ARB_texture_multisample</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glSampleMaski(GLuint maskNumber, GLbitfield mask);</para>
        /// </summary>
        public static void glSampleMaski(uint maskNumber, uint mask) {
            var _F = _GetProc<GLNativeDelegate.FNglSampleMaski>("glSampleMaski");
            _F(maskNumber, mask);
        }

        #endregion Reuse ARB_texture_multisample

        #region Compatibility-only GL 1.0 features removed from GL 3.2

        // void glNewList(GLuint list, GLenum mode);
        // void glEndList();
        // void glCallList(GLuint list);
        // void glCallLists(GLsizei n, GLenum type, const void * lists);
        // void glDeleteLists(GLuint list, GLsizei range);
        // GLuint glGenLists(GLsizei range);
        // void glListBase(GLuint b);
        // void glBegin(GLenum mode);
        // void glBitmap(GLsizei width, GLsizei height, GLfloat xorig, GLfloat yorig, GLfloat xmove, GLfloat ymove, const GLubyte * bitmap);
        // void glColor3b(GLbyte red, GLbyte green, GLbyte blue);
        // void glColor3bv(const GLbyte * v);
        // void glColor3d(GLdouble red, GLdouble green, GLdouble blue);
        // void glColor3dv(const GLdouble * v);
        // void glColor3f(GLfloat red, GLfloat green, GLfloat blue);
        // void glColor3fv(const GLfloat * v);
        // void glColor3i(GLint red, GLint green, GLint blue);
        // void glColor3iv(const GLint * v);
        // void glColor3s(GLshort red, GLshort green, GLshort blue);
        // void glColor3sv(const GLshort * v);
        // void glColor3ub(GLubyte red, GLubyte green, GLubyte blue);
        // void glColor3ubv(const GLubyte * v);
        // void glColor3ui(GLuint red, GLuint green, GLuint blue);
        // void glColor3uiv(const GLuint * v);
        // void glColor3us(GLushort red, GLushort green, GLushort blue);
        // void glColor3usv(const GLushort * v);
        // void glColor4b(GLbyte red, GLbyte green, GLbyte blue, GLbyte alpha);
        // void glColor4bv(const GLbyte * v);
        // void glColor4d(GLdouble red, GLdouble green, GLdouble blue, GLdouble alpha);
        // void glColor4dv(const GLdouble * v);
        // void glColor4f(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha);
        // void glColor4fv(const GLfloat * v);
        // void glColor4i(GLint red, GLint green, GLint blue, GLint alpha);
        // void glColor4iv(const GLint * v);
        // void glColor4s(GLshort red, GLshort green, GLshort blue, GLshort alpha);
        // void glColor4sv(const GLshort * v);
        // void glColor4ub(GLubyte red, GLubyte green, GLubyte blue, GLubyte alpha);
        // void glColor4ubv(const GLubyte * v);
        // void glColor4ui(GLuint red, GLuint green, GLuint blue, GLuint alpha);
        // void glColor4uiv(const GLuint * v);
        // void glColor4us(GLushort red, GLushort green, GLushort blue, GLushort alpha);
        // void glColor4usv(const GLushort * v);
        // void glEdgeFlag(GLboolean flag);
        // void glEdgeFlagv(const GLboolean * flag);
        // void glEnd();
        // void glIndexd(GLdouble c);
        // void glIndexdv(const GLdouble * c);
        // void glIndexf(GLfloat c);
        // void glIndexfv(const GLfloat * c);
        // void glIndexi(GLint c);
        // void glIndexiv(const GLint * c);
        // void glIndexs(GLshort c);
        // void glIndexsv(const GLshort * c);
        // void glNormal3b(GLbyte nx, GLbyte ny, GLbyte nz);
        // void glNormal3bv(const GLbyte * v);
        // void glNormal3d(GLdouble nx, GLdouble ny, GLdouble nz);
        // void glNormal3dv(const GLdouble * v);
        // void glNormal3f(GLfloat nx, GLfloat ny, GLfloat nz);
        // void glNormal3fv(const GLfloat * v);
        // void glNormal3i(GLint nx, GLint ny, GLint nz);
        // void glNormal3iv(const GLint * v);
        // void glNormal3s(GLshort nx, GLshort ny, GLshort nz);
        // void glNormal3sv(const GLshort * v);
        // void glRasterPos2d(GLdouble x, GLdouble y);
        // void glRasterPos2dv(const GLdouble * v);
        // void glRasterPos2f(GLfloat x, GLfloat y);
        // void glRasterPos2fv(const GLfloat * v);
        // void glRasterPos2i(GLint x, GLint y);
        // void glRasterPos2iv(const GLint * v);
        // void glRasterPos2s(GLshort x, GLshort y);
        // void glRasterPos2sv(const GLshort * v);
        // void glRasterPos3d(GLdouble x, GLdouble y, GLdouble z);
        // void glRasterPos3dv(const GLdouble * v);
        // void glRasterPos3f(GLfloat x, GLfloat y, GLfloat z);
        // void glRasterPos3fv(const GLfloat * v);
        // void glRasterPos3i(GLint x, GLint y, GLint z);
        // void glRasterPos3iv(const GLint * v);
        // void glRasterPos3s(GLshort x, GLshort y, GLshort z);
        // void glRasterPos3sv(const GLshort * v);
        // void glRasterPos4d(GLdouble x, GLdouble y, GLdouble z, GLdouble w);
        // void glRasterPos4dv(const GLdouble * v);
        // void glRasterPos4f(GLfloat x, GLfloat y, GLfloat z, GLfloat w);
        // void glRasterPos4fv(const GLfloat * v);
        // void glRasterPos4i(GLint x, GLint y, GLint z, GLint w);
        // void glRasterPos4iv(const GLint * v);
        // void glRasterPos4s(GLshort x, GLshort y, GLshort z, GLshort w);
        // void glRasterPos4sv(const GLshort * v);
        // void glRectd(GLdouble x1, GLdouble y1, GLdouble x2, GLdouble y2);
        // void glRectdv(const GLdouble * v1, const GLdouble * v2);
        // void glRectf(GLfloat x1, GLfloat y1, GLfloat x2, GLfloat y2);
        // void glRectfv(const GLfloat * v1, const GLfloat * v2);
        // void glRecti(GLint x1, GLint y1, GLint x2, GLint y2);
        // void glRectiv(const GLint * v1, const GLint * v2);
        // void glRects(GLshort x1, GLshort y1, GLshort x2, GLshort y2);
        // void glRectsv(const GLshort * v1, const GLshort * v2);
        // void glTexCoord1d(GLdouble s);
        // void glTexCoord1dv(const GLdouble * v);
        // void glTexCoord1f(GLfloat s);
        // void glTexCoord1fv(const GLfloat * v);
        // void glTexCoord1i(GLint s);
        // void glTexCoord1iv(const GLint * v);
        // void glTexCoord1s(GLshort s);
        // void glTexCoord1sv(const GLshort * v);
        // void glTexCoord2d(GLdouble s, GLdouble t);
        // void glTexCoord2dv(const GLdouble * v);
        // void glTexCoord2f(GLfloat s, GLfloat t);
        // void glTexCoord2fv(const GLfloat * v);
        // void glTexCoord2i(GLint s, GLint t);
        // void glTexCoord2iv(const GLint * v);
        // void glTexCoord2s(GLshort s, GLshort t);
        // void glTexCoord2sv(const GLshort * v);
        // void glTexCoord3d(GLdouble s, GLdouble t, GLdouble r);
        // void glTexCoord3dv(const GLdouble * v);
        // void glTexCoord3f(GLfloat s, GLfloat t, GLfloat r);
        // void glTexCoord3fv(const GLfloat * v);
        // void glTexCoord3i(GLint s, GLint t, GLint r);
        // void glTexCoord3iv(const GLint * v);
        // void glTexCoord3s(GLshort s, GLshort t, GLshort r);
        // void glTexCoord3sv(const GLshort * v);
        // void glTexCoord4d(GLdouble s, GLdouble t, GLdouble r, GLdouble q);
        // void glTexCoord4dv(const GLdouble * v);
        // void glTexCoord4f(GLfloat s, GLfloat t, GLfloat r, GLfloat q);
        // void glTexCoord4fv(const GLfloat * v);
        // void glTexCoord4i(GLint s, GLint t, GLint r, GLint q);
        // void glTexCoord4iv(const GLint * v);
        // void glTexCoord4s(GLshort s, GLshort t, GLshort r, GLshort q);
        // void glTexCoord4sv(const GLshort * v);
        // void glVertex2d(GLdouble x, GLdouble y);
        // void glVertex2dv(const GLdouble * v);
        // void glVertex2f(GLfloat x, GLfloat y);
        // void glVertex2fv(const GLfloat * v);
        // void glVertex2i(GLint x, GLint y);
        // void glVertex2iv(const GLint * v);
        // void glVertex2s(GLshort x, GLshort y);
        // void glVertex2sv(const GLshort * v);
        // void glVertex3d(GLdouble x, GLdouble y, GLdouble z);
        // void glVertex3dv(const GLdouble * v);
        // void glVertex3f(GLfloat x, GLfloat y, GLfloat z);
        // void glVertex3fv(const GLfloat * v);
        // void glVertex3i(GLint x, GLint y, GLint z);
        // void glVertex3iv(const GLint * v);
        // void glVertex3s(GLshort x, GLshort y, GLshort z);
        // void glVertex3sv(const GLshort * v);
        // void glVertex4d(GLdouble x, GLdouble y, GLdouble z, GLdouble w);
        // void glVertex4dv(const GLdouble * v);
        // void glVertex4f(GLfloat x, GLfloat y, GLfloat z, GLfloat w);
        // void glVertex4fv(const GLfloat * v);
        // void glVertex4i(GLint x, GLint y, GLint z, GLint w);
        // void glVertex4iv(const GLint * v);
        // void glVertex4s(GLshort x, GLshort y, GLshort z, GLshort w);
        // void glVertex4sv(const GLshort * v);
        // void glClipPlane(GLenum plane, const GLdouble * equation);
        // void glColorMaterial(GLenum face, GLenum mode);
        // void glFogf(GLenum pname, GLfloat param);
        // void glFogfv(GLenum pname, const GLfloat * ps);
        // void glFogi(GLenum pname, GLint param);
        // void glFogiv(GLenum pname, const GLint * ps);
        // void glLightf(GLenum light, GLenum pname, GLfloat param);
        // void glLightfv(GLenum light, GLenum pname, const GLfloat * ps);
        // void glLighti(GLenum light, GLenum pname, GLint param);
        // void glLightiv(GLenum light, GLenum pname, const GLint * ps);
        // void glLightModelf(GLenum pname, GLfloat param);
        // void glLightModelfv(GLenum pname, const GLfloat * ps);
        // void glLightModeli(GLenum pname, GLint param);
        // void glLightModeliv(GLenum pname, const GLint * ps);
        // void glLineStipple(GLint factor, GLushort pattern);
        // void glMaterialf(GLenum face, GLenum pname, GLfloat param);
        // void glMaterialfv(GLenum face, GLenum pname, const GLfloat * ps);
        // void glMateriali(GLenum face, GLenum pname, GLint param);
        // void glMaterialiv(GLenum face, GLenum pname, const GLint * ps);
        // void glPolygonStipple(const GLubyte * pattern);
        // void glShadeModel(GLenum mode);
        // void glTexEnvf(GLenum target, GLenum pname, GLfloat param);
        // void glTexEnvfv(GLenum target, GLenum pname, const GLfloat * ps);
        // void glTexEnvi(GLenum target, GLenum pname, GLint param);
        // void glTexEnviv(GLenum target, GLenum pname, const GLint * ps);
        // void glTexGend(GLenum coord, GLenum pname, GLdouble param);
        // void glTexGendv(GLenum coord, GLenum pname, const GLdouble * ps);
        // void glTexGenf(GLenum coord, GLenum pname, GLfloat param);
        // void glTexGenfv(GLenum coord, GLenum pname, const GLfloat * ps);
        // void glTexGeni(GLenum coord, GLenum pname, GLint param);
        // void glTexGeniv(GLenum coord, GLenum pname, const GLint * ps);
        // void glFeedbackBuffer(GLsizei size, GLenum type, GLfloat * buffer);
        // void glSelectBuffer(GLsizei size, GLuint * buffer);
        // GLint glRenderMode(GLenum mode);
        // void glInitNames();
        // void glLoadName(GLuint name);
        // void glPassThrough(GLfloat token);
        // void glPopName();
        // void glPushName(GLuint name);
        // void glClearAccum(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha);
        // void glClearIndex(GLfloat c);
        // void glIndexMask(GLuint mask);
        // void glAccum(GLenum op, GLfloat value);
        // void glPopAttrib();
        // void glPushAttrib(GLbitfield mask);
        // void glMap1d(GLenum target, GLdouble u1, GLdouble u2, GLint stride, GLint order, const GLdouble * points);
        // void glMap1f(GLenum target, GLfloat u1, GLfloat u2, GLint stride, GLint order, const GLfloat * points);
        // void glMap2d(GLenum target, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, const GLdouble * points);
        // void glMap2f(GLenum target, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, const GLfloat * points);
        // void glMapGrid1d(GLint un, GLdouble u1, GLdouble u2);
        // void glMapGrid1f(GLint un, GLfloat u1, GLfloat u2);
        // void glMapGrid2d(GLint un, GLdouble u1, GLdouble u2, GLint vn, GLdouble v1, GLdouble v2);
        // void glMapGrid2f(GLint un, GLfloat u1, GLfloat u2, GLint vn, GLfloat v1, GLfloat v2);
        // void glEvalCoord1d(GLdouble u);
        // void glEvalCoord1dv(const GLdouble * u);
        // void glEvalCoord1f(GLfloat u);
        // void glEvalCoord1fv(const GLfloat * u);
        // void glEvalCoord2d(GLdouble u, GLdouble v);
        // void glEvalCoord2dv(const GLdouble * u);
        // void glEvalCoord2f(GLfloat u, GLfloat v);
        // void glEvalCoord2fv(const GLfloat * u);
        // void glEvalMesh1(GLenum mode, GLint i1, GLint i2);
        // void glEvalPoint1(GLint i);
        // void glEvalMesh2(GLenum mode, GLint i1, GLint i2, GLint j1, GLint j2);
        // void glEvalPoint2(GLint i, GLint j);
        // void glAlphaFunc(GLenum func, GLclampf r);
        // void glPixelZoom(GLfloat xfactor, GLfloat yfactor);
        // void glPixelTransferf(GLenum pname, GLfloat param);
        // void glPixelTransferi(GLenum pname, GLint param);
        // void glPixelMapfv(GLenum map, GLsizei mapsize, const GLfloat * values);
        // void glPixelMapuiv(GLenum map, GLsizei mapsize, const GLuint * values);
        // void glPixelMapusv(GLenum map, GLsizei mapsize, const GLushort * values);
        // void glCopyPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum type);
        // void glDrawPixels(GLsizei width, GLsizei height, GLenum format, GLenum type, const void * data);
        // void glGetClipPlane(GLenum plane, GLdouble * equation);
        // void glGetLightfv(GLenum light, GLenum pname, GLfloat * ps);
        // void glGetLightiv(GLenum light, GLenum pname, GLint * ps);
        // void glGetMapdv(GLenum target, GLenum query, GLdouble * v);
        // void glGetMapfv(GLenum target, GLenum query, GLfloat * v);
        // void glGetMapiv(GLenum target, GLenum query, GLint * v);
        // void glGetMaterialfv(GLenum face, GLenum pname, GLfloat * ps);
        // void glGetMaterialiv(GLenum face, GLenum pname, GLint * ps);
        // void glGetPixelMapfv(GLenum map, GLfloat * data);
        // void glGetPixelMapuiv(GLenum map, GLuint * data);
        // void glGetPixelMapusv(GLenum map, GLushort * data);
        // void glGetPolygonStipple(GLubyte * pattern);
        // void glGetTexEnvfv(GLenum target, GLenum pname, GLfloat * ps);
        // void glGetTexEnviv(GLenum target, GLenum pname, GLint * ps);
        // void glGetTexGendv(GLenum coord, GLenum pname, GLdouble * ps);
        // void glGetTexGenfv(GLenum coord, GLenum pname, GLfloat * ps);
        // void glGetTexGeniv(GLenum coord, GLenum pname, GLint * ps);
        // GLboolean glIsList(GLuint list);
        // void glFrustum(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble nearVal, GLdouble farVal);
        // void glLoadIdentity();
        // void glLoadMatrixf(const GLfloat * m);
        // void glLoadMatrixd(const GLdouble * m);
        // void glMatrixMode(GLenum mode);
        // void glMultMatrixf(const GLfloat * m);
        // void glMultMatrixd(const GLdouble * m);
        // void glOrtho(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble nearVal, GLdouble farVal);
        // void glPopMatrix();
        // void glPushMatrix();
        // void glRotated(GLdouble angle, GLdouble x, GLdouble y, GLdouble z);
        // void glRotatef(GLfloat angle, GLfloat x, GLfloat y, GLfloat z);
        // void glScaled(GLdouble x, GLdouble y, GLdouble z);
        // void glScalef(GLfloat x, GLfloat y, GLfloat z);
        // void glTranslated(GLdouble x, GLdouble y, GLdouble z);
        // void glTranslatef(GLfloat x, GLfloat y, GLfloat z);

        #endregion Compatibility-only GL 1.0 features removed from GL 3.2

        #region Compatibility-only GL 1.1 features removed from GL 3.2

        // void glArrayElement(GLint i);
        // void glColorPointer(GLint size, GLenum type, GLsizei stride, const void * pointer);
        // void glDisableClientState(GLenum cap);
        // void glEdgeFlagPointer(GLsizei stride, const void * pointer);
        // void glEnableClientState(GLenum cap);
        // void glIndexPointer(GLenum type, GLsizei stride, const void * pointer);
        // void glGetPointerv(GLenum pname, void ** ps);
        // void glInterleavedArrays(GLenum format, GLsizei stride, const void * pointer);
        // void glNormalPointer(GLenum type, GLsizei stride, const void * pointer);
        // void glTexCoordPointer(GLint size, GLenum type, GLsizei stride, const void * pointer);
        // void glVertexPointer(GLint size, GLenum type, GLsizei stride, const void * pointer);
        // GLboolean glAreTexturesResident(GLsizei n, const GLuint * textures, GLboolean * residences);
        // void glPrioritizeTextures(GLsizei n, const GLuint * textures, const GLclampf * priorities);
        // void glIndexub(GLubyte c);
        // void glIndexubv(const GLubyte * c);
        // void glPopClientAttrib();
        // void glPushClientAttrib(GLbitfield mask);

        #endregion Compatibility-only GL 1.1 features removed from GL 3.2

        #region Compatibility-only GL 1.2 features removed from GL 3.2


        #endregion Compatibility-only GL 1.2 features removed from GL 3.2

        #region Compatibility-only GL 1.3 features removed from GL 3.2

        // void glClientActiveTexture(GLenum texture);
        // void glMultiTexCoord1d(GLenum target, GLdouble s);
        // void glMultiTexCoord1dv(GLenum target, const GLdouble * v);
        // void glMultiTexCoord1f(GLenum target, GLfloat s);
        // void glMultiTexCoord1fv(GLenum target, const GLfloat * v);
        // void glMultiTexCoord1i(GLenum target, GLint s);
        // void glMultiTexCoord1iv(GLenum target, const GLint * v);
        // void glMultiTexCoord1s(GLenum target, GLshort s);
        // void glMultiTexCoord1sv(GLenum target, const GLshort * v);
        // void glMultiTexCoord2d(GLenum target, GLdouble s, GLdouble t);
        // void glMultiTexCoord2dv(GLenum target, const GLdouble * v);
        // void glMultiTexCoord2f(GLenum target, GLfloat s, GLfloat t);
        // void glMultiTexCoord2fv(GLenum target, const GLfloat * v);
        // void glMultiTexCoord2i(GLenum target, GLint s, GLint t);
        // void glMultiTexCoord2iv(GLenum target, const GLint * v);
        // void glMultiTexCoord2s(GLenum target, GLshort s, GLshort t);
        // void glMultiTexCoord2sv(GLenum target, const GLshort * v);
        // void glMultiTexCoord3d(GLenum target, GLdouble s, GLdouble t, GLdouble r);
        // void glMultiTexCoord3dv(GLenum target, const GLdouble * v);
        // void glMultiTexCoord3f(GLenum target, GLfloat s, GLfloat t, GLfloat r);
        // void glMultiTexCoord3fv(GLenum target, const GLfloat * v);
        // void glMultiTexCoord3i(GLenum target, GLint s, GLint t, GLint r);
        // void glMultiTexCoord3iv(GLenum target, const GLint * v);
        // void glMultiTexCoord3s(GLenum target, GLshort s, GLshort t, GLshort r);
        // void glMultiTexCoord3sv(GLenum target, const GLshort * v);
        // void glMultiTexCoord4d(GLenum target, GLdouble s, GLdouble t, GLdouble r, GLdouble q);
        // void glMultiTexCoord4dv(GLenum target, const GLdouble * v);
        // void glMultiTexCoord4f(GLenum target, GLfloat s, GLfloat t, GLfloat r, GLfloat q);
        // void glMultiTexCoord4fv(GLenum target, const GLfloat * v);
        // void glMultiTexCoord4i(GLenum target, GLint s, GLint t, GLint r, GLint q);
        // void glMultiTexCoord4iv(GLenum target, const GLint * v);
        // void glMultiTexCoord4s(GLenum target, GLshort s, GLshort t, GLshort r, GLshort q);
        // void glMultiTexCoord4sv(GLenum target, const GLshort * v);
        // void glLoadTransposeMatrixf(const GLfloat * m);
        // void glLoadTransposeMatrixd(const GLdouble * m);
        // void glMultTransposeMatrixf(const GLfloat * m);
        // void glMultTransposeMatrixd(const GLdouble * m);

        #endregion Compatibility-only GL 1.3 features removed from GL 3.2

        #region Compatibility-only GL 1.4 features removed from GL 3.2

        // void glFogCoordf(GLfloat coord);
        // void glFogCoordfv(GLfloat * coord);
        // void glFogCoordd(GLdouble coord);
        // void glFogCoorddv(GLdouble * coord);
        // void glFogCoordPointer(GLenum type, GLsizei stride, void * pointer);
        // void glSecondaryColor3b(GLbyte red, GLbyte green, GLbyte blue);
        // void glSecondaryColor3bv(const GLbyte * v);
        // void glSecondaryColor3d(GLdouble red, GLdouble green, GLdouble blue);
        // void glSecondaryColor3dv(const GLdouble * v);
        // void glSecondaryColor3f(GLfloat red, GLfloat green, GLfloat blue);
        // void glSecondaryColor3fv(const GLfloat * v);
        // void glSecondaryColor3i(GLint red, GLint green, GLint blue);
        // void glSecondaryColor3iv(const GLint * v);
        // void glSecondaryColor3s(GLshort red, GLshort green, GLshort blue);
        // void glSecondaryColor3sv(const GLshort * v);
        // void glSecondaryColor3ub(GLubyte red, GLubyte green, GLubyte blue);
        // void glSecondaryColor3ubv(const GLubyte * v);
        // void glSecondaryColor3ui(GLuint red, GLuint green, GLuint blue);
        // void glSecondaryColor3uiv(const GLuint * v);
        // void glSecondaryColor3us(GLushort red, GLushort green, GLushort blue);
        // void glSecondaryColor3usv(const GLushort * v);
        // void glSecondaryColorPointer(GLint size, GLenum type, GLsizei stride, const void * pointer);
        // void glWindowPos2d(GLdouble x, GLdouble y);
        // void glWindowPos2dv(const GLdouble * v);
        // void glWindowPos2f(GLfloat x, GLfloat y);
        // void glWindowPos2fv(const GLfloat * v);
        // void glWindowPos2i(GLint x, GLint y);
        // void glWindowPos2iv(const GLint * v);
        // void glWindowPos2s(GLshort x, GLshort y);
        // void glWindowPos2sv(const GLshort * v);
        // void glWindowPos3d(GLdouble x, GLdouble y, GLdouble z);
        // void glWindowPos3dv(const GLdouble * v);
        // void glWindowPos3f(GLfloat x, GLfloat y, GLfloat z);
        // void glWindowPos3fv(const GLfloat * v);
        // void glWindowPos3i(GLint x, GLint y, GLint z);
        // void glWindowPos3iv(const GLint * v);
        // void glWindowPos3s(GLshort x, GLshort y, GLshort z);
        // void glWindowPos3sv(const GLshort * v);

        #endregion Compatibility-only GL 1.4 features removed from GL 3.2

        #region Compatibility-only GL 1.5 features removed from GL 3.2


        #endregion Compatibility-only GL 1.5 features removed from GL 3.2

        #region Compatibility-only GL 2.0 features removed from GL 3.2


        #endregion Compatibility-only GL 2.0 features removed from GL 3.2

        #region Compatibility-only GL 2.1 features removed from GL 3.2


        #endregion Compatibility-only GL 2.1 features removed from GL 3.2

        #region Compatibility-only GL 3.0 features removed from GL 3.2


        #endregion Compatibility-only GL 3.0 features removed from GL 3.2

        #endregion GL_VERSION_3_2

        #region GL_VERSION_3_3


        #region Reuse ARB_blend_func_extended

        /// <summary>
        /// bind a user-defined varying out variable to a fragment shader color number and index
        /// <para>Require:</para> <para>GL_VERSION_3_3, GL_ARB_blend_func_extended</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glBindFragDataLocationIndexed(GLuint program, GLuint colorNumber, GLuint index, const char * name);</para>
        /// </summary>
        public unsafe static void glBindFragDataLocationIndexed(uint program, uint colorNumber, uint index, byte* name) {
            var _F = _GetProc<GLNativeDelegate.FNglBindFragDataLocationIndexed>("glBindFragDataLocationIndexed");
            _F(program, colorNumber, index, name);
        }
        /// <summary>
        /// query the bindings of color indices to user-defined varying out variables
        /// <para>Require:</para> <para>GL_VERSION_3_3, GL_ARB_blend_func_extended</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>GLint glGetFragDataIndex(GLuint program, const char * name);</para>
        /// </summary>
        public unsafe static int glGetFragDataIndex(uint program, byte* name) {
            var _F = _GetProc<GLNativeDelegate.FNglGetFragDataIndex>("glGetFragDataIndex");
            return _F(program, name);
        }

        #endregion Reuse ARB_blend_func_extended

        #region Reuse ARB_sampler_objects

        /// <summary>
        /// generate sampler object names
        /// <para>Require:</para> <para>GL_VERSION_3_3, GL_ES_VERSION_3_0, GL_ARB_sampler_objects</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGenSamplers(GLsizei n, GLuint * samplers);</para>
        /// </summary>
        public unsafe static void glGenSamplers(int n, uint* samplers) {
            var _F = _GetProc<GLNativeDelegate.FNglGenSamplers>("glGenSamplers");
            _F(n, samplers);
        }
        /// <summary>
        /// delete named sampler objects
        /// <para>Require:</para> <para>GL_VERSION_3_3, GL_ES_VERSION_3_0, GL_ARB_sampler_objects</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glDeleteSamplers(GLsizei n, const GLuint * samplers);</para>
        /// </summary>
        public unsafe static void glDeleteSamplers(int n, uint* samplers) {
            var _F = _GetProc<GLNativeDelegate.FNglDeleteSamplers>("glDeleteSamplers");
            _F(n, samplers);
        }
        /// <summary>
        /// determine if a name corresponds to a sampler object
        /// <para>Require:</para> <para>GL_VERSION_3_3, GL_ES_VERSION_3_0, GL_ARB_sampler_objects</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>GLboolean glIsSampler(GLuint id);</para>
        /// </summary>
        public static bool glIsSampler(uint id) {
            var _F = _GetProc<GLNativeDelegate.FNglIsSampler>("glIsSampler");
            return _F(id);
        }
        /// <summary>
        /// bind a named sampler to a texturing target
        /// <para>Require:</para> <para>GL_VERSION_3_3, GL_ES_VERSION_3_0, GL_ARB_sampler_objects</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glBindSampler(GLuint unit, GLuint sampler);</para>
        /// </summary>
        public static void glBindSampler(uint unit, uint sampler) {
            var _F = _GetProc<GLNativeDelegate.FNglBindSampler>("glBindSampler");
            _F(unit, sampler);
        }
        /// <summary>
        /// set sampler parameters
        /// <para>Require:</para> <para>GL_VERSION_3_3, GL_ES_VERSION_3_0, GL_ARB_sampler_objects</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glSamplerParameteri(GLuint sampler, GLenum pname, GLint param);</para>
        /// </summary>
        public static void glSamplerParameteri(uint sampler, uint pname, int param) {
            var _F = _GetProc<GLNativeDelegate.FNglSamplerParameteri>("glSamplerParameteri");
            _F(sampler, pname, param);
        }
        /// <summary>
        /// set sampler parameters
        /// <para>Require:</para> <para>GL_VERSION_3_3, GL_ES_VERSION_3_0, GL_ARB_sampler_objects</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glSamplerParameteriv(GLuint sampler, GLenum pname, const GLint * params);</para>
        /// </summary>
        public unsafe static void glSamplerParameteriv(uint sampler, uint pname, int* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglSamplerParameteriv>("glSamplerParameteriv");
            _F(sampler, pname, ps);
        }
        /// <summary>
        /// set sampler parameters
        /// <para>Require:</para> <para>GL_VERSION_3_3, GL_ES_VERSION_3_0, GL_ARB_sampler_objects</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glSamplerParameterf(GLuint sampler, GLenum pname, GLfloat param);</para>
        /// </summary>
        public static void glSamplerParameterf(uint sampler, uint pname, float param) {
            var _F = _GetProc<GLNativeDelegate.FNglSamplerParameterf>("glSamplerParameterf");
            _F(sampler, pname, param);
        }
        /// <summary>
        /// set sampler parameters
        /// <para>Require:</para> <para>GL_VERSION_3_3, GL_ES_VERSION_3_0, GL_ARB_sampler_objects</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glSamplerParameterfv(GLuint sampler, GLenum pname, const GLfloat * params);</para>
        /// </summary>
        public unsafe static void glSamplerParameterfv(uint sampler, uint pname, float* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglSamplerParameterfv>("glSamplerParameterfv");
            _F(sampler, pname, ps);
        }
        /// <summary>
        /// set sampler parameters
        /// <para>Require:</para> <para>GL_VERSION_3_3, GL_ES_VERSION_3_2, GL_ARB_sampler_objects</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glSamplerParameterIiv(GLuint sampler, GLenum pname, const GLint * params);</para>
        /// </summary>
        public unsafe static void glSamplerParameterIiv(uint sampler, uint pname, int* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglSamplerParameterIiv>("glSamplerParameterIiv");
            _F(sampler, pname, ps);
        }
        /// <summary>
        /// set sampler parameters
        /// <para>Require:</para> <para>GL_VERSION_3_3, GL_ES_VERSION_3_2, GL_ARB_sampler_objects</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glSamplerParameterIuiv(GLuint sampler, GLenum pname, const GLuint * params);</para>
        /// </summary>
        public unsafe static void glSamplerParameterIuiv(uint sampler, uint pname, uint* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglSamplerParameterIuiv>("glSamplerParameterIuiv");
            _F(sampler, pname, ps);
        }
        /// <summary>
        /// return sampler parameter values
        /// <para>Require:</para> <para>GL_VERSION_3_3, GL_ES_VERSION_3_0, GL_ARB_sampler_objects</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetSamplerParameteriv(GLuint sampler, GLenum pname, GLint * params);</para>
        /// </summary>
        public unsafe static void glGetSamplerParameteriv(uint sampler, uint pname, int* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetSamplerParameteriv>("glGetSamplerParameteriv");
            _F(sampler, pname, ps);
        }
        /// <summary>
        /// return sampler parameter values
        /// <para>Require:</para> <para>GL_VERSION_3_3, GL_ES_VERSION_3_2, GL_ARB_sampler_objects</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetSamplerParameterIiv(GLuint sampler, GLenum pname, GLint * params);</para>
        /// </summary>
        public unsafe static void glGetSamplerParameterIiv(uint sampler, uint pname, int* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetSamplerParameterIiv>("glGetSamplerParameterIiv");
            _F(sampler, pname, ps);
        }
        /// <summary>
        /// return sampler parameter values
        /// <para>Require:</para> <para>GL_VERSION_3_3, GL_ES_VERSION_3_0, GL_ARB_sampler_objects</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetSamplerParameterfv(GLuint sampler, GLenum pname, GLfloat * params);</para>
        /// </summary>
        public unsafe static void glGetSamplerParameterfv(uint sampler, uint pname, float* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetSamplerParameterfv>("glGetSamplerParameterfv");
            _F(sampler, pname, ps);
        }
        /// <summary>
        /// return sampler parameter values
        /// <para>Require:</para> <para>GL_VERSION_3_3, GL_ES_VERSION_3_2, GL_ARB_sampler_objects</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetSamplerParameterIuiv(GLuint sampler, GLenum pname, GLuint * params);</para>
        /// </summary>
        public unsafe static void glGetSamplerParameterIuiv(uint sampler, uint pname, uint* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetSamplerParameterIuiv>("glGetSamplerParameterIuiv");
            _F(sampler, pname, ps);
        }

        #endregion Reuse ARB_sampler_objects

        #region Reuse ARB_timer_query

        /// <summary>
        /// record the GL time into a query object after all previous commands have reached the GL server but have not yet necessarily executed.
        /// <para>Require:</para> <para>GL_VERSION_3_3, GL_ARB_timer_query</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glQueryCounter(GLuint id, GLenum target);</para>
        /// </summary>
        public static void glQueryCounter(uint id, uint target) {
            var _F = _GetProc<GLNativeDelegate.FNglQueryCounter>("glQueryCounter");
            _F(id, target);
        }
        /// <summary>
        /// return parameters of a query object
        /// <para>Require:</para> <para>GL_VERSION_3_3, GL_ARB_timer_query</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetQueryObjecti64v(GLuint id, GLenum pname, GLint64 * params);</para>
        /// </summary>
        public unsafe static void glGetQueryObjecti64v(uint id, uint pname, UInt64* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetQueryObjecti64v>("glGetQueryObjecti64v");
            _F(id, pname, ps);
        }
        /// <summary>
        /// return parameters of a query object
        /// <para>Require:</para> <para>GL_VERSION_3_3, GL_ARB_timer_query</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetQueryObjectui64v(GLuint id, GLenum pname, GLuint64 * params);</para>
        /// </summary>
        public unsafe static void glGetQueryObjectui64v(uint id, uint pname, UInt64* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetQueryObjectui64v>("glGetQueryObjectui64v");
            _F(id, pname, ps);
        }

        #endregion Reuse ARB_timer_query

        #region Reuse ARB_vertex_type_2_10_10_10_rev

        /// <summary>
        /// modify the rate at which generic vertex attributes advance during instanced rendering
        /// <para>Require:</para> <para>GL_VERSION_3_3, GL_ES_VERSION_3_0</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glVertexAttribDivisor(GLuint index, GLuint divisor);</para>
        /// </summary>
        public static void glVertexAttribDivisor(uint index, uint divisor) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttribDivisor>("glVertexAttribDivisor");
            _F(index, divisor);
        }
        /// <summary>
        /// Specifies the value of a generic vertex attribute
        /// <para>Require:</para> <para>GL_VERSION_3_3, GL_ARB_vertex_type_2_10_10_10_rev</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glVertexAttribP1ui(GLuint index, GLenum type, GLboolean normalized, GLuint value);</para>
        /// </summary>
        public static void glVertexAttribP1ui(uint index, uint type, bool normalized, uint value) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttribP1ui>("glVertexAttribP1ui");
            _F(index, type, normalized, value);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_VERSION_3_3, GL_ARB_vertex_type_2_10_10_10_rev</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glVertexAttribP1uiv(GLuint index, GLenum type, GLboolean normalized, const GLuint * value);</para>
        /// </summary>
        public unsafe static void glVertexAttribP1uiv(uint index, uint type, bool normalized, uint* value) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttribP1uiv>("glVertexAttribP1uiv");
            _F(index, type, normalized, value);
        }
        /// <summary>
        /// Specifies the value of a generic vertex attribute
        /// <para>Require:</para> <para>GL_VERSION_3_3, GL_ARB_vertex_type_2_10_10_10_rev</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glVertexAttribP2ui(GLuint index, GLenum type, GLboolean normalized, GLuint value);</para>
        /// </summary>
        public static void glVertexAttribP2ui(uint index, uint type, bool normalized, uint value) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttribP2ui>("glVertexAttribP2ui");
            _F(index, type, normalized, value);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_VERSION_3_3, GL_ARB_vertex_type_2_10_10_10_rev</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glVertexAttribP2uiv(GLuint index, GLenum type, GLboolean normalized, const GLuint * value);</para>
        /// </summary>
        public unsafe static void glVertexAttribP2uiv(uint index, uint type, bool normalized, uint* value) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttribP2uiv>("glVertexAttribP2uiv");
            _F(index, type, normalized, value);
        }
        /// <summary>
        /// Specifies the value of a generic vertex attribute
        /// <para>Require:</para> <para>GL_VERSION_3_3, GL_ARB_vertex_type_2_10_10_10_rev</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glVertexAttribP3ui(GLuint index, GLenum type, GLboolean normalized, GLuint value);</para>
        /// </summary>
        public static void glVertexAttribP3ui(uint index, uint type, bool normalized, uint value) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttribP3ui>("glVertexAttribP3ui");
            _F(index, type, normalized, value);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_VERSION_3_3, GL_ARB_vertex_type_2_10_10_10_rev</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glVertexAttribP3uiv(GLuint index, GLenum type, GLboolean normalized, const GLuint * value);</para>
        /// </summary>
        public unsafe static void glVertexAttribP3uiv(uint index, uint type, bool normalized, uint* value) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttribP3uiv>("glVertexAttribP3uiv");
            _F(index, type, normalized, value);
        }
        /// <summary>
        /// Specifies the value of a generic vertex attribute
        /// <para>Require:</para> <para>GL_VERSION_3_3, GL_ARB_vertex_type_2_10_10_10_rev</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glVertexAttribP4ui(GLuint index, GLenum type, GLboolean normalized, GLuint value);</para>
        /// </summary>
        public static void glVertexAttribP4ui(uint index, uint type, bool normalized, uint value) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttribP4ui>("glVertexAttribP4ui");
            _F(index, type, normalized, value);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_VERSION_3_3, GL_ARB_vertex_type_2_10_10_10_rev</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glVertexAttribP4uiv(GLuint index, GLenum type, GLboolean normalized, const GLuint * value);</para>
        /// </summary>
        public unsafe static void glVertexAttribP4uiv(uint index, uint type, bool normalized, uint* value) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttribP4uiv>("glVertexAttribP4uiv");
            _F(index, type, normalized, value);
        }

        #endregion Reuse ARB_vertex_type_2_10_10_10_rev

        #region Reuse ARB_vertex_type_2_10_10_10_rev compatibility profile

        /// <summary>
        /// <para>Require:</para> <para>GL_VERSION_3_3, GL_ARB_vertex_type_2_10_10_10_rev</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glVertexP2ui(GLenum type, GLuint value);</para>
        /// </summary>
        public static void glVertexP2ui(uint type, uint value) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexP2ui>("glVertexP2ui");
            _F(type, value);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_VERSION_3_3, GL_ARB_vertex_type_2_10_10_10_rev</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glVertexP2uiv(GLenum type, const GLuint * value);</para>
        /// </summary>
        public unsafe static void glVertexP2uiv(uint type, uint* value) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexP2uiv>("glVertexP2uiv");
            _F(type, value);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_VERSION_3_3, GL_ARB_vertex_type_2_10_10_10_rev</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glVertexP3ui(GLenum type, GLuint value);</para>
        /// </summary>
        public static void glVertexP3ui(uint type, uint value) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexP3ui>("glVertexP3ui");
            _F(type, value);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_VERSION_3_3, GL_ARB_vertex_type_2_10_10_10_rev</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glVertexP3uiv(GLenum type, const GLuint * value);</para>
        /// </summary>
        public unsafe static void glVertexP3uiv(uint type, uint* value) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexP3uiv>("glVertexP3uiv");
            _F(type, value);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_VERSION_3_3, GL_ARB_vertex_type_2_10_10_10_rev</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glVertexP4ui(GLenum type, GLuint value);</para>
        /// </summary>
        public static void glVertexP4ui(uint type, uint value) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexP4ui>("glVertexP4ui");
            _F(type, value);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_VERSION_3_3, GL_ARB_vertex_type_2_10_10_10_rev</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glVertexP4uiv(GLenum type, const GLuint * value);</para>
        /// </summary>
        public unsafe static void glVertexP4uiv(uint type, uint* value) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexP4uiv>("glVertexP4uiv");
            _F(type, value);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_VERSION_3_3, GL_ARB_vertex_type_2_10_10_10_rev</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glTexCoordP1ui(GLenum type, GLuint coords);</para>
        /// </summary>
        public static void glTexCoordP1ui(uint type, uint coords) {
            var _F = _GetProc<GLNativeDelegate.FNglTexCoordP1ui>("glTexCoordP1ui");
            _F(type, coords);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_VERSION_3_3, GL_ARB_vertex_type_2_10_10_10_rev</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glTexCoordP1uiv(GLenum type, const GLuint * coords);</para>
        /// </summary>
        public unsafe static void glTexCoordP1uiv(uint type, uint* coords) {
            var _F = _GetProc<GLNativeDelegate.FNglTexCoordP1uiv>("glTexCoordP1uiv");
            _F(type, coords);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_VERSION_3_3, GL_ARB_vertex_type_2_10_10_10_rev</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glTexCoordP2ui(GLenum type, GLuint coords);</para>
        /// </summary>
        public static void glTexCoordP2ui(uint type, uint coords) {
            var _F = _GetProc<GLNativeDelegate.FNglTexCoordP2ui>("glTexCoordP2ui");
            _F(type, coords);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_VERSION_3_3, GL_ARB_vertex_type_2_10_10_10_rev</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glTexCoordP2uiv(GLenum type, const GLuint * coords);</para>
        /// </summary>
        public unsafe static void glTexCoordP2uiv(uint type, uint* coords) {
            var _F = _GetProc<GLNativeDelegate.FNglTexCoordP2uiv>("glTexCoordP2uiv");
            _F(type, coords);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_VERSION_3_3, GL_ARB_vertex_type_2_10_10_10_rev</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glTexCoordP3ui(GLenum type, GLuint coords);</para>
        /// </summary>
        public static void glTexCoordP3ui(uint type, uint coords) {
            var _F = _GetProc<GLNativeDelegate.FNglTexCoordP3ui>("glTexCoordP3ui");
            _F(type, coords);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_VERSION_3_3, GL_ARB_vertex_type_2_10_10_10_rev</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glTexCoordP3uiv(GLenum type, const GLuint * coords);</para>
        /// </summary>
        public unsafe static void glTexCoordP3uiv(uint type, uint* coords) {
            var _F = _GetProc<GLNativeDelegate.FNglTexCoordP3uiv>("glTexCoordP3uiv");
            _F(type, coords);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_VERSION_3_3, GL_ARB_vertex_type_2_10_10_10_rev</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glTexCoordP4ui(GLenum type, GLuint coords);</para>
        /// </summary>
        public static void glTexCoordP4ui(uint type, uint coords) {
            var _F = _GetProc<GLNativeDelegate.FNglTexCoordP4ui>("glTexCoordP4ui");
            _F(type, coords);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_VERSION_3_3, GL_ARB_vertex_type_2_10_10_10_rev</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glTexCoordP4uiv(GLenum type, const GLuint * coords);</para>
        /// </summary>
        public unsafe static void glTexCoordP4uiv(uint type, uint* coords) {
            var _F = _GetProc<GLNativeDelegate.FNglTexCoordP4uiv>("glTexCoordP4uiv");
            _F(type, coords);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_VERSION_3_3, GL_ARB_vertex_type_2_10_10_10_rev</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glMultiTexCoordP1ui(GLenum texture, GLenum type, GLuint coords);</para>
        /// </summary>
        public static void glMultiTexCoordP1ui(uint texture, uint type, uint coords) {
            var _F = _GetProc<GLNativeDelegate.FNglMultiTexCoordP1ui>("glMultiTexCoordP1ui");
            _F(texture, type, coords);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_VERSION_3_3, GL_ARB_vertex_type_2_10_10_10_rev</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glMultiTexCoordP1uiv(GLenum texture, GLenum type, const GLuint * coords);</para>
        /// </summary>
        public unsafe static void glMultiTexCoordP1uiv(uint texture, uint type, uint* coords) {
            var _F = _GetProc<GLNativeDelegate.FNglMultiTexCoordP1uiv>("glMultiTexCoordP1uiv");
            _F(texture, type, coords);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_VERSION_3_3, GL_ARB_vertex_type_2_10_10_10_rev</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glMultiTexCoordP2ui(GLenum texture, GLenum type, GLuint coords);</para>
        /// </summary>
        public static void glMultiTexCoordP2ui(uint texture, uint type, uint coords) {
            var _F = _GetProc<GLNativeDelegate.FNglMultiTexCoordP2ui>("glMultiTexCoordP2ui");
            _F(texture, type, coords);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_VERSION_3_3, GL_ARB_vertex_type_2_10_10_10_rev</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glMultiTexCoordP2uiv(GLenum texture, GLenum type, const GLuint * coords);</para>
        /// </summary>
        public unsafe static void glMultiTexCoordP2uiv(uint texture, uint type, uint* coords) {
            var _F = _GetProc<GLNativeDelegate.FNglMultiTexCoordP2uiv>("glMultiTexCoordP2uiv");
            _F(texture, type, coords);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_VERSION_3_3, GL_ARB_vertex_type_2_10_10_10_rev</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glMultiTexCoordP3ui(GLenum texture, GLenum type, GLuint coords);</para>
        /// </summary>
        public static void glMultiTexCoordP3ui(uint texture, uint type, uint coords) {
            var _F = _GetProc<GLNativeDelegate.FNglMultiTexCoordP3ui>("glMultiTexCoordP3ui");
            _F(texture, type, coords);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_VERSION_3_3, GL_ARB_vertex_type_2_10_10_10_rev</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glMultiTexCoordP3uiv(GLenum texture, GLenum type, const GLuint * coords);</para>
        /// </summary>
        public unsafe static void glMultiTexCoordP3uiv(uint texture, uint type, uint* coords) {
            var _F = _GetProc<GLNativeDelegate.FNglMultiTexCoordP3uiv>("glMultiTexCoordP3uiv");
            _F(texture, type, coords);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_VERSION_3_3, GL_ARB_vertex_type_2_10_10_10_rev</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glMultiTexCoordP4ui(GLenum texture, GLenum type, GLuint coords);</para>
        /// </summary>
        public static void glMultiTexCoordP4ui(uint texture, uint type, uint coords) {
            var _F = _GetProc<GLNativeDelegate.FNglMultiTexCoordP4ui>("glMultiTexCoordP4ui");
            _F(texture, type, coords);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_VERSION_3_3, GL_ARB_vertex_type_2_10_10_10_rev</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glMultiTexCoordP4uiv(GLenum texture, GLenum type, const GLuint * coords);</para>
        /// </summary>
        public unsafe static void glMultiTexCoordP4uiv(uint texture, uint type, uint* coords) {
            var _F = _GetProc<GLNativeDelegate.FNglMultiTexCoordP4uiv>("glMultiTexCoordP4uiv");
            _F(texture, type, coords);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_VERSION_3_3, GL_ARB_vertex_type_2_10_10_10_rev</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glNormalP3ui(GLenum type, GLuint coords);</para>
        /// </summary>
        public static void glNormalP3ui(uint type, uint coords) {
            var _F = _GetProc<GLNativeDelegate.FNglNormalP3ui>("glNormalP3ui");
            _F(type, coords);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_VERSION_3_3, GL_ARB_vertex_type_2_10_10_10_rev</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glNormalP3uiv(GLenum type, const GLuint * coords);</para>
        /// </summary>
        public unsafe static void glNormalP3uiv(uint type, uint* coords) {
            var _F = _GetProc<GLNativeDelegate.FNglNormalP3uiv>("glNormalP3uiv");
            _F(type, coords);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_VERSION_3_3, GL_ARB_vertex_type_2_10_10_10_rev</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glColorP3ui(GLenum type, GLuint color);</para>
        /// </summary>
        public static void glColorP3ui(uint type, uint color) {
            var _F = _GetProc<GLNativeDelegate.FNglColorP3ui>("glColorP3ui");
            _F(type, color);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_VERSION_3_3, GL_ARB_vertex_type_2_10_10_10_rev</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glColorP3uiv(GLenum type, const GLuint * color);</para>
        /// </summary>
        public unsafe static void glColorP3uiv(uint type, uint* color) {
            var _F = _GetProc<GLNativeDelegate.FNglColorP3uiv>("glColorP3uiv");
            _F(type, color);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_VERSION_3_3, GL_ARB_vertex_type_2_10_10_10_rev</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glColorP4ui(GLenum type, GLuint color);</para>
        /// </summary>
        public static void glColorP4ui(uint type, uint color) {
            var _F = _GetProc<GLNativeDelegate.FNglColorP4ui>("glColorP4ui");
            _F(type, color);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_VERSION_3_3, GL_ARB_vertex_type_2_10_10_10_rev</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glColorP4uiv(GLenum type, const GLuint * color);</para>
        /// </summary>
        public unsafe static void glColorP4uiv(uint type, uint* color) {
            var _F = _GetProc<GLNativeDelegate.FNglColorP4uiv>("glColorP4uiv");
            _F(type, color);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_VERSION_3_3, GL_ARB_vertex_type_2_10_10_10_rev</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glSecondaryColorP3ui(GLenum type, GLuint color);</para>
        /// </summary>
        public static void glSecondaryColorP3ui(uint type, uint color) {
            var _F = _GetProc<GLNativeDelegate.FNglSecondaryColorP3ui>("glSecondaryColorP3ui");
            _F(type, color);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_VERSION_3_3, GL_ARB_vertex_type_2_10_10_10_rev</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glSecondaryColorP3uiv(GLenum type, const GLuint * color);</para>
        /// </summary>
        public unsafe static void glSecondaryColorP3uiv(uint type, uint* color) {
            var _F = _GetProc<GLNativeDelegate.FNglSecondaryColorP3uiv>("glSecondaryColorP3uiv");
            _F(type, color);
        }

        #endregion Reuse ARB_vertex_type_2_10_10_10_rev compatibility profile

        #endregion GL_VERSION_3_3

        #region GL_VERSION_4_0

        /// <summary>
        /// specifies minimum rate at which sample shading takes place
        /// <para>Require:</para> <para>GL_VERSION_4_0, GL_ES_VERSION_3_2</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glMinSampleShading(GLfloat value);</para>
        /// </summary>
        public static void glMinSampleShading(float value) {
            var _F = _GetProc<GLNativeDelegate.FNglMinSampleShading>("glMinSampleShading");
            _F(value);
        }
        /// <summary>
        /// specify the equation used for both the RGB blend equation and the Alpha blend equation
        /// <para>Require:</para> <para>GL_VERSION_4_0, GL_ES_VERSION_3_2</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glBlendEquationi(GLuint buf, GLenum mode);</para>
        /// </summary>
        public static void glBlendEquationi(uint buf, uint mode) {
            var _F = _GetProc<GLNativeDelegate.FNglBlendEquationi>("glBlendEquationi");
            _F(buf, mode);
        }
        /// <summary>
        /// set the RGB blend equation and the alpha blend equation separately
        /// <para>Require:</para> <para>GL_VERSION_4_0, GL_ES_VERSION_3_2</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glBlendEquationSeparatei(GLuint buf, GLenum modeRGB, GLenum modeAlpha);</para>
        /// </summary>
        public static void glBlendEquationSeparatei(uint buf, uint modeRGB, uint modeAlpha) {
            var _F = _GetProc<GLNativeDelegate.FNglBlendEquationSeparatei>("glBlendEquationSeparatei");
            _F(buf, modeRGB, modeAlpha);
        }
        /// <summary>
        /// specify pixel arithmetic
        /// <para>Require:</para> <para>GL_VERSION_4_0, GL_ES_VERSION_3_2</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glBlendFunci(GLuint buf, GLenum sfactor, GLenum dfactor);</para>
        /// </summary>
        public static void glBlendFunci(uint buf, uint sfactor, uint dfactor) {
            var _F = _GetProc<GLNativeDelegate.FNglBlendFunci>("glBlendFunci");
            _F(buf, sfactor, dfactor);
        }
        /// <summary>
        /// specify pixel arithmetic for RGB and alpha components separately
        /// <para>Require:</para> <para>GL_VERSION_4_0, GL_ES_VERSION_3_2</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glBlendFuncSeparatei(GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha);</para>
        /// </summary>
        public static void glBlendFuncSeparatei(uint buf, uint srcRGB, uint dstRGB, uint srcAlpha, uint dstAlpha) {
            var _F = _GetProc<GLNativeDelegate.FNglBlendFuncSeparatei>("glBlendFuncSeparatei");
            _F(buf, srcRGB, dstRGB, srcAlpha, dstAlpha);
        }

        #region Reuse ARB_draw_indirect

        /// <summary>
        /// render primitives from array data, taking parameters from memory
        /// <para>Require:</para> <para>GL_VERSION_4_0, GL_ES_VERSION_3_1, GL_ARB_draw_indirect</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glDrawArraysIndirect(GLenum mode, const void * indirect);</para>
        /// </summary>
        public unsafe static void glDrawArraysIndirect(uint mode, void* indirect) {
            var _F = _GetProc<GLNativeDelegate.FNglDrawArraysIndirect>("glDrawArraysIndirect");
            _F(mode, indirect);
        }
        /// <summary>
        /// render indexed primitives from array data, taking parameters from memory
        /// <para>Require:</para> <para>GL_VERSION_4_0, GL_ES_VERSION_3_1, GL_ARB_draw_indirect</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glDrawElementsIndirect(GLenum mode, GLenum type, const void * indirect);</para>
        /// </summary>
        public unsafe static void glDrawElementsIndirect(uint mode, uint type, void* indirect) {
            var _F = _GetProc<GLNativeDelegate.FNglDrawElementsIndirect>("glDrawElementsIndirect");
            _F(mode, type, indirect);
        }

        #endregion Reuse ARB_draw_indirect

        #region Reuse ARB_gpu_shader_fp64

        /// <summary>
        /// <para>Require:</para> <para>GL_VERSION_4_0, GL_ARB_gpu_shader_fp64</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glUniform1d(GLint location, GLdouble x);</para>
        /// </summary>
        public static void glUniform1d(int location, double x) {
            var _F = _GetProc<GLNativeDelegate.FNglUniform1d>("glUniform1d");
            _F(location, x);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_VERSION_4_0, GL_ARB_gpu_shader_fp64</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glUniform2d(GLint location, GLdouble x, GLdouble y);</para>
        /// </summary>
        public static void glUniform2d(int location, double x, double y) {
            var _F = _GetProc<GLNativeDelegate.FNglUniform2d>("glUniform2d");
            _F(location, x, y);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_VERSION_4_0, GL_ARB_gpu_shader_fp64</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glUniform3d(GLint location, GLdouble x, GLdouble y, GLdouble z);</para>
        /// </summary>
        public static void glUniform3d(int location, double x, double y, double z) {
            var _F = _GetProc<GLNativeDelegate.FNglUniform3d>("glUniform3d");
            _F(location, x, y, z);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_VERSION_4_0, GL_ARB_gpu_shader_fp64</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glUniform4d(GLint location, GLdouble x, GLdouble y, GLdouble z, GLdouble w);</para>
        /// </summary>
        public static void glUniform4d(int location, double x, double y, double z, double w) {
            var _F = _GetProc<GLNativeDelegate.FNglUniform4d>("glUniform4d");
            _F(location, x, y, z, w);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_VERSION_4_0, GL_ARB_gpu_shader_fp64</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glUniform1dv(GLint location, GLsizei count, const GLdouble * value);</para>
        /// </summary>
        public unsafe static void glUniform1dv(int location, int count, double* value) {
            var _F = _GetProc<GLNativeDelegate.FNglUniform1dv>("glUniform1dv");
            _F(location, count, value);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_VERSION_4_0, GL_ARB_gpu_shader_fp64</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glUniform2dv(GLint location, GLsizei count, const GLdouble * value);</para>
        /// </summary>
        public unsafe static void glUniform2dv(int location, int count, double* value) {
            var _F = _GetProc<GLNativeDelegate.FNglUniform2dv>("glUniform2dv");
            _F(location, count, value);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_VERSION_4_0, GL_ARB_gpu_shader_fp64</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glUniform3dv(GLint location, GLsizei count, const GLdouble * value);</para>
        /// </summary>
        public unsafe static void glUniform3dv(int location, int count, double* value) {
            var _F = _GetProc<GLNativeDelegate.FNglUniform3dv>("glUniform3dv");
            _F(location, count, value);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_VERSION_4_0, GL_ARB_gpu_shader_fp64</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glUniform4dv(GLint location, GLsizei count, const GLdouble * value);</para>
        /// </summary>
        public unsafe static void glUniform4dv(int location, int count, double* value) {
            var _F = _GetProc<GLNativeDelegate.FNglUniform4dv>("glUniform4dv");
            _F(location, count, value);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_VERSION_4_0, GL_ARB_gpu_shader_fp64</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glUniformMatrix2dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);</para>
        /// </summary>
        public unsafe static void glUniformMatrix2dv(int location, int count, bool transpose, double* value) {
            var _F = _GetProc<GLNativeDelegate.FNglUniformMatrix2dv>("glUniformMatrix2dv");
            _F(location, count, transpose, value);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_VERSION_4_0, GL_ARB_gpu_shader_fp64</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glUniformMatrix3dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);</para>
        /// </summary>
        public unsafe static void glUniformMatrix3dv(int location, int count, bool transpose, double* value) {
            var _F = _GetProc<GLNativeDelegate.FNglUniformMatrix3dv>("glUniformMatrix3dv");
            _F(location, count, transpose, value);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_VERSION_4_0, GL_ARB_gpu_shader_fp64</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glUniformMatrix4dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);</para>
        /// </summary>
        public unsafe static void glUniformMatrix4dv(int location, int count, bool transpose, double* value) {
            var _F = _GetProc<GLNativeDelegate.FNglUniformMatrix4dv>("glUniformMatrix4dv");
            _F(location, count, transpose, value);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_VERSION_4_0, GL_ARB_gpu_shader_fp64</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glUniformMatrix2x3dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);</para>
        /// </summary>
        public unsafe static void glUniformMatrix2x3dv(int location, int count, bool transpose, double* value) {
            var _F = _GetProc<GLNativeDelegate.FNglUniformMatrix2x3dv>("glUniformMatrix2x3dv");
            _F(location, count, transpose, value);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_VERSION_4_0, GL_ARB_gpu_shader_fp64</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glUniformMatrix2x4dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);</para>
        /// </summary>
        public unsafe static void glUniformMatrix2x4dv(int location, int count, bool transpose, double* value) {
            var _F = _GetProc<GLNativeDelegate.FNglUniformMatrix2x4dv>("glUniformMatrix2x4dv");
            _F(location, count, transpose, value);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_VERSION_4_0, GL_ARB_gpu_shader_fp64</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glUniformMatrix3x2dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);</para>
        /// </summary>
        public unsafe static void glUniformMatrix3x2dv(int location, int count, bool transpose, double* value) {
            var _F = _GetProc<GLNativeDelegate.FNglUniformMatrix3x2dv>("glUniformMatrix3x2dv");
            _F(location, count, transpose, value);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_VERSION_4_0, GL_ARB_gpu_shader_fp64</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glUniformMatrix3x4dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);</para>
        /// </summary>
        public unsafe static void glUniformMatrix3x4dv(int location, int count, bool transpose, double* value) {
            var _F = _GetProc<GLNativeDelegate.FNglUniformMatrix3x4dv>("glUniformMatrix3x4dv");
            _F(location, count, transpose, value);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_VERSION_4_0, GL_ARB_gpu_shader_fp64</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glUniformMatrix4x2dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);</para>
        /// </summary>
        public unsafe static void glUniformMatrix4x2dv(int location, int count, bool transpose, double* value) {
            var _F = _GetProc<GLNativeDelegate.FNglUniformMatrix4x2dv>("glUniformMatrix4x2dv");
            _F(location, count, transpose, value);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_VERSION_4_0, GL_ARB_gpu_shader_fp64</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glUniformMatrix4x3dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);</para>
        /// </summary>
        public unsafe static void glUniformMatrix4x3dv(int location, int count, bool transpose, double* value) {
            var _F = _GetProc<GLNativeDelegate.FNglUniformMatrix4x3dv>("glUniformMatrix4x3dv");
            _F(location, count, transpose, value);
        }
        /// <summary>
        /// Returns the value of a uniform variable
        /// <para>Require:</para> <para>GL_VERSION_4_0, GL_ARB_gpu_shader_fp64</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetUniformdv(GLuint program, GLint location, GLdouble * params);</para>
        /// </summary>
        public unsafe static void glGetUniformdv(uint program, int location, double* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetUniformdv>("glGetUniformdv");
            _F(program, location, ps);
        }

        #endregion Reuse ARB_gpu_shader_fp64

        #region Reuse ARB_shader_subroutine

        /// <summary>
        /// retrieve the location of a subroutine uniform of a given shader stage within a program
        /// <para>Require:</para> <para>GL_VERSION_4_0, GL_ARB_shader_subroutine</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>GLint glGetSubroutineUniformLocation(GLuint program, GLenum shadertype, const GLchar * name);</para>
        /// </summary>
        public unsafe static int glGetSubroutineUniformLocation(uint program, uint shadertype, byte* name) {
            var _F = _GetProc<GLNativeDelegate.FNglGetSubroutineUniformLocation>("glGetSubroutineUniformLocation");
            return _F(program, shadertype, name);
        }
        /// <summary>
        /// retrieve the index of a subroutine uniform of a given shader stage within a program
        /// <para>Require:</para> <para>GL_VERSION_4_0, GL_ARB_shader_subroutine</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>GLuint glGetSubroutineIndex(GLuint program, GLenum shadertype, const GLchar * name);</para>
        /// </summary>
        public unsafe static uint glGetSubroutineIndex(uint program, uint shadertype, byte* name) {
            var _F = _GetProc<GLNativeDelegate.FNglGetSubroutineIndex>("glGetSubroutineIndex");
            return _F(program, shadertype, name);
        }
        /// <summary>
        /// query a property of an active shader subroutine uniform
        /// <para>Require:</para> <para>GL_VERSION_4_0, GL_ARB_shader_subroutine</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetActiveSubroutineUniformiv(GLuint program, GLenum shadertype, GLuint index, GLenum pname, GLint * values);</para>
        /// </summary>
        public unsafe static void glGetActiveSubroutineUniformiv(uint program, uint shadertype, uint index, uint pname, int* values) {
            var _F = _GetProc<GLNativeDelegate.FNglGetActiveSubroutineUniformiv>("glGetActiveSubroutineUniformiv");
            _F(program, shadertype, index, pname, values);
        }
        /// <summary>
        /// query the name of an active shader subroutine uniform
        /// <para>Require:</para> <para>GL_VERSION_4_0, GL_ARB_shader_subroutine</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetActiveSubroutineUniformName(GLuint program, GLenum shadertype, GLuint index, GLsizei bufSize, GLsizei * length, GLchar * name);</para>
        /// </summary>
        public unsafe static void glGetActiveSubroutineUniformName(uint program, uint shadertype, uint index, int bufSize, int* length, byte* name) {
            var _F = _GetProc<GLNativeDelegate.FNglGetActiveSubroutineUniformName>("glGetActiveSubroutineUniformName");
            _F(program, shadertype, index, bufSize, length, name);
        }
        /// <summary>
        /// query the name of an active shader subroutine
        /// <para>Require:</para> <para>GL_VERSION_4_0, GL_ARB_shader_subroutine</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetActiveSubroutineName(GLuint program, GLenum shadertype, GLuint index, GLsizei bufSize, GLsizei * length, GLchar * name);</para>
        /// </summary>
        public unsafe static void glGetActiveSubroutineName(uint program, uint shadertype, uint index, int bufSize, int* length, byte* name) {
            var _F = _GetProc<GLNativeDelegate.FNglGetActiveSubroutineName>("glGetActiveSubroutineName");
            _F(program, shadertype, index, bufSize, length, name);
        }
        /// <summary>
        /// load active subroutine uniforms
        /// <para>Require:</para> <para>GL_VERSION_4_0, GL_ARB_shader_subroutine</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glUniformSubroutinesuiv(GLenum shadertype, GLsizei count, const GLuint * indices);</para>
        /// </summary>
        public unsafe static void glUniformSubroutinesuiv(uint shadertype, int count, uint* indices) {
            var _F = _GetProc<GLNativeDelegate.FNglUniformSubroutinesuiv>("glUniformSubroutinesuiv");
            _F(shadertype, count, indices);
        }
        /// <summary>
        /// retrieve the value of a subroutine uniform of a given shader stage of the current program
        /// <para>Require:</para> <para>GL_VERSION_4_0, GL_ARB_shader_subroutine</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetUniformSubroutineuiv(GLenum shadertype, GLint location, GLuint * values);</para>
        /// </summary>
        public unsafe static void glGetUniformSubroutineuiv(uint shadertype, int location, uint* values) {
            var _F = _GetProc<GLNativeDelegate.FNglGetUniformSubroutineuiv>("glGetUniformSubroutineuiv");
            _F(shadertype, location, values);
        }
        /// <summary>
        /// retrieve properties of a program object corresponding to a specified shader stage
        /// <para>Require:</para> <para>GL_VERSION_4_0, GL_ARB_shader_subroutine</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetProgramStageiv(GLuint program, GLenum shadertype, GLenum pname, GLint * values);</para>
        /// </summary>
        public unsafe static void glGetProgramStageiv(uint program, uint shadertype, uint pname, int* values) {
            var _F = _GetProc<GLNativeDelegate.FNglGetProgramStageiv>("glGetProgramStageiv");
            _F(program, shadertype, pname, values);
        }

        #endregion Reuse ARB_shader_subroutine

        #region Reuse ARB_tessellation_shader

        /// <summary>
        /// specifies the parameters for patch primitives
        /// <para>Require:</para> <para>GL_VERSION_4_0, GL_ES_VERSION_3_2, GL_ARB_tessellation_shader</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glPatchParameteri(GLenum pname, GLint value);</para>
        /// </summary>
        public static void glPatchParameteri(uint pname, int value) {
            var _F = _GetProc<GLNativeDelegate.FNglPatchParameteri>("glPatchParameteri");
            _F(pname, value);
        }
        /// <summary>
        /// specifies the parameters for patch primitives
        /// <para>Require:</para> <para>GL_VERSION_4_0, GL_ARB_tessellation_shader</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glPatchParameterfv(GLenum pname, const GLfloat * values);</para>
        /// </summary>
        public unsafe static void glPatchParameterfv(uint pname, float* values) {
            var _F = _GetProc<GLNativeDelegate.FNglPatchParameterfv>("glPatchParameterfv");
            _F(pname, values);
        }

        #endregion Reuse ARB_tessellation_shader

        #region Reuse ARB_transform_feedback2

        /// <summary>
        /// bind a transform feedback object
        /// <para>Require:</para> <para>GL_VERSION_4_0, GL_ES_VERSION_3_0, GL_ARB_transform_feedback2</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glBindTransformFeedback(GLenum target, GLuint id);</para>
        /// </summary>
        public static void glBindTransformFeedback(uint target, uint id) {
            var _F = _GetProc<GLNativeDelegate.FNglBindTransformFeedback>("glBindTransformFeedback");
            _F(target, id);
        }
        /// <summary>
        /// delete transform feedback objects
        /// <para>Require:</para> <para>GL_VERSION_4_0, GL_ES_VERSION_3_0, GL_ARB_transform_feedback2</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glDeleteTransformFeedbacks(GLsizei n, const GLuint * ids);</para>
        /// </summary>
        public unsafe static void glDeleteTransformFeedbacks(int n, uint* ids) {
            var _F = _GetProc<GLNativeDelegate.FNglDeleteTransformFeedbacks>("glDeleteTransformFeedbacks");
            _F(n, ids);
        }
        /// <summary>
        /// reserve transform feedback object names
        /// <para>Require:</para> <para>GL_VERSION_4_0, GL_ES_VERSION_3_0, GL_ARB_transform_feedback2</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGenTransformFeedbacks(GLsizei n, GLuint * ids);</para>
        /// </summary>
        public unsafe static void glGenTransformFeedbacks(int n, uint* ids) {
            var _F = _GetProc<GLNativeDelegate.FNglGenTransformFeedbacks>("glGenTransformFeedbacks");
            _F(n, ids);
        }
        /// <summary>
        /// determine if a name corresponds to a transform feedback object
        /// <para>Require:</para> <para>GL_VERSION_4_0, GL_ES_VERSION_3_0, GL_ARB_transform_feedback2</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>GLboolean glIsTransformFeedback(GLuint id);</para>
        /// </summary>
        public static bool glIsTransformFeedback(uint id) {
            var _F = _GetProc<GLNativeDelegate.FNglIsTransformFeedback>("glIsTransformFeedback");
            return _F(id);
        }
        /// <summary>
        /// pause transform feedback operations
        /// <para>Require:</para> <para>GL_VERSION_4_0, GL_ES_VERSION_3_0, GL_ARB_transform_feedback2</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glPauseTransformFeedback();</para>
        /// </summary>
        public static void glPauseTransformFeedback() {
            var _F = _GetProc<GLNativeDelegate.FNglPauseTransformFeedback>("glPauseTransformFeedback");
            _F();
        }
        /// <summary>
        /// resume transform feedback operations
        /// <para>Require:</para> <para>GL_VERSION_4_0, GL_ES_VERSION_3_0, GL_ARB_transform_feedback2</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glResumeTransformFeedback();</para>
        /// </summary>
        public static void glResumeTransformFeedback() {
            var _F = _GetProc<GLNativeDelegate.FNglResumeTransformFeedback>("glResumeTransformFeedback");
            _F();
        }
        /// <summary>
        /// render primitives using a count derived from a transform feedback object
        /// <para>Require:</para> <para>GL_VERSION_4_0, GL_ARB_transform_feedback2</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glDrawTransformFeedback(GLenum mode, GLuint id);</para>
        /// </summary>
        public static void glDrawTransformFeedback(uint mode, uint id) {
            var _F = _GetProc<GLNativeDelegate.FNglDrawTransformFeedback>("glDrawTransformFeedback");
            _F(mode, id);
        }

        #endregion Reuse ARB_transform_feedback2

        #region Reuse ARB_transform_feedback3

        /// <summary>
        /// render primitives using a count derived from a specifed stream of a transform feedback object
        /// <para>Require:</para> <para>GL_VERSION_4_0, GL_ARB_transform_feedback3</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glDrawTransformFeedbackStream(GLenum mode, GLuint id, GLuint stream);</para>
        /// </summary>
        public static void glDrawTransformFeedbackStream(uint mode, uint id, uint stream) {
            var _F = _GetProc<GLNativeDelegate.FNglDrawTransformFeedbackStream>("glDrawTransformFeedbackStream");
            _F(mode, id, stream);
        }
        /// <summary>
        /// delimit the boundaries of a query object on an indexed target
        /// <para>Require:</para> <para>GL_VERSION_4_0, GL_ARB_transform_feedback3</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glBeginQueryIndexed(GLenum target, GLuint index, GLuint id);</para>
        /// </summary>
        public static void glBeginQueryIndexed(uint target, uint index, uint id) {
            var _F = _GetProc<GLNativeDelegate.FNglBeginQueryIndexed>("glBeginQueryIndexed");
            _F(target, index, id);
        }
        /// <summary>
        /// delimit the boundaries of a query object on an indexed target
        /// <para>Require:</para> <para>GL_VERSION_4_0, GL_ARB_transform_feedback3</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glEndQueryIndexed(GLenum target, GLuint index);</para>
        /// </summary>
        public static void glEndQueryIndexed(uint target, uint index) {
            var _F = _GetProc<GLNativeDelegate.FNglEndQueryIndexed>("glEndQueryIndexed");
            _F(target, index);
        }
        /// <summary>
        /// return parameters of an indexed query object target
        /// <para>Require:</para> <para>GL_VERSION_4_0, GL_ARB_transform_feedback3</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetQueryIndexediv(GLenum target, GLuint index, GLenum pname, GLint * params);</para>
        /// </summary>
        public unsafe static void glGetQueryIndexediv(uint target, uint index, uint pname, int* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetQueryIndexediv>("glGetQueryIndexediv");
            _F(target, index, pname, ps);
        }

        #endregion Reuse ARB_transform_feedback3

        #endregion GL_VERSION_4_0

        #region GL_VERSION_4_1


        #region Reuse commands from ARB_ES2_compatibility

        /// <summary>
        /// release resources consumed by the implementation's shader compiler
        /// <para>Require:</para> <para>GL_VERSION_4_1, GL_ES_VERSION_2_0, GL_ARB_ES2_compatibility</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glReleaseShaderCompiler();</para>
        /// </summary>
        public static void glReleaseShaderCompiler() {
            var _F = _GetProc<GLNativeDelegate.FNglReleaseShaderCompiler>("glReleaseShaderCompiler");
            _F();
        }
        /// <summary>
        /// load pre-compiled shader binaries
        /// <para>Require:</para> <para>GL_VERSION_4_1, GL_ES_VERSION_2_0, GL_ARB_ES2_compatibility</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glShaderBinary(GLsizei count, const GLuint * shaders, GLenum binaryFormat, const void * binary, GLsizei length);</para>
        /// </summary>
        public unsafe static void glShaderBinary(int count, uint* shaders, uint binaryFormat, void* binary, int length) {
            var _F = _GetProc<GLNativeDelegate.FNglShaderBinary>("glShaderBinary");
            _F(count, shaders, binaryFormat, binary, length);
        }
        /// <summary>
        /// retrieve the range and precision for numeric formats supported by the shader compiler
        /// <para>Require:</para> <para>GL_VERSION_4_1, GL_ES_VERSION_2_0, GL_ARB_ES2_compatibility</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetShaderPrecisionFormat(GLenum shaderType, GLenum precisionType, GLint * range, GLint * precision);</para>
        /// </summary>
        public unsafe static void glGetShaderPrecisionFormat(uint shaderType, uint precisionType, int* range, int* precision) {
            var _F = _GetProc<GLNativeDelegate.FNglGetShaderPrecisionFormat>("glGetShaderPrecisionFormat");
            _F(shaderType, precisionType, range, precision);
        }
        /// <summary>
        /// specify mapping of depth values from normalized device coordinates to window coordinates
        /// <para>Require:</para> <para>GL_VERSION_4_1, GL_VERSION_ES_CM_1_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0, GL_ARB_ES2_compatibility</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glDepthRangef(GLfloat nearVal, GLfloat farVal);</para>
        /// </summary>
        public static void glDepthRangef(float nearVal, float farVal) {
            var _F = _GetProc<GLNativeDelegate.FNglDepthRangef>("glDepthRangef");
            _F(nearVal, farVal);
        }
        /// <summary>
        /// specify the clear value for the depth buffer
        /// <para>Require:</para> <para>GL_VERSION_4_1, GL_VERSION_ES_CM_1_0, GL_ES_VERSION_2_0, GL_SC_VERSION_2_0, GL_ARB_ES2_compatibility</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glClearDepthf(GLfloat depth);</para>
        /// </summary>
        public static void glClearDepthf(float depth) {
            var _F = _GetProc<GLNativeDelegate.FNglClearDepthf>("glClearDepthf");
            _F(depth);
        }

        #endregion Reuse commands from ARB_ES2_compatibility

        #region Reuse commands from ARB_get_program_binary

        /// <summary>
        /// return a binary representation of a program object's compiled and linked executable source
        /// <para>Require:</para> <para>GL_VERSION_4_1, GL_ES_VERSION_3_0, GL_ARB_get_program_binary</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetProgramBinary(GLuint program, GLsizei bufSize, GLsizei * length, GLenum * binaryFormat, void * binary);</para>
        /// </summary>
        public unsafe static void glGetProgramBinary(uint program, int bufSize, int* length, uint* binaryFormat, void* binary) {
            var _F = _GetProc<GLNativeDelegate.FNglGetProgramBinary>("glGetProgramBinary");
            _F(program, bufSize, length, binaryFormat, binary);
        }
        /// <summary>
        /// load a program object with a program binary
        /// <para>Require:</para> <para>GL_VERSION_4_1, GL_ES_VERSION_3_0, GL_SC_VERSION_2_0, GL_ARB_get_program_binary</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glProgramBinary(GLuint program, GLenum binaryFormat, const void * binary, GLsizei length);</para>
        /// </summary>
        public unsafe static void glProgramBinary(uint program, uint binaryFormat, void* binary, int length) {
            var _F = _GetProc<GLNativeDelegate.FNglProgramBinary>("glProgramBinary");
            _F(program, binaryFormat, binary, length);
        }
        /// <summary>
        /// specify a parameter for a program object
        /// <para>Require:</para> <para>GL_VERSION_4_1, GL_VERSION_4_1, GL_ES_VERSION_3_0, GL_ARB_get_program_binary, GL_ARB_separate_shader_objects</para>
        /// Supported: <para>gl, glcore, gl, glcore</para>
        /// Original: <para>void glProgramParameteri(GLuint program, GLenum pname, GLint value);</para>
        /// </summary>
        public static void glProgramParameteri(uint program, uint pname, int value) {
            var _F = _GetProc<GLNativeDelegate.FNglProgramParameteri>("glProgramParameteri");
            _F(program, pname, value);
        }

        #endregion Reuse commands from ARB_get_program_binary

        #region Reuse commands from ARB_separate_shader_objects

        /// <summary>
        /// bind stages of a program object to a program pipeline
        /// <para>Require:</para> <para>GL_VERSION_4_1, GL_ES_VERSION_3_1, GL_ARB_separate_shader_objects</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glUseProgramStages(GLuint pipeline, GLbitfield stages, GLuint program);</para>
        /// </summary>
        public static void glUseProgramStages(uint pipeline, uint stages, uint program) {
            var _F = _GetProc<GLNativeDelegate.FNglUseProgramStages>("glUseProgramStages");
            _F(pipeline, stages, program);
        }
        /// <summary>
        /// set the active program object for a program pipeline object
        /// <para>Require:</para> <para>GL_VERSION_4_1, GL_ES_VERSION_3_1, GL_ARB_separate_shader_objects</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glActiveShaderProgram(GLuint pipeline, GLuint program);</para>
        /// </summary>
        public static void glActiveShaderProgram(uint pipeline, uint program) {
            var _F = _GetProc<GLNativeDelegate.FNglActiveShaderProgram>("glActiveShaderProgram");
            _F(pipeline, program);
        }
        /// <summary>
        /// create a stand-alone program from an array of null-terminated source code strings
        /// <para>Require:</para> <para>GL_VERSION_4_1, GL_ES_VERSION_3_1, GL_ARB_separate_shader_objects</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>GLuint glCreateShaderProgramv(GLenum type, GLsizei count, const char ** strings);</para>
        /// </summary>
        public unsafe static uint glCreateShaderProgramv(uint type, int count, byte** strings) {
            var _F = _GetProc<GLNativeDelegate.FNglCreateShaderProgramv>("glCreateShaderProgramv");
            return _F(type, count, strings);
        }
        /// <summary>
        /// bind a program pipeline to the current context
        /// <para>Require:</para> <para>GL_VERSION_4_1, GL_ES_VERSION_3_1, GL_ARB_separate_shader_objects</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glBindProgramPipeline(GLuint pipeline);</para>
        /// </summary>
        public static void glBindProgramPipeline(uint pipeline) {
            var _F = _GetProc<GLNativeDelegate.FNglBindProgramPipeline>("glBindProgramPipeline");
            _F(pipeline);
        }
        /// <summary>
        /// delete program pipeline objects
        /// <para>Require:</para> <para>GL_VERSION_4_1, GL_ES_VERSION_3_1, GL_ARB_separate_shader_objects</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glDeleteProgramPipelines(GLsizei n, const GLuint * pipelines);</para>
        /// </summary>
        public unsafe static void glDeleteProgramPipelines(int n, uint* pipelines) {
            var _F = _GetProc<GLNativeDelegate.FNglDeleteProgramPipelines>("glDeleteProgramPipelines");
            _F(n, pipelines);
        }
        /// <summary>
        /// reserve program pipeline object names
        /// <para>Require:</para> <para>GL_VERSION_4_1, GL_ES_VERSION_3_1, GL_ARB_separate_shader_objects</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGenProgramPipelines(GLsizei n, GLuint * pipelines);</para>
        /// </summary>
        public unsafe static void glGenProgramPipelines(int n, uint* pipelines) {
            var _F = _GetProc<GLNativeDelegate.FNglGenProgramPipelines>("glGenProgramPipelines");
            _F(n, pipelines);
        }
        /// <summary>
        /// determine if a name corresponds to a program pipeline object
        /// <para>Require:</para> <para>GL_VERSION_4_1, GL_ES_VERSION_3_1, GL_ARB_separate_shader_objects</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>GLboolean glIsProgramPipeline(GLuint pipeline);</para>
        /// </summary>
        public static bool glIsProgramPipeline(uint pipeline) {
            var _F = _GetProc<GLNativeDelegate.FNglIsProgramPipeline>("glIsProgramPipeline");
            return _F(pipeline);
        }
        /// <summary>
        /// retrieve properties of a program pipeline object
        /// <para>Require:</para> <para>GL_VERSION_4_1, GL_ES_VERSION_3_1, GL_ARB_separate_shader_objects</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetProgramPipelineiv(GLuint pipeline, GLenum pname, GLint * params);</para>
        /// </summary>
        public unsafe static void glGetProgramPipelineiv(uint pipeline, uint pname, int* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetProgramPipelineiv>("glGetProgramPipelineiv");
            _F(pipeline, pname, ps);
        }
        // void glProgramParameteri(GLuint program, GLenum pname, GLint value);
        /// <summary>
        /// Specify the value of a uniform variable for a specified program object
        /// <para>Require:</para> <para>GL_VERSION_4_1, GL_ES_VERSION_3_1, GL_ARB_separate_shader_objects</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glProgramUniform1i(GLuint program, GLint location, GLint v0);</para>
        /// </summary>
        public static void glProgramUniform1i(uint program, int location, int v0) {
            var _F = _GetProc<GLNativeDelegate.FNglProgramUniform1i>("glProgramUniform1i");
            _F(program, location, v0);
        }
        /// <summary>
        /// Specify the value of a uniform variable for a specified program object
        /// <para>Require:</para> <para>GL_VERSION_4_1, GL_ES_VERSION_3_1, GL_ARB_separate_shader_objects</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glProgramUniform1iv(GLuint program, GLint location, GLsizei count, const GLint * value);</para>
        /// </summary>
        public unsafe static void glProgramUniform1iv(uint program, int location, int count, int* value) {
            var _F = _GetProc<GLNativeDelegate.FNglProgramUniform1iv>("glProgramUniform1iv");
            _F(program, location, count, value);
        }
        /// <summary>
        /// Specify the value of a uniform variable for a specified program object
        /// <para>Require:</para> <para>GL_VERSION_4_1, GL_ES_VERSION_3_1, GL_ARB_separate_shader_objects</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glProgramUniform1f(GLuint program, GLint location, GLfloat v0);</para>
        /// </summary>
        public static void glProgramUniform1f(uint program, int location, float v0) {
            var _F = _GetProc<GLNativeDelegate.FNglProgramUniform1f>("glProgramUniform1f");
            _F(program, location, v0);
        }
        /// <summary>
        /// Specify the value of a uniform variable for a specified program object
        /// <para>Require:</para> <para>GL_VERSION_4_1, GL_ES_VERSION_3_1, GL_ARB_separate_shader_objects</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glProgramUniform1fv(GLuint program, GLint location, GLsizei count, const GLfloat * value);</para>
        /// </summary>
        public unsafe static void glProgramUniform1fv(uint program, int location, int count, float* value) {
            var _F = _GetProc<GLNativeDelegate.FNglProgramUniform1fv>("glProgramUniform1fv");
            _F(program, location, count, value);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_VERSION_4_1, GL_ARB_separate_shader_objects</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glProgramUniform1d(GLuint program, GLint location, GLdouble v0);</para>
        /// </summary>
        public static void glProgramUniform1d(uint program, int location, double v0) {
            var _F = _GetProc<GLNativeDelegate.FNglProgramUniform1d>("glProgramUniform1d");
            _F(program, location, v0);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_VERSION_4_1, GL_ARB_separate_shader_objects</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glProgramUniform1dv(GLuint program, GLint location, GLsizei count, const GLdouble * value);</para>
        /// </summary>
        public unsafe static void glProgramUniform1dv(uint program, int location, int count, double* value) {
            var _F = _GetProc<GLNativeDelegate.FNglProgramUniform1dv>("glProgramUniform1dv");
            _F(program, location, count, value);
        }
        /// <summary>
        /// Specify the value of a uniform variable for a specified program object
        /// <para>Require:</para> <para>GL_VERSION_4_1, GL_ES_VERSION_3_1, GL_ARB_separate_shader_objects</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glProgramUniform1ui(GLuint program, GLint location, GLuint v0);</para>
        /// </summary>
        public static void glProgramUniform1ui(uint program, int location, uint v0) {
            var _F = _GetProc<GLNativeDelegate.FNglProgramUniform1ui>("glProgramUniform1ui");
            _F(program, location, v0);
        }
        /// <summary>
        /// Specify the value of a uniform variable for a specified program object
        /// <para>Require:</para> <para>GL_VERSION_4_1, GL_ES_VERSION_3_1, GL_ARB_separate_shader_objects</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glProgramUniform1uiv(GLuint program, GLint location, GLsizei count, const GLuint * value);</para>
        /// </summary>
        public unsafe static void glProgramUniform1uiv(uint program, int location, int count, uint* value) {
            var _F = _GetProc<GLNativeDelegate.FNglProgramUniform1uiv>("glProgramUniform1uiv");
            _F(program, location, count, value);
        }
        /// <summary>
        /// Specify the value of a uniform variable for a specified program object
        /// <para>Require:</para> <para>GL_VERSION_4_1, GL_ES_VERSION_3_1, GL_ARB_separate_shader_objects</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glProgramUniform2i(GLuint program, GLint location, GLint v0, GLint v1);</para>
        /// </summary>
        public static void glProgramUniform2i(uint program, int location, int v0, int v1) {
            var _F = _GetProc<GLNativeDelegate.FNglProgramUniform2i>("glProgramUniform2i");
            _F(program, location, v0, v1);
        }
        /// <summary>
        /// Specify the value of a uniform variable for a specified program object
        /// <para>Require:</para> <para>GL_VERSION_4_1, GL_ES_VERSION_3_1, GL_ARB_separate_shader_objects</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glProgramUniform2iv(GLuint program, GLint location, GLsizei count, const GLint * value);</para>
        /// </summary>
        public unsafe static void glProgramUniform2iv(uint program, int location, int count, int* value) {
            var _F = _GetProc<GLNativeDelegate.FNglProgramUniform2iv>("glProgramUniform2iv");
            _F(program, location, count, value);
        }
        /// <summary>
        /// Specify the value of a uniform variable for a specified program object
        /// <para>Require:</para> <para>GL_VERSION_4_1, GL_ES_VERSION_3_1, GL_ARB_separate_shader_objects</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glProgramUniform2f(GLuint program, GLint location, GLfloat v0, GLfloat v1);</para>
        /// </summary>
        public static void glProgramUniform2f(uint program, int location, float v0, float v1) {
            var _F = _GetProc<GLNativeDelegate.FNglProgramUniform2f>("glProgramUniform2f");
            _F(program, location, v0, v1);
        }
        /// <summary>
        /// Specify the value of a uniform variable for a specified program object
        /// <para>Require:</para> <para>GL_VERSION_4_1, GL_ES_VERSION_3_1, GL_ARB_separate_shader_objects</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glProgramUniform2fv(GLuint program, GLint location, GLsizei count, const GLfloat * value);</para>
        /// </summary>
        public unsafe static void glProgramUniform2fv(uint program, int location, int count, float* value) {
            var _F = _GetProc<GLNativeDelegate.FNglProgramUniform2fv>("glProgramUniform2fv");
            _F(program, location, count, value);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_VERSION_4_1, GL_ARB_separate_shader_objects</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glProgramUniform2d(GLuint program, GLint location, GLdouble v0, GLdouble v1);</para>
        /// </summary>
        public static void glProgramUniform2d(uint program, int location, double v0, double v1) {
            var _F = _GetProc<GLNativeDelegate.FNglProgramUniform2d>("glProgramUniform2d");
            _F(program, location, v0, v1);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_VERSION_4_1, GL_ARB_separate_shader_objects</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glProgramUniform2dv(GLuint program, GLint location, GLsizei count, const GLdouble * value);</para>
        /// </summary>
        public unsafe static void glProgramUniform2dv(uint program, int location, int count, double* value) {
            var _F = _GetProc<GLNativeDelegate.FNglProgramUniform2dv>("glProgramUniform2dv");
            _F(program, location, count, value);
        }
        /// <summary>
        /// Specify the value of a uniform variable for a specified program object
        /// <para>Require:</para> <para>GL_VERSION_4_1, GL_ES_VERSION_3_1, GL_ARB_separate_shader_objects</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glProgramUniform2ui(GLuint program, GLint location, GLuint v0, GLuint v1);</para>
        /// </summary>
        public static void glProgramUniform2ui(uint program, int location, uint v0, uint v1) {
            var _F = _GetProc<GLNativeDelegate.FNglProgramUniform2ui>("glProgramUniform2ui");
            _F(program, location, v0, v1);
        }
        /// <summary>
        /// Specify the value of a uniform variable for a specified program object
        /// <para>Require:</para> <para>GL_VERSION_4_1, GL_ES_VERSION_3_1, GL_ARB_separate_shader_objects</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glProgramUniform2uiv(GLuint program, GLint location, GLsizei count, const GLuint * value);</para>
        /// </summary>
        public unsafe static void glProgramUniform2uiv(uint program, int location, int count, uint* value) {
            var _F = _GetProc<GLNativeDelegate.FNglProgramUniform2uiv>("glProgramUniform2uiv");
            _F(program, location, count, value);
        }
        /// <summary>
        /// Specify the value of a uniform variable for a specified program object
        /// <para>Require:</para> <para>GL_VERSION_4_1, GL_ES_VERSION_3_1, GL_ARB_separate_shader_objects</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glProgramUniform3i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2);</para>
        /// </summary>
        public static void glProgramUniform3i(uint program, int location, int v0, int v1, int v2) {
            var _F = _GetProc<GLNativeDelegate.FNglProgramUniform3i>("glProgramUniform3i");
            _F(program, location, v0, v1, v2);
        }
        /// <summary>
        /// Specify the value of a uniform variable for a specified program object
        /// <para>Require:</para> <para>GL_VERSION_4_1, GL_ES_VERSION_3_1, GL_ARB_separate_shader_objects</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glProgramUniform3iv(GLuint program, GLint location, GLsizei count, const GLint * value);</para>
        /// </summary>
        public unsafe static void glProgramUniform3iv(uint program, int location, int count, int* value) {
            var _F = _GetProc<GLNativeDelegate.FNglProgramUniform3iv>("glProgramUniform3iv");
            _F(program, location, count, value);
        }
        /// <summary>
        /// Specify the value of a uniform variable for a specified program object
        /// <para>Require:</para> <para>GL_VERSION_4_1, GL_ES_VERSION_3_1, GL_ARB_separate_shader_objects</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glProgramUniform3f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2);</para>
        /// </summary>
        public static void glProgramUniform3f(uint program, int location, float v0, float v1, float v2) {
            var _F = _GetProc<GLNativeDelegate.FNglProgramUniform3f>("glProgramUniform3f");
            _F(program, location, v0, v1, v2);
        }
        /// <summary>
        /// Specify the value of a uniform variable for a specified program object
        /// <para>Require:</para> <para>GL_VERSION_4_1, GL_ES_VERSION_3_1, GL_ARB_separate_shader_objects</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glProgramUniform3fv(GLuint program, GLint location, GLsizei count, const GLfloat * value);</para>
        /// </summary>
        public unsafe static void glProgramUniform3fv(uint program, int location, int count, float* value) {
            var _F = _GetProc<GLNativeDelegate.FNglProgramUniform3fv>("glProgramUniform3fv");
            _F(program, location, count, value);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_VERSION_4_1, GL_ARB_separate_shader_objects</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glProgramUniform3d(GLuint program, GLint location, GLdouble v0, GLdouble v1, GLdouble v2);</para>
        /// </summary>
        public static void glProgramUniform3d(uint program, int location, double v0, double v1, double v2) {
            var _F = _GetProc<GLNativeDelegate.FNglProgramUniform3d>("glProgramUniform3d");
            _F(program, location, v0, v1, v2);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_VERSION_4_1, GL_ARB_separate_shader_objects</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glProgramUniform3dv(GLuint program, GLint location, GLsizei count, const GLdouble * value);</para>
        /// </summary>
        public unsafe static void glProgramUniform3dv(uint program, int location, int count, double* value) {
            var _F = _GetProc<GLNativeDelegate.FNglProgramUniform3dv>("glProgramUniform3dv");
            _F(program, location, count, value);
        }
        /// <summary>
        /// Specify the value of a uniform variable for a specified program object
        /// <para>Require:</para> <para>GL_VERSION_4_1, GL_ES_VERSION_3_1, GL_ARB_separate_shader_objects</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glProgramUniform3ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2);</para>
        /// </summary>
        public static void glProgramUniform3ui(uint program, int location, uint v0, uint v1, uint v2) {
            var _F = _GetProc<GLNativeDelegate.FNglProgramUniform3ui>("glProgramUniform3ui");
            _F(program, location, v0, v1, v2);
        }
        /// <summary>
        /// Specify the value of a uniform variable for a specified program object
        /// <para>Require:</para> <para>GL_VERSION_4_1, GL_ES_VERSION_3_1, GL_ARB_separate_shader_objects</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glProgramUniform3uiv(GLuint program, GLint location, GLsizei count, const GLuint * value);</para>
        /// </summary>
        public unsafe static void glProgramUniform3uiv(uint program, int location, int count, uint* value) {
            var _F = _GetProc<GLNativeDelegate.FNglProgramUniform3uiv>("glProgramUniform3uiv");
            _F(program, location, count, value);
        }
        /// <summary>
        /// Specify the value of a uniform variable for a specified program object
        /// <para>Require:</para> <para>GL_VERSION_4_1, GL_ES_VERSION_3_1, GL_ARB_separate_shader_objects</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glProgramUniform4i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3);</para>
        /// </summary>
        public static void glProgramUniform4i(uint program, int location, int v0, int v1, int v2, int v3) {
            var _F = _GetProc<GLNativeDelegate.FNglProgramUniform4i>("glProgramUniform4i");
            _F(program, location, v0, v1, v2, v3);
        }
        /// <summary>
        /// Specify the value of a uniform variable for a specified program object
        /// <para>Require:</para> <para>GL_VERSION_4_1, GL_ES_VERSION_3_1, GL_ARB_separate_shader_objects</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glProgramUniform4iv(GLuint program, GLint location, GLsizei count, const GLint * value);</para>
        /// </summary>
        public unsafe static void glProgramUniform4iv(uint program, int location, int count, int* value) {
            var _F = _GetProc<GLNativeDelegate.FNglProgramUniform4iv>("glProgramUniform4iv");
            _F(program, location, count, value);
        }
        /// <summary>
        /// Specify the value of a uniform variable for a specified program object
        /// <para>Require:</para> <para>GL_VERSION_4_1, GL_ES_VERSION_3_1, GL_ARB_separate_shader_objects</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glProgramUniform4f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3);</para>
        /// </summary>
        public static void glProgramUniform4f(uint program, int location, float v0, float v1, float v2, float v3) {
            var _F = _GetProc<GLNativeDelegate.FNglProgramUniform4f>("glProgramUniform4f");
            _F(program, location, v0, v1, v2, v3);
        }
        /// <summary>
        /// Specify the value of a uniform variable for a specified program object
        /// <para>Require:</para> <para>GL_VERSION_4_1, GL_ES_VERSION_3_1, GL_ARB_separate_shader_objects</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glProgramUniform4fv(GLuint program, GLint location, GLsizei count, const GLfloat * value);</para>
        /// </summary>
        public unsafe static void glProgramUniform4fv(uint program, int location, int count, float* value) {
            var _F = _GetProc<GLNativeDelegate.FNglProgramUniform4fv>("glProgramUniform4fv");
            _F(program, location, count, value);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_VERSION_4_1, GL_ARB_separate_shader_objects</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glProgramUniform4d(GLuint program, GLint location, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3);</para>
        /// </summary>
        public static void glProgramUniform4d(uint program, int location, double v0, double v1, double v2, double v3) {
            var _F = _GetProc<GLNativeDelegate.FNglProgramUniform4d>("glProgramUniform4d");
            _F(program, location, v0, v1, v2, v3);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_VERSION_4_1, GL_ARB_separate_shader_objects</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glProgramUniform4dv(GLuint program, GLint location, GLsizei count, const GLdouble * value);</para>
        /// </summary>
        public unsafe static void glProgramUniform4dv(uint program, int location, int count, double* value) {
            var _F = _GetProc<GLNativeDelegate.FNglProgramUniform4dv>("glProgramUniform4dv");
            _F(program, location, count, value);
        }
        /// <summary>
        /// Specify the value of a uniform variable for a specified program object
        /// <para>Require:</para> <para>GL_VERSION_4_1, GL_ES_VERSION_3_1, GL_ARB_separate_shader_objects</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glProgramUniform4ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3);</para>
        /// </summary>
        public static void glProgramUniform4ui(uint program, int location, uint v0, uint v1, uint v2, uint v3) {
            var _F = _GetProc<GLNativeDelegate.FNglProgramUniform4ui>("glProgramUniform4ui");
            _F(program, location, v0, v1, v2, v3);
        }
        /// <summary>
        /// Specify the value of a uniform variable for a specified program object
        /// <para>Require:</para> <para>GL_VERSION_4_1, GL_ES_VERSION_3_1, GL_ARB_separate_shader_objects</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glProgramUniform4uiv(GLuint program, GLint location, GLsizei count, const GLuint * value);</para>
        /// </summary>
        public unsafe static void glProgramUniform4uiv(uint program, int location, int count, uint* value) {
            var _F = _GetProc<GLNativeDelegate.FNglProgramUniform4uiv>("glProgramUniform4uiv");
            _F(program, location, count, value);
        }
        /// <summary>
        /// Specify the value of a uniform variable for a specified program object
        /// <para>Require:</para> <para>GL_VERSION_4_1, GL_ES_VERSION_3_1, GL_ARB_separate_shader_objects</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glProgramUniformMatrix2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);</para>
        /// </summary>
        public unsafe static void glProgramUniformMatrix2fv(uint program, int location, int count, bool transpose, float* value) {
            var _F = _GetProc<GLNativeDelegate.FNglProgramUniformMatrix2fv>("glProgramUniformMatrix2fv");
            _F(program, location, count, transpose, value);
        }
        /// <summary>
        /// Specify the value of a uniform variable for a specified program object
        /// <para>Require:</para> <para>GL_VERSION_4_1, GL_ES_VERSION_3_1, GL_ARB_separate_shader_objects</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glProgramUniformMatrix3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);</para>
        /// </summary>
        public unsafe static void glProgramUniformMatrix3fv(uint program, int location, int count, bool transpose, float* value) {
            var _F = _GetProc<GLNativeDelegate.FNglProgramUniformMatrix3fv>("glProgramUniformMatrix3fv");
            _F(program, location, count, transpose, value);
        }
        /// <summary>
        /// Specify the value of a uniform variable for a specified program object
        /// <para>Require:</para> <para>GL_VERSION_4_1, GL_ES_VERSION_3_1, GL_ARB_separate_shader_objects</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glProgramUniformMatrix4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);</para>
        /// </summary>
        public unsafe static void glProgramUniformMatrix4fv(uint program, int location, int count, bool transpose, float* value) {
            var _F = _GetProc<GLNativeDelegate.FNglProgramUniformMatrix4fv>("glProgramUniformMatrix4fv");
            _F(program, location, count, transpose, value);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_VERSION_4_1, GL_ARB_separate_shader_objects</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glProgramUniformMatrix2dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);</para>
        /// </summary>
        public unsafe static void glProgramUniformMatrix2dv(uint program, int location, int count, bool transpose, double* value) {
            var _F = _GetProc<GLNativeDelegate.FNglProgramUniformMatrix2dv>("glProgramUniformMatrix2dv");
            _F(program, location, count, transpose, value);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_VERSION_4_1, GL_ARB_separate_shader_objects</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glProgramUniformMatrix3dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);</para>
        /// </summary>
        public unsafe static void glProgramUniformMatrix3dv(uint program, int location, int count, bool transpose, double* value) {
            var _F = _GetProc<GLNativeDelegate.FNglProgramUniformMatrix3dv>("glProgramUniformMatrix3dv");
            _F(program, location, count, transpose, value);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_VERSION_4_1, GL_ARB_separate_shader_objects</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glProgramUniformMatrix4dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);</para>
        /// </summary>
        public unsafe static void glProgramUniformMatrix4dv(uint program, int location, int count, bool transpose, double* value) {
            var _F = _GetProc<GLNativeDelegate.FNglProgramUniformMatrix4dv>("glProgramUniformMatrix4dv");
            _F(program, location, count, transpose, value);
        }
        /// <summary>
        /// Specify the value of a uniform variable for a specified program object
        /// <para>Require:</para> <para>GL_VERSION_4_1, GL_ES_VERSION_3_1, GL_ARB_separate_shader_objects</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glProgramUniformMatrix2x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);</para>
        /// </summary>
        public unsafe static void glProgramUniformMatrix2x3fv(uint program, int location, int count, bool transpose, float* value) {
            var _F = _GetProc<GLNativeDelegate.FNglProgramUniformMatrix2x3fv>("glProgramUniformMatrix2x3fv");
            _F(program, location, count, transpose, value);
        }
        /// <summary>
        /// Specify the value of a uniform variable for a specified program object
        /// <para>Require:</para> <para>GL_VERSION_4_1, GL_ES_VERSION_3_1, GL_ARB_separate_shader_objects</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glProgramUniformMatrix3x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);</para>
        /// </summary>
        public unsafe static void glProgramUniformMatrix3x2fv(uint program, int location, int count, bool transpose, float* value) {
            var _F = _GetProc<GLNativeDelegate.FNglProgramUniformMatrix3x2fv>("glProgramUniformMatrix3x2fv");
            _F(program, location, count, transpose, value);
        }
        /// <summary>
        /// Specify the value of a uniform variable for a specified program object
        /// <para>Require:</para> <para>GL_VERSION_4_1, GL_ES_VERSION_3_1, GL_ARB_separate_shader_objects</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glProgramUniformMatrix2x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);</para>
        /// </summary>
        public unsafe static void glProgramUniformMatrix2x4fv(uint program, int location, int count, bool transpose, float* value) {
            var _F = _GetProc<GLNativeDelegate.FNglProgramUniformMatrix2x4fv>("glProgramUniformMatrix2x4fv");
            _F(program, location, count, transpose, value);
        }
        /// <summary>
        /// Specify the value of a uniform variable for a specified program object
        /// <para>Require:</para> <para>GL_VERSION_4_1, GL_ES_VERSION_3_1, GL_ARB_separate_shader_objects</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glProgramUniformMatrix4x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);</para>
        /// </summary>
        public unsafe static void glProgramUniformMatrix4x2fv(uint program, int location, int count, bool transpose, float* value) {
            var _F = _GetProc<GLNativeDelegate.FNglProgramUniformMatrix4x2fv>("glProgramUniformMatrix4x2fv");
            _F(program, location, count, transpose, value);
        }
        /// <summary>
        /// Specify the value of a uniform variable for a specified program object
        /// <para>Require:</para> <para>GL_VERSION_4_1, GL_ES_VERSION_3_1, GL_ARB_separate_shader_objects</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glProgramUniformMatrix3x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);</para>
        /// </summary>
        public unsafe static void glProgramUniformMatrix3x4fv(uint program, int location, int count, bool transpose, float* value) {
            var _F = _GetProc<GLNativeDelegate.FNglProgramUniformMatrix3x4fv>("glProgramUniformMatrix3x4fv");
            _F(program, location, count, transpose, value);
        }
        /// <summary>
        /// Specify the value of a uniform variable for a specified program object
        /// <para>Require:</para> <para>GL_VERSION_4_1, GL_ES_VERSION_3_1, GL_ARB_separate_shader_objects</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glProgramUniformMatrix4x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);</para>
        /// </summary>
        public unsafe static void glProgramUniformMatrix4x3fv(uint program, int location, int count, bool transpose, float* value) {
            var _F = _GetProc<GLNativeDelegate.FNglProgramUniformMatrix4x3fv>("glProgramUniformMatrix4x3fv");
            _F(program, location, count, transpose, value);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_VERSION_4_1, GL_ARB_separate_shader_objects</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glProgramUniformMatrix2x3dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);</para>
        /// </summary>
        public unsafe static void glProgramUniformMatrix2x3dv(uint program, int location, int count, bool transpose, double* value) {
            var _F = _GetProc<GLNativeDelegate.FNglProgramUniformMatrix2x3dv>("glProgramUniformMatrix2x3dv");
            _F(program, location, count, transpose, value);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_VERSION_4_1, GL_ARB_separate_shader_objects</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glProgramUniformMatrix3x2dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);</para>
        /// </summary>
        public unsafe static void glProgramUniformMatrix3x2dv(uint program, int location, int count, bool transpose, double* value) {
            var _F = _GetProc<GLNativeDelegate.FNglProgramUniformMatrix3x2dv>("glProgramUniformMatrix3x2dv");
            _F(program, location, count, transpose, value);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_VERSION_4_1, GL_ARB_separate_shader_objects</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glProgramUniformMatrix2x4dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);</para>
        /// </summary>
        public unsafe static void glProgramUniformMatrix2x4dv(uint program, int location, int count, bool transpose, double* value) {
            var _F = _GetProc<GLNativeDelegate.FNglProgramUniformMatrix2x4dv>("glProgramUniformMatrix2x4dv");
            _F(program, location, count, transpose, value);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_VERSION_4_1, GL_ARB_separate_shader_objects</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glProgramUniformMatrix4x2dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);</para>
        /// </summary>
        public unsafe static void glProgramUniformMatrix4x2dv(uint program, int location, int count, bool transpose, double* value) {
            var _F = _GetProc<GLNativeDelegate.FNglProgramUniformMatrix4x2dv>("glProgramUniformMatrix4x2dv");
            _F(program, location, count, transpose, value);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_VERSION_4_1, GL_ARB_separate_shader_objects</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glProgramUniformMatrix3x4dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);</para>
        /// </summary>
        public unsafe static void glProgramUniformMatrix3x4dv(uint program, int location, int count, bool transpose, double* value) {
            var _F = _GetProc<GLNativeDelegate.FNglProgramUniformMatrix3x4dv>("glProgramUniformMatrix3x4dv");
            _F(program, location, count, transpose, value);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_VERSION_4_1, GL_ARB_separate_shader_objects</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glProgramUniformMatrix4x3dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);</para>
        /// </summary>
        public unsafe static void glProgramUniformMatrix4x3dv(uint program, int location, int count, bool transpose, double* value) {
            var _F = _GetProc<GLNativeDelegate.FNglProgramUniformMatrix4x3dv>("glProgramUniformMatrix4x3dv");
            _F(program, location, count, transpose, value);
        }
        /// <summary>
        /// validate a program pipeline object against current GL state
        /// <para>Require:</para> <para>GL_VERSION_4_1, GL_ES_VERSION_3_1, GL_ARB_separate_shader_objects</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glValidateProgramPipeline(GLuint pipeline);</para>
        /// </summary>
        public static void glValidateProgramPipeline(uint pipeline) {
            var _F = _GetProc<GLNativeDelegate.FNglValidateProgramPipeline>("glValidateProgramPipeline");
            _F(pipeline);
        }
        /// <summary>
        /// retrieve the info log string from a program pipeline object
        /// <para>Require:</para> <para>GL_VERSION_4_1, GL_ES_VERSION_3_1, GL_ARB_separate_shader_objects</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetProgramPipelineInfoLog(GLuint pipeline, GLsizei bufSize, GLsizei * length, GLchar * infoLog);</para>
        /// </summary>
        public unsafe static void glGetProgramPipelineInfoLog(uint pipeline, int bufSize, int* length, byte* infoLog) {
            var _F = _GetProc<GLNativeDelegate.FNglGetProgramPipelineInfoLog>("glGetProgramPipelineInfoLog");
            _F(pipeline, bufSize, length, infoLog);
        }

        #endregion Reuse commands from ARB_separate_shader_objects

        #region Reuse commands from ARB_vertex_attrib_64bit

        /// <summary>
        /// Specifies the value of a generic vertex attribute
        /// <para>Require:</para> <para>GL_VERSION_4_1, GL_ARB_vertex_attrib_64bit</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glVertexAttribL1d(GLuint index, GLdouble v0);</para>
        /// </summary>
        public static void glVertexAttribL1d(uint index, double v0) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttribL1d>("glVertexAttribL1d");
            _F(index, v0);
        }
        /// <summary>
        /// Specifies the value of a generic vertex attribute
        /// <para>Require:</para> <para>GL_VERSION_4_1, GL_ARB_vertex_attrib_64bit</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glVertexAttribL2d(GLuint index, GLdouble v0, GLdouble v1);</para>
        /// </summary>
        public static void glVertexAttribL2d(uint index, double v0, double v1) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttribL2d>("glVertexAttribL2d");
            _F(index, v0, v1);
        }
        /// <summary>
        /// Specifies the value of a generic vertex attribute
        /// <para>Require:</para> <para>GL_VERSION_4_1, GL_ARB_vertex_attrib_64bit</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glVertexAttribL3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2);</para>
        /// </summary>
        public static void glVertexAttribL3d(uint index, double v0, double v1, double v2) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttribL3d>("glVertexAttribL3d");
            _F(index, v0, v1, v2);
        }
        /// <summary>
        /// Specifies the value of a generic vertex attribute
        /// <para>Require:</para> <para>GL_VERSION_4_1, GL_ARB_vertex_attrib_64bit</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glVertexAttribL4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3);</para>
        /// </summary>
        public static void glVertexAttribL4d(uint index, double v0, double v1, double v2, double v3) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttribL4d>("glVertexAttribL4d");
            _F(index, v0, v1, v2, v3);
        }
        /// <summary>
        /// Specifies the value of a generic vertex attribute
        /// <para>Require:</para> <para>GL_VERSION_4_1, GL_ARB_vertex_attrib_64bit</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glVertexAttribL1dv(GLuint index, const GLdouble * v);</para>
        /// </summary>
        public unsafe static void glVertexAttribL1dv(uint index, double* v) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttribL1dv>("glVertexAttribL1dv");
            _F(index, v);
        }
        /// <summary>
        /// Specifies the value of a generic vertex attribute
        /// <para>Require:</para> <para>GL_VERSION_4_1, GL_ARB_vertex_attrib_64bit</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glVertexAttribL2dv(GLuint index, const GLdouble * v);</para>
        /// </summary>
        public unsafe static void glVertexAttribL2dv(uint index, double* v) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttribL2dv>("glVertexAttribL2dv");
            _F(index, v);
        }
        /// <summary>
        /// Specifies the value of a generic vertex attribute
        /// <para>Require:</para> <para>GL_VERSION_4_1, GL_ARB_vertex_attrib_64bit</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glVertexAttribL3dv(GLuint index, const GLdouble * v);</para>
        /// </summary>
        public unsafe static void glVertexAttribL3dv(uint index, double* v) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttribL3dv>("glVertexAttribL3dv");
            _F(index, v);
        }
        /// <summary>
        /// Specifies the value of a generic vertex attribute
        /// <para>Require:</para> <para>GL_VERSION_4_1, GL_ARB_vertex_attrib_64bit</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glVertexAttribL4dv(GLuint index, const GLdouble * v);</para>
        /// </summary>
        public unsafe static void glVertexAttribL4dv(uint index, double* v) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttribL4dv>("glVertexAttribL4dv");
            _F(index, v);
        }
        /// <summary>
        /// define an array of generic vertex attribute data
        /// <para>Require:</para> <para>GL_VERSION_4_1, GL_ARB_vertex_attrib_64bit</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glVertexAttribLPointer(GLuint index, GLint size, GLenum type, GLsizei stride, const void * pointer);</para>
        /// </summary>
        public unsafe static void glVertexAttribLPointer(uint index, int size, uint type, int stride, void* pointer) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttribLPointer>("glVertexAttribLPointer");
            _F(index, size, type, stride, pointer);
        }
        /// <summary>
        /// Return a generic vertex attribute parameter
        /// <para>Require:</para> <para>GL_VERSION_4_1, GL_ARB_vertex_attrib_64bit</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetVertexAttribLdv(GLuint index, GLenum pname, GLdouble * params);</para>
        /// </summary>
        public unsafe static void glGetVertexAttribLdv(uint index, uint pname, double* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetVertexAttribLdv>("glGetVertexAttribLdv");
            _F(index, pname, ps);
        }

        #endregion Reuse commands from ARB_vertex_attrib_64bit

        #region Reuse commands from ARB_viewport_array

        /// <summary>
        /// set multiple viewports
        /// <para>Require:</para> <para>GL_VERSION_4_1, GL_ARB_viewport_array</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glViewportArrayv(GLuint first, GLsizei count, const GLfloat * v);</para>
        /// </summary>
        public unsafe static void glViewportArrayv(uint first, int count, float* v) {
            var _F = _GetProc<GLNativeDelegate.FNglViewportArrayv>("glViewportArrayv");
            _F(first, count, v);
        }
        /// <summary>
        /// set a specified viewport
        /// <para>Require:</para> <para>GL_VERSION_4_1, GL_ARB_viewport_array</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glViewportIndexedf(GLuint index, GLfloat x, GLfloat y, GLfloat w, GLfloat h);</para>
        /// </summary>
        public static void glViewportIndexedf(uint index, float x, float y, float w, float h) {
            var _F = _GetProc<GLNativeDelegate.FNglViewportIndexedf>("glViewportIndexedf");
            _F(index, x, y, w, h);
        }
        /// <summary>
        /// set a specified viewport
        /// <para>Require:</para> <para>GL_VERSION_4_1, GL_ARB_viewport_array</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glViewportIndexedfv(GLuint index, const GLfloat * v);</para>
        /// </summary>
        public unsafe static void glViewportIndexedfv(uint index, float* v) {
            var _F = _GetProc<GLNativeDelegate.FNglViewportIndexedfv>("glViewportIndexedfv");
            _F(index, v);
        }
        /// <summary>
        /// define the scissor box for multiple viewports
        /// <para>Require:</para> <para>GL_VERSION_4_1, GL_ARB_viewport_array</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glScissorArrayv(GLuint first, GLsizei count, const GLint * v);</para>
        /// </summary>
        public unsafe static void glScissorArrayv(uint first, int count, int* v) {
            var _F = _GetProc<GLNativeDelegate.FNglScissorArrayv>("glScissorArrayv");
            _F(first, count, v);
        }
        /// <summary>
        /// define the scissor box for a specific viewport
        /// <para>Require:</para> <para>GL_VERSION_4_1, GL_ARB_viewport_array</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glScissorIndexed(GLuint index, GLint left, GLint bottom, GLsizei width, GLsizei height);</para>
        /// </summary>
        public static void glScissorIndexed(uint index, int left, int bottom, int width, int height) {
            var _F = _GetProc<GLNativeDelegate.FNglScissorIndexed>("glScissorIndexed");
            _F(index, left, bottom, width, height);
        }
        /// <summary>
        /// define the scissor box for a specific viewport
        /// <para>Require:</para> <para>GL_VERSION_4_1, GL_ARB_viewport_array</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glScissorIndexedv(GLuint index, const GLint * v);</para>
        /// </summary>
        public unsafe static void glScissorIndexedv(uint index, int* v) {
            var _F = _GetProc<GLNativeDelegate.FNglScissorIndexedv>("glScissorIndexedv");
            _F(index, v);
        }
        /// <summary>
        /// specify mapping of depth values from normalized device coordinates to window coordinates for a specified set of viewports
        /// <para>Require:</para> <para>GL_VERSION_4_1, GL_ARB_viewport_array</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glDepthRangeArrayv(GLuint first, GLsizei count, const GLdouble * v);</para>
        /// </summary>
        public unsafe static void glDepthRangeArrayv(uint first, int count, double* v) {
            var _F = _GetProc<GLNativeDelegate.FNglDepthRangeArrayv>("glDepthRangeArrayv");
            _F(first, count, v);
        }
        /// <summary>
        /// specify mapping of depth values from normalized device coordinates to window coordinates for a specified viewport
        /// <para>Require:</para> <para>GL_VERSION_4_1, GL_ARB_viewport_array</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glDepthRangeIndexed(GLuint index, GLdouble nearVal, GLdouble farVal);</para>
        /// </summary>
        public static void glDepthRangeIndexed(uint index, double nearVal, double farVal) {
            var _F = _GetProc<GLNativeDelegate.FNglDepthRangeIndexed>("glDepthRangeIndexed");
            _F(index, nearVal, farVal);
        }
        /// <summary>
        /// return the value or values of a selected parameter
        /// <para>Require:</para> <para>GL_VERSION_4_1, GL_ARB_viewport_array</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetFloati_v(GLenum target, GLuint index, GLfloat * data);</para>
        /// </summary>
        public unsafe static void glGetFloati_v(uint target, uint index, float* data) {
            var _F = _GetProc<GLNativeDelegate.FNglGetFloati_v>("glGetFloati_v");
            _F(target, index, data);
        }
        /// <summary>
        /// return the value or values of a selected parameter
        /// <para>Require:</para> <para>GL_VERSION_4_1, GL_ARB_viewport_array</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetDoublei_v(GLenum target, GLuint index, GLdouble * data);</para>
        /// </summary>
        public unsafe static void glGetDoublei_v(uint target, uint index, double* data) {
            var _F = _GetProc<GLNativeDelegate.FNglGetDoublei_v>("glGetDoublei_v");
            _F(target, index, data);
        }

        #endregion Reuse commands from ARB_viewport_array

        #endregion GL_VERSION_4_1

        #region GL_VERSION_4_2


        #region Reuse commands from ARB_base_instance

        /// <summary>
        /// draw multiple instances of a range of elements with offset applied to instanced attributes
        /// <para>Require:</para> <para>GL_VERSION_4_2, GL_ARB_base_instance</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glDrawArraysInstancedBaseInstance(GLenum mode, GLint first, GLsizei count, GLsizei instancecount, GLuint baseinstance);</para>
        /// </summary>
        public static void glDrawArraysInstancedBaseInstance(uint mode, int first, int count, int instancecount, uint baseinstance) {
            var _F = _GetProc<GLNativeDelegate.FNglDrawArraysInstancedBaseInstance>("glDrawArraysInstancedBaseInstance");
            _F(mode, first, count, instancecount, baseinstance);
        }
        /// <summary>
        /// draw multiple instances of a set of elements with offset applied to instanced attributes
        /// <para>Require:</para> <para>GL_VERSION_4_2, GL_ARB_base_instance</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glDrawElementsInstancedBaseInstance(GLenum mode, GLsizei count, GLenum type, const void * indices, GLsizei instancecount, GLuint baseinstance);</para>
        /// </summary>
        public unsafe static void glDrawElementsInstancedBaseInstance(uint mode, int count, uint type, void* indices, int instancecount, uint baseinstance) {
            var _F = _GetProc<GLNativeDelegate.FNglDrawElementsInstancedBaseInstance>("glDrawElementsInstancedBaseInstance");
            _F(mode, count, type, indices, instancecount, baseinstance);
        }
        /// <summary>
        /// render multiple instances of a set of primitives from array data with a per-element offset
        /// <para>Require:</para> <para>GL_VERSION_4_2, GL_ARB_base_instance</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glDrawElementsInstancedBaseVertexBaseInstance(GLenum mode, GLsizei count, GLenum type, void * indices, GLsizei instancecount, GLint basevertex, GLuint baseinstance);</para>
        /// </summary>
        public unsafe static void glDrawElementsInstancedBaseVertexBaseInstance(uint mode, int count, uint type, void* indices, int instancecount, int basevertex, uint baseinstance) {
            var _F = _GetProc<GLNativeDelegate.FNglDrawElementsInstancedBaseVertexBaseInstance>("glDrawElementsInstancedBaseVertexBaseInstance");
            _F(mode, count, type, indices, instancecount, basevertex, baseinstance);
        }

        #endregion Reuse commands from ARB_base_instance

        #region Reuse commands from ARB_internalformat_query

        /// <summary>
        /// retrieve information about implementation-dependent support for internal formats
        /// <para>Require:</para> <para>GL_VERSION_4_2, GL_ES_VERSION_3_0, GL_ARB_internalformat_query</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetInternalformativ(GLenum target, GLenum internalformat, GLenum pname, GLsizei bufSize, GLint * params);</para>
        /// </summary>
        public unsafe static void glGetInternalformativ(uint target, uint internalformat, uint pname, int bufSize, int* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetInternalformativ>("glGetInternalformativ");
            _F(target, internalformat, pname, bufSize, ps);
        }

        #endregion Reuse commands from ARB_internalformat_query

        #region Reuse commands from ARB_shader_atomic_counters

        /// <summary>
        /// retrieve information about the set of active atomic counter buffers for a program
        /// <para>Require:</para> <para>GL_VERSION_4_2, GL_ARB_shader_atomic_counters</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetActiveAtomicCounterBufferiv(GLuint program, GLuint bufferIndex, GLenum pname, GLint * params);</para>
        /// </summary>
        public unsafe static void glGetActiveAtomicCounterBufferiv(uint program, uint bufferIndex, uint pname, int* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetActiveAtomicCounterBufferiv>("glGetActiveAtomicCounterBufferiv");
            _F(program, bufferIndex, pname, ps);
        }

        #endregion Reuse commands from ARB_shader_atomic_counters

        #region Reuse commands from ARB_shader_image_load_store

        /// <summary>
        /// bind a level of a texture to an image unit
        /// <para>Require:</para> <para>GL_VERSION_4_2, GL_ES_VERSION_3_1, GL_ARB_shader_image_load_store</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glBindImageTexture(GLuint unit, GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum access, GLenum format);</para>
        /// </summary>
        public static void glBindImageTexture(uint unit, uint texture, int level, bool layered, int layer, uint access, uint format) {
            var _F = _GetProc<GLNativeDelegate.FNglBindImageTexture>("glBindImageTexture");
            _F(unit, texture, level, layered, layer, access, format);
        }
        /// <summary>
        /// defines a barrier ordering memory transactions
        /// <para>Require:</para> <para>GL_VERSION_4_2, GL_ES_VERSION_3_1, GL_ARB_shader_image_load_store</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glMemoryBarrier(GLbitfield barriers);</para>
        /// </summary>
        public static void glMemoryBarrier(uint barriers) {
            var _F = _GetProc<GLNativeDelegate.FNglMemoryBarrier>("glMemoryBarrier");
            _F(barriers);
        }

        #endregion Reuse commands from ARB_shader_image_load_store

        #region Reuse commands from ARB_texture_storage

        /// <summary>
        /// simultaneously specify storage for all levels of a one-dimensional texture
        /// <para>Require:</para> <para>GL_VERSION_4_2, GL_ARB_texture_storage</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glTexStorage1D(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width);</para>
        /// </summary>
        public static void glTexStorage1D(uint target, int levels, uint internalformat, int width) {
            var _F = _GetProc<GLNativeDelegate.FNglTexStorage1D>("glTexStorage1D");
            _F(target, levels, internalformat, width);
        }
        /// <summary>
        /// simultaneously specify storage for all levels of a two-dimensional or one-dimensional array texture
        /// <para>Require:</para> <para>GL_VERSION_4_2, GL_ES_VERSION_3_0, GL_SC_VERSION_2_0, GL_ARB_texture_storage</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glTexStorage2D(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height);</para>
        /// </summary>
        public static void glTexStorage2D(uint target, int levels, uint internalformat, int width, int height) {
            var _F = _GetProc<GLNativeDelegate.FNglTexStorage2D>("glTexStorage2D");
            _F(target, levels, internalformat, width, height);
        }
        /// <summary>
        /// simultaneously specify storage for all levels of a three-dimensional, two-dimensional array or cube-map array texture
        /// <para>Require:</para> <para>GL_VERSION_4_2, GL_ES_VERSION_3_0, GL_ARB_texture_storage</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glTexStorage3D(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth);</para>
        /// </summary>
        public static void glTexStorage3D(uint target, int levels, uint internalformat, int width, int height, int depth) {
            var _F = _GetProc<GLNativeDelegate.FNglTexStorage3D>("glTexStorage3D");
            _F(target, levels, internalformat, width, height, depth);
        }

        #endregion Reuse commands from ARB_texture_storage

        #region Reuse commands from ARB_transform_feedback_instanced

        /// <summary>
        /// render multiple instances of primitives using a count derived from a transform feedback object
        /// <para>Require:</para> <para>GL_VERSION_4_2, GL_ARB_transform_feedback_instanced</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glDrawTransformFeedbackInstanced(GLenum mode, GLuint id, GLsizei instancecount);</para>
        /// </summary>
        public static void glDrawTransformFeedbackInstanced(uint mode, uint id, int instancecount) {
            var _F = _GetProc<GLNativeDelegate.FNglDrawTransformFeedbackInstanced>("glDrawTransformFeedbackInstanced");
            _F(mode, id, instancecount);
        }
        /// <summary>
        /// render multiple instances of primitives using a count derived from a specifed stream of a transform feedback object
        /// <para>Require:</para> <para>GL_VERSION_4_2, GL_ARB_transform_feedback_instanced</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glDrawTransformFeedbackStreamInstanced(GLenum mode, GLuint id, GLuint stream, GLsizei instancecount);</para>
        /// </summary>
        public static void glDrawTransformFeedbackStreamInstanced(uint mode, uint id, uint stream, int instancecount) {
            var _F = _GetProc<GLNativeDelegate.FNglDrawTransformFeedbackStreamInstanced>("glDrawTransformFeedbackStreamInstanced");
            _F(mode, id, stream, instancecount);
        }

        #endregion Reuse commands from ARB_transform_feedback_instanced

        #endregion GL_VERSION_4_2

        #region GL_VERSION_4_3


        #region Reuse commands from ARB_clear_buffer_object

        /// <summary>
        /// fill a buffer object's data store with a fixed value
        /// <para>Require:</para> <para>GL_VERSION_4_3, GL_ARB_clear_buffer_object</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glClearBufferData(GLenum target, GLenum internalformat, GLenum format, GLenum type, const void * data);</para>
        /// </summary>
        public unsafe static void glClearBufferData(uint target, uint internalformat, uint format, uint type, void* data) {
            var _F = _GetProc<GLNativeDelegate.FNglClearBufferData>("glClearBufferData");
            _F(target, internalformat, format, type, data);
        }
        /// <summary>
        /// fill all or part of buffer object's data store with a fixed value
        /// <para>Require:</para> <para>GL_VERSION_4_3, GL_ARB_clear_buffer_object</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glClearBufferSubData(GLenum target, GLenum internalformat, GLintptr offset, GLsizeiptr size, GLenum format, GLenum type, const void * data);</para>
        /// </summary>
        public unsafe static void glClearBufferSubData(uint target, uint internalformat, IntPtr offset, IntPtr size, uint format, uint type, void* data) {
            var _F = _GetProc<GLNativeDelegate.FNglClearBufferSubData>("glClearBufferSubData");
            _F(target, internalformat, offset, size, format, type, data);
        }

        #endregion Reuse commands from ARB_clear_buffer_object

        #region Reuse commands from ARB_compute_shader

        /// <summary>
        /// launch one or more compute work groups
        /// <para>Require:</para> <para>GL_VERSION_4_3, GL_ES_VERSION_3_1, GL_ARB_compute_shader</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glDispatchCompute(GLuint num_groups_x, GLuint num_groups_y, GLuint num_groups_z);</para>
        /// </summary>
        public static void glDispatchCompute(uint num_groups_x, uint num_groups_y, uint num_groups_z) {
            var _F = _GetProc<GLNativeDelegate.FNglDispatchCompute>("glDispatchCompute");
            _F(num_groups_x, num_groups_y, num_groups_z);
        }
        /// <summary>
        /// launch one or more compute work groups using parameters stored in a buffer
        /// <para>Require:</para> <para>GL_VERSION_4_3, GL_ES_VERSION_3_1, GL_ARB_compute_shader</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glDispatchComputeIndirect(GLintptr indirect);</para>
        /// </summary>
        public static void glDispatchComputeIndirect(IntPtr indirect) {
            var _F = _GetProc<GLNativeDelegate.FNglDispatchComputeIndirect>("glDispatchComputeIndirect");
            _F(indirect);
        }

        #endregion Reuse commands from ARB_compute_shader

        #region Reuse commands from ARB_copy_image

        /// <summary>
        /// perform a raw data copy between two images
        /// <para>Require:</para> <para>GL_VERSION_4_3, GL_ES_VERSION_3_2, GL_ARB_copy_image</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glCopyImageSubData(GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei srcWidth, GLsizei srcHeight, GLsizei srcDepth);</para>
        /// </summary>
        public static void glCopyImageSubData(uint srcName, uint srcTarget, int srcLevel, int srcX, int srcY, int srcZ, uint dstName, uint dstTarget, int dstLevel, int dstX, int dstY, int dstZ, int srcWidth, int srcHeight, int srcDepth) {
            var _F = _GetProc<GLNativeDelegate.FNglCopyImageSubData>("glCopyImageSubData");
            _F(srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth);
        }

        #endregion Reuse commands from ARB_copy_image

        #region Reuse commands from ARB_framebuffer_no_attachments

        /// <summary>
        /// set a named parameter of a framebuffer object
        /// <para>Require:</para> <para>GL_VERSION_4_3, GL_ES_VERSION_3_1, GL_ARB_framebuffer_no_attachments</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glFramebufferParameteri(GLenum target, GLenum pname, GLint param);</para>
        /// </summary>
        public static void glFramebufferParameteri(uint target, uint pname, int param) {
            var _F = _GetProc<GLNativeDelegate.FNglFramebufferParameteri>("glFramebufferParameteri");
            _F(target, pname, param);
        }
        /// <summary>
        /// query a named parameter of a framebuffer object
        /// <para>Require:</para> <para>GL_VERSION_4_3, GL_ES_VERSION_3_1, GL_ARB_framebuffer_no_attachments</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetFramebufferParameteriv(GLenum target, GLenum pname, GLint * params);</para>
        /// </summary>
        public unsafe static void glGetFramebufferParameteriv(uint target, uint pname, int* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetFramebufferParameteriv>("glGetFramebufferParameteriv");
            _F(target, pname, ps);
        }

        #endregion Reuse commands from ARB_framebuffer_no_attachments

        #region Reuse commands from ARB_internalformat_query2

        /// <summary>
        /// retrieve information about implementation-dependent support for internal formats
        /// <para>Require:</para> <para>GL_VERSION_4_3, GL_ARB_internalformat_query2</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetInternalformati64v(GLenum target, GLenum internalformat, GLenum pname, GLsizei bufSize, GLint64 * params);</para>
        /// </summary>
        public unsafe static void glGetInternalformati64v(uint target, uint internalformat, uint pname, int bufSize, UInt64* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetInternalformati64v>("glGetInternalformati64v");
            _F(target, internalformat, pname, bufSize, ps);
        }

        #endregion Reuse commands from ARB_internalformat_query2

        #region Reuse commands from ARB_invalidate_subdata

        /// <summary>
        /// invalidate a region of a texture image
        /// <para>Require:</para> <para>GL_VERSION_4_3, GL_ARB_invalidate_subdata</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glInvalidateTexSubImage(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth);</para>
        /// </summary>
        public static void glInvalidateTexSubImage(uint texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth) {
            var _F = _GetProc<GLNativeDelegate.FNglInvalidateTexSubImage>("glInvalidateTexSubImage");
            _F(texture, level, xoffset, yoffset, zoffset, width, height, depth);
        }
        /// <summary>
        /// invalidate the entirety a texture image
        /// <para>Require:</para> <para>GL_VERSION_4_3, GL_ARB_invalidate_subdata</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glInvalidateTexImage(GLuint texture, GLint level);</para>
        /// </summary>
        public static void glInvalidateTexImage(uint texture, int level) {
            var _F = _GetProc<GLNativeDelegate.FNglInvalidateTexImage>("glInvalidateTexImage");
            _F(texture, level);
        }
        /// <summary>
        /// invalidate a region of a buffer object's data store
        /// <para>Require:</para> <para>GL_VERSION_4_3, GL_ARB_invalidate_subdata</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glInvalidateBufferSubData(GLuint buffer, GLintptr offset, GLsizeiptr length);</para>
        /// </summary>
        public static void glInvalidateBufferSubData(uint buffer, IntPtr offset, IntPtr length) {
            var _F = _GetProc<GLNativeDelegate.FNglInvalidateBufferSubData>("glInvalidateBufferSubData");
            _F(buffer, offset, length);
        }
        /// <summary>
        /// invalidate the content of a buffer object's data store
        /// <para>Require:</para> <para>GL_VERSION_4_3, GL_ARB_invalidate_subdata</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glInvalidateBufferData(GLuint buffer);</para>
        /// </summary>
        public static void glInvalidateBufferData(uint buffer) {
            var _F = _GetProc<GLNativeDelegate.FNglInvalidateBufferData>("glInvalidateBufferData");
            _F(buffer);
        }
        /// <summary>
        /// invalidate the content of some or all of a framebuffer's attachments
        /// <para>Require:</para> <para>GL_VERSION_4_3, GL_ES_VERSION_3_0, GL_ARB_invalidate_subdata</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glInvalidateFramebuffer(GLenum target, GLsizei numAttachments, const GLenum * attachments);</para>
        /// </summary>
        public unsafe static void glInvalidateFramebuffer(uint target, int numAttachments, uint* attachments) {
            var _F = _GetProc<GLNativeDelegate.FNglInvalidateFramebuffer>("glInvalidateFramebuffer");
            _F(target, numAttachments, attachments);
        }
        /// <summary>
        /// invalidate the content of a region of some or all of a framebuffer's attachments
        /// <para>Require:</para> <para>GL_VERSION_4_3, GL_ES_VERSION_3_0, GL_ARB_invalidate_subdata</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glInvalidateSubFramebuffer(GLenum target, GLsizei numAttachments, const GLenum * attachments, GLint x, GLint y, GLint width, GLint height);</para>
        /// </summary>
        public unsafe static void glInvalidateSubFramebuffer(uint target, int numAttachments, uint* attachments, int x, int y, int width, int height) {
            var _F = _GetProc<GLNativeDelegate.FNglInvalidateSubFramebuffer>("glInvalidateSubFramebuffer");
            _F(target, numAttachments, attachments, x, y, width, height);
        }

        #endregion Reuse commands from ARB_invalidate_subdata

        #region Reuse commands from ARB_multi_draw_indirect

        /// <summary>
        /// render multiple sets of primitives from array data, taking parameters from memory
        /// <para>Require:</para> <para>GL_VERSION_4_3, GL_ARB_multi_draw_indirect</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glMultiDrawArraysIndirect(GLenum mode, const void * indirect, GLsizei drawcount, GLsizei stride);</para>
        /// </summary>
        public unsafe static void glMultiDrawArraysIndirect(uint mode, void* indirect, int drawcount, int stride) {
            var _F = _GetProc<GLNativeDelegate.FNglMultiDrawArraysIndirect>("glMultiDrawArraysIndirect");
            _F(mode, indirect, drawcount, stride);
        }
        /// <summary>
        /// render indexed primitives from array data, taking parameters from memory
        /// <para>Require:</para> <para>GL_VERSION_4_3, GL_ARB_multi_draw_indirect</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glMultiDrawElementsIndirect(GLenum mode, GLenum type, const void * indirect, GLsizei drawcount, GLsizei stride);</para>
        /// </summary>
        public unsafe static void glMultiDrawElementsIndirect(uint mode, uint type, void* indirect, int drawcount, int stride) {
            var _F = _GetProc<GLNativeDelegate.FNglMultiDrawElementsIndirect>("glMultiDrawElementsIndirect");
            _F(mode, type, indirect, drawcount, stride);
        }

        #endregion Reuse commands from ARB_multi_draw_indirect

        #region Reuse commands from ARB_program_interface_query

        /// <summary>
        /// query a property of an interface in a program
        /// <para>Require:</para> <para>GL_VERSION_4_3, GL_ES_VERSION_3_1, GL_ARB_program_interface_query</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetProgramInterfaceiv(GLuint program, GLenum programInterface, GLenum pname, GLint * params);</para>
        /// </summary>
        public unsafe static void glGetProgramInterfaceiv(uint program, uint programInterface, uint pname, int* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetProgramInterfaceiv>("glGetProgramInterfaceiv");
            _F(program, programInterface, pname, ps);
        }
        /// <summary>
        /// query the index of a named resource within a program
        /// <para>Require:</para> <para>GL_VERSION_4_3, GL_ES_VERSION_3_1, GL_ARB_program_interface_query</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>GLuint glGetProgramResourceIndex(GLuint program, GLenum programInterface, const char * name);</para>
        /// </summary>
        public unsafe static uint glGetProgramResourceIndex(uint program, uint programInterface, byte* name) {
            var _F = _GetProc<GLNativeDelegate.FNglGetProgramResourceIndex>("glGetProgramResourceIndex");
            return _F(program, programInterface, name);
        }
        /// <summary>
        /// query the name of an indexed resource within a program
        /// <para>Require:</para> <para>GL_VERSION_4_3, GL_ES_VERSION_3_1, GL_ARB_program_interface_query</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetProgramResourceName(GLuint program, GLenum programInterface, GLuint index, GLsizei bufSize, GLsizei * length, char * name);</para>
        /// </summary>
        public unsafe static void glGetProgramResourceName(uint program, uint programInterface, uint index, int bufSize, int* length, byte* name) {
            var _F = _GetProc<GLNativeDelegate.FNglGetProgramResourceName>("glGetProgramResourceName");
            _F(program, programInterface, index, bufSize, length, name);
        }
        /// <summary>
        /// retrieve values for multiple properties of a single active resource within a program object
        /// <para>Require:</para> <para>GL_VERSION_4_3, GL_ES_VERSION_3_1, GL_ARB_program_interface_query</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetProgramResourceiv(GLuint program, GLenum programInterface, GLuint index, GLsizei propCount, const GLenum * props, GLsizei bufSize, GLsizei * length, GLint * params);</para>
        /// </summary>
        public unsafe static void glGetProgramResourceiv(uint program, uint programInterface, uint index, int propCount, uint* props, int bufSize, int* length, int* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetProgramResourceiv>("glGetProgramResourceiv");
            _F(program, programInterface, index, propCount, props, bufSize, length, ps);
        }
        /// <summary>
        /// query the location of a named resource within a program
        /// <para>Require:</para> <para>GL_VERSION_4_3, GL_ES_VERSION_3_1, GL_ARB_program_interface_query</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>GLint glGetProgramResourceLocation(GLuint program, GLenum programInterface, const char * name);</para>
        /// </summary>
        public unsafe static int glGetProgramResourceLocation(uint program, uint programInterface, byte* name) {
            var _F = _GetProc<GLNativeDelegate.FNglGetProgramResourceLocation>("glGetProgramResourceLocation");
            return _F(program, programInterface, name);
        }
        /// <summary>
        /// query the fragment color index of a named variable within a program
        /// <para>Require:</para> <para>GL_VERSION_4_3, GL_ARB_program_interface_query</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>GLint glGetProgramResourceLocationIndex(GLuint program, GLenum programInterface, const char * name);</para>
        /// </summary>
        public unsafe static int glGetProgramResourceLocationIndex(uint program, uint programInterface, byte* name) {
            var _F = _GetProc<GLNativeDelegate.FNglGetProgramResourceLocationIndex>("glGetProgramResourceLocationIndex");
            return _F(program, programInterface, name);
        }

        #endregion Reuse commands from ARB_program_interface_query

        #region Reuse commands from ARB_shader_storage_buffer_object

        /// <summary>
        /// change an active shader storage block binding
        /// <para>Require:</para> <para>GL_VERSION_4_3, GL_ARB_shader_storage_buffer_object</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glShaderStorageBlockBinding(GLuint program, GLuint storageBlockIndex, GLuint storageBlockBinding);</para>
        /// </summary>
        public static void glShaderStorageBlockBinding(uint program, uint storageBlockIndex, uint storageBlockBinding) {
            var _F = _GetProc<GLNativeDelegate.FNglShaderStorageBlockBinding>("glShaderStorageBlockBinding");
            _F(program, storageBlockIndex, storageBlockBinding);
        }

        #endregion Reuse commands from ARB_shader_storage_buffer_object

        #region Reuse commands from ARB_texture_buffer_range

        /// <summary>
        /// attach a range of a buffer object's data store to a buffer texture object
        /// <para>Require:</para> <para>GL_VERSION_4_3, GL_ES_VERSION_3_2, GL_ARB_texture_buffer_range</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glTexBufferRange(GLenum target, GLenum internalformat, GLuint buffer, GLintptr offset, GLsizeiptr size);</para>
        /// </summary>
        public static void glTexBufferRange(uint target, uint internalformat, uint buffer, IntPtr offset, IntPtr size) {
            var _F = _GetProc<GLNativeDelegate.FNglTexBufferRange>("glTexBufferRange");
            _F(target, internalformat, buffer, offset, size);
        }

        #endregion Reuse commands from ARB_texture_buffer_range

        #region Reuse commands from ARB_texture_storage_multisample

        /// <summary>
        /// specify storage for a two-dimensional multisample texture
        /// <para>Require:</para> <para>GL_VERSION_4_3, GL_ES_VERSION_3_1, GL_ARB_texture_storage_multisample</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glTexStorage2DMultisample(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations);</para>
        /// </summary>
        public static void glTexStorage2DMultisample(uint target, int samples, uint internalformat, int width, int height, bool fixedsamplelocations) {
            var _F = _GetProc<GLNativeDelegate.FNglTexStorage2DMultisample>("glTexStorage2DMultisample");
            _F(target, samples, internalformat, width, height, fixedsamplelocations);
        }
        /// <summary>
        /// specify storage for a two-dimensional multisample array texture
        /// <para>Require:</para> <para>GL_VERSION_4_3, GL_ES_VERSION_3_2, GL_ARB_texture_storage_multisample</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glTexStorage3DMultisample(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations);</para>
        /// </summary>
        public static void glTexStorage3DMultisample(uint target, int samples, uint internalformat, int width, int height, int depth, bool fixedsamplelocations) {
            var _F = _GetProc<GLNativeDelegate.FNglTexStorage3DMultisample>("glTexStorage3DMultisample");
            _F(target, samples, internalformat, width, height, depth, fixedsamplelocations);
        }

        #endregion Reuse commands from ARB_texture_storage_multisample

        #region Reuse commands from ARB_texture_view

        /// <summary>
        /// initialize a texture as a data alias of another texture's data store
        /// <para>Require:</para> <para>GL_VERSION_4_3, GL_ARB_texture_view</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glTextureView(GLuint texture, GLenum target, GLuint origtexture, GLenum internalformat, GLuint minlevel, GLuint numlevels, GLuint minlayer, GLuint numlayers);</para>
        /// </summary>
        public static void glTextureView(uint texture, uint target, uint origtexture, uint internalformat, uint minlevel, uint numlevels, uint minlayer, uint numlayers) {
            var _F = _GetProc<GLNativeDelegate.FNglTextureView>("glTextureView");
            _F(texture, target, origtexture, internalformat, minlevel, numlevels, minlayer, numlayers);
        }

        #endregion Reuse commands from ARB_texture_view

        #region Reuse commands from ARB_vertex_attrib_binding

        /// <summary>
        /// bind a buffer to a vertex buffer bind point
        /// <para>Require:</para> <para>GL_VERSION_4_3, GL_ES_VERSION_3_1, GL_ARB_vertex_attrib_binding</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glBindVertexBuffer(GLuint bindingindex, GLuint buffer, GLintptr offset, GLsizei stride);</para>
        /// </summary>
        public static void glBindVertexBuffer(uint bindingindex, uint buffer, IntPtr offset, int stride) {
            var _F = _GetProc<GLNativeDelegate.FNglBindVertexBuffer>("glBindVertexBuffer");
            _F(bindingindex, buffer, offset, stride);
        }
        /// <summary>
        /// specify the organization of vertex arrays
        /// <para>Require:</para> <para>GL_VERSION_4_3, GL_ES_VERSION_3_1, GL_ARB_vertex_attrib_binding</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glVertexAttribFormat(GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset);</para>
        /// </summary>
        public static void glVertexAttribFormat(uint attribindex, int size, uint type, bool normalized, uint relativeoffset) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttribFormat>("glVertexAttribFormat");
            _F(attribindex, size, type, normalized, relativeoffset);
        }
        /// <summary>
        /// specify the organization of vertex arrays
        /// <para>Require:</para> <para>GL_VERSION_4_3, GL_ES_VERSION_3_1, GL_ARB_vertex_attrib_binding</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glVertexAttribIFormat(GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset);</para>
        /// </summary>
        public static void glVertexAttribIFormat(uint attribindex, int size, uint type, uint relativeoffset) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttribIFormat>("glVertexAttribIFormat");
            _F(attribindex, size, type, relativeoffset);
        }
        /// <summary>
        /// specify the organization of vertex arrays
        /// <para>Require:</para> <para>GL_VERSION_4_3, GL_ARB_vertex_attrib_binding</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glVertexAttribLFormat(GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset);</para>
        /// </summary>
        public static void glVertexAttribLFormat(uint attribindex, int size, uint type, uint relativeoffset) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttribLFormat>("glVertexAttribLFormat");
            _F(attribindex, size, type, relativeoffset);
        }
        /// <summary>
        /// associate a vertex attribute and a vertex buffer binding for a vertex array object
        /// <para>Require:</para> <para>GL_VERSION_4_3, GL_ES_VERSION_3_1, GL_ARB_vertex_attrib_binding</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glVertexAttribBinding(GLuint attribindex, GLuint bindingindex);</para>
        /// </summary>
        public static void glVertexAttribBinding(uint attribindex, uint bindingindex) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttribBinding>("glVertexAttribBinding");
            _F(attribindex, bindingindex);
        }
        /// <summary>
        /// <para>
        /// modify the rate at which generic vertex attributes
        /// advance
        /// </para>
        /// <para>Require:</para> <para>GL_VERSION_4_3, GL_ES_VERSION_3_1, GL_ARB_vertex_attrib_binding</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glVertexBindingDivisor(GLuint bindingindex, GLuint divisor);</para>
        /// </summary>
        public static void glVertexBindingDivisor(uint bindingindex, uint divisor) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexBindingDivisor>("glVertexBindingDivisor");
            _F(bindingindex, divisor);
        }

        #endregion Reuse commands from ARB_vertex_attrib_binding

        #region Reuse commands from KHR_debug (includes ARB_debug_output commands promoted to KHR without suffixes)

        /// <summary>
        /// control the reporting of debug messages in a debug context
        /// <para>Require:</para> <para>GL_VERSION_4_3, GL_ES_VERSION_3_2, GL_KHR_debug</para>
        /// Supported: <para>gl, glcore, gles1, gles2</para>
        /// Original: <para>void glDebugMessageControl(GLenum source, GLenum type, GLenum severity, GLsizei count, const GLuint * ids, GLboolean enabled);</para>
        /// </summary>
        public unsafe static void glDebugMessageControl(uint source, uint type, uint severity, int count, uint* ids, bool enabled) {
            var _F = _GetProc<GLNativeDelegate.FNglDebugMessageControl>("glDebugMessageControl");
            _F(source, type, severity, count, ids, enabled);
        }
        /// <summary>
        /// inject an application-supplied message into the debug message queue
        /// <para>Require:</para> <para>GL_VERSION_4_3, GL_ES_VERSION_3_2, GL_KHR_debug</para>
        /// Supported: <para>gl, glcore, gles1, gles2</para>
        /// Original: <para>void glDebugMessageInsert(GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const char * message);</para>
        /// </summary>
        public unsafe static void glDebugMessageInsert(uint source, uint type, uint id, uint severity, int length, byte* message) {
            var _F = _GetProc<GLNativeDelegate.FNglDebugMessageInsert>("glDebugMessageInsert");
            _F(source, type, id, severity, length, message);
        }
        /// <summary>
        /// specify a callback to receive debugging messages from the GL
        /// <para>Require:</para> <para>GL_VERSION_4_3, GL_ES_VERSION_3_2, GL_KHR_debug</para>
        /// Supported: <para>gl, glcore, gles1, gles2</para>
        /// Original: <para>void glDebugMessageCallback(GLDEBUGPROC callback, const void * userParam);</para>
        /// </summary>
        public unsafe static void glDebugMessageCallback(GLNativeDelegate.GLDEBUGPROC callback, void* userParam) {
            var _F = _GetProc<GLNativeDelegate.FNglDebugMessageCallback>("glDebugMessageCallback");
            _F(callback, userParam);
        }
        /// <summary>
        /// retrieve messages from the debug message log
        /// <para>Require:</para> <para>GL_VERSION_4_3, GL_ES_VERSION_3_2, GL_KHR_debug</para>
        /// Supported: <para>gl, glcore, gles1, gles2</para>
        /// Original: <para>GLuint glGetDebugMessageLog(GLuint count, GLsizei bufSize, GLenum * sources, GLenum * types, GLuint * ids, GLenum * severities, GLsizei * lengths, GLchar * messageLog);</para>
        /// </summary>
        public unsafe static uint glGetDebugMessageLog(uint count, int bufSize, uint* sources, uint* types, uint* ids, uint* severities, int* lengths, byte* messageLog) {
            var _F = _GetProc<GLNativeDelegate.FNglGetDebugMessageLog>("glGetDebugMessageLog");
            return _F(count, bufSize, sources, types, ids, severities, lengths, messageLog);
        }
        /// <summary>
        /// push a named debug group into the command stream
        /// <para>Require:</para> <para>GL_VERSION_4_3, GL_ES_VERSION_3_2, GL_KHR_debug</para>
        /// Supported: <para>gl, glcore, gles1, gles2</para>
        /// Original: <para>void glPushDebugGroup(GLenum source, GLuint id, GLsizei length, const char * message);</para>
        /// </summary>
        public unsafe static void glPushDebugGroup(uint source, uint id, int length, byte* message) {
            var _F = _GetProc<GLNativeDelegate.FNglPushDebugGroup>("glPushDebugGroup");
            _F(source, id, length, message);
        }
        /// <summary>
        /// pop the active debug group
        /// <para>Require:</para> <para>GL_VERSION_4_3, GL_ES_VERSION_3_2, GL_KHR_debug</para>
        /// Supported: <para>gl, glcore, gles1, gles2</para>
        /// Original: <para>void glPopDebugGroup();</para>
        /// </summary>
        public static void glPopDebugGroup() {
            var _F = _GetProc<GLNativeDelegate.FNglPopDebugGroup>("glPopDebugGroup");
            _F();
        }
        /// <summary>
        /// label a named object identified within a namespace
        /// <para>Require:</para> <para>GL_VERSION_4_3, GL_ES_VERSION_3_2, GL_KHR_debug</para>
        /// Supported: <para>gl, glcore, gles1, gles2</para>
        /// Original: <para>void glObjectLabel(GLenum identifier, GLuint name, GLsizei length, const char * label);</para>
        /// </summary>
        public unsafe static void glObjectLabel(uint identifier, uint name, int length, byte* label) {
            var _F = _GetProc<GLNativeDelegate.FNglObjectLabel>("glObjectLabel");
            _F(identifier, name, length, label);
        }
        /// <summary>
        /// retrieve the label of a named object identified within a namespace
        /// <para>Require:</para> <para>GL_VERSION_4_3, GL_ES_VERSION_3_2, GL_KHR_debug</para>
        /// Supported: <para>gl, glcore, gles1, gles2</para>
        /// Original: <para>void glGetObjectLabel(GLenum identifier, GLuint name, GLsizei bufSize, GLsizei * length, char * label);</para>
        /// </summary>
        public unsafe static void glGetObjectLabel(uint identifier, uint name, int bufSize, int* length, byte* label) {
            var _F = _GetProc<GLNativeDelegate.FNglGetObjectLabel>("glGetObjectLabel");
            _F(identifier, name, bufSize, length, label);
        }
        /// <summary>
        /// label a sync object identified by a pointer
        /// <para>Require:</para> <para>GL_VERSION_4_3, GL_ES_VERSION_3_2, GL_KHR_debug</para>
        /// Supported: <para>gl, glcore, gles1, gles2</para>
        /// Original: <para>void glObjectPtrLabel(void * ptr, GLsizei length, const char * label);</para>
        /// </summary>
        public unsafe static void glObjectPtrLabel(void* ptr, int length, byte* label) {
            var _F = _GetProc<GLNativeDelegate.FNglObjectPtrLabel>("glObjectPtrLabel");
            _F(ptr, length, label);
        }
        /// <summary>
        /// retrieve the label of a sync object identified by a pointer
        /// <para>Require:</para> <para>GL_VERSION_4_3, GL_ES_VERSION_3_2, GL_KHR_debug</para>
        /// Supported: <para>gl, glcore, gles1, gles2</para>
        /// Original: <para>void glGetObjectPtrLabel(void * ptr, GLsizei bufSize, GLsizei * length, char * label);</para>
        /// </summary>
        public unsafe static void glGetObjectPtrLabel(void* ptr, int bufSize, int* length, byte* label) {
            var _F = _GetProc<GLNativeDelegate.FNglGetObjectPtrLabel>("glGetObjectPtrLabel");
            _F(ptr, bufSize, length, label);
        }
        // void glGetPointerv(GLenum pname, void ** ps);

        #endregion Reuse commands from KHR_debug (includes ARB_debug_output commands promoted to KHR without suffixes)

        #endregion GL_VERSION_4_3

        #region GL_VERSION_4_4


        #region Reuse GL_ARB_buffer_storage

        /// <summary>
        /// <para>
        /// creates and initializes a buffer object's immutable data
        /// store
        /// </para>
        /// <para>Require:</para> <para>GL_VERSION_4_4, GL_ARB_buffer_storage</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glBufferStorage(GLenum target, GLsizeiptr size, const void * data, GLbitfield flags);</para>
        /// </summary>
        public unsafe static void glBufferStorage(uint target, IntPtr size, void* data, uint flags) {
            var _F = _GetProc<GLNativeDelegate.FNglBufferStorage>("glBufferStorage");
            _F(target, size, data, flags);
        }

        #endregion Reuse GL_ARB_buffer_storage

        #region Reuse GL_ARB_clear_texture

        /// <summary>
        /// fills all a texture image with a constant value
        /// <para>Require:</para> <para>GL_VERSION_4_4, GL_ARB_clear_texture</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glClearTexImage(GLuint texture, GLint level, GLenum format, GLenum type, const void * data);</para>
        /// </summary>
        public unsafe static void glClearTexImage(uint texture, int level, uint format, uint type, void* data) {
            var _F = _GetProc<GLNativeDelegate.FNglClearTexImage>("glClearTexImage");
            _F(texture, level, format, type, data);
        }
        /// <summary>
        /// fills all or part of a texture image with a constant value
        /// <para>Require:</para> <para>GL_VERSION_4_4, GL_ARB_clear_texture</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glClearTexSubImage(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void * data);</para>
        /// </summary>
        public unsafe static void glClearTexSubImage(uint texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, uint format, uint type, void* data) {
            var _F = _GetProc<GLNativeDelegate.FNglClearTexSubImage>("glClearTexSubImage");
            _F(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, type, data);
        }

        #endregion Reuse GL_ARB_clear_texture

        #region Reuse GL_ARB_multi_bind (none)

        /// <summary>
        /// bind one or more buffer objects to a sequence of indexed buffer targets
        /// <para>Require:</para> <para>GL_VERSION_4_4, GL_ARB_multi_bind</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glBindBuffersBase(GLenum target, GLuint first, GLsizei count, const GLuint * buffers);</para>
        /// </summary>
        public unsafe static void glBindBuffersBase(uint target, uint first, int count, uint* buffers) {
            var _F = _GetProc<GLNativeDelegate.FNglBindBuffersBase>("glBindBuffersBase");
            _F(target, first, count, buffers);
        }
        /// <summary>
        /// bind ranges of one or more buffer objects to a sequence of indexed buffer targets
        /// <para>Require:</para> <para>GL_VERSION_4_4, GL_ARB_multi_bind</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glBindBuffersRange(GLenum target, GLuint first, GLsizei count, const GLuint * buffers, const GLintptr * offsets, const GLintptr * sizes);</para>
        /// </summary>
        public unsafe static void glBindBuffersRange(uint target, uint first, int count, uint* buffers, IntPtr offsets, IntPtr sizes) {
            var _F = _GetProc<GLNativeDelegate.FNglBindBuffersRange>("glBindBuffersRange");
            _F(target, first, count, buffers, offsets, sizes);
        }
        /// <summary>
        /// bind one or more named textures to a sequence of consecutive texture units
        /// <para>Require:</para> <para>GL_VERSION_4_4, GL_ARB_multi_bind</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glBindTextures(GLuint first, GLsizei count, const GLuint * textures);</para>
        /// </summary>
        public unsafe static void glBindTextures(uint first, int count, uint* textures) {
            var _F = _GetProc<GLNativeDelegate.FNglBindTextures>("glBindTextures");
            _F(first, count, textures);
        }
        /// <summary>
        /// bind one or more named sampler objects to a sequence of consecutive sampler units
        /// <para>Require:</para> <para>GL_VERSION_4_4, GL_ARB_multi_bind</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glBindSamplers(GLuint first, GLsizei count, const GLuint * samplers);</para>
        /// </summary>
        public unsafe static void glBindSamplers(uint first, int count, uint* samplers) {
            var _F = _GetProc<GLNativeDelegate.FNglBindSamplers>("glBindSamplers");
            _F(first, count, samplers);
        }
        /// <summary>
        /// bind one or more named texture images to a sequence of consecutive image units
        /// <para>Require:</para> <para>GL_VERSION_4_4, GL_ARB_multi_bind</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glBindImageTextures(GLuint first, GLsizei count, const GLuint * textures);</para>
        /// </summary>
        public unsafe static void glBindImageTextures(uint first, int count, uint* textures) {
            var _F = _GetProc<GLNativeDelegate.FNglBindImageTextures>("glBindImageTextures");
            _F(first, count, textures);
        }
        /// <summary>
        /// attach multiple buffer objects to a vertex array object
        /// <para>Require:</para> <para>GL_VERSION_4_4, GL_ARB_multi_bind</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glBindVertexBuffers(GLuint first, GLsizei count, const GLuint * buffers, const GLintptr * offsets, const GLsizei * strides);</para>
        /// </summary>
        public unsafe static void glBindVertexBuffers(uint first, int count, uint* buffers, IntPtr offsets, int* strides) {
            var _F = _GetProc<GLNativeDelegate.FNglBindVertexBuffers>("glBindVertexBuffers");
            _F(first, count, buffers, offsets, strides);
        }

        #endregion Reuse GL_ARB_multi_bind (none)

        #endregion GL_VERSION_4_4

        #region GL_VERSION_4_5


        #region Reuse GL_ARB_clip_control

        /// <summary>
        /// control clip coordinate to window coordinate behavior
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_clip_control</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glClipControl(GLenum origin, GLenum depth);</para>
        /// </summary>
        public static void glClipControl(uint origin, uint depth) {
            var _F = _GetProc<GLNativeDelegate.FNglClipControl>("glClipControl");
            _F(origin, depth);
        }

        #endregion Reuse GL_ARB_clip_control

        #region Reuse GL_ARB_direct_state_access

        /// <summary>
        /// create transform feedback objects
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glCreateTransformFeedbacks(GLsizei n, GLuint * ids);</para>
        /// </summary>
        public unsafe static void glCreateTransformFeedbacks(int n, uint* ids) {
            var _F = _GetProc<GLNativeDelegate.FNglCreateTransformFeedbacks>("glCreateTransformFeedbacks");
            _F(n, ids);
        }
        /// <summary>
        /// bind a buffer object to a transform feedback buffer object
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glTransformFeedbackBufferBase(GLuint xfb, GLuint index, GLuint buffer);</para>
        /// </summary>
        public static void glTransformFeedbackBufferBase(uint xfb, uint index, uint buffer) {
            var _F = _GetProc<GLNativeDelegate.FNglTransformFeedbackBufferBase>("glTransformFeedbackBufferBase");
            _F(xfb, index, buffer);
        }
        /// <summary>
        /// bind a range within a buffer object to a transform feedback buffer object
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glTransformFeedbackBufferRange(GLuint xfb, GLuint index, GLuint buffer, GLintptr offset, GLsizei size);</para>
        /// </summary>
        public static void glTransformFeedbackBufferRange(uint xfb, uint index, uint buffer, IntPtr offset, int size) {
            var _F = _GetProc<GLNativeDelegate.FNglTransformFeedbackBufferRange>("glTransformFeedbackBufferRange");
            _F(xfb, index, buffer, offset, size);
        }
        /// <summary>
        /// query the state of a transform feedback object.
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetTransformFeedbackiv(GLuint xfb, GLenum pname, GLint * param);</para>
        /// </summary>
        public unsafe static void glGetTransformFeedbackiv(uint xfb, uint pname, int* param) {
            var _F = _GetProc<GLNativeDelegate.FNglGetTransformFeedbackiv>("glGetTransformFeedbackiv");
            _F(xfb, pname, param);
        }
        /// <summary>
        /// query the state of a transform feedback object.
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetTransformFeedbacki_v(GLuint xfb, GLenum pname, GLuint index, GLint * param);</para>
        /// </summary>
        public unsafe static void glGetTransformFeedbacki_v(uint xfb, uint pname, uint index, int* param) {
            var _F = _GetProc<GLNativeDelegate.FNglGetTransformFeedbacki_v>("glGetTransformFeedbacki_v");
            _F(xfb, pname, index, param);
        }
        /// <summary>
        /// query the state of a transform feedback object.
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetTransformFeedbacki64_v(GLuint xfb, GLenum pname, GLuint index, GLint64 * param);</para>
        /// </summary>
        public unsafe static void glGetTransformFeedbacki64_v(uint xfb, uint pname, uint index, UInt64* param) {
            var _F = _GetProc<GLNativeDelegate.FNglGetTransformFeedbacki64_v>("glGetTransformFeedbacki64_v");
            _F(xfb, pname, index, param);
        }
        /// <summary>
        /// create buffer objects
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glCreateBuffers(GLsizei n, GLuint * buffers);</para>
        /// </summary>
        public unsafe static void glCreateBuffers(int n, uint* buffers) {
            var _F = _GetProc<GLNativeDelegate.FNglCreateBuffers>("glCreateBuffers");
            _F(n, buffers);
        }
        /// <summary>
        /// <para>
        /// creates and initializes a buffer object's immutable data
        /// store
        /// </para>
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glNamedBufferStorage(GLuint buffer, GLsizeiptr size, const void * data, GLbitfield flags);</para>
        /// </summary>
        public unsafe static void glNamedBufferStorage(uint buffer, IntPtr size, void* data, uint flags) {
            var _F = _GetProc<GLNativeDelegate.FNglNamedBufferStorage>("glNamedBufferStorage");
            _F(buffer, size, data, flags);
        }
        /// <summary>
        /// <para>
        /// creates and initializes a buffer object's data
        /// store
        /// </para>
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glNamedBufferData(GLuint buffer, GLsizeiptr size, const void * data, GLenum usage);</para>
        /// </summary>
        public unsafe static void glNamedBufferData(uint buffer, IntPtr size, void* data, uint usage) {
            var _F = _GetProc<GLNativeDelegate.FNglNamedBufferData>("glNamedBufferData");
            _F(buffer, size, data, usage);
        }
        /// <summary>
        /// updates a subset of a buffer object's data store
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glNamedBufferSubData(GLuint buffer, GLintptr offset, GLsizeiptr size, const void * data);</para>
        /// </summary>
        public unsafe static void glNamedBufferSubData(uint buffer, IntPtr offset, IntPtr size, void* data) {
            var _F = _GetProc<GLNativeDelegate.FNglNamedBufferSubData>("glNamedBufferSubData");
            _F(buffer, offset, size, data);
        }
        /// <summary>
        /// copy all or part of the data store of a buffer object to the data store of another buffer object
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glCopyNamedBufferSubData(GLuint readBuffer, GLuint writeBuffer, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size);</para>
        /// </summary>
        public static void glCopyNamedBufferSubData(uint readBuffer, uint writeBuffer, IntPtr readOffset, IntPtr writeOffset, IntPtr size) {
            var _F = _GetProc<GLNativeDelegate.FNglCopyNamedBufferSubData>("glCopyNamedBufferSubData");
            _F(readBuffer, writeBuffer, readOffset, writeOffset, size);
        }
        /// <summary>
        /// fill a buffer object's data store with a fixed value
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glClearNamedBufferData(GLuint buffer, GLenum internalformat, GLenum format, GLenum type, const void * data);</para>
        /// </summary>
        public unsafe static void glClearNamedBufferData(uint buffer, uint internalformat, uint format, uint type, void* data) {
            var _F = _GetProc<GLNativeDelegate.FNglClearNamedBufferData>("glClearNamedBufferData");
            _F(buffer, internalformat, format, type, data);
        }
        /// <summary>
        /// fill all or part of buffer object's data store with a fixed value
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glClearNamedBufferSubData(GLuint buffer, GLenum internalformat, GLintptr offset, GLsizeiptr size, GLenum format, GLenum type, const void * data);</para>
        /// </summary>
        public unsafe static void glClearNamedBufferSubData(uint buffer, uint internalformat, IntPtr offset, IntPtr size, uint format, uint type, void* data) {
            var _F = _GetProc<GLNativeDelegate.FNglClearNamedBufferSubData>("glClearNamedBufferSubData");
            _F(buffer, internalformat, offset, size, format, type, data);
        }
        /// <summary>
        /// map all of a buffer object's data store into the client's address space
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void * glMapNamedBuffer(GLuint buffer, GLenum access);</para>
        /// </summary>
        public unsafe static void* glMapNamedBuffer(uint buffer, uint access) {
            var _F = _GetProc<GLNativeDelegate.FNglMapNamedBuffer>("glMapNamedBuffer");
            return _F(buffer, access);
        }
        /// <summary>
        /// map all or part of a buffer object's data store into the client's address space
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void * glMapNamedBufferRange(GLuint buffer, GLintptr offset, GLsizeiptr length, GLbitfield access);</para>
        /// </summary>
        public unsafe static void* glMapNamedBufferRange(uint buffer, IntPtr offset, IntPtr length, uint access) {
            var _F = _GetProc<GLNativeDelegate.FNglMapNamedBufferRange>("glMapNamedBufferRange");
            return _F(buffer, offset, length, access);
        }
        /// <summary>
        /// release the mapping of a buffer object's data store into the client's address space
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>GLboolean glUnmapNamedBuffer(GLuint buffer);</para>
        /// </summary>
        public static bool glUnmapNamedBuffer(uint buffer) {
            var _F = _GetProc<GLNativeDelegate.FNglUnmapNamedBuffer>("glUnmapNamedBuffer");
            return _F(buffer);
        }
        /// <summary>
        /// indicate modifications to a range of a mapped buffer
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glFlushMappedNamedBufferRange(GLuint buffer, GLintptr offset, GLsizeiptr length);</para>
        /// </summary>
        public static void glFlushMappedNamedBufferRange(uint buffer, IntPtr offset, IntPtr length) {
            var _F = _GetProc<GLNativeDelegate.FNglFlushMappedNamedBufferRange>("glFlushMappedNamedBufferRange");
            _F(buffer, offset, length);
        }
        /// <summary>
        /// return parameters of a buffer object
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetNamedBufferParameteriv(GLuint buffer, GLenum pname, GLint * params);</para>
        /// </summary>
        public unsafe static void glGetNamedBufferParameteriv(uint buffer, uint pname, int* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetNamedBufferParameteriv>("glGetNamedBufferParameteriv");
            _F(buffer, pname, ps);
        }
        /// <summary>
        /// return parameters of a buffer object
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetNamedBufferParameteri64v(GLuint buffer, GLenum pname, GLint64 * params);</para>
        /// </summary>
        public unsafe static void glGetNamedBufferParameteri64v(uint buffer, uint pname, UInt64* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetNamedBufferParameteri64v>("glGetNamedBufferParameteri64v");
            _F(buffer, pname, ps);
        }
        /// <summary>
        /// return the pointer to a mapped buffer object's data store
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetNamedBufferPointerv(GLuint buffer, GLenum pname, void ** params);</para>
        /// </summary>
        public unsafe static void glGetNamedBufferPointerv(uint buffer, uint pname, void** ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetNamedBufferPointerv>("glGetNamedBufferPointerv");
            _F(buffer, pname, ps);
        }
        /// <summary>
        /// returns a subset of a buffer object's data store
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetNamedBufferSubData(GLuint buffer, GLintptr offset, GLsizeiptr size, void * data);</para>
        /// </summary>
        public unsafe static void glGetNamedBufferSubData(uint buffer, IntPtr offset, IntPtr size, void* data) {
            var _F = _GetProc<GLNativeDelegate.FNglGetNamedBufferSubData>("glGetNamedBufferSubData");
            _F(buffer, offset, size, data);
        }
        /// <summary>
        /// create framebuffer objects
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glCreateFramebuffers(GLsizei n, GLuint * framebuffers);</para>
        /// </summary>
        public unsafe static void glCreateFramebuffers(int n, uint* framebuffers) {
            var _F = _GetProc<GLNativeDelegate.FNglCreateFramebuffers>("glCreateFramebuffers");
            _F(n, framebuffers);
        }
        /// <summary>
        /// attach a renderbuffer as a logical buffer of a framebuffer object
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glNamedFramebufferRenderbuffer(GLuint framebuffer, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer);</para>
        /// </summary>
        public static void glNamedFramebufferRenderbuffer(uint framebuffer, uint attachment, uint renderbuffertarget, uint renderbuffer) {
            var _F = _GetProc<GLNativeDelegate.FNglNamedFramebufferRenderbuffer>("glNamedFramebufferRenderbuffer");
            _F(framebuffer, attachment, renderbuffertarget, renderbuffer);
        }
        /// <summary>
        /// set a named parameter of a framebuffer object
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glNamedFramebufferParameteri(GLuint framebuffer, GLenum pname, GLint param);</para>
        /// </summary>
        public static void glNamedFramebufferParameteri(uint framebuffer, uint pname, int param) {
            var _F = _GetProc<GLNativeDelegate.FNglNamedFramebufferParameteri>("glNamedFramebufferParameteri");
            _F(framebuffer, pname, param);
        }
        /// <summary>
        /// attach a level of a texture object as a logical buffer of a framebuffer object
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glNamedFramebufferTexture(GLuint framebuffer, GLenum attachment, GLuint texture, GLint level);</para>
        /// </summary>
        public static void glNamedFramebufferTexture(uint framebuffer, uint attachment, uint texture, int level) {
            var _F = _GetProc<GLNativeDelegate.FNglNamedFramebufferTexture>("glNamedFramebufferTexture");
            _F(framebuffer, attachment, texture, level);
        }
        /// <summary>
        /// attach a single layer of a texture object as a logical buffer of a framebuffer object
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glNamedFramebufferTextureLayer(GLuint framebuffer, GLenum attachment, GLuint texture, GLint level, GLint layer);</para>
        /// </summary>
        public static void glNamedFramebufferTextureLayer(uint framebuffer, uint attachment, uint texture, int level, int layer) {
            var _F = _GetProc<GLNativeDelegate.FNglNamedFramebufferTextureLayer>("glNamedFramebufferTextureLayer");
            _F(framebuffer, attachment, texture, level, layer);
        }
        /// <summary>
        /// specify which color buffers are to be drawn into
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glNamedFramebufferDrawBuffer(GLuint framebuffer, GLenum buf);</para>
        /// </summary>
        public static void glNamedFramebufferDrawBuffer(uint framebuffer, uint buf) {
            var _F = _GetProc<GLNativeDelegate.FNglNamedFramebufferDrawBuffer>("glNamedFramebufferDrawBuffer");
            _F(framebuffer, buf);
        }
        /// <summary>
        /// <para>
        /// Specifies a list of color buffers to be drawn
        /// into
        /// </para>
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glNamedFramebufferDrawBuffers(GLuint framebuffer, GLsizei n, const GLenum * bufs);</para>
        /// </summary>
        public unsafe static void glNamedFramebufferDrawBuffers(uint framebuffer, int n, uint* bufs) {
            var _F = _GetProc<GLNativeDelegate.FNglNamedFramebufferDrawBuffers>("glNamedFramebufferDrawBuffers");
            _F(framebuffer, n, bufs);
        }
        /// <summary>
        /// select a color buffer source for pixels
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glNamedFramebufferReadBuffer(GLuint framebuffer, GLenum mode);</para>
        /// </summary>
        public static void glNamedFramebufferReadBuffer(uint framebuffer, uint mode) {
            var _F = _GetProc<GLNativeDelegate.FNglNamedFramebufferReadBuffer>("glNamedFramebufferReadBuffer");
            _F(framebuffer, mode);
        }
        /// <summary>
        /// invalidate the content of some or all of a framebuffer's attachments
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glInvalidateNamedFramebufferData(GLuint framebuffer, GLsizei numAttachments, const GLenum * attachments);</para>
        /// </summary>
        public unsafe static void glInvalidateNamedFramebufferData(uint framebuffer, int numAttachments, uint* attachments) {
            var _F = _GetProc<GLNativeDelegate.FNglInvalidateNamedFramebufferData>("glInvalidateNamedFramebufferData");
            _F(framebuffer, numAttachments, attachments);
        }
        /// <summary>
        /// invalidate the content of a region of some or all of a framebuffer's attachments
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glInvalidateNamedFramebufferSubData(GLuint framebuffer, GLsizei numAttachments, const GLenum * attachments, GLint x, GLint y, GLsizei width, GLsizei height);</para>
        /// </summary>
        public unsafe static void glInvalidateNamedFramebufferSubData(uint framebuffer, int numAttachments, uint* attachments, int x, int y, int width, int height) {
            var _F = _GetProc<GLNativeDelegate.FNglInvalidateNamedFramebufferSubData>("glInvalidateNamedFramebufferSubData");
            _F(framebuffer, numAttachments, attachments, x, y, width, height);
        }
        /// <summary>
        /// clear individual buffers of a framebuffer
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glClearNamedFramebufferiv(GLuint framebuffer, GLenum buffer, GLint drawbuffer, const GLint * value);</para>
        /// </summary>
        public unsafe static void glClearNamedFramebufferiv(uint framebuffer, uint buffer, int drawbuffer, int* value) {
            var _F = _GetProc<GLNativeDelegate.FNglClearNamedFramebufferiv>("glClearNamedFramebufferiv");
            _F(framebuffer, buffer, drawbuffer, value);
        }
        /// <summary>
        /// clear individual buffers of a framebuffer
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glClearNamedFramebufferuiv(GLuint framebuffer, GLenum buffer, GLint drawbuffer, const GLuint * value);</para>
        /// </summary>
        public unsafe static void glClearNamedFramebufferuiv(uint framebuffer, uint buffer, int drawbuffer, uint* value) {
            var _F = _GetProc<GLNativeDelegate.FNglClearNamedFramebufferuiv>("glClearNamedFramebufferuiv");
            _F(framebuffer, buffer, drawbuffer, value);
        }
        /// <summary>
        /// clear individual buffers of a framebuffer
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glClearNamedFramebufferfv(GLuint framebuffer, GLenum buffer, GLint drawbuffer, const GLfloat * value);</para>
        /// </summary>
        public unsafe static void glClearNamedFramebufferfv(uint framebuffer, uint buffer, int drawbuffer, float* value) {
            var _F = _GetProc<GLNativeDelegate.FNglClearNamedFramebufferfv>("glClearNamedFramebufferfv");
            _F(framebuffer, buffer, drawbuffer, value);
        }
        /// <summary>
        /// clear individual buffers of a framebuffer
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glClearNamedFramebufferfi(GLuint framebuffer, GLenum buffer, GLint drawbuffer, GLfloat depth, GLint stencil);</para>
        /// </summary>
        public static void glClearNamedFramebufferfi(uint framebuffer, uint buffer, int drawbuffer, float depth, int stencil) {
            var _F = _GetProc<GLNativeDelegate.FNglClearNamedFramebufferfi>("glClearNamedFramebufferfi");
            _F(framebuffer, buffer, drawbuffer, depth, stencil);
        }
        /// <summary>
        /// copy a block of pixels from one framebuffer object to another
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glBlitNamedFramebuffer(GLuint readFramebuffer, GLuint drawFramebuffer, GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter);</para>
        /// </summary>
        public static void glBlitNamedFramebuffer(uint readFramebuffer, uint drawFramebuffer, int srcX0, int srcY0, int srcX1, int srcY1, int dstX0, int dstY0, int dstX1, int dstY1, uint mask, uint filter) {
            var _F = _GetProc<GLNativeDelegate.FNglBlitNamedFramebuffer>("glBlitNamedFramebuffer");
            _F(readFramebuffer, drawFramebuffer, srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
        }
        /// <summary>
        /// check the completeness status of a framebuffer
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>GLenum glCheckNamedFramebufferStatus(GLuint framebuffer, GLenum target);</para>
        /// </summary>
        public static uint glCheckNamedFramebufferStatus(uint framebuffer, uint target) {
            var _F = _GetProc<GLNativeDelegate.FNglCheckNamedFramebufferStatus>("glCheckNamedFramebufferStatus");
            return _F(framebuffer, target);
        }
        /// <summary>
        /// query a named parameter of a framebuffer object
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetNamedFramebufferParameteriv(GLuint framebuffer, GLenum pname, GLint * param);</para>
        /// </summary>
        public unsafe static void glGetNamedFramebufferParameteriv(uint framebuffer, uint pname, int* param) {
            var _F = _GetProc<GLNativeDelegate.FNglGetNamedFramebufferParameteriv>("glGetNamedFramebufferParameteriv");
            _F(framebuffer, pname, param);
        }
        /// <summary>
        /// retrieve information about attachments of a framebuffer object
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetNamedFramebufferAttachmentParameteriv(GLuint framebuffer, GLenum attachment, GLenum pname, GLint * params);</para>
        /// </summary>
        public unsafe static void glGetNamedFramebufferAttachmentParameteriv(uint framebuffer, uint attachment, uint pname, int* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetNamedFramebufferAttachmentParameteriv>("glGetNamedFramebufferAttachmentParameteriv");
            _F(framebuffer, attachment, pname, ps);
        }
        /// <summary>
        /// create renderbuffer objects
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glCreateRenderbuffers(GLsizei n, GLuint * renderbuffers);</para>
        /// </summary>
        public unsafe static void glCreateRenderbuffers(int n, uint* renderbuffers) {
            var _F = _GetProc<GLNativeDelegate.FNglCreateRenderbuffers>("glCreateRenderbuffers");
            _F(n, renderbuffers);
        }
        /// <summary>
        /// <para>
        /// establish data storage, format and dimensions of a
        /// renderbuffer object's image
        /// </para>
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glNamedRenderbufferStorage(GLuint renderbuffer, GLenum internalformat, GLsizei width, GLsizei height);</para>
        /// </summary>
        public static void glNamedRenderbufferStorage(uint renderbuffer, uint internalformat, int width, int height) {
            var _F = _GetProc<GLNativeDelegate.FNglNamedRenderbufferStorage>("glNamedRenderbufferStorage");
            _F(renderbuffer, internalformat, width, height);
        }
        /// <summary>
        /// <para>
        /// establish data storage, format, dimensions and sample count of
        /// a renderbuffer object's image
        /// </para>
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glNamedRenderbufferStorageMultisample(GLuint renderbuffer, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height);</para>
        /// </summary>
        public static void glNamedRenderbufferStorageMultisample(uint renderbuffer, int samples, uint internalformat, int width, int height) {
            var _F = _GetProc<GLNativeDelegate.FNglNamedRenderbufferStorageMultisample>("glNamedRenderbufferStorageMultisample");
            _F(renderbuffer, samples, internalformat, width, height);
        }
        /// <summary>
        /// query a named parameter of a renderbuffer object
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetNamedRenderbufferParameteriv(GLuint renderbuffer, GLenum pname, GLint * params);</para>
        /// </summary>
        public unsafe static void glGetNamedRenderbufferParameteriv(uint renderbuffer, uint pname, int* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetNamedRenderbufferParameteriv>("glGetNamedRenderbufferParameteriv");
            _F(renderbuffer, pname, ps);
        }
        /// <summary>
        /// create texture objects
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glCreateTextures(GLenum target, GLsizei n, GLuint * textures);</para>
        /// </summary>
        public unsafe static void glCreateTextures(uint target, int n, uint* textures) {
            var _F = _GetProc<GLNativeDelegate.FNglCreateTextures>("glCreateTextures");
            _F(target, n, textures);
        }
        /// <summary>
        /// attach a buffer object's data store to a buffer texture object
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glTextureBuffer(GLuint texture, GLenum internalformat, GLuint buffer);</para>
        /// </summary>
        public static void glTextureBuffer(uint texture, uint internalformat, uint buffer) {
            var _F = _GetProc<GLNativeDelegate.FNglTextureBuffer>("glTextureBuffer");
            _F(texture, internalformat, buffer);
        }
        /// <summary>
        /// attach a range of a buffer object's data store to a buffer texture object
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glTextureBufferRange(GLuint texture, GLenum internalformat, GLuint buffer, GLintptr offset, GLsizei size);</para>
        /// </summary>
        public static void glTextureBufferRange(uint texture, uint internalformat, uint buffer, IntPtr offset, int size) {
            var _F = _GetProc<GLNativeDelegate.FNglTextureBufferRange>("glTextureBufferRange");
            _F(texture, internalformat, buffer, offset, size);
        }
        /// <summary>
        /// simultaneously specify storage for all levels of a one-dimensional texture
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glTextureStorage1D(GLuint texture, GLsizei levels, GLenum internalformat, GLsizei width);</para>
        /// </summary>
        public static void glTextureStorage1D(uint texture, int levels, uint internalformat, int width) {
            var _F = _GetProc<GLNativeDelegate.FNglTextureStorage1D>("glTextureStorage1D");
            _F(texture, levels, internalformat, width);
        }
        /// <summary>
        /// simultaneously specify storage for all levels of a two-dimensional or one-dimensional array texture
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glTextureStorage2D(GLuint texture, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height);</para>
        /// </summary>
        public static void glTextureStorage2D(uint texture, int levels, uint internalformat, int width, int height) {
            var _F = _GetProc<GLNativeDelegate.FNglTextureStorage2D>("glTextureStorage2D");
            _F(texture, levels, internalformat, width, height);
        }
        /// <summary>
        /// simultaneously specify storage for all levels of a three-dimensional, two-dimensional array or cube-map array texture
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glTextureStorage3D(GLuint texture, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth);</para>
        /// </summary>
        public static void glTextureStorage3D(uint texture, int levels, uint internalformat, int width, int height, int depth) {
            var _F = _GetProc<GLNativeDelegate.FNglTextureStorage3D>("glTextureStorage3D");
            _F(texture, levels, internalformat, width, height, depth);
        }
        /// <summary>
        /// specify storage for a two-dimensional multisample texture
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glTextureStorage2DMultisample(GLuint texture, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations);</para>
        /// </summary>
        public static void glTextureStorage2DMultisample(uint texture, int samples, uint internalformat, int width, int height, bool fixedsamplelocations) {
            var _F = _GetProc<GLNativeDelegate.FNglTextureStorage2DMultisample>("glTextureStorage2DMultisample");
            _F(texture, samples, internalformat, width, height, fixedsamplelocations);
        }
        /// <summary>
        /// specify storage for a two-dimensional multisample array texture
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glTextureStorage3DMultisample(GLuint texture, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations);</para>
        /// </summary>
        public static void glTextureStorage3DMultisample(uint texture, int samples, uint internalformat, int width, int height, int depth, bool fixedsamplelocations) {
            var _F = _GetProc<GLNativeDelegate.FNglTextureStorage3DMultisample>("glTextureStorage3DMultisample");
            _F(texture, samples, internalformat, width, height, depth, fixedsamplelocations);
        }
        /// <summary>
        /// specify a one-dimensional texture subimage
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glTextureSubImage1D(GLuint texture, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const void * pixels);</para>
        /// </summary>
        public unsafe static void glTextureSubImage1D(uint texture, int level, int xoffset, int width, uint format, uint type, void* pixels) {
            var _F = _GetProc<GLNativeDelegate.FNglTextureSubImage1D>("glTextureSubImage1D");
            _F(texture, level, xoffset, width, format, type, pixels);
        }
        /// <summary>
        /// specify a two-dimensional texture subimage
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glTextureSubImage2D(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const void * pixels);</para>
        /// </summary>
        public unsafe static void glTextureSubImage2D(uint texture, int level, int xoffset, int yoffset, int width, int height, uint format, uint type, void* pixels) {
            var _F = _GetProc<GLNativeDelegate.FNglTextureSubImage2D>("glTextureSubImage2D");
            _F(texture, level, xoffset, yoffset, width, height, format, type, pixels);
        }
        /// <summary>
        /// specify a three-dimensional texture subimage
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glTextureSubImage3D(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void * pixels);</para>
        /// </summary>
        public unsafe static void glTextureSubImage3D(uint texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, uint format, uint type, void* pixels) {
            var _F = _GetProc<GLNativeDelegate.FNglTextureSubImage3D>("glTextureSubImage3D");
            _F(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels);
        }
        /// <summary>
        /// <para>
        /// specify a one-dimensional texture subimage in a compressed
        /// format
        /// </para>
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glCompressedTextureSubImage1D(GLuint texture, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const void * data);</para>
        /// </summary>
        public unsafe static void glCompressedTextureSubImage1D(uint texture, int level, int xoffset, int width, uint format, int imageSize, void* data) {
            var _F = _GetProc<GLNativeDelegate.FNglCompressedTextureSubImage1D>("glCompressedTextureSubImage1D");
            _F(texture, level, xoffset, width, format, imageSize, data);
        }
        /// <summary>
        /// specify a two-dimensional texture subimage in a compressed format
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glCompressedTextureSubImage2D(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void * data);</para>
        /// </summary>
        public unsafe static void glCompressedTextureSubImage2D(uint texture, int level, int xoffset, int yoffset, int width, int height, uint format, int imageSize, void* data) {
            var _F = _GetProc<GLNativeDelegate.FNglCompressedTextureSubImage2D>("glCompressedTextureSubImage2D");
            _F(texture, level, xoffset, yoffset, width, height, format, imageSize, data);
        }
        /// <summary>
        /// specify a three-dimensional texture subimage in a compressed format
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glCompressedTextureSubImage3D(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void * data);</para>
        /// </summary>
        public unsafe static void glCompressedTextureSubImage3D(uint texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, uint format, int imageSize, void* data) {
            var _F = _GetProc<GLNativeDelegate.FNglCompressedTextureSubImage3D>("glCompressedTextureSubImage3D");
            _F(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data);
        }
        /// <summary>
        /// copy a one-dimensional texture subimage
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glCopyTextureSubImage1D(GLuint texture, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width);</para>
        /// </summary>
        public static void glCopyTextureSubImage1D(uint texture, int level, int xoffset, int x, int y, int width) {
            var _F = _GetProc<GLNativeDelegate.FNglCopyTextureSubImage1D>("glCopyTextureSubImage1D");
            _F(texture, level, xoffset, x, y, width);
        }
        /// <summary>
        /// copy a two-dimensional texture subimage
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glCopyTextureSubImage2D(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height);</para>
        /// </summary>
        public static void glCopyTextureSubImage2D(uint texture, int level, int xoffset, int yoffset, int x, int y, int width, int height) {
            var _F = _GetProc<GLNativeDelegate.FNglCopyTextureSubImage2D>("glCopyTextureSubImage2D");
            _F(texture, level, xoffset, yoffset, x, y, width, height);
        }
        /// <summary>
        /// copy a three-dimensional texture subimage
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glCopyTextureSubImage3D(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height);</para>
        /// </summary>
        public static void glCopyTextureSubImage3D(uint texture, int level, int xoffset, int yoffset, int zoffset, int x, int y, int width, int height) {
            var _F = _GetProc<GLNativeDelegate.FNglCopyTextureSubImage3D>("glCopyTextureSubImage3D");
            _F(texture, level, xoffset, yoffset, zoffset, x, y, width, height);
        }
        /// <summary>
        /// set texture parameters
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glTextureParameterf(GLuint texture, GLenum pname, GLfloat param);</para>
        /// </summary>
        public static void glTextureParameterf(uint texture, uint pname, float param) {
            var _F = _GetProc<GLNativeDelegate.FNglTextureParameterf>("glTextureParameterf");
            _F(texture, pname, param);
        }
        /// <summary>
        /// set texture parameters
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glTextureParameterfv(GLuint texture, GLenum pname, const GLfloat * params);</para>
        /// </summary>
        public unsafe static void glTextureParameterfv(uint texture, uint pname, float* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglTextureParameterfv>("glTextureParameterfv");
            _F(texture, pname, ps);
        }
        /// <summary>
        /// set texture parameters
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glTextureParameteri(GLuint texture, GLenum pname, GLint param);</para>
        /// </summary>
        public static void glTextureParameteri(uint texture, uint pname, int param) {
            var _F = _GetProc<GLNativeDelegate.FNglTextureParameteri>("glTextureParameteri");
            _F(texture, pname, param);
        }
        /// <summary>
        /// set texture parameters
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glTextureParameterIiv(GLuint texture, GLenum pname, const GLint * params);</para>
        /// </summary>
        public unsafe static void glTextureParameterIiv(uint texture, uint pname, int* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglTextureParameterIiv>("glTextureParameterIiv");
            _F(texture, pname, ps);
        }
        /// <summary>
        /// set texture parameters
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glTextureParameterIuiv(GLuint texture, GLenum pname, const GLuint * params);</para>
        /// </summary>
        public unsafe static void glTextureParameterIuiv(uint texture, uint pname, uint* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglTextureParameterIuiv>("glTextureParameterIuiv");
            _F(texture, pname, ps);
        }
        /// <summary>
        /// set texture parameters
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glTextureParameteriv(GLuint texture, GLenum pname, const GLint * params);</para>
        /// </summary>
        public unsafe static void glTextureParameteriv(uint texture, uint pname, int* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglTextureParameteriv>("glTextureParameteriv");
            _F(texture, pname, ps);
        }
        /// <summary>
        /// generate mipmaps for a specified texture object
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGenerateTextureMipmap(GLuint texture);</para>
        /// </summary>
        public static void glGenerateTextureMipmap(uint texture) {
            var _F = _GetProc<GLNativeDelegate.FNglGenerateTextureMipmap>("glGenerateTextureMipmap");
            _F(texture);
        }
        /// <summary>
        /// bind an existing texture object to the specified texture unit
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glBindTextureUnit(GLuint unit, GLuint texture);</para>
        /// </summary>
        public static void glBindTextureUnit(uint unit, uint texture) {
            var _F = _GetProc<GLNativeDelegate.FNglBindTextureUnit>("glBindTextureUnit");
            _F(unit, texture);
        }
        /// <summary>
        /// return a texture image
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetTextureImage(GLuint texture, GLint level, GLenum format, GLenum type, GLsizei bufSize, void * pixels);</para>
        /// </summary>
        public unsafe static void glGetTextureImage(uint texture, int level, uint format, uint type, int bufSize, void* pixels) {
            var _F = _GetProc<GLNativeDelegate.FNglGetTextureImage>("glGetTextureImage");
            _F(texture, level, format, type, bufSize, pixels);
        }
        /// <summary>
        /// return a compressed texture image
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetCompressedTextureImage(GLuint texture, GLint level, GLsizei bufSize, void * pixels);</para>
        /// </summary>
        public unsafe static void glGetCompressedTextureImage(uint texture, int level, int bufSize, void* pixels) {
            var _F = _GetProc<GLNativeDelegate.FNglGetCompressedTextureImage>("glGetCompressedTextureImage");
            _F(texture, level, bufSize, pixels);
        }
        /// <summary>
        /// <para>
        /// return texture parameter values for a specific level of
        /// detail
        /// </para>
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetTextureLevelParameterfv(GLuint texture, GLint level, GLenum pname, GLfloat * params);</para>
        /// </summary>
        public unsafe static void glGetTextureLevelParameterfv(uint texture, int level, uint pname, float* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetTextureLevelParameterfv>("glGetTextureLevelParameterfv");
            _F(texture, level, pname, ps);
        }
        /// <summary>
        /// <para>
        /// return texture parameter values for a specific level of
        /// detail
        /// </para>
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetTextureLevelParameteriv(GLuint texture, GLint level, GLenum pname, GLint * params);</para>
        /// </summary>
        public unsafe static void glGetTextureLevelParameteriv(uint texture, int level, uint pname, int* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetTextureLevelParameteriv>("glGetTextureLevelParameteriv");
            _F(texture, level, pname, ps);
        }
        /// <summary>
        /// return texture parameter values
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetTextureParameterfv(GLuint texture, GLenum pname, GLfloat * params);</para>
        /// </summary>
        public unsafe static void glGetTextureParameterfv(uint texture, uint pname, float* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetTextureParameterfv>("glGetTextureParameterfv");
            _F(texture, pname, ps);
        }
        /// <summary>
        /// return texture parameter values
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetTextureParameterIiv(GLuint texture, GLenum pname, GLint * params);</para>
        /// </summary>
        public unsafe static void glGetTextureParameterIiv(uint texture, uint pname, int* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetTextureParameterIiv>("glGetTextureParameterIiv");
            _F(texture, pname, ps);
        }
        /// <summary>
        /// return texture parameter values
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetTextureParameterIuiv(GLuint texture, GLenum pname, GLuint * params);</para>
        /// </summary>
        public unsafe static void glGetTextureParameterIuiv(uint texture, uint pname, uint* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetTextureParameterIuiv>("glGetTextureParameterIuiv");
            _F(texture, pname, ps);
        }
        /// <summary>
        /// return texture parameter values
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetTextureParameteriv(GLuint texture, GLenum pname, GLint * params);</para>
        /// </summary>
        public unsafe static void glGetTextureParameteriv(uint texture, uint pname, int* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetTextureParameteriv>("glGetTextureParameteriv");
            _F(texture, pname, ps);
        }
        /// <summary>
        /// create vertex array objects
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glCreateVertexArrays(GLsizei n, GLuint * arrays);</para>
        /// </summary>
        public unsafe static void glCreateVertexArrays(int n, uint* arrays) {
            var _F = _GetProc<GLNativeDelegate.FNglCreateVertexArrays>("glCreateVertexArrays");
            _F(n, arrays);
        }
        /// <summary>
        /// <para>
        /// Enable or disable a generic vertex attribute
        /// array
        /// </para>
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glDisableVertexArrayAttrib(GLuint vaobj, GLuint index);</para>
        /// </summary>
        public static void glDisableVertexArrayAttrib(uint vaobj, uint index) {
            var _F = _GetProc<GLNativeDelegate.FNglDisableVertexArrayAttrib>("glDisableVertexArrayAttrib");
            _F(vaobj, index);
        }
        /// <summary>
        /// <para>
        /// Enable or disable a generic vertex attribute
        /// array
        /// </para>
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glEnableVertexArrayAttrib(GLuint vaobj, GLuint index);</para>
        /// </summary>
        public static void glEnableVertexArrayAttrib(uint vaobj, uint index) {
            var _F = _GetProc<GLNativeDelegate.FNglEnableVertexArrayAttrib>("glEnableVertexArrayAttrib");
            _F(vaobj, index);
        }
        /// <summary>
        /// configures element array buffer binding of a vertex array object
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glVertexArrayElementBuffer(GLuint vaobj, GLuint buffer);</para>
        /// </summary>
        public static void glVertexArrayElementBuffer(uint vaobj, uint buffer) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexArrayElementBuffer>("glVertexArrayElementBuffer");
            _F(vaobj, buffer);
        }
        /// <summary>
        /// bind a buffer to a vertex buffer bind point
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glVertexArrayVertexBuffer(GLuint vaobj, GLuint bindingindex, GLuint buffer, GLintptr offset, GLsizei stride);</para>
        /// </summary>
        public static void glVertexArrayVertexBuffer(uint vaobj, uint bindingindex, uint buffer, IntPtr offset, int stride) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexArrayVertexBuffer>("glVertexArrayVertexBuffer");
            _F(vaobj, bindingindex, buffer, offset, stride);
        }
        /// <summary>
        /// attach multiple buffer objects to a vertex array object
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glVertexArrayVertexBuffers(GLuint vaobj, GLuint first, GLsizei count, const GLuint * buffers, const GLintptr * offsets, const GLsizei * strides);</para>
        /// </summary>
        public unsafe static void glVertexArrayVertexBuffers(uint vaobj, uint first, int count, uint* buffers, IntPtr offsets, int* strides) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexArrayVertexBuffers>("glVertexArrayVertexBuffers");
            _F(vaobj, first, count, buffers, offsets, strides);
        }
        /// <summary>
        /// associate a vertex attribute and a vertex buffer binding for a vertex array object
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glVertexArrayAttribBinding(GLuint vaobj, GLuint attribindex, GLuint bindingindex);</para>
        /// </summary>
        public static void glVertexArrayAttribBinding(uint vaobj, uint attribindex, uint bindingindex) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexArrayAttribBinding>("glVertexArrayAttribBinding");
            _F(vaobj, attribindex, bindingindex);
        }
        /// <summary>
        /// specify the organization of vertex arrays
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glVertexArrayAttribFormat(GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset);</para>
        /// </summary>
        public static void glVertexArrayAttribFormat(uint vaobj, uint attribindex, int size, uint type, bool normalized, uint relativeoffset) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexArrayAttribFormat>("glVertexArrayAttribFormat");
            _F(vaobj, attribindex, size, type, normalized, relativeoffset);
        }
        /// <summary>
        /// specify the organization of vertex arrays
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glVertexArrayAttribIFormat(GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset);</para>
        /// </summary>
        public static void glVertexArrayAttribIFormat(uint vaobj, uint attribindex, int size, uint type, uint relativeoffset) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexArrayAttribIFormat>("glVertexArrayAttribIFormat");
            _F(vaobj, attribindex, size, type, relativeoffset);
        }
        /// <summary>
        /// specify the organization of vertex arrays
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glVertexArrayAttribLFormat(GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset);</para>
        /// </summary>
        public static void glVertexArrayAttribLFormat(uint vaobj, uint attribindex, int size, uint type, uint relativeoffset) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexArrayAttribLFormat>("glVertexArrayAttribLFormat");
            _F(vaobj, attribindex, size, type, relativeoffset);
        }
        /// <summary>
        /// <para>
        /// modify the rate at which generic vertex attributes
        /// advance
        /// </para>
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glVertexArrayBindingDivisor(GLuint vaobj, GLuint bindingindex, GLuint divisor);</para>
        /// </summary>
        public static void glVertexArrayBindingDivisor(uint vaobj, uint bindingindex, uint divisor) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexArrayBindingDivisor>("glVertexArrayBindingDivisor");
            _F(vaobj, bindingindex, divisor);
        }
        /// <summary>
        /// retrieve parameters of a vertex array object
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetVertexArrayiv(GLuint vaobj, GLenum pname, GLint * param);</para>
        /// </summary>
        public unsafe static void glGetVertexArrayiv(uint vaobj, uint pname, int* param) {
            var _F = _GetProc<GLNativeDelegate.FNglGetVertexArrayiv>("glGetVertexArrayiv");
            _F(vaobj, pname, param);
        }
        /// <summary>
        /// <para>
        /// retrieve parameters of an attribute of a vertex array
        /// object
        /// </para>
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetVertexArrayIndexediv(GLuint vaobj, GLuint index, GLenum pname, GLint * param);</para>
        /// </summary>
        public unsafe static void glGetVertexArrayIndexediv(uint vaobj, uint index, uint pname, int* param) {
            var _F = _GetProc<GLNativeDelegate.FNglGetVertexArrayIndexediv>("glGetVertexArrayIndexediv");
            _F(vaobj, index, pname, param);
        }
        /// <summary>
        /// <para>
        /// retrieve parameters of an attribute of a vertex array
        /// object
        /// </para>
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetVertexArrayIndexed64iv(GLuint vaobj, GLuint index, GLenum pname, GLint64 * param);</para>
        /// </summary>
        public unsafe static void glGetVertexArrayIndexed64iv(uint vaobj, uint index, uint pname, UInt64* param) {
            var _F = _GetProc<GLNativeDelegate.FNglGetVertexArrayIndexed64iv>("glGetVertexArrayIndexed64iv");
            _F(vaobj, index, pname, param);
        }
        /// <summary>
        /// create sampler objects
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glCreateSamplers(GLsizei n, GLuint * samplers);</para>
        /// </summary>
        public unsafe static void glCreateSamplers(int n, uint* samplers) {
            var _F = _GetProc<GLNativeDelegate.FNglCreateSamplers>("glCreateSamplers");
            _F(n, samplers);
        }
        /// <summary>
        /// create program pipeline objects
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glCreateProgramPipelines(GLsizei n, GLuint * pipelines);</para>
        /// </summary>
        public unsafe static void glCreateProgramPipelines(int n, uint* pipelines) {
            var _F = _GetProc<GLNativeDelegate.FNglCreateProgramPipelines>("glCreateProgramPipelines");
            _F(n, pipelines);
        }
        /// <summary>
        /// create query objects
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glCreateQueries(GLenum target, GLsizei n, GLuint * ids);</para>
        /// </summary>
        public unsafe static void glCreateQueries(uint target, int n, uint* ids) {
            var _F = _GetProc<GLNativeDelegate.FNglCreateQueries>("glCreateQueries");
            _F(target, n, ids);
        }
        /// <summary>
        /// return parameters of a query object
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetQueryBufferObjecti64v(GLuint id, GLuint buffer, GLenum pname, GLintptr offset);</para>
        /// </summary>
        public static void glGetQueryBufferObjecti64v(uint id, uint buffer, uint pname, IntPtr offset) {
            var _F = _GetProc<GLNativeDelegate.FNglGetQueryBufferObjecti64v>("glGetQueryBufferObjecti64v");
            _F(id, buffer, pname, offset);
        }
        /// <summary>
        /// return parameters of a query object
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetQueryBufferObjectiv(GLuint id, GLuint buffer, GLenum pname, GLintptr offset);</para>
        /// </summary>
        public static void glGetQueryBufferObjectiv(uint id, uint buffer, uint pname, IntPtr offset) {
            var _F = _GetProc<GLNativeDelegate.FNglGetQueryBufferObjectiv>("glGetQueryBufferObjectiv");
            _F(id, buffer, pname, offset);
        }
        /// <summary>
        /// return parameters of a query object
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetQueryBufferObjectui64v(GLuint id, GLuint buffer, GLenum pname, GLintptr offset);</para>
        /// </summary>
        public static void glGetQueryBufferObjectui64v(uint id, uint buffer, uint pname, IntPtr offset) {
            var _F = _GetProc<GLNativeDelegate.FNglGetQueryBufferObjectui64v>("glGetQueryBufferObjectui64v");
            _F(id, buffer, pname, offset);
        }
        /// <summary>
        /// return parameters of a query object
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_direct_state_access</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetQueryBufferObjectuiv(GLuint id, GLuint buffer, GLenum pname, GLintptr offset);</para>
        /// </summary>
        public static void glGetQueryBufferObjectuiv(uint id, uint buffer, uint pname, IntPtr offset) {
            var _F = _GetProc<GLNativeDelegate.FNglGetQueryBufferObjectuiv>("glGetQueryBufferObjectuiv");
            _F(id, buffer, pname, offset);
        }

        #endregion Reuse GL_ARB_direct_state_access

        #region Reuse GL_ARB_ES3_1_compatibility

        /// <summary>
        /// defines a barrier ordering memory transactions
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ES_VERSION_3_1, GL_ARB_ES3_1_compatibility</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glMemoryBarrierByRegion(GLbitfield barriers);</para>
        /// </summary>
        public static void glMemoryBarrierByRegion(uint barriers) {
            var _F = _GetProc<GLNativeDelegate.FNglMemoryBarrierByRegion>("glMemoryBarrierByRegion");
            _F(barriers);
        }

        #endregion Reuse GL_ARB_ES3_1_compatibility

        #region Reuse GL_ARB_get_texture_sub_image

        /// <summary>
        /// <para>
        /// retrieve a sub-region of a texture image from a texture
        /// object
        /// </para>
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_get_texture_sub_image</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetTextureSubImage(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, GLsizei bufSize, void * pixels);</para>
        /// </summary>
        public unsafe static void glGetTextureSubImage(uint texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, uint format, uint type, int bufSize, void* pixels) {
            var _F = _GetProc<GLNativeDelegate.FNglGetTextureSubImage>("glGetTextureSubImage");
            _F(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, type, bufSize, pixels);
        }
        /// <summary>
        /// <para>
        /// retrieve a sub-region of a compressed texture image from a
        /// compressed texture object
        /// </para>
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_get_texture_sub_image</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetCompressedTextureSubImage(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLsizei bufSize, void * pixels);</para>
        /// </summary>
        public unsafe static void glGetCompressedTextureSubImage(uint texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, int bufSize, void* pixels) {
            var _F = _GetProc<GLNativeDelegate.FNglGetCompressedTextureSubImage>("glGetCompressedTextureSubImage");
            _F(texture, level, xoffset, yoffset, zoffset, width, height, depth, bufSize, pixels);
        }

        #endregion Reuse GL_ARB_get_texture_sub_image

        #region Reuse GL_ARB_robustness

        /// <summary>
        /// check if the rendering context has not been lost due to software or hardware issues
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ES_VERSION_3_2, GL_SC_VERSION_2_0, GL_KHR_robustness</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>GLenum glGetGraphicsResetStatus();</para>
        /// </summary>
        public static uint glGetGraphicsResetStatus() {
            var _F = _GetProc<GLNativeDelegate.FNglGetGraphicsResetStatus>("glGetGraphicsResetStatus");
            return _F();
        }
        /// <summary>
        /// return a compressed texture image
        /// <para>Require:</para> <para>GL_VERSION_4_5</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glGetnCompressedTexImage(GLenum target, GLint level, GLsizei bufSize, void * pixels);</para>
        /// </summary>
        public unsafe static void glGetnCompressedTexImage(uint target, int level, int bufSize, void* pixels) {
            var _F = _GetProc<GLNativeDelegate.FNglGetnCompressedTexImage>("glGetnCompressedTexImage");
            _F(target, level, bufSize, pixels);
        }
        /// <summary>
        /// return a texture image
        /// <para>Require:</para> <para>GL_VERSION_4_5</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glGetnTexImage(GLenum target, GLint level, GLenum format, GLenum type, GLsizei bufSize, void * pixels);</para>
        /// </summary>
        public unsafe static void glGetnTexImage(uint target, int level, uint format, uint type, int bufSize, void* pixels) {
            var _F = _GetProc<GLNativeDelegate.FNglGetnTexImage>("glGetnTexImage");
            _F(target, level, format, type, bufSize, pixels);
        }
        /// <summary>
        /// Returns the value of a uniform variable
        /// <para>Require:</para> <para>GL_VERSION_4_5</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glGetnUniformdv(GLuint program, GLint location, GLsizei bufSize, GLdouble * params);</para>
        /// </summary>
        public unsafe static void glGetnUniformdv(uint program, int location, int bufSize, double* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetnUniformdv>("glGetnUniformdv");
            _F(program, location, bufSize, ps);
        }
        /// <summary>
        /// Returns the value of a uniform variable
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ES_VERSION_3_2, GL_SC_VERSION_2_0, GL_KHR_robustness</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glGetnUniformfv(GLuint program, GLint location, GLsizei bufSize, GLfloat * params);</para>
        /// </summary>
        public unsafe static void glGetnUniformfv(uint program, int location, int bufSize, float* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetnUniformfv>("glGetnUniformfv");
            _F(program, location, bufSize, ps);
        }
        /// <summary>
        /// Returns the value of a uniform variable
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ES_VERSION_3_2, GL_SC_VERSION_2_0, GL_KHR_robustness</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glGetnUniformiv(GLuint program, GLint location, GLsizei bufSize, GLint * params);</para>
        /// </summary>
        public unsafe static void glGetnUniformiv(uint program, int location, int bufSize, int* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetnUniformiv>("glGetnUniformiv");
            _F(program, location, bufSize, ps);
        }
        /// <summary>
        /// Returns the value of a uniform variable
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ES_VERSION_3_2, GL_KHR_robustness</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glGetnUniformuiv(GLuint program, GLint location, GLsizei bufSize, GLuint * params);</para>
        /// </summary>
        public unsafe static void glGetnUniformuiv(uint program, int location, int bufSize, uint* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetnUniformuiv>("glGetnUniformuiv");
            _F(program, location, bufSize, ps);
        }
        /// <summary>
        /// read a block of pixels from the frame buffer
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ES_VERSION_3_2, GL_SC_VERSION_2_0, GL_KHR_robustness</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glReadnPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLsizei bufSize, void * data);</para>
        /// </summary>
        public unsafe static void glReadnPixels(int x, int y, int width, int height, uint format, uint type, int bufSize, void* data) {
            var _F = _GetProc<GLNativeDelegate.FNglReadnPixels>("glReadnPixels");
            _F(x, y, width, height, format, type, bufSize, data);
        }

        #endregion Reuse GL_ARB_robustness

        #region Reuse GL_ARB_robustness

        /// <summary>
        /// <para>Require:</para> <para>GL_VERSION_4_5</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glGetnMapdv(GLenum target, GLenum query, GLsizei bufSize, GLdouble * v);</para>
        /// </summary>
        public unsafe static void glGetnMapdv(uint target, uint query, int bufSize, double* v) {
            var _F = _GetProc<GLNativeDelegate.FNglGetnMapdv>("glGetnMapdv");
            _F(target, query, bufSize, v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_VERSION_4_5</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glGetnMapfv(GLenum target, GLenum query, GLsizei bufSize, GLfloat * v);</para>
        /// </summary>
        public unsafe static void glGetnMapfv(uint target, uint query, int bufSize, float* v) {
            var _F = _GetProc<GLNativeDelegate.FNglGetnMapfv>("glGetnMapfv");
            _F(target, query, bufSize, v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_VERSION_4_5</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glGetnMapiv(GLenum target, GLenum query, GLsizei bufSize, GLint * v);</para>
        /// </summary>
        public unsafe static void glGetnMapiv(uint target, uint query, int bufSize, int* v) {
            var _F = _GetProc<GLNativeDelegate.FNglGetnMapiv>("glGetnMapiv");
            _F(target, query, bufSize, v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_VERSION_4_5</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glGetnPixelMapfv(GLenum map, GLsizei bufSize, GLfloat * values);</para>
        /// </summary>
        public unsafe static void glGetnPixelMapfv(uint map, int bufSize, float* values) {
            var _F = _GetProc<GLNativeDelegate.FNglGetnPixelMapfv>("glGetnPixelMapfv");
            _F(map, bufSize, values);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_VERSION_4_5</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glGetnPixelMapuiv(GLenum map, GLsizei bufSize, GLuint * values);</para>
        /// </summary>
        public unsafe static void glGetnPixelMapuiv(uint map, int bufSize, uint* values) {
            var _F = _GetProc<GLNativeDelegate.FNglGetnPixelMapuiv>("glGetnPixelMapuiv");
            _F(map, bufSize, values);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_VERSION_4_5</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glGetnPixelMapusv(GLenum map, GLsizei bufSize, GLushort * values);</para>
        /// </summary>
        public unsafe static void glGetnPixelMapusv(uint map, int bufSize, ushort* values) {
            var _F = _GetProc<GLNativeDelegate.FNglGetnPixelMapusv>("glGetnPixelMapusv");
            _F(map, bufSize, values);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_VERSION_4_5</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glGetnPolygonStipple(GLsizei bufSize, GLubyte * pattern);</para>
        /// </summary>
        public unsafe static void glGetnPolygonStipple(int bufSize, byte* pattern) {
            var _F = _GetProc<GLNativeDelegate.FNglGetnPolygonStipple>("glGetnPolygonStipple");
            _F(bufSize, pattern);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_VERSION_4_5</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glGetnColorTable(GLenum target, GLenum format, GLenum type, GLsizei bufSize, void * table);</para>
        /// </summary>
        public unsafe static void glGetnColorTable(uint target, uint format, uint type, int bufSize, void* table) {
            var _F = _GetProc<GLNativeDelegate.FNglGetnColorTable>("glGetnColorTable");
            _F(target, format, type, bufSize, table);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_VERSION_4_5</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glGetnConvolutionFilter(GLenum target, GLenum format, GLenum type, GLsizei bufSize, void * image);</para>
        /// </summary>
        public unsafe static void glGetnConvolutionFilter(uint target, uint format, uint type, int bufSize, void* image) {
            var _F = _GetProc<GLNativeDelegate.FNglGetnConvolutionFilter>("glGetnConvolutionFilter");
            _F(target, format, type, bufSize, image);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_VERSION_4_5</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glGetnSeparableFilter(GLenum target, GLenum format, GLenum type, GLsizei rowBufSize, void * row, GLsizei columnBufSize, void * column, void * span);</para>
        /// </summary>
        public unsafe static void glGetnSeparableFilter(uint target, uint format, uint type, int rowBufSize, void* row, int columnBufSize, void* column, void* span) {
            var _F = _GetProc<GLNativeDelegate.FNglGetnSeparableFilter>("glGetnSeparableFilter");
            _F(target, format, type, rowBufSize, row, columnBufSize, column, span);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_VERSION_4_5</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glGetnHistogram(GLenum target, GLboolean reset, GLenum format, GLenum type, GLsizei bufSize, void * values);</para>
        /// </summary>
        public unsafe static void glGetnHistogram(uint target, bool reset, uint format, uint type, int bufSize, void* values) {
            var _F = _GetProc<GLNativeDelegate.FNglGetnHistogram>("glGetnHistogram");
            _F(target, reset, format, type, bufSize, values);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_VERSION_4_5</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glGetnMinmax(GLenum target, GLboolean reset, GLenum format, GLenum type, GLsizei bufSize, void * values);</para>
        /// </summary>
        public unsafe static void glGetnMinmax(uint target, bool reset, uint format, uint type, int bufSize, void* values) {
            var _F = _GetProc<GLNativeDelegate.FNglGetnMinmax>("glGetnMinmax");
            _F(target, reset, format, type, bufSize, values);
        }

        #endregion Reuse GL_ARB_robustness

        #region Reuse GL_ARB_texture_barrier

        /// <summary>
        /// controls the ordering of reads and writes to rendered fragments across drawing commands
        /// <para>Require:</para> <para>GL_VERSION_4_5, GL_ARB_texture_barrier</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glTextureBarrier();</para>
        /// </summary>
        public static void glTextureBarrier() {
            var _F = _GetProc<GLNativeDelegate.FNglTextureBarrier>("glTextureBarrier");
            _F();
        }

        #endregion Reuse GL_ARB_texture_barrier

        #endregion GL_VERSION_4_5

        #region GL_VERSION_4_6


        #region Reuse GL_ARB_gl_spirv

        /// <summary>
        /// <para>Require:</para> <para>GL_VERSION_4_6</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glSpecializeShader(GLuint shader, const GLchar * pEntryPoint, GLuint numSpecializationConstants, const GLuint * pConstantIndex, const GLuint * pConstantValue);</para>
        /// </summary>
        public unsafe static void glSpecializeShader(uint shader, byte* pEntryPoint, uint numSpecializationConstants, uint* pConstantIndex, uint* pConstantValue) {
            var _F = _GetProc<GLNativeDelegate.FNglSpecializeShader>("glSpecializeShader");
            _F(shader, pEntryPoint, numSpecializationConstants, pConstantIndex, pConstantValue);
        }

        #endregion Reuse GL_ARB_gl_spirv

        #region Reuse GL_ARB_indirect_parameters

        /// <summary>
        /// <para>Require:</para> <para>GL_VERSION_4_6</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glMultiDrawArraysIndirectCount(GLenum mode, const void * indirect, GLintptr drawcount, GLsizei maxdrawcount, GLsizei stride);</para>
        /// </summary>
        public unsafe static void glMultiDrawArraysIndirectCount(uint mode, void* indirect, IntPtr drawcount, int maxdrawcount, int stride) {
            var _F = _GetProc<GLNativeDelegate.FNglMultiDrawArraysIndirectCount>("glMultiDrawArraysIndirectCount");
            _F(mode, indirect, drawcount, maxdrawcount, stride);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_VERSION_4_6</para>
        /// Supported: <para>GL</para>
        /// Original: <para>void glMultiDrawElementsIndirectCount(GLenum mode, GLenum type, const void * indirect, GLintptr drawcount, GLsizei maxdrawcount, GLsizei stride);</para>
        /// </summary>
        public unsafe static void glMultiDrawElementsIndirectCount(uint mode, uint type, void* indirect, IntPtr drawcount, int maxdrawcount, int stride) {
            var _F = _GetProc<GLNativeDelegate.FNglMultiDrawElementsIndirectCount>("glMultiDrawElementsIndirectCount");
            _F(mode, type, indirect, drawcount, maxdrawcount, stride);
        }

        #endregion Reuse GL_ARB_indirect_parameters

        #region Reuse GL_ARB_polygon_offset_clamp

        /// <summary>
        /// <para>Require:</para> <para>GL_VERSION_4_6, GL_ARB_polygon_offset_clamp</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glPolygonOffsetClamp(GLfloat factor, GLfloat units, GLfloat clamp);</para>
        /// </summary>
        public static void glPolygonOffsetClamp(float factor, float units, float clamp) {
            var _F = _GetProc<GLNativeDelegate.FNglPolygonOffsetClamp>("glPolygonOffsetClamp");
            _F(factor, units, clamp);
        }

        #endregion Reuse GL_ARB_polygon_offset_clamp

        #endregion GL_VERSION_4_6

        #region GL_3DFX_tbuffer

        /// <summary>
        /// <para>Require:</para> <para>GL_3DFX_tbuffer</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glTbufferMask3DFX(GLuint mask);</para>
        /// </summary>
        public static void glTbufferMask3DFX(uint mask) {
            var _F = _GetProc<GLNativeDelegate.FNglTbufferMask3DFX>("glTbufferMask3DFX");
            _F(mask);
        }

        #endregion GL_3DFX_tbuffer

        #region GL_AMD_debug_output

        /// <summary>
        /// <para>Require:</para> <para>GL_AMD_debug_output</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glDebugMessageEnableAMD(GLenum category, GLenum severity, GLsizei count, const GLuint * ids, GLboolean enabled);</para>
        /// </summary>
        public unsafe static void glDebugMessageEnableAMD(uint category, uint severity, int count, uint* ids, bool enabled) {
            var _F = _GetProc<GLNativeDelegate.FNglDebugMessageEnableAMD>("glDebugMessageEnableAMD");
            _F(category, severity, count, ids, enabled);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_AMD_debug_output</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glDebugMessageInsertAMD(GLenum category, GLenum severity, GLuint id, GLsizei length, const GLchar * buf);</para>
        /// </summary>
        public unsafe static void glDebugMessageInsertAMD(uint category, uint severity, uint id, int length, byte* buf) {
            var _F = _GetProc<GLNativeDelegate.FNglDebugMessageInsertAMD>("glDebugMessageInsertAMD");
            _F(category, severity, id, length, buf);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_AMD_debug_output</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glDebugMessageCallbackAMD(GLDEBUGPROCAMD callback, void * userParam);</para>
        /// </summary>
        public unsafe static void glDebugMessageCallbackAMD(GLNativeDelegate.GLDEBUGPROCAMD callback, void* userParam) {
            var _F = _GetProc<GLNativeDelegate.FNglDebugMessageCallbackAMD>("glDebugMessageCallbackAMD");
            _F(callback, userParam);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_AMD_debug_output</para>
        /// Supported: <para>gl</para>
        /// Original: <para>GLuint glGetDebugMessageLogAMD(GLuint count, GLsizei bufSize, GLenum * categories, GLuint * severities, GLuint * ids, GLsizei * lengths, GLchar * message);</para>
        /// </summary>
        public unsafe static uint glGetDebugMessageLogAMD(uint count, int bufSize, uint* categories, uint* severities, uint* ids, int* lengths, byte* message) {
            var _F = _GetProc<GLNativeDelegate.FNglGetDebugMessageLogAMD>("glGetDebugMessageLogAMD");
            return _F(count, bufSize, categories, severities, ids, lengths, message);
        }

        #endregion GL_AMD_debug_output

        #region GL_AMD_draw_buffers_blend

        /// <summary>
        /// <para>Require:</para> <para>GL_AMD_draw_buffers_blend</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glBlendFuncIndexedAMD(GLuint buf, GLenum src, GLenum dst);</para>
        /// </summary>
        public static void glBlendFuncIndexedAMD(uint buf, uint src, uint dst) {
            var _F = _GetProc<GLNativeDelegate.FNglBlendFuncIndexedAMD>("glBlendFuncIndexedAMD");
            _F(buf, src, dst);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_AMD_draw_buffers_blend</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glBlendFuncSeparateIndexedAMD(GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha);</para>
        /// </summary>
        public static void glBlendFuncSeparateIndexedAMD(uint buf, uint srcRGB, uint dstRGB, uint srcAlpha, uint dstAlpha) {
            var _F = _GetProc<GLNativeDelegate.FNglBlendFuncSeparateIndexedAMD>("glBlendFuncSeparateIndexedAMD");
            _F(buf, srcRGB, dstRGB, srcAlpha, dstAlpha);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_AMD_draw_buffers_blend</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glBlendEquationIndexedAMD(GLuint buf, GLenum mode);</para>
        /// </summary>
        public static void glBlendEquationIndexedAMD(uint buf, uint mode) {
            var _F = _GetProc<GLNativeDelegate.FNglBlendEquationIndexedAMD>("glBlendEquationIndexedAMD");
            _F(buf, mode);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_AMD_draw_buffers_blend</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glBlendEquationSeparateIndexedAMD(GLuint buf, GLenum modeRGB, GLenum modeAlpha);</para>
        /// </summary>
        public static void glBlendEquationSeparateIndexedAMD(uint buf, uint modeRGB, uint modeAlpha) {
            var _F = _GetProc<GLNativeDelegate.FNglBlendEquationSeparateIndexedAMD>("glBlendEquationSeparateIndexedAMD");
            _F(buf, modeRGB, modeAlpha);
        }

        #endregion GL_AMD_draw_buffers_blend

        #region GL_AMD_framebuffer_multisample_advanced

        /// <summary>
        /// <para>Require:</para> <para>GL_AMD_framebuffer_multisample_advanced</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glRenderbufferStorageMultisampleAdvancedAMD(GLenum target, GLsizei samples, GLsizei storageSamples, GLenum internalformat, GLsizei width, GLsizei height);</para>
        /// </summary>
        public static void glRenderbufferStorageMultisampleAdvancedAMD(uint target, int samples, int storageSamples, uint internalformat, int width, int height) {
            var _F = _GetProc<GLNativeDelegate.FNglRenderbufferStorageMultisampleAdvancedAMD>("glRenderbufferStorageMultisampleAdvancedAMD");
            _F(target, samples, storageSamples, internalformat, width, height);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_AMD_framebuffer_multisample_advanced</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glNamedRenderbufferStorageMultisampleAdvancedAMD(GLuint renderbuffer, GLsizei samples, GLsizei storageSamples, GLenum internalformat, GLsizei width, GLsizei height);</para>
        /// </summary>
        public static void glNamedRenderbufferStorageMultisampleAdvancedAMD(uint renderbuffer, int samples, int storageSamples, uint internalformat, int width, int height) {
            var _F = _GetProc<GLNativeDelegate.FNglNamedRenderbufferStorageMultisampleAdvancedAMD>("glNamedRenderbufferStorageMultisampleAdvancedAMD");
            _F(renderbuffer, samples, storageSamples, internalformat, width, height);
        }

        #endregion GL_AMD_framebuffer_multisample_advanced

        #region GL_AMD_framebuffer_sample_positions

        /// <summary>
        /// <para>Require:</para> <para>GL_AMD_framebuffer_sample_positions</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glFramebufferSamplePositionsfvAMD(GLenum target, GLuint numsamples, GLuint pixelindex, const GLfloat * values);</para>
        /// </summary>
        public unsafe static void glFramebufferSamplePositionsfvAMD(uint target, uint numsamples, uint pixelindex, float* values) {
            var _F = _GetProc<GLNativeDelegate.FNglFramebufferSamplePositionsfvAMD>("glFramebufferSamplePositionsfvAMD");
            _F(target, numsamples, pixelindex, values);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_AMD_framebuffer_sample_positions</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glNamedFramebufferSamplePositionsfvAMD(GLuint framebuffer, GLuint numsamples, GLuint pixelindex, const GLfloat * values);</para>
        /// </summary>
        public unsafe static void glNamedFramebufferSamplePositionsfvAMD(uint framebuffer, uint numsamples, uint pixelindex, float* values) {
            var _F = _GetProc<GLNativeDelegate.FNglNamedFramebufferSamplePositionsfvAMD>("glNamedFramebufferSamplePositionsfvAMD");
            _F(framebuffer, numsamples, pixelindex, values);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_AMD_framebuffer_sample_positions</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetFramebufferParameterfvAMD(GLenum target, GLenum pname, GLuint numsamples, GLuint pixelindex, GLsizei size, GLfloat * values);</para>
        /// </summary>
        public unsafe static void glGetFramebufferParameterfvAMD(uint target, uint pname, uint numsamples, uint pixelindex, int size, float* values) {
            var _F = _GetProc<GLNativeDelegate.FNglGetFramebufferParameterfvAMD>("glGetFramebufferParameterfvAMD");
            _F(target, pname, numsamples, pixelindex, size, values);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_AMD_framebuffer_sample_positions</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetNamedFramebufferParameterfvAMD(GLuint framebuffer, GLenum pname, GLuint numsamples, GLuint pixelindex, GLsizei size, GLfloat * values);</para>
        /// </summary>
        public unsafe static void glGetNamedFramebufferParameterfvAMD(uint framebuffer, uint pname, uint numsamples, uint pixelindex, int size, float* values) {
            var _F = _GetProc<GLNativeDelegate.FNglGetNamedFramebufferParameterfvAMD>("glGetNamedFramebufferParameterfvAMD");
            _F(framebuffer, pname, numsamples, pixelindex, size, values);
        }

        #endregion GL_AMD_framebuffer_sample_positions

        #region GL_AMD_gpu_shader_int64

        /// <summary>
        /// <para>Require:</para> <para>GL_AMD_gpu_shader_int64, GL_NV_gpu_shader5</para>
        /// Supported: <para>gl, gl, glcore, gles2</para>
        /// Original: <para>void glUniform1i64NV(GLint location, GLint64EXT x);</para>
        /// </summary>
        public static void glUniform1i64NV(int location, Int64 x) {
            var _F = _GetProc<GLNativeDelegate.FNglUniform1i64NV>("glUniform1i64NV");
            _F(location, x);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_AMD_gpu_shader_int64, GL_NV_gpu_shader5</para>
        /// Supported: <para>gl, gl, glcore, gles2</para>
        /// Original: <para>void glUniform2i64NV(GLint location, GLint64EXT x, GLint64EXT y);</para>
        /// </summary>
        public static void glUniform2i64NV(int location, Int64 x, Int64 y) {
            var _F = _GetProc<GLNativeDelegate.FNglUniform2i64NV>("glUniform2i64NV");
            _F(location, x, y);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_AMD_gpu_shader_int64, GL_NV_gpu_shader5</para>
        /// Supported: <para>gl, gl, glcore, gles2</para>
        /// Original: <para>void glUniform3i64NV(GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z);</para>
        /// </summary>
        public static void glUniform3i64NV(int location, Int64 x, Int64 y, Int64 z) {
            var _F = _GetProc<GLNativeDelegate.FNglUniform3i64NV>("glUniform3i64NV");
            _F(location, x, y, z);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_AMD_gpu_shader_int64, GL_NV_gpu_shader5</para>
        /// Supported: <para>gl, gl, glcore, gles2</para>
        /// Original: <para>void glUniform4i64NV(GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z, GLint64EXT w);</para>
        /// </summary>
        public static void glUniform4i64NV(int location, Int64 x, Int64 y, Int64 z, Int64 w) {
            var _F = _GetProc<GLNativeDelegate.FNglUniform4i64NV>("glUniform4i64NV");
            _F(location, x, y, z, w);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_AMD_gpu_shader_int64, GL_NV_gpu_shader5</para>
        /// Supported: <para>gl, gl, glcore, gles2</para>
        /// Original: <para>void glUniform1i64vNV(GLint location, GLsizei count, const GLint64EXT * value);</para>
        /// </summary>
        public unsafe static void glUniform1i64vNV(int location, int count, Int64* value) {
            var _F = _GetProc<GLNativeDelegate.FNglUniform1i64vNV>("glUniform1i64vNV");
            _F(location, count, value);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_AMD_gpu_shader_int64, GL_NV_gpu_shader5</para>
        /// Supported: <para>gl, gl, glcore, gles2</para>
        /// Original: <para>void glUniform2i64vNV(GLint location, GLsizei count, const GLint64EXT * value);</para>
        /// </summary>
        public unsafe static void glUniform2i64vNV(int location, int count, Int64* value) {
            var _F = _GetProc<GLNativeDelegate.FNglUniform2i64vNV>("glUniform2i64vNV");
            _F(location, count, value);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_AMD_gpu_shader_int64, GL_NV_gpu_shader5</para>
        /// Supported: <para>gl, gl, glcore, gles2</para>
        /// Original: <para>void glUniform3i64vNV(GLint location, GLsizei count, const GLint64EXT * value);</para>
        /// </summary>
        public unsafe static void glUniform3i64vNV(int location, int count, Int64* value) {
            var _F = _GetProc<GLNativeDelegate.FNglUniform3i64vNV>("glUniform3i64vNV");
            _F(location, count, value);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_AMD_gpu_shader_int64, GL_NV_gpu_shader5</para>
        /// Supported: <para>gl, gl, glcore, gles2</para>
        /// Original: <para>void glUniform4i64vNV(GLint location, GLsizei count, const GLint64EXT * value);</para>
        /// </summary>
        public unsafe static void glUniform4i64vNV(int location, int count, Int64* value) {
            var _F = _GetProc<GLNativeDelegate.FNglUniform4i64vNV>("glUniform4i64vNV");
            _F(location, count, value);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_AMD_gpu_shader_int64, GL_NV_gpu_shader5</para>
        /// Supported: <para>gl, gl, glcore, gles2</para>
        /// Original: <para>void glUniform1ui64NV(GLint location, GLuint64EXT x);</para>
        /// </summary>
        public static void glUniform1ui64NV(int location, UInt64 x) {
            var _F = _GetProc<GLNativeDelegate.FNglUniform1ui64NV>("glUniform1ui64NV");
            _F(location, x);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_AMD_gpu_shader_int64, GL_NV_gpu_shader5</para>
        /// Supported: <para>gl, gl, glcore, gles2</para>
        /// Original: <para>void glUniform2ui64NV(GLint location, GLuint64EXT x, GLuint64EXT y);</para>
        /// </summary>
        public static void glUniform2ui64NV(int location, UInt64 x, UInt64 y) {
            var _F = _GetProc<GLNativeDelegate.FNglUniform2ui64NV>("glUniform2ui64NV");
            _F(location, x, y);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_AMD_gpu_shader_int64, GL_NV_gpu_shader5</para>
        /// Supported: <para>gl, gl, glcore, gles2</para>
        /// Original: <para>void glUniform3ui64NV(GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z);</para>
        /// </summary>
        public static void glUniform3ui64NV(int location, UInt64 x, UInt64 y, UInt64 z) {
            var _F = _GetProc<GLNativeDelegate.FNglUniform3ui64NV>("glUniform3ui64NV");
            _F(location, x, y, z);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_AMD_gpu_shader_int64, GL_NV_gpu_shader5</para>
        /// Supported: <para>gl, gl, glcore, gles2</para>
        /// Original: <para>void glUniform4ui64NV(GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z, GLuint64EXT w);</para>
        /// </summary>
        public static void glUniform4ui64NV(int location, UInt64 x, UInt64 y, UInt64 z, UInt64 w) {
            var _F = _GetProc<GLNativeDelegate.FNglUniform4ui64NV>("glUniform4ui64NV");
            _F(location, x, y, z, w);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_AMD_gpu_shader_int64, GL_NV_gpu_shader5</para>
        /// Supported: <para>gl, gl, glcore, gles2</para>
        /// Original: <para>void glUniform1ui64vNV(GLint location, GLsizei count, const GLuint64EXT * value);</para>
        /// </summary>
        public unsafe static void glUniform1ui64vNV(int location, int count, UInt64* value) {
            var _F = _GetProc<GLNativeDelegate.FNglUniform1ui64vNV>("glUniform1ui64vNV");
            _F(location, count, value);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_AMD_gpu_shader_int64, GL_NV_gpu_shader5</para>
        /// Supported: <para>gl, gl, glcore, gles2</para>
        /// Original: <para>void glUniform2ui64vNV(GLint location, GLsizei count, const GLuint64EXT * value);</para>
        /// </summary>
        public unsafe static void glUniform2ui64vNV(int location, int count, UInt64* value) {
            var _F = _GetProc<GLNativeDelegate.FNglUniform2ui64vNV>("glUniform2ui64vNV");
            _F(location, count, value);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_AMD_gpu_shader_int64, GL_NV_gpu_shader5</para>
        /// Supported: <para>gl, gl, glcore, gles2</para>
        /// Original: <para>void glUniform3ui64vNV(GLint location, GLsizei count, const GLuint64EXT * value);</para>
        /// </summary>
        public unsafe static void glUniform3ui64vNV(int location, int count, UInt64* value) {
            var _F = _GetProc<GLNativeDelegate.FNglUniform3ui64vNV>("glUniform3ui64vNV");
            _F(location, count, value);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_AMD_gpu_shader_int64, GL_NV_gpu_shader5</para>
        /// Supported: <para>gl, gl, glcore, gles2</para>
        /// Original: <para>void glUniform4ui64vNV(GLint location, GLsizei count, const GLuint64EXT * value);</para>
        /// </summary>
        public unsafe static void glUniform4ui64vNV(int location, int count, UInt64* value) {
            var _F = _GetProc<GLNativeDelegate.FNglUniform4ui64vNV>("glUniform4ui64vNV");
            _F(location, count, value);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_AMD_gpu_shader_int64, GL_NV_gpu_shader5</para>
        /// Supported: <para>gl, gl, glcore, gles2</para>
        /// Original: <para>void glGetUniformi64vNV(GLuint program, GLint location, GLint64EXT * params);</para>
        /// </summary>
        public unsafe static void glGetUniformi64vNV(uint program, int location, Int64* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetUniformi64vNV>("glGetUniformi64vNV");
            _F(program, location, ps);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_AMD_gpu_shader_int64, GL_NV_shader_buffer_load</para>
        /// Supported: <para>gl, gl, glcore</para>
        /// Original: <para>void glGetUniformui64vNV(GLuint program, GLint location, GLuint64EXT * params);</para>
        /// </summary>
        public unsafe static void glGetUniformui64vNV(uint program, int location, UInt64* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetUniformui64vNV>("glGetUniformui64vNV");
            _F(program, location, ps);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_AMD_gpu_shader_int64, GL_NV_gpu_shader5</para>
        /// Supported: <para>gl, gl, glcore, gles2</para>
        /// Original: <para>void glProgramUniform1i64NV(GLuint program, GLint location, GLint64EXT x);</para>
        /// </summary>
        public static void glProgramUniform1i64NV(uint program, int location, Int64 x) {
            var _F = _GetProc<GLNativeDelegate.FNglProgramUniform1i64NV>("glProgramUniform1i64NV");
            _F(program, location, x);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_AMD_gpu_shader_int64, GL_NV_gpu_shader5</para>
        /// Supported: <para>gl, gl, glcore, gles2</para>
        /// Original: <para>void glProgramUniform2i64NV(GLuint program, GLint location, GLint64EXT x, GLint64EXT y);</para>
        /// </summary>
        public static void glProgramUniform2i64NV(uint program, int location, Int64 x, Int64 y) {
            var _F = _GetProc<GLNativeDelegate.FNglProgramUniform2i64NV>("glProgramUniform2i64NV");
            _F(program, location, x, y);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_AMD_gpu_shader_int64, GL_NV_gpu_shader5</para>
        /// Supported: <para>gl, gl, glcore, gles2</para>
        /// Original: <para>void glProgramUniform3i64NV(GLuint program, GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z);</para>
        /// </summary>
        public static void glProgramUniform3i64NV(uint program, int location, Int64 x, Int64 y, Int64 z) {
            var _F = _GetProc<GLNativeDelegate.FNglProgramUniform3i64NV>("glProgramUniform3i64NV");
            _F(program, location, x, y, z);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_AMD_gpu_shader_int64, GL_NV_gpu_shader5</para>
        /// Supported: <para>gl, gl, glcore, gles2</para>
        /// Original: <para>void glProgramUniform4i64NV(GLuint program, GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z, GLint64EXT w);</para>
        /// </summary>
        public static void glProgramUniform4i64NV(uint program, int location, Int64 x, Int64 y, Int64 z, Int64 w) {
            var _F = _GetProc<GLNativeDelegate.FNglProgramUniform4i64NV>("glProgramUniform4i64NV");
            _F(program, location, x, y, z, w);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_AMD_gpu_shader_int64, GL_NV_gpu_shader5</para>
        /// Supported: <para>gl, gl, glcore, gles2</para>
        /// Original: <para>void glProgramUniform1i64vNV(GLuint program, GLint location, GLsizei count, const GLint64EXT * value);</para>
        /// </summary>
        public unsafe static void glProgramUniform1i64vNV(uint program, int location, int count, Int64* value) {
            var _F = _GetProc<GLNativeDelegate.FNglProgramUniform1i64vNV>("glProgramUniform1i64vNV");
            _F(program, location, count, value);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_AMD_gpu_shader_int64, GL_NV_gpu_shader5</para>
        /// Supported: <para>gl, gl, glcore, gles2</para>
        /// Original: <para>void glProgramUniform2i64vNV(GLuint program, GLint location, GLsizei count, const GLint64EXT * value);</para>
        /// </summary>
        public unsafe static void glProgramUniform2i64vNV(uint program, int location, int count, Int64* value) {
            var _F = _GetProc<GLNativeDelegate.FNglProgramUniform2i64vNV>("glProgramUniform2i64vNV");
            _F(program, location, count, value);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_AMD_gpu_shader_int64, GL_NV_gpu_shader5</para>
        /// Supported: <para>gl, gl, glcore, gles2</para>
        /// Original: <para>void glProgramUniform3i64vNV(GLuint program, GLint location, GLsizei count, const GLint64EXT * value);</para>
        /// </summary>
        public unsafe static void glProgramUniform3i64vNV(uint program, int location, int count, Int64* value) {
            var _F = _GetProc<GLNativeDelegate.FNglProgramUniform3i64vNV>("glProgramUniform3i64vNV");
            _F(program, location, count, value);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_AMD_gpu_shader_int64, GL_NV_gpu_shader5</para>
        /// Supported: <para>gl, gl, glcore, gles2</para>
        /// Original: <para>void glProgramUniform4i64vNV(GLuint program, GLint location, GLsizei count, const GLint64EXT * value);</para>
        /// </summary>
        public unsafe static void glProgramUniform4i64vNV(uint program, int location, int count, Int64* value) {
            var _F = _GetProc<GLNativeDelegate.FNglProgramUniform4i64vNV>("glProgramUniform4i64vNV");
            _F(program, location, count, value);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_AMD_gpu_shader_int64, GL_NV_gpu_shader5</para>
        /// Supported: <para>gl, gl, glcore, gles2</para>
        /// Original: <para>void glProgramUniform1ui64NV(GLuint program, GLint location, GLuint64EXT x);</para>
        /// </summary>
        public static void glProgramUniform1ui64NV(uint program, int location, UInt64 x) {
            var _F = _GetProc<GLNativeDelegate.FNglProgramUniform1ui64NV>("glProgramUniform1ui64NV");
            _F(program, location, x);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_AMD_gpu_shader_int64, GL_NV_gpu_shader5</para>
        /// Supported: <para>gl, gl, glcore, gles2</para>
        /// Original: <para>void glProgramUniform2ui64NV(GLuint program, GLint location, GLuint64EXT x, GLuint64EXT y);</para>
        /// </summary>
        public static void glProgramUniform2ui64NV(uint program, int location, UInt64 x, UInt64 y) {
            var _F = _GetProc<GLNativeDelegate.FNglProgramUniform2ui64NV>("glProgramUniform2ui64NV");
            _F(program, location, x, y);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_AMD_gpu_shader_int64, GL_NV_gpu_shader5</para>
        /// Supported: <para>gl, gl, glcore, gles2</para>
        /// Original: <para>void glProgramUniform3ui64NV(GLuint program, GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z);</para>
        /// </summary>
        public static void glProgramUniform3ui64NV(uint program, int location, UInt64 x, UInt64 y, UInt64 z) {
            var _F = _GetProc<GLNativeDelegate.FNglProgramUniform3ui64NV>("glProgramUniform3ui64NV");
            _F(program, location, x, y, z);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_AMD_gpu_shader_int64, GL_NV_gpu_shader5</para>
        /// Supported: <para>gl, gl, glcore, gles2</para>
        /// Original: <para>void glProgramUniform4ui64NV(GLuint program, GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z, GLuint64EXT w);</para>
        /// </summary>
        public static void glProgramUniform4ui64NV(uint program, int location, UInt64 x, UInt64 y, UInt64 z, UInt64 w) {
            var _F = _GetProc<GLNativeDelegate.FNglProgramUniform4ui64NV>("glProgramUniform4ui64NV");
            _F(program, location, x, y, z, w);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_AMD_gpu_shader_int64, GL_NV_gpu_shader5</para>
        /// Supported: <para>gl, gl, glcore, gles2</para>
        /// Original: <para>void glProgramUniform1ui64vNV(GLuint program, GLint location, GLsizei count, const GLuint64EXT * value);</para>
        /// </summary>
        public unsafe static void glProgramUniform1ui64vNV(uint program, int location, int count, UInt64* value) {
            var _F = _GetProc<GLNativeDelegate.FNglProgramUniform1ui64vNV>("glProgramUniform1ui64vNV");
            _F(program, location, count, value);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_AMD_gpu_shader_int64, GL_NV_gpu_shader5</para>
        /// Supported: <para>gl, gl, glcore, gles2</para>
        /// Original: <para>void glProgramUniform2ui64vNV(GLuint program, GLint location, GLsizei count, const GLuint64EXT * value);</para>
        /// </summary>
        public unsafe static void glProgramUniform2ui64vNV(uint program, int location, int count, UInt64* value) {
            var _F = _GetProc<GLNativeDelegate.FNglProgramUniform2ui64vNV>("glProgramUniform2ui64vNV");
            _F(program, location, count, value);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_AMD_gpu_shader_int64, GL_NV_gpu_shader5</para>
        /// Supported: <para>gl, gl, glcore, gles2</para>
        /// Original: <para>void glProgramUniform3ui64vNV(GLuint program, GLint location, GLsizei count, const GLuint64EXT * value);</para>
        /// </summary>
        public unsafe static void glProgramUniform3ui64vNV(uint program, int location, int count, UInt64* value) {
            var _F = _GetProc<GLNativeDelegate.FNglProgramUniform3ui64vNV>("glProgramUniform3ui64vNV");
            _F(program, location, count, value);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_AMD_gpu_shader_int64, GL_NV_gpu_shader5</para>
        /// Supported: <para>gl, gl, glcore, gles2</para>
        /// Original: <para>void glProgramUniform4ui64vNV(GLuint program, GLint location, GLsizei count, const GLuint64EXT * value);</para>
        /// </summary>
        public unsafe static void glProgramUniform4ui64vNV(uint program, int location, int count, UInt64* value) {
            var _F = _GetProc<GLNativeDelegate.FNglProgramUniform4ui64vNV>("glProgramUniform4ui64vNV");
            _F(program, location, count, value);
        }

        #endregion GL_AMD_gpu_shader_int64

        #region GL_AMD_interleaved_elements

        /// <summary>
        /// <para>Require:</para> <para>GL_AMD_interleaved_elements</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexAttribParameteriAMD(GLuint index, GLenum pname, GLint param);</para>
        /// </summary>
        public static void glVertexAttribParameteriAMD(uint index, uint pname, int param) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttribParameteriAMD>("glVertexAttribParameteriAMD");
            _F(index, pname, param);
        }

        #endregion GL_AMD_interleaved_elements

        #region GL_AMD_multi_draw_indirect

        /// <summary>
        /// <para>Require:</para> <para>GL_AMD_multi_draw_indirect</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glMultiDrawArraysIndirectAMD(GLenum mode, const void * indirect, GLsizei primcount, GLsizei stride);</para>
        /// </summary>
        public unsafe static void glMultiDrawArraysIndirectAMD(uint mode, void* indirect, int primcount, int stride) {
            var _F = _GetProc<GLNativeDelegate.FNglMultiDrawArraysIndirectAMD>("glMultiDrawArraysIndirectAMD");
            _F(mode, indirect, primcount, stride);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_AMD_multi_draw_indirect</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glMultiDrawElementsIndirectAMD(GLenum mode, GLenum type, const void * indirect, GLsizei primcount, GLsizei stride);</para>
        /// </summary>
        public unsafe static void glMultiDrawElementsIndirectAMD(uint mode, uint type, void* indirect, int primcount, int stride) {
            var _F = _GetProc<GLNativeDelegate.FNglMultiDrawElementsIndirectAMD>("glMultiDrawElementsIndirectAMD");
            _F(mode, type, indirect, primcount, stride);
        }

        #endregion GL_AMD_multi_draw_indirect

        #region GL_AMD_name_gen_delete

        /// <summary>
        /// <para>Require:</para> <para>GL_AMD_name_gen_delete</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGenNamesAMD(GLenum identifier, GLuint num, GLuint * names);</para>
        /// </summary>
        public unsafe static void glGenNamesAMD(uint identifier, uint num, uint* names) {
            var _F = _GetProc<GLNativeDelegate.FNglGenNamesAMD>("glGenNamesAMD");
            _F(identifier, num, names);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_AMD_name_gen_delete</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glDeleteNamesAMD(GLenum identifier, GLuint num, const GLuint * names);</para>
        /// </summary>
        public unsafe static void glDeleteNamesAMD(uint identifier, uint num, uint* names) {
            var _F = _GetProc<GLNativeDelegate.FNglDeleteNamesAMD>("glDeleteNamesAMD");
            _F(identifier, num, names);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_AMD_name_gen_delete</para>
        /// Supported: <para>gl</para>
        /// Original: <para>GLboolean glIsNameAMD(GLenum identifier, GLuint name);</para>
        /// </summary>
        public static bool glIsNameAMD(uint identifier, uint name) {
            var _F = _GetProc<GLNativeDelegate.FNglIsNameAMD>("glIsNameAMD");
            return _F(identifier, name);
        }

        #endregion GL_AMD_name_gen_delete

        #region GL_AMD_occlusion_query_event

        /// <summary>
        /// <para>Require:</para> <para>GL_AMD_occlusion_query_event</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glQueryObjectParameteruiAMD(GLenum target, GLuint id, GLenum pname, GLuint param);</para>
        /// </summary>
        public static void glQueryObjectParameteruiAMD(uint target, uint id, uint pname, uint param) {
            var _F = _GetProc<GLNativeDelegate.FNglQueryObjectParameteruiAMD>("glQueryObjectParameteruiAMD");
            _F(target, id, pname, param);
        }

        #endregion GL_AMD_occlusion_query_event

        #region GL_AMD_performance_monitor

        /// <summary>
        /// <para>Require:</para> <para>GL_AMD_performance_monitor</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glGetPerfMonitorGroupsAMD(GLint * numGroups, GLsizei groupsSize, GLuint * groups);</para>
        /// </summary>
        public unsafe static void glGetPerfMonitorGroupsAMD(int* numGroups, int groupsSize, uint* groups) {
            var _F = _GetProc<GLNativeDelegate.FNglGetPerfMonitorGroupsAMD>("glGetPerfMonitorGroupsAMD");
            _F(numGroups, groupsSize, groups);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_AMD_performance_monitor</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glGetPerfMonitorCountersAMD(GLuint group, GLint * numCounters, GLint * maxActiveCounters, GLsizei counterSize, GLuint * counters);</para>
        /// </summary>
        public unsafe static void glGetPerfMonitorCountersAMD(uint group, int* numCounters, int* maxActiveCounters, int counterSize, uint* counters) {
            var _F = _GetProc<GLNativeDelegate.FNglGetPerfMonitorCountersAMD>("glGetPerfMonitorCountersAMD");
            _F(group, numCounters, maxActiveCounters, counterSize, counters);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_AMD_performance_monitor</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glGetPerfMonitorGroupStringAMD(GLuint group, GLsizei bufSize, GLsizei * length, GLchar * groupString);</para>
        /// </summary>
        public unsafe static void glGetPerfMonitorGroupStringAMD(uint group, int bufSize, int* length, byte* groupString) {
            var _F = _GetProc<GLNativeDelegate.FNglGetPerfMonitorGroupStringAMD>("glGetPerfMonitorGroupStringAMD");
            _F(group, bufSize, length, groupString);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_AMD_performance_monitor</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glGetPerfMonitorCounterStringAMD(GLuint group, GLuint counter, GLsizei bufSize, GLsizei * length, GLchar * counterString);</para>
        /// </summary>
        public unsafe static void glGetPerfMonitorCounterStringAMD(uint group, uint counter, int bufSize, int* length, byte* counterString) {
            var _F = _GetProc<GLNativeDelegate.FNglGetPerfMonitorCounterStringAMD>("glGetPerfMonitorCounterStringAMD");
            _F(group, counter, bufSize, length, counterString);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_AMD_performance_monitor</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glGetPerfMonitorCounterInfoAMD(GLuint group, GLuint counter, GLenum pname, void * data);</para>
        /// </summary>
        public unsafe static void glGetPerfMonitorCounterInfoAMD(uint group, uint counter, uint pname, void* data) {
            var _F = _GetProc<GLNativeDelegate.FNglGetPerfMonitorCounterInfoAMD>("glGetPerfMonitorCounterInfoAMD");
            _F(group, counter, pname, data);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_AMD_performance_monitor</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glGenPerfMonitorsAMD(GLsizei n, GLuint * monitors);</para>
        /// </summary>
        public unsafe static void glGenPerfMonitorsAMD(int n, uint* monitors) {
            var _F = _GetProc<GLNativeDelegate.FNglGenPerfMonitorsAMD>("glGenPerfMonitorsAMD");
            _F(n, monitors);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_AMD_performance_monitor</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glDeletePerfMonitorsAMD(GLsizei n, GLuint * monitors);</para>
        /// </summary>
        public unsafe static void glDeletePerfMonitorsAMD(int n, uint* monitors) {
            var _F = _GetProc<GLNativeDelegate.FNglDeletePerfMonitorsAMD>("glDeletePerfMonitorsAMD");
            _F(n, monitors);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_AMD_performance_monitor</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glSelectPerfMonitorCountersAMD(GLuint monitor, GLboolean enable, GLuint group, GLint numCounters, GLuint * counterList);</para>
        /// </summary>
        public unsafe static void glSelectPerfMonitorCountersAMD(uint monitor, bool enable, uint group, int numCounters, uint* counterList) {
            var _F = _GetProc<GLNativeDelegate.FNglSelectPerfMonitorCountersAMD>("glSelectPerfMonitorCountersAMD");
            _F(monitor, enable, group, numCounters, counterList);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_AMD_performance_monitor</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glBeginPerfMonitorAMD(GLuint monitor);</para>
        /// </summary>
        public static void glBeginPerfMonitorAMD(uint monitor) {
            var _F = _GetProc<GLNativeDelegate.FNglBeginPerfMonitorAMD>("glBeginPerfMonitorAMD");
            _F(monitor);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_AMD_performance_monitor</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glEndPerfMonitorAMD(GLuint monitor);</para>
        /// </summary>
        public static void glEndPerfMonitorAMD(uint monitor) {
            var _F = _GetProc<GLNativeDelegate.FNglEndPerfMonitorAMD>("glEndPerfMonitorAMD");
            _F(monitor);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_AMD_performance_monitor</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glGetPerfMonitorCounterDataAMD(GLuint monitor, GLenum pname, GLsizei dataSize, GLuint * data, GLint * bytesWritten);</para>
        /// </summary>
        public unsafe static void glGetPerfMonitorCounterDataAMD(uint monitor, uint pname, int dataSize, uint* data, int* bytesWritten) {
            var _F = _GetProc<GLNativeDelegate.FNglGetPerfMonitorCounterDataAMD>("glGetPerfMonitorCounterDataAMD");
            _F(monitor, pname, dataSize, data, bytesWritten);
        }

        #endregion GL_AMD_performance_monitor

        #region GL_AMD_sample_positions

        /// <summary>
        /// <para>Require:</para> <para>GL_AMD_sample_positions</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glSetMultisamplefvAMD(GLenum pname, GLuint index, const GLfloat * val);</para>
        /// </summary>
        public unsafe static void glSetMultisamplefvAMD(uint pname, uint index, float* val) {
            var _F = _GetProc<GLNativeDelegate.FNglSetMultisamplefvAMD>("glSetMultisamplefvAMD");
            _F(pname, index, val);
        }

        #endregion GL_AMD_sample_positions

        #region GL_AMD_sparse_texture

        /// <summary>
        /// <para>Require:</para> <para>GL_AMD_sparse_texture</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glTexStorageSparseAMD(GLenum target, GLenum internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLsizei layers, GLbitfield flags);</para>
        /// </summary>
        public static void glTexStorageSparseAMD(uint target, uint internalFormat, int width, int height, int depth, int layers, uint flags) {
            var _F = _GetProc<GLNativeDelegate.FNglTexStorageSparseAMD>("glTexStorageSparseAMD");
            _F(target, internalFormat, width, height, depth, layers, flags);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_AMD_sparse_texture</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glTextureStorageSparseAMD(GLuint texture, GLenum target, GLenum internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLsizei layers, GLbitfield flags);</para>
        /// </summary>
        public static void glTextureStorageSparseAMD(uint texture, uint target, uint internalFormat, int width, int height, int depth, int layers, uint flags) {
            var _F = _GetProc<GLNativeDelegate.FNglTextureStorageSparseAMD>("glTextureStorageSparseAMD");
            _F(texture, target, internalFormat, width, height, depth, layers, flags);
        }

        #endregion GL_AMD_sparse_texture

        #region GL_AMD_stencil_operation_extended

        /// <summary>
        /// <para>Require:</para> <para>GL_AMD_stencil_operation_extended</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glStencilOpValueAMD(GLenum face, GLuint value);</para>
        /// </summary>
        public static void glStencilOpValueAMD(uint face, uint value) {
            var _F = _GetProc<GLNativeDelegate.FNglStencilOpValueAMD>("glStencilOpValueAMD");
            _F(face, value);
        }

        #endregion GL_AMD_stencil_operation_extended

        #region GL_AMD_vertex_shader_tessellator

        /// <summary>
        /// <para>Require:</para> <para>GL_AMD_vertex_shader_tessellator</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glTessellationFactorAMD(GLfloat factor);</para>
        /// </summary>
        public static void glTessellationFactorAMD(float factor) {
            var _F = _GetProc<GLNativeDelegate.FNglTessellationFactorAMD>("glTessellationFactorAMD");
            _F(factor);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_AMD_vertex_shader_tessellator</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glTessellationModeAMD(GLenum mode);</para>
        /// </summary>
        public static void glTessellationModeAMD(uint mode) {
            var _F = _GetProc<GLNativeDelegate.FNglTessellationModeAMD>("glTessellationModeAMD");
            _F(mode);
        }

        #endregion GL_AMD_vertex_shader_tessellator

        #region GL_APPLE_element_array

        /// <summary>
        /// <para>Require:</para> <para>GL_APPLE_element_array</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glElementPointerAPPLE(GLenum type, const void * pointer);</para>
        /// </summary>
        public unsafe static void glElementPointerAPPLE(uint type, void* pointer) {
            var _F = _GetProc<GLNativeDelegate.FNglElementPointerAPPLE>("glElementPointerAPPLE");
            _F(type, pointer);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_APPLE_element_array</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glDrawElementArrayAPPLE(GLenum mode, GLint first, GLsizei count);</para>
        /// </summary>
        public static void glDrawElementArrayAPPLE(uint mode, int first, int count) {
            var _F = _GetProc<GLNativeDelegate.FNglDrawElementArrayAPPLE>("glDrawElementArrayAPPLE");
            _F(mode, first, count);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_APPLE_element_array</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glDrawRangeElementArrayAPPLE(GLenum mode, GLuint start, GLuint end, GLint first, GLsizei count);</para>
        /// </summary>
        public static void glDrawRangeElementArrayAPPLE(uint mode, uint start, uint end, int first, int count) {
            var _F = _GetProc<GLNativeDelegate.FNglDrawRangeElementArrayAPPLE>("glDrawRangeElementArrayAPPLE");
            _F(mode, start, end, first, count);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_APPLE_element_array</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glMultiDrawElementArrayAPPLE(GLenum mode, const GLint * first, const GLsizei * count, GLsizei primcount);</para>
        /// </summary>
        public unsafe static void glMultiDrawElementArrayAPPLE(uint mode, int* first, int* count, int primcount) {
            var _F = _GetProc<GLNativeDelegate.FNglMultiDrawElementArrayAPPLE>("glMultiDrawElementArrayAPPLE");
            _F(mode, first, count, primcount);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_APPLE_element_array</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glMultiDrawRangeElementArrayAPPLE(GLenum mode, GLuint start, GLuint end, const GLint * first, const GLsizei * count, GLsizei primcount);</para>
        /// </summary>
        public unsafe static void glMultiDrawRangeElementArrayAPPLE(uint mode, uint start, uint end, int* first, int* count, int primcount) {
            var _F = _GetProc<GLNativeDelegate.FNglMultiDrawRangeElementArrayAPPLE>("glMultiDrawRangeElementArrayAPPLE");
            _F(mode, start, end, first, count, primcount);
        }

        #endregion GL_APPLE_element_array

        #region GL_APPLE_fence

        /// <summary>
        /// <para>Require:</para> <para>GL_APPLE_fence</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGenFencesAPPLE(GLsizei n, GLuint * fences);</para>
        /// </summary>
        public unsafe static void glGenFencesAPPLE(int n, uint* fences) {
            var _F = _GetProc<GLNativeDelegate.FNglGenFencesAPPLE>("glGenFencesAPPLE");
            _F(n, fences);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_APPLE_fence</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glDeleteFencesAPPLE(GLsizei n, const GLuint * fences);</para>
        /// </summary>
        public unsafe static void glDeleteFencesAPPLE(int n, uint* fences) {
            var _F = _GetProc<GLNativeDelegate.FNglDeleteFencesAPPLE>("glDeleteFencesAPPLE");
            _F(n, fences);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_APPLE_fence</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glSetFenceAPPLE(GLuint fence);</para>
        /// </summary>
        public static void glSetFenceAPPLE(uint fence) {
            var _F = _GetProc<GLNativeDelegate.FNglSetFenceAPPLE>("glSetFenceAPPLE");
            _F(fence);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_APPLE_fence</para>
        /// Supported: <para>gl</para>
        /// Original: <para>GLboolean glIsFenceAPPLE(GLuint fence);</para>
        /// </summary>
        public static bool glIsFenceAPPLE(uint fence) {
            var _F = _GetProc<GLNativeDelegate.FNglIsFenceAPPLE>("glIsFenceAPPLE");
            return _F(fence);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_APPLE_fence</para>
        /// Supported: <para>gl</para>
        /// Original: <para>GLboolean glTestFenceAPPLE(GLuint fence);</para>
        /// </summary>
        public static bool glTestFenceAPPLE(uint fence) {
            var _F = _GetProc<GLNativeDelegate.FNglTestFenceAPPLE>("glTestFenceAPPLE");
            return _F(fence);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_APPLE_fence</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glFinishFenceAPPLE(GLuint fence);</para>
        /// </summary>
        public static void glFinishFenceAPPLE(uint fence) {
            var _F = _GetProc<GLNativeDelegate.FNglFinishFenceAPPLE>("glFinishFenceAPPLE");
            _F(fence);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_APPLE_fence</para>
        /// Supported: <para>gl</para>
        /// Original: <para>GLboolean glTestObjectAPPLE(GLenum object, GLuint name);</para>
        /// </summary>
        public static bool glTestObjectAPPLE(uint obj, uint name) {
            var _F = _GetProc<GLNativeDelegate.FNglTestObjectAPPLE>("glTestObjectAPPLE");
            return _F(obj, name);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_APPLE_fence</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glFinishObjectAPPLE(GLenum object, GLint name);</para>
        /// </summary>
        public static void glFinishObjectAPPLE(uint obj, int name) {
            var _F = _GetProc<GLNativeDelegate.FNglFinishObjectAPPLE>("glFinishObjectAPPLE");
            _F(obj, name);
        }

        #endregion GL_APPLE_fence

        #region GL_APPLE_flush_buffer_range

        /// <summary>
        /// <para>Require:</para> <para>GL_APPLE_flush_buffer_range</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glBufferParameteriAPPLE(GLenum target, GLenum pname, GLint param);</para>
        /// </summary>
        public static void glBufferParameteriAPPLE(uint target, uint pname, int param) {
            var _F = _GetProc<GLNativeDelegate.FNglBufferParameteriAPPLE>("glBufferParameteriAPPLE");
            _F(target, pname, param);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_APPLE_flush_buffer_range</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glFlushMappedBufferRangeAPPLE(GLenum target, GLintptr offset, GLsizeiptr size);</para>
        /// </summary>
        public static void glFlushMappedBufferRangeAPPLE(uint target, IntPtr offset, IntPtr size) {
            var _F = _GetProc<GLNativeDelegate.FNglFlushMappedBufferRangeAPPLE>("glFlushMappedBufferRangeAPPLE");
            _F(target, offset, size);
        }

        #endregion GL_APPLE_flush_buffer_range

        #region GL_APPLE_object_purgeable

        /// <summary>
        /// <para>Require:</para> <para>GL_APPLE_object_purgeable</para>
        /// Supported: <para>gl</para>
        /// Original: <para>GLenum glObjectPurgeableAPPLE(GLenum objectType, GLuint name, GLenum option);</para>
        /// </summary>
        public static uint glObjectPurgeableAPPLE(uint objectType, uint name, uint option) {
            var _F = _GetProc<GLNativeDelegate.FNglObjectPurgeableAPPLE>("glObjectPurgeableAPPLE");
            return _F(objectType, name, option);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_APPLE_object_purgeable</para>
        /// Supported: <para>gl</para>
        /// Original: <para>GLenum glObjectUnpurgeableAPPLE(GLenum objectType, GLuint name, GLenum option);</para>
        /// </summary>
        public static uint glObjectUnpurgeableAPPLE(uint objectType, uint name, uint option) {
            var _F = _GetProc<GLNativeDelegate.FNglObjectUnpurgeableAPPLE>("glObjectUnpurgeableAPPLE");
            return _F(objectType, name, option);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_APPLE_object_purgeable</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetObjectParameterivAPPLE(GLenum objectType, GLuint name, GLenum pname, GLint * params);</para>
        /// </summary>
        public unsafe static void glGetObjectParameterivAPPLE(uint objectType, uint name, uint pname, int* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetObjectParameterivAPPLE>("glGetObjectParameterivAPPLE");
            _F(objectType, name, pname, ps);
        }

        #endregion GL_APPLE_object_purgeable

        #region GL_APPLE_texture_range

        /// <summary>
        /// <para>Require:</para> <para>GL_APPLE_texture_range</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glTextureRangeAPPLE(GLenum target, GLsizei length, const void * pointer);</para>
        /// </summary>
        public unsafe static void glTextureRangeAPPLE(uint target, int length, void* pointer) {
            var _F = _GetProc<GLNativeDelegate.FNglTextureRangeAPPLE>("glTextureRangeAPPLE");
            _F(target, length, pointer);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_APPLE_texture_range</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetTexParameterPointervAPPLE(GLenum target, GLenum pname, void ** params);</para>
        /// </summary>
        public unsafe static void glGetTexParameterPointervAPPLE(uint target, uint pname, void** ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetTexParameterPointervAPPLE>("glGetTexParameterPointervAPPLE");
            _F(target, pname, ps);
        }

        #endregion GL_APPLE_texture_range

        #region GL_APPLE_vertex_array_object

        /// <summary>
        /// <para>Require:</para> <para>GL_APPLE_vertex_array_object</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glBindVertexArrayAPPLE(GLuint array);</para>
        /// </summary>
        public static void glBindVertexArrayAPPLE(uint array) {
            var _F = _GetProc<GLNativeDelegate.FNglBindVertexArrayAPPLE>("glBindVertexArrayAPPLE");
            _F(array);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_APPLE_vertex_array_object</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glDeleteVertexArraysAPPLE(GLsizei n, const GLuint * arrays);</para>
        /// </summary>
        public unsafe static void glDeleteVertexArraysAPPLE(int n, uint* arrays) {
            var _F = _GetProc<GLNativeDelegate.FNglDeleteVertexArraysAPPLE>("glDeleteVertexArraysAPPLE");
            _F(n, arrays);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_APPLE_vertex_array_object</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGenVertexArraysAPPLE(GLsizei n, GLuint * arrays);</para>
        /// </summary>
        public unsafe static void glGenVertexArraysAPPLE(int n, uint* arrays) {
            var _F = _GetProc<GLNativeDelegate.FNglGenVertexArraysAPPLE>("glGenVertexArraysAPPLE");
            _F(n, arrays);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_APPLE_vertex_array_object</para>
        /// Supported: <para>gl</para>
        /// Original: <para>GLboolean glIsVertexArrayAPPLE(GLuint array);</para>
        /// </summary>
        public static bool glIsVertexArrayAPPLE(uint array) {
            var _F = _GetProc<GLNativeDelegate.FNglIsVertexArrayAPPLE>("glIsVertexArrayAPPLE");
            return _F(array);
        }

        #endregion GL_APPLE_vertex_array_object

        #region GL_APPLE_vertex_array_range

        /// <summary>
        /// <para>Require:</para> <para>GL_APPLE_vertex_array_range</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexArrayRangeAPPLE(GLsizei length, void * pointer);</para>
        /// </summary>
        public unsafe static void glVertexArrayRangeAPPLE(int length, void* pointer) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexArrayRangeAPPLE>("glVertexArrayRangeAPPLE");
            _F(length, pointer);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_APPLE_vertex_array_range</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glFlushVertexArrayRangeAPPLE(GLsizei length, void * pointer);</para>
        /// </summary>
        public unsafe static void glFlushVertexArrayRangeAPPLE(int length, void* pointer) {
            var _F = _GetProc<GLNativeDelegate.FNglFlushVertexArrayRangeAPPLE>("glFlushVertexArrayRangeAPPLE");
            _F(length, pointer);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_APPLE_vertex_array_range</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexArrayParameteriAPPLE(GLenum pname, GLint param);</para>
        /// </summary>
        public static void glVertexArrayParameteriAPPLE(uint pname, int param) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexArrayParameteriAPPLE>("glVertexArrayParameteriAPPLE");
            _F(pname, param);
        }

        #endregion GL_APPLE_vertex_array_range

        #region GL_APPLE_vertex_program_evaluators

        /// <summary>
        /// <para>Require:</para> <para>GL_APPLE_vertex_program_evaluators</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glEnableVertexAttribAPPLE(GLuint index, GLenum pname);</para>
        /// </summary>
        public static void glEnableVertexAttribAPPLE(uint index, uint pname) {
            var _F = _GetProc<GLNativeDelegate.FNglEnableVertexAttribAPPLE>("glEnableVertexAttribAPPLE");
            _F(index, pname);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_APPLE_vertex_program_evaluators</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glDisableVertexAttribAPPLE(GLuint index, GLenum pname);</para>
        /// </summary>
        public static void glDisableVertexAttribAPPLE(uint index, uint pname) {
            var _F = _GetProc<GLNativeDelegate.FNglDisableVertexAttribAPPLE>("glDisableVertexAttribAPPLE");
            _F(index, pname);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_APPLE_vertex_program_evaluators</para>
        /// Supported: <para>gl</para>
        /// Original: <para>GLboolean glIsVertexAttribEnabledAPPLE(GLuint index, GLenum pname);</para>
        /// </summary>
        public static bool glIsVertexAttribEnabledAPPLE(uint index, uint pname) {
            var _F = _GetProc<GLNativeDelegate.FNglIsVertexAttribEnabledAPPLE>("glIsVertexAttribEnabledAPPLE");
            return _F(index, pname);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_APPLE_vertex_program_evaluators</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glMapVertexAttrib1dAPPLE(GLuint index, GLuint size, GLdouble u1, GLdouble u2, GLint stride, GLint order, const GLdouble * points);</para>
        /// </summary>
        public unsafe static void glMapVertexAttrib1dAPPLE(uint index, uint size, double u1, double u2, int stride, int order, double* points) {
            var _F = _GetProc<GLNativeDelegate.FNglMapVertexAttrib1dAPPLE>("glMapVertexAttrib1dAPPLE");
            _F(index, size, u1, u2, stride, order, points);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_APPLE_vertex_program_evaluators</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glMapVertexAttrib1fAPPLE(GLuint index, GLuint size, GLfloat u1, GLfloat u2, GLint stride, GLint order, const GLfloat * points);</para>
        /// </summary>
        public unsafe static void glMapVertexAttrib1fAPPLE(uint index, uint size, float u1, float u2, int stride, int order, float* points) {
            var _F = _GetProc<GLNativeDelegate.FNglMapVertexAttrib1fAPPLE>("glMapVertexAttrib1fAPPLE");
            _F(index, size, u1, u2, stride, order, points);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_APPLE_vertex_program_evaluators</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glMapVertexAttrib2dAPPLE(GLuint index, GLuint size, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, const GLdouble * points);</para>
        /// </summary>
        public unsafe static void glMapVertexAttrib2dAPPLE(uint index, uint size, double u1, double u2, int ustride, int uorder, double v1, double v2, int vstride, int vorder, double* points) {
            var _F = _GetProc<GLNativeDelegate.FNglMapVertexAttrib2dAPPLE>("glMapVertexAttrib2dAPPLE");
            _F(index, size, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_APPLE_vertex_program_evaluators</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glMapVertexAttrib2fAPPLE(GLuint index, GLuint size, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, const GLfloat * points);</para>
        /// </summary>
        public unsafe static void glMapVertexAttrib2fAPPLE(uint index, uint size, float u1, float u2, int ustride, int uorder, float v1, float v2, int vstride, int vorder, float* points) {
            var _F = _GetProc<GLNativeDelegate.FNglMapVertexAttrib2fAPPLE>("glMapVertexAttrib2fAPPLE");
            _F(index, size, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
        }

        #endregion GL_APPLE_vertex_program_evaluators

        #region GL_ARB_ES2_compatibility

        // void glReleaseShaderCompiler();
        // void glShaderBinary(GLsizei count, const GLuint * shaders, GLenum binaryFormat, const void * binary, GLsizei length);
        // void glGetShaderPrecisionFormat(GLenum shaderType, GLenum precisionType, GLint * range, GLint * precision);
        // void glDepthRangef(GLfloat nearVal, GLfloat farVal);
        // void glClearDepthf(GLfloat depth);

        #endregion GL_ARB_ES2_compatibility

        #region GL_ARB_ES3_1_compatibility

        // void glMemoryBarrierByRegion(GLbitfield barriers);

        #endregion GL_ARB_ES3_1_compatibility

        #region GL_ARB_ES3_2_compatibility

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_ES3_2_compatibility</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glPrimitiveBoundingBoxARB(GLfloat minX, GLfloat minY, GLfloat minZ, GLfloat minW, GLfloat maxX, GLfloat maxY, GLfloat maxZ, GLfloat maxW);</para>
        /// </summary>
        public static void glPrimitiveBoundingBoxARB(float minX, float minY, float minZ, float minW, float maxX, float maxY, float maxZ, float maxW) {
            var _F = _GetProc<GLNativeDelegate.FNglPrimitiveBoundingBoxARB>("glPrimitiveBoundingBoxARB");
            _F(minX, minY, minZ, minW, maxX, maxY, maxZ, maxW);
        }

        #endregion GL_ARB_ES3_2_compatibility

        #region GL_ARB_base_instance

        // void glDrawArraysInstancedBaseInstance(GLenum mode, GLint first, GLsizei count, GLsizei instancecount, GLuint baseinstance);
        // void glDrawElementsInstancedBaseInstance(GLenum mode, GLsizei count, GLenum type, const void * indices, GLsizei instancecount, GLuint baseinstance);
        // void glDrawElementsInstancedBaseVertexBaseInstance(GLenum mode, GLsizei count, GLenum type, void * indices, GLsizei instancecount, GLint basevertex, GLuint baseinstance);

        #endregion GL_ARB_base_instance

        #region GL_ARB_bindless_texture

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_bindless_texture</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>GLuint64 glGetTextureHandleARB(GLuint texture);</para>
        /// </summary>
        public static UInt64 glGetTextureHandleARB(uint texture) {
            var _F = _GetProc<GLNativeDelegate.FNglGetTextureHandleARB>("glGetTextureHandleARB");
            return _F(texture);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_bindless_texture</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>GLuint64 glGetTextureSamplerHandleARB(GLuint texture, GLuint sampler);</para>
        /// </summary>
        public static UInt64 glGetTextureSamplerHandleARB(uint texture, uint sampler) {
            var _F = _GetProc<GLNativeDelegate.FNglGetTextureSamplerHandleARB>("glGetTextureSamplerHandleARB");
            return _F(texture, sampler);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_bindless_texture</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glMakeTextureHandleResidentARB(GLuint64 handle);</para>
        /// </summary>
        public static void glMakeTextureHandleResidentARB(UInt64 handle) {
            var _F = _GetProc<GLNativeDelegate.FNglMakeTextureHandleResidentARB>("glMakeTextureHandleResidentARB");
            _F(handle);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_bindless_texture</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glMakeTextureHandleNonResidentARB(GLuint64 handle);</para>
        /// </summary>
        public static void glMakeTextureHandleNonResidentARB(UInt64 handle) {
            var _F = _GetProc<GLNativeDelegate.FNglMakeTextureHandleNonResidentARB>("glMakeTextureHandleNonResidentARB");
            _F(handle);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_bindless_texture</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>GLuint64 glGetImageHandleARB(GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum format);</para>
        /// </summary>
        public static UInt64 glGetImageHandleARB(uint texture, int level, bool layered, int layer, uint format) {
            var _F = _GetProc<GLNativeDelegate.FNglGetImageHandleARB>("glGetImageHandleARB");
            return _F(texture, level, layered, layer, format);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_bindless_texture</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glMakeImageHandleResidentARB(GLuint64 handle, GLenum access);</para>
        /// </summary>
        public static void glMakeImageHandleResidentARB(UInt64 handle, uint access) {
            var _F = _GetProc<GLNativeDelegate.FNglMakeImageHandleResidentARB>("glMakeImageHandleResidentARB");
            _F(handle, access);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_bindless_texture</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glMakeImageHandleNonResidentARB(GLuint64 handle);</para>
        /// </summary>
        public static void glMakeImageHandleNonResidentARB(UInt64 handle) {
            var _F = _GetProc<GLNativeDelegate.FNglMakeImageHandleNonResidentARB>("glMakeImageHandleNonResidentARB");
            _F(handle);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_bindless_texture</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glUniformHandleui64ARB(GLint location, GLuint64 value);</para>
        /// </summary>
        public static void glUniformHandleui64ARB(int location, UInt64 value) {
            var _F = _GetProc<GLNativeDelegate.FNglUniformHandleui64ARB>("glUniformHandleui64ARB");
            _F(location, value);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_bindless_texture</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glUniformHandleui64vARB(GLint location, GLsizei count, const GLuint64 * value);</para>
        /// </summary>
        public unsafe static void glUniformHandleui64vARB(int location, int count, UInt64* value) {
            var _F = _GetProc<GLNativeDelegate.FNglUniformHandleui64vARB>("glUniformHandleui64vARB");
            _F(location, count, value);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_bindless_texture</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glProgramUniformHandleui64ARB(GLuint program, GLint location, GLuint64 value);</para>
        /// </summary>
        public static void glProgramUniformHandleui64ARB(uint program, int location, UInt64 value) {
            var _F = _GetProc<GLNativeDelegate.FNglProgramUniformHandleui64ARB>("glProgramUniformHandleui64ARB");
            _F(program, location, value);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_bindless_texture</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glProgramUniformHandleui64vARB(GLuint program, GLint location, GLsizei count, const GLuint64 * values);</para>
        /// </summary>
        public unsafe static void glProgramUniformHandleui64vARB(uint program, int location, int count, UInt64* values) {
            var _F = _GetProc<GLNativeDelegate.FNglProgramUniformHandleui64vARB>("glProgramUniformHandleui64vARB");
            _F(program, location, count, values);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_bindless_texture</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>GLboolean glIsTextureHandleResidentARB(GLuint64 handle);</para>
        /// </summary>
        public static bool glIsTextureHandleResidentARB(UInt64 handle) {
            var _F = _GetProc<GLNativeDelegate.FNglIsTextureHandleResidentARB>("glIsTextureHandleResidentARB");
            return _F(handle);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_bindless_texture</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>GLboolean glIsImageHandleResidentARB(GLuint64 handle);</para>
        /// </summary>
        public static bool glIsImageHandleResidentARB(UInt64 handle) {
            var _F = _GetProc<GLNativeDelegate.FNglIsImageHandleResidentARB>("glIsImageHandleResidentARB");
            return _F(handle);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_bindless_texture</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glVertexAttribL1ui64ARB(GLuint index, GLuint64EXT x);</para>
        /// </summary>
        public static void glVertexAttribL1ui64ARB(uint index, UInt64 x) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttribL1ui64ARB>("glVertexAttribL1ui64ARB");
            _F(index, x);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_bindless_texture</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glVertexAttribL1ui64vARB(GLuint index, const GLuint64EXT * v);</para>
        /// </summary>
        public unsafe static void glVertexAttribL1ui64vARB(uint index, UInt64* v) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttribL1ui64vARB>("glVertexAttribL1ui64vARB");
            _F(index, v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_bindless_texture</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetVertexAttribLui64vARB(GLuint index, GLenum pname, GLuint64EXT * params);</para>
        /// </summary>
        public unsafe static void glGetVertexAttribLui64vARB(uint index, uint pname, UInt64* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetVertexAttribLui64vARB>("glGetVertexAttribLui64vARB");
            _F(index, pname, ps);
        }

        #endregion GL_ARB_bindless_texture

        #region GL_ARB_blend_func_extended

        // void glBindFragDataLocationIndexed(GLuint program, GLuint colorNumber, GLuint index, const char * name);
        // GLint glGetFragDataIndex(GLuint program, const char * name);

        #endregion GL_ARB_blend_func_extended

        #region GL_ARB_buffer_storage

        // void glBufferStorage(GLenum target, GLsizeiptr size, const void * data, GLbitfield flags);

        #endregion GL_ARB_buffer_storage

        #region GL_ARB_cl_event

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_cl_event</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>GLsync glCreateSyncFromCLeventARB(struct _cl_context * context, struct _cl_event * event, GLbitfield flags);</para>
        /// </summary>
        public static IntPtr glCreateSyncFromCLeventARB(IntPtr context, IntPtr e, uint flags) {
            var _F = _GetProc<GLNativeDelegate.FNglCreateSyncFromCLeventARB>("glCreateSyncFromCLeventARB");
            return _F(context, e, flags);
        }

        #endregion GL_ARB_cl_event

        #region GL_ARB_clear_buffer_object

        // void glClearBufferData(GLenum target, GLenum internalformat, GLenum format, GLenum type, const void * data);
        // void glClearBufferSubData(GLenum target, GLenum internalformat, GLintptr offset, GLsizeiptr size, GLenum format, GLenum type, const void * data);

        #endregion GL_ARB_clear_buffer_object

        #region GL_ARB_clear_texture

        // void glClearTexImage(GLuint texture, GLint level, GLenum format, GLenum type, const void * data);
        // void glClearTexSubImage(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void * data);

        #endregion GL_ARB_clear_texture

        #region GL_ARB_clip_control

        // void glClipControl(GLenum origin, GLenum depth);

        #endregion GL_ARB_clip_control

        #region GL_ARB_color_buffer_float

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_color_buffer_float</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glClampColorARB(GLenum target, GLenum clamp);</para>
        /// </summary>
        public static void glClampColorARB(uint target, uint clamp) {
            var _F = _GetProc<GLNativeDelegate.FNglClampColorARB>("glClampColorARB");
            _F(target, clamp);
        }

        #endregion GL_ARB_color_buffer_float

        #region GL_ARB_compute_shader

        // void glDispatchCompute(GLuint num_groups_x, GLuint num_groups_y, GLuint num_groups_z);
        // void glDispatchComputeIndirect(GLintptr indirect);

        #endregion GL_ARB_compute_shader

        #region GL_ARB_compute_variable_group_size

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_compute_variable_group_size</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glDispatchComputeGroupSizeARB(GLuint num_groups_x, GLuint num_groups_y, GLuint num_groups_z, GLuint group_size_x, GLuint group_size_y, GLuint group_size_z);</para>
        /// </summary>
        public static void glDispatchComputeGroupSizeARB(uint num_groups_x, uint num_groups_y, uint num_groups_z, uint group_size_x, uint group_size_y, uint group_size_z) {
            var _F = _GetProc<GLNativeDelegate.FNglDispatchComputeGroupSizeARB>("glDispatchComputeGroupSizeARB");
            _F(num_groups_x, num_groups_y, num_groups_z, group_size_x, group_size_y, group_size_z);
        }

        #endregion GL_ARB_compute_variable_group_size

        #region GL_ARB_copy_buffer

        // void glCopyBufferSubData(GLenum readTarget, GLenum writeTarget, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size);

        #endregion GL_ARB_copy_buffer

        #region GL_ARB_copy_image

        // void glCopyImageSubData(GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei srcWidth, GLsizei srcHeight, GLsizei srcDepth);

        #endregion GL_ARB_copy_image

        #region GL_ARB_debug_output

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_debug_output</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glDebugMessageControlARB(GLenum source, GLenum type, GLenum severity, GLsizei count, const GLuint * ids, GLboolean enabled);</para>
        /// </summary>
        public unsafe static void glDebugMessageControlARB(uint source, uint type, uint severity, int count, uint* ids, bool enabled) {
            var _F = _GetProc<GLNativeDelegate.FNglDebugMessageControlARB>("glDebugMessageControlARB");
            _F(source, type, severity, count, ids, enabled);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_debug_output</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glDebugMessageInsertARB(GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const GLchar * buf);</para>
        /// </summary>
        public unsafe static void glDebugMessageInsertARB(uint source, uint type, uint id, uint severity, int length, byte* buf) {
            var _F = _GetProc<GLNativeDelegate.FNglDebugMessageInsertARB>("glDebugMessageInsertARB");
            _F(source, type, id, severity, length, buf);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_debug_output</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glDebugMessageCallbackARB(GLDEBUGPROCARB callback, const void * userParam);</para>
        /// </summary>
        public unsafe static void glDebugMessageCallbackARB(GLNativeDelegate.GLDEBUGPROCARB callback, void* userParam) {
            var _F = _GetProc<GLNativeDelegate.FNglDebugMessageCallbackARB>("glDebugMessageCallbackARB");
            _F(callback, userParam);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_debug_output</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>GLuint glGetDebugMessageLogARB(GLuint count, GLsizei bufSize, GLenum * sources, GLenum * types, GLuint * ids, GLenum * severities, GLsizei * lengths, GLchar * messageLog);</para>
        /// </summary>
        public unsafe static uint glGetDebugMessageLogARB(uint count, int bufSize, uint* sources, uint* types, uint* ids, uint* severities, int* lengths, byte* messageLog) {
            var _F = _GetProc<GLNativeDelegate.FNglGetDebugMessageLogARB>("glGetDebugMessageLogARB");
            return _F(count, bufSize, sources, types, ids, severities, lengths, messageLog);
        }

        #endregion GL_ARB_debug_output

        #region GL_ARB_draw_buffers

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_draw_buffers</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glDrawBuffersARB(GLsizei n, const GLenum * bufs);</para>
        /// </summary>
        public unsafe static void glDrawBuffersARB(int n, uint* bufs) {
            var _F = _GetProc<GLNativeDelegate.FNglDrawBuffersARB>("glDrawBuffersARB");
            _F(n, bufs);
        }

        #endregion GL_ARB_draw_buffers

        #region GL_ARB_draw_buffers_blend

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_draw_buffers_blend</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glBlendEquationiARB(GLuint buf, GLenum mode);</para>
        /// </summary>
        public static void glBlendEquationiARB(uint buf, uint mode) {
            var _F = _GetProc<GLNativeDelegate.FNglBlendEquationiARB>("glBlendEquationiARB");
            _F(buf, mode);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_draw_buffers_blend</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glBlendEquationSeparateiARB(GLuint buf, GLenum modeRGB, GLenum modeAlpha);</para>
        /// </summary>
        public static void glBlendEquationSeparateiARB(uint buf, uint modeRGB, uint modeAlpha) {
            var _F = _GetProc<GLNativeDelegate.FNglBlendEquationSeparateiARB>("glBlendEquationSeparateiARB");
            _F(buf, modeRGB, modeAlpha);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_draw_buffers_blend</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glBlendFunciARB(GLuint buf, GLenum src, GLenum dst);</para>
        /// </summary>
        public static void glBlendFunciARB(uint buf, uint src, uint dst) {
            var _F = _GetProc<GLNativeDelegate.FNglBlendFunciARB>("glBlendFunciARB");
            _F(buf, src, dst);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_draw_buffers_blend</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glBlendFuncSeparateiARB(GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha);</para>
        /// </summary>
        public static void glBlendFuncSeparateiARB(uint buf, uint srcRGB, uint dstRGB, uint srcAlpha, uint dstAlpha) {
            var _F = _GetProc<GLNativeDelegate.FNglBlendFuncSeparateiARB>("glBlendFuncSeparateiARB");
            _F(buf, srcRGB, dstRGB, srcAlpha, dstAlpha);
        }

        #endregion GL_ARB_draw_buffers_blend

        #region GL_ARB_draw_elements_base_vertex

        // void glDrawElementsBaseVertex(GLenum mode, GLsizei count, GLenum type, void * indices, GLint basevertex);
        // void glDrawRangeElementsBaseVertex(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, void * indices, GLint basevertex);
        // void glDrawElementsInstancedBaseVertex(GLenum mode, GLsizei count, GLenum type, void * indices, GLsizei instancecount, GLint basevertex);
        // void glMultiDrawElementsBaseVertex(GLenum mode, const GLsizei * count, GLenum type, const void * const * indices, GLsizei drawcount, const GLint * basevertex);

        #endregion GL_ARB_draw_elements_base_vertex

        #region GL_ARB_draw_indirect

        // void glDrawArraysIndirect(GLenum mode, const void * indirect);
        // void glDrawElementsIndirect(GLenum mode, GLenum type, const void * indirect);

        #endregion GL_ARB_draw_indirect

        #region GL_ARB_draw_instanced

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_draw_instanced</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glDrawArraysInstancedARB(GLenum mode, GLint first, GLsizei count, GLsizei primcount);</para>
        /// </summary>
        public static void glDrawArraysInstancedARB(uint mode, int first, int count, int primcount) {
            var _F = _GetProc<GLNativeDelegate.FNglDrawArraysInstancedARB>("glDrawArraysInstancedARB");
            _F(mode, first, count, primcount);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_draw_instanced</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glDrawElementsInstancedARB(GLenum mode, GLsizei count, GLenum type, const void * indices, GLsizei primcount);</para>
        /// </summary>
        public unsafe static void glDrawElementsInstancedARB(uint mode, int count, uint type, void* indices, int primcount) {
            var _F = _GetProc<GLNativeDelegate.FNglDrawElementsInstancedARB>("glDrawElementsInstancedARB");
            _F(mode, count, type, indices, primcount);
        }

        #endregion GL_ARB_draw_instanced

        #region GL_ARB_framebuffer_no_attachments

        // void glFramebufferParameteri(GLenum target, GLenum pname, GLint param);
        // void glGetFramebufferParameteriv(GLenum target, GLenum pname, GLint * ps);

        #endregion GL_ARB_framebuffer_no_attachments

        #region GL_ARB_framebuffer_object

        // GLboolean glIsRenderbuffer(GLuint renderbuffer);
        // void glBindRenderbuffer(GLenum target, GLuint renderbuffer);
        // void glDeleteRenderbuffers(GLsizei n, GLuint * renderbuffers);
        // void glGenRenderbuffers(GLsizei n, GLuint * renderbuffers);
        // void glRenderbufferStorage(GLenum target, GLenum internalformat, GLsizei width, GLsizei height);
        // void glGetRenderbufferParameteriv(GLenum target, GLenum pname, GLint * ps);
        // GLboolean glIsFramebuffer(GLuint framebuffer);
        // void glBindFramebuffer(GLenum target, GLuint framebuffer);
        // void glDeleteFramebuffers(GLsizei n, GLuint * framebuffers);
        // void glGenFramebuffers(GLsizei n, GLuint * ids);
        // GLenum glCheckFramebufferStatus(GLenum target);
        // void glFramebufferTexture1D(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
        // void glFramebufferTexture2D(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
        // void glFramebufferTexture3D(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint layer);
        // void glFramebufferRenderbuffer(GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer);
        // void glGetFramebufferAttachmentParameteriv(GLenum target, GLenum attachment, GLenum pname, GLint * ps);
        // void glGenerateMipmap(GLenum target);
        // void glBlitFramebuffer(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter);
        // void glRenderbufferStorageMultisample(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height);
        // void glFramebufferTextureLayer(GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer);

        #endregion GL_ARB_framebuffer_object

        #region GL_ARB_geometry_shader4

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_geometry_shader4</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glProgramParameteriARB(GLuint program, GLenum pname, GLint value);</para>
        /// </summary>
        public static void glProgramParameteriARB(uint program, uint pname, int value) {
            var _F = _GetProc<GLNativeDelegate.FNglProgramParameteriARB>("glProgramParameteriARB");
            _F(program, pname, value);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_geometry_shader4</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glFramebufferTextureARB(GLenum target, GLenum attachment, GLuint texture, GLint level);</para>
        /// </summary>
        public static void glFramebufferTextureARB(uint target, uint attachment, uint texture, int level) {
            var _F = _GetProc<GLNativeDelegate.FNglFramebufferTextureARB>("glFramebufferTextureARB");
            _F(target, attachment, texture, level);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_geometry_shader4</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glFramebufferTextureLayerARB(GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer);</para>
        /// </summary>
        public static void glFramebufferTextureLayerARB(uint target, uint attachment, uint texture, int level, int layer) {
            var _F = _GetProc<GLNativeDelegate.FNglFramebufferTextureLayerARB>("glFramebufferTextureLayerARB");
            _F(target, attachment, texture, level, layer);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_geometry_shader4</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glFramebufferTextureFaceARB(GLenum target, GLenum attachment, GLuint texture, GLint level, GLenum face);</para>
        /// </summary>
        public static void glFramebufferTextureFaceARB(uint target, uint attachment, uint texture, int level, uint face) {
            var _F = _GetProc<GLNativeDelegate.FNglFramebufferTextureFaceARB>("glFramebufferTextureFaceARB");
            _F(target, attachment, texture, level, face);
        }

        #endregion GL_ARB_geometry_shader4

        #region GL_ARB_get_program_binary

        // void glGetProgramBinary(GLuint program, GLsizei bufSize, GLsizei * length, GLenum * binaryFormat, void * binary);
        // void glProgramBinary(GLuint program, GLenum binaryFormat, const void * binary, GLsizei length);
        // void glProgramParameteri(GLuint program, GLenum pname, GLint value);

        #endregion GL_ARB_get_program_binary

        #region GL_ARB_get_texture_sub_image

        // void glGetTextureSubImage(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, GLsizei bufSize, void * pixels);
        // void glGetCompressedTextureSubImage(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLsizei bufSize, void * pixels);

        #endregion GL_ARB_get_texture_sub_image

        #region GL_ARB_gl_spirv

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_gl_spirv</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glSpecializeShaderARB(GLuint shader, const GLchar * pEntryPoint, GLuint numSpecializationConstants, const GLuint * pConstantIndex, const GLuint * pConstantValue);</para>
        /// </summary>
        public unsafe static void glSpecializeShaderARB(uint shader, byte* pEntryPoint, uint numSpecializationConstants, uint* pConstantIndex, uint* pConstantValue) {
            var _F = _GetProc<GLNativeDelegate.FNglSpecializeShaderARB>("glSpecializeShaderARB");
            _F(shader, pEntryPoint, numSpecializationConstants, pConstantIndex, pConstantValue);
        }

        #endregion GL_ARB_gl_spirv

        #region GL_ARB_gpu_shader_fp64

        // void glUniform1d(GLint location, GLdouble x);
        // void glUniform2d(GLint location, GLdouble x, GLdouble y);
        // void glUniform3d(GLint location, GLdouble x, GLdouble y, GLdouble z);
        // void glUniform4d(GLint location, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
        // void glUniform1dv(GLint location, GLsizei count, const GLdouble * value);
        // void glUniform2dv(GLint location, GLsizei count, const GLdouble * value);
        // void glUniform3dv(GLint location, GLsizei count, const GLdouble * value);
        // void glUniform4dv(GLint location, GLsizei count, const GLdouble * value);
        // void glUniformMatrix2dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);
        // void glUniformMatrix3dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);
        // void glUniformMatrix4dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);
        // void glUniformMatrix2x3dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);
        // void glUniformMatrix2x4dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);
        // void glUniformMatrix3x2dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);
        // void glUniformMatrix3x4dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);
        // void glUniformMatrix4x2dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);
        // void glUniformMatrix4x3dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);
        // void glGetUniformdv(GLuint program, GLint location, GLdouble * ps);

        #endregion GL_ARB_gpu_shader_fp64

        #region GL_ARB_gpu_shader_int64

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_gpu_shader_int64</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glUniform1i64ARB(GLint location, GLint64 x);</para>
        /// </summary>
        public static void glUniform1i64ARB(int location, Int64 x) {
            var _F = _GetProc<GLNativeDelegate.FNglUniform1i64ARB>("glUniform1i64ARB");
            _F(location, x);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_gpu_shader_int64</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glUniform2i64ARB(GLint location, GLint64 x, GLint64 y);</para>
        /// </summary>
        public static void glUniform2i64ARB(int location, Int64 x, Int64 y) {
            var _F = _GetProc<GLNativeDelegate.FNglUniform2i64ARB>("glUniform2i64ARB");
            _F(location, x, y);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_gpu_shader_int64</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glUniform3i64ARB(GLint location, GLint64 x, GLint64 y, GLint64 z);</para>
        /// </summary>
        public static void glUniform3i64ARB(int location, Int64 x, Int64 y, Int64 z) {
            var _F = _GetProc<GLNativeDelegate.FNglUniform3i64ARB>("glUniform3i64ARB");
            _F(location, x, y, z);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_gpu_shader_int64</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glUniform4i64ARB(GLint location, GLint64 x, GLint64 y, GLint64 z, GLint64 w);</para>
        /// </summary>
        public static void glUniform4i64ARB(int location, Int64 x, Int64 y, Int64 z, Int64 w) {
            var _F = _GetProc<GLNativeDelegate.FNglUniform4i64ARB>("glUniform4i64ARB");
            _F(location, x, y, z, w);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_gpu_shader_int64</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glUniform1i64vARB(GLint location, GLsizei count, const GLint64 * value);</para>
        /// </summary>
        public unsafe static void glUniform1i64vARB(int location, int count, Int64* value) {
            var _F = _GetProc<GLNativeDelegate.FNglUniform1i64vARB>("glUniform1i64vARB");
            _F(location, count, value);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_gpu_shader_int64</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glUniform2i64vARB(GLint location, GLsizei count, const GLint64 * value);</para>
        /// </summary>
        public unsafe static void glUniform2i64vARB(int location, int count, Int64* value) {
            var _F = _GetProc<GLNativeDelegate.FNglUniform2i64vARB>("glUniform2i64vARB");
            _F(location, count, value);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_gpu_shader_int64</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glUniform3i64vARB(GLint location, GLsizei count, const GLint64 * value);</para>
        /// </summary>
        public unsafe static void glUniform3i64vARB(int location, int count, Int64* value) {
            var _F = _GetProc<GLNativeDelegate.FNglUniform3i64vARB>("glUniform3i64vARB");
            _F(location, count, value);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_gpu_shader_int64</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glUniform4i64vARB(GLint location, GLsizei count, const GLint64 * value);</para>
        /// </summary>
        public unsafe static void glUniform4i64vARB(int location, int count, Int64* value) {
            var _F = _GetProc<GLNativeDelegate.FNglUniform4i64vARB>("glUniform4i64vARB");
            _F(location, count, value);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_gpu_shader_int64</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glUniform1ui64ARB(GLint location, GLuint64 x);</para>
        /// </summary>
        public static void glUniform1ui64ARB(int location, UInt64 x) {
            var _F = _GetProc<GLNativeDelegate.FNglUniform1ui64ARB>("glUniform1ui64ARB");
            _F(location, x);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_gpu_shader_int64</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glUniform2ui64ARB(GLint location, GLuint64 x, GLuint64 y);</para>
        /// </summary>
        public static void glUniform2ui64ARB(int location, UInt64 x, UInt64 y) {
            var _F = _GetProc<GLNativeDelegate.FNglUniform2ui64ARB>("glUniform2ui64ARB");
            _F(location, x, y);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_gpu_shader_int64</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glUniform3ui64ARB(GLint location, GLuint64 x, GLuint64 y, GLuint64 z);</para>
        /// </summary>
        public static void glUniform3ui64ARB(int location, UInt64 x, UInt64 y, UInt64 z) {
            var _F = _GetProc<GLNativeDelegate.FNglUniform3ui64ARB>("glUniform3ui64ARB");
            _F(location, x, y, z);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_gpu_shader_int64</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glUniform4ui64ARB(GLint location, GLuint64 x, GLuint64 y, GLuint64 z, GLuint64 w);</para>
        /// </summary>
        public static void glUniform4ui64ARB(int location, UInt64 x, UInt64 y, UInt64 z, UInt64 w) {
            var _F = _GetProc<GLNativeDelegate.FNglUniform4ui64ARB>("glUniform4ui64ARB");
            _F(location, x, y, z, w);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_gpu_shader_int64</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glUniform1ui64vARB(GLint location, GLsizei count, const GLuint64 * value);</para>
        /// </summary>
        public unsafe static void glUniform1ui64vARB(int location, int count, UInt64* value) {
            var _F = _GetProc<GLNativeDelegate.FNglUniform1ui64vARB>("glUniform1ui64vARB");
            _F(location, count, value);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_gpu_shader_int64</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glUniform2ui64vARB(GLint location, GLsizei count, const GLuint64 * value);</para>
        /// </summary>
        public unsafe static void glUniform2ui64vARB(int location, int count, UInt64* value) {
            var _F = _GetProc<GLNativeDelegate.FNglUniform2ui64vARB>("glUniform2ui64vARB");
            _F(location, count, value);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_gpu_shader_int64</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glUniform3ui64vARB(GLint location, GLsizei count, const GLuint64 * value);</para>
        /// </summary>
        public unsafe static void glUniform3ui64vARB(int location, int count, UInt64* value) {
            var _F = _GetProc<GLNativeDelegate.FNglUniform3ui64vARB>("glUniform3ui64vARB");
            _F(location, count, value);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_gpu_shader_int64</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glUniform4ui64vARB(GLint location, GLsizei count, const GLuint64 * value);</para>
        /// </summary>
        public unsafe static void glUniform4ui64vARB(int location, int count, UInt64* value) {
            var _F = _GetProc<GLNativeDelegate.FNglUniform4ui64vARB>("glUniform4ui64vARB");
            _F(location, count, value);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_gpu_shader_int64</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetUniformi64vARB(GLuint program, GLint location, GLint64 * params);</para>
        /// </summary>
        public unsafe static void glGetUniformi64vARB(uint program, int location, UInt64* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetUniformi64vARB>("glGetUniformi64vARB");
            _F(program, location, ps);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_gpu_shader_int64</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetUniformui64vARB(GLuint program, GLint location, GLuint64 * params);</para>
        /// </summary>
        public unsafe static void glGetUniformui64vARB(uint program, int location, UInt64* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetUniformui64vARB>("glGetUniformui64vARB");
            _F(program, location, ps);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_gpu_shader_int64</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetnUniformi64vARB(GLuint program, GLint location, GLsizei bufSize, GLint64 * params);</para>
        /// </summary>
        public unsafe static void glGetnUniformi64vARB(uint program, int location, int bufSize, UInt64* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetnUniformi64vARB>("glGetnUniformi64vARB");
            _F(program, location, bufSize, ps);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_gpu_shader_int64</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetnUniformui64vARB(GLuint program, GLint location, GLsizei bufSize, GLuint64 * params);</para>
        /// </summary>
        public unsafe static void glGetnUniformui64vARB(uint program, int location, int bufSize, UInt64* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetnUniformui64vARB>("glGetnUniformui64vARB");
            _F(program, location, bufSize, ps);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_gpu_shader_int64</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glProgramUniform1i64ARB(GLuint program, GLint location, GLint64 x);</para>
        /// </summary>
        public static void glProgramUniform1i64ARB(uint program, int location, Int64 x) {
            var _F = _GetProc<GLNativeDelegate.FNglProgramUniform1i64ARB>("glProgramUniform1i64ARB");
            _F(program, location, x);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_gpu_shader_int64</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glProgramUniform2i64ARB(GLuint program, GLint location, GLint64 x, GLint64 y);</para>
        /// </summary>
        public static void glProgramUniform2i64ARB(uint program, int location, Int64 x, Int64 y) {
            var _F = _GetProc<GLNativeDelegate.FNglProgramUniform2i64ARB>("glProgramUniform2i64ARB");
            _F(program, location, x, y);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_gpu_shader_int64</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glProgramUniform3i64ARB(GLuint program, GLint location, GLint64 x, GLint64 y, GLint64 z);</para>
        /// </summary>
        public static void glProgramUniform3i64ARB(uint program, int location, Int64 x, Int64 y, Int64 z) {
            var _F = _GetProc<GLNativeDelegate.FNglProgramUniform3i64ARB>("glProgramUniform3i64ARB");
            _F(program, location, x, y, z);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_gpu_shader_int64</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glProgramUniform4i64ARB(GLuint program, GLint location, GLint64 x, GLint64 y, GLint64 z, GLint64 w);</para>
        /// </summary>
        public static void glProgramUniform4i64ARB(uint program, int location, Int64 x, Int64 y, Int64 z, Int64 w) {
            var _F = _GetProc<GLNativeDelegate.FNglProgramUniform4i64ARB>("glProgramUniform4i64ARB");
            _F(program, location, x, y, z, w);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_gpu_shader_int64</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glProgramUniform1i64vARB(GLuint program, GLint location, GLsizei count, const GLint64 * value);</para>
        /// </summary>
        public unsafe static void glProgramUniform1i64vARB(uint program, int location, int count, Int64* value) {
            var _F = _GetProc<GLNativeDelegate.FNglProgramUniform1i64vARB>("glProgramUniform1i64vARB");
            _F(program, location, count, value);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_gpu_shader_int64</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glProgramUniform2i64vARB(GLuint program, GLint location, GLsizei count, const GLint64 * value);</para>
        /// </summary>
        public unsafe static void glProgramUniform2i64vARB(uint program, int location, int count, Int64* value) {
            var _F = _GetProc<GLNativeDelegate.FNglProgramUniform2i64vARB>("glProgramUniform2i64vARB");
            _F(program, location, count, value);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_gpu_shader_int64</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glProgramUniform3i64vARB(GLuint program, GLint location, GLsizei count, const GLint64 * value);</para>
        /// </summary>
        public unsafe static void glProgramUniform3i64vARB(uint program, int location, int count, Int64* value) {
            var _F = _GetProc<GLNativeDelegate.FNglProgramUniform3i64vARB>("glProgramUniform3i64vARB");
            _F(program, location, count, value);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_gpu_shader_int64</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glProgramUniform4i64vARB(GLuint program, GLint location, GLsizei count, const GLint64 * value);</para>
        /// </summary>
        public unsafe static void glProgramUniform4i64vARB(uint program, int location, int count, Int64* value) {
            var _F = _GetProc<GLNativeDelegate.FNglProgramUniform4i64vARB>("glProgramUniform4i64vARB");
            _F(program, location, count, value);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_gpu_shader_int64</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glProgramUniform1ui64ARB(GLuint program, GLint location, GLuint64 x);</para>
        /// </summary>
        public static void glProgramUniform1ui64ARB(uint program, int location, UInt64 x) {
            var _F = _GetProc<GLNativeDelegate.FNglProgramUniform1ui64ARB>("glProgramUniform1ui64ARB");
            _F(program, location, x);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_gpu_shader_int64</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glProgramUniform2ui64ARB(GLuint program, GLint location, GLuint64 x, GLuint64 y);</para>
        /// </summary>
        public static void glProgramUniform2ui64ARB(uint program, int location, UInt64 x, UInt64 y) {
            var _F = _GetProc<GLNativeDelegate.FNglProgramUniform2ui64ARB>("glProgramUniform2ui64ARB");
            _F(program, location, x, y);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_gpu_shader_int64</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glProgramUniform3ui64ARB(GLuint program, GLint location, GLuint64 x, GLuint64 y, GLuint64 z);</para>
        /// </summary>
        public static void glProgramUniform3ui64ARB(uint program, int location, UInt64 x, UInt64 y, UInt64 z) {
            var _F = _GetProc<GLNativeDelegate.FNglProgramUniform3ui64ARB>("glProgramUniform3ui64ARB");
            _F(program, location, x, y, z);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_gpu_shader_int64</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glProgramUniform4ui64ARB(GLuint program, GLint location, GLuint64 x, GLuint64 y, GLuint64 z, GLuint64 w);</para>
        /// </summary>
        public static void glProgramUniform4ui64ARB(uint program, int location, UInt64 x, UInt64 y, UInt64 z, UInt64 w) {
            var _F = _GetProc<GLNativeDelegate.FNglProgramUniform4ui64ARB>("glProgramUniform4ui64ARB");
            _F(program, location, x, y, z, w);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_gpu_shader_int64</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glProgramUniform1ui64vARB(GLuint program, GLint location, GLsizei count, const GLuint64 * value);</para>
        /// </summary>
        public unsafe static void glProgramUniform1ui64vARB(uint program, int location, int count, UInt64* value) {
            var _F = _GetProc<GLNativeDelegate.FNglProgramUniform1ui64vARB>("glProgramUniform1ui64vARB");
            _F(program, location, count, value);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_gpu_shader_int64</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glProgramUniform2ui64vARB(GLuint program, GLint location, GLsizei count, const GLuint64 * value);</para>
        /// </summary>
        public unsafe static void glProgramUniform2ui64vARB(uint program, int location, int count, UInt64* value) {
            var _F = _GetProc<GLNativeDelegate.FNglProgramUniform2ui64vARB>("glProgramUniform2ui64vARB");
            _F(program, location, count, value);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_gpu_shader_int64</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glProgramUniform3ui64vARB(GLuint program, GLint location, GLsizei count, const GLuint64 * value);</para>
        /// </summary>
        public unsafe static void glProgramUniform3ui64vARB(uint program, int location, int count, UInt64* value) {
            var _F = _GetProc<GLNativeDelegate.FNglProgramUniform3ui64vARB>("glProgramUniform3ui64vARB");
            _F(program, location, count, value);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_gpu_shader_int64</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glProgramUniform4ui64vARB(GLuint program, GLint location, GLsizei count, const GLuint64 * value);</para>
        /// </summary>
        public unsafe static void glProgramUniform4ui64vARB(uint program, int location, int count, UInt64* value) {
            var _F = _GetProc<GLNativeDelegate.FNglProgramUniform4ui64vARB>("glProgramUniform4ui64vARB");
            _F(program, location, count, value);
        }

        #endregion GL_ARB_gpu_shader_int64

        #region GL_ARB_imaging

        // void glBlendColor(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha);
        // void glBlendEquation(GLenum mode);
        /// <summary>
        /// define a color lookup table
        /// <para>Require:</para> <para>GL_ARB_imaging</para>
        /// Supported: <para>gl, glcore</para>
        /// Notes: 
        /// <para>
        /// <see cref="glColorTable"/> is present only if <code>ARB_imaging</code> is returned when  <see cref="glGetString"/> 
        /// is called with an argument of <code>GL_EXTENSIONS</code>.
        /// If <paramref name="target"/> is set to <code>GL_COLOR_TABLE</code>,
        /// <code>GL_POST_CONVOLUTION_COLOR_TABLE</code>,
        /// or <code>GL_POST_COLOR_MATRIX_COLOR_TABLE</code>,
        /// then <paramref name="width"/> must be a power of two or a <code>GL_INVALID_VALUE</code>
        /// error is generated.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="target"/> is not one of the allowable
        /// values.
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="internalformat"/> is not one of the
        /// allowable values.
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="format"/> is not one of the allowable
        /// values.
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="type"/> is not one of the allowable
        /// values.
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="width"/> is less than zero.
        /// <code>GL_TABLE_TOO_LARGE</code> is generated if the requested color table
        /// is too large to be supported by the implementation, and <paramref name="target"/> is
        /// not a <code>GL_PROXY_*</code> target.
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_UNPACK_BUFFER</code> target and the buffer object's data store is currently mapped.
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_UNPACK_BUFFER</code> target and the data would be unpacked from the buffer 
        /// object such that the memory reads required would exceed the data store size.
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_UNPACK_BUFFER</code> target and <paramref name="data"/> is not evenly divisible 
        /// into the number of bytes needed to store in memory a datum indicated by <paramref name="type"/>.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glColorTable"/> is executed
        /// between the execution of  <see cref="glBegin"/>  and the corresponding
        /// execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glColorTable(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const void * data);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Must be one of
        /// <code>GL_COLOR_TABLE</code>,
        /// <code>GL_POST_CONVOLUTION_COLOR_TABLE</code>,
        /// <code>GL_POST_COLOR_MATRIX_COLOR_TABLE</code>,
        /// <code>GL_PROXY_COLOR_TABLE</code>,
        /// <code>GL_PROXY_POST_CONVOLUTION_COLOR_TABLE</code>,
        /// or
        /// <code>GL_PROXY_POST_COLOR_MATRIX_COLOR_TABLE</code>.
        /// </para>
        /// </param>
        /// <param name="internalformat">
        /// <para>
        /// The internal format of the color table.
        /// The allowable values are
        /// <code>GL_ALPHA</code>,
        /// <code>GL_ALPHA4</code>,
        /// <code>GL_ALPHA8</code>,
        /// <code>GL_ALPHA12</code>,
        /// <code>GL_ALPHA16</code>,
        /// <code>GL_LUMINANCE</code>,
        /// <code>GL_LUMINANCE4</code>,
        /// <code>GL_LUMINANCE8</code>,
        /// <code>GL_LUMINANCE12</code>,
        /// <code>GL_LUMINANCE16</code>,
        /// <code>GL_LUMINANCE_ALPHA</code>,
        /// <code>GL_LUMINANCE4_ALPHA4</code>,
        /// <code>GL_LUMINANCE6_ALPHA2</code>,
        /// <code>GL_LUMINANCE8_ALPHA8</code>,
        /// <code>GL_LUMINANCE12_ALPHA4</code>,
        /// <code>GL_LUMINANCE12_ALPHA12</code>,
        /// <code>GL_LUMINANCE16_ALPHA16</code>,
        /// <code>GL_INTENSITY</code>,
        /// <code>GL_INTENSITY4</code>,
        /// <code>GL_INTENSITY8</code>,
        /// <code>GL_INTENSITY12</code>,
        /// <code>GL_INTENSITY16</code>,
        /// <code>GL_R3_G3_B2</code>,
        /// <code>GL_RGB</code>,
        /// <code>GL_RGB4</code>,
        /// <code>GL_RGB5</code>,
        /// <code>GL_RGB8</code>,
        /// <code>GL_RGB10</code>,
        /// <code>GL_RGB12</code>,
        /// <code>GL_RGB16</code>,
        /// <code>GL_RGBA</code>,
        /// <code>GL_RGBA2</code>,
        /// <code>GL_RGBA4</code>,
        /// <code>GL_RGB5_A1</code>,
        /// <code>GL_RGBA8</code>,
        /// <code>GL_RGB10_A2</code>,
        /// <code>GL_RGBA12</code>, and
        /// <code>GL_RGBA16</code>.
        /// </para>
        /// </param>
        /// <param name="width">
        /// The number of entries in the color lookup table specified by <paramref name="data"/>.
        /// </param>
        /// <param name="format">
        /// <para>
        /// The format of the pixel data in <paramref name="data"/>.
        /// The allowable values are
        /// <code>GL_RED</code>,
        /// <code>GL_GREEN</code>,
        /// <code>GL_BLUE</code>,
        /// <code>GL_ALPHA</code>,
        /// <code>GL_LUMINANCE</code>,
        /// <code>GL_LUMINANCE_ALPHA</code>,
        /// <code>GL_RGB</code>,
        /// <code>GL_BGR</code>,
        /// <code>GL_RGBA</code>, and
        /// <code>GL_BGRA</code>.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// The type of the pixel data in <paramref name="data"/>.
        /// The allowable values are
        /// <code>GL_UNSIGNED_BYTE</code>,
        /// <code>GL_BYTE</code>,
        /// <code>GL_UNSIGNED_SHORT</code>,
        /// <code>GL_SHORT</code>,
        /// <code>GL_UNSIGNED_INT</code>,
        /// <code>GL_INT</code>,
        /// <code>GL_FLOAT</code>,
        /// <code>GL_UNSIGNED_BYTE_3_3_2</code>,
        /// <code>GL_UNSIGNED_BYTE_2_3_3_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_5_6_5</code>,
        /// <code>GL_UNSIGNED_SHORT_5_6_5_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_4_4_4_4</code>,
        /// <code>GL_UNSIGNED_SHORT_4_4_4_4_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_5_5_5_1</code>,
        /// <code>GL_UNSIGNED_SHORT_1_5_5_5_REV</code>,
        /// <code>GL_UNSIGNED_INT_8_8_8_8</code>,
        /// <code>GL_UNSIGNED_INT_8_8_8_8_REV</code>,
        /// <code>GL_UNSIGNED_INT_10_10_10_2</code>, and
        /// <code>GL_UNSIGNED_INT_2_10_10_10_REV</code>.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Pointer to a one-dimensional array of pixel data that is processed to
        /// build the color table.
        /// </para>
        /// </param>
        /// <seealso cref="glColorSubTable"/>
        /// <seealso cref="glColorTableParameter"/>
        /// <seealso cref="glCopyColorTable"/>
        /// <seealso cref="glCopyColorSubTable"/>
        /// <seealso cref="glGetColorTable"/>
        public unsafe static void glColorTable(uint target, uint internalformat, int width, uint format, uint type, void* data) {
            var _F = _GetProc<GLNativeDelegate.FNglColorTable>("glColorTable");
            _F(target, internalformat, width, format, type, data);
        }
        /// <summary>
        /// set color lookup table parameters
        /// <para>Require:</para> <para>GL_ARB_imaging</para>
        /// Supported: <para>gl, glcore</para>
        /// Notes: 
        /// <para>
        /// <see cref="glColorTableParameter"/> is available only if <code>ARB_imaging</code> is returned from calling
        /// <see cref="glGetString"/>  with an argument of <code>GL_EXTENSIONS</code>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="target"/> or <paramref name="pname"/> is not
        /// an acceptable value.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glColorTableParameter"/> is executed
        /// between the execution of  <see cref="glBegin"/>  and the corresponding
        /// execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glColorTableParameterfv(GLenum target, GLenum pname, const GLfloat * params);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// The target color table.
        /// Must be
        /// <code>GL_COLOR_TABLE</code>,
        /// <code>GL_POST_CONVOLUTION_COLOR_TABLE</code>, or
        /// <code>GL_POST_COLOR_MATRIX_COLOR_TABLE</code>.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// The symbolic name of a texture color lookup table parameter.
        /// Must be one of
        /// <code>GL_COLOR_TABLE_SCALE</code> or
        /// <code>GL_COLOR_TABLE_BIAS</code>.
        /// </para>
        /// </param>
        /// <param name="ps">
        /// A pointer to an array where the values of the parameters are stored.
        /// </param>
        /// <seealso cref="glColorTable"/>
        /// <seealso cref="glPixelTransfer"/>
        public unsafe static void glColorTableParameterfv(uint target, uint pname, float* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglColorTableParameterfv>("glColorTableParameterfv");
            _F(target, pname, ps);
        }
        /// <summary>
        /// set color lookup table parameters
        /// <para>Require:</para> <para>GL_ARB_imaging</para>
        /// Supported: <para>gl, glcore</para>
        /// Notes: 
        /// <para>
        /// <see cref="glColorTableParameter"/> is available only if <code>ARB_imaging</code> is returned from calling
        /// <see cref="glGetString"/>  with an argument of <code>GL_EXTENSIONS</code>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="target"/> or <paramref name="pname"/> is not
        /// an acceptable value.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glColorTableParameter"/> is executed
        /// between the execution of  <see cref="glBegin"/>  and the corresponding
        /// execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glColorTableParameteriv(GLenum target, GLenum pname, const GLint * params);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// The target color table.
        /// Must be
        /// <code>GL_COLOR_TABLE</code>,
        /// <code>GL_POST_CONVOLUTION_COLOR_TABLE</code>, or
        /// <code>GL_POST_COLOR_MATRIX_COLOR_TABLE</code>.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// The symbolic name of a texture color lookup table parameter.
        /// Must be one of
        /// <code>GL_COLOR_TABLE_SCALE</code> or
        /// <code>GL_COLOR_TABLE_BIAS</code>.
        /// </para>
        /// </param>
        /// <param name="ps">
        /// A pointer to an array where the values of the parameters are stored.
        /// </param>
        /// <seealso cref="glColorTable"/>
        /// <seealso cref="glPixelTransfer"/>
        public unsafe static void glColorTableParameteriv(uint target, uint pname, int* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglColorTableParameteriv>("glColorTableParameteriv");
            _F(target, pname, ps);
        }
        /// <summary>
        /// copy pixels into a color table
        /// <para>Require:</para> <para>GL_ARB_imaging</para>
        /// Supported: <para>gl, glcore</para>
        /// Notes: 
        /// <para>
        /// <see cref="glCopyColorTable"/> is available only if <code>ARB_imaging</code> is returned from calling
        /// <see cref="glGetString"/>  with an argument of <code>GL_EXTENSIONS</code>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated when <paramref name="target"/> is not one of the
        /// allowable values.
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="width"/> is less than zero.
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="internalformat"/> is not one of the
        /// allowable values.
        /// <code>GL_TABLE_TOO_LARGE</code> is generated if the requested color table
        /// is too large to be supported by the implementation.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glCopyColorTable"/> is executed
        /// between the execution of  <see cref="glBegin"/>  and the corresponding
        /// execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glCopyColorTable(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// The color table target. Must be
        /// <code>GL_COLOR_TABLE</code>,
        /// <code>GL_POST_CONVOLUTION_COLOR_TABLE</code>,
        /// or <code>GL_POST_COLOR_MATRIX_COLOR_TABLE</code>.
        /// </para>
        /// </param>
        /// <param name="internalformat">
        /// <para>
        /// The internal storage format of the texture image.
        /// Must be one of the following symbolic constants:
        /// <code>GL_ALPHA</code>,
        /// <code>GL_ALPHA4</code>,
        /// <code>GL_ALPHA8</code>,
        /// <code>GL_ALPHA12</code>,
        /// <code>GL_ALPHA16</code>,
        /// <code>GL_LUMINANCE</code>,
        /// <code>GL_LUMINANCE4</code>,
        /// <code>GL_LUMINANCE8</code>,
        /// <code>GL_LUMINANCE12</code>,
        /// <code>GL_LUMINANCE16</code>,
        /// <code>GL_LUMINANCE_ALPHA</code>,
        /// <code>GL_LUMINANCE4_ALPHA4</code>,
        /// <code>GL_LUMINANCE6_ALPHA2</code>,
        /// <code>GL_LUMINANCE8_ALPHA8</code>,
        /// <code>GL_LUMINANCE12_ALPHA4</code>,
        /// <code>GL_LUMINANCE12_ALPHA12</code>,
        /// <code>GL_LUMINANCE16_ALPHA16</code>,
        /// <code>GL_INTENSITY</code>,
        /// <code>GL_INTENSITY4</code>,
        /// <code>GL_INTENSITY8</code>,
        /// <code>GL_INTENSITY12</code>,
        /// <code>GL_INTENSITY16</code>,
        /// <code>GL_R3_G3_B2</code>,
        /// <code>GL_RGB</code>,
        /// <code>GL_RGB4</code>,
        /// <code>GL_RGB5</code>,
        /// <code>GL_RGB8</code>,
        /// <code>GL_RGB10</code>,
        /// <code>GL_RGB12</code>,
        /// <code>GL_RGB16</code>,
        /// <code>GL_RGBA</code>,
        /// <code>GL_RGBA2</code>,
        /// <code>GL_RGBA4</code>,
        /// <code>GL_RGB5_A1</code>,
        /// <code>GL_RGBA8</code>,
        /// <code>GL_RGB10_A2</code>,
        /// <code>GL_RGBA12</code>, or
        /// <code>GL_RGBA16</code>.
        /// </para>
        /// </param>
        /// <param name="x">
        /// <para>
        /// The x coordinate of the lower-left corner of the pixel rectangle
        /// to be transferred to the color table.
        /// </para>
        /// </param>
        /// <param name="y">
        /// <para>
        /// The y coordinate of the lower-left corner of the pixel rectangle
        /// to be transferred to the color table.
        /// </para>
        /// </param>
        /// <param name="width">
        /// The width of the pixel rectangle.
        /// </param>
        /// <seealso cref="glColorTable"/>
        /// <seealso cref="glColorTableParameter"/>
        /// <seealso cref="glReadPixels"/>
        public static void glCopyColorTable(uint target, uint internalformat, int x, int y, int width) {
            var _F = _GetProc<GLNativeDelegate.FNglCopyColorTable>("glCopyColorTable");
            _F(target, internalformat, x, y, width);
        }
        /// <summary>
        /// retrieve contents of a color lookup table
        /// <para>Require:</para> <para>GL_ARB_imaging</para>
        /// Supported: <para>gl, glcore</para>
        /// Notes: 
        /// <para>
        /// <see cref="glGetColorTable"/> is present only if <code>ARB_imaging</code> is returned when  <see cref="glGetString"/> 
        /// is called with an argument of <code>GL_EXTENSIONS</code>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="target"/> is not one of the allowable
        /// values.
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="format"/> is not one of the allowable
        /// values.
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="type"/> is not one of the allowable
        /// values.
        /// <code>GL_INVALID_OPERATION</code> is generated if <paramref name="type"/> is one of
        /// <code>GL_UNSIGNED_BYTE_3_3_2</code>,
        /// <code>GL_UNSIGNED_BYTE_2_3_3_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_5_6_5</code>, or
        /// <code>GL_UNSIGNED_SHORT_5_6_5_REV</code>
        /// and <paramref name="format"/> is not <code>GL_RGB</code>.
        /// <code>GL_INVALID_OPERATION</code> is generated if <paramref name="type"/> is one of
        /// <code>GL_UNSIGNED_SHORT_4_4_4_4</code>,
        /// <code>GL_UNSIGNED_SHORT_4_4_4_4_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_5_5_5_1</code>,
        /// <code>GL_UNSIGNED_SHORT_1_5_5_5_REV</code>,
        /// <code>GL_UNSIGNED_INT_8_8_8_8</code>,
        /// <code>GL_UNSIGNED_INT_8_8_8_8_REV</code>,
        /// <code>GL_UNSIGNED_INT_10_10_10_2</code>, or
        /// <code>GL_UNSIGNED_INT_2_10_10_10_REV</code>
        /// and <paramref name="format"/> is neither <code>GL_RGBA</code> nor <code>GL_BGRA</code>.
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_PACK_BUFFER</code> target and the buffer object's data store is currently mapped.
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_PACK_BUFFER</code> target and the data would be packed to the buffer 
        /// object such that the memory writes required would exceed the data store size.
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_PACK_BUFFER</code> target and <paramref name="table"/> is not evenly divisible 
        /// into the number of bytes needed to store in memory a datum indicated by <paramref name="type"/>.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glGetColorTable"/> is executed
        /// between the execution of  <see cref="glBegin"/>  and the corresponding
        /// execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glGetColorTable(GLenum target, GLenum format, GLenum type, void * table);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Must be <code>GL_COLOR_TABLE</code>,
        /// <code>GL_POST_CONVOLUTION_COLOR_TABLE</code>,
        /// or
        /// <code>GL_POST_COLOR_MATRIX_COLOR_TABLE</code>.
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// The format of the pixel data in <paramref name="table"/>.
        /// The possible values are
        /// <code>GL_RED</code>,
        /// <code>GL_GREEN</code>,
        /// <code>GL_BLUE</code>,
        /// <code>GL_ALPHA</code>,
        /// <code>GL_LUMINANCE</code>,
        /// <code>GL_LUMINANCE_ALPHA</code>,
        /// <code>GL_RGB</code>,
        /// <code>GL_BGR</code>,
        /// <code>GL_RGBA</code>, and
        /// <code>GL_BGRA</code>.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// The type of the pixel data in <paramref name="table"/>.
        /// Symbolic constants
        /// <code>GL_UNSIGNED_BYTE</code>,
        /// <code>GL_BYTE</code>,
        /// <code>GL_BITMAP</code>,
        /// <code>GL_UNSIGNED_SHORT</code>,
        /// <code>GL_SHORT</code>,
        /// <code>GL_UNSIGNED_INT</code>,
        /// <code>GL_INT</code>,
        /// <code>GL_FLOAT</code>,
        /// <code>GL_UNSIGNED_BYTE_3_3_2</code>,
        /// <code>GL_UNSIGNED_BYTE_2_3_3_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_5_6_5</code>,
        /// <code>GL_UNSIGNED_SHORT_5_6_5_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_4_4_4_4</code>,
        /// <code>GL_UNSIGNED_SHORT_4_4_4_4_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_5_5_5_1</code>,
        /// <code>GL_UNSIGNED_SHORT_1_5_5_5_REV</code>,
        /// <code>GL_UNSIGNED_INT_8_8_8_8</code>,
        /// <code>GL_UNSIGNED_INT_8_8_8_8_REV</code>,
        /// <code>GL_UNSIGNED_INT_10_10_10_2</code>, and
        /// <code>GL_UNSIGNED_INT_2_10_10_10_REV</code>
        /// are accepted.
        /// </para>
        /// </param>
        /// <param name="table">
        /// <para>
        /// Pointer to a one-dimensional array of pixel data containing the contents
        /// of the color table.
        /// </para>
        /// </param>
        /// <seealso cref="glColorTable"/>
        /// <seealso cref="glColorTableParameter"/>
        public unsafe static void glGetColorTable(uint target, uint format, uint type, void* table) {
            var _F = _GetProc<GLNativeDelegate.FNglGetColorTable>("glGetColorTable");
            _F(target, format, type, table);
        }
        /// <summary>
        /// get color lookup table parameters
        /// <para>Require:</para> <para>GL_ARB_imaging</para>
        /// Supported: <para>gl, glcore</para>
        /// Notes: 
        /// <para>
        /// <see cref="glGetColorTableParameter"/> is present only if <code>ARB_imaging</code> is returned when  <see cref="glGetString"/> 
        /// is called with an argument of <code>GL_EXTENSIONS</code>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="target"/> or <paramref name="pname"/> is not
        /// an acceptable value.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glGetColorTableParameter"/> is executed
        /// between the execution of  <see cref="glBegin"/>  and the corresponding
        /// execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glGetColorTableParameterfv(GLenum target, GLenum pname, GLfloat * params);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// The target color table.
        /// Must be
        /// <code>GL_COLOR_TABLE</code>,
        /// <code>GL_POST_CONVOLUTION_COLOR_TABLE</code>,
        /// <code>GL_POST_COLOR_MATRIX_COLOR_TABLE</code>,
        /// <code>GL_PROXY_COLOR_TABLE</code>,
        /// <code>GL_PROXY_POST_CONVOLUTION_COLOR_TABLE</code>, or
        /// <code>GL_PROXY_POST_COLOR_MATRIX_COLOR_TABLE</code>.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// The symbolic name of a color lookup table parameter.
        /// Must be one of
        /// <code>GL_COLOR_TABLE_BIAS</code>,
        /// <code>GL_COLOR_TABLE_SCALE</code>,
        /// <code>GL_COLOR_TABLE_FORMAT</code>,
        /// <code>GL_COLOR_TABLE_WIDTH</code>,
        /// <code>GL_COLOR_TABLE_RED_SIZE</code>,
        /// <code>GL_COLOR_TABLE_GREEN_SIZE</code>,
        /// <code>GL_COLOR_TABLE_BLUE_SIZE</code>,
        /// <code>GL_COLOR_TABLE_ALPHA_SIZE</code>,
        /// <code>GL_COLOR_TABLE_LUMINANCE_SIZE</code>, or
        /// <code>GL_COLOR_TABLE_INTENSITY_SIZE</code>.
        /// </para>
        /// </param>
        /// <param name="ps">
        /// A pointer to an array where the values of the parameter will be stored.
        /// </param>
        /// <seealso cref="glColorTable"/>
        /// <seealso cref="glTexParameter"/>
        /// <seealso cref="glColorTableParameter"/>
        public unsafe static void glGetColorTableParameterfv(uint target, uint pname, float* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetColorTableParameterfv>("glGetColorTableParameterfv");
            _F(target, pname, ps);
        }
        /// <summary>
        /// get color lookup table parameters
        /// <para>Require:</para> <para>GL_ARB_imaging</para>
        /// Supported: <para>gl, glcore</para>
        /// Notes: 
        /// <para>
        /// <see cref="glGetColorTableParameter"/> is present only if <code>ARB_imaging</code> is returned when  <see cref="glGetString"/> 
        /// is called with an argument of <code>GL_EXTENSIONS</code>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="target"/> or <paramref name="pname"/> is not
        /// an acceptable value.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glGetColorTableParameter"/> is executed
        /// between the execution of  <see cref="glBegin"/>  and the corresponding
        /// execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glGetColorTableParameteriv(GLenum target, GLenum pname, GLint * params);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// The target color table.
        /// Must be
        /// <code>GL_COLOR_TABLE</code>,
        /// <code>GL_POST_CONVOLUTION_COLOR_TABLE</code>,
        /// <code>GL_POST_COLOR_MATRIX_COLOR_TABLE</code>,
        /// <code>GL_PROXY_COLOR_TABLE</code>,
        /// <code>GL_PROXY_POST_CONVOLUTION_COLOR_TABLE</code>, or
        /// <code>GL_PROXY_POST_COLOR_MATRIX_COLOR_TABLE</code>.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// The symbolic name of a color lookup table parameter.
        /// Must be one of
        /// <code>GL_COLOR_TABLE_BIAS</code>,
        /// <code>GL_COLOR_TABLE_SCALE</code>,
        /// <code>GL_COLOR_TABLE_FORMAT</code>,
        /// <code>GL_COLOR_TABLE_WIDTH</code>,
        /// <code>GL_COLOR_TABLE_RED_SIZE</code>,
        /// <code>GL_COLOR_TABLE_GREEN_SIZE</code>,
        /// <code>GL_COLOR_TABLE_BLUE_SIZE</code>,
        /// <code>GL_COLOR_TABLE_ALPHA_SIZE</code>,
        /// <code>GL_COLOR_TABLE_LUMINANCE_SIZE</code>, or
        /// <code>GL_COLOR_TABLE_INTENSITY_SIZE</code>.
        /// </para>
        /// </param>
        /// <param name="ps">
        /// A pointer to an array where the values of the parameter will be stored.
        /// </param>
        /// <seealso cref="glColorTable"/>
        /// <seealso cref="glTexParameter"/>
        /// <seealso cref="glColorTableParameter"/>
        public unsafe static void glGetColorTableParameteriv(uint target, uint pname, int* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetColorTableParameteriv>("glGetColorTableParameteriv");
            _F(target, pname, ps);
        }
        /// <summary>
        /// respecify a portion of a color table
        /// <para>Require:</para> <para>GL_ARB_imaging</para>
        /// Supported: <para>gl, glcore</para>
        /// Notes: 
        /// <para>
        /// <see cref="glColorSubTable"/> is present only if <code>ARB_imaging</code> is returned when  <see cref="glGetString"/> 
        /// is called with an argument of <code>GL_EXTENSIONS</code>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="target"/> is not one of the allowable
        /// values.
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="format"/> is not one of the allowable
        /// values.
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="type"/> is not one of the allowable
        /// values.
        /// <code>GL_INVALID_VALUE</code> is generated if 
        /// width:-->
        /// start 
        /// + 
        /// count 
        /// &gt; 
        /// width 
        /// .
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_UNPACK_BUFFER</code> target and the buffer object's data store is currently mapped.
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_UNPACK_BUFFER</code> target and the data would be unpacked from the buffer 
        /// object such that the memory reads required would exceed the data store size.
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_UNPACK_BUFFER</code> target and <paramref name="data"/> is not evenly divisible 
        /// into the number of bytes needed to store in memory a datum indicated by <paramref name="type"/>.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glColorSubTable"/> is executed
        /// between the execution of  <see cref="glBegin"/>  and the corresponding
        /// execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glColorSubTable(GLenum target, GLsizei start, GLsizei count, GLenum format, GLenum type, const void * data);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Must be one of
        /// <code>GL_COLOR_TABLE</code>,
        /// <code>GL_POST_CONVOLUTION_COLOR_TABLE</code>, or
        /// <code>GL_POST_COLOR_MATRIX_COLOR_TABLE</code>.
        /// </para>
        /// </param>
        /// <param name="start">
        /// The starting index of the portion of the color table to be replaced.
        /// </param>
        /// <param name="count">
        /// The number of table entries to replace.
        /// </param>
        /// <param name="format">
        /// <para>
        /// The format of the pixel data in <paramref name="data"/>.
        /// The allowable values are
        /// <code>GL_RED</code>,
        /// <code>GL_GREEN</code>,
        /// <code>GL_BLUE</code>,
        /// <code>GL_ALPHA</code>,
        /// <code>GL_LUMINANCE</code>,
        /// <code>GL_LUMINANCE_ALPHA</code>,
        /// <code>GL_RGB</code>,
        /// <code>GL_BGR</code>,
        /// <code>GL_RGBA</code>, and
        /// <code>GL_BGRA</code>.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// The type of the pixel data in <paramref name="data"/>.
        /// The allowable values are
        /// <code>GL_UNSIGNED_BYTE</code>,
        /// <code>GL_BYTE</code>,
        /// <code>GL_UNSIGNED_SHORT</code>,
        /// <code>GL_SHORT</code>,
        /// <code>GL_UNSIGNED_INT</code>,
        /// <code>GL_INT</code>,
        /// <code>GL_FLOAT</code>,
        /// <code>GL_UNSIGNED_BYTE_3_3_2</code>,
        /// <code>GL_UNSIGNED_BYTE_2_3_3_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_5_6_5</code>,
        /// <code>GL_UNSIGNED_SHORT_5_6_5_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_4_4_4_4</code>,
        /// <code>GL_UNSIGNED_SHORT_4_4_4_4_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_5_5_5_1</code>,
        /// <code>GL_UNSIGNED_SHORT_1_5_5_5_REV</code>,
        /// <code>GL_UNSIGNED_INT_8_8_8_8</code>,
        /// <code>GL_UNSIGNED_INT_8_8_8_8_REV</code>,
        /// <code>GL_UNSIGNED_INT_10_10_10_2</code>, and
        /// <code>GL_UNSIGNED_INT_2_10_10_10_REV</code>.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Pointer to a one-dimensional array of pixel data that is processed to
        /// replace the specified region of the color table.
        /// </para>
        /// </param>
        /// <seealso cref="glColorTable"/>
        /// <seealso cref="glColorTableParameter"/>
        /// <seealso cref="glCopyColorTable"/>
        /// <seealso cref="glCopyColorSubTable"/>
        /// <seealso cref="glGetColorTable"/>
        public unsafe static void glColorSubTable(uint target, int start, int count, uint format, uint type, void* data) {
            var _F = _GetProc<GLNativeDelegate.FNglColorSubTable>("glColorSubTable");
            _F(target, start, count, format, type, data);
        }
        /// <summary>
        /// respecify a portion of a color table
        /// <para>Require:</para> <para>GL_ARB_imaging</para>
        /// Supported: <para>gl, glcore</para>
        /// Notes: 
        /// <para>
        /// <see cref="glCopyColorSubTable"/> is present only if <code>ARB_imaging</code> is returned when  <see cref="glGetString"/> 
        /// is called with an argument of <code>GL_EXTENSIONS</code>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="target"/> is not a previously defined
        /// color table.
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="target"/> is not one of the allowable
        /// values.
        /// <code>GL_INVALID_VALUE</code> is generated if 
        /// width:-->
        /// start 
        /// + 
        /// x 
        /// &gt; 
        /// width 
        /// .
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glCopyColorSubTable"/> is executed
        /// between the execution of  <see cref="glBegin"/>  and the corresponding
        /// execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glCopyColorSubTable(GLenum target, GLsizei start, GLint x, GLint y, GLsizei width);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Must be one of
        /// <code>GL_COLOR_TABLE</code>,
        /// <code>GL_POST_CONVOLUTION_COLOR_TABLE</code>, or
        /// <code>GL_POST_COLOR_MATRIX_COLOR_TABLE</code>.
        /// </para>
        /// </param>
        /// <param name="start">
        /// The starting index of the portion of the color table to be replaced.
        /// </param>
        /// <param name="x">
        /// <para>
        /// The window coordinates of the left corner of the row of pixels to be
        /// copied.
        /// </para>
        /// </param>
        /// <param name="y">
        /// <para>
        /// The window coordinates of the left corner of the row of pixels to be
        /// copied.
        /// </para>
        /// </param>
        /// <param name="width">
        /// The number of table entries to replace.
        /// </param>
        /// <seealso cref="glColorSubTable"/>
        /// <seealso cref="glColorTableParameter"/>
        /// <seealso cref="glCopyColorTable"/>
        /// <seealso cref="glCopyColorSubTable"/>
        /// <seealso cref="glGetColorTable"/>
        public static void glCopyColorSubTable(uint target, int start, int x, int y, int width) {
            var _F = _GetProc<GLNativeDelegate.FNglCopyColorSubTable>("glCopyColorSubTable");
            _F(target, start, x, y, width);
        }
        /// <summary>
        /// define a one-dimensional convolution filter
        /// <para>Require:</para> <para>GL_ARB_imaging</para>
        /// Supported: <para>gl, glcore</para>
        /// Notes: 
        /// <para>
        /// <see cref="glConvolutionFilter1D"/> is present only if <code>ARB_imaging</code> is returned when  <see cref="glGetString"/> 
        /// is called with an argument of <code>GL_EXTENSIONS</code>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="target"/> is not
        /// <code>GL_CONVOLUTION_1D</code>.
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="internalformat"/> is not one of the
        /// allowable values.
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="format"/> is not one of the allowable
        /// values.
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="type"/> is not one of the allowable
        /// values.
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="width"/> is less than zero or greater
        /// than the maximum supported value.
        /// This value may be queried with  <see cref="glGetConvolutionParameter"/> 
        /// using target <code>GL_CONVOLUTION_1D</code> and name
        /// <code>GL_MAX_CONVOLUTION_WIDTH</code>.
        /// <code>GL_INVALID_OPERATION</code> is generated if <paramref name="type"/> is one of
        /// <code>GL_UNSIGNED_BYTE_3_3_2</code>,
        /// <code>GL_UNSIGNED_BYTE_2_3_3_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_5_6_5</code>, or
        /// <code>GL_UNSIGNED_SHORT_5_6_5_REV</code>
        /// and <paramref name="format"/> is not <code>GL_RGB</code>.
        /// <code>GL_INVALID_OPERATION</code> is generated if <paramref name="type"/> is one of
        /// <code>GL_UNSIGNED_SHORT_4_4_4_4</code>,
        /// <code>GL_UNSIGNED_SHORT_4_4_4_4_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_5_5_5_1</code>,
        /// <code>GL_UNSIGNED_SHORT_1_5_5_5_REV</code>,
        /// <code>GL_UNSIGNED_INT_8_8_8_8</code>,
        /// <code>GL_UNSIGNED_INT_8_8_8_8_REV</code>,
        /// <code>GL_UNSIGNED_INT_10_10_10_2</code>, or
        /// <code>GL_UNSIGNED_INT_2_10_10_10_REV</code>
        /// and <paramref name="format"/> is neither <code>GL_RGBA</code> nor <code>GL_BGRA</code>.
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_UNPACK_BUFFER</code> target and the buffer object's data store is currently mapped.
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_UNPACK_BUFFER</code> target and the data would be unpacked from the buffer 
        /// object such that the memory reads required would exceed the data store size.
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_UNPACK_BUFFER</code> target and <paramref name="data"/> is not evenly divisible 
        /// into the number of bytes needed to store in memory a datum indicated by <paramref name="type"/>.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glConvolutionFilter1D"/> is executed
        /// between the execution of  <see cref="glBegin"/>  and the corresponding
        /// execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glConvolutionFilter1D(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const void * data);</para>
        /// </summary>
        /// <param name="target">
        /// Must be <code>GL_CONVOLUTION_1D</code>.
        /// </param>
        /// <param name="internalformat">
        /// <para>
        /// The internal format of the convolution filter kernel.
        /// The allowable values are
        /// <code>GL_ALPHA</code>,
        /// <code>GL_ALPHA4</code>,
        /// <code>GL_ALPHA8</code>,
        /// <code>GL_ALPHA12</code>,
        /// <code>GL_ALPHA16</code>,
        /// <code>GL_LUMINANCE</code>,
        /// <code>GL_LUMINANCE4</code>,
        /// <code>GL_LUMINANCE8</code>,
        /// <code>GL_LUMINANCE12</code>,
        /// <code>GL_LUMINANCE16</code>,
        /// <code>GL_LUMINANCE_ALPHA</code>,
        /// <code>GL_LUMINANCE4_ALPHA4</code>,
        /// <code>GL_LUMINANCE6_ALPHA2</code>,
        /// <code>GL_LUMINANCE8_ALPHA8</code>,
        /// <code>GL_LUMINANCE12_ALPHA4</code>,
        /// <code>GL_LUMINANCE12_ALPHA12</code>,
        /// <code>GL_LUMINANCE16_ALPHA16</code>,
        /// <code>GL_INTENSITY</code>,
        /// <code>GL_INTENSITY4</code>,
        /// <code>GL_INTENSITY8</code>,
        /// <code>GL_INTENSITY12</code>,
        /// <code>GL_INTENSITY16</code>,
        /// <code>GL_R3_G3_B2</code>,
        /// <code>GL_RGB</code>,
        /// <code>GL_RGB4</code>,
        /// <code>GL_RGB5</code>,
        /// <code>GL_RGB8</code>,
        /// <code>GL_RGB10</code>,
        /// <code>GL_RGB12</code>,
        /// <code>GL_RGB16</code>,
        /// <code>GL_RGBA</code>,
        /// <code>GL_RGBA2</code>,
        /// <code>GL_RGBA4</code>,
        /// <code>GL_RGB5_A1</code>,
        /// <code>GL_RGBA8</code>,
        /// <code>GL_RGB10_A2</code>,
        /// <code>GL_RGBA12</code>, or
        /// <code>GL_RGBA16</code>.
        /// </para>
        /// </param>
        /// <param name="width">
        /// The width of the pixel array referenced by <paramref name="data"/>.
        /// </param>
        /// <param name="format">
        /// <para>
        /// The format of the pixel data in <paramref name="data"/>.
        /// The allowable values are
        /// <code>GL_ALPHA</code>,
        /// <code>GL_LUMINANCE</code>,
        /// <code>GL_LUMINANCE_ALPHA</code>,
        /// <code>GL_INTENSITY</code>,
        /// <code>GL_RGB</code>, and
        /// <code>GL_RGBA</code>.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// The type of the pixel data in <paramref name="data"/>.
        /// Symbolic constants
        /// <code>GL_UNSIGNED_BYTE</code>,
        /// <code>GL_BYTE</code>,
        /// <code>GL_BITMAP</code>,
        /// <code>GL_UNSIGNED_SHORT</code>,
        /// <code>GL_SHORT</code>,
        /// <code>GL_UNSIGNED_INT</code>,
        /// <code>GL_INT</code>,
        /// <code>GL_FLOAT</code>,
        /// <code>GL_UNSIGNED_BYTE_3_3_2</code>,
        /// <code>GL_UNSIGNED_BYTE_2_3_3_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_5_6_5</code>,
        /// <code>GL_UNSIGNED_SHORT_5_6_5_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_4_4_4_4</code>,
        /// <code>GL_UNSIGNED_SHORT_4_4_4_4_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_5_5_5_1</code>,
        /// <code>GL_UNSIGNED_SHORT_1_5_5_5_REV</code>,
        /// <code>GL_UNSIGNED_INT_8_8_8_8</code>,
        /// <code>GL_UNSIGNED_INT_8_8_8_8_REV</code>,
        /// <code>GL_UNSIGNED_INT_10_10_10_2</code>, and
        /// <code>GL_UNSIGNED_INT_2_10_10_10_REV</code>
        /// are accepted.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Pointer to a one-dimensional array of pixel data that is processed to
        /// build the convolution filter kernel.
        /// </para>
        /// </param>
        /// <seealso cref="glConvolutionFilter2D"/>
        /// <seealso cref="glSeparableFilter2D"/>
        /// <seealso cref="glConvolutionParameter"/>
        /// <seealso cref="glPixelTransfer"/>
        public unsafe static void glConvolutionFilter1D(uint target, uint internalformat, int width, uint format, uint type, void* data) {
            var _F = _GetProc<GLNativeDelegate.FNglConvolutionFilter1D>("glConvolutionFilter1D");
            _F(target, internalformat, width, format, type, data);
        }
        /// <summary>
        /// define a two-dimensional convolution filter
        /// <para>Require:</para> <para>GL_ARB_imaging</para>
        /// Supported: <para>gl, glcore</para>
        /// Notes: 
        /// <para>
        /// <see cref="glConvolutionFilter2D"/> is present only if <code>ARB_imaging</code> is returned when  <see cref="glGetString"/> 
        /// is called with an argument of <code>GL_EXTENSIONS</code>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="target"/> is not
        /// <code>GL_CONVOLUTION_2D</code>.
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="internalformat"/> is not one of the
        /// allowable values.
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="format"/> is not one of the allowable
        /// values.
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="type"/> is not one of the allowable
        /// values.
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="width"/> is less than zero or greater
        /// than the maximum supported value.
        /// This value may be queried with  <see cref="glGetConvolutionParameter"/> 
        /// using target <code>GL_CONVOLUTION_2D</code> and name
        /// <code>GL_MAX_CONVOLUTION_WIDTH</code>.
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="height"/> is less than zero or greater
        /// than the maximum supported value.
        /// This value may be queried with  <see cref="glGetConvolutionParameter"/> 
        /// using target <code>GL_CONVOLUTION_2D</code> and name
        /// <code>GL_MAX_CONVOLUTION_HEIGHT</code>.
        /// <code>GL_INVALID_OPERATION</code> is generated if <paramref name="type"/> is one of
        /// <code>GL_UNSIGNED_BYTE_3_3_2</code>,
        /// <code>GL_UNSIGNED_BYTE_2_3_3_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_5_6_5</code>, or
        /// <code>GL_UNSIGNED_SHORT_5_6_5_REV</code>
        /// and <paramref name="format"/> is not <code>GL_RGB</code>.
        /// <code>GL_INVALID_OPERATION</code> is generated if <paramref name="type"/> is one of
        /// <code>GL_UNSIGNED_SHORT_4_4_4_4</code>,
        /// <code>GL_UNSIGNED_SHORT_4_4_4_4_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_5_5_5_1</code>,
        /// <code>GL_UNSIGNED_SHORT_1_5_5_5_REV</code>,
        /// <code>GL_UNSIGNED_INT_8_8_8_8</code>,
        /// <code>GL_UNSIGNED_INT_8_8_8_8_REV</code>,
        /// <code>GL_UNSIGNED_INT_10_10_10_2</code>, or
        /// <code>GL_UNSIGNED_INT_2_10_10_10_REV</code>
        /// and <paramref name="format"/> is neither <code>GL_RGBA</code> nor <code>GL_BGRA</code>.
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_UNPACK_BUFFER</code> target and the buffer object's data store is currently mapped.
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_UNPACK_BUFFER</code> target and the data would be unpacked from the buffer 
        /// object such that the memory reads required would exceed the data store size.
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_UNPACK_BUFFER</code> target and <paramref name="data"/> is not evenly divisible 
        /// into the number of bytes needed to store in memory a datum indicated by <paramref name="type"/>.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glConvolutionFilter2D"/> is executed
        /// between the execution of  <see cref="glBegin"/>  and the corresponding
        /// execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glConvolutionFilter2D(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const void * data);</para>
        /// </summary>
        /// <param name="target">
        /// Must be <code>GL_CONVOLUTION_2D</code>.
        /// </param>
        /// <param name="internalformat">
        /// <para>
        /// The internal format of the convolution filter kernel.
        /// The allowable values are
        /// <code>GL_ALPHA</code>,
        /// <code>GL_ALPHA4</code>,
        /// <code>GL_ALPHA8</code>,
        /// <code>GL_ALPHA12</code>,
        /// <code>GL_ALPHA16</code>,
        /// <code>GL_LUMINANCE</code>,
        /// <code>GL_LUMINANCE4</code>,
        /// <code>GL_LUMINANCE8</code>,
        /// <code>GL_LUMINANCE12</code>,
        /// <code>GL_LUMINANCE16</code>,
        /// <code>GL_LUMINANCE_ALPHA</code>,
        /// <code>GL_LUMINANCE4_ALPHA4</code>,
        /// <code>GL_LUMINANCE6_ALPHA2</code>,
        /// <code>GL_LUMINANCE8_ALPHA8</code>,
        /// <code>GL_LUMINANCE12_ALPHA4</code>,
        /// <code>GL_LUMINANCE12_ALPHA12</code>,
        /// <code>GL_LUMINANCE16_ALPHA16</code>,
        /// <code>GL_INTENSITY</code>,
        /// <code>GL_INTENSITY4</code>,
        /// <code>GL_INTENSITY8</code>,
        /// <code>GL_INTENSITY12</code>,
        /// <code>GL_INTENSITY16</code>,
        /// <code>GL_R3_G3_B2</code>,
        /// <code>GL_RGB</code>,
        /// <code>GL_RGB4</code>,
        /// <code>GL_RGB5</code>,
        /// <code>GL_RGB8</code>,
        /// <code>GL_RGB10</code>,
        /// <code>GL_RGB12</code>,
        /// <code>GL_RGB16</code>,
        /// <code>GL_RGBA</code>,
        /// <code>GL_RGBA2</code>,
        /// <code>GL_RGBA4</code>,
        /// <code>GL_RGB5_A1</code>,
        /// <code>GL_RGBA8</code>,
        /// <code>GL_RGB10_A2</code>,
        /// <code>GL_RGBA12</code>, or
        /// <code>GL_RGBA16</code>.
        /// </para>
        /// </param>
        /// <param name="width">
        /// The width of the pixel array referenced by <paramref name="data"/>.
        /// </param>
        /// <param name="height">
        /// The height of the pixel array referenced by <paramref name="data"/>.
        /// </param>
        /// <param name="format">
        /// <para>
        /// The format of the pixel data in <paramref name="data"/>.
        /// The allowable values are
        /// <code>GL_RED</code>,
        /// <code>GL_GREEN</code>,
        /// <code>GL_BLUE</code>,
        /// <code>GL_ALPHA</code>,
        /// <code>GL_RGB</code>,
        /// <code>GL_BGR</code>,
        /// <code>GL_RGBA</code>,
        /// <code>GL_BGRA</code>,
        /// <code>GL_LUMINANCE</code>, and
        /// <code>GL_LUMINANCE_ALPHA</code>.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// The type of the pixel data in <paramref name="data"/>.
        /// Symbolic constants
        /// <code>GL_UNSIGNED_BYTE</code>,
        /// <code>GL_BYTE</code>,
        /// <code>GL_BITMAP</code>,
        /// <code>GL_UNSIGNED_SHORT</code>,
        /// <code>GL_SHORT</code>,
        /// <code>GL_UNSIGNED_INT</code>,
        /// <code>GL_INT</code>,
        /// <code>GL_FLOAT</code>,
        /// <code>GL_UNSIGNED_BYTE_3_3_2</code>,
        /// <code>GL_UNSIGNED_BYTE_2_3_3_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_5_6_5</code>,
        /// <code>GL_UNSIGNED_SHORT_5_6_5_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_4_4_4_4</code>,
        /// <code>GL_UNSIGNED_SHORT_4_4_4_4_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_5_5_5_1</code>,
        /// <code>GL_UNSIGNED_SHORT_1_5_5_5_REV</code>,
        /// <code>GL_UNSIGNED_INT_8_8_8_8</code>,
        /// <code>GL_UNSIGNED_INT_8_8_8_8_REV</code>,
        /// <code>GL_UNSIGNED_INT_10_10_10_2</code>, and
        /// <code>GL_UNSIGNED_INT_2_10_10_10_REV</code>
        /// are accepted.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Pointer to a two-dimensional array of pixel data that is processed to
        /// build the convolution filter kernel.
        /// </para>
        /// </param>
        /// <seealso cref="glConvolutionFilter1D"/>
        /// <seealso cref="glSeparableFilter2D"/>
        /// <seealso cref="glConvolutionParameter"/>
        /// <seealso cref="glPixelTransfer"/>
        public unsafe static void glConvolutionFilter2D(uint target, uint internalformat, int width, int height, uint format, uint type, void* data) {
            var _F = _GetProc<GLNativeDelegate.FNglConvolutionFilter2D>("glConvolutionFilter2D");
            _F(target, internalformat, width, height, format, type, data);
        }
        /// <summary>
        /// set convolution parameters
        /// <para>Require:</para> <para>GL_ARB_imaging</para>
        /// Supported: <para>gl, glcore</para>
        /// Notes: 
        /// <para>
        /// <see cref="glConvolutionParameter"/> is present only if <code>ARB_imaging</code> is returned when  <see cref="glGetString"/> 
        /// is called with an argument of <code>GL_EXTENSIONS</code>.
        /// In cases where errors can result from the specification of invalid
        /// image dimensions, it is the dimensions after convolution that are
        /// tested, not the dimensions of the source image.
        /// For example,  <see cref="glTexImage1D"/>  requires power-of-two image size.
        /// When <code>GL_REDUCE</code> border mode is in effect,
        /// the source image must be larger than the final power-of-two size
        /// by one less than the size of the 1D filter kernel.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="target"/> is not one of the allowable
        /// values.
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="pname"/> is not one of the allowable
        /// values.
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="pname"/> is
        /// <code>GL_CONVOLUTION_BORDER_MODE</code> and <paramref name="ps"/> is not one of
        /// <code>GL_REDUCE</code>, <code>GL_CONSTANT_BORDER</code>, or <code>GL_REPLICATE_BORDER</code>.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glConvolutionParameter"/> is executed
        /// between the execution of  <see cref="glBegin"/>  and the corresponding
        /// execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glConvolutionParameterf(GLenum target, GLenum pname, GLfloat params);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// The target for the convolution parameter.
        /// Must be one of
        /// <code>GL_CONVOLUTION_1D</code>,
        /// <code>GL_CONVOLUTION_2D</code>, or
        /// <code>GL_SEPARABLE_2D</code>.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// The parameter to be set.
        /// Must be
        /// <code>GL_CONVOLUTION_BORDER_MODE</code>.
        /// </para>
        /// </param>
        /// <param name="ps">
        /// <para>
        /// The parameter value.
        /// Must be one of
        /// <code>GL_REDUCE</code>, <code>GL_CONSTANT_BORDER</code>, <code>GL_REPLICATE_BORDER</code>.
        /// </para>
        /// </param>
        /// <seealso cref="glConvolutionFilter1D"/>
        /// <seealso cref="glConvolutionFilter2D"/>
        /// <seealso cref="glSeparableFilter2D"/>
        /// <seealso cref="glGetConvolutionParameter"/>
        public static void glConvolutionParameterf(uint target, uint pname, float ps) {
            var _F = _GetProc<GLNativeDelegate.FNglConvolutionParameterf>("glConvolutionParameterf");
            _F(target, pname, ps);
        }
        /// <summary>
        /// set convolution parameters
        /// <para>Require:</para> <para>GL_ARB_imaging</para>
        /// Supported: <para>gl, glcore</para>
        /// Notes: 
        /// <para>
        /// <see cref="glConvolutionParameter"/> is present only if <code>ARB_imaging</code> is returned when  <see cref="glGetString"/> 
        /// is called with an argument of <code>GL_EXTENSIONS</code>.
        /// In cases where errors can result from the specification of invalid
        /// image dimensions, it is the dimensions after convolution that are
        /// tested, not the dimensions of the source image.
        /// For example,  <see cref="glTexImage1D"/>  requires power-of-two image size.
        /// When <code>GL_REDUCE</code> border mode is in effect,
        /// the source image must be larger than the final power-of-two size
        /// by one less than the size of the 1D filter kernel.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="target"/> is not one of the allowable
        /// values.
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="pname"/> is not one of the allowable
        /// values.
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="pname"/> is
        /// <code>GL_CONVOLUTION_BORDER_MODE</code> and <paramref name="ps"/> is not one of
        /// <code>GL_REDUCE</code>, <code>GL_CONSTANT_BORDER</code>, or <code>GL_REPLICATE_BORDER</code>.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glConvolutionParameter"/> is executed
        /// between the execution of  <see cref="glBegin"/>  and the corresponding
        /// execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glConvolutionParameterfv(GLenum target, GLenum pname, const GLfloat * params);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// The target for the convolution parameter.
        /// Must be one of
        /// <code>GL_CONVOLUTION_1D</code>,
        /// <code>GL_CONVOLUTION_2D</code>, or
        /// <code>GL_SEPARABLE_2D</code>.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// The parameter to be set.
        /// Must be one of
        /// <code>GL_CONVOLUTION_BORDER_MODE</code>,
        /// <code>GL_CONVOLUTION_BORDER_COLOR</code>,
        /// <code>GL_CONVOLUTION_FILTER_SCALE</code>, or
        /// <code>GL_CONVOLUTION_FILTER_BIAS</code>.
        /// </para>
        /// </param>
        /// <param name="ps">
        /// <para>
        /// The parameter value.
        /// If <paramref name="pname"/>v is <code>GL_CONVOLUTION_BORDER_MODE</code>, <paramref name="ps"/>v must be one of
        /// <code>GL_REDUCE</code>, <code>GL_CONSTANT_BORDER</code>, or <code>GL_REPLICATE_BORDER</code>.
        /// Otherwise, must be a vector of four values (for red, green, blue, and alpha,
        /// respectively) to be used for
        /// scaling (when <paramref name="pname"/>v is <code>GL_CONVOLUTION_FILTER_SCALE</code>), or
        /// biasing (when <paramref name="pname"/>v is <code>GL_CONVOLUTION_FILTER_BIAS</code>) a convolution
        /// filter kernel or setting the constant border color (when <paramref name="pname"/>v is
        /// <code>GL_CONVOLUTION_BORDER_COLOR</code>.
        /// </para>
        /// </param>
        /// <seealso cref="glConvolutionFilter1D"/>
        /// <seealso cref="glConvolutionFilter2D"/>
        /// <seealso cref="glSeparableFilter2D"/>
        /// <seealso cref="glGetConvolutionParameter"/>
        public unsafe static void glConvolutionParameterfv(uint target, uint pname, float* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglConvolutionParameterfv>("glConvolutionParameterfv");
            _F(target, pname, ps);
        }
        /// <summary>
        /// set convolution parameters
        /// <para>Require:</para> <para>GL_ARB_imaging</para>
        /// Supported: <para>gl, glcore</para>
        /// Notes: 
        /// <para>
        /// <see cref="glConvolutionParameter"/> is present only if <code>ARB_imaging</code> is returned when  <see cref="glGetString"/> 
        /// is called with an argument of <code>GL_EXTENSIONS</code>.
        /// In cases where errors can result from the specification of invalid
        /// image dimensions, it is the dimensions after convolution that are
        /// tested, not the dimensions of the source image.
        /// For example,  <see cref="glTexImage1D"/>  requires power-of-two image size.
        /// When <code>GL_REDUCE</code> border mode is in effect,
        /// the source image must be larger than the final power-of-two size
        /// by one less than the size of the 1D filter kernel.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="target"/> is not one of the allowable
        /// values.
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="pname"/> is not one of the allowable
        /// values.
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="pname"/> is
        /// <code>GL_CONVOLUTION_BORDER_MODE</code> and <paramref name="ps"/> is not one of
        /// <code>GL_REDUCE</code>, <code>GL_CONSTANT_BORDER</code>, or <code>GL_REPLICATE_BORDER</code>.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glConvolutionParameter"/> is executed
        /// between the execution of  <see cref="glBegin"/>  and the corresponding
        /// execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glConvolutionParameteri(GLenum target, GLenum pname, GLint params);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// The target for the convolution parameter.
        /// Must be one of
        /// <code>GL_CONVOLUTION_1D</code>,
        /// <code>GL_CONVOLUTION_2D</code>, or
        /// <code>GL_SEPARABLE_2D</code>.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// The parameter to be set.
        /// Must be
        /// <code>GL_CONVOLUTION_BORDER_MODE</code>.
        /// </para>
        /// </param>
        /// <param name="ps">
        /// <para>
        /// The parameter value.
        /// Must be one of
        /// <code>GL_REDUCE</code>, <code>GL_CONSTANT_BORDER</code>, <code>GL_REPLICATE_BORDER</code>.
        /// </para>
        /// </param>
        /// <seealso cref="glConvolutionFilter1D"/>
        /// <seealso cref="glConvolutionFilter2D"/>
        /// <seealso cref="glSeparableFilter2D"/>
        /// <seealso cref="glGetConvolutionParameter"/>
        public static void glConvolutionParameteri(uint target, uint pname, int ps) {
            var _F = _GetProc<GLNativeDelegate.FNglConvolutionParameteri>("glConvolutionParameteri");
            _F(target, pname, ps);
        }
        /// <summary>
        /// set convolution parameters
        /// <para>Require:</para> <para>GL_ARB_imaging</para>
        /// Supported: <para>gl, glcore</para>
        /// Notes: 
        /// <para>
        /// <see cref="glConvolutionParameter"/> is present only if <code>ARB_imaging</code> is returned when  <see cref="glGetString"/> 
        /// is called with an argument of <code>GL_EXTENSIONS</code>.
        /// In cases where errors can result from the specification of invalid
        /// image dimensions, it is the dimensions after convolution that are
        /// tested, not the dimensions of the source image.
        /// For example,  <see cref="glTexImage1D"/>  requires power-of-two image size.
        /// When <code>GL_REDUCE</code> border mode is in effect,
        /// the source image must be larger than the final power-of-two size
        /// by one less than the size of the 1D filter kernel.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="target"/> is not one of the allowable
        /// values.
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="pname"/> is not one of the allowable
        /// values.
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="pname"/> is
        /// <code>GL_CONVOLUTION_BORDER_MODE</code> and <paramref name="ps"/> is not one of
        /// <code>GL_REDUCE</code>, <code>GL_CONSTANT_BORDER</code>, or <code>GL_REPLICATE_BORDER</code>.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glConvolutionParameter"/> is executed
        /// between the execution of  <see cref="glBegin"/>  and the corresponding
        /// execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glConvolutionParameteriv(GLenum target, GLenum pname, const GLint * params);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// The target for the convolution parameter.
        /// Must be one of
        /// <code>GL_CONVOLUTION_1D</code>,
        /// <code>GL_CONVOLUTION_2D</code>, or
        /// <code>GL_SEPARABLE_2D</code>.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// The parameter to be set.
        /// Must be one of
        /// <code>GL_CONVOLUTION_BORDER_MODE</code>,
        /// <code>GL_CONVOLUTION_BORDER_COLOR</code>,
        /// <code>GL_CONVOLUTION_FILTER_SCALE</code>, or
        /// <code>GL_CONVOLUTION_FILTER_BIAS</code>.
        /// </para>
        /// </param>
        /// <param name="ps">
        /// <para>
        /// The parameter value.
        /// If <paramref name="pname"/>v is <code>GL_CONVOLUTION_BORDER_MODE</code>, <paramref name="ps"/>v must be one of
        /// <code>GL_REDUCE</code>, <code>GL_CONSTANT_BORDER</code>, or <code>GL_REPLICATE_BORDER</code>.
        /// Otherwise, must be a vector of four values (for red, green, blue, and alpha,
        /// respectively) to be used for
        /// scaling (when <paramref name="pname"/>v is <code>GL_CONVOLUTION_FILTER_SCALE</code>), or
        /// biasing (when <paramref name="pname"/>v is <code>GL_CONVOLUTION_FILTER_BIAS</code>) a convolution
        /// filter kernel or setting the constant border color (when <paramref name="pname"/>v is
        /// <code>GL_CONVOLUTION_BORDER_COLOR</code>.
        /// </para>
        /// </param>
        /// <seealso cref="glConvolutionFilter1D"/>
        /// <seealso cref="glConvolutionFilter2D"/>
        /// <seealso cref="glSeparableFilter2D"/>
        /// <seealso cref="glGetConvolutionParameter"/>
        public unsafe static void glConvolutionParameteriv(uint target, uint pname, int* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglConvolutionParameteriv>("glConvolutionParameteriv");
            _F(target, pname, ps);
        }
        /// <summary>
        /// copy pixels into a one-dimensional convolution filter
        /// <para>Require:</para> <para>GL_ARB_imaging</para>
        /// Supported: <para>gl, glcore</para>
        /// Notes: 
        /// <para>
        /// <see cref="glCopyConvolutionFilter1D"/> is present only if <code>ARB_imaging</code> is returned when  <see cref="glGetString"/> 
        /// is called with an argument of <code>GL_EXTENSIONS</code>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="target"/> is not
        /// <code>GL_CONVOLUTION_1D</code>.
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="internalformat"/> is not one of the
        /// allowable values.
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="width"/> is less than zero or greater
        /// than the maximum supported value.
        /// This value may be queried with  <see cref="glGetConvolutionParameter"/> 
        /// using target <code>GL_CONVOLUTION_1D</code> and name
        /// <code>GL_MAX_CONVOLUTION_WIDTH</code>.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glCopyConvolutionFilter1D"/> is executed
        /// between the execution of  <see cref="glBegin"/>  and the corresponding
        /// execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glCopyConvolutionFilter1D(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width);</para>
        /// </summary>
        /// <param name="target">
        /// Must be <code>GL_CONVOLUTION_1D</code>.
        /// </param>
        /// <param name="internalformat">
        /// <para>
        /// The internal format of the convolution filter kernel.
        /// The allowable values are
        /// <code>GL_ALPHA</code>,
        /// <code>GL_ALPHA4</code>,
        /// <code>GL_ALPHA8</code>,
        /// <code>GL_ALPHA12</code>,
        /// <code>GL_ALPHA16</code>,
        /// <code>GL_LUMINANCE</code>,
        /// <code>GL_LUMINANCE4</code>,
        /// <code>GL_LUMINANCE8</code>,
        /// <code>GL_LUMINANCE12</code>,
        /// <code>GL_LUMINANCE16</code>,
        /// <code>GL_LUMINANCE_ALPHA</code>,
        /// <code>GL_LUMINANCE4_ALPHA4</code>,
        /// <code>GL_LUMINANCE6_ALPHA2</code>,
        /// <code>GL_LUMINANCE8_ALPHA8</code>,
        /// <code>GL_LUMINANCE12_ALPHA4</code>,
        /// <code>GL_LUMINANCE12_ALPHA12</code>,
        /// <code>GL_LUMINANCE16_ALPHA16</code>,
        /// <code>GL_INTENSITY</code>,
        /// <code>GL_INTENSITY4</code>,
        /// <code>GL_INTENSITY8</code>,
        /// <code>GL_INTENSITY12</code>,
        /// <code>GL_INTENSITY16</code>,
        /// <code>GL_R3_G3_B2</code>,
        /// <code>GL_RGB</code>,
        /// <code>GL_RGB4</code>,
        /// <code>GL_RGB5</code>,
        /// <code>GL_RGB8</code>,
        /// <code>GL_RGB10</code>,
        /// <code>GL_RGB12</code>,
        /// <code>GL_RGB16</code>,
        /// <code>GL_RGBA</code>,
        /// <code>GL_RGBA2</code>,
        /// <code>GL_RGBA4</code>,
        /// <code>GL_RGB5_A1</code>,
        /// <code>GL_RGBA8</code>,
        /// <code>GL_RGB10_A2</code>,
        /// <code>GL_RGBA12</code>, or
        /// <code>GL_RGBA16</code>.
        /// </para>
        /// </param>
        /// <param name="x">
        /// <para>
        /// The window space coordinates of the lower-left coordinate of the
        /// pixel array to copy.
        /// </para>
        /// </param>
        /// <param name="y">
        /// <para>
        /// The window space coordinates of the lower-left coordinate of the
        /// pixel array to copy.
        /// </para>
        /// </param>
        /// <param name="width">
        /// The width of the pixel array to copy.
        /// </param>
        /// <seealso cref="glConvolutionFilter1D"/>
        /// <seealso cref="glConvolutionParameter"/>
        /// <seealso cref="glPixelTransfer"/>
        public static void glCopyConvolutionFilter1D(uint target, uint internalformat, int x, int y, int width) {
            var _F = _GetProc<GLNativeDelegate.FNglCopyConvolutionFilter1D>("glCopyConvolutionFilter1D");
            _F(target, internalformat, x, y, width);
        }
        /// <summary>
        /// copy pixels into a two-dimensional convolution filter
        /// <para>Require:</para> <para>GL_ARB_imaging</para>
        /// Supported: <para>gl, glcore</para>
        /// Notes: 
        /// <para>
        /// <see cref="glCopyConvolutionFilter2D"/> is present only if <code>ARB_imaging</code> is returned when  <see cref="glGetString"/> 
        /// is called with an argument of <code>GL_EXTENSIONS</code>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="target"/> is not
        /// <code>GL_CONVOLUTION_2D</code>.
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="internalformat"/> is not one of the
        /// allowable values.
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="width"/> is less than zero or greater
        /// than the maximum supported value.
        /// This value may be queried with  <see cref="glGetConvolutionParameter"/> 
        /// using target <code>GL_CONVOLUTION_2D</code> and name
        /// <code>GL_MAX_CONVOLUTION_WIDTH</code>.
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="height"/> is less than zero or greater
        /// than the maximum supported value.
        /// This value may be queried with  <see cref="glGetConvolutionParameter"/> 
        /// using target <code>GL_CONVOLUTION_2D</code> and name
        /// <code>GL_MAX_CONVOLUTION_HEIGHT</code>.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glCopyConvolutionFilter2D"/> is executed
        /// between the execution of  <see cref="glBegin"/>  and the corresponding
        /// execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glCopyConvolutionFilter2D(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height);</para>
        /// </summary>
        /// <param name="target">
        /// Must be <code>GL_CONVOLUTION_2D</code>.
        /// </param>
        /// <param name="internalformat">
        /// <para>
        /// The internal format of the convolution filter kernel.
        /// The allowable values are
        /// <code>GL_ALPHA</code>,
        /// <code>GL_ALPHA4</code>,
        /// <code>GL_ALPHA8</code>,
        /// <code>GL_ALPHA12</code>,
        /// <code>GL_ALPHA16</code>,
        /// <code>GL_LUMINANCE</code>,
        /// <code>GL_LUMINANCE4</code>,
        /// <code>GL_LUMINANCE8</code>,
        /// <code>GL_LUMINANCE12</code>,
        /// <code>GL_LUMINANCE16</code>,
        /// <code>GL_LUMINANCE_ALPHA</code>,
        /// <code>GL_LUMINANCE4_ALPHA4</code>,
        /// <code>GL_LUMINANCE6_ALPHA2</code>,
        /// <code>GL_LUMINANCE8_ALPHA8</code>,
        /// <code>GL_LUMINANCE12_ALPHA4</code>,
        /// <code>GL_LUMINANCE12_ALPHA12</code>,
        /// <code>GL_LUMINANCE16_ALPHA16</code>,
        /// <code>GL_INTENSITY</code>,
        /// <code>GL_INTENSITY4</code>,
        /// <code>GL_INTENSITY8</code>,
        /// <code>GL_INTENSITY12</code>,
        /// <code>GL_INTENSITY16</code>,
        /// <code>GL_R3_G3_B2</code>,
        /// <code>GL_RGB</code>,
        /// <code>GL_RGB4</code>,
        /// <code>GL_RGB5</code>,
        /// <code>GL_RGB8</code>,
        /// <code>GL_RGB10</code>,
        /// <code>GL_RGB12</code>,
        /// <code>GL_RGB16</code>,
        /// <code>GL_RGBA</code>,
        /// <code>GL_RGBA2</code>,
        /// <code>GL_RGBA4</code>,
        /// <code>GL_RGB5_A1</code>,
        /// <code>GL_RGBA8</code>,
        /// <code>GL_RGB10_A2</code>,
        /// <code>GL_RGBA12</code>, or
        /// <code>GL_RGBA16</code>.
        /// </para>
        /// </param>
        /// <param name="x">
        /// <para>
        /// The window space coordinates of the lower-left coordinate of the
        /// pixel array to copy.
        /// </para>
        /// </param>
        /// <param name="y">
        /// <para>
        /// The window space coordinates of the lower-left coordinate of the
        /// pixel array to copy.
        /// </para>
        /// </param>
        /// <param name="width">
        /// The width of the pixel array to copy.
        /// </param>
        /// <param name="height">
        /// The height of the pixel array to copy.
        /// </param>
        /// <seealso cref="glConvolutionFilter2D"/>
        /// <seealso cref="glConvolutionParameter"/>
        /// <seealso cref="glPixelTransfer"/>
        public static void glCopyConvolutionFilter2D(uint target, uint internalformat, int x, int y, int width, int height) {
            var _F = _GetProc<GLNativeDelegate.FNglCopyConvolutionFilter2D>("glCopyConvolutionFilter2D");
            _F(target, internalformat, x, y, width, height);
        }
        /// <summary>
        /// get current 1D or 2D convolution filter kernel
        /// <para>Require:</para> <para>GL_ARB_imaging</para>
        /// Supported: <para>gl, glcore</para>
        /// Notes: 
        /// <para>
        /// <see cref="glGetConvolutionFilter"/> is present only if <code>ARB_imaging</code> is returned when  <see cref="glGetString"/> 
        /// is called with an argument of <code>GL_EXTENSIONS</code>.
        /// The current separable 2D filter must be retrieved with
        /// <see cref="glGetSeparableFilter"/>  rather than <see cref="glGetConvolutionFilter"/>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="target"/> is not one of the allowable
        /// values.
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="format"/> is not one of the allowable
        /// values.
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="type"/> is not one of the allowable
        /// values.
        /// <code>GL_INVALID_OPERATION</code> is generated if <paramref name="type"/> is one of
        /// <code>GL_UNSIGNED_BYTE_3_3_2</code>,
        /// <code>GL_UNSIGNED_BYTE_2_3_3_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_5_6_5</code>, or
        /// <code>GL_UNSIGNED_SHORT_5_6_5_REV</code>
        /// and <paramref name="format"/> is not <code>GL_RGB</code>.
        /// <code>GL_INVALID_OPERATION</code> is generated if <paramref name="type"/> is one of
        /// <code>GL_UNSIGNED_SHORT_4_4_4_4</code>,
        /// <code>GL_UNSIGNED_SHORT_4_4_4_4_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_5_5_5_1</code>,
        /// <code>GL_UNSIGNED_SHORT_1_5_5_5_REV</code>,
        /// <code>GL_UNSIGNED_INT_8_8_8_8</code>,
        /// <code>GL_UNSIGNED_INT_8_8_8_8_REV</code>,
        /// <code>GL_UNSIGNED_INT_10_10_10_2</code>, or
        /// <code>GL_UNSIGNED_INT_2_10_10_10_REV</code>
        /// and <paramref name="format"/> is neither <code>GL_RGBA</code> nor <code>GL_BGRA</code>.
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_PACK_BUFFER</code> target and the buffer object's data store is currently mapped.
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_PACK_BUFFER</code> target and the data would be packed to the buffer 
        /// object such that the memory writes required would exceed the data store size.
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_PACK_BUFFER</code> target and <paramref name="image"/> is not evenly divisible 
        /// into the number of bytes needed to store in memory a datum indicated by <paramref name="type"/>.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glGetConvolutionFilter"/> is executed
        /// between the execution of  <see cref="glBegin"/>  and the corresponding
        /// execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glGetConvolutionFilter(GLenum target, GLenum format, GLenum type, void * image);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// The filter to be retrieved.
        /// Must be one of
        /// <code>GL_CONVOLUTION_1D</code> or
        /// <code>GL_CONVOLUTION_2D</code>.
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// Format of the output image.
        /// Must be one of
        /// <code>GL_RED</code>,
        /// <code>GL_GREEN</code>,
        /// <code>GL_BLUE</code>,
        /// <code>GL_ALPHA</code>,
        /// <code>GL_RGB</code>,
        /// <code>GL_BGR</code>,
        /// <code>GL_RGBA</code>,
        /// <code>GL_BGRA</code>,
        /// <code>GL_LUMINANCE</code>, or
        /// <code>GL_LUMINANCE_ALPHA</code>.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Data type of components in the output image.
        /// Symbolic constants
        /// <code>GL_UNSIGNED_BYTE</code>,
        /// <code>GL_BYTE</code>,
        /// <code>GL_BITMAP</code>,
        /// <code>GL_UNSIGNED_SHORT</code>,
        /// <code>GL_SHORT</code>,
        /// <code>GL_UNSIGNED_INT</code>,
        /// <code>GL_INT</code>,
        /// <code>GL_FLOAT</code>,
        /// <code>GL_UNSIGNED_BYTE_3_3_2</code>,
        /// <code>GL_UNSIGNED_BYTE_2_3_3_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_5_6_5</code>,
        /// <code>GL_UNSIGNED_SHORT_5_6_5_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_4_4_4_4</code>,
        /// <code>GL_UNSIGNED_SHORT_4_4_4_4_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_5_5_5_1</code>,
        /// <code>GL_UNSIGNED_SHORT_1_5_5_5_REV</code>,
        /// <code>GL_UNSIGNED_INT_8_8_8_8</code>,
        /// <code>GL_UNSIGNED_INT_8_8_8_8_REV</code>,
        /// <code>GL_UNSIGNED_INT_10_10_10_2</code>, and
        /// <code>GL_UNSIGNED_INT_2_10_10_10_REV</code>
        /// are accepted.
        /// </para>
        /// </param>
        /// <param name="image">
        /// Pointer to storage for the output image.
        /// </param>
        /// <seealso cref="glGetSeparableFilter"/>
        /// <seealso cref="glConvolutionParameter"/>
        /// <seealso cref="glConvolutionFilter1D"/>
        /// <seealso cref="glConvolutionFilter2D"/>
        public unsafe static void glGetConvolutionFilter(uint target, uint format, uint type, void* image) {
            var _F = _GetProc<GLNativeDelegate.FNglGetConvolutionFilter>("glGetConvolutionFilter");
            _F(target, format, type, image);
        }
        /// <summary>
        /// get convolution parameters
        /// <para>Require:</para> <para>GL_ARB_imaging</para>
        /// Supported: <para>gl, glcore</para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="target"/> is not one of the allowable
        /// values.
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="pname"/> is not one of the allowable
        /// values.
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="target"/> is <code>GL_CONVOLUTION_1D</code>
        /// and <paramref name="pname"/> is <code>GL_CONVOLUTION_HEIGHT</code> or
        /// <code>GL_MAX_CONVOLUTION_HEIGHT</code>.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glGetConvolutionParameter"/> is executed
        /// between the execution of  <see cref="glBegin"/>  and the corresponding
        /// execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glGetConvolutionParameterfv(GLenum target, GLenum pname, GLfloat * params);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// The filter whose parameters are to be retrieved.
        /// Must be one of
        /// <code>GL_CONVOLUTION_1D</code>,
        /// <code>GL_CONVOLUTION_2D</code>, or
        /// <code>GL_SEPARABLE_2D</code>.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// The parameter to be retrieved.
        /// Must be one of
        /// <code>GL_CONVOLUTION_BORDER_MODE</code>,
        /// <code>GL_CONVOLUTION_BORDER_COLOR</code>,
        /// <code>GL_CONVOLUTION_FILTER_SCALE</code>,
        /// <code>GL_CONVOLUTION_FILTER_BIAS</code>,
        /// <code>GL_CONVOLUTION_FORMAT</code>,
        /// <code>GL_CONVOLUTION_WIDTH</code>,
        /// <code>GL_CONVOLUTION_HEIGHT</code>,
        /// <code>GL_MAX_CONVOLUTION_WIDTH</code>, or
        /// <code>GL_MAX_CONVOLUTION_HEIGHT</code>.
        /// </para>
        /// </param>
        /// <param name="ps">
        /// Pointer to storage for the parameters to be retrieved.
        /// </param>
        /// <seealso cref="glGetConvolutionFilter"/>
        /// <seealso cref="glGetSeparableFilter"/>
        /// <seealso cref="glConvolutionParameter"/>
        public unsafe static void glGetConvolutionParameterfv(uint target, uint pname, float* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetConvolutionParameterfv>("glGetConvolutionParameterfv");
            _F(target, pname, ps);
        }
        /// <summary>
        /// get convolution parameters
        /// <para>Require:</para> <para>GL_ARB_imaging</para>
        /// Supported: <para>gl, glcore</para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="target"/> is not one of the allowable
        /// values.
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="pname"/> is not one of the allowable
        /// values.
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="target"/> is <code>GL_CONVOLUTION_1D</code>
        /// and <paramref name="pname"/> is <code>GL_CONVOLUTION_HEIGHT</code> or
        /// <code>GL_MAX_CONVOLUTION_HEIGHT</code>.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glGetConvolutionParameter"/> is executed
        /// between the execution of  <see cref="glBegin"/>  and the corresponding
        /// execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glGetConvolutionParameteriv(GLenum target, GLenum pname, GLint * params);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// The filter whose parameters are to be retrieved.
        /// Must be one of
        /// <code>GL_CONVOLUTION_1D</code>,
        /// <code>GL_CONVOLUTION_2D</code>, or
        /// <code>GL_SEPARABLE_2D</code>.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// The parameter to be retrieved.
        /// Must be one of
        /// <code>GL_CONVOLUTION_BORDER_MODE</code>,
        /// <code>GL_CONVOLUTION_BORDER_COLOR</code>,
        /// <code>GL_CONVOLUTION_FILTER_SCALE</code>,
        /// <code>GL_CONVOLUTION_FILTER_BIAS</code>,
        /// <code>GL_CONVOLUTION_FORMAT</code>,
        /// <code>GL_CONVOLUTION_WIDTH</code>,
        /// <code>GL_CONVOLUTION_HEIGHT</code>,
        /// <code>GL_MAX_CONVOLUTION_WIDTH</code>, or
        /// <code>GL_MAX_CONVOLUTION_HEIGHT</code>.
        /// </para>
        /// </param>
        /// <param name="ps">
        /// Pointer to storage for the parameters to be retrieved.
        /// </param>
        /// <seealso cref="glGetConvolutionFilter"/>
        /// <seealso cref="glGetSeparableFilter"/>
        /// <seealso cref="glConvolutionParameter"/>
        public unsafe static void glGetConvolutionParameteriv(uint target, uint pname, int* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetConvolutionParameteriv>("glGetConvolutionParameteriv");
            _F(target, pname, ps);
        }
        /// <summary>
        /// get separable convolution filter kernel images
        /// <para>Require:</para> <para>GL_ARB_imaging</para>
        /// Supported: <para>gl, glcore</para>
        /// Notes: 
        /// <para>
        /// <see cref="glGetSeparableFilter"/> is present only if <code>ARB_imaging</code> is returned when  <see cref="glGetString"/> 
        /// is called with an argument of <code>GL_EXTENSIONS</code>.
        /// Non-separable 2D filters must be retrieved with  <see cref="glGetConvolutionFilter"/> .
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="target"/> is not <code>GL_SEPARABLE_2D</code>.
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="format"/> is not one of the allowable
        /// values.
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="type"/> is not one of the allowable
        /// values.
        /// <code>GL_INVALID_OPERATION</code> is generated if <paramref name="type"/> is one of
        /// <code>GL_UNSIGNED_BYTE_3_3_2</code>,
        /// <code>GL_UNSIGNED_BYTE_2_3_3_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_5_6_5</code>, or
        /// <code>GL_UNSIGNED_SHORT_5_6_5_REV</code>
        /// and <paramref name="format"/> is not <code>GL_RGB</code>.
        /// <code>GL_INVALID_OPERATION</code> is generated if <paramref name="type"/> is one of
        /// <code>GL_UNSIGNED_SHORT_4_4_4_4</code>,
        /// <code>GL_UNSIGNED_SHORT_4_4_4_4_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_5_5_5_1</code>,
        /// <code>GL_UNSIGNED_SHORT_1_5_5_5_REV</code>,
        /// <code>GL_UNSIGNED_INT_8_8_8_8</code>,
        /// <code>GL_UNSIGNED_INT_8_8_8_8_REV</code>,
        /// <code>GL_UNSIGNED_INT_10_10_10_2</code>, or
        /// <code>GL_UNSIGNED_INT_2_10_10_10_REV</code>
        /// and <paramref name="format"/> is neither <code>GL_RGBA</code> nor <code>GL_BGRA</code>.
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_PACK_BUFFER</code> target and the buffer object's data store is currently mapped.
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_PACK_BUFFER</code> target and the data would be packed to the buffer 
        /// object such that the memory writes required would exceed the data store size.
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_PACK_BUFFER</code> target and <paramref name="row"/> or <paramref name="column"/> is not evenly divisible 
        /// into the number of bytes needed to store in memory a datum indicated by <paramref name="type"/>.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glGetSeparableFilter"/> is executed
        /// between the execution of  <see cref="glBegin"/>  and the corresponding
        /// execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glGetSeparableFilter(GLenum target, GLenum format, GLenum type, void * row, void * column, void * span);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// The separable filter to be retrieved.
        /// Must be
        /// <code>GL_SEPARABLE_2D</code>.
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// Format of the output images.
        /// Must be one of
        /// <code>GL_RED</code>,
        /// <code>GL_GREEN</code>,
        /// <code>GL_BLUE</code>,
        /// <code>GL_ALPHA</code>,
        /// <code>GL_RGB</code>,
        /// <code>GL_BGR</code>
        /// <code>GL_RGBA</code>,
        /// <code>GL_BGRA</code>,
        /// <code>GL_LUMINANCE</code>, or
        /// <code>GL_LUMINANCE_ALPHA</code>.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Data type of components in the output images.
        /// Symbolic constants
        /// <code>GL_UNSIGNED_BYTE</code>,
        /// <code>GL_BYTE</code>,
        /// <code>GL_BITMAP</code>,
        /// <code>GL_UNSIGNED_SHORT</code>,
        /// <code>GL_SHORT</code>,
        /// <code>GL_UNSIGNED_INT</code>,
        /// <code>GL_INT</code>,
        /// <code>GL_FLOAT</code>,
        /// <code>GL_UNSIGNED_BYTE_3_3_2</code>,
        /// <code>GL_UNSIGNED_BYTE_2_3_3_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_5_6_5</code>,
        /// <code>GL_UNSIGNED_SHORT_5_6_5_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_4_4_4_4</code>,
        /// <code>GL_UNSIGNED_SHORT_4_4_4_4_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_5_5_5_1</code>,
        /// <code>GL_UNSIGNED_SHORT_1_5_5_5_REV</code>,
        /// <code>GL_UNSIGNED_INT_8_8_8_8</code>,
        /// <code>GL_UNSIGNED_INT_8_8_8_8_REV</code>,
        /// <code>GL_UNSIGNED_INT_10_10_10_2</code>, and
        /// <code>GL_UNSIGNED_INT_2_10_10_10_REV</code>
        /// are accepted.
        /// </para>
        /// </param>
        /// <param name="row">
        /// Pointer to storage for the row filter image.
        /// </param>
        /// <param name="column">
        /// Pointer to storage for the column filter image.
        /// </param>
        /// <param name="span">
        /// Pointer to storage for the span filter image (currently unused).
        /// </param>
        /// <seealso cref="glGetConvolutionFilter"/>
        /// <seealso cref="glConvolutionParameter"/>
        /// <seealso cref="glSeparableFilter2D"/>
        public unsafe static void glGetSeparableFilter(uint target, uint format, uint type, void* row, void* column, void* span) {
            var _F = _GetProc<GLNativeDelegate.FNglGetSeparableFilter>("glGetSeparableFilter");
            _F(target, format, type, row, column, span);
        }
        /// <summary>
        /// define a separable two-dimensional convolution filter
        /// <para>Require:</para> <para>GL_ARB_imaging</para>
        /// Supported: <para>gl, glcore</para>
        /// Notes: 
        /// <para>
        /// <see cref="glSeparableFilter2D"/> is present only if <code>ARB_imaging</code> is returned when  <see cref="glGetString"/> 
        /// is called with an argument of <code>GL_EXTENSIONS</code>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="target"/> is not
        /// <code>GL_SEPARABLE_2D</code>.
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="internalformat"/> is not one of the
        /// allowable values.
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="format"/> is not one of the allowable
        /// values.
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="type"/> is not one of the allowable
        /// values.
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="width"/> is less than zero or greater
        /// than the maximum supported value.
        /// This value may be queried with  <see cref="glGetConvolutionParameter"/> 
        /// using target <code>GL_SEPARABLE_2D</code> and name
        /// <code>GL_MAX_CONVOLUTION_WIDTH</code>.
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="height"/> is less than zero or greater
        /// than the maximum supported value.
        /// This value may be queried with  <see cref="glGetConvolutionParameter"/> 
        /// using target <code>GL_SEPARABLE_2D</code> and name
        /// <code>GL_MAX_CONVOLUTION_HEIGHT</code>.
        /// <code>GL_INVALID_OPERATION</code> is generated if <paramref name="height"/> is one of
        /// <code>GL_UNSIGNED_BYTE_3_3_2</code>,
        /// <code>GL_UNSIGNED_BYTE_2_3_3_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_5_6_5</code>, or
        /// <code>GL_UNSIGNED_SHORT_5_6_5_REV</code>
        /// and <paramref name="format"/> is not <code>GL_RGB</code>.
        /// <code>GL_INVALID_OPERATION</code> is generated if <paramref name="height"/> is one of
        /// <code>GL_UNSIGNED_SHORT_4_4_4_4</code>,
        /// <code>GL_UNSIGNED_SHORT_4_4_4_4_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_5_5_5_1</code>,
        /// <code>GL_UNSIGNED_SHORT_1_5_5_5_REV</code>,
        /// <code>GL_UNSIGNED_INT_8_8_8_8</code>,
        /// <code>GL_UNSIGNED_INT_8_8_8_8_REV</code>,
        /// <code>GL_UNSIGNED_INT_10_10_10_2</code>, or
        /// <code>GL_UNSIGNED_INT_2_10_10_10_REV</code>
        /// and <paramref name="format"/> is neither <code>GL_RGBA</code> nor <code>GL_BGRA</code>.
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_UNPACK_BUFFER</code> target and the buffer object's data store is currently mapped.
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_UNPACK_BUFFER</code> target and the data would be unpacked from the buffer 
        /// object such that the memory reads required would exceed the data store size.
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_UNPACK_BUFFER</code> target and <paramref name="row"/> or 
        /// <paramref name="column"/> is not evenly divisible 
        /// into the number of bytes needed to store in memory a datum indicated by <paramref name="type"/>.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glSeparableFilter2D"/> is executed
        /// between the execution of  <see cref="glBegin"/>  and the corresponding
        /// execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glSeparableFilter2D(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const void * row, const void * column);</para>
        /// </summary>
        /// <param name="target">
        /// Must be <code>GL_SEPARABLE_2D</code>.
        /// </param>
        /// <param name="internalformat">
        /// <para>
        /// The internal format of the convolution filter kernel.
        /// The allowable values are
        /// <code>GL_ALPHA</code>,
        /// <code>GL_ALPHA4</code>,
        /// <code>GL_ALPHA8</code>,
        /// <code>GL_ALPHA12</code>,
        /// <code>GL_ALPHA16</code>,
        /// <code>GL_LUMINANCE</code>,
        /// <code>GL_LUMINANCE4</code>,
        /// <code>GL_LUMINANCE8</code>,
        /// <code>GL_LUMINANCE12</code>,
        /// <code>GL_LUMINANCE16</code>,
        /// <code>GL_LUMINANCE_ALPHA</code>,
        /// <code>GL_LUMINANCE4_ALPHA4</code>,
        /// <code>GL_LUMINANCE6_ALPHA2</code>,
        /// <code>GL_LUMINANCE8_ALPHA8</code>,
        /// <code>GL_LUMINANCE12_ALPHA4</code>,
        /// <code>GL_LUMINANCE12_ALPHA12</code>,
        /// <code>GL_LUMINANCE16_ALPHA16</code>,
        /// <code>GL_INTENSITY</code>,
        /// <code>GL_INTENSITY4</code>,
        /// <code>GL_INTENSITY8</code>,
        /// <code>GL_INTENSITY12</code>,
        /// <code>GL_INTENSITY16</code>,
        /// <code>GL_R3_G3_B2</code>,
        /// <code>GL_RGB</code>,
        /// <code>GL_RGB4</code>,
        /// <code>GL_RGB5</code>,
        /// <code>GL_RGB8</code>,
        /// <code>GL_RGB10</code>,
        /// <code>GL_RGB12</code>,
        /// <code>GL_RGB16</code>,
        /// <code>GL_RGBA</code>,
        /// <code>GL_RGBA2</code>,
        /// <code>GL_RGBA4</code>,
        /// <code>GL_RGB5_A1</code>,
        /// <code>GL_RGBA8</code>,
        /// <code>GL_RGB10_A2</code>,
        /// <code>GL_RGBA12</code>, or
        /// <code>GL_RGBA16</code>.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// The number of elements in the pixel array referenced by <paramref name="row"/>.
        /// (This is the width of the separable filter kernel.)
        /// </para>
        /// </param>
        /// <param name="height">
        /// <para>
        /// The number of elements in the pixel array referenced by <paramref name="column"/>.
        /// (This is the height of the separable filter kernel.)
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// The format of the pixel data in <paramref name="row"/> and <paramref name="column"/>.
        /// The allowable values are
        /// <code>GL_RED</code>,
        /// <code>GL_GREEN</code>,
        /// <code>GL_BLUE</code>,
        /// <code>GL_ALPHA</code>,
        /// <code>GL_RGB</code>,
        /// <code>GL_BGR</code>,
        /// <code>GL_RGBA</code>,
        /// <code>GL_BGRA</code>,
        /// <code>GL_INTENSITY</code>,
        /// <code>GL_LUMINANCE</code>, and
        /// <code>GL_LUMINANCE_ALPHA</code>.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// The type of the pixel data in <paramref name="row"/> and <paramref name="column"/>.
        /// Symbolic constants
        /// <code>GL_UNSIGNED_BYTE</code>,
        /// <code>GL_BYTE</code>,
        /// <code>GL_BITMAP</code>,
        /// <code>GL_UNSIGNED_SHORT</code>,
        /// <code>GL_SHORT</code>,
        /// <code>GL_UNSIGNED_INT</code>,
        /// <code>GL_INT</code>,
        /// <code>GL_FLOAT</code>,
        /// <code>GL_UNSIGNED_BYTE_3_3_2</code>,
        /// <code>GL_UNSIGNED_BYTE_2_3_3_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_5_6_5</code>,
        /// <code>GL_UNSIGNED_SHORT_5_6_5_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_4_4_4_4</code>,
        /// <code>GL_UNSIGNED_SHORT_4_4_4_4_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_5_5_5_1</code>,
        /// <code>GL_UNSIGNED_SHORT_1_5_5_5_REV</code>,
        /// <code>GL_UNSIGNED_INT_8_8_8_8</code>,
        /// <code>GL_UNSIGNED_INT_8_8_8_8_REV</code>,
        /// <code>GL_UNSIGNED_INT_10_10_10_2</code>, and
        /// <code>GL_UNSIGNED_INT_2_10_10_10_REV</code>
        /// are accepted.
        /// </para>
        /// </param>
        /// <param name="row">
        /// <para>
        /// Pointer to a one-dimensional array of pixel data that is processed to
        /// build the row filter kernel.
        /// </para>
        /// </param>
        /// <param name="column">
        /// <para>
        /// Pointer to a one-dimensional array of pixel data that is processed to
        /// build the column filter kernel.
        /// </para>
        /// </param>
        /// <seealso cref="glConvolutionFilter1D"/>
        /// <seealso cref="glConvolutionFilter2D"/>
        /// <seealso cref="glConvolutionParameter"/>
        /// <seealso cref="glPixelTransfer"/>
        public unsafe static void glSeparableFilter2D(uint target, uint internalformat, int width, int height, uint format, uint type, void* row, void* column) {
            var _F = _GetProc<GLNativeDelegate.FNglSeparableFilter2D>("glSeparableFilter2D");
            _F(target, internalformat, width, height, format, type, row, column);
        }
        /// <summary>
        /// get histogram table
        /// <para>Require:</para> <para>GL_ARB_imaging</para>
        /// Supported: <para>gl, glcore</para>
        /// Notes: 
        /// <para>
        /// <see cref="glGetHistogram"/> is present only if <code>ARB_imaging</code> is returned when  <see cref="glGetString"/> 
        /// is called with an argument of <code>GL_EXTENSIONS</code>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="target"/> is not <code>GL_HISTOGRAM</code>.
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="format"/> is not one of the allowable
        /// values.
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="type"/> is not one of the allowable
        /// values.
        /// <code>GL_INVALID_OPERATION</code> is generated if <paramref name="type"/> is one of
        /// <code>GL_UNSIGNED_BYTE_3_3_2</code>,
        /// <code>GL_UNSIGNED_BYTE_2_3_3_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_5_6_5</code>, or
        /// <code>GL_UNSIGNED_SHORT_5_6_5_REV</code>
        /// and <paramref name="format"/> is not <code>GL_RGB</code>.
        /// <code>GL_INVALID_OPERATION</code> is generated if <paramref name="type"/> is one of
        /// <code>GL_UNSIGNED_SHORT_4_4_4_4</code>,
        /// <code>GL_UNSIGNED_SHORT_4_4_4_4_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_5_5_5_1</code>,
        /// <code>GL_UNSIGNED_SHORT_1_5_5_5_REV</code>,
        /// <code>GL_UNSIGNED_INT_8_8_8_8</code>,
        /// <code>GL_UNSIGNED_INT_8_8_8_8_REV</code>,
        /// <code>GL_UNSIGNED_INT_10_10_10_2</code>, or
        /// <code>GL_UNSIGNED_INT_2_10_10_10_REV</code>
        /// and <paramref name="format"/> is neither <code>GL_RGBA</code> nor <code>GL_BGRA</code>.
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_PACK_BUFFER</code> target and the buffer object's data store is currently mapped.
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_PACK_BUFFER</code> target and the data would be packed to the buffer 
        /// object such that the memory writes required would exceed the data store size.
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_PACK_BUFFER</code> target and <paramref name="values"/> is not evenly divisible 
        /// into the number of bytes needed to store in memory a datum indicated by <paramref name="type"/>.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glGetHistogram"/> is executed
        /// between the execution of  <see cref="glBegin"/>  and the corresponding
        /// execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glGetHistogram(GLenum target, GLboolean reset, GLenum format, GLenum type, void * values);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Must be
        /// <code>GL_HISTOGRAM</code>.
        /// </para>
        /// </param>
        /// <param name="reset">
        /// <para>
        /// If <code>GL_TRUE</code>, each component counter that is actually returned
        /// is reset to zero.  (Other counters are unaffected.)
        /// If <code>GL_FALSE</code>, none of the counters in the histogram table is modified.
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// The format of values to be returned in <paramref name="values"/>.
        /// Must be one of
        /// <code>GL_RED</code>,
        /// <code>GL_GREEN</code>,
        /// <code>GL_BLUE</code>,
        /// <code>GL_ALPHA</code>,
        /// <code>GL_RGB</code>,
        /// <code>GL_BGR</code>,
        /// <code>GL_RGBA</code>,
        /// <code>GL_BGRA</code>,
        /// <code>GL_LUMINANCE</code>, or
        /// <code>GL_LUMINANCE_ALPHA</code>.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// The type of values to be returned in <paramref name="values"/>.
        /// Symbolic constants
        /// <code>GL_UNSIGNED_BYTE</code>,
        /// <code>GL_BYTE</code>,
        /// <code>GL_BITMAP</code>,
        /// <code>GL_UNSIGNED_SHORT</code>,
        /// <code>GL_SHORT</code>,
        /// <code>GL_UNSIGNED_INT</code>,
        /// <code>GL_INT</code>,
        /// <code>GL_FLOAT</code>,
        /// <code>GL_UNSIGNED_BYTE_3_3_2</code>,
        /// <code>GL_UNSIGNED_BYTE_2_3_3_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_5_6_5</code>,
        /// <code>GL_UNSIGNED_SHORT_5_6_5_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_4_4_4_4</code>,
        /// <code>GL_UNSIGNED_SHORT_4_4_4_4_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_5_5_5_1</code>,
        /// <code>GL_UNSIGNED_SHORT_1_5_5_5_REV</code>,
        /// <code>GL_UNSIGNED_INT_8_8_8_8</code>,
        /// <code>GL_UNSIGNED_INT_8_8_8_8_REV</code>,
        /// <code>GL_UNSIGNED_INT_10_10_10_2</code>, and
        /// <code>GL_UNSIGNED_INT_2_10_10_10_REV</code>
        /// are accepted.
        /// </para>
        /// </param>
        /// <param name="values">
        /// A pointer to storage for the returned histogram table.
        /// </param>
        /// <seealso cref="glHistogram"/>
        /// <seealso cref="glResetHistogram"/>
        public unsafe static void glGetHistogram(uint target, bool reset, uint format, uint type, void* values) {
            var _F = _GetProc<GLNativeDelegate.FNglGetHistogram>("glGetHistogram");
            _F(target, reset, format, type, values);
        }
        /// <summary>
        /// get histogram parameters
        /// <para>Require:</para> <para>GL_ARB_imaging</para>
        /// Supported: <para>gl, glcore</para>
        /// Notes: 
        /// <para>
        /// <see cref="glGetHistogramParameter"/> is present only if <code>ARB_imaging</code> is returned when  <see cref="glGetString"/> 
        /// is called with an argument of <code>GL_EXTENSIONS</code>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="target"/> is not one of the allowable
        /// values.
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="pname"/> is not one of the allowable
        /// values.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glGetHistogramParameter"/> is executed
        /// between the execution of  <see cref="glBegin"/>  and the corresponding
        /// execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glGetHistogramParameterfv(GLenum target, GLenum pname, GLfloat * params);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Must be one of
        /// <code>GL_HISTOGRAM</code> or
        /// <code>GL_PROXY_HISTOGRAM</code>.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// The name of the parameter to be retrieved.
        /// Must be one of
        /// <code>GL_HISTOGRAM_WIDTH</code>,
        /// <code>GL_HISTOGRAM_FORMAT</code>,
        /// <code>GL_HISTOGRAM_RED_SIZE</code>,
        /// <code>GL_HISTOGRAM_GREEN_SIZE</code>,
        /// <code>GL_HISTOGRAM_BLUE_SIZE</code>,
        /// <code>GL_HISTOGRAM_ALPHA_SIZE</code>,
        /// <code>GL_HISTOGRAM_LUMINANCE_SIZE</code>, or
        /// <code>GL_HISTOGRAM_SINK</code>.
        /// </para>
        /// </param>
        /// <param name="ps">
        /// Pointer to storage for the returned values.
        /// </param>
        /// <seealso cref="glGetHistogram"/>
        /// <seealso cref="glHistogram"/>
        public unsafe static void glGetHistogramParameterfv(uint target, uint pname, float* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetHistogramParameterfv>("glGetHistogramParameterfv");
            _F(target, pname, ps);
        }
        /// <summary>
        /// get histogram parameters
        /// <para>Require:</para> <para>GL_ARB_imaging</para>
        /// Supported: <para>gl, glcore</para>
        /// Notes: 
        /// <para>
        /// <see cref="glGetHistogramParameter"/> is present only if <code>ARB_imaging</code> is returned when  <see cref="glGetString"/> 
        /// is called with an argument of <code>GL_EXTENSIONS</code>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="target"/> is not one of the allowable
        /// values.
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="pname"/> is not one of the allowable
        /// values.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glGetHistogramParameter"/> is executed
        /// between the execution of  <see cref="glBegin"/>  and the corresponding
        /// execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glGetHistogramParameteriv(GLenum target, GLenum pname, GLint * params);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Must be one of
        /// <code>GL_HISTOGRAM</code> or
        /// <code>GL_PROXY_HISTOGRAM</code>.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// The name of the parameter to be retrieved.
        /// Must be one of
        /// <code>GL_HISTOGRAM_WIDTH</code>,
        /// <code>GL_HISTOGRAM_FORMAT</code>,
        /// <code>GL_HISTOGRAM_RED_SIZE</code>,
        /// <code>GL_HISTOGRAM_GREEN_SIZE</code>,
        /// <code>GL_HISTOGRAM_BLUE_SIZE</code>,
        /// <code>GL_HISTOGRAM_ALPHA_SIZE</code>,
        /// <code>GL_HISTOGRAM_LUMINANCE_SIZE</code>, or
        /// <code>GL_HISTOGRAM_SINK</code>.
        /// </para>
        /// </param>
        /// <param name="ps">
        /// Pointer to storage for the returned values.
        /// </param>
        /// <seealso cref="glGetHistogram"/>
        /// <seealso cref="glHistogram"/>
        public unsafe static void glGetHistogramParameteriv(uint target, uint pname, int* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetHistogramParameteriv>("glGetHistogramParameteriv");
            _F(target, pname, ps);
        }
        /// <summary>
        /// get minimum and maximum pixel values
        /// <para>Require:</para> <para>GL_ARB_imaging</para>
        /// Supported: <para>gl, glcore</para>
        /// Notes: 
        /// <para>
        /// <see cref="glGetMinmax"/> is present only if <code>ARB_imaging</code> is returned when  <see cref="glGetString"/> 
        /// is called with an argument of <code>GL_EXTENSIONS</code>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="target"/> is not <code>GL_MINMAX</code>.
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="format"/> is not one of the allowable
        /// values.
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="types"/> is not one of the allowable
        /// values.
        /// <code>GL_INVALID_OPERATION</code> is generated if <paramref name="types"/> is one of
        /// <code>GL_UNSIGNED_BYTE_3_3_2</code>,
        /// <code>GL_UNSIGNED_BYTE_2_3_3_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_5_6_5</code>, or
        /// <code>GL_UNSIGNED_SHORT_5_6_5_REV</code>
        /// and <paramref name="format"/> is not <code>GL_RGB</code>.
        /// <code>GL_INVALID_OPERATION</code> is generated if <paramref name="types"/> is one of
        /// <code>GL_UNSIGNED_SHORT_4_4_4_4</code>,
        /// <code>GL_UNSIGNED_SHORT_4_4_4_4_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_5_5_5_1</code>,
        /// <code>GL_UNSIGNED_SHORT_1_5_5_5_REV</code>,
        /// <code>GL_UNSIGNED_INT_8_8_8_8</code>,
        /// <code>GL_UNSIGNED_INT_8_8_8_8_REV</code>,
        /// <code>GL_UNSIGNED_INT_10_10_10_2</code>, or
        /// <code>GL_UNSIGNED_INT_2_10_10_10_REV</code>
        /// and <paramref name="format"/> is neither <code>GL_RGBA</code> nor <code>GL_BGRA</code>.
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_PACK_BUFFER</code> target and the buffer object's data store is currently mapped.
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_PACK_BUFFER</code> target and the data would be packed to the buffer 
        /// object such that the memory writes required would exceed the data store size.
        /// <code>GL_INVALID_OPERATION</code> is generated if a non-zero buffer object name is bound to the
        /// <code>GL_PIXEL_PACK_BUFFER</code> target and <paramref name="values"/> is not evenly divisible 
        /// into the number of bytes needed to store in memory a datum indicated by <paramref name="type"/>.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glGetMinmax"/> is executed
        /// between the execution of  <see cref="glBegin"/>  and the corresponding
        /// execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glGetMinmax(GLenum target, GLboolean reset, GLenum format, GLenum types, void * values);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Must be
        /// <code>GL_MINMAX</code>.
        /// </para>
        /// </param>
        /// <param name="reset">
        /// <para>
        /// If <code>GL_TRUE</code>, all entries in the minmax table that are actually
        /// returned are reset to their initial values.  (Other entries are unaltered.)
        /// If <code>GL_FALSE</code>, the minmax table is unaltered.
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// The format of the data to be returned in <paramref name="values"/>.
        /// Must be one of
        /// <code>GL_RED</code>,
        /// <code>GL_GREEN</code>,
        /// <code>GL_BLUE</code>,
        /// <code>GL_ALPHA</code>,
        /// <code>GL_RGB</code>,
        /// <code>GL_BGR</code>,
        /// <code>GL_RGBA</code>,
        /// <code>GL_BGRA</code>,
        /// <code>GL_LUMINANCE</code>, or
        /// <code>GL_LUMINANCE_ALPHA</code>.
        /// </para>
        /// </param>
        /// <param name="types">
        /// <para>
        /// The type of the data to be returned in <paramref name="values"/>.
        /// Symbolic constants
        /// <code>GL_UNSIGNED_BYTE</code>,
        /// <code>GL_BYTE</code>,
        /// <code>GL_BITMAP</code>,
        /// <code>GL_UNSIGNED_SHORT</code>,
        /// <code>GL_SHORT</code>,
        /// <code>GL_UNSIGNED_INT</code>,
        /// <code>GL_INT</code>,
        /// <code>GL_FLOAT</code>,
        /// <code>GL_UNSIGNED_BYTE_3_3_2</code>,
        /// <code>GL_UNSIGNED_BYTE_2_3_3_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_5_6_5</code>,
        /// <code>GL_UNSIGNED_SHORT_5_6_5_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_4_4_4_4</code>,
        /// <code>GL_UNSIGNED_SHORT_4_4_4_4_REV</code>,
        /// <code>GL_UNSIGNED_SHORT_5_5_5_1</code>,
        /// <code>GL_UNSIGNED_SHORT_1_5_5_5_REV</code>,
        /// <code>GL_UNSIGNED_INT_8_8_8_8</code>,
        /// <code>GL_UNSIGNED_INT_8_8_8_8_REV</code>,
        /// <code>GL_UNSIGNED_INT_10_10_10_2</code>, and
        /// <code>GL_UNSIGNED_INT_2_10_10_10_REV</code>
        /// are accepted.
        /// </para>
        /// </param>
        /// <param name="values">
        /// A pointer to storage for the returned values.
        /// </param>
        /// <seealso cref="glMinmax"/>
        /// <seealso cref="glResetMinmax"/>
        public unsafe static void glGetMinmax(uint target, bool reset, uint format, uint types, void* values) {
            var _F = _GetProc<GLNativeDelegate.FNglGetMinmax>("glGetMinmax");
            _F(target, reset, format, types, values);
        }
        /// <summary>
        /// get minmax parameters
        /// <para>Require:</para> <para>GL_ARB_imaging</para>
        /// Supported: <para>gl, glcore</para>
        /// Notes: 
        /// <para>
        /// <see cref="glGetMinmaxParameter"/> is present only if <code>ARB_imaging</code> is returned when  <see cref="glGetString"/> 
        /// is called with an argument of <code>GL_EXTENSIONS</code>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="target"/> is not <code>GL_MINMAX</code>.
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="pname"/> is not one of the allowable
        /// values.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glGetMinmaxParameter"/> is executed
        /// between the execution of  <see cref="glBegin"/>  and the corresponding
        /// execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glGetMinmaxParameterfv(GLenum target, GLenum pname, GLfloat * params);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Must be
        /// <code>GL_MINMAX</code>.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// The parameter to be retrieved.
        /// Must be one of
        /// <code>GL_MINMAX_FORMAT</code> or
        /// <code>GL_MINMAX_SINK</code>.
        /// </para>
        /// </param>
        /// <param name="ps">
        /// A pointer to storage for the retrieved parameters.
        /// </param>
        /// <seealso cref="glMinmax"/>
        /// <seealso cref="glGetMinmax"/>
        public unsafe static void glGetMinmaxParameterfv(uint target, uint pname, float* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetMinmaxParameterfv>("glGetMinmaxParameterfv");
            _F(target, pname, ps);
        }
        /// <summary>
        /// get minmax parameters
        /// <para>Require:</para> <para>GL_ARB_imaging</para>
        /// Supported: <para>gl, glcore</para>
        /// Notes: 
        /// <para>
        /// <see cref="glGetMinmaxParameter"/> is present only if <code>ARB_imaging</code> is returned when  <see cref="glGetString"/> 
        /// is called with an argument of <code>GL_EXTENSIONS</code>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="target"/> is not <code>GL_MINMAX</code>.
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="pname"/> is not one of the allowable
        /// values.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glGetMinmaxParameter"/> is executed
        /// between the execution of  <see cref="glBegin"/>  and the corresponding
        /// execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glGetMinmaxParameteriv(GLenum target, GLenum pname, GLint * params);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Must be
        /// <code>GL_MINMAX</code>.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// The parameter to be retrieved.
        /// Must be one of
        /// <code>GL_MINMAX_FORMAT</code> or
        /// <code>GL_MINMAX_SINK</code>.
        /// </para>
        /// </param>
        /// <param name="ps">
        /// A pointer to storage for the retrieved parameters.
        /// </param>
        /// <seealso cref="glMinmax"/>
        /// <seealso cref="glGetMinmax"/>
        public unsafe static void glGetMinmaxParameteriv(uint target, uint pname, int* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetMinmaxParameteriv>("glGetMinmaxParameteriv");
            _F(target, pname, ps);
        }
        /// <summary>
        /// define histogram table
        /// <para>Require:</para> <para>GL_ARB_imaging</para>
        /// Supported: <para>gl, glcore</para>
        /// Notes: 
        /// <para>
        /// <see cref="glHistogram"/> is present only if <code>ARB_imaging</code> is returned when  <see cref="glGetString"/> 
        /// is called with an argument of <code>GL_EXTENSIONS</code>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="target"/> is not one of the allowable
        /// values.
        /// <code>GL_INVALID_VALUE</code> is generated if <paramref name="width"/> is less than zero or is
        /// not a power of 2.
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="internalformat"/> is not one of the
        /// allowable values.
        /// <code>GL_TABLE_TOO_LARGE</code> is generated if <paramref name="target"/> is <code>GL_HISTOGRAM</code>
        /// and the histogram table specified is too large for the implementation.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glHistogram"/> is executed
        /// between the execution of  <see cref="glBegin"/>  and the corresponding
        /// execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glHistogram(GLenum target, GLsizei width, GLenum internalformat, GLboolean sink);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// The histogram whose parameters are to be set.
        /// Must be one of
        /// <code>GL_HISTOGRAM</code> or
        /// <code>GL_PROXY_HISTOGRAM</code>.
        /// </para>
        /// </param>
        /// <param name="width">
        /// The number of entries in the histogram table.  Must be a power of 2.
        /// </param>
        /// <param name="internalformat">
        /// <para>
        /// The format of entries in the histogram table.
        /// Must be one of
        /// <code>GL_ALPHA</code>,
        /// <code>GL_ALPHA4</code>,
        /// <code>GL_ALPHA8</code>,
        /// <code>GL_ALPHA12</code>,
        /// <code>GL_ALPHA16</code>,
        /// <code>GL_LUMINANCE</code>,
        /// <code>GL_LUMINANCE4</code>,
        /// <code>GL_LUMINANCE8</code>,
        /// <code>GL_LUMINANCE12</code>,
        /// <code>GL_LUMINANCE16</code>,
        /// <code>GL_LUMINANCE_ALPHA</code>,
        /// <code>GL_LUMINANCE4_ALPHA4</code>,
        /// <code>GL_LUMINANCE6_ALPHA2</code>,
        /// <code>GL_LUMINANCE8_ALPHA8</code>,
        /// <code>GL_LUMINANCE12_ALPHA4</code>,
        /// <code>GL_LUMINANCE12_ALPHA12</code>,
        /// <code>GL_LUMINANCE16_ALPHA16</code>,
        /// <code>GL_R3_G3_B2</code>,
        /// <code>GL_RGB</code>,
        /// <code>GL_RGB4</code>,
        /// <code>GL_RGB5</code>,
        /// <code>GL_RGB8</code>,
        /// <code>GL_RGB10</code>,
        /// <code>GL_RGB12</code>,
        /// <code>GL_RGB16</code>,
        /// <code>GL_RGBA</code>,
        /// <code>GL_RGBA2</code>,
        /// <code>GL_RGBA4</code>,
        /// <code>GL_RGB5_A1</code>,
        /// <code>GL_RGBA8</code>,
        /// <code>GL_RGB10_A2</code>,
        /// <code>GL_RGBA12</code>, or
        /// <code>GL_RGBA16</code>.
        /// </para>
        /// </param>
        /// <param name="sink">
        /// <para>
        /// If <code>GL_TRUE</code>, pixels will be consumed by the histogramming
        /// process and no drawing or texture loading will take place.
        /// If <code>GL_FALSE</code>, pixels will proceed to the minmax process after
        /// histogramming.
        /// </para>
        /// </param>
        /// <seealso cref="glGetHistogram"/>
        /// <seealso cref="glResetHistogram"/>
        public static void glHistogram(uint target, int width, uint internalformat, bool sink) {
            var _F = _GetProc<GLNativeDelegate.FNglHistogram>("glHistogram");
            _F(target, width, internalformat, sink);
        }
        /// <summary>
        /// define minmax table
        /// <para>Require:</para> <para>GL_ARB_imaging</para>
        /// Supported: <para>gl, glcore</para>
        /// Notes: 
        /// <para>
        /// <see cref="glMinmax"/> is present only if <code>ARB_imaging</code> is returned when  <see cref="glGetString"/> 
        /// is called with an argument of <code>GL_EXTENSIONS</code>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="target"/> is not one of the allowable
        /// values.
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="internalformat"/> is not one of the
        /// allowable values.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glMinmax"/> is executed
        /// between the execution of  <see cref="glBegin"/>  and the corresponding
        /// execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glMinmax(GLenum target, GLenum internalformat, GLboolean sink);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// The minmax table whose parameters are to be set.
        /// Must be
        /// <code>GL_MINMAX</code>.
        /// </para>
        /// </param>
        /// <param name="internalformat">
        /// <para>
        /// The format of entries in the minmax table.
        /// Must be one of
        /// <code>GL_ALPHA</code>,
        /// <code>GL_ALPHA4</code>,
        /// <code>GL_ALPHA8</code>,
        /// <code>GL_ALPHA12</code>,
        /// <code>GL_ALPHA16</code>,
        /// <code>GL_LUMINANCE</code>,
        /// <code>GL_LUMINANCE4</code>,
        /// <code>GL_LUMINANCE8</code>,
        /// <code>GL_LUMINANCE12</code>,
        /// <code>GL_LUMINANCE16</code>,
        /// <code>GL_LUMINANCE_ALPHA</code>,
        /// <code>GL_LUMINANCE4_ALPHA4</code>,
        /// <code>GL_LUMINANCE6_ALPHA2</code>,
        /// <code>GL_LUMINANCE8_ALPHA8</code>,
        /// <code>GL_LUMINANCE12_ALPHA4</code>,
        /// <code>GL_LUMINANCE12_ALPHA12</code>,
        /// <code>GL_LUMINANCE16_ALPHA16</code>,
        /// <code>GL_R3_G3_B2</code>,
        /// <code>GL_RGB</code>,
        /// <code>GL_RGB4</code>,
        /// <code>GL_RGB5</code>,
        /// <code>GL_RGB8</code>,
        /// <code>GL_RGB10</code>,
        /// <code>GL_RGB12</code>,
        /// <code>GL_RGB16</code>,
        /// <code>GL_RGBA</code>,
        /// <code>GL_RGBA2</code>,
        /// <code>GL_RGBA4</code>,
        /// <code>GL_RGB5_A1</code>,
        /// <code>GL_RGBA8</code>,
        /// <code>GL_RGB10_A2</code>,
        /// <code>GL_RGBA12</code>, or
        /// <code>GL_RGBA16</code>.
        /// </para>
        /// </param>
        /// <param name="sink">
        /// <para>
        /// If <code>GL_TRUE</code>, pixels will be consumed by the minmax
        /// process and no drawing or texture loading will take place.
        /// If <code>GL_FALSE</code>, pixels will proceed to the final conversion process after
        /// minmax.
        /// </para>
        /// </param>
        /// <seealso cref="glGetMinmax"/>
        /// <seealso cref="glResetMinmax"/>
        public static void glMinmax(uint target, uint internalformat, bool sink) {
            var _F = _GetProc<GLNativeDelegate.FNglMinmax>("glMinmax");
            _F(target, internalformat, sink);
        }
        /// <summary>
        /// reset histogram table entries to zero
        /// <para>Require:</para> <para>GL_ARB_imaging</para>
        /// Supported: <para>gl, glcore</para>
        /// Notes: 
        /// <para>
        /// <see cref="glResetHistogram"/> is present only if <code>ARB_imaging</code> is returned when  <see cref="glGetString"/> 
        /// is called with an argument of <code>GL_EXTENSIONS</code>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="target"/> is not <code>GL_HISTOGRAM</code>.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glResetHistogram"/> is executed
        /// between the execution of  <see cref="glBegin"/>  and the corresponding
        /// execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glResetHistogram(GLenum target);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Must be
        /// <code>GL_HISTOGRAM</code>.
        /// </para>
        /// </param>
        /// <seealso cref="glHistogram"/>
        public static void glResetHistogram(uint target) {
            var _F = _GetProc<GLNativeDelegate.FNglResetHistogram>("glResetHistogram");
            _F(target);
        }
        /// <summary>
        /// reset minmax table entries to initial values
        /// <para>Require:</para> <para>GL_ARB_imaging</para>
        /// Supported: <para>gl, glcore</para>
        /// Notes: 
        /// <para>
        /// <see cref="glResetMinmax"/> is present only if <code>ARB_imaging</code> is returned when  <see cref="glGetString"/> 
        /// is called with an argument of <code>GL_EXTENSIONS</code>.
        /// </para>
        /// Errors: 
        /// <para>
        /// <code>GL_INVALID_ENUM</code> is generated if <paramref name="target"/> is not <code>GL_MINMAX</code>.
        /// <code>GL_INVALID_OPERATION</code> is generated if <see cref="glResetMinmax"/> is executed
        /// between the execution of  <see cref="glBegin"/>  and the corresponding
        /// execution of  <see cref="glEnd"/> .
        /// </para>
        /// Original: <para>void glResetMinmax(GLenum target);</para>
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Must be
        /// <code>GL_MINMAX</code>.
        /// </para>
        /// </param>
        /// <seealso cref="glMinmax"/>
        public static void glResetMinmax(uint target) {
            var _F = _GetProc<GLNativeDelegate.FNglResetMinmax>("glResetMinmax");
            _F(target);
        }

        #endregion GL_ARB_imaging

        #region GL_ARB_indirect_parameters

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_indirect_parameters</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glMultiDrawArraysIndirectCountARB(GLenum mode, const void * indirect, GLintptr drawcount, GLsizei maxdrawcount, GLsizei stride);</para>
        /// </summary>
        public unsafe static void glMultiDrawArraysIndirectCountARB(uint mode, void* indirect, IntPtr drawcount, int maxdrawcount, int stride) {
            var _F = _GetProc<GLNativeDelegate.FNglMultiDrawArraysIndirectCountARB>("glMultiDrawArraysIndirectCountARB");
            _F(mode, indirect, drawcount, maxdrawcount, stride);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_indirect_parameters</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glMultiDrawElementsIndirectCountARB(GLenum mode, GLenum type, const void * indirect, GLintptr drawcount, GLsizei maxdrawcount, GLsizei stride);</para>
        /// </summary>
        public unsafe static void glMultiDrawElementsIndirectCountARB(uint mode, uint type, void* indirect, IntPtr drawcount, int maxdrawcount, int stride) {
            var _F = _GetProc<GLNativeDelegate.FNglMultiDrawElementsIndirectCountARB>("glMultiDrawElementsIndirectCountARB");
            _F(mode, type, indirect, drawcount, maxdrawcount, stride);
        }

        #endregion GL_ARB_indirect_parameters

        #region GL_ARB_instanced_arrays

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_instanced_arrays</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glVertexAttribDivisorARB(GLuint index, GLuint divisor);</para>
        /// </summary>
        public static void glVertexAttribDivisorARB(uint index, uint divisor) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttribDivisorARB>("glVertexAttribDivisorARB");
            _F(index, divisor);
        }

        #endregion GL_ARB_instanced_arrays

        #region GL_ARB_internalformat_query

        // void glGetInternalformativ(GLenum target, GLenum internalformat, GLenum pname, GLsizei bufSize, GLint * ps);

        #endregion GL_ARB_internalformat_query

        #region GL_ARB_invalidate_subdata

        // void glInvalidateTexSubImage(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth);
        // void glInvalidateTexImage(GLuint texture, GLint level);
        // void glInvalidateBufferSubData(GLuint buffer, GLintptr offset, GLsizeiptr length);
        // void glInvalidateBufferData(GLuint buffer);
        // void glInvalidateFramebuffer(GLenum target, GLsizei numAttachments, const GLenum * attachments);
        // void glInvalidateSubFramebuffer(GLenum target, GLsizei numAttachments, const GLenum * attachments, GLint x, GLint y, GLint width, GLint height);

        #endregion GL_ARB_invalidate_subdata

        #region GL_ARB_map_buffer_range

        // void * glMapBufferRange(GLenum target, GLintptr offset, GLsizeiptr length, GLbitfield access);
        // void glFlushMappedBufferRange(GLenum target, GLintptr offset, GLsizeiptr length);

        #endregion GL_ARB_map_buffer_range

        #region GL_ARB_matrix_palette

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_matrix_palette</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glCurrentPaletteMatrixARB(GLint index);</para>
        /// </summary>
        public static void glCurrentPaletteMatrixARB(int index) {
            var _F = _GetProc<GLNativeDelegate.FNglCurrentPaletteMatrixARB>("glCurrentPaletteMatrixARB");
            _F(index);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_matrix_palette</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glMatrixIndexubvARB(GLint size, const GLubyte * indices);</para>
        /// </summary>
        public unsafe static void glMatrixIndexubvARB(int size, byte* indices) {
            var _F = _GetProc<GLNativeDelegate.FNglMatrixIndexubvARB>("glMatrixIndexubvARB");
            _F(size, indices);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_matrix_palette</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glMatrixIndexusvARB(GLint size, const GLushort * indices);</para>
        /// </summary>
        public unsafe static void glMatrixIndexusvARB(int size, ushort* indices) {
            var _F = _GetProc<GLNativeDelegate.FNglMatrixIndexusvARB>("glMatrixIndexusvARB");
            _F(size, indices);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_matrix_palette</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glMatrixIndexuivARB(GLint size, const GLuint * indices);</para>
        /// </summary>
        public unsafe static void glMatrixIndexuivARB(int size, uint* indices) {
            var _F = _GetProc<GLNativeDelegate.FNglMatrixIndexuivARB>("glMatrixIndexuivARB");
            _F(size, indices);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_matrix_palette</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glMatrixIndexPointerARB(GLint size, GLenum type, GLsizei stride, const void * pointer);</para>
        /// </summary>
        public unsafe static void glMatrixIndexPointerARB(int size, uint type, int stride, void* pointer) {
            var _F = _GetProc<GLNativeDelegate.FNglMatrixIndexPointerARB>("glMatrixIndexPointerARB");
            _F(size, type, stride, pointer);
        }

        #endregion GL_ARB_matrix_palette

        #region GL_ARB_multi_bind

        // void glBindBuffersBase(GLenum target, GLuint first, GLsizei count, const GLuint * buffers);
        // void glBindBuffersRange(GLenum target, GLuint first, GLsizei count, const GLuint * buffers, const GLintptr * offsets, const GLintptr * sizes);
        // void glBindTextures(GLuint first, GLsizei count, const GLuint * textures);
        // void glBindSamplers(GLuint first, GLsizei count, const GLuint * samplers);
        // void glBindImageTextures(GLuint first, GLsizei count, const GLuint * textures);
        // void glBindVertexBuffers(GLuint first, GLsizei count, const GLuint * buffers, const GLintptr * offsets, const GLsizei * strides);

        #endregion GL_ARB_multi_bind

        #region GL_ARB_multi_draw_indirect

        // void glMultiDrawArraysIndirect(GLenum mode, const void * indirect, GLsizei drawcount, GLsizei stride);
        // void glMultiDrawElementsIndirect(GLenum mode, GLenum type, const void * indirect, GLsizei drawcount, GLsizei stride);

        #endregion GL_ARB_multi_draw_indirect

        #region GL_ARB_multisample

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_multisample</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glSampleCoverageARB(GLfloat value, GLboolean invert);</para>
        /// </summary>
        public static void glSampleCoverageARB(float value, bool invert) {
            var _F = _GetProc<GLNativeDelegate.FNglSampleCoverageARB>("glSampleCoverageARB");
            _F(value, invert);
        }

        #endregion GL_ARB_multisample

        #region GL_ARB_multitexture

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_multitexture</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glActiveTextureARB(GLenum texture);</para>
        /// </summary>
        public static void glActiveTextureARB(uint texture) {
            var _F = _GetProc<GLNativeDelegate.FNglActiveTextureARB>("glActiveTextureARB");
            _F(texture);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_multitexture</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glClientActiveTextureARB(GLenum texture);</para>
        /// </summary>
        public static void glClientActiveTextureARB(uint texture) {
            var _F = _GetProc<GLNativeDelegate.FNglClientActiveTextureARB>("glClientActiveTextureARB");
            _F(texture);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_multitexture</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glMultiTexCoord1dARB(GLenum target, GLdouble s);</para>
        /// </summary>
        public static void glMultiTexCoord1dARB(uint target, double s) {
            var _F = _GetProc<GLNativeDelegate.FNglMultiTexCoord1dARB>("glMultiTexCoord1dARB");
            _F(target, s);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_multitexture</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glMultiTexCoord1dvARB(GLenum target, const GLdouble * v);</para>
        /// </summary>
        public unsafe static void glMultiTexCoord1dvARB(uint target, double* v) {
            var _F = _GetProc<GLNativeDelegate.FNglMultiTexCoord1dvARB>("glMultiTexCoord1dvARB");
            _F(target, v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_multitexture</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glMultiTexCoord1fARB(GLenum target, GLfloat s);</para>
        /// </summary>
        public static void glMultiTexCoord1fARB(uint target, float s) {
            var _F = _GetProc<GLNativeDelegate.FNglMultiTexCoord1fARB>("glMultiTexCoord1fARB");
            _F(target, s);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_multitexture</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glMultiTexCoord1fvARB(GLenum target, const GLfloat * v);</para>
        /// </summary>
        public unsafe static void glMultiTexCoord1fvARB(uint target, float* v) {
            var _F = _GetProc<GLNativeDelegate.FNglMultiTexCoord1fvARB>("glMultiTexCoord1fvARB");
            _F(target, v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_multitexture</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glMultiTexCoord1iARB(GLenum target, GLint s);</para>
        /// </summary>
        public static void glMultiTexCoord1iARB(uint target, int s) {
            var _F = _GetProc<GLNativeDelegate.FNglMultiTexCoord1iARB>("glMultiTexCoord1iARB");
            _F(target, s);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_multitexture</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glMultiTexCoord1ivARB(GLenum target, const GLint * v);</para>
        /// </summary>
        public unsafe static void glMultiTexCoord1ivARB(uint target, int* v) {
            var _F = _GetProc<GLNativeDelegate.FNglMultiTexCoord1ivARB>("glMultiTexCoord1ivARB");
            _F(target, v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_multitexture</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glMultiTexCoord1sARB(GLenum target, GLshort s);</para>
        /// </summary>
        public static void glMultiTexCoord1sARB(uint target, short s) {
            var _F = _GetProc<GLNativeDelegate.FNglMultiTexCoord1sARB>("glMultiTexCoord1sARB");
            _F(target, s);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_multitexture</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glMultiTexCoord1svARB(GLenum target, const GLshort * v);</para>
        /// </summary>
        public unsafe static void glMultiTexCoord1svARB(uint target, short* v) {
            var _F = _GetProc<GLNativeDelegate.FNglMultiTexCoord1svARB>("glMultiTexCoord1svARB");
            _F(target, v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_multitexture</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glMultiTexCoord2dARB(GLenum target, GLdouble s, GLdouble t);</para>
        /// </summary>
        public static void glMultiTexCoord2dARB(uint target, double s, double t) {
            var _F = _GetProc<GLNativeDelegate.FNglMultiTexCoord2dARB>("glMultiTexCoord2dARB");
            _F(target, s, t);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_multitexture</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glMultiTexCoord2dvARB(GLenum target, const GLdouble * v);</para>
        /// </summary>
        public unsafe static void glMultiTexCoord2dvARB(uint target, double* v) {
            var _F = _GetProc<GLNativeDelegate.FNglMultiTexCoord2dvARB>("glMultiTexCoord2dvARB");
            _F(target, v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_multitexture</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glMultiTexCoord2fARB(GLenum target, GLfloat s, GLfloat t);</para>
        /// </summary>
        public static void glMultiTexCoord2fARB(uint target, float s, float t) {
            var _F = _GetProc<GLNativeDelegate.FNglMultiTexCoord2fARB>("glMultiTexCoord2fARB");
            _F(target, s, t);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_multitexture</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glMultiTexCoord2fvARB(GLenum target, const GLfloat * v);</para>
        /// </summary>
        public unsafe static void glMultiTexCoord2fvARB(uint target, float* v) {
            var _F = _GetProc<GLNativeDelegate.FNglMultiTexCoord2fvARB>("glMultiTexCoord2fvARB");
            _F(target, v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_multitexture</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glMultiTexCoord2iARB(GLenum target, GLint s, GLint t);</para>
        /// </summary>
        public static void glMultiTexCoord2iARB(uint target, int s, int t) {
            var _F = _GetProc<GLNativeDelegate.FNglMultiTexCoord2iARB>("glMultiTexCoord2iARB");
            _F(target, s, t);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_multitexture</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glMultiTexCoord2ivARB(GLenum target, const GLint * v);</para>
        /// </summary>
        public unsafe static void glMultiTexCoord2ivARB(uint target, int* v) {
            var _F = _GetProc<GLNativeDelegate.FNglMultiTexCoord2ivARB>("glMultiTexCoord2ivARB");
            _F(target, v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_multitexture</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glMultiTexCoord2sARB(GLenum target, GLshort s, GLshort t);</para>
        /// </summary>
        public static void glMultiTexCoord2sARB(uint target, short s, short t) {
            var _F = _GetProc<GLNativeDelegate.FNglMultiTexCoord2sARB>("glMultiTexCoord2sARB");
            _F(target, s, t);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_multitexture</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glMultiTexCoord2svARB(GLenum target, const GLshort * v);</para>
        /// </summary>
        public unsafe static void glMultiTexCoord2svARB(uint target, short* v) {
            var _F = _GetProc<GLNativeDelegate.FNglMultiTexCoord2svARB>("glMultiTexCoord2svARB");
            _F(target, v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_multitexture</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glMultiTexCoord3dARB(GLenum target, GLdouble s, GLdouble t, GLdouble r);</para>
        /// </summary>
        public static void glMultiTexCoord3dARB(uint target, double s, double t, double r) {
            var _F = _GetProc<GLNativeDelegate.FNglMultiTexCoord3dARB>("glMultiTexCoord3dARB");
            _F(target, s, t, r);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_multitexture</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glMultiTexCoord3dvARB(GLenum target, const GLdouble * v);</para>
        /// </summary>
        public unsafe static void glMultiTexCoord3dvARB(uint target, double* v) {
            var _F = _GetProc<GLNativeDelegate.FNglMultiTexCoord3dvARB>("glMultiTexCoord3dvARB");
            _F(target, v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_multitexture</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glMultiTexCoord3fARB(GLenum target, GLfloat s, GLfloat t, GLfloat r);</para>
        /// </summary>
        public static void glMultiTexCoord3fARB(uint target, float s, float t, float r) {
            var _F = _GetProc<GLNativeDelegate.FNglMultiTexCoord3fARB>("glMultiTexCoord3fARB");
            _F(target, s, t, r);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_multitexture</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glMultiTexCoord3fvARB(GLenum target, const GLfloat * v);</para>
        /// </summary>
        public unsafe static void glMultiTexCoord3fvARB(uint target, float* v) {
            var _F = _GetProc<GLNativeDelegate.FNglMultiTexCoord3fvARB>("glMultiTexCoord3fvARB");
            _F(target, v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_multitexture</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glMultiTexCoord3iARB(GLenum target, GLint s, GLint t, GLint r);</para>
        /// </summary>
        public static void glMultiTexCoord3iARB(uint target, int s, int t, int r) {
            var _F = _GetProc<GLNativeDelegate.FNglMultiTexCoord3iARB>("glMultiTexCoord3iARB");
            _F(target, s, t, r);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_multitexture</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glMultiTexCoord3ivARB(GLenum target, const GLint * v);</para>
        /// </summary>
        public unsafe static void glMultiTexCoord3ivARB(uint target, int* v) {
            var _F = _GetProc<GLNativeDelegate.FNglMultiTexCoord3ivARB>("glMultiTexCoord3ivARB");
            _F(target, v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_multitexture</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glMultiTexCoord3sARB(GLenum target, GLshort s, GLshort t, GLshort r);</para>
        /// </summary>
        public static void glMultiTexCoord3sARB(uint target, short s, short t, short r) {
            var _F = _GetProc<GLNativeDelegate.FNglMultiTexCoord3sARB>("glMultiTexCoord3sARB");
            _F(target, s, t, r);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_multitexture</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glMultiTexCoord3svARB(GLenum target, const GLshort * v);</para>
        /// </summary>
        public unsafe static void glMultiTexCoord3svARB(uint target, short* v) {
            var _F = _GetProc<GLNativeDelegate.FNglMultiTexCoord3svARB>("glMultiTexCoord3svARB");
            _F(target, v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_multitexture</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glMultiTexCoord4dARB(GLenum target, GLdouble s, GLdouble t, GLdouble r, GLdouble q);</para>
        /// </summary>
        public static void glMultiTexCoord4dARB(uint target, double s, double t, double r, double q) {
            var _F = _GetProc<GLNativeDelegate.FNglMultiTexCoord4dARB>("glMultiTexCoord4dARB");
            _F(target, s, t, r, q);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_multitexture</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glMultiTexCoord4dvARB(GLenum target, const GLdouble * v);</para>
        /// </summary>
        public unsafe static void glMultiTexCoord4dvARB(uint target, double* v) {
            var _F = _GetProc<GLNativeDelegate.FNglMultiTexCoord4dvARB>("glMultiTexCoord4dvARB");
            _F(target, v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_multitexture</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glMultiTexCoord4fARB(GLenum target, GLfloat s, GLfloat t, GLfloat r, GLfloat q);</para>
        /// </summary>
        public static void glMultiTexCoord4fARB(uint target, float s, float t, float r, float q) {
            var _F = _GetProc<GLNativeDelegate.FNglMultiTexCoord4fARB>("glMultiTexCoord4fARB");
            _F(target, s, t, r, q);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_multitexture</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glMultiTexCoord4fvARB(GLenum target, const GLfloat * v);</para>
        /// </summary>
        public unsafe static void glMultiTexCoord4fvARB(uint target, float* v) {
            var _F = _GetProc<GLNativeDelegate.FNglMultiTexCoord4fvARB>("glMultiTexCoord4fvARB");
            _F(target, v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_multitexture</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glMultiTexCoord4iARB(GLenum target, GLint s, GLint t, GLint r, GLint q);</para>
        /// </summary>
        public static void glMultiTexCoord4iARB(uint target, int s, int t, int r, int q) {
            var _F = _GetProc<GLNativeDelegate.FNglMultiTexCoord4iARB>("glMultiTexCoord4iARB");
            _F(target, s, t, r, q);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_multitexture</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glMultiTexCoord4ivARB(GLenum target, const GLint * v);</para>
        /// </summary>
        public unsafe static void glMultiTexCoord4ivARB(uint target, int* v) {
            var _F = _GetProc<GLNativeDelegate.FNglMultiTexCoord4ivARB>("glMultiTexCoord4ivARB");
            _F(target, v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_multitexture</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glMultiTexCoord4sARB(GLenum target, GLshort s, GLshort t, GLshort r, GLshort q);</para>
        /// </summary>
        public static void glMultiTexCoord4sARB(uint target, short s, short t, short r, short q) {
            var _F = _GetProc<GLNativeDelegate.FNglMultiTexCoord4sARB>("glMultiTexCoord4sARB");
            _F(target, s, t, r, q);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_multitexture</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glMultiTexCoord4svARB(GLenum target, const GLshort * v);</para>
        /// </summary>
        public unsafe static void glMultiTexCoord4svARB(uint target, short* v) {
            var _F = _GetProc<GLNativeDelegate.FNglMultiTexCoord4svARB>("glMultiTexCoord4svARB");
            _F(target, v);
        }

        #endregion GL_ARB_multitexture

        #region GL_ARB_occlusion_query

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_occlusion_query</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGenQueriesARB(GLsizei n, GLuint * ids);</para>
        /// </summary>
        public unsafe static void glGenQueriesARB(int n, uint* ids) {
            var _F = _GetProc<GLNativeDelegate.FNglGenQueriesARB>("glGenQueriesARB");
            _F(n, ids);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_occlusion_query</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glDeleteQueriesARB(GLsizei n, const GLuint * ids);</para>
        /// </summary>
        public unsafe static void glDeleteQueriesARB(int n, uint* ids) {
            var _F = _GetProc<GLNativeDelegate.FNglDeleteQueriesARB>("glDeleteQueriesARB");
            _F(n, ids);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_occlusion_query</para>
        /// Supported: <para>gl</para>
        /// Original: <para>GLboolean glIsQueryARB(GLuint id);</para>
        /// </summary>
        public static bool glIsQueryARB(uint id) {
            var _F = _GetProc<GLNativeDelegate.FNglIsQueryARB>("glIsQueryARB");
            return _F(id);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_occlusion_query</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glBeginQueryARB(GLenum target, GLuint id);</para>
        /// </summary>
        public static void glBeginQueryARB(uint target, uint id) {
            var _F = _GetProc<GLNativeDelegate.FNglBeginQueryARB>("glBeginQueryARB");
            _F(target, id);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_occlusion_query</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glEndQueryARB(GLenum target);</para>
        /// </summary>
        public static void glEndQueryARB(uint target) {
            var _F = _GetProc<GLNativeDelegate.FNglEndQueryARB>("glEndQueryARB");
            _F(target);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_occlusion_query</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetQueryivARB(GLenum target, GLenum pname, GLint * params);</para>
        /// </summary>
        public unsafe static void glGetQueryivARB(uint target, uint pname, int* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetQueryivARB>("glGetQueryivARB");
            _F(target, pname, ps);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_occlusion_query</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetQueryObjectivARB(GLuint id, GLenum pname, GLint * params);</para>
        /// </summary>
        public unsafe static void glGetQueryObjectivARB(uint id, uint pname, int* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetQueryObjectivARB>("glGetQueryObjectivARB");
            _F(id, pname, ps);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_occlusion_query</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetQueryObjectuivARB(GLuint id, GLenum pname, GLuint * params);</para>
        /// </summary>
        public unsafe static void glGetQueryObjectuivARB(uint id, uint pname, uint* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetQueryObjectuivARB>("glGetQueryObjectuivARB");
            _F(id, pname, ps);
        }

        #endregion GL_ARB_occlusion_query

        #region GL_ARB_parallel_shader_compile

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_parallel_shader_compile</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glMaxShaderCompilerThreadsARB(GLuint count);</para>
        /// </summary>
        public static void glMaxShaderCompilerThreadsARB(uint count) {
            var _F = _GetProc<GLNativeDelegate.FNglMaxShaderCompilerThreadsARB>("glMaxShaderCompilerThreadsARB");
            _F(count);
        }

        #endregion GL_ARB_parallel_shader_compile

        #region GL_ARB_point_parameters

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_point_parameters</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glPointParameterfARB(GLenum pname, GLfloat param);</para>
        /// </summary>
        public static void glPointParameterfARB(uint pname, float param) {
            var _F = _GetProc<GLNativeDelegate.FNglPointParameterfARB>("glPointParameterfARB");
            _F(pname, param);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_point_parameters</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glPointParameterfvARB(GLenum pname, const GLfloat * params);</para>
        /// </summary>
        public unsafe static void glPointParameterfvARB(uint pname, float* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglPointParameterfvARB>("glPointParameterfvARB");
            _F(pname, ps);
        }

        #endregion GL_ARB_point_parameters

        #region GL_ARB_polygon_offset_clamp

        // void glPolygonOffsetClamp(GLfloat factor, GLfloat units, GLfloat clamp);

        #endregion GL_ARB_polygon_offset_clamp

        #region GL_ARB_program_interface_query

        // void glGetProgramInterfaceiv(GLuint program, GLenum programInterface, GLenum pname, GLint * ps);
        // GLuint glGetProgramResourceIndex(GLuint program, GLenum programInterface, const char * name);
        // void glGetProgramResourceName(GLuint program, GLenum programInterface, GLuint index, GLsizei bufSize, GLsizei * length, char * name);
        // void glGetProgramResourceiv(GLuint program, GLenum programInterface, GLuint index, GLsizei propCount, const GLenum * props, GLsizei bufSize, GLsizei * length, GLint * ps);
        // GLint glGetProgramResourceLocation(GLuint program, GLenum programInterface, const char * name);
        // GLint glGetProgramResourceLocationIndex(GLuint program, GLenum programInterface, const char * name);

        #endregion GL_ARB_program_interface_query

        #region GL_ARB_provoking_vertex

        // void glProvokingVertex(GLenum provokeMode);

        #endregion GL_ARB_provoking_vertex

        #region GL_ARB_robustness

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_robustness</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>GLenum glGetGraphicsResetStatusARB();</para>
        /// </summary>
        public static uint glGetGraphicsResetStatusARB() {
            var _F = _GetProc<GLNativeDelegate.FNglGetGraphicsResetStatusARB>("glGetGraphicsResetStatusARB");
            return _F();
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_robustness</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetnTexImageARB(GLenum target, GLint level, GLenum format, GLenum type, GLsizei bufSize, void * img);</para>
        /// </summary>
        public unsafe static void glGetnTexImageARB(uint target, int level, uint format, uint type, int bufSize, void* img) {
            var _F = _GetProc<GLNativeDelegate.FNglGetnTexImageARB>("glGetnTexImageARB");
            _F(target, level, format, type, bufSize, img);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_robustness</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glReadnPixelsARB(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLsizei bufSize, void * data);</para>
        /// </summary>
        public unsafe static void glReadnPixelsARB(int x, int y, int width, int height, uint format, uint type, int bufSize, void* data) {
            var _F = _GetProc<GLNativeDelegate.FNglReadnPixelsARB>("glReadnPixelsARB");
            _F(x, y, width, height, format, type, bufSize, data);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_robustness</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetnCompressedTexImageARB(GLenum target, GLint lod, GLsizei bufSize, void * img);</para>
        /// </summary>
        public unsafe static void glGetnCompressedTexImageARB(uint target, int lod, int bufSize, void* img) {
            var _F = _GetProc<GLNativeDelegate.FNglGetnCompressedTexImageARB>("glGetnCompressedTexImageARB");
            _F(target, lod, bufSize, img);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_robustness</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetnUniformfvARB(GLuint program, GLint location, GLsizei bufSize, GLfloat * params);</para>
        /// </summary>
        public unsafe static void glGetnUniformfvARB(uint program, int location, int bufSize, float* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetnUniformfvARB>("glGetnUniformfvARB");
            _F(program, location, bufSize, ps);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_robustness</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetnUniformivARB(GLuint program, GLint location, GLsizei bufSize, GLint * params);</para>
        /// </summary>
        public unsafe static void glGetnUniformivARB(uint program, int location, int bufSize, int* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetnUniformivARB>("glGetnUniformivARB");
            _F(program, location, bufSize, ps);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_robustness</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetnUniformuivARB(GLuint program, GLint location, GLsizei bufSize, GLuint * params);</para>
        /// </summary>
        public unsafe static void glGetnUniformuivARB(uint program, int location, int bufSize, uint* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetnUniformuivARB>("glGetnUniformuivARB");
            _F(program, location, bufSize, ps);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_robustness</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetnUniformdvARB(GLuint program, GLint location, GLsizei bufSize, GLdouble * params);</para>
        /// </summary>
        public unsafe static void glGetnUniformdvARB(uint program, int location, int bufSize, double* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetnUniformdvARB>("glGetnUniformdvARB");
            _F(program, location, bufSize, ps);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_robustness</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetnMapdvARB(GLenum target, GLenum query, GLsizei bufSize, GLdouble * v);</para>
        /// </summary>
        public unsafe static void glGetnMapdvARB(uint target, uint query, int bufSize, double* v) {
            var _F = _GetProc<GLNativeDelegate.FNglGetnMapdvARB>("glGetnMapdvARB");
            _F(target, query, bufSize, v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_robustness</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetnMapfvARB(GLenum target, GLenum query, GLsizei bufSize, GLfloat * v);</para>
        /// </summary>
        public unsafe static void glGetnMapfvARB(uint target, uint query, int bufSize, float* v) {
            var _F = _GetProc<GLNativeDelegate.FNglGetnMapfvARB>("glGetnMapfvARB");
            _F(target, query, bufSize, v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_robustness</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetnMapivARB(GLenum target, GLenum query, GLsizei bufSize, GLint * v);</para>
        /// </summary>
        public unsafe static void glGetnMapivARB(uint target, uint query, int bufSize, int* v) {
            var _F = _GetProc<GLNativeDelegate.FNglGetnMapivARB>("glGetnMapivARB");
            _F(target, query, bufSize, v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_robustness</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetnPixelMapfvARB(GLenum map, GLsizei bufSize, GLfloat * values);</para>
        /// </summary>
        public unsafe static void glGetnPixelMapfvARB(uint map, int bufSize, float* values) {
            var _F = _GetProc<GLNativeDelegate.FNglGetnPixelMapfvARB>("glGetnPixelMapfvARB");
            _F(map, bufSize, values);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_robustness</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetnPixelMapuivARB(GLenum map, GLsizei bufSize, GLuint * values);</para>
        /// </summary>
        public unsafe static void glGetnPixelMapuivARB(uint map, int bufSize, uint* values) {
            var _F = _GetProc<GLNativeDelegate.FNglGetnPixelMapuivARB>("glGetnPixelMapuivARB");
            _F(map, bufSize, values);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_robustness</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetnPixelMapusvARB(GLenum map, GLsizei bufSize, GLushort * values);</para>
        /// </summary>
        public unsafe static void glGetnPixelMapusvARB(uint map, int bufSize, ushort* values) {
            var _F = _GetProc<GLNativeDelegate.FNglGetnPixelMapusvARB>("glGetnPixelMapusvARB");
            _F(map, bufSize, values);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_robustness</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetnPolygonStippleARB(GLsizei bufSize, GLubyte * pattern);</para>
        /// </summary>
        public unsafe static void glGetnPolygonStippleARB(int bufSize, byte* pattern) {
            var _F = _GetProc<GLNativeDelegate.FNglGetnPolygonStippleARB>("glGetnPolygonStippleARB");
            _F(bufSize, pattern);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_robustness</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetnColorTableARB(GLenum target, GLenum format, GLenum type, GLsizei bufSize, void * table);</para>
        /// </summary>
        public unsafe static void glGetnColorTableARB(uint target, uint format, uint type, int bufSize, void* table) {
            var _F = _GetProc<GLNativeDelegate.FNglGetnColorTableARB>("glGetnColorTableARB");
            _F(target, format, type, bufSize, table);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_robustness</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetnConvolutionFilterARB(GLenum target, GLenum format, GLenum type, GLsizei bufSize, void * image);</para>
        /// </summary>
        public unsafe static void glGetnConvolutionFilterARB(uint target, uint format, uint type, int bufSize, void* image) {
            var _F = _GetProc<GLNativeDelegate.FNglGetnConvolutionFilterARB>("glGetnConvolutionFilterARB");
            _F(target, format, type, bufSize, image);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_robustness</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetnSeparableFilterARB(GLenum target, GLenum format, GLenum type, GLsizei rowBufSize, void * row, GLsizei columnBufSize, void * column, void * span);</para>
        /// </summary>
        public unsafe static void glGetnSeparableFilterARB(uint target, uint format, uint type, int rowBufSize, void* row, int columnBufSize, void* column, void* span) {
            var _F = _GetProc<GLNativeDelegate.FNglGetnSeparableFilterARB>("glGetnSeparableFilterARB");
            _F(target, format, type, rowBufSize, row, columnBufSize, column, span);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_robustness</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetnHistogramARB(GLenum target, GLboolean reset, GLenum format, GLenum type, GLsizei bufSize, void * values);</para>
        /// </summary>
        public unsafe static void glGetnHistogramARB(uint target, bool reset, uint format, uint type, int bufSize, void* values) {
            var _F = _GetProc<GLNativeDelegate.FNglGetnHistogramARB>("glGetnHistogramARB");
            _F(target, reset, format, type, bufSize, values);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_robustness</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetnMinmaxARB(GLenum target, GLboolean reset, GLenum format, GLenum type, GLsizei bufSize, void * values);</para>
        /// </summary>
        public unsafe static void glGetnMinmaxARB(uint target, bool reset, uint format, uint type, int bufSize, void* values) {
            var _F = _GetProc<GLNativeDelegate.FNglGetnMinmaxARB>("glGetnMinmaxARB");
            _F(target, reset, format, type, bufSize, values);
        }

        #endregion GL_ARB_robustness

        #region GL_ARB_sample_locations

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_sample_locations</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glFramebufferSampleLocationsfvARB(GLenum target, GLuint start, GLsizei count, const GLfloat * v);</para>
        /// </summary>
        public unsafe static void glFramebufferSampleLocationsfvARB(uint target, uint start, int count, float* v) {
            var _F = _GetProc<GLNativeDelegate.FNglFramebufferSampleLocationsfvARB>("glFramebufferSampleLocationsfvARB");
            _F(target, start, count, v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_sample_locations</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glNamedFramebufferSampleLocationsfvARB(GLuint framebuffer, GLuint start, GLsizei count, const GLfloat * v);</para>
        /// </summary>
        public unsafe static void glNamedFramebufferSampleLocationsfvARB(uint framebuffer, uint start, int count, float* v) {
            var _F = _GetProc<GLNativeDelegate.FNglNamedFramebufferSampleLocationsfvARB>("glNamedFramebufferSampleLocationsfvARB");
            _F(framebuffer, start, count, v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_sample_locations</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glEvaluateDepthValuesARB();</para>
        /// </summary>
        public static void glEvaluateDepthValuesARB() {
            var _F = _GetProc<GLNativeDelegate.FNglEvaluateDepthValuesARB>("glEvaluateDepthValuesARB");
            _F();
        }

        #endregion GL_ARB_sample_locations

        #region GL_ARB_sample_shading

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_sample_shading</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glMinSampleShadingARB(GLfloat value);</para>
        /// </summary>
        public static void glMinSampleShadingARB(float value) {
            var _F = _GetProc<GLNativeDelegate.FNglMinSampleShadingARB>("glMinSampleShadingARB");
            _F(value);
        }

        #endregion GL_ARB_sample_shading

        #region GL_ARB_sampler_objects

        // void glGenSamplers(GLsizei n, GLuint * samplers);
        // void glDeleteSamplers(GLsizei n, const GLuint * samplers);
        // GLboolean glIsSampler(GLuint id);
        // void glBindSampler(GLuint unit, GLuint sampler);
        // void glSamplerParameteri(GLuint sampler, GLenum pname, GLint param);
        // void glSamplerParameteriv(GLuint sampler, GLenum pname, const GLint * ps);
        // void glSamplerParameterf(GLuint sampler, GLenum pname, GLfloat param);
        // void glSamplerParameterfv(GLuint sampler, GLenum pname, const GLfloat * ps);
        // void glSamplerParameterIiv(GLuint sampler, GLenum pname, const GLint * ps);
        // void glSamplerParameterIuiv(GLuint sampler, GLenum pname, const GLuint * ps);
        // void glGetSamplerParameteriv(GLuint sampler, GLenum pname, GLint * ps);
        // void glGetSamplerParameterIiv(GLuint sampler, GLenum pname, GLint * ps);
        // void glGetSamplerParameterfv(GLuint sampler, GLenum pname, GLfloat * ps);
        // void glGetSamplerParameterIuiv(GLuint sampler, GLenum pname, GLuint * ps);

        #endregion GL_ARB_sampler_objects

        #region GL_ARB_separate_shader_objects

        // void glUseProgramStages(GLuint pipeline, GLbitfield stages, GLuint program);
        // void glActiveShaderProgram(GLuint pipeline, GLuint program);
        // GLuint glCreateShaderProgramv(GLenum type, GLsizei count, const char ** strings);
        // void glBindProgramPipeline(GLuint pipeline);
        // void glDeleteProgramPipelines(GLsizei n, const GLuint * pipelines);
        // void glGenProgramPipelines(GLsizei n, GLuint * pipelines);
        // GLboolean glIsProgramPipeline(GLuint pipeline);
        // void glGetProgramPipelineiv(GLuint pipeline, GLenum pname, GLint * ps);
        // void glProgramParameteri(GLuint program, GLenum pname, GLint value);
        // void glProgramUniform1i(GLuint program, GLint location, GLint v0);
        // void glProgramUniform1iv(GLuint program, GLint location, GLsizei count, const GLint * value);
        // void glProgramUniform1f(GLuint program, GLint location, GLfloat v0);
        // void glProgramUniform1fv(GLuint program, GLint location, GLsizei count, const GLfloat * value);
        // void glProgramUniform1d(GLuint program, GLint location, GLdouble v0);
        // void glProgramUniform1dv(GLuint program, GLint location, GLsizei count, const GLdouble * value);
        // void glProgramUniform1ui(GLuint program, GLint location, GLuint v0);
        // void glProgramUniform1uiv(GLuint program, GLint location, GLsizei count, const GLuint * value);
        // void glProgramUniform2i(GLuint program, GLint location, GLint v0, GLint v1);
        // void glProgramUniform2iv(GLuint program, GLint location, GLsizei count, const GLint * value);
        // void glProgramUniform2f(GLuint program, GLint location, GLfloat v0, GLfloat v1);
        // void glProgramUniform2fv(GLuint program, GLint location, GLsizei count, const GLfloat * value);
        // void glProgramUniform2d(GLuint program, GLint location, GLdouble v0, GLdouble v1);
        // void glProgramUniform2dv(GLuint program, GLint location, GLsizei count, const GLdouble * value);
        // void glProgramUniform2ui(GLuint program, GLint location, GLuint v0, GLuint v1);
        // void glProgramUniform2uiv(GLuint program, GLint location, GLsizei count, const GLuint * value);
        // void glProgramUniform3i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2);
        // void glProgramUniform3iv(GLuint program, GLint location, GLsizei count, const GLint * value);
        // void glProgramUniform3f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2);
        // void glProgramUniform3fv(GLuint program, GLint location, GLsizei count, const GLfloat * value);
        // void glProgramUniform3d(GLuint program, GLint location, GLdouble v0, GLdouble v1, GLdouble v2);
        // void glProgramUniform3dv(GLuint program, GLint location, GLsizei count, const GLdouble * value);
        // void glProgramUniform3ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2);
        // void glProgramUniform3uiv(GLuint program, GLint location, GLsizei count, const GLuint * value);
        // void glProgramUniform4i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3);
        // void glProgramUniform4iv(GLuint program, GLint location, GLsizei count, const GLint * value);
        // void glProgramUniform4f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3);
        // void glProgramUniform4fv(GLuint program, GLint location, GLsizei count, const GLfloat * value);
        // void glProgramUniform4d(GLuint program, GLint location, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3);
        // void glProgramUniform4dv(GLuint program, GLint location, GLsizei count, const GLdouble * value);
        // void glProgramUniform4ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3);
        // void glProgramUniform4uiv(GLuint program, GLint location, GLsizei count, const GLuint * value);
        // void glProgramUniformMatrix2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);
        // void glProgramUniformMatrix3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);
        // void glProgramUniformMatrix4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);
        // void glProgramUniformMatrix2dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);
        // void glProgramUniformMatrix3dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);
        // void glProgramUniformMatrix4dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);
        // void glProgramUniformMatrix2x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);
        // void glProgramUniformMatrix3x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);
        // void glProgramUniformMatrix2x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);
        // void glProgramUniformMatrix4x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);
        // void glProgramUniformMatrix3x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);
        // void glProgramUniformMatrix4x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);
        // void glProgramUniformMatrix2x3dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);
        // void glProgramUniformMatrix3x2dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);
        // void glProgramUniformMatrix2x4dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);
        // void glProgramUniformMatrix4x2dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);
        // void glProgramUniformMatrix3x4dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);
        // void glProgramUniformMatrix4x3dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);
        // void glValidateProgramPipeline(GLuint pipeline);
        // void glGetProgramPipelineInfoLog(GLuint pipeline, GLsizei bufSize, GLsizei * length, GLchar * infoLog);

        #endregion GL_ARB_separate_shader_objects

        #region GL_ARB_shader_atomic_counters

        // void glGetActiveAtomicCounterBufferiv(GLuint program, GLuint bufferIndex, GLenum pname, GLint * ps);

        #endregion GL_ARB_shader_atomic_counters

        #region GL_ARB_shader_image_load_store

        // void glBindImageTexture(GLuint unit, GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum access, GLenum format);
        // void glMemoryBarrier(GLbitfield barriers);

        #endregion GL_ARB_shader_image_load_store

        #region GL_ARB_shader_objects

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_shader_objects</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glDeleteObjectARB(GLhandleARB obj);</para>
        /// </summary>
        public static void glDeleteObjectARB(uint obj) {
            var _F = _GetProc<GLNativeDelegate.FNglDeleteObjectARB>("glDeleteObjectARB");
            _F(obj);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_shader_objects</para>
        /// Supported: <para>gl</para>
        /// Original: <para>GLhandleARB glGetHandleARB(GLenum pname);</para>
        /// </summary>
        public static uint glGetHandleARB(uint pname) {
            var _F = _GetProc<GLNativeDelegate.FNglGetHandleARB>("glGetHandleARB");
            return _F(pname);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_shader_objects</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glDetachObjectARB(GLhandleARB containerObj, GLhandleARB attachedObj);</para>
        /// </summary>
        public static void glDetachObjectARB(uint containerObj, uint attachedObj) {
            var _F = _GetProc<GLNativeDelegate.FNglDetachObjectARB>("glDetachObjectARB");
            _F(containerObj, attachedObj);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_shader_objects</para>
        /// Supported: <para>gl</para>
        /// Original: <para>GLhandleARB glCreateShaderObjectARB(GLenum shaderType);</para>
        /// </summary>
        public static uint glCreateShaderObjectARB(uint shaderType) {
            var _F = _GetProc<GLNativeDelegate.FNglCreateShaderObjectARB>("glCreateShaderObjectARB");
            return _F(shaderType);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_shader_objects</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glShaderSourceARB(GLhandleARB shaderObj, GLsizei count, const GLcharARB ** string, const GLint * length);</para>
        /// </summary>
        public unsafe static void glShaderSourceARB(uint shaderObj, int count, uint** str, int* length) {
            var _F = _GetProc<GLNativeDelegate.FNglShaderSourceARB>("glShaderSourceARB");
            _F(shaderObj, count, str, length);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_shader_objects</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glCompileShaderARB(GLhandleARB shaderObj);</para>
        /// </summary>
        public static void glCompileShaderARB(uint shaderObj) {
            var _F = _GetProc<GLNativeDelegate.FNglCompileShaderARB>("glCompileShaderARB");
            _F(shaderObj);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_shader_objects</para>
        /// Supported: <para>gl</para>
        /// Original: <para>GLhandleARB glCreateProgramObjectARB();</para>
        /// </summary>
        public static uint glCreateProgramObjectARB() {
            var _F = _GetProc<GLNativeDelegate.FNglCreateProgramObjectARB>("glCreateProgramObjectARB");
            return _F();
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_shader_objects</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glAttachObjectARB(GLhandleARB containerObj, GLhandleARB obj);</para>
        /// </summary>
        public static void glAttachObjectARB(uint containerObj, uint obj) {
            var _F = _GetProc<GLNativeDelegate.FNglAttachObjectARB>("glAttachObjectARB");
            _F(containerObj, obj);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_shader_objects</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glLinkProgramARB(GLhandleARB programObj);</para>
        /// </summary>
        public static void glLinkProgramARB(uint programObj) {
            var _F = _GetProc<GLNativeDelegate.FNglLinkProgramARB>("glLinkProgramARB");
            _F(programObj);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_shader_objects</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glUseProgramObjectARB(GLhandleARB programObj);</para>
        /// </summary>
        public static void glUseProgramObjectARB(uint programObj) {
            var _F = _GetProc<GLNativeDelegate.FNglUseProgramObjectARB>("glUseProgramObjectARB");
            _F(programObj);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_shader_objects</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glValidateProgramARB(GLhandleARB programObj);</para>
        /// </summary>
        public static void glValidateProgramARB(uint programObj) {
            var _F = _GetProc<GLNativeDelegate.FNglValidateProgramARB>("glValidateProgramARB");
            _F(programObj);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_shader_objects</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glUniform1fARB(GLint location, GLfloat v0);</para>
        /// </summary>
        public static void glUniform1fARB(int location, float v0) {
            var _F = _GetProc<GLNativeDelegate.FNglUniform1fARB>("glUniform1fARB");
            _F(location, v0);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_shader_objects</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glUniform2fARB(GLint location, GLfloat v0, GLfloat v1);</para>
        /// </summary>
        public static void glUniform2fARB(int location, float v0, float v1) {
            var _F = _GetProc<GLNativeDelegate.FNglUniform2fARB>("glUniform2fARB");
            _F(location, v0, v1);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_shader_objects</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glUniform3fARB(GLint location, GLfloat v0, GLfloat v1, GLfloat v2);</para>
        /// </summary>
        public static void glUniform3fARB(int location, float v0, float v1, float v2) {
            var _F = _GetProc<GLNativeDelegate.FNglUniform3fARB>("glUniform3fARB");
            _F(location, v0, v1, v2);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_shader_objects</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glUniform4fARB(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3);</para>
        /// </summary>
        public static void glUniform4fARB(int location, float v0, float v1, float v2, float v3) {
            var _F = _GetProc<GLNativeDelegate.FNglUniform4fARB>("glUniform4fARB");
            _F(location, v0, v1, v2, v3);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_shader_objects</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glUniform1iARB(GLint location, GLint v0);</para>
        /// </summary>
        public static void glUniform1iARB(int location, int v0) {
            var _F = _GetProc<GLNativeDelegate.FNglUniform1iARB>("glUniform1iARB");
            _F(location, v0);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_shader_objects</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glUniform2iARB(GLint location, GLint v0, GLint v1);</para>
        /// </summary>
        public static void glUniform2iARB(int location, int v0, int v1) {
            var _F = _GetProc<GLNativeDelegate.FNglUniform2iARB>("glUniform2iARB");
            _F(location, v0, v1);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_shader_objects</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glUniform3iARB(GLint location, GLint v0, GLint v1, GLint v2);</para>
        /// </summary>
        public static void glUniform3iARB(int location, int v0, int v1, int v2) {
            var _F = _GetProc<GLNativeDelegate.FNglUniform3iARB>("glUniform3iARB");
            _F(location, v0, v1, v2);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_shader_objects</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glUniform4iARB(GLint location, GLint v0, GLint v1, GLint v2, GLint v3);</para>
        /// </summary>
        public static void glUniform4iARB(int location, int v0, int v1, int v2, int v3) {
            var _F = _GetProc<GLNativeDelegate.FNglUniform4iARB>("glUniform4iARB");
            _F(location, v0, v1, v2, v3);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_shader_objects</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glUniform1fvARB(GLint location, GLsizei count, const GLfloat * value);</para>
        /// </summary>
        public unsafe static void glUniform1fvARB(int location, int count, float* value) {
            var _F = _GetProc<GLNativeDelegate.FNglUniform1fvARB>("glUniform1fvARB");
            _F(location, count, value);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_shader_objects</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glUniform2fvARB(GLint location, GLsizei count, const GLfloat * value);</para>
        /// </summary>
        public unsafe static void glUniform2fvARB(int location, int count, float* value) {
            var _F = _GetProc<GLNativeDelegate.FNglUniform2fvARB>("glUniform2fvARB");
            _F(location, count, value);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_shader_objects</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glUniform3fvARB(GLint location, GLsizei count, const GLfloat * value);</para>
        /// </summary>
        public unsafe static void glUniform3fvARB(int location, int count, float* value) {
            var _F = _GetProc<GLNativeDelegate.FNglUniform3fvARB>("glUniform3fvARB");
            _F(location, count, value);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_shader_objects</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glUniform4fvARB(GLint location, GLsizei count, const GLfloat * value);</para>
        /// </summary>
        public unsafe static void glUniform4fvARB(int location, int count, float* value) {
            var _F = _GetProc<GLNativeDelegate.FNglUniform4fvARB>("glUniform4fvARB");
            _F(location, count, value);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_shader_objects</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glUniform1ivARB(GLint location, GLsizei count, const GLint * value);</para>
        /// </summary>
        public unsafe static void glUniform1ivARB(int location, int count, int* value) {
            var _F = _GetProc<GLNativeDelegate.FNglUniform1ivARB>("glUniform1ivARB");
            _F(location, count, value);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_shader_objects</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glUniform2ivARB(GLint location, GLsizei count, const GLint * value);</para>
        /// </summary>
        public unsafe static void glUniform2ivARB(int location, int count, int* value) {
            var _F = _GetProc<GLNativeDelegate.FNglUniform2ivARB>("glUniform2ivARB");
            _F(location, count, value);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_shader_objects</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glUniform3ivARB(GLint location, GLsizei count, const GLint * value);</para>
        /// </summary>
        public unsafe static void glUniform3ivARB(int location, int count, int* value) {
            var _F = _GetProc<GLNativeDelegate.FNglUniform3ivARB>("glUniform3ivARB");
            _F(location, count, value);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_shader_objects</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glUniform4ivARB(GLint location, GLsizei count, const GLint * value);</para>
        /// </summary>
        public unsafe static void glUniform4ivARB(int location, int count, int* value) {
            var _F = _GetProc<GLNativeDelegate.FNglUniform4ivARB>("glUniform4ivARB");
            _F(location, count, value);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_shader_objects</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glUniformMatrix2fvARB(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);</para>
        /// </summary>
        public unsafe static void glUniformMatrix2fvARB(int location, int count, bool transpose, float* value) {
            var _F = _GetProc<GLNativeDelegate.FNglUniformMatrix2fvARB>("glUniformMatrix2fvARB");
            _F(location, count, transpose, value);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_shader_objects</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glUniformMatrix3fvARB(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);</para>
        /// </summary>
        public unsafe static void glUniformMatrix3fvARB(int location, int count, bool transpose, float* value) {
            var _F = _GetProc<GLNativeDelegate.FNglUniformMatrix3fvARB>("glUniformMatrix3fvARB");
            _F(location, count, transpose, value);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_shader_objects</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glUniformMatrix4fvARB(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);</para>
        /// </summary>
        public unsafe static void glUniformMatrix4fvARB(int location, int count, bool transpose, float* value) {
            var _F = _GetProc<GLNativeDelegate.FNglUniformMatrix4fvARB>("glUniformMatrix4fvARB");
            _F(location, count, transpose, value);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_shader_objects</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetObjectParameterfvARB(GLhandleARB obj, GLenum pname, GLfloat * params);</para>
        /// </summary>
        public unsafe static void glGetObjectParameterfvARB(uint obj, uint pname, float* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetObjectParameterfvARB>("glGetObjectParameterfvARB");
            _F(obj, pname, ps);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_shader_objects</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetObjectParameterivARB(GLhandleARB obj, GLenum pname, GLint * params);</para>
        /// </summary>
        public unsafe static void glGetObjectParameterivARB(uint obj, uint pname, int* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetObjectParameterivARB>("glGetObjectParameterivARB");
            _F(obj, pname, ps);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_shader_objects</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetInfoLogARB(GLhandleARB obj, GLsizei maxLength, GLsizei * length, GLcharARB * infoLog);</para>
        /// </summary>
        public unsafe static void glGetInfoLogARB(uint obj, int maxLength, int* length, uint* infoLog) {
            var _F = _GetProc<GLNativeDelegate.FNglGetInfoLogARB>("glGetInfoLogARB");
            _F(obj, maxLength, length, infoLog);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_shader_objects</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetAttachedObjectsARB(GLhandleARB containerObj, GLsizei maxCount, GLsizei * count, GLhandleARB * obj);</para>
        /// </summary>
        public unsafe static void glGetAttachedObjectsARB(uint containerObj, int maxCount, int* count, uint* obj) {
            var _F = _GetProc<GLNativeDelegate.FNglGetAttachedObjectsARB>("glGetAttachedObjectsARB");
            _F(containerObj, maxCount, count, obj);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_shader_objects</para>
        /// Supported: <para>gl</para>
        /// Original: <para>GLint glGetUniformLocationARB(GLhandleARB programObj, const GLcharARB * name);</para>
        /// </summary>
        public unsafe static int glGetUniformLocationARB(uint programObj, uint* name) {
            var _F = _GetProc<GLNativeDelegate.FNglGetUniformLocationARB>("glGetUniformLocationARB");
            return _F(programObj, name);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_shader_objects</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetActiveUniformARB(GLhandleARB programObj, GLuint index, GLsizei maxLength, GLsizei * length, GLint * size, GLenum * type, GLcharARB * name);</para>
        /// </summary>
        public unsafe static void glGetActiveUniformARB(uint programObj, uint index, int maxLength, int* length, int* size, uint* type, uint* name) {
            var _F = _GetProc<GLNativeDelegate.FNglGetActiveUniformARB>("glGetActiveUniformARB");
            _F(programObj, index, maxLength, length, size, type, name);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_shader_objects</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetUniformfvARB(GLhandleARB programObj, GLint location, GLfloat * params);</para>
        /// </summary>
        public unsafe static void glGetUniformfvARB(uint programObj, int location, float* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetUniformfvARB>("glGetUniformfvARB");
            _F(programObj, location, ps);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_shader_objects</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetUniformivARB(GLhandleARB programObj, GLint location, GLint * params);</para>
        /// </summary>
        public unsafe static void glGetUniformivARB(uint programObj, int location, int* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetUniformivARB>("glGetUniformivARB");
            _F(programObj, location, ps);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_shader_objects</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetShaderSourceARB(GLhandleARB obj, GLsizei maxLength, GLsizei * length, GLcharARB * source);</para>
        /// </summary>
        public unsafe static void glGetShaderSourceARB(uint obj, int maxLength, int* length, uint* source) {
            var _F = _GetProc<GLNativeDelegate.FNglGetShaderSourceARB>("glGetShaderSourceARB");
            _F(obj, maxLength, length, source);
        }

        #endregion GL_ARB_shader_objects

        #region GL_ARB_shader_storage_buffer_object

        // void glShaderStorageBlockBinding(GLuint program, GLuint storageBlockIndex, GLuint storageBlockBinding);

        #endregion GL_ARB_shader_storage_buffer_object

        #region GL_ARB_shader_subroutine

        // GLint glGetSubroutineUniformLocation(GLuint program, GLenum shadertype, const GLchar * name);
        // GLuint glGetSubroutineIndex(GLuint program, GLenum shadertype, const GLchar * name);
        // void glGetActiveSubroutineUniformiv(GLuint program, GLenum shadertype, GLuint index, GLenum pname, GLint * values);
        // void glGetActiveSubroutineUniformName(GLuint program, GLenum shadertype, GLuint index, GLsizei bufSize, GLsizei * length, GLchar * name);
        // void glGetActiveSubroutineName(GLuint program, GLenum shadertype, GLuint index, GLsizei bufSize, GLsizei * length, GLchar * name);
        // void glUniformSubroutinesuiv(GLenum shadertype, GLsizei count, const GLuint * indices);
        // void glGetUniformSubroutineuiv(GLenum shadertype, GLint location, GLuint * values);
        // void glGetProgramStageiv(GLuint program, GLenum shadertype, GLenum pname, GLint * values);

        #endregion GL_ARB_shader_subroutine

        #region GL_ARB_shading_language_include

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_shading_language_include</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glNamedStringARB(GLenum type, GLint namelen, const GLchar * name, GLint stringlen, const GLchar * string);</para>
        /// </summary>
        public unsafe static void glNamedStringARB(uint type, int namelen, byte* name, int stringlen, byte* str) {
            var _F = _GetProc<GLNativeDelegate.FNglNamedStringARB>("glNamedStringARB");
            _F(type, namelen, name, stringlen, str);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_shading_language_include</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glDeleteNamedStringARB(GLint namelen, const GLchar * name);</para>
        /// </summary>
        public unsafe static void glDeleteNamedStringARB(int namelen, byte* name) {
            var _F = _GetProc<GLNativeDelegate.FNglDeleteNamedStringARB>("glDeleteNamedStringARB");
            _F(namelen, name);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_shading_language_include</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glCompileShaderIncludeARB(GLuint shader, GLsizei count, const GLchar *const* path, const GLint * length);</para>
        /// </summary>
        public unsafe static void glCompileShaderIncludeARB(uint shader, int count, byte** path, int* length) {
            var _F = _GetProc<GLNativeDelegate.FNglCompileShaderIncludeARB>("glCompileShaderIncludeARB");
            _F(shader, count, path, length);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_shading_language_include</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>GLboolean glIsNamedStringARB(GLint namelen, const GLchar * name);</para>
        /// </summary>
        public unsafe static bool glIsNamedStringARB(int namelen, byte* name) {
            var _F = _GetProc<GLNativeDelegate.FNglIsNamedStringARB>("glIsNamedStringARB");
            return _F(namelen, name);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_shading_language_include</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetNamedStringARB(GLint namelen, const GLchar * name, GLsizei bufSize, GLint * stringlen, GLchar * string);</para>
        /// </summary>
        public unsafe static void glGetNamedStringARB(int namelen, byte* name, int bufSize, int* stringlen, byte* str) {
            var _F = _GetProc<GLNativeDelegate.FNglGetNamedStringARB>("glGetNamedStringARB");
            _F(namelen, name, bufSize, stringlen, str);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_shading_language_include</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetNamedStringivARB(GLint namelen, const GLchar * name, GLenum pname, GLint * params);</para>
        /// </summary>
        public unsafe static void glGetNamedStringivARB(int namelen, byte* name, uint pname, int* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetNamedStringivARB>("glGetNamedStringivARB");
            _F(namelen, name, pname, ps);
        }

        #endregion GL_ARB_shading_language_include

        #region GL_ARB_sparse_buffer

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_sparse_buffer</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glBufferPageCommitmentARB(GLenum target, GLintptr offset, GLsizeiptr size, GLboolean commit);</para>
        /// </summary>
        public static void glBufferPageCommitmentARB(uint target, IntPtr offset, IntPtr size, bool commit) {
            var _F = _GetProc<GLNativeDelegate.FNglBufferPageCommitmentARB>("glBufferPageCommitmentARB");
            _F(target, offset, size, commit);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_sparse_buffer</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glNamedBufferPageCommitmentEXT(GLuint buffer, GLintptr offset, GLsizeiptr size, GLboolean commit);</para>
        /// </summary>
        public static void glNamedBufferPageCommitmentEXT(uint buffer, IntPtr offset, IntPtr size, bool commit) {
            var _F = _GetProc<GLNativeDelegate.FNglNamedBufferPageCommitmentEXT>("glNamedBufferPageCommitmentEXT");
            _F(buffer, offset, size, commit);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_sparse_buffer</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glNamedBufferPageCommitmentARB(GLuint buffer, GLintptr offset, GLsizeiptr size, GLboolean commit);</para>
        /// </summary>
        public static void glNamedBufferPageCommitmentARB(uint buffer, IntPtr offset, IntPtr size, bool commit) {
            var _F = _GetProc<GLNativeDelegate.FNglNamedBufferPageCommitmentARB>("glNamedBufferPageCommitmentARB");
            _F(buffer, offset, size, commit);
        }

        #endregion GL_ARB_sparse_buffer

        #region GL_ARB_sparse_texture

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_sparse_texture</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glTexPageCommitmentARB(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLboolean commit);</para>
        /// </summary>
        public static void glTexPageCommitmentARB(uint target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, bool commit) {
            var _F = _GetProc<GLNativeDelegate.FNglTexPageCommitmentARB>("glTexPageCommitmentARB");
            _F(target, level, xoffset, yoffset, zoffset, width, height, depth, commit);
        }

        #endregion GL_ARB_sparse_texture

        #region GL_ARB_sync

        // GLsync glFenceSync(GLenum condition, GLbitfield flags);
        // GLboolean glIsSync(GLsync sync);
        // void glDeleteSync(GLsync sync);
        // GLenum glClientWaitSync(GLsync sync, GLbitfield flags, GLuint64 timeout);
        // void glWaitSync(GLsync sync, GLbitfield flags, GLuint64 timeout);
        // void glGetInteger64v(GLenum pname, GLint64 * data);
        // void glGetSynciv(GLsync sync, GLenum pname, GLsizei bufSize, GLsizei * length, GLint * values);

        #endregion GL_ARB_sync

        #region GL_ARB_tessellation_shader

        // void glPatchParameteri(GLenum pname, GLint value);
        // void glPatchParameterfv(GLenum pname, const GLfloat * values);

        #endregion GL_ARB_tessellation_shader

        #region GL_ARB_texture_barrier

        // void glTextureBarrier();

        #endregion GL_ARB_texture_barrier

        #region GL_ARB_texture_buffer_object

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_texture_buffer_object</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glTexBufferARB(GLenum target, GLenum internalformat, GLuint buffer);</para>
        /// </summary>
        public static void glTexBufferARB(uint target, uint internalformat, uint buffer) {
            var _F = _GetProc<GLNativeDelegate.FNglTexBufferARB>("glTexBufferARB");
            _F(target, internalformat, buffer);
        }

        #endregion GL_ARB_texture_buffer_object

        #region GL_ARB_texture_buffer_range

        // void glTexBufferRange(GLenum target, GLenum internalformat, GLuint buffer, GLintptr offset, GLsizeiptr size);

        #endregion GL_ARB_texture_buffer_range

        #region GL_ARB_texture_compression

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_texture_compression</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glCompressedTexImage3DARB(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const void * data);</para>
        /// </summary>
        public unsafe static void glCompressedTexImage3DARB(uint target, int level, uint internalformat, int width, int height, int depth, int border, int imageSize, void* data) {
            var _F = _GetProc<GLNativeDelegate.FNglCompressedTexImage3DARB>("glCompressedTexImage3DARB");
            _F(target, level, internalformat, width, height, depth, border, imageSize, data);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_texture_compression</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glCompressedTexImage2DARB(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const void * data);</para>
        /// </summary>
        public unsafe static void glCompressedTexImage2DARB(uint target, int level, uint internalformat, int width, int height, int border, int imageSize, void* data) {
            var _F = _GetProc<GLNativeDelegate.FNglCompressedTexImage2DARB>("glCompressedTexImage2DARB");
            _F(target, level, internalformat, width, height, border, imageSize, data);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_texture_compression</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glCompressedTexImage1DARB(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const void * data);</para>
        /// </summary>
        public unsafe static void glCompressedTexImage1DARB(uint target, int level, uint internalformat, int width, int border, int imageSize, void* data) {
            var _F = _GetProc<GLNativeDelegate.FNglCompressedTexImage1DARB>("glCompressedTexImage1DARB");
            _F(target, level, internalformat, width, border, imageSize, data);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_texture_compression</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glCompressedTexSubImage3DARB(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void * data);</para>
        /// </summary>
        public unsafe static void glCompressedTexSubImage3DARB(uint target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, uint format, int imageSize, void* data) {
            var _F = _GetProc<GLNativeDelegate.FNglCompressedTexSubImage3DARB>("glCompressedTexSubImage3DARB");
            _F(target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_texture_compression</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glCompressedTexSubImage2DARB(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void * data);</para>
        /// </summary>
        public unsafe static void glCompressedTexSubImage2DARB(uint target, int level, int xoffset, int yoffset, int width, int height, uint format, int imageSize, void* data) {
            var _F = _GetProc<GLNativeDelegate.FNglCompressedTexSubImage2DARB>("glCompressedTexSubImage2DARB");
            _F(target, level, xoffset, yoffset, width, height, format, imageSize, data);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_texture_compression</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glCompressedTexSubImage1DARB(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const void * data);</para>
        /// </summary>
        public unsafe static void glCompressedTexSubImage1DARB(uint target, int level, int xoffset, int width, uint format, int imageSize, void* data) {
            var _F = _GetProc<GLNativeDelegate.FNglCompressedTexSubImage1DARB>("glCompressedTexSubImage1DARB");
            _F(target, level, xoffset, width, format, imageSize, data);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_texture_compression</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetCompressedTexImageARB(GLenum target, GLint level, void * img);</para>
        /// </summary>
        public unsafe static void glGetCompressedTexImageARB(uint target, int level, void* img) {
            var _F = _GetProc<GLNativeDelegate.FNglGetCompressedTexImageARB>("glGetCompressedTexImageARB");
            _F(target, level, img);
        }

        #endregion GL_ARB_texture_compression

        #region GL_ARB_texture_multisample

        // void glTexImage2DMultisample(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations);
        // void glTexImage3DMultisample(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations);
        // void glGetMultisamplefv(GLenum pname, GLuint index, GLfloat * val);
        // void glSampleMaski(GLuint maskNumber, GLbitfield mask);

        #endregion GL_ARB_texture_multisample

        #region GL_ARB_texture_storage

        // void glTexStorage1D(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width);
        // void glTexStorage2D(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height);
        // void glTexStorage3D(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth);

        #endregion GL_ARB_texture_storage

        #region GL_ARB_texture_storage_multisample

        // void glTexStorage2DMultisample(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations);
        // void glTexStorage3DMultisample(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations);

        #endregion GL_ARB_texture_storage_multisample

        #region GL_ARB_texture_view

        // void glTextureView(GLuint texture, GLenum target, GLuint origtexture, GLenum internalformat, GLuint minlevel, GLuint numlevels, GLuint minlayer, GLuint numlayers);

        #endregion GL_ARB_texture_view

        #region GL_ARB_timer_query

        // void glQueryCounter(GLuint id, GLenum target);
        // void glGetQueryObjecti64v(GLuint id, GLenum pname, GLint64 * ps);
        // void glGetQueryObjectui64v(GLuint id, GLenum pname, GLuint64 * ps);

        #endregion GL_ARB_timer_query

        #region GL_ARB_transform_feedback2

        // void glBindTransformFeedback(GLenum target, GLuint id);
        // void glDeleteTransformFeedbacks(GLsizei n, const GLuint * ids);
        // void glGenTransformFeedbacks(GLsizei n, GLuint * ids);
        // GLboolean glIsTransformFeedback(GLuint id);
        // void glPauseTransformFeedback();
        // void glResumeTransformFeedback();
        // void glDrawTransformFeedback(GLenum mode, GLuint id);

        #endregion GL_ARB_transform_feedback2

        #region GL_ARB_transform_feedback3

        // void glDrawTransformFeedbackStream(GLenum mode, GLuint id, GLuint stream);
        // void glBeginQueryIndexed(GLenum target, GLuint index, GLuint id);
        // void glEndQueryIndexed(GLenum target, GLuint index);
        // void glGetQueryIndexediv(GLenum target, GLuint index, GLenum pname, GLint * ps);

        #endregion GL_ARB_transform_feedback3

        #region GL_ARB_transform_feedback_instanced

        // void glDrawTransformFeedbackInstanced(GLenum mode, GLuint id, GLsizei instancecount);
        // void glDrawTransformFeedbackStreamInstanced(GLenum mode, GLuint id, GLuint stream, GLsizei instancecount);

        #endregion GL_ARB_transform_feedback_instanced

        #region GL_ARB_transpose_matrix

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_transpose_matrix</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glLoadTransposeMatrixfARB(const GLfloat * m);</para>
        /// </summary>
        public unsafe static void glLoadTransposeMatrixfARB(float* m) {
            var _F = _GetProc<GLNativeDelegate.FNglLoadTransposeMatrixfARB>("glLoadTransposeMatrixfARB");
            _F(m);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_transpose_matrix</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glLoadTransposeMatrixdARB(const GLdouble * m);</para>
        /// </summary>
        public unsafe static void glLoadTransposeMatrixdARB(double* m) {
            var _F = _GetProc<GLNativeDelegate.FNglLoadTransposeMatrixdARB>("glLoadTransposeMatrixdARB");
            _F(m);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_transpose_matrix</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glMultTransposeMatrixfARB(const GLfloat * m);</para>
        /// </summary>
        public unsafe static void glMultTransposeMatrixfARB(float* m) {
            var _F = _GetProc<GLNativeDelegate.FNglMultTransposeMatrixfARB>("glMultTransposeMatrixfARB");
            _F(m);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_transpose_matrix</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glMultTransposeMatrixdARB(const GLdouble * m);</para>
        /// </summary>
        public unsafe static void glMultTransposeMatrixdARB(double* m) {
            var _F = _GetProc<GLNativeDelegate.FNglMultTransposeMatrixdARB>("glMultTransposeMatrixdARB");
            _F(m);
        }

        #endregion GL_ARB_transpose_matrix

        #region GL_ARB_uniform_buffer_object

        // void glGetUniformIndices(GLuint program, GLsizei uniformCount, const GLchar ** uniformNames, GLuint * uniformIndices);
        // void glGetActiveUniformsiv(GLuint program, GLsizei uniformCount, const GLuint * uniformIndices, GLenum pname, GLint * ps);
        // void glGetActiveUniformName(GLuint program, GLuint uniformIndex, GLsizei bufSize, GLsizei * length, GLchar * uniformName);
        // GLuint glGetUniformBlockIndex(GLuint program, const GLchar * uniformBlockName);
        // void glGetActiveUniformBlockiv(GLuint program, GLuint uniformBlockIndex, GLenum pname, GLint * ps);
        // void glGetActiveUniformBlockName(GLuint program, GLuint uniformBlockIndex, GLsizei bufSize, GLsizei * length, GLchar * uniformBlockName);
        // void glUniformBlockBinding(GLuint program, GLuint uniformBlockIndex, GLuint uniformBlockBinding);
        // void glBindBufferRange(GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size);
        // void glBindBufferBase(GLenum target, GLuint index, GLuint buffer);
        // void glGetIntegeri_v(GLenum target, GLuint index, GLint * data);

        #endregion GL_ARB_uniform_buffer_object

        #region GL_ARB_vertex_array_object

        // void glBindVertexArray(GLuint array);
        // void glDeleteVertexArrays(GLsizei n, const GLuint * arrays);
        // void glGenVertexArrays(GLsizei n, GLuint * arrays);
        // GLboolean glIsVertexArray(GLuint array);

        #endregion GL_ARB_vertex_array_object

        #region GL_ARB_vertex_attrib_64bit

        // void glVertexAttribL1d(GLuint index, GLdouble v0);
        // void glVertexAttribL2d(GLuint index, GLdouble v0, GLdouble v1);
        // void glVertexAttribL3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2);
        // void glVertexAttribL4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3);
        // void glVertexAttribL1dv(GLuint index, const GLdouble * v);
        // void glVertexAttribL2dv(GLuint index, const GLdouble * v);
        // void glVertexAttribL3dv(GLuint index, const GLdouble * v);
        // void glVertexAttribL4dv(GLuint index, const GLdouble * v);
        // void glVertexAttribLPointer(GLuint index, GLint size, GLenum type, GLsizei stride, const void * pointer);
        // void glGetVertexAttribLdv(GLuint index, GLenum pname, GLdouble * ps);

        #endregion GL_ARB_vertex_attrib_64bit

        #region GL_ARB_vertex_attrib_binding

        // void glBindVertexBuffer(GLuint bindingindex, GLuint buffer, GLintptr offset, GLsizei stride);
        // void glVertexAttribFormat(GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset);
        // void glVertexAttribIFormat(GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset);
        // void glVertexAttribLFormat(GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset);
        // void glVertexAttribBinding(GLuint attribindex, GLuint bindingindex);
        // void glVertexBindingDivisor(GLuint bindingindex, GLuint divisor);

        #endregion GL_ARB_vertex_attrib_binding

        #region GL_ARB_vertex_blend

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_vertex_blend</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glWeightbvARB(GLint size, const GLbyte * weights);</para>
        /// </summary>
        public unsafe static void glWeightbvARB(int size, byte* weights) {
            var _F = _GetProc<GLNativeDelegate.FNglWeightbvARB>("glWeightbvARB");
            _F(size, weights);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_vertex_blend</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glWeightsvARB(GLint size, const GLshort * weights);</para>
        /// </summary>
        public unsafe static void glWeightsvARB(int size, short* weights) {
            var _F = _GetProc<GLNativeDelegate.FNglWeightsvARB>("glWeightsvARB");
            _F(size, weights);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_vertex_blend</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glWeightivARB(GLint size, const GLint * weights);</para>
        /// </summary>
        public unsafe static void glWeightivARB(int size, int* weights) {
            var _F = _GetProc<GLNativeDelegate.FNglWeightivARB>("glWeightivARB");
            _F(size, weights);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_vertex_blend</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glWeightfvARB(GLint size, const GLfloat * weights);</para>
        /// </summary>
        public unsafe static void glWeightfvARB(int size, float* weights) {
            var _F = _GetProc<GLNativeDelegate.FNglWeightfvARB>("glWeightfvARB");
            _F(size, weights);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_vertex_blend</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glWeightdvARB(GLint size, const GLdouble * weights);</para>
        /// </summary>
        public unsafe static void glWeightdvARB(int size, double* weights) {
            var _F = _GetProc<GLNativeDelegate.FNglWeightdvARB>("glWeightdvARB");
            _F(size, weights);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_vertex_blend</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glWeightubvARB(GLint size, const GLubyte * weights);</para>
        /// </summary>
        public unsafe static void glWeightubvARB(int size, byte* weights) {
            var _F = _GetProc<GLNativeDelegate.FNglWeightubvARB>("glWeightubvARB");
            _F(size, weights);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_vertex_blend</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glWeightusvARB(GLint size, const GLushort * weights);</para>
        /// </summary>
        public unsafe static void glWeightusvARB(int size, ushort* weights) {
            var _F = _GetProc<GLNativeDelegate.FNglWeightusvARB>("glWeightusvARB");
            _F(size, weights);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_vertex_blend</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glWeightuivARB(GLint size, const GLuint * weights);</para>
        /// </summary>
        public unsafe static void glWeightuivARB(int size, uint* weights) {
            var _F = _GetProc<GLNativeDelegate.FNglWeightuivARB>("glWeightuivARB");
            _F(size, weights);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_vertex_blend</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glWeightPointerARB(GLint size, GLenum type, GLsizei stride, const void * pointer);</para>
        /// </summary>
        public unsafe static void glWeightPointerARB(int size, uint type, int stride, void* pointer) {
            var _F = _GetProc<GLNativeDelegate.FNglWeightPointerARB>("glWeightPointerARB");
            _F(size, type, stride, pointer);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_vertex_blend</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexBlendARB(GLint count);</para>
        /// </summary>
        public static void glVertexBlendARB(int count) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexBlendARB>("glVertexBlendARB");
            _F(count);
        }

        #endregion GL_ARB_vertex_blend

        #region GL_ARB_vertex_buffer_object

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_vertex_buffer_object</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glBindBufferARB(GLenum target, GLuint buffer);</para>
        /// </summary>
        public static void glBindBufferARB(uint target, uint buffer) {
            var _F = _GetProc<GLNativeDelegate.FNglBindBufferARB>("glBindBufferARB");
            _F(target, buffer);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_vertex_buffer_object</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glDeleteBuffersARB(GLsizei n, const GLuint * buffers);</para>
        /// </summary>
        public unsafe static void glDeleteBuffersARB(int n, uint* buffers) {
            var _F = _GetProc<GLNativeDelegate.FNglDeleteBuffersARB>("glDeleteBuffersARB");
            _F(n, buffers);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_vertex_buffer_object</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGenBuffersARB(GLsizei n, GLuint * buffers);</para>
        /// </summary>
        public unsafe static void glGenBuffersARB(int n, uint* buffers) {
            var _F = _GetProc<GLNativeDelegate.FNglGenBuffersARB>("glGenBuffersARB");
            _F(n, buffers);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_vertex_buffer_object</para>
        /// Supported: <para>gl</para>
        /// Original: <para>GLboolean glIsBufferARB(GLuint buffer);</para>
        /// </summary>
        public static bool glIsBufferARB(uint buffer) {
            var _F = _GetProc<GLNativeDelegate.FNglIsBufferARB>("glIsBufferARB");
            return _F(buffer);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_vertex_buffer_object</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glBufferDataARB(GLenum target, GLsizeiptrARB size, const void * data, GLenum usage);</para>
        /// </summary>
        public unsafe static void glBufferDataARB(uint target, IntPtr size, void* data, uint usage) {
            var _F = _GetProc<GLNativeDelegate.FNglBufferDataARB>("glBufferDataARB");
            _F(target, size, data, usage);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_vertex_buffer_object</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glBufferSubDataARB(GLenum target, GLintptrARB offset, GLsizeiptrARB size, const void * data);</para>
        /// </summary>
        public unsafe static void glBufferSubDataARB(uint target, IntPtr offset, IntPtr size, void* data) {
            var _F = _GetProc<GLNativeDelegate.FNglBufferSubDataARB>("glBufferSubDataARB");
            _F(target, offset, size, data);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_vertex_buffer_object</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetBufferSubDataARB(GLenum target, GLintptrARB offset, GLsizeiptrARB size, void * data);</para>
        /// </summary>
        public unsafe static void glGetBufferSubDataARB(uint target, IntPtr offset, IntPtr size, void* data) {
            var _F = _GetProc<GLNativeDelegate.FNglGetBufferSubDataARB>("glGetBufferSubDataARB");
            _F(target, offset, size, data);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_vertex_buffer_object</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void * glMapBufferARB(GLenum target, GLenum access);</para>
        /// </summary>
        public unsafe static void* glMapBufferARB(uint target, uint access) {
            var _F = _GetProc<GLNativeDelegate.FNglMapBufferARB>("glMapBufferARB");
            return _F(target, access);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_vertex_buffer_object</para>
        /// Supported: <para>gl</para>
        /// Original: <para>GLboolean glUnmapBufferARB(GLenum target);</para>
        /// </summary>
        public static bool glUnmapBufferARB(uint target) {
            var _F = _GetProc<GLNativeDelegate.FNglUnmapBufferARB>("glUnmapBufferARB");
            return _F(target);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_vertex_buffer_object</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetBufferParameterivARB(GLenum target, GLenum pname, GLint * params);</para>
        /// </summary>
        public unsafe static void glGetBufferParameterivARB(uint target, uint pname, int* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetBufferParameterivARB>("glGetBufferParameterivARB");
            _F(target, pname, ps);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_vertex_buffer_object</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetBufferPointervARB(GLenum target, GLenum pname, void ** params);</para>
        /// </summary>
        public unsafe static void glGetBufferPointervARB(uint target, uint pname, void** ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetBufferPointervARB>("glGetBufferPointervARB");
            _F(target, pname, ps);
        }

        #endregion GL_ARB_vertex_buffer_object

        #region GL_ARB_vertex_program

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_vertex_program, GL_ARB_vertex_shader</para>
        /// Supported: <para>gl, gl</para>
        /// Original: <para>void glVertexAttrib1dARB(GLuint index, GLdouble x);</para>
        /// </summary>
        public static void glVertexAttrib1dARB(uint index, double x) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttrib1dARB>("glVertexAttrib1dARB");
            _F(index, x);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_vertex_program, GL_ARB_vertex_shader</para>
        /// Supported: <para>gl, gl</para>
        /// Original: <para>void glVertexAttrib1dvARB(GLuint index, const GLdouble * v);</para>
        /// </summary>
        public unsafe static void glVertexAttrib1dvARB(uint index, double* v) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttrib1dvARB>("glVertexAttrib1dvARB");
            _F(index, v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_vertex_program, GL_ARB_vertex_shader</para>
        /// Supported: <para>gl, gl</para>
        /// Original: <para>void glVertexAttrib1fARB(GLuint index, GLfloat x);</para>
        /// </summary>
        public static void glVertexAttrib1fARB(uint index, float x) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttrib1fARB>("glVertexAttrib1fARB");
            _F(index, x);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_vertex_program, GL_ARB_vertex_shader</para>
        /// Supported: <para>gl, gl</para>
        /// Original: <para>void glVertexAttrib1fvARB(GLuint index, const GLfloat * v);</para>
        /// </summary>
        public unsafe static void glVertexAttrib1fvARB(uint index, float* v) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttrib1fvARB>("glVertexAttrib1fvARB");
            _F(index, v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_vertex_program, GL_ARB_vertex_shader</para>
        /// Supported: <para>gl, gl</para>
        /// Original: <para>void glVertexAttrib1sARB(GLuint index, GLshort x);</para>
        /// </summary>
        public static void glVertexAttrib1sARB(uint index, short x) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttrib1sARB>("glVertexAttrib1sARB");
            _F(index, x);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_vertex_program, GL_ARB_vertex_shader</para>
        /// Supported: <para>gl, gl</para>
        /// Original: <para>void glVertexAttrib1svARB(GLuint index, const GLshort * v);</para>
        /// </summary>
        public unsafe static void glVertexAttrib1svARB(uint index, short* v) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttrib1svARB>("glVertexAttrib1svARB");
            _F(index, v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_vertex_program, GL_ARB_vertex_shader</para>
        /// Supported: <para>gl, gl</para>
        /// Original: <para>void glVertexAttrib2dARB(GLuint index, GLdouble x, GLdouble y);</para>
        /// </summary>
        public static void glVertexAttrib2dARB(uint index, double x, double y) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttrib2dARB>("glVertexAttrib2dARB");
            _F(index, x, y);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_vertex_program, GL_ARB_vertex_shader</para>
        /// Supported: <para>gl, gl</para>
        /// Original: <para>void glVertexAttrib2dvARB(GLuint index, const GLdouble * v);</para>
        /// </summary>
        public unsafe static void glVertexAttrib2dvARB(uint index, double* v) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttrib2dvARB>("glVertexAttrib2dvARB");
            _F(index, v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_vertex_program, GL_ARB_vertex_shader</para>
        /// Supported: <para>gl, gl</para>
        /// Original: <para>void glVertexAttrib2fARB(GLuint index, GLfloat x, GLfloat y);</para>
        /// </summary>
        public static void glVertexAttrib2fARB(uint index, float x, float y) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttrib2fARB>("glVertexAttrib2fARB");
            _F(index, x, y);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_vertex_program, GL_ARB_vertex_shader</para>
        /// Supported: <para>gl, gl</para>
        /// Original: <para>void glVertexAttrib2fvARB(GLuint index, const GLfloat * v);</para>
        /// </summary>
        public unsafe static void glVertexAttrib2fvARB(uint index, float* v) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttrib2fvARB>("glVertexAttrib2fvARB");
            _F(index, v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_vertex_program, GL_ARB_vertex_shader</para>
        /// Supported: <para>gl, gl</para>
        /// Original: <para>void glVertexAttrib2sARB(GLuint index, GLshort x, GLshort y);</para>
        /// </summary>
        public static void glVertexAttrib2sARB(uint index, short x, short y) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttrib2sARB>("glVertexAttrib2sARB");
            _F(index, x, y);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_vertex_program, GL_ARB_vertex_shader</para>
        /// Supported: <para>gl, gl</para>
        /// Original: <para>void glVertexAttrib2svARB(GLuint index, const GLshort * v);</para>
        /// </summary>
        public unsafe static void glVertexAttrib2svARB(uint index, short* v) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttrib2svARB>("glVertexAttrib2svARB");
            _F(index, v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_vertex_program, GL_ARB_vertex_shader</para>
        /// Supported: <para>gl, gl</para>
        /// Original: <para>void glVertexAttrib3dARB(GLuint index, GLdouble x, GLdouble y, GLdouble z);</para>
        /// </summary>
        public static void glVertexAttrib3dARB(uint index, double x, double y, double z) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttrib3dARB>("glVertexAttrib3dARB");
            _F(index, x, y, z);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_vertex_program, GL_ARB_vertex_shader</para>
        /// Supported: <para>gl, gl</para>
        /// Original: <para>void glVertexAttrib3dvARB(GLuint index, const GLdouble * v);</para>
        /// </summary>
        public unsafe static void glVertexAttrib3dvARB(uint index, double* v) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttrib3dvARB>("glVertexAttrib3dvARB");
            _F(index, v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_vertex_program, GL_ARB_vertex_shader</para>
        /// Supported: <para>gl, gl</para>
        /// Original: <para>void glVertexAttrib3fARB(GLuint index, GLfloat x, GLfloat y, GLfloat z);</para>
        /// </summary>
        public static void glVertexAttrib3fARB(uint index, float x, float y, float z) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttrib3fARB>("glVertexAttrib3fARB");
            _F(index, x, y, z);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_vertex_program, GL_ARB_vertex_shader</para>
        /// Supported: <para>gl, gl</para>
        /// Original: <para>void glVertexAttrib3fvARB(GLuint index, const GLfloat * v);</para>
        /// </summary>
        public unsafe static void glVertexAttrib3fvARB(uint index, float* v) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttrib3fvARB>("glVertexAttrib3fvARB");
            _F(index, v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_vertex_program, GL_ARB_vertex_shader</para>
        /// Supported: <para>gl, gl</para>
        /// Original: <para>void glVertexAttrib3sARB(GLuint index, GLshort x, GLshort y, GLshort z);</para>
        /// </summary>
        public static void glVertexAttrib3sARB(uint index, short x, short y, short z) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttrib3sARB>("glVertexAttrib3sARB");
            _F(index, x, y, z);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_vertex_program, GL_ARB_vertex_shader</para>
        /// Supported: <para>gl, gl</para>
        /// Original: <para>void glVertexAttrib3svARB(GLuint index, const GLshort * v);</para>
        /// </summary>
        public unsafe static void glVertexAttrib3svARB(uint index, short* v) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttrib3svARB>("glVertexAttrib3svARB");
            _F(index, v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_vertex_program, GL_ARB_vertex_shader</para>
        /// Supported: <para>gl, gl</para>
        /// Original: <para>void glVertexAttrib4NbvARB(GLuint index, const GLbyte * v);</para>
        /// </summary>
        public unsafe static void glVertexAttrib4NbvARB(uint index, byte* v) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttrib4NbvARB>("glVertexAttrib4NbvARB");
            _F(index, v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_vertex_program, GL_ARB_vertex_shader</para>
        /// Supported: <para>gl, gl</para>
        /// Original: <para>void glVertexAttrib4NivARB(GLuint index, const GLint * v);</para>
        /// </summary>
        public unsafe static void glVertexAttrib4NivARB(uint index, int* v) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttrib4NivARB>("glVertexAttrib4NivARB");
            _F(index, v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_vertex_program, GL_ARB_vertex_shader</para>
        /// Supported: <para>gl, gl</para>
        /// Original: <para>void glVertexAttrib4NsvARB(GLuint index, const GLshort * v);</para>
        /// </summary>
        public unsafe static void glVertexAttrib4NsvARB(uint index, short* v) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttrib4NsvARB>("glVertexAttrib4NsvARB");
            _F(index, v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_vertex_program, GL_ARB_vertex_shader</para>
        /// Supported: <para>gl, gl</para>
        /// Original: <para>void glVertexAttrib4NubARB(GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w);</para>
        /// </summary>
        public static void glVertexAttrib4NubARB(uint index, byte x, byte y, byte z, byte w) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttrib4NubARB>("glVertexAttrib4NubARB");
            _F(index, x, y, z, w);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_vertex_program, GL_ARB_vertex_shader</para>
        /// Supported: <para>gl, gl</para>
        /// Original: <para>void glVertexAttrib4NubvARB(GLuint index, const GLubyte * v);</para>
        /// </summary>
        public unsafe static void glVertexAttrib4NubvARB(uint index, byte* v) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttrib4NubvARB>("glVertexAttrib4NubvARB");
            _F(index, v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_vertex_program, GL_ARB_vertex_shader</para>
        /// Supported: <para>gl, gl</para>
        /// Original: <para>void glVertexAttrib4NuivARB(GLuint index, const GLuint * v);</para>
        /// </summary>
        public unsafe static void glVertexAttrib4NuivARB(uint index, uint* v) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttrib4NuivARB>("glVertexAttrib4NuivARB");
            _F(index, v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_vertex_program, GL_ARB_vertex_shader</para>
        /// Supported: <para>gl, gl</para>
        /// Original: <para>void glVertexAttrib4NusvARB(GLuint index, const GLushort * v);</para>
        /// </summary>
        public unsafe static void glVertexAttrib4NusvARB(uint index, ushort* v) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttrib4NusvARB>("glVertexAttrib4NusvARB");
            _F(index, v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_vertex_program, GL_ARB_vertex_shader</para>
        /// Supported: <para>gl, gl</para>
        /// Original: <para>void glVertexAttrib4bvARB(GLuint index, const GLbyte * v);</para>
        /// </summary>
        public unsafe static void glVertexAttrib4bvARB(uint index, byte* v) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttrib4bvARB>("glVertexAttrib4bvARB");
            _F(index, v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_vertex_program, GL_ARB_vertex_shader</para>
        /// Supported: <para>gl, gl</para>
        /// Original: <para>void glVertexAttrib4dARB(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);</para>
        /// </summary>
        public static void glVertexAttrib4dARB(uint index, double x, double y, double z, double w) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttrib4dARB>("glVertexAttrib4dARB");
            _F(index, x, y, z, w);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_vertex_program, GL_ARB_vertex_shader</para>
        /// Supported: <para>gl, gl</para>
        /// Original: <para>void glVertexAttrib4dvARB(GLuint index, const GLdouble * v);</para>
        /// </summary>
        public unsafe static void glVertexAttrib4dvARB(uint index, double* v) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttrib4dvARB>("glVertexAttrib4dvARB");
            _F(index, v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_vertex_program, GL_ARB_vertex_shader</para>
        /// Supported: <para>gl, gl</para>
        /// Original: <para>void glVertexAttrib4fARB(GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);</para>
        /// </summary>
        public static void glVertexAttrib4fARB(uint index, float x, float y, float z, float w) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttrib4fARB>("glVertexAttrib4fARB");
            _F(index, x, y, z, w);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_vertex_program, GL_ARB_vertex_shader</para>
        /// Supported: <para>gl, gl</para>
        /// Original: <para>void glVertexAttrib4fvARB(GLuint index, const GLfloat * v);</para>
        /// </summary>
        public unsafe static void glVertexAttrib4fvARB(uint index, float* v) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttrib4fvARB>("glVertexAttrib4fvARB");
            _F(index, v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_vertex_program, GL_ARB_vertex_shader</para>
        /// Supported: <para>gl, gl</para>
        /// Original: <para>void glVertexAttrib4ivARB(GLuint index, const GLint * v);</para>
        /// </summary>
        public unsafe static void glVertexAttrib4ivARB(uint index, int* v) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttrib4ivARB>("glVertexAttrib4ivARB");
            _F(index, v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_vertex_program, GL_ARB_vertex_shader</para>
        /// Supported: <para>gl, gl</para>
        /// Original: <para>void glVertexAttrib4sARB(GLuint index, GLshort x, GLshort y, GLshort z, GLshort w);</para>
        /// </summary>
        public static void glVertexAttrib4sARB(uint index, short x, short y, short z, short w) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttrib4sARB>("glVertexAttrib4sARB");
            _F(index, x, y, z, w);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_vertex_program, GL_ARB_vertex_shader</para>
        /// Supported: <para>gl, gl</para>
        /// Original: <para>void glVertexAttrib4svARB(GLuint index, const GLshort * v);</para>
        /// </summary>
        public unsafe static void glVertexAttrib4svARB(uint index, short* v) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttrib4svARB>("glVertexAttrib4svARB");
            _F(index, v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_vertex_program, GL_ARB_vertex_shader</para>
        /// Supported: <para>gl, gl</para>
        /// Original: <para>void glVertexAttrib4ubvARB(GLuint index, const GLubyte * v);</para>
        /// </summary>
        public unsafe static void glVertexAttrib4ubvARB(uint index, byte* v) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttrib4ubvARB>("glVertexAttrib4ubvARB");
            _F(index, v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_vertex_program, GL_ARB_vertex_shader</para>
        /// Supported: <para>gl, gl</para>
        /// Original: <para>void glVertexAttrib4uivARB(GLuint index, const GLuint * v);</para>
        /// </summary>
        public unsafe static void glVertexAttrib4uivARB(uint index, uint* v) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttrib4uivARB>("glVertexAttrib4uivARB");
            _F(index, v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_vertex_program, GL_ARB_vertex_shader</para>
        /// Supported: <para>gl, gl</para>
        /// Original: <para>void glVertexAttrib4usvARB(GLuint index, const GLushort * v);</para>
        /// </summary>
        public unsafe static void glVertexAttrib4usvARB(uint index, ushort* v) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttrib4usvARB>("glVertexAttrib4usvARB");
            _F(index, v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_vertex_program, GL_ARB_vertex_shader</para>
        /// Supported: <para>gl, gl</para>
        /// Original: <para>void glVertexAttribPointerARB(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const void * pointer);</para>
        /// </summary>
        public unsafe static void glVertexAttribPointerARB(uint index, int size, uint type, bool normalized, int stride, void* pointer) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttribPointerARB>("glVertexAttribPointerARB");
            _F(index, size, type, normalized, stride, pointer);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_vertex_program, GL_ARB_vertex_shader</para>
        /// Supported: <para>gl, gl</para>
        /// Original: <para>void glEnableVertexAttribArrayARB(GLuint index);</para>
        /// </summary>
        public static void glEnableVertexAttribArrayARB(uint index) {
            var _F = _GetProc<GLNativeDelegate.FNglEnableVertexAttribArrayARB>("glEnableVertexAttribArrayARB");
            _F(index);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_vertex_program, GL_ARB_vertex_shader</para>
        /// Supported: <para>gl, gl</para>
        /// Original: <para>void glDisableVertexAttribArrayARB(GLuint index);</para>
        /// </summary>
        public static void glDisableVertexAttribArrayARB(uint index) {
            var _F = _GetProc<GLNativeDelegate.FNglDisableVertexAttribArrayARB>("glDisableVertexAttribArrayARB");
            _F(index);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_fragment_program, GL_ARB_vertex_program</para>
        /// Supported: <para>gl, gl</para>
        /// Original: <para>void glProgramStringARB(GLenum target, GLenum format, GLsizei len, const void * string);</para>
        /// </summary>
        public unsafe static void glProgramStringARB(uint target, uint format, int len, void* str) {
            var _F = _GetProc<GLNativeDelegate.FNglProgramStringARB>("glProgramStringARB");
            _F(target, format, len, str);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_fragment_program, GL_ARB_vertex_program</para>
        /// Supported: <para>gl, gl</para>
        /// Original: <para>void glBindProgramARB(GLenum target, GLuint program);</para>
        /// </summary>
        public static void glBindProgramARB(uint target, uint program) {
            var _F = _GetProc<GLNativeDelegate.FNglBindProgramARB>("glBindProgramARB");
            _F(target, program);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_fragment_program, GL_ARB_vertex_program</para>
        /// Supported: <para>gl, gl</para>
        /// Original: <para>void glDeleteProgramsARB(GLsizei n, const GLuint * programs);</para>
        /// </summary>
        public unsafe static void glDeleteProgramsARB(int n, uint* programs) {
            var _F = _GetProc<GLNativeDelegate.FNglDeleteProgramsARB>("glDeleteProgramsARB");
            _F(n, programs);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_fragment_program, GL_ARB_vertex_program</para>
        /// Supported: <para>gl, gl</para>
        /// Original: <para>void glGenProgramsARB(GLsizei n, GLuint * programs);</para>
        /// </summary>
        public unsafe static void glGenProgramsARB(int n, uint* programs) {
            var _F = _GetProc<GLNativeDelegate.FNglGenProgramsARB>("glGenProgramsARB");
            _F(n, programs);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_fragment_program, GL_ARB_vertex_program</para>
        /// Supported: <para>gl, gl</para>
        /// Original: <para>void glProgramEnvParameter4dARB(GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);</para>
        /// </summary>
        public static void glProgramEnvParameter4dARB(uint target, uint index, double x, double y, double z, double w) {
            var _F = _GetProc<GLNativeDelegate.FNglProgramEnvParameter4dARB>("glProgramEnvParameter4dARB");
            _F(target, index, x, y, z, w);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_fragment_program, GL_ARB_vertex_program</para>
        /// Supported: <para>gl, gl</para>
        /// Original: <para>void glProgramEnvParameter4dvARB(GLenum target, GLuint index, const GLdouble * params);</para>
        /// </summary>
        public unsafe static void glProgramEnvParameter4dvARB(uint target, uint index, double* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglProgramEnvParameter4dvARB>("glProgramEnvParameter4dvARB");
            _F(target, index, ps);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_fragment_program, GL_ARB_vertex_program</para>
        /// Supported: <para>gl, gl</para>
        /// Original: <para>void glProgramEnvParameter4fARB(GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);</para>
        /// </summary>
        public static void glProgramEnvParameter4fARB(uint target, uint index, float x, float y, float z, float w) {
            var _F = _GetProc<GLNativeDelegate.FNglProgramEnvParameter4fARB>("glProgramEnvParameter4fARB");
            _F(target, index, x, y, z, w);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_fragment_program, GL_ARB_vertex_program</para>
        /// Supported: <para>gl, gl</para>
        /// Original: <para>void glProgramEnvParameter4fvARB(GLenum target, GLuint index, const GLfloat * params);</para>
        /// </summary>
        public unsafe static void glProgramEnvParameter4fvARB(uint target, uint index, float* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglProgramEnvParameter4fvARB>("glProgramEnvParameter4fvARB");
            _F(target, index, ps);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_fragment_program, GL_ARB_vertex_program</para>
        /// Supported: <para>gl, gl</para>
        /// Original: <para>void glProgramLocalParameter4dARB(GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);</para>
        /// </summary>
        public static void glProgramLocalParameter4dARB(uint target, uint index, double x, double y, double z, double w) {
            var _F = _GetProc<GLNativeDelegate.FNglProgramLocalParameter4dARB>("glProgramLocalParameter4dARB");
            _F(target, index, x, y, z, w);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_fragment_program, GL_ARB_vertex_program</para>
        /// Supported: <para>gl, gl</para>
        /// Original: <para>void glProgramLocalParameter4dvARB(GLenum target, GLuint index, const GLdouble * params);</para>
        /// </summary>
        public unsafe static void glProgramLocalParameter4dvARB(uint target, uint index, double* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglProgramLocalParameter4dvARB>("glProgramLocalParameter4dvARB");
            _F(target, index, ps);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_fragment_program, GL_ARB_vertex_program</para>
        /// Supported: <para>gl, gl</para>
        /// Original: <para>void glProgramLocalParameter4fARB(GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);</para>
        /// </summary>
        public static void glProgramLocalParameter4fARB(uint target, uint index, float x, float y, float z, float w) {
            var _F = _GetProc<GLNativeDelegate.FNglProgramLocalParameter4fARB>("glProgramLocalParameter4fARB");
            _F(target, index, x, y, z, w);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_fragment_program, GL_ARB_vertex_program</para>
        /// Supported: <para>gl, gl</para>
        /// Original: <para>void glProgramLocalParameter4fvARB(GLenum target, GLuint index, const GLfloat * params);</para>
        /// </summary>
        public unsafe static void glProgramLocalParameter4fvARB(uint target, uint index, float* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglProgramLocalParameter4fvARB>("glProgramLocalParameter4fvARB");
            _F(target, index, ps);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_fragment_program, GL_ARB_vertex_program</para>
        /// Supported: <para>gl, gl</para>
        /// Original: <para>void glGetProgramEnvParameterdvARB(GLenum target, GLuint index, GLdouble * params);</para>
        /// </summary>
        public unsafe static void glGetProgramEnvParameterdvARB(uint target, uint index, double* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetProgramEnvParameterdvARB>("glGetProgramEnvParameterdvARB");
            _F(target, index, ps);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_fragment_program, GL_ARB_vertex_program</para>
        /// Supported: <para>gl, gl</para>
        /// Original: <para>void glGetProgramEnvParameterfvARB(GLenum target, GLuint index, GLfloat * params);</para>
        /// </summary>
        public unsafe static void glGetProgramEnvParameterfvARB(uint target, uint index, float* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetProgramEnvParameterfvARB>("glGetProgramEnvParameterfvARB");
            _F(target, index, ps);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_fragment_program, GL_ARB_vertex_program</para>
        /// Supported: <para>gl, gl</para>
        /// Original: <para>void glGetProgramLocalParameterdvARB(GLenum target, GLuint index, GLdouble * params);</para>
        /// </summary>
        public unsafe static void glGetProgramLocalParameterdvARB(uint target, uint index, double* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetProgramLocalParameterdvARB>("glGetProgramLocalParameterdvARB");
            _F(target, index, ps);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_fragment_program, GL_ARB_vertex_program</para>
        /// Supported: <para>gl, gl</para>
        /// Original: <para>void glGetProgramLocalParameterfvARB(GLenum target, GLuint index, GLfloat * params);</para>
        /// </summary>
        public unsafe static void glGetProgramLocalParameterfvARB(uint target, uint index, float* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetProgramLocalParameterfvARB>("glGetProgramLocalParameterfvARB");
            _F(target, index, ps);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_fragment_program, GL_ARB_vertex_program</para>
        /// Supported: <para>gl, gl</para>
        /// Original: <para>void glGetProgramivARB(GLenum target, GLenum pname, GLint * params);</para>
        /// </summary>
        public unsafe static void glGetProgramivARB(uint target, uint pname, int* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetProgramivARB>("glGetProgramivARB");
            _F(target, pname, ps);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_fragment_program, GL_ARB_vertex_program</para>
        /// Supported: <para>gl, gl</para>
        /// Original: <para>void glGetProgramStringARB(GLenum target, GLenum pname, void * string);</para>
        /// </summary>
        public unsafe static void glGetProgramStringARB(uint target, uint pname, void* str) {
            var _F = _GetProc<GLNativeDelegate.FNglGetProgramStringARB>("glGetProgramStringARB");
            _F(target, pname, str);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_vertex_program, GL_ARB_vertex_shader</para>
        /// Supported: <para>gl, gl</para>
        /// Original: <para>void glGetVertexAttribdvARB(GLuint index, GLenum pname, GLdouble * params);</para>
        /// </summary>
        public unsafe static void glGetVertexAttribdvARB(uint index, uint pname, double* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetVertexAttribdvARB>("glGetVertexAttribdvARB");
            _F(index, pname, ps);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_vertex_program, GL_ARB_vertex_shader</para>
        /// Supported: <para>gl, gl</para>
        /// Original: <para>void glGetVertexAttribfvARB(GLuint index, GLenum pname, GLfloat * params);</para>
        /// </summary>
        public unsafe static void glGetVertexAttribfvARB(uint index, uint pname, float* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetVertexAttribfvARB>("glGetVertexAttribfvARB");
            _F(index, pname, ps);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_vertex_program, GL_ARB_vertex_shader</para>
        /// Supported: <para>gl, gl</para>
        /// Original: <para>void glGetVertexAttribivARB(GLuint index, GLenum pname, GLint * params);</para>
        /// </summary>
        public unsafe static void glGetVertexAttribivARB(uint index, uint pname, int* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetVertexAttribivARB>("glGetVertexAttribivARB");
            _F(index, pname, ps);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_vertex_program, GL_ARB_vertex_shader</para>
        /// Supported: <para>gl, gl</para>
        /// Original: <para>void glGetVertexAttribPointervARB(GLuint index, GLenum pname, void ** pointer);</para>
        /// </summary>
        public unsafe static void glGetVertexAttribPointervARB(uint index, uint pname, void** pointer) {
            var _F = _GetProc<GLNativeDelegate.FNglGetVertexAttribPointervARB>("glGetVertexAttribPointervARB");
            _F(index, pname, pointer);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_fragment_program, GL_ARB_vertex_program</para>
        /// Supported: <para>gl, gl</para>
        /// Original: <para>GLboolean glIsProgramARB(GLuint program);</para>
        /// </summary>
        public static bool glIsProgramARB(uint program) {
            var _F = _GetProc<GLNativeDelegate.FNglIsProgramARB>("glIsProgramARB");
            return _F(program);
        }

        #endregion GL_ARB_vertex_program

        #region GL_ARB_vertex_shader

        // void glVertexAttrib1fARB(GLuint index, GLfloat x);
        // void glVertexAttrib1sARB(GLuint index, GLshort x);
        // void glVertexAttrib1dARB(GLuint index, GLdouble x);
        // void glVertexAttrib2fARB(GLuint index, GLfloat x, GLfloat y);
        // void glVertexAttrib2sARB(GLuint index, GLshort x, GLshort y);
        // void glVertexAttrib2dARB(GLuint index, GLdouble x, GLdouble y);
        // void glVertexAttrib3fARB(GLuint index, GLfloat x, GLfloat y, GLfloat z);
        // void glVertexAttrib3sARB(GLuint index, GLshort x, GLshort y, GLshort z);
        // void glVertexAttrib3dARB(GLuint index, GLdouble x, GLdouble y, GLdouble z);
        // void glVertexAttrib4fARB(GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
        // void glVertexAttrib4sARB(GLuint index, GLshort x, GLshort y, GLshort z, GLshort w);
        // void glVertexAttrib4dARB(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
        // void glVertexAttrib4NubARB(GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w);
        // void glVertexAttrib1fvARB(GLuint index, const GLfloat * v);
        // void glVertexAttrib1svARB(GLuint index, const GLshort * v);
        // void glVertexAttrib1dvARB(GLuint index, const GLdouble * v);
        // void glVertexAttrib2fvARB(GLuint index, const GLfloat * v);
        // void glVertexAttrib2svARB(GLuint index, const GLshort * v);
        // void glVertexAttrib2dvARB(GLuint index, const GLdouble * v);
        // void glVertexAttrib3fvARB(GLuint index, const GLfloat * v);
        // void glVertexAttrib3svARB(GLuint index, const GLshort * v);
        // void glVertexAttrib3dvARB(GLuint index, const GLdouble * v);
        // void glVertexAttrib4fvARB(GLuint index, const GLfloat * v);
        // void glVertexAttrib4svARB(GLuint index, const GLshort * v);
        // void glVertexAttrib4dvARB(GLuint index, const GLdouble * v);
        // void glVertexAttrib4ivARB(GLuint index, const GLint * v);
        // void glVertexAttrib4bvARB(GLuint index, const GLbyte * v);
        // void glVertexAttrib4ubvARB(GLuint index, const GLubyte * v);
        // void glVertexAttrib4usvARB(GLuint index, const GLushort * v);
        // void glVertexAttrib4uivARB(GLuint index, const GLuint * v);
        // void glVertexAttrib4NbvARB(GLuint index, const GLbyte * v);
        // void glVertexAttrib4NsvARB(GLuint index, const GLshort * v);
        // void glVertexAttrib4NivARB(GLuint index, const GLint * v);
        // void glVertexAttrib4NubvARB(GLuint index, const GLubyte * v);
        // void glVertexAttrib4NusvARB(GLuint index, const GLushort * v);
        // void glVertexAttrib4NuivARB(GLuint index, const GLuint * v);
        // void glVertexAttribPointerARB(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const void * pointer);
        // void glEnableVertexAttribArrayARB(GLuint index);
        // void glDisableVertexAttribArrayARB(GLuint index);
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_vertex_shader</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glBindAttribLocationARB(GLhandleARB programObj, GLuint index, const GLcharARB * name);</para>
        /// </summary>
        public unsafe static void glBindAttribLocationARB(uint programObj, uint index, uint* name) {
            var _F = _GetProc<GLNativeDelegate.FNglBindAttribLocationARB>("glBindAttribLocationARB");
            _F(programObj, index, name);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_vertex_shader</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetActiveAttribARB(GLhandleARB programObj, GLuint index, GLsizei maxLength, GLsizei * length, GLint * size, GLenum * type, GLcharARB * name);</para>
        /// </summary>
        public unsafe static void glGetActiveAttribARB(uint programObj, uint index, int maxLength, int* length, int* size, uint* type, uint* name) {
            var _F = _GetProc<GLNativeDelegate.FNglGetActiveAttribARB>("glGetActiveAttribARB");
            _F(programObj, index, maxLength, length, size, type, name);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_vertex_shader</para>
        /// Supported: <para>gl</para>
        /// Original: <para>GLint glGetAttribLocationARB(GLhandleARB programObj, const GLcharARB * name);</para>
        /// </summary>
        public unsafe static int glGetAttribLocationARB(uint programObj, uint* name) {
            var _F = _GetProc<GLNativeDelegate.FNglGetAttribLocationARB>("glGetAttribLocationARB");
            return _F(programObj, name);
        }
        // void glGetVertexAttribdvARB(GLuint index, GLenum pname, GLdouble * ps);
        // void glGetVertexAttribfvARB(GLuint index, GLenum pname, GLfloat * ps);
        // void glGetVertexAttribivARB(GLuint index, GLenum pname, GLint * ps);
        // void glGetVertexAttribPointervARB(GLuint index, GLenum pname, void ** pointer);

        #endregion GL_ARB_vertex_shader

        #region GL_ARB_vertex_type_2_10_10_10_rev

        // void glVertexAttribP1ui(GLuint index, GLenum type, GLboolean normalized, GLuint value);
        // void glVertexAttribP1uiv(GLuint index, GLenum type, GLboolean normalized, const GLuint * value);
        // void glVertexAttribP2ui(GLuint index, GLenum type, GLboolean normalized, GLuint value);
        // void glVertexAttribP2uiv(GLuint index, GLenum type, GLboolean normalized, const GLuint * value);
        // void glVertexAttribP3ui(GLuint index, GLenum type, GLboolean normalized, GLuint value);
        // void glVertexAttribP3uiv(GLuint index, GLenum type, GLboolean normalized, const GLuint * value);
        // void glVertexAttribP4ui(GLuint index, GLenum type, GLboolean normalized, GLuint value);
        // void glVertexAttribP4uiv(GLuint index, GLenum type, GLboolean normalized, const GLuint * value);
        // void glVertexP2ui(GLenum type, GLuint value);
        // void glVertexP2uiv(GLenum type, const GLuint * value);
        // void glVertexP3ui(GLenum type, GLuint value);
        // void glVertexP3uiv(GLenum type, const GLuint * value);
        // void glVertexP4ui(GLenum type, GLuint value);
        // void glVertexP4uiv(GLenum type, const GLuint * value);
        // void glTexCoordP1ui(GLenum type, GLuint coords);
        // void glTexCoordP1uiv(GLenum type, const GLuint * coords);
        // void glTexCoordP2ui(GLenum type, GLuint coords);
        // void glTexCoordP2uiv(GLenum type, const GLuint * coords);
        // void glTexCoordP3ui(GLenum type, GLuint coords);
        // void glTexCoordP3uiv(GLenum type, const GLuint * coords);
        // void glTexCoordP4ui(GLenum type, GLuint coords);
        // void glTexCoordP4uiv(GLenum type, const GLuint * coords);
        // void glMultiTexCoordP1ui(GLenum texture, GLenum type, GLuint coords);
        // void glMultiTexCoordP1uiv(GLenum texture, GLenum type, const GLuint * coords);
        // void glMultiTexCoordP2ui(GLenum texture, GLenum type, GLuint coords);
        // void glMultiTexCoordP2uiv(GLenum texture, GLenum type, const GLuint * coords);
        // void glMultiTexCoordP3ui(GLenum texture, GLenum type, GLuint coords);
        // void glMultiTexCoordP3uiv(GLenum texture, GLenum type, const GLuint * coords);
        // void glMultiTexCoordP4ui(GLenum texture, GLenum type, GLuint coords);
        // void glMultiTexCoordP4uiv(GLenum texture, GLenum type, const GLuint * coords);
        // void glNormalP3ui(GLenum type, GLuint coords);
        // void glNormalP3uiv(GLenum type, const GLuint * coords);
        // void glColorP3ui(GLenum type, GLuint color);
        // void glColorP3uiv(GLenum type, const GLuint * color);
        // void glColorP4ui(GLenum type, GLuint color);
        // void glColorP4uiv(GLenum type, const GLuint * color);
        // void glSecondaryColorP3ui(GLenum type, GLuint color);
        // void glSecondaryColorP3uiv(GLenum type, const GLuint * color);

        #endregion GL_ARB_vertex_type_2_10_10_10_rev

        #region GL_ARB_viewport_array

        // void glViewportArrayv(GLuint first, GLsizei count, const GLfloat * v);
        // void glViewportIndexedf(GLuint index, GLfloat x, GLfloat y, GLfloat w, GLfloat h);
        // void glViewportIndexedfv(GLuint index, const GLfloat * v);
        // void glScissorArrayv(GLuint first, GLsizei count, const GLint * v);
        // void glScissorIndexed(GLuint index, GLint left, GLint bottom, GLsizei width, GLsizei height);
        // void glScissorIndexedv(GLuint index, const GLint * v);
        // void glDepthRangeArrayv(GLuint first, GLsizei count, const GLdouble * v);
        // void glDepthRangeIndexed(GLuint index, GLdouble nearVal, GLdouble farVal);
        // void glGetFloati_v(GLenum target, GLuint index, GLfloat * data);
        // void glGetDoublei_v(GLenum target, GLuint index, GLdouble * data);
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_viewport_array</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glDepthRangeArraydvNV(GLuint first, GLsizei count, const GLdouble * v);</para>
        /// </summary>
        public unsafe static void glDepthRangeArraydvNV(uint first, int count, double* v) {
            var _F = _GetProc<GLNativeDelegate.FNglDepthRangeArraydvNV>("glDepthRangeArraydvNV");
            _F(first, count, v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_viewport_array</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glDepthRangeIndexeddNV(GLuint index, GLdouble n, GLdouble f);</para>
        /// </summary>
        public static void glDepthRangeIndexeddNV(uint index, double n, double f) {
            var _F = _GetProc<GLNativeDelegate.FNglDepthRangeIndexeddNV>("glDepthRangeIndexeddNV");
            _F(index, n, f);
        }

        #endregion GL_ARB_viewport_array

        #region GL_ARB_window_pos

        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_window_pos</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glWindowPos2dARB(GLdouble x, GLdouble y);</para>
        /// </summary>
        public static void glWindowPos2dARB(double x, double y) {
            var _F = _GetProc<GLNativeDelegate.FNglWindowPos2dARB>("glWindowPos2dARB");
            _F(x, y);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_window_pos</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glWindowPos2dvARB(const GLdouble * v);</para>
        /// </summary>
        public unsafe static void glWindowPos2dvARB(double* v) {
            var _F = _GetProc<GLNativeDelegate.FNglWindowPos2dvARB>("glWindowPos2dvARB");
            _F(v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_window_pos</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glWindowPos2fARB(GLfloat x, GLfloat y);</para>
        /// </summary>
        public static void glWindowPos2fARB(float x, float y) {
            var _F = _GetProc<GLNativeDelegate.FNglWindowPos2fARB>("glWindowPos2fARB");
            _F(x, y);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_window_pos</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glWindowPos2fvARB(const GLfloat * v);</para>
        /// </summary>
        public unsafe static void glWindowPos2fvARB(float* v) {
            var _F = _GetProc<GLNativeDelegate.FNglWindowPos2fvARB>("glWindowPos2fvARB");
            _F(v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_window_pos</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glWindowPos2iARB(GLint x, GLint y);</para>
        /// </summary>
        public static void glWindowPos2iARB(int x, int y) {
            var _F = _GetProc<GLNativeDelegate.FNglWindowPos2iARB>("glWindowPos2iARB");
            _F(x, y);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_window_pos</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glWindowPos2ivARB(const GLint * v);</para>
        /// </summary>
        public unsafe static void glWindowPos2ivARB(int* v) {
            var _F = _GetProc<GLNativeDelegate.FNglWindowPos2ivARB>("glWindowPos2ivARB");
            _F(v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_window_pos</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glWindowPos2sARB(GLshort x, GLshort y);</para>
        /// </summary>
        public static void glWindowPos2sARB(short x, short y) {
            var _F = _GetProc<GLNativeDelegate.FNglWindowPos2sARB>("glWindowPos2sARB");
            _F(x, y);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_window_pos</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glWindowPos2svARB(const GLshort * v);</para>
        /// </summary>
        public unsafe static void glWindowPos2svARB(short* v) {
            var _F = _GetProc<GLNativeDelegate.FNglWindowPos2svARB>("glWindowPos2svARB");
            _F(v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_window_pos</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glWindowPos3dARB(GLdouble x, GLdouble y, GLdouble z);</para>
        /// </summary>
        public static void glWindowPos3dARB(double x, double y, double z) {
            var _F = _GetProc<GLNativeDelegate.FNglWindowPos3dARB>("glWindowPos3dARB");
            _F(x, y, z);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_window_pos</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glWindowPos3dvARB(const GLdouble * v);</para>
        /// </summary>
        public unsafe static void glWindowPos3dvARB(double* v) {
            var _F = _GetProc<GLNativeDelegate.FNglWindowPos3dvARB>("glWindowPos3dvARB");
            _F(v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_window_pos</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glWindowPos3fARB(GLfloat x, GLfloat y, GLfloat z);</para>
        /// </summary>
        public static void glWindowPos3fARB(float x, float y, float z) {
            var _F = _GetProc<GLNativeDelegate.FNglWindowPos3fARB>("glWindowPos3fARB");
            _F(x, y, z);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_window_pos</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glWindowPos3fvARB(const GLfloat * v);</para>
        /// </summary>
        public unsafe static void glWindowPos3fvARB(float* v) {
            var _F = _GetProc<GLNativeDelegate.FNglWindowPos3fvARB>("glWindowPos3fvARB");
            _F(v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_window_pos</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glWindowPos3iARB(GLint x, GLint y, GLint z);</para>
        /// </summary>
        public static void glWindowPos3iARB(int x, int y, int z) {
            var _F = _GetProc<GLNativeDelegate.FNglWindowPos3iARB>("glWindowPos3iARB");
            _F(x, y, z);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_window_pos</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glWindowPos3ivARB(const GLint * v);</para>
        /// </summary>
        public unsafe static void glWindowPos3ivARB(int* v) {
            var _F = _GetProc<GLNativeDelegate.FNglWindowPos3ivARB>("glWindowPos3ivARB");
            _F(v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_window_pos</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glWindowPos3sARB(GLshort x, GLshort y, GLshort z);</para>
        /// </summary>
        public static void glWindowPos3sARB(short x, short y, short z) {
            var _F = _GetProc<GLNativeDelegate.FNglWindowPos3sARB>("glWindowPos3sARB");
            _F(x, y, z);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ARB_window_pos</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glWindowPos3svARB(const GLshort * v);</para>
        /// </summary>
        public unsafe static void glWindowPos3svARB(short* v) {
            var _F = _GetProc<GLNativeDelegate.FNglWindowPos3svARB>("glWindowPos3svARB");
            _F(v);
        }

        #endregion GL_ARB_window_pos

        #region GL_ATI_draw_buffers

        /// <summary>
        /// <para>Require:</para> <para>GL_ATI_draw_buffers</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glDrawBuffersATI(GLsizei n, const GLenum * bufs);</para>
        /// </summary>
        public unsafe static void glDrawBuffersATI(int n, uint* bufs) {
            var _F = _GetProc<GLNativeDelegate.FNglDrawBuffersATI>("glDrawBuffersATI");
            _F(n, bufs);
        }

        #endregion GL_ATI_draw_buffers

        #region GL_ATI_element_array

        /// <summary>
        /// <para>Require:</para> <para>GL_ATI_element_array</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glElementPointerATI(GLenum type, const void * pointer);</para>
        /// </summary>
        public unsafe static void glElementPointerATI(uint type, void* pointer) {
            var _F = _GetProc<GLNativeDelegate.FNglElementPointerATI>("glElementPointerATI");
            _F(type, pointer);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ATI_element_array</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glDrawElementArrayATI(GLenum mode, GLsizei count);</para>
        /// </summary>
        public static void glDrawElementArrayATI(uint mode, int count) {
            var _F = _GetProc<GLNativeDelegate.FNglDrawElementArrayATI>("glDrawElementArrayATI");
            _F(mode, count);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ATI_element_array</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glDrawRangeElementArrayATI(GLenum mode, GLuint start, GLuint end, GLsizei count);</para>
        /// </summary>
        public static void glDrawRangeElementArrayATI(uint mode, uint start, uint end, int count) {
            var _F = _GetProc<GLNativeDelegate.FNglDrawRangeElementArrayATI>("glDrawRangeElementArrayATI");
            _F(mode, start, end, count);
        }

        #endregion GL_ATI_element_array

        #region GL_ATI_envmap_bumpmap

        /// <summary>
        /// <para>Require:</para> <para>GL_ATI_envmap_bumpmap</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glTexBumpParameterivATI(GLenum pname, const GLint * param);</para>
        /// </summary>
        public unsafe static void glTexBumpParameterivATI(uint pname, int* param) {
            var _F = _GetProc<GLNativeDelegate.FNglTexBumpParameterivATI>("glTexBumpParameterivATI");
            _F(pname, param);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ATI_envmap_bumpmap</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glTexBumpParameterfvATI(GLenum pname, const GLfloat * param);</para>
        /// </summary>
        public unsafe static void glTexBumpParameterfvATI(uint pname, float* param) {
            var _F = _GetProc<GLNativeDelegate.FNglTexBumpParameterfvATI>("glTexBumpParameterfvATI");
            _F(pname, param);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ATI_envmap_bumpmap</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetTexBumpParameterivATI(GLenum pname, GLint * param);</para>
        /// </summary>
        public unsafe static void glGetTexBumpParameterivATI(uint pname, int* param) {
            var _F = _GetProc<GLNativeDelegate.FNglGetTexBumpParameterivATI>("glGetTexBumpParameterivATI");
            _F(pname, param);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ATI_envmap_bumpmap</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetTexBumpParameterfvATI(GLenum pname, GLfloat * param);</para>
        /// </summary>
        public unsafe static void glGetTexBumpParameterfvATI(uint pname, float* param) {
            var _F = _GetProc<GLNativeDelegate.FNglGetTexBumpParameterfvATI>("glGetTexBumpParameterfvATI");
            _F(pname, param);
        }

        #endregion GL_ATI_envmap_bumpmap

        #region GL_ATI_fragment_shader

        /// <summary>
        /// <para>Require:</para> <para>GL_ATI_fragment_shader</para>
        /// Supported: <para>gl</para>
        /// Original: <para>GLuint glGenFragmentShadersATI(GLuint range);</para>
        /// </summary>
        public static uint glGenFragmentShadersATI(uint range) {
            var _F = _GetProc<GLNativeDelegate.FNglGenFragmentShadersATI>("glGenFragmentShadersATI");
            return _F(range);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ATI_fragment_shader</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glBindFragmentShaderATI(GLuint id);</para>
        /// </summary>
        public static void glBindFragmentShaderATI(uint id) {
            var _F = _GetProc<GLNativeDelegate.FNglBindFragmentShaderATI>("glBindFragmentShaderATI");
            _F(id);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ATI_fragment_shader</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glDeleteFragmentShaderATI(GLuint id);</para>
        /// </summary>
        public static void glDeleteFragmentShaderATI(uint id) {
            var _F = _GetProc<GLNativeDelegate.FNglDeleteFragmentShaderATI>("glDeleteFragmentShaderATI");
            _F(id);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ATI_fragment_shader</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glBeginFragmentShaderATI();</para>
        /// </summary>
        public static void glBeginFragmentShaderATI() {
            var _F = _GetProc<GLNativeDelegate.FNglBeginFragmentShaderATI>("glBeginFragmentShaderATI");
            _F();
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ATI_fragment_shader</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glEndFragmentShaderATI();</para>
        /// </summary>
        public static void glEndFragmentShaderATI() {
            var _F = _GetProc<GLNativeDelegate.FNglEndFragmentShaderATI>("glEndFragmentShaderATI");
            _F();
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ATI_fragment_shader</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glPassTexCoordATI(GLuint dst, GLuint coord, GLenum swizzle);</para>
        /// </summary>
        public static void glPassTexCoordATI(uint dst, uint coord, uint swizzle) {
            var _F = _GetProc<GLNativeDelegate.FNglPassTexCoordATI>("glPassTexCoordATI");
            _F(dst, coord, swizzle);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ATI_fragment_shader</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glSampleMapATI(GLuint dst, GLuint interp, GLenum swizzle);</para>
        /// </summary>
        public static void glSampleMapATI(uint dst, uint interp, uint swizzle) {
            var _F = _GetProc<GLNativeDelegate.FNglSampleMapATI>("glSampleMapATI");
            _F(dst, interp, swizzle);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ATI_fragment_shader</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glColorFragmentOp1ATI(GLenum op, GLuint dst, GLuint dstMask, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod);</para>
        /// </summary>
        public static void glColorFragmentOp1ATI(uint op, uint dst, uint dstMask, uint dstMod, uint arg1, uint arg1Rep, uint arg1Mod) {
            var _F = _GetProc<GLNativeDelegate.FNglColorFragmentOp1ATI>("glColorFragmentOp1ATI");
            _F(op, dst, dstMask, dstMod, arg1, arg1Rep, arg1Mod);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ATI_fragment_shader</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glColorFragmentOp2ATI(GLenum op, GLuint dst, GLuint dstMask, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod);</para>
        /// </summary>
        public static void glColorFragmentOp2ATI(uint op, uint dst, uint dstMask, uint dstMod, uint arg1, uint arg1Rep, uint arg1Mod, uint arg2, uint arg2Rep, uint arg2Mod) {
            var _F = _GetProc<GLNativeDelegate.FNglColorFragmentOp2ATI>("glColorFragmentOp2ATI");
            _F(op, dst, dstMask, dstMod, arg1, arg1Rep, arg1Mod, arg2, arg2Rep, arg2Mod);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ATI_fragment_shader</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glColorFragmentOp3ATI(GLenum op, GLuint dst, GLuint dstMask, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod, GLuint arg3, GLuint arg3Rep, GLuint arg3Mod);</para>
        /// </summary>
        public static void glColorFragmentOp3ATI(uint op, uint dst, uint dstMask, uint dstMod, uint arg1, uint arg1Rep, uint arg1Mod, uint arg2, uint arg2Rep, uint arg2Mod, uint arg3, uint arg3Rep, uint arg3Mod) {
            var _F = _GetProc<GLNativeDelegate.FNglColorFragmentOp3ATI>("glColorFragmentOp3ATI");
            _F(op, dst, dstMask, dstMod, arg1, arg1Rep, arg1Mod, arg2, arg2Rep, arg2Mod, arg3, arg3Rep, arg3Mod);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ATI_fragment_shader</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glAlphaFragmentOp1ATI(GLenum op, GLuint dst, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod);</para>
        /// </summary>
        public static void glAlphaFragmentOp1ATI(uint op, uint dst, uint dstMod, uint arg1, uint arg1Rep, uint arg1Mod) {
            var _F = _GetProc<GLNativeDelegate.FNglAlphaFragmentOp1ATI>("glAlphaFragmentOp1ATI");
            _F(op, dst, dstMod, arg1, arg1Rep, arg1Mod);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ATI_fragment_shader</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glAlphaFragmentOp2ATI(GLenum op, GLuint dst, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod);</para>
        /// </summary>
        public static void glAlphaFragmentOp2ATI(uint op, uint dst, uint dstMod, uint arg1, uint arg1Rep, uint arg1Mod, uint arg2, uint arg2Rep, uint arg2Mod) {
            var _F = _GetProc<GLNativeDelegate.FNglAlphaFragmentOp2ATI>("glAlphaFragmentOp2ATI");
            _F(op, dst, dstMod, arg1, arg1Rep, arg1Mod, arg2, arg2Rep, arg2Mod);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ATI_fragment_shader</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glAlphaFragmentOp3ATI(GLenum op, GLuint dst, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod, GLuint arg3, GLuint arg3Rep, GLuint arg3Mod);</para>
        /// </summary>
        public static void glAlphaFragmentOp3ATI(uint op, uint dst, uint dstMod, uint arg1, uint arg1Rep, uint arg1Mod, uint arg2, uint arg2Rep, uint arg2Mod, uint arg3, uint arg3Rep, uint arg3Mod) {
            var _F = _GetProc<GLNativeDelegate.FNglAlphaFragmentOp3ATI>("glAlphaFragmentOp3ATI");
            _F(op, dst, dstMod, arg1, arg1Rep, arg1Mod, arg2, arg2Rep, arg2Mod, arg3, arg3Rep, arg3Mod);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ATI_fragment_shader</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glSetFragmentShaderConstantATI(GLuint dst, const GLfloat * value);</para>
        /// </summary>
        public unsafe static void glSetFragmentShaderConstantATI(uint dst, float* value) {
            var _F = _GetProc<GLNativeDelegate.FNglSetFragmentShaderConstantATI>("glSetFragmentShaderConstantATI");
            _F(dst, value);
        }

        #endregion GL_ATI_fragment_shader

        #region GL_ATI_map_object_buffer

        /// <summary>
        /// <para>Require:</para> <para>GL_ATI_map_object_buffer</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void * glMapObjectBufferATI(GLuint buffer);</para>
        /// </summary>
        public unsafe static void* glMapObjectBufferATI(uint buffer) {
            var _F = _GetProc<GLNativeDelegate.FNglMapObjectBufferATI>("glMapObjectBufferATI");
            return _F(buffer);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ATI_map_object_buffer</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glUnmapObjectBufferATI(GLuint buffer);</para>
        /// </summary>
        public static void glUnmapObjectBufferATI(uint buffer) {
            var _F = _GetProc<GLNativeDelegate.FNglUnmapObjectBufferATI>("glUnmapObjectBufferATI");
            _F(buffer);
        }

        #endregion GL_ATI_map_object_buffer

        #region GL_ATI_pn_triangles

        /// <summary>
        /// <para>Require:</para> <para>GL_ATI_pn_triangles</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glPNTrianglesiATI(GLenum pname, GLint param);</para>
        /// </summary>
        public static void glPNTrianglesiATI(uint pname, int param) {
            var _F = _GetProc<GLNativeDelegate.FNglPNTrianglesiATI>("glPNTrianglesiATI");
            _F(pname, param);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ATI_pn_triangles</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glPNTrianglesfATI(GLenum pname, GLfloat param);</para>
        /// </summary>
        public static void glPNTrianglesfATI(uint pname, float param) {
            var _F = _GetProc<GLNativeDelegate.FNglPNTrianglesfATI>("glPNTrianglesfATI");
            _F(pname, param);
        }

        #endregion GL_ATI_pn_triangles

        #region GL_ATI_separate_stencil

        /// <summary>
        /// <para>Require:</para> <para>GL_ATI_separate_stencil</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glStencilOpSeparateATI(GLenum face, GLenum sfail, GLenum dpfail, GLenum dppass);</para>
        /// </summary>
        public static void glStencilOpSeparateATI(uint face, uint sfail, uint dpfail, uint dppass) {
            var _F = _GetProc<GLNativeDelegate.FNglStencilOpSeparateATI>("glStencilOpSeparateATI");
            _F(face, sfail, dpfail, dppass);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ATI_separate_stencil</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glStencilFuncSeparateATI(GLenum frontfunc, GLenum backfunc, GLint ref, GLuint mask);</para>
        /// </summary>
        public static void glStencilFuncSeparateATI(uint frontfunc, uint backfunc, int r, uint mask) {
            var _F = _GetProc<GLNativeDelegate.FNglStencilFuncSeparateATI>("glStencilFuncSeparateATI");
            _F(frontfunc, backfunc, r, mask);
        }

        #endregion GL_ATI_separate_stencil

        #region GL_ATI_vertex_array_object

        /// <summary>
        /// <para>Require:</para> <para>GL_ATI_vertex_array_object</para>
        /// Supported: <para>gl</para>
        /// Original: <para>GLuint glNewObjectBufferATI(GLsizei size, const void * pointer, GLenum usage);</para>
        /// </summary>
        public unsafe static uint glNewObjectBufferATI(int size, void* pointer, uint usage) {
            var _F = _GetProc<GLNativeDelegate.FNglNewObjectBufferATI>("glNewObjectBufferATI");
            return _F(size, pointer, usage);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ATI_vertex_array_object</para>
        /// Supported: <para>gl</para>
        /// Original: <para>GLboolean glIsObjectBufferATI(GLuint buffer);</para>
        /// </summary>
        public static bool glIsObjectBufferATI(uint buffer) {
            var _F = _GetProc<GLNativeDelegate.FNglIsObjectBufferATI>("glIsObjectBufferATI");
            return _F(buffer);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ATI_vertex_array_object</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glUpdateObjectBufferATI(GLuint buffer, GLuint offset, GLsizei size, const void * pointer, GLenum preserve);</para>
        /// </summary>
        public unsafe static void glUpdateObjectBufferATI(uint buffer, uint offset, int size, void* pointer, uint preserve) {
            var _F = _GetProc<GLNativeDelegate.FNglUpdateObjectBufferATI>("glUpdateObjectBufferATI");
            _F(buffer, offset, size, pointer, preserve);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ATI_vertex_array_object</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetObjectBufferfvATI(GLuint buffer, GLenum pname, GLfloat * params);</para>
        /// </summary>
        public unsafe static void glGetObjectBufferfvATI(uint buffer, uint pname, float* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetObjectBufferfvATI>("glGetObjectBufferfvATI");
            _F(buffer, pname, ps);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ATI_vertex_array_object</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetObjectBufferivATI(GLuint buffer, GLenum pname, GLint * params);</para>
        /// </summary>
        public unsafe static void glGetObjectBufferivATI(uint buffer, uint pname, int* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetObjectBufferivATI>("glGetObjectBufferivATI");
            _F(buffer, pname, ps);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ATI_vertex_array_object</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glFreeObjectBufferATI(GLuint buffer);</para>
        /// </summary>
        public static void glFreeObjectBufferATI(uint buffer) {
            var _F = _GetProc<GLNativeDelegate.FNglFreeObjectBufferATI>("glFreeObjectBufferATI");
            _F(buffer);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ATI_vertex_array_object</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glArrayObjectATI(GLenum array, GLint size, GLenum type, GLsizei stride, GLuint buffer, GLuint offset);</para>
        /// </summary>
        public static void glArrayObjectATI(uint array, int size, uint type, int stride, uint buffer, uint offset) {
            var _F = _GetProc<GLNativeDelegate.FNglArrayObjectATI>("glArrayObjectATI");
            _F(array, size, type, stride, buffer, offset);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ATI_vertex_array_object</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetArrayObjectfvATI(GLenum array, GLenum pname, GLfloat * params);</para>
        /// </summary>
        public unsafe static void glGetArrayObjectfvATI(uint array, uint pname, float* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetArrayObjectfvATI>("glGetArrayObjectfvATI");
            _F(array, pname, ps);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ATI_vertex_array_object</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetArrayObjectivATI(GLenum array, GLenum pname, GLint * params);</para>
        /// </summary>
        public unsafe static void glGetArrayObjectivATI(uint array, uint pname, int* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetArrayObjectivATI>("glGetArrayObjectivATI");
            _F(array, pname, ps);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ATI_vertex_array_object</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVariantArrayObjectATI(GLuint id, GLenum type, GLsizei stride, GLuint buffer, GLuint offset);</para>
        /// </summary>
        public static void glVariantArrayObjectATI(uint id, uint type, int stride, uint buffer, uint offset) {
            var _F = _GetProc<GLNativeDelegate.FNglVariantArrayObjectATI>("glVariantArrayObjectATI");
            _F(id, type, stride, buffer, offset);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ATI_vertex_array_object</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetVariantArrayObjectfvATI(GLuint id, GLenum pname, GLfloat * params);</para>
        /// </summary>
        public unsafe static void glGetVariantArrayObjectfvATI(uint id, uint pname, float* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetVariantArrayObjectfvATI>("glGetVariantArrayObjectfvATI");
            _F(id, pname, ps);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ATI_vertex_array_object</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetVariantArrayObjectivATI(GLuint id, GLenum pname, GLint * params);</para>
        /// </summary>
        public unsafe static void glGetVariantArrayObjectivATI(uint id, uint pname, int* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetVariantArrayObjectivATI>("glGetVariantArrayObjectivATI");
            _F(id, pname, ps);
        }

        #endregion GL_ATI_vertex_array_object

        #region GL_ATI_vertex_attrib_array_object

        /// <summary>
        /// <para>Require:</para> <para>GL_ATI_vertex_attrib_array_object</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexAttribArrayObjectATI(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, GLuint buffer, GLuint offset);</para>
        /// </summary>
        public static void glVertexAttribArrayObjectATI(uint index, int size, uint type, bool normalized, int stride, uint buffer, uint offset) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttribArrayObjectATI>("glVertexAttribArrayObjectATI");
            _F(index, size, type, normalized, stride, buffer, offset);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ATI_vertex_attrib_array_object</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetVertexAttribArrayObjectfvATI(GLuint index, GLenum pname, GLfloat * params);</para>
        /// </summary>
        public unsafe static void glGetVertexAttribArrayObjectfvATI(uint index, uint pname, float* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetVertexAttribArrayObjectfvATI>("glGetVertexAttribArrayObjectfvATI");
            _F(index, pname, ps);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ATI_vertex_attrib_array_object</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetVertexAttribArrayObjectivATI(GLuint index, GLenum pname, GLint * params);</para>
        /// </summary>
        public unsafe static void glGetVertexAttribArrayObjectivATI(uint index, uint pname, int* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetVertexAttribArrayObjectivATI>("glGetVertexAttribArrayObjectivATI");
            _F(index, pname, ps);
        }

        #endregion GL_ATI_vertex_attrib_array_object

        #region GL_ATI_vertex_streams

        /// <summary>
        /// <para>Require:</para> <para>GL_ATI_vertex_streams</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexStream1sATI(GLenum stream, GLshort x);</para>
        /// </summary>
        public static void glVertexStream1sATI(uint stream, short x) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexStream1sATI>("glVertexStream1sATI");
            _F(stream, x);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ATI_vertex_streams</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexStream1svATI(GLenum stream, const GLshort * coords);</para>
        /// </summary>
        public unsafe static void glVertexStream1svATI(uint stream, short* coords) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexStream1svATI>("glVertexStream1svATI");
            _F(stream, coords);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ATI_vertex_streams</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexStream1iATI(GLenum stream, GLint x);</para>
        /// </summary>
        public static void glVertexStream1iATI(uint stream, int x) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexStream1iATI>("glVertexStream1iATI");
            _F(stream, x);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ATI_vertex_streams</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexStream1ivATI(GLenum stream, const GLint * coords);</para>
        /// </summary>
        public unsafe static void glVertexStream1ivATI(uint stream, int* coords) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexStream1ivATI>("glVertexStream1ivATI");
            _F(stream, coords);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ATI_vertex_streams</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexStream1fATI(GLenum stream, GLfloat x);</para>
        /// </summary>
        public static void glVertexStream1fATI(uint stream, float x) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexStream1fATI>("glVertexStream1fATI");
            _F(stream, x);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ATI_vertex_streams</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexStream1fvATI(GLenum stream, const GLfloat * coords);</para>
        /// </summary>
        public unsafe static void glVertexStream1fvATI(uint stream, float* coords) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexStream1fvATI>("glVertexStream1fvATI");
            _F(stream, coords);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ATI_vertex_streams</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexStream1dATI(GLenum stream, GLdouble x);</para>
        /// </summary>
        public static void glVertexStream1dATI(uint stream, double x) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexStream1dATI>("glVertexStream1dATI");
            _F(stream, x);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ATI_vertex_streams</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexStream1dvATI(GLenum stream, const GLdouble * coords);</para>
        /// </summary>
        public unsafe static void glVertexStream1dvATI(uint stream, double* coords) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexStream1dvATI>("glVertexStream1dvATI");
            _F(stream, coords);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ATI_vertex_streams</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexStream2sATI(GLenum stream, GLshort x, GLshort y);</para>
        /// </summary>
        public static void glVertexStream2sATI(uint stream, short x, short y) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexStream2sATI>("glVertexStream2sATI");
            _F(stream, x, y);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ATI_vertex_streams</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexStream2svATI(GLenum stream, const GLshort * coords);</para>
        /// </summary>
        public unsafe static void glVertexStream2svATI(uint stream, short* coords) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexStream2svATI>("glVertexStream2svATI");
            _F(stream, coords);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ATI_vertex_streams</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexStream2iATI(GLenum stream, GLint x, GLint y);</para>
        /// </summary>
        public static void glVertexStream2iATI(uint stream, int x, int y) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexStream2iATI>("glVertexStream2iATI");
            _F(stream, x, y);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ATI_vertex_streams</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexStream2ivATI(GLenum stream, const GLint * coords);</para>
        /// </summary>
        public unsafe static void glVertexStream2ivATI(uint stream, int* coords) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexStream2ivATI>("glVertexStream2ivATI");
            _F(stream, coords);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ATI_vertex_streams</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexStream2fATI(GLenum stream, GLfloat x, GLfloat y);</para>
        /// </summary>
        public static void glVertexStream2fATI(uint stream, float x, float y) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexStream2fATI>("glVertexStream2fATI");
            _F(stream, x, y);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ATI_vertex_streams</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexStream2fvATI(GLenum stream, const GLfloat * coords);</para>
        /// </summary>
        public unsafe static void glVertexStream2fvATI(uint stream, float* coords) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexStream2fvATI>("glVertexStream2fvATI");
            _F(stream, coords);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ATI_vertex_streams</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexStream2dATI(GLenum stream, GLdouble x, GLdouble y);</para>
        /// </summary>
        public static void glVertexStream2dATI(uint stream, double x, double y) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexStream2dATI>("glVertexStream2dATI");
            _F(stream, x, y);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ATI_vertex_streams</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexStream2dvATI(GLenum stream, const GLdouble * coords);</para>
        /// </summary>
        public unsafe static void glVertexStream2dvATI(uint stream, double* coords) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexStream2dvATI>("glVertexStream2dvATI");
            _F(stream, coords);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ATI_vertex_streams</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexStream3sATI(GLenum stream, GLshort x, GLshort y, GLshort z);</para>
        /// </summary>
        public static void glVertexStream3sATI(uint stream, short x, short y, short z) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexStream3sATI>("glVertexStream3sATI");
            _F(stream, x, y, z);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ATI_vertex_streams</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexStream3svATI(GLenum stream, const GLshort * coords);</para>
        /// </summary>
        public unsafe static void glVertexStream3svATI(uint stream, short* coords) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexStream3svATI>("glVertexStream3svATI");
            _F(stream, coords);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ATI_vertex_streams</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexStream3iATI(GLenum stream, GLint x, GLint y, GLint z);</para>
        /// </summary>
        public static void glVertexStream3iATI(uint stream, int x, int y, int z) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexStream3iATI>("glVertexStream3iATI");
            _F(stream, x, y, z);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ATI_vertex_streams</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexStream3ivATI(GLenum stream, const GLint * coords);</para>
        /// </summary>
        public unsafe static void glVertexStream3ivATI(uint stream, int* coords) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexStream3ivATI>("glVertexStream3ivATI");
            _F(stream, coords);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ATI_vertex_streams</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexStream3fATI(GLenum stream, GLfloat x, GLfloat y, GLfloat z);</para>
        /// </summary>
        public static void glVertexStream3fATI(uint stream, float x, float y, float z) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexStream3fATI>("glVertexStream3fATI");
            _F(stream, x, y, z);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ATI_vertex_streams</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexStream3fvATI(GLenum stream, const GLfloat * coords);</para>
        /// </summary>
        public unsafe static void glVertexStream3fvATI(uint stream, float* coords) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexStream3fvATI>("glVertexStream3fvATI");
            _F(stream, coords);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ATI_vertex_streams</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexStream3dATI(GLenum stream, GLdouble x, GLdouble y, GLdouble z);</para>
        /// </summary>
        public static void glVertexStream3dATI(uint stream, double x, double y, double z) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexStream3dATI>("glVertexStream3dATI");
            _F(stream, x, y, z);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ATI_vertex_streams</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexStream3dvATI(GLenum stream, const GLdouble * coords);</para>
        /// </summary>
        public unsafe static void glVertexStream3dvATI(uint stream, double* coords) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexStream3dvATI>("glVertexStream3dvATI");
            _F(stream, coords);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ATI_vertex_streams</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexStream4sATI(GLenum stream, GLshort x, GLshort y, GLshort z, GLshort w);</para>
        /// </summary>
        public static void glVertexStream4sATI(uint stream, short x, short y, short z, short w) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexStream4sATI>("glVertexStream4sATI");
            _F(stream, x, y, z, w);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ATI_vertex_streams</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexStream4svATI(GLenum stream, const GLshort * coords);</para>
        /// </summary>
        public unsafe static void glVertexStream4svATI(uint stream, short* coords) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexStream4svATI>("glVertexStream4svATI");
            _F(stream, coords);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ATI_vertex_streams</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexStream4iATI(GLenum stream, GLint x, GLint y, GLint z, GLint w);</para>
        /// </summary>
        public static void glVertexStream4iATI(uint stream, int x, int y, int z, int w) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexStream4iATI>("glVertexStream4iATI");
            _F(stream, x, y, z, w);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ATI_vertex_streams</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexStream4ivATI(GLenum stream, const GLint * coords);</para>
        /// </summary>
        public unsafe static void glVertexStream4ivATI(uint stream, int* coords) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexStream4ivATI>("glVertexStream4ivATI");
            _F(stream, coords);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ATI_vertex_streams</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexStream4fATI(GLenum stream, GLfloat x, GLfloat y, GLfloat z, GLfloat w);</para>
        /// </summary>
        public static void glVertexStream4fATI(uint stream, float x, float y, float z, float w) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexStream4fATI>("glVertexStream4fATI");
            _F(stream, x, y, z, w);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ATI_vertex_streams</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexStream4fvATI(GLenum stream, const GLfloat * coords);</para>
        /// </summary>
        public unsafe static void glVertexStream4fvATI(uint stream, float* coords) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexStream4fvATI>("glVertexStream4fvATI");
            _F(stream, coords);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ATI_vertex_streams</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexStream4dATI(GLenum stream, GLdouble x, GLdouble y, GLdouble z, GLdouble w);</para>
        /// </summary>
        public static void glVertexStream4dATI(uint stream, double x, double y, double z, double w) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexStream4dATI>("glVertexStream4dATI");
            _F(stream, x, y, z, w);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ATI_vertex_streams</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexStream4dvATI(GLenum stream, const GLdouble * coords);</para>
        /// </summary>
        public unsafe static void glVertexStream4dvATI(uint stream, double* coords) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexStream4dvATI>("glVertexStream4dvATI");
            _F(stream, coords);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ATI_vertex_streams</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glNormalStream3bATI(GLenum stream, GLbyte nx, GLbyte ny, GLbyte nz);</para>
        /// </summary>
        public static void glNormalStream3bATI(uint stream, byte nx, byte ny, byte nz) {
            var _F = _GetProc<GLNativeDelegate.FNglNormalStream3bATI>("glNormalStream3bATI");
            _F(stream, nx, ny, nz);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ATI_vertex_streams</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glNormalStream3bvATI(GLenum stream, const GLbyte * coords);</para>
        /// </summary>
        public unsafe static void glNormalStream3bvATI(uint stream, byte* coords) {
            var _F = _GetProc<GLNativeDelegate.FNglNormalStream3bvATI>("glNormalStream3bvATI");
            _F(stream, coords);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ATI_vertex_streams</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glNormalStream3sATI(GLenum stream, GLshort nx, GLshort ny, GLshort nz);</para>
        /// </summary>
        public static void glNormalStream3sATI(uint stream, short nx, short ny, short nz) {
            var _F = _GetProc<GLNativeDelegate.FNglNormalStream3sATI>("glNormalStream3sATI");
            _F(stream, nx, ny, nz);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ATI_vertex_streams</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glNormalStream3svATI(GLenum stream, const GLshort * coords);</para>
        /// </summary>
        public unsafe static void glNormalStream3svATI(uint stream, short* coords) {
            var _F = _GetProc<GLNativeDelegate.FNglNormalStream3svATI>("glNormalStream3svATI");
            _F(stream, coords);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ATI_vertex_streams</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glNormalStream3iATI(GLenum stream, GLint nx, GLint ny, GLint nz);</para>
        /// </summary>
        public static void glNormalStream3iATI(uint stream, int nx, int ny, int nz) {
            var _F = _GetProc<GLNativeDelegate.FNglNormalStream3iATI>("glNormalStream3iATI");
            _F(stream, nx, ny, nz);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ATI_vertex_streams</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glNormalStream3ivATI(GLenum stream, const GLint * coords);</para>
        /// </summary>
        public unsafe static void glNormalStream3ivATI(uint stream, int* coords) {
            var _F = _GetProc<GLNativeDelegate.FNglNormalStream3ivATI>("glNormalStream3ivATI");
            _F(stream, coords);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ATI_vertex_streams</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glNormalStream3fATI(GLenum stream, GLfloat nx, GLfloat ny, GLfloat nz);</para>
        /// </summary>
        public static void glNormalStream3fATI(uint stream, float nx, float ny, float nz) {
            var _F = _GetProc<GLNativeDelegate.FNglNormalStream3fATI>("glNormalStream3fATI");
            _F(stream, nx, ny, nz);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ATI_vertex_streams</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glNormalStream3fvATI(GLenum stream, const GLfloat * coords);</para>
        /// </summary>
        public unsafe static void glNormalStream3fvATI(uint stream, float* coords) {
            var _F = _GetProc<GLNativeDelegate.FNglNormalStream3fvATI>("glNormalStream3fvATI");
            _F(stream, coords);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ATI_vertex_streams</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glNormalStream3dATI(GLenum stream, GLdouble nx, GLdouble ny, GLdouble nz);</para>
        /// </summary>
        public static void glNormalStream3dATI(uint stream, double nx, double ny, double nz) {
            var _F = _GetProc<GLNativeDelegate.FNglNormalStream3dATI>("glNormalStream3dATI");
            _F(stream, nx, ny, nz);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ATI_vertex_streams</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glNormalStream3dvATI(GLenum stream, const GLdouble * coords);</para>
        /// </summary>
        public unsafe static void glNormalStream3dvATI(uint stream, double* coords) {
            var _F = _GetProc<GLNativeDelegate.FNglNormalStream3dvATI>("glNormalStream3dvATI");
            _F(stream, coords);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ATI_vertex_streams</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glClientActiveVertexStreamATI(GLenum stream);</para>
        /// </summary>
        public static void glClientActiveVertexStreamATI(uint stream) {
            var _F = _GetProc<GLNativeDelegate.FNglClientActiveVertexStreamATI>("glClientActiveVertexStreamATI");
            _F(stream);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ATI_vertex_streams</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexBlendEnviATI(GLenum pname, GLint param);</para>
        /// </summary>
        public static void glVertexBlendEnviATI(uint pname, int param) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexBlendEnviATI>("glVertexBlendEnviATI");
            _F(pname, param);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_ATI_vertex_streams</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexBlendEnvfATI(GLenum pname, GLfloat param);</para>
        /// </summary>
        public static void glVertexBlendEnvfATI(uint pname, float param) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexBlendEnvfATI>("glVertexBlendEnvfATI");
            _F(pname, param);
        }

        #endregion GL_ATI_vertex_streams

        #region GL_EXT_EGL_image_storage

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_EGL_image_storage</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glEGLImageTargetTexStorageEXT(GLenum target, GLeglImageOES image, const GLint* attrib_list);</para>
        /// </summary>
        public unsafe static void glEGLImageTargetTexStorageEXT(uint target, IntPtr image, int* attrib_list) {
            var _F = _GetProc<GLNativeDelegate.FNglEGLImageTargetTexStorageEXT>("glEGLImageTargetTexStorageEXT");
            _F(target, image, attrib_list);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_EGL_image_storage</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glEGLImageTargetTextureStorageEXT(GLuint texture, GLeglImageOES image, const GLint* attrib_list);</para>
        /// </summary>
        public unsafe static void glEGLImageTargetTextureStorageEXT(uint texture, IntPtr image, int* attrib_list) {
            var _F = _GetProc<GLNativeDelegate.FNglEGLImageTargetTextureStorageEXT>("glEGLImageTargetTextureStorageEXT");
            _F(texture, image, attrib_list);
        }

        #endregion GL_EXT_EGL_image_storage

        #region GL_EXT_bindable_uniform

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_bindable_uniform</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glUniformBufferEXT(GLuint program, GLint location, GLuint buffer);</para>
        /// </summary>
        public static void glUniformBufferEXT(uint program, int location, uint buffer) {
            var _F = _GetProc<GLNativeDelegate.FNglUniformBufferEXT>("glUniformBufferEXT");
            _F(program, location, buffer);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_bindable_uniform</para>
        /// Supported: <para>gl</para>
        /// Original: <para>GLint glGetUniformBufferSizeEXT(GLuint program, GLint location);</para>
        /// </summary>
        public static int glGetUniformBufferSizeEXT(uint program, int location) {
            var _F = _GetProc<GLNativeDelegate.FNglGetUniformBufferSizeEXT>("glGetUniformBufferSizeEXT");
            return _F(program, location);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_bindable_uniform</para>
        /// Supported: <para>gl</para>
        /// Original: <para>GLintptr glGetUniformOffsetEXT(GLuint program, GLint location);</para>
        /// </summary>
        public static IntPtr glGetUniformOffsetEXT(uint program, int location) {
            var _F = _GetProc<GLNativeDelegate.FNglGetUniformOffsetEXT>("glGetUniformOffsetEXT");
            return _F(program, location);
        }

        #endregion GL_EXT_bindable_uniform

        #region GL_EXT_blend_color

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_blend_color</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glBlendColorEXT(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha);</para>
        /// </summary>
        public static void glBlendColorEXT(float red, float green, float blue, float alpha) {
            var _F = _GetProc<GLNativeDelegate.FNglBlendColorEXT>("glBlendColorEXT");
            _F(red, green, blue, alpha);
        }

        #endregion GL_EXT_blend_color

        #region GL_EXT_blend_equation_separate

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_blend_equation_separate</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glBlendEquationSeparateEXT(GLenum modeRGB, GLenum modeAlpha);</para>
        /// </summary>
        public static void glBlendEquationSeparateEXT(uint modeRGB, uint modeAlpha) {
            var _F = _GetProc<GLNativeDelegate.FNglBlendEquationSeparateEXT>("glBlendEquationSeparateEXT");
            _F(modeRGB, modeAlpha);
        }

        #endregion GL_EXT_blend_equation_separate

        #region GL_EXT_blend_func_separate

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_blend_func_separate</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glBlendFuncSeparateEXT(GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha);</para>
        /// </summary>
        public static void glBlendFuncSeparateEXT(uint sfactorRGB, uint dfactorRGB, uint sfactorAlpha, uint dfactorAlpha) {
            var _F = _GetProc<GLNativeDelegate.FNglBlendFuncSeparateEXT>("glBlendFuncSeparateEXT");
            _F(sfactorRGB, dfactorRGB, sfactorAlpha, dfactorAlpha);
        }

        #endregion GL_EXT_blend_func_separate

        #region GL_EXT_color_subtable

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_color_subtable</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glColorSubTableEXT(GLenum target, GLsizei start, GLsizei count, GLenum format, GLenum type, const void * data);</para>
        /// </summary>
        public unsafe static void glColorSubTableEXT(uint target, int start, int count, uint format, uint type, void* data) {
            var _F = _GetProc<GLNativeDelegate.FNglColorSubTableEXT>("glColorSubTableEXT");
            _F(target, start, count, format, type, data);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_color_subtable</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glCopyColorSubTableEXT(GLenum target, GLsizei start, GLint x, GLint y, GLsizei width);</para>
        /// </summary>
        public static void glCopyColorSubTableEXT(uint target, int start, int x, int y, int width) {
            var _F = _GetProc<GLNativeDelegate.FNglCopyColorSubTableEXT>("glCopyColorSubTableEXT");
            _F(target, start, x, y, width);
        }

        #endregion GL_EXT_color_subtable

        #region GL_EXT_compiled_vertex_array

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_compiled_vertex_array</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glLockArraysEXT(GLint first, GLsizei count);</para>
        /// </summary>
        public static void glLockArraysEXT(int first, int count) {
            var _F = _GetProc<GLNativeDelegate.FNglLockArraysEXT>("glLockArraysEXT");
            _F(first, count);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_compiled_vertex_array</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glUnlockArraysEXT();</para>
        /// </summary>
        public static void glUnlockArraysEXT() {
            var _F = _GetProc<GLNativeDelegate.FNglUnlockArraysEXT>("glUnlockArraysEXT");
            _F();
        }

        #endregion GL_EXT_compiled_vertex_array

        #region GL_EXT_convolution

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_convolution</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glConvolutionFilter1DEXT(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const void * image);</para>
        /// </summary>
        public unsafe static void glConvolutionFilter1DEXT(uint target, uint internalformat, int width, uint format, uint type, void* image) {
            var _F = _GetProc<GLNativeDelegate.FNglConvolutionFilter1DEXT>("glConvolutionFilter1DEXT");
            _F(target, internalformat, width, format, type, image);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_convolution</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glConvolutionFilter2DEXT(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const void * image);</para>
        /// </summary>
        public unsafe static void glConvolutionFilter2DEXT(uint target, uint internalformat, int width, int height, uint format, uint type, void* image) {
            var _F = _GetProc<GLNativeDelegate.FNglConvolutionFilter2DEXT>("glConvolutionFilter2DEXT");
            _F(target, internalformat, width, height, format, type, image);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_convolution</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glConvolutionParameterfEXT(GLenum target, GLenum pname, GLfloat params);</para>
        /// </summary>
        public static void glConvolutionParameterfEXT(uint target, uint pname, float ps) {
            var _F = _GetProc<GLNativeDelegate.FNglConvolutionParameterfEXT>("glConvolutionParameterfEXT");
            _F(target, pname, ps);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_convolution</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glConvolutionParameterfvEXT(GLenum target, GLenum pname, const GLfloat * params);</para>
        /// </summary>
        public unsafe static void glConvolutionParameterfvEXT(uint target, uint pname, float* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglConvolutionParameterfvEXT>("glConvolutionParameterfvEXT");
            _F(target, pname, ps);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_convolution</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glConvolutionParameteriEXT(GLenum target, GLenum pname, GLint params);</para>
        /// </summary>
        public static void glConvolutionParameteriEXT(uint target, uint pname, int ps) {
            var _F = _GetProc<GLNativeDelegate.FNglConvolutionParameteriEXT>("glConvolutionParameteriEXT");
            _F(target, pname, ps);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_convolution</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glConvolutionParameterivEXT(GLenum target, GLenum pname, const GLint * params);</para>
        /// </summary>
        public unsafe static void glConvolutionParameterivEXT(uint target, uint pname, int* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglConvolutionParameterivEXT>("glConvolutionParameterivEXT");
            _F(target, pname, ps);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_convolution</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glCopyConvolutionFilter1DEXT(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width);</para>
        /// </summary>
        public static void glCopyConvolutionFilter1DEXT(uint target, uint internalformat, int x, int y, int width) {
            var _F = _GetProc<GLNativeDelegate.FNglCopyConvolutionFilter1DEXT>("glCopyConvolutionFilter1DEXT");
            _F(target, internalformat, x, y, width);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_convolution</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glCopyConvolutionFilter2DEXT(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height);</para>
        /// </summary>
        public static void glCopyConvolutionFilter2DEXT(uint target, uint internalformat, int x, int y, int width, int height) {
            var _F = _GetProc<GLNativeDelegate.FNglCopyConvolutionFilter2DEXT>("glCopyConvolutionFilter2DEXT");
            _F(target, internalformat, x, y, width, height);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_convolution</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetConvolutionFilterEXT(GLenum target, GLenum format, GLenum type, void * image);</para>
        /// </summary>
        public unsafe static void glGetConvolutionFilterEXT(uint target, uint format, uint type, void* image) {
            var _F = _GetProc<GLNativeDelegate.FNglGetConvolutionFilterEXT>("glGetConvolutionFilterEXT");
            _F(target, format, type, image);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_convolution</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetConvolutionParameterfvEXT(GLenum target, GLenum pname, GLfloat * params);</para>
        /// </summary>
        public unsafe static void glGetConvolutionParameterfvEXT(uint target, uint pname, float* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetConvolutionParameterfvEXT>("glGetConvolutionParameterfvEXT");
            _F(target, pname, ps);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_convolution</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetConvolutionParameterivEXT(GLenum target, GLenum pname, GLint * params);</para>
        /// </summary>
        public unsafe static void glGetConvolutionParameterivEXT(uint target, uint pname, int* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetConvolutionParameterivEXT>("glGetConvolutionParameterivEXT");
            _F(target, pname, ps);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_convolution</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetSeparableFilterEXT(GLenum target, GLenum format, GLenum type, void * row, void * column, void * span);</para>
        /// </summary>
        public unsafe static void glGetSeparableFilterEXT(uint target, uint format, uint type, void* row, void* column, void* span) {
            var _F = _GetProc<GLNativeDelegate.FNglGetSeparableFilterEXT>("glGetSeparableFilterEXT");
            _F(target, format, type, row, column, span);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_convolution</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glSeparableFilter2DEXT(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const void * row, const void * column);</para>
        /// </summary>
        public unsafe static void glSeparableFilter2DEXT(uint target, uint internalformat, int width, int height, uint format, uint type, void* row, void* column) {
            var _F = _GetProc<GLNativeDelegate.FNglSeparableFilter2DEXT>("glSeparableFilter2DEXT");
            _F(target, internalformat, width, height, format, type, row, column);
        }

        #endregion GL_EXT_convolution

        #region GL_EXT_coordinate_frame

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_coordinate_frame</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glTangent3bEXT(GLbyte tx, GLbyte ty, GLbyte tz);</para>
        /// </summary>
        public static void glTangent3bEXT(byte tx, byte ty, byte tz) {
            var _F = _GetProc<GLNativeDelegate.FNglTangent3bEXT>("glTangent3bEXT");
            _F(tx, ty, tz);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_coordinate_frame</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glTangent3bvEXT(const GLbyte * v);</para>
        /// </summary>
        public unsafe static void glTangent3bvEXT(byte* v) {
            var _F = _GetProc<GLNativeDelegate.FNglTangent3bvEXT>("glTangent3bvEXT");
            _F(v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_coordinate_frame</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glTangent3dEXT(GLdouble tx, GLdouble ty, GLdouble tz);</para>
        /// </summary>
        public static void glTangent3dEXT(double tx, double ty, double tz) {
            var _F = _GetProc<GLNativeDelegate.FNglTangent3dEXT>("glTangent3dEXT");
            _F(tx, ty, tz);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_coordinate_frame</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glTangent3dvEXT(const GLdouble * v);</para>
        /// </summary>
        public unsafe static void glTangent3dvEXT(double* v) {
            var _F = _GetProc<GLNativeDelegate.FNglTangent3dvEXT>("glTangent3dvEXT");
            _F(v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_coordinate_frame</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glTangent3fEXT(GLfloat tx, GLfloat ty, GLfloat tz);</para>
        /// </summary>
        public static void glTangent3fEXT(float tx, float ty, float tz) {
            var _F = _GetProc<GLNativeDelegate.FNglTangent3fEXT>("glTangent3fEXT");
            _F(tx, ty, tz);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_coordinate_frame</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glTangent3fvEXT(const GLfloat * v);</para>
        /// </summary>
        public unsafe static void glTangent3fvEXT(float* v) {
            var _F = _GetProc<GLNativeDelegate.FNglTangent3fvEXT>("glTangent3fvEXT");
            _F(v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_coordinate_frame</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glTangent3iEXT(GLint tx, GLint ty, GLint tz);</para>
        /// </summary>
        public static void glTangent3iEXT(int tx, int ty, int tz) {
            var _F = _GetProc<GLNativeDelegate.FNglTangent3iEXT>("glTangent3iEXT");
            _F(tx, ty, tz);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_coordinate_frame</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glTangent3ivEXT(const GLint * v);</para>
        /// </summary>
        public unsafe static void glTangent3ivEXT(int* v) {
            var _F = _GetProc<GLNativeDelegate.FNglTangent3ivEXT>("glTangent3ivEXT");
            _F(v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_coordinate_frame</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glTangent3sEXT(GLshort tx, GLshort ty, GLshort tz);</para>
        /// </summary>
        public static void glTangent3sEXT(short tx, short ty, short tz) {
            var _F = _GetProc<GLNativeDelegate.FNglTangent3sEXT>("glTangent3sEXT");
            _F(tx, ty, tz);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_coordinate_frame</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glTangent3svEXT(const GLshort * v);</para>
        /// </summary>
        public unsafe static void glTangent3svEXT(short* v) {
            var _F = _GetProc<GLNativeDelegate.FNglTangent3svEXT>("glTangent3svEXT");
            _F(v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_coordinate_frame</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glBinormal3bEXT(GLbyte bx, GLbyte by, GLbyte bz);</para>
        /// </summary>
        public static void glBinormal3bEXT(byte bx, byte by, byte bz) {
            var _F = _GetProc<GLNativeDelegate.FNglBinormal3bEXT>("glBinormal3bEXT");
            _F(bx, by, bz);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_coordinate_frame</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glBinormal3bvEXT(const GLbyte * v);</para>
        /// </summary>
        public unsafe static void glBinormal3bvEXT(byte* v) {
            var _F = _GetProc<GLNativeDelegate.FNglBinormal3bvEXT>("glBinormal3bvEXT");
            _F(v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_coordinate_frame</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glBinormal3dEXT(GLdouble bx, GLdouble by, GLdouble bz);</para>
        /// </summary>
        public static void glBinormal3dEXT(double bx, double by, double bz) {
            var _F = _GetProc<GLNativeDelegate.FNglBinormal3dEXT>("glBinormal3dEXT");
            _F(bx, by, bz);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_coordinate_frame</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glBinormal3dvEXT(const GLdouble * v);</para>
        /// </summary>
        public unsafe static void glBinormal3dvEXT(double* v) {
            var _F = _GetProc<GLNativeDelegate.FNglBinormal3dvEXT>("glBinormal3dvEXT");
            _F(v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_coordinate_frame</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glBinormal3fEXT(GLfloat bx, GLfloat by, GLfloat bz);</para>
        /// </summary>
        public static void glBinormal3fEXT(float bx, float by, float bz) {
            var _F = _GetProc<GLNativeDelegate.FNglBinormal3fEXT>("glBinormal3fEXT");
            _F(bx, by, bz);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_coordinate_frame</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glBinormal3fvEXT(const GLfloat * v);</para>
        /// </summary>
        public unsafe static void glBinormal3fvEXT(float* v) {
            var _F = _GetProc<GLNativeDelegate.FNglBinormal3fvEXT>("glBinormal3fvEXT");
            _F(v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_coordinate_frame</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glBinormal3iEXT(GLint bx, GLint by, GLint bz);</para>
        /// </summary>
        public static void glBinormal3iEXT(int bx, int by, int bz) {
            var _F = _GetProc<GLNativeDelegate.FNglBinormal3iEXT>("glBinormal3iEXT");
            _F(bx, by, bz);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_coordinate_frame</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glBinormal3ivEXT(const GLint * v);</para>
        /// </summary>
        public unsafe static void glBinormal3ivEXT(int* v) {
            var _F = _GetProc<GLNativeDelegate.FNglBinormal3ivEXT>("glBinormal3ivEXT");
            _F(v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_coordinate_frame</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glBinormal3sEXT(GLshort bx, GLshort by, GLshort bz);</para>
        /// </summary>
        public static void glBinormal3sEXT(short bx, short by, short bz) {
            var _F = _GetProc<GLNativeDelegate.FNglBinormal3sEXT>("glBinormal3sEXT");
            _F(bx, by, bz);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_coordinate_frame</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glBinormal3svEXT(const GLshort * v);</para>
        /// </summary>
        public unsafe static void glBinormal3svEXT(short* v) {
            var _F = _GetProc<GLNativeDelegate.FNglBinormal3svEXT>("glBinormal3svEXT");
            _F(v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_coordinate_frame</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glTangentPointerEXT(GLenum type, GLsizei stride, const void * pointer);</para>
        /// </summary>
        public unsafe static void glTangentPointerEXT(uint type, int stride, void* pointer) {
            var _F = _GetProc<GLNativeDelegate.FNglTangentPointerEXT>("glTangentPointerEXT");
            _F(type, stride, pointer);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_coordinate_frame</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glBinormalPointerEXT(GLenum type, GLsizei stride, const void * pointer);</para>
        /// </summary>
        public unsafe static void glBinormalPointerEXT(uint type, int stride, void* pointer) {
            var _F = _GetProc<GLNativeDelegate.FNglBinormalPointerEXT>("glBinormalPointerEXT");
            _F(type, stride, pointer);
        }

        #endregion GL_EXT_coordinate_frame

        #region GL_EXT_copy_texture

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_copy_texture</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glCopyTexImage1DEXT(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border);</para>
        /// </summary>
        public static void glCopyTexImage1DEXT(uint target, int level, uint internalformat, int x, int y, int width, int border) {
            var _F = _GetProc<GLNativeDelegate.FNglCopyTexImage1DEXT>("glCopyTexImage1DEXT");
            _F(target, level, internalformat, x, y, width, border);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_copy_texture</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glCopyTexImage2DEXT(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border);</para>
        /// </summary>
        public static void glCopyTexImage2DEXT(uint target, int level, uint internalformat, int x, int y, int width, int height, int border) {
            var _F = _GetProc<GLNativeDelegate.FNglCopyTexImage2DEXT>("glCopyTexImage2DEXT");
            _F(target, level, internalformat, x, y, width, height, border);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_copy_texture</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glCopyTexSubImage1DEXT(GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width);</para>
        /// </summary>
        public static void glCopyTexSubImage1DEXT(uint target, int level, int xoffset, int x, int y, int width) {
            var _F = _GetProc<GLNativeDelegate.FNglCopyTexSubImage1DEXT>("glCopyTexSubImage1DEXT");
            _F(target, level, xoffset, x, y, width);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_copy_texture</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glCopyTexSubImage2DEXT(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height);</para>
        /// </summary>
        public static void glCopyTexSubImage2DEXT(uint target, int level, int xoffset, int yoffset, int x, int y, int width, int height) {
            var _F = _GetProc<GLNativeDelegate.FNglCopyTexSubImage2DEXT>("glCopyTexSubImage2DEXT");
            _F(target, level, xoffset, yoffset, x, y, width, height);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_copy_texture</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glCopyTexSubImage3DEXT(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height);</para>
        /// </summary>
        public static void glCopyTexSubImage3DEXT(uint target, int level, int xoffset, int yoffset, int zoffset, int x, int y, int width, int height) {
            var _F = _GetProc<GLNativeDelegate.FNglCopyTexSubImage3DEXT>("glCopyTexSubImage3DEXT");
            _F(target, level, xoffset, yoffset, zoffset, x, y, width, height);
        }

        #endregion GL_EXT_copy_texture

        #region GL_EXT_cull_vertex

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_cull_vertex</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glCullParameterdvEXT(GLenum pname, GLdouble * params);</para>
        /// </summary>
        public unsafe static void glCullParameterdvEXT(uint pname, double* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglCullParameterdvEXT>("glCullParameterdvEXT");
            _F(pname, ps);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_cull_vertex</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glCullParameterfvEXT(GLenum pname, GLfloat * params);</para>
        /// </summary>
        public unsafe static void glCullParameterfvEXT(uint pname, float* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglCullParameterfvEXT>("glCullParameterfvEXT");
            _F(pname, ps);
        }

        #endregion GL_EXT_cull_vertex

        #region GL_EXT_debug_label

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_debug_label</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glLabelObjectEXT(GLenum type, GLuint object, GLsizei length, const GLchar * label);</para>
        /// </summary>
        public unsafe static void glLabelObjectEXT(uint type, uint obj, int length, byte* label) {
            var _F = _GetProc<GLNativeDelegate.FNglLabelObjectEXT>("glLabelObjectEXT");
            _F(type, obj, length, label);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_debug_label</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glGetObjectLabelEXT(GLenum type, GLuint object, GLsizei bufSize, GLsizei * length, GLchar * label);</para>
        /// </summary>
        public unsafe static void glGetObjectLabelEXT(uint type, uint obj, int bufSize, int* length, byte* label) {
            var _F = _GetProc<GLNativeDelegate.FNglGetObjectLabelEXT>("glGetObjectLabelEXT");
            _F(type, obj, bufSize, length, label);
        }

        #endregion GL_EXT_debug_label

        #region GL_EXT_debug_marker

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_debug_marker</para>
        /// Supported: <para>gl, glcore, gles1, gles2</para>
        /// Original: <para>void glInsertEventMarkerEXT(GLsizei length, const GLchar * marker);</para>
        /// </summary>
        public unsafe static void glInsertEventMarkerEXT(int length, byte* marker) {
            var _F = _GetProc<GLNativeDelegate.FNglInsertEventMarkerEXT>("glInsertEventMarkerEXT");
            _F(length, marker);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_debug_marker</para>
        /// Supported: <para>gl, glcore, gles1, gles2</para>
        /// Original: <para>void glPushGroupMarkerEXT(GLsizei length, const GLchar * marker);</para>
        /// </summary>
        public unsafe static void glPushGroupMarkerEXT(int length, byte* marker) {
            var _F = _GetProc<GLNativeDelegate.FNglPushGroupMarkerEXT>("glPushGroupMarkerEXT");
            _F(length, marker);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_debug_marker</para>
        /// Supported: <para>gl, glcore, gles1, gles2</para>
        /// Original: <para>void glPopGroupMarkerEXT();</para>
        /// </summary>
        public static void glPopGroupMarkerEXT() {
            var _F = _GetProc<GLNativeDelegate.FNglPopGroupMarkerEXT>("glPopGroupMarkerEXT");
            _F();
        }

        #endregion GL_EXT_debug_marker

        #region GL_EXT_depth_bounds_test

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_depth_bounds_test</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glDepthBoundsEXT(GLclampd zmin, GLclampd zmax);</para>
        /// </summary>
        public static void glDepthBoundsEXT(double zmin, double zmax) {
            var _F = _GetProc<GLNativeDelegate.FNglDepthBoundsEXT>("glDepthBoundsEXT");
            _F(zmin, zmax);
        }

        #endregion GL_EXT_depth_bounds_test

        #region GL_EXT_draw_buffers2

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_draw_buffers2</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glColorMaskIndexedEXT(GLuint index, GLboolean r, GLboolean g, GLboolean b, GLboolean a);</para>
        /// </summary>
        public static void glColorMaskIndexedEXT(uint index, bool r, bool g, bool b, bool a) {
            var _F = _GetProc<GLNativeDelegate.FNglColorMaskIndexedEXT>("glColorMaskIndexedEXT");
            _F(index, r, g, b, a);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_direct_state_access, GL_EXT_draw_buffers2</para>
        /// Supported: <para>gl, glcore, gl</para>
        /// Original: <para>void glGetBooleanIndexedvEXT(GLenum target, GLuint index, GLboolean * data);</para>
        /// </summary>
        public unsafe static void glGetBooleanIndexedvEXT(uint target, uint index, bool* data) {
            var _F = _GetProc<GLNativeDelegate.FNglGetBooleanIndexedvEXT>("glGetBooleanIndexedvEXT");
            _F(target, index, data);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_direct_state_access, GL_EXT_draw_buffers2</para>
        /// Supported: <para>gl, glcore, gl</para>
        /// Original: <para>void glGetIntegerIndexedvEXT(GLenum target, GLuint index, GLint * data);</para>
        /// </summary>
        public unsafe static void glGetIntegerIndexedvEXT(uint target, uint index, int* data) {
            var _F = _GetProc<GLNativeDelegate.FNglGetIntegerIndexedvEXT>("glGetIntegerIndexedvEXT");
            _F(target, index, data);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_direct_state_access, GL_EXT_draw_buffers2</para>
        /// Supported: <para>gl, glcore, gl</para>
        /// Original: <para>void glEnableIndexedEXT(GLenum target, GLuint index);</para>
        /// </summary>
        public static void glEnableIndexedEXT(uint target, uint index) {
            var _F = _GetProc<GLNativeDelegate.FNglEnableIndexedEXT>("glEnableIndexedEXT");
            _F(target, index);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_direct_state_access, GL_EXT_draw_buffers2</para>
        /// Supported: <para>gl, glcore, gl</para>
        /// Original: <para>void glDisableIndexedEXT(GLenum target, GLuint index);</para>
        /// </summary>
        public static void glDisableIndexedEXT(uint target, uint index) {
            var _F = _GetProc<GLNativeDelegate.FNglDisableIndexedEXT>("glDisableIndexedEXT");
            _F(target, index);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_direct_state_access, GL_EXT_draw_buffers2</para>
        /// Supported: <para>gl, glcore, gl</para>
        /// Original: <para>GLboolean glIsEnabledIndexedEXT(GLenum target, GLuint index);</para>
        /// </summary>
        public static bool glIsEnabledIndexedEXT(uint target, uint index) {
            var _F = _GetProc<GLNativeDelegate.FNglIsEnabledIndexedEXT>("glIsEnabledIndexedEXT");
            return _F(target, index);
        }

        #endregion GL_EXT_draw_buffers2

        #region GL_EXT_draw_instanced

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_draw_instanced, GL_EXT_instanced_arrays</para>
        /// Supported: <para>gl, glcore, gles2, gles2</para>
        /// Original: <para>void glDrawArraysInstancedEXT(GLenum mode, GLint start, GLsizei count, GLsizei primcount);</para>
        /// </summary>
        public static void glDrawArraysInstancedEXT(uint mode, int start, int count, int primcount) {
            var _F = _GetProc<GLNativeDelegate.FNglDrawArraysInstancedEXT>("glDrawArraysInstancedEXT");
            _F(mode, start, count, primcount);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_draw_instanced, GL_EXT_instanced_arrays</para>
        /// Supported: <para>gl, glcore, gles2, gles2</para>
        /// Original: <para>void glDrawElementsInstancedEXT(GLenum mode, GLsizei count, GLenum type, const void * indices, GLsizei primcount);</para>
        /// </summary>
        public unsafe static void glDrawElementsInstancedEXT(uint mode, int count, uint type, void* indices, int primcount) {
            var _F = _GetProc<GLNativeDelegate.FNglDrawElementsInstancedEXT>("glDrawElementsInstancedEXT");
            _F(mode, count, type, indices, primcount);
        }

        #endregion GL_EXT_draw_instanced

        #region GL_EXT_draw_range_elements

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_draw_range_elements</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glDrawRangeElementsEXT(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const void * indices);</para>
        /// </summary>
        public unsafe static void glDrawRangeElementsEXT(uint mode, uint start, uint end, int count, uint type, void* indices) {
            var _F = _GetProc<GLNativeDelegate.FNglDrawRangeElementsEXT>("glDrawRangeElementsEXT");
            _F(mode, start, end, count, type, indices);
        }

        #endregion GL_EXT_draw_range_elements

        #region GL_EXT_external_buffer

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_external_buffer</para>
        /// Supported: <para>gl, gles2</para>
        /// Original: <para>void glBufferStorageExternalEXT(GLenum target, GLintptr offset, GLsizeiptr size, GLeglClientBufferEXT clientBuffer, GLbitfield flags);</para>
        /// </summary>
        public static void glBufferStorageExternalEXT(uint target, IntPtr offset, IntPtr size, IntPtr clientBuffer, uint flags) {
            var _F = _GetProc<GLNativeDelegate.FNglBufferStorageExternalEXT>("glBufferStorageExternalEXT");
            _F(target, offset, size, clientBuffer, flags);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_external_buffer</para>
        /// Supported: <para>gl, gles2</para>
        /// Original: <para>void glNamedBufferStorageExternalEXT(GLuint buffer, GLintptr offset, GLsizeiptr size, GLeglClientBufferEXT clientBuffer, GLbitfield flags);</para>
        /// </summary>
        public static void glNamedBufferStorageExternalEXT(uint buffer, IntPtr offset, IntPtr size, IntPtr clientBuffer, uint flags) {
            var _F = _GetProc<GLNativeDelegate.FNglNamedBufferStorageExternalEXT>("glNamedBufferStorageExternalEXT");
            _F(buffer, offset, size, clientBuffer, flags);
        }

        #endregion GL_EXT_external_buffer

        #region GL_EXT_fog_coord

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_fog_coord</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glFogCoordfEXT(GLfloat coord);</para>
        /// </summary>
        public static void glFogCoordfEXT(float coord) {
            var _F = _GetProc<GLNativeDelegate.FNglFogCoordfEXT>("glFogCoordfEXT");
            _F(coord);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_fog_coord</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glFogCoordfvEXT(const GLfloat * coord);</para>
        /// </summary>
        public unsafe static void glFogCoordfvEXT(float* coord) {
            var _F = _GetProc<GLNativeDelegate.FNglFogCoordfvEXT>("glFogCoordfvEXT");
            _F(coord);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_fog_coord</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glFogCoorddEXT(GLdouble coord);</para>
        /// </summary>
        public static void glFogCoorddEXT(double coord) {
            var _F = _GetProc<GLNativeDelegate.FNglFogCoorddEXT>("glFogCoorddEXT");
            _F(coord);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_fog_coord</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glFogCoorddvEXT(const GLdouble * coord);</para>
        /// </summary>
        public unsafe static void glFogCoorddvEXT(double* coord) {
            var _F = _GetProc<GLNativeDelegate.FNglFogCoorddvEXT>("glFogCoorddvEXT");
            _F(coord);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_fog_coord</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glFogCoordPointerEXT(GLenum type, GLsizei stride, const void * pointer);</para>
        /// </summary>
        public unsafe static void glFogCoordPointerEXT(uint type, int stride, void* pointer) {
            var _F = _GetProc<GLNativeDelegate.FNglFogCoordPointerEXT>("glFogCoordPointerEXT");
            _F(type, stride, pointer);
        }

        #endregion GL_EXT_fog_coord

        #region GL_EXT_framebuffer_blit

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_framebuffer_blit</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glBlitFramebufferEXT(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter);</para>
        /// </summary>
        public static void glBlitFramebufferEXT(int srcX0, int srcY0, int srcX1, int srcY1, int dstX0, int dstY0, int dstX1, int dstY1, uint mask, uint filter) {
            var _F = _GetProc<GLNativeDelegate.FNglBlitFramebufferEXT>("glBlitFramebufferEXT");
            _F(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
        }

        #endregion GL_EXT_framebuffer_blit

        #region GL_EXT_framebuffer_multisample

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_framebuffer_multisample, GL_EXT_multisampled_render_to_texture</para>
        /// Supported: <para>gl, gles1, gles2</para>
        /// Original: <para>void glRenderbufferStorageMultisampleEXT(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height);</para>
        /// </summary>
        public static void glRenderbufferStorageMultisampleEXT(uint target, int samples, uint internalformat, int width, int height) {
            var _F = _GetProc<GLNativeDelegate.FNglRenderbufferStorageMultisampleEXT>("glRenderbufferStorageMultisampleEXT");
            _F(target, samples, internalformat, width, height);
        }

        #endregion GL_EXT_framebuffer_multisample

        #region GL_EXT_framebuffer_object

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_framebuffer_object</para>
        /// Supported: <para>gl</para>
        /// Original: <para>GLboolean glIsRenderbufferEXT(GLuint renderbuffer);</para>
        /// </summary>
        public static bool glIsRenderbufferEXT(uint renderbuffer) {
            var _F = _GetProc<GLNativeDelegate.FNglIsRenderbufferEXT>("glIsRenderbufferEXT");
            return _F(renderbuffer);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_framebuffer_object</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glBindRenderbufferEXT(GLenum target, GLuint renderbuffer);</para>
        /// </summary>
        public static void glBindRenderbufferEXT(uint target, uint renderbuffer) {
            var _F = _GetProc<GLNativeDelegate.FNglBindRenderbufferEXT>("glBindRenderbufferEXT");
            _F(target, renderbuffer);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_framebuffer_object</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glDeleteRenderbuffersEXT(GLsizei n, const GLuint * renderbuffers);</para>
        /// </summary>
        public unsafe static void glDeleteRenderbuffersEXT(int n, uint* renderbuffers) {
            var _F = _GetProc<GLNativeDelegate.FNglDeleteRenderbuffersEXT>("glDeleteRenderbuffersEXT");
            _F(n, renderbuffers);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_framebuffer_object</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGenRenderbuffersEXT(GLsizei n, GLuint * renderbuffers);</para>
        /// </summary>
        public unsafe static void glGenRenderbuffersEXT(int n, uint* renderbuffers) {
            var _F = _GetProc<GLNativeDelegate.FNglGenRenderbuffersEXT>("glGenRenderbuffersEXT");
            _F(n, renderbuffers);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_framebuffer_object</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glRenderbufferStorageEXT(GLenum target, GLenum internalformat, GLsizei width, GLsizei height);</para>
        /// </summary>
        public static void glRenderbufferStorageEXT(uint target, uint internalformat, int width, int height) {
            var _F = _GetProc<GLNativeDelegate.FNglRenderbufferStorageEXT>("glRenderbufferStorageEXT");
            _F(target, internalformat, width, height);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_framebuffer_object</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetRenderbufferParameterivEXT(GLenum target, GLenum pname, GLint * params);</para>
        /// </summary>
        public unsafe static void glGetRenderbufferParameterivEXT(uint target, uint pname, int* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetRenderbufferParameterivEXT>("glGetRenderbufferParameterivEXT");
            _F(target, pname, ps);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_framebuffer_object</para>
        /// Supported: <para>gl</para>
        /// Original: <para>GLboolean glIsFramebufferEXT(GLuint framebuffer);</para>
        /// </summary>
        public static bool glIsFramebufferEXT(uint framebuffer) {
            var _F = _GetProc<GLNativeDelegate.FNglIsFramebufferEXT>("glIsFramebufferEXT");
            return _F(framebuffer);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_framebuffer_object</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glBindFramebufferEXT(GLenum target, GLuint framebuffer);</para>
        /// </summary>
        public static void glBindFramebufferEXT(uint target, uint framebuffer) {
            var _F = _GetProc<GLNativeDelegate.FNglBindFramebufferEXT>("glBindFramebufferEXT");
            _F(target, framebuffer);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_framebuffer_object</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glDeleteFramebuffersEXT(GLsizei n, const GLuint * framebuffers);</para>
        /// </summary>
        public unsafe static void glDeleteFramebuffersEXT(int n, uint* framebuffers) {
            var _F = _GetProc<GLNativeDelegate.FNglDeleteFramebuffersEXT>("glDeleteFramebuffersEXT");
            _F(n, framebuffers);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_framebuffer_object</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGenFramebuffersEXT(GLsizei n, GLuint * framebuffers);</para>
        /// </summary>
        public unsafe static void glGenFramebuffersEXT(int n, uint* framebuffers) {
            var _F = _GetProc<GLNativeDelegate.FNglGenFramebuffersEXT>("glGenFramebuffersEXT");
            _F(n, framebuffers);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_framebuffer_object</para>
        /// Supported: <para>gl</para>
        /// Original: <para>GLenum glCheckFramebufferStatusEXT(GLenum target);</para>
        /// </summary>
        public static uint glCheckFramebufferStatusEXT(uint target) {
            var _F = _GetProc<GLNativeDelegate.FNglCheckFramebufferStatusEXT>("glCheckFramebufferStatusEXT");
            return _F(target);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_framebuffer_object</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glFramebufferTexture1DEXT(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level);</para>
        /// </summary>
        public static void glFramebufferTexture1DEXT(uint target, uint attachment, uint textarget, uint texture, int level) {
            var _F = _GetProc<GLNativeDelegate.FNglFramebufferTexture1DEXT>("glFramebufferTexture1DEXT");
            _F(target, attachment, textarget, texture, level);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_framebuffer_object</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glFramebufferTexture2DEXT(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level);</para>
        /// </summary>
        public static void glFramebufferTexture2DEXT(uint target, uint attachment, uint textarget, uint texture, int level) {
            var _F = _GetProc<GLNativeDelegate.FNglFramebufferTexture2DEXT>("glFramebufferTexture2DEXT");
            _F(target, attachment, textarget, texture, level);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_framebuffer_object</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glFramebufferTexture3DEXT(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset);</para>
        /// </summary>
        public static void glFramebufferTexture3DEXT(uint target, uint attachment, uint textarget, uint texture, int level, int zoffset) {
            var _F = _GetProc<GLNativeDelegate.FNglFramebufferTexture3DEXT>("glFramebufferTexture3DEXT");
            _F(target, attachment, textarget, texture, level, zoffset);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_framebuffer_object</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glFramebufferRenderbufferEXT(GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer);</para>
        /// </summary>
        public static void glFramebufferRenderbufferEXT(uint target, uint attachment, uint renderbuffertarget, uint renderbuffer) {
            var _F = _GetProc<GLNativeDelegate.FNglFramebufferRenderbufferEXT>("glFramebufferRenderbufferEXT");
            _F(target, attachment, renderbuffertarget, renderbuffer);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_framebuffer_object</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetFramebufferAttachmentParameterivEXT(GLenum target, GLenum attachment, GLenum pname, GLint * params);</para>
        /// </summary>
        public unsafe static void glGetFramebufferAttachmentParameterivEXT(uint target, uint attachment, uint pname, int* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetFramebufferAttachmentParameterivEXT>("glGetFramebufferAttachmentParameterivEXT");
            _F(target, attachment, pname, ps);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_framebuffer_object</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGenerateMipmapEXT(GLenum target);</para>
        /// </summary>
        public static void glGenerateMipmapEXT(uint target) {
            var _F = _GetProc<GLNativeDelegate.FNglGenerateMipmapEXT>("glGenerateMipmapEXT");
            _F(target);
        }

        #endregion GL_EXT_framebuffer_object

        #region GL_EXT_geometry_shader4

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_geometry_shader4, GL_EXT_separate_shader_objects</para>
        /// Supported: <para>gl, gl, glcore, gles2</para>
        /// Original: <para>void glProgramParameteriEXT(GLuint program, GLenum pname, GLint value);</para>
        /// </summary>
        public static void glProgramParameteriEXT(uint program, uint pname, int value) {
            var _F = _GetProc<GLNativeDelegate.FNglProgramParameteriEXT>("glProgramParameteriEXT");
            _F(program, pname, value);
        }

        #endregion GL_EXT_geometry_shader4

        #region GL_EXT_gpu_program_parameters

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_gpu_program_parameters</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glProgramEnvParameters4fvEXT(GLenum target, GLuint index, GLsizei count, const GLfloat * params);</para>
        /// </summary>
        public unsafe static void glProgramEnvParameters4fvEXT(uint target, uint index, int count, float* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglProgramEnvParameters4fvEXT>("glProgramEnvParameters4fvEXT");
            _F(target, index, count, ps);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_gpu_program_parameters</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glProgramLocalParameters4fvEXT(GLenum target, GLuint index, GLsizei count, const GLfloat * params);</para>
        /// </summary>
        public unsafe static void glProgramLocalParameters4fvEXT(uint target, uint index, int count, float* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglProgramLocalParameters4fvEXT>("glProgramLocalParameters4fvEXT");
            _F(target, index, count, ps);
        }

        #endregion GL_EXT_gpu_program_parameters

        #region GL_EXT_gpu_shader4

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_gpu_shader4</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetUniformuivEXT(GLuint program, GLint location, GLuint * params);</para>
        /// </summary>
        public unsafe static void glGetUniformuivEXT(uint program, int location, uint* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetUniformuivEXT>("glGetUniformuivEXT");
            _F(program, location, ps);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_blend_func_extended, GL_EXT_gpu_shader4</para>
        /// Supported: <para>gles2, gl</para>
        /// Original: <para>void glBindFragDataLocationEXT(GLuint program, GLuint color, const GLchar * name);</para>
        /// </summary>
        public unsafe static void glBindFragDataLocationEXT(uint program, uint color, byte* name) {
            var _F = _GetProc<GLNativeDelegate.FNglBindFragDataLocationEXT>("glBindFragDataLocationEXT");
            _F(program, color, name);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_gpu_shader4</para>
        /// Supported: <para>gl</para>
        /// Original: <para>GLint glGetFragDataLocationEXT(GLuint program, const GLchar * name);</para>
        /// </summary>
        public unsafe static int glGetFragDataLocationEXT(uint program, byte* name) {
            var _F = _GetProc<GLNativeDelegate.FNglGetFragDataLocationEXT>("glGetFragDataLocationEXT");
            return _F(program, name);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_gpu_shader4</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glUniform1uiEXT(GLint location, GLuint v0);</para>
        /// </summary>
        public static void glUniform1uiEXT(int location, uint v0) {
            var _F = _GetProc<GLNativeDelegate.FNglUniform1uiEXT>("glUniform1uiEXT");
            _F(location, v0);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_gpu_shader4</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glUniform2uiEXT(GLint location, GLuint v0, GLuint v1);</para>
        /// </summary>
        public static void glUniform2uiEXT(int location, uint v0, uint v1) {
            var _F = _GetProc<GLNativeDelegate.FNglUniform2uiEXT>("glUniform2uiEXT");
            _F(location, v0, v1);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_gpu_shader4</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glUniform3uiEXT(GLint location, GLuint v0, GLuint v1, GLuint v2);</para>
        /// </summary>
        public static void glUniform3uiEXT(int location, uint v0, uint v1, uint v2) {
            var _F = _GetProc<GLNativeDelegate.FNglUniform3uiEXT>("glUniform3uiEXT");
            _F(location, v0, v1, v2);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_gpu_shader4</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glUniform4uiEXT(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3);</para>
        /// </summary>
        public static void glUniform4uiEXT(int location, uint v0, uint v1, uint v2, uint v3) {
            var _F = _GetProc<GLNativeDelegate.FNglUniform4uiEXT>("glUniform4uiEXT");
            _F(location, v0, v1, v2, v3);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_gpu_shader4</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glUniform1uivEXT(GLint location, GLsizei count, const GLuint * value);</para>
        /// </summary>
        public unsafe static void glUniform1uivEXT(int location, int count, uint* value) {
            var _F = _GetProc<GLNativeDelegate.FNglUniform1uivEXT>("glUniform1uivEXT");
            _F(location, count, value);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_gpu_shader4</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glUniform2uivEXT(GLint location, GLsizei count, const GLuint * value);</para>
        /// </summary>
        public unsafe static void glUniform2uivEXT(int location, int count, uint* value) {
            var _F = _GetProc<GLNativeDelegate.FNglUniform2uivEXT>("glUniform2uivEXT");
            _F(location, count, value);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_gpu_shader4</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glUniform3uivEXT(GLint location, GLsizei count, const GLuint * value);</para>
        /// </summary>
        public unsafe static void glUniform3uivEXT(int location, int count, uint* value) {
            var _F = _GetProc<GLNativeDelegate.FNglUniform3uivEXT>("glUniform3uivEXT");
            _F(location, count, value);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_gpu_shader4</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glUniform4uivEXT(GLint location, GLsizei count, const GLuint * value);</para>
        /// </summary>
        public unsafe static void glUniform4uivEXT(int location, int count, uint* value) {
            var _F = _GetProc<GLNativeDelegate.FNglUniform4uivEXT>("glUniform4uivEXT");
            _F(location, count, value);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_gpu_shader4, GL_NV_vertex_program4</para>
        /// Supported: <para>gl, gl</para>
        /// Original: <para>void glVertexAttribI1iEXT(GLuint index, GLint x);</para>
        /// </summary>
        public static void glVertexAttribI1iEXT(uint index, int x) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttribI1iEXT>("glVertexAttribI1iEXT");
            _F(index, x);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_gpu_shader4, GL_NV_vertex_program4</para>
        /// Supported: <para>gl, gl</para>
        /// Original: <para>void glVertexAttribI2iEXT(GLuint index, GLint x, GLint y);</para>
        /// </summary>
        public static void glVertexAttribI2iEXT(uint index, int x, int y) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttribI2iEXT>("glVertexAttribI2iEXT");
            _F(index, x, y);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_gpu_shader4, GL_NV_vertex_program4</para>
        /// Supported: <para>gl, gl</para>
        /// Original: <para>void glVertexAttribI3iEXT(GLuint index, GLint x, GLint y, GLint z);</para>
        /// </summary>
        public static void glVertexAttribI3iEXT(uint index, int x, int y, int z) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttribI3iEXT>("glVertexAttribI3iEXT");
            _F(index, x, y, z);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_gpu_shader4, GL_NV_vertex_program4</para>
        /// Supported: <para>gl, gl</para>
        /// Original: <para>void glVertexAttribI4iEXT(GLuint index, GLint x, GLint y, GLint z, GLint w);</para>
        /// </summary>
        public static void glVertexAttribI4iEXT(uint index, int x, int y, int z, int w) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttribI4iEXT>("glVertexAttribI4iEXT");
            _F(index, x, y, z, w);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_gpu_shader4, GL_NV_vertex_program4</para>
        /// Supported: <para>gl, gl</para>
        /// Original: <para>void glVertexAttribI1uiEXT(GLuint index, GLuint x);</para>
        /// </summary>
        public static void glVertexAttribI1uiEXT(uint index, uint x) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttribI1uiEXT>("glVertexAttribI1uiEXT");
            _F(index, x);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_gpu_shader4, GL_NV_vertex_program4</para>
        /// Supported: <para>gl, gl</para>
        /// Original: <para>void glVertexAttribI2uiEXT(GLuint index, GLuint x, GLuint y);</para>
        /// </summary>
        public static void glVertexAttribI2uiEXT(uint index, uint x, uint y) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttribI2uiEXT>("glVertexAttribI2uiEXT");
            _F(index, x, y);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_gpu_shader4, GL_NV_vertex_program4</para>
        /// Supported: <para>gl, gl</para>
        /// Original: <para>void glVertexAttribI3uiEXT(GLuint index, GLuint x, GLuint y, GLuint z);</para>
        /// </summary>
        public static void glVertexAttribI3uiEXT(uint index, uint x, uint y, uint z) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttribI3uiEXT>("glVertexAttribI3uiEXT");
            _F(index, x, y, z);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_gpu_shader4, GL_NV_vertex_program4</para>
        /// Supported: <para>gl, gl</para>
        /// Original: <para>void glVertexAttribI4uiEXT(GLuint index, GLuint x, GLuint y, GLuint z, GLuint w);</para>
        /// </summary>
        public static void glVertexAttribI4uiEXT(uint index, uint x, uint y, uint z, uint w) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttribI4uiEXT>("glVertexAttribI4uiEXT");
            _F(index, x, y, z, w);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_gpu_shader4, GL_NV_vertex_program4</para>
        /// Supported: <para>gl, gl</para>
        /// Original: <para>void glVertexAttribI1ivEXT(GLuint index, const GLint * v);</para>
        /// </summary>
        public unsafe static void glVertexAttribI1ivEXT(uint index, int* v) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttribI1ivEXT>("glVertexAttribI1ivEXT");
            _F(index, v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_gpu_shader4, GL_NV_vertex_program4</para>
        /// Supported: <para>gl, gl</para>
        /// Original: <para>void glVertexAttribI2ivEXT(GLuint index, const GLint * v);</para>
        /// </summary>
        public unsafe static void glVertexAttribI2ivEXT(uint index, int* v) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttribI2ivEXT>("glVertexAttribI2ivEXT");
            _F(index, v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_gpu_shader4, GL_NV_vertex_program4</para>
        /// Supported: <para>gl, gl</para>
        /// Original: <para>void glVertexAttribI3ivEXT(GLuint index, const GLint * v);</para>
        /// </summary>
        public unsafe static void glVertexAttribI3ivEXT(uint index, int* v) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttribI3ivEXT>("glVertexAttribI3ivEXT");
            _F(index, v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_gpu_shader4, GL_NV_vertex_program4</para>
        /// Supported: <para>gl, gl</para>
        /// Original: <para>void glVertexAttribI4ivEXT(GLuint index, const GLint * v);</para>
        /// </summary>
        public unsafe static void glVertexAttribI4ivEXT(uint index, int* v) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttribI4ivEXT>("glVertexAttribI4ivEXT");
            _F(index, v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_gpu_shader4, GL_NV_vertex_program4</para>
        /// Supported: <para>gl, gl</para>
        /// Original: <para>void glVertexAttribI1uivEXT(GLuint index, const GLuint * v);</para>
        /// </summary>
        public unsafe static void glVertexAttribI1uivEXT(uint index, uint* v) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttribI1uivEXT>("glVertexAttribI1uivEXT");
            _F(index, v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_gpu_shader4, GL_NV_vertex_program4</para>
        /// Supported: <para>gl, gl</para>
        /// Original: <para>void glVertexAttribI2uivEXT(GLuint index, const GLuint * v);</para>
        /// </summary>
        public unsafe static void glVertexAttribI2uivEXT(uint index, uint* v) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttribI2uivEXT>("glVertexAttribI2uivEXT");
            _F(index, v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_gpu_shader4, GL_NV_vertex_program4</para>
        /// Supported: <para>gl, gl</para>
        /// Original: <para>void glVertexAttribI3uivEXT(GLuint index, const GLuint * v);</para>
        /// </summary>
        public unsafe static void glVertexAttribI3uivEXT(uint index, uint* v) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttribI3uivEXT>("glVertexAttribI3uivEXT");
            _F(index, v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_gpu_shader4, GL_NV_vertex_program4</para>
        /// Supported: <para>gl, gl</para>
        /// Original: <para>void glVertexAttribI4uivEXT(GLuint index, const GLuint * v);</para>
        /// </summary>
        public unsafe static void glVertexAttribI4uivEXT(uint index, uint* v) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttribI4uivEXT>("glVertexAttribI4uivEXT");
            _F(index, v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_gpu_shader4, GL_NV_vertex_program4</para>
        /// Supported: <para>gl, gl</para>
        /// Original: <para>void glVertexAttribI4bvEXT(GLuint index, const GLbyte * v);</para>
        /// </summary>
        public unsafe static void glVertexAttribI4bvEXT(uint index, byte* v) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttribI4bvEXT>("glVertexAttribI4bvEXT");
            _F(index, v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_gpu_shader4, GL_NV_vertex_program4</para>
        /// Supported: <para>gl, gl</para>
        /// Original: <para>void glVertexAttribI4svEXT(GLuint index, const GLshort * v);</para>
        /// </summary>
        public unsafe static void glVertexAttribI4svEXT(uint index, short* v) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttribI4svEXT>("glVertexAttribI4svEXT");
            _F(index, v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_gpu_shader4, GL_NV_vertex_program4</para>
        /// Supported: <para>gl, gl</para>
        /// Original: <para>void glVertexAttribI4ubvEXT(GLuint index, const GLubyte * v);</para>
        /// </summary>
        public unsafe static void glVertexAttribI4ubvEXT(uint index, byte* v) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttribI4ubvEXT>("glVertexAttribI4ubvEXT");
            _F(index, v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_gpu_shader4, GL_NV_vertex_program4</para>
        /// Supported: <para>gl, gl</para>
        /// Original: <para>void glVertexAttribI4usvEXT(GLuint index, const GLushort * v);</para>
        /// </summary>
        public unsafe static void glVertexAttribI4usvEXT(uint index, ushort* v) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttribI4usvEXT>("glVertexAttribI4usvEXT");
            _F(index, v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_gpu_shader4, GL_NV_vertex_program4</para>
        /// Supported: <para>gl, gl</para>
        /// Original: <para>void glVertexAttribIPointerEXT(GLuint index, GLint size, GLenum type, GLsizei stride, const void * pointer);</para>
        /// </summary>
        public unsafe static void glVertexAttribIPointerEXT(uint index, int size, uint type, int stride, void* pointer) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttribIPointerEXT>("glVertexAttribIPointerEXT");
            _F(index, size, type, stride, pointer);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_gpu_shader4, GL_NV_vertex_program4</para>
        /// Supported: <para>gl, gl</para>
        /// Original: <para>void glGetVertexAttribIivEXT(GLuint index, GLenum pname, GLint * params);</para>
        /// </summary>
        public unsafe static void glGetVertexAttribIivEXT(uint index, uint pname, int* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetVertexAttribIivEXT>("glGetVertexAttribIivEXT");
            _F(index, pname, ps);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_gpu_shader4, GL_NV_vertex_program4</para>
        /// Supported: <para>gl, gl</para>
        /// Original: <para>void glGetVertexAttribIuivEXT(GLuint index, GLenum pname, GLuint * params);</para>
        /// </summary>
        public unsafe static void glGetVertexAttribIuivEXT(uint index, uint pname, uint* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetVertexAttribIuivEXT>("glGetVertexAttribIuivEXT");
            _F(index, pname, ps);
        }

        #endregion GL_EXT_gpu_shader4

        #region GL_EXT_histogram

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_histogram</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetHistogramEXT(GLenum target, GLboolean reset, GLenum format, GLenum type, void * values);</para>
        /// </summary>
        public unsafe static void glGetHistogramEXT(uint target, bool reset, uint format, uint type, void* values) {
            var _F = _GetProc<GLNativeDelegate.FNglGetHistogramEXT>("glGetHistogramEXT");
            _F(target, reset, format, type, values);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_histogram</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetHistogramParameterfvEXT(GLenum target, GLenum pname, GLfloat * params);</para>
        /// </summary>
        public unsafe static void glGetHistogramParameterfvEXT(uint target, uint pname, float* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetHistogramParameterfvEXT>("glGetHistogramParameterfvEXT");
            _F(target, pname, ps);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_histogram</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetHistogramParameterivEXT(GLenum target, GLenum pname, GLint * params);</para>
        /// </summary>
        public unsafe static void glGetHistogramParameterivEXT(uint target, uint pname, int* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetHistogramParameterivEXT>("glGetHistogramParameterivEXT");
            _F(target, pname, ps);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_histogram</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetMinmaxEXT(GLenum target, GLboolean reset, GLenum format, GLenum type, void * values);</para>
        /// </summary>
        public unsafe static void glGetMinmaxEXT(uint target, bool reset, uint format, uint type, void* values) {
            var _F = _GetProc<GLNativeDelegate.FNglGetMinmaxEXT>("glGetMinmaxEXT");
            _F(target, reset, format, type, values);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_histogram</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetMinmaxParameterfvEXT(GLenum target, GLenum pname, GLfloat * params);</para>
        /// </summary>
        public unsafe static void glGetMinmaxParameterfvEXT(uint target, uint pname, float* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetMinmaxParameterfvEXT>("glGetMinmaxParameterfvEXT");
            _F(target, pname, ps);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_histogram</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetMinmaxParameterivEXT(GLenum target, GLenum pname, GLint * params);</para>
        /// </summary>
        public unsafe static void glGetMinmaxParameterivEXT(uint target, uint pname, int* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetMinmaxParameterivEXT>("glGetMinmaxParameterivEXT");
            _F(target, pname, ps);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_histogram</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glHistogramEXT(GLenum target, GLsizei width, GLenum internalformat, GLboolean sink);</para>
        /// </summary>
        public static void glHistogramEXT(uint target, int width, uint internalformat, bool sink) {
            var _F = _GetProc<GLNativeDelegate.FNglHistogramEXT>("glHistogramEXT");
            _F(target, width, internalformat, sink);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_histogram</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glMinmaxEXT(GLenum target, GLenum internalformat, GLboolean sink);</para>
        /// </summary>
        public static void glMinmaxEXT(uint target, uint internalformat, bool sink) {
            var _F = _GetProc<GLNativeDelegate.FNglMinmaxEXT>("glMinmaxEXT");
            _F(target, internalformat, sink);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_histogram</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glResetHistogramEXT(GLenum target);</para>
        /// </summary>
        public static void glResetHistogramEXT(uint target) {
            var _F = _GetProc<GLNativeDelegate.FNglResetHistogramEXT>("glResetHistogramEXT");
            _F(target);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_histogram</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glResetMinmaxEXT(GLenum target);</para>
        /// </summary>
        public static void glResetMinmaxEXT(uint target) {
            var _F = _GetProc<GLNativeDelegate.FNglResetMinmaxEXT>("glResetMinmaxEXT");
            _F(target);
        }

        #endregion GL_EXT_histogram

        #region GL_EXT_index_func

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_index_func</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glIndexFuncEXT(GLenum func, GLclampf ref);</para>
        /// </summary>
        public static void glIndexFuncEXT(uint func, float r) {
            var _F = _GetProc<GLNativeDelegate.FNglIndexFuncEXT>("glIndexFuncEXT");
            _F(func, r);
        }

        #endregion GL_EXT_index_func

        #region GL_EXT_index_material

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_index_material</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glIndexMaterialEXT(GLenum face, GLenum mode);</para>
        /// </summary>
        public static void glIndexMaterialEXT(uint face, uint mode) {
            var _F = _GetProc<GLNativeDelegate.FNglIndexMaterialEXT>("glIndexMaterialEXT");
            _F(face, mode);
        }

        #endregion GL_EXT_index_material

        #region GL_EXT_light_texture

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_light_texture</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glApplyTextureEXT(GLenum mode);</para>
        /// </summary>
        public static void glApplyTextureEXT(uint mode) {
            var _F = _GetProc<GLNativeDelegate.FNglApplyTextureEXT>("glApplyTextureEXT");
            _F(mode);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_light_texture</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glTextureLightEXT(GLenum pname);</para>
        /// </summary>
        public static void glTextureLightEXT(uint pname) {
            var _F = _GetProc<GLNativeDelegate.FNglTextureLightEXT>("glTextureLightEXT");
            _F(pname);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_light_texture</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glTextureMaterialEXT(GLenum face, GLenum mode);</para>
        /// </summary>
        public static void glTextureMaterialEXT(uint face, uint mode) {
            var _F = _GetProc<GLNativeDelegate.FNglTextureMaterialEXT>("glTextureMaterialEXT");
            _F(face, mode);
        }

        #endregion GL_EXT_light_texture

        #region GL_EXT_memory_object

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_memory_object, GL_EXT_semaphore</para>
        /// Supported: <para>gl, gles2, gl, gles2</para>
        /// Original: <para>void glGetUnsignedBytevEXT(GLenum pname, GLubyte * data);</para>
        /// </summary>
        public unsafe static void glGetUnsignedBytevEXT(uint pname, byte* data) {
            var _F = _GetProc<GLNativeDelegate.FNglGetUnsignedBytevEXT>("glGetUnsignedBytevEXT");
            _F(pname, data);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_memory_object, GL_EXT_semaphore</para>
        /// Supported: <para>gl, gles2, gl, gles2</para>
        /// Original: <para>void glGetUnsignedBytei_vEXT(GLenum target, GLuint index, GLubyte * data);</para>
        /// </summary>
        public unsafe static void glGetUnsignedBytei_vEXT(uint target, uint index, byte* data) {
            var _F = _GetProc<GLNativeDelegate.FNglGetUnsignedBytei_vEXT>("glGetUnsignedBytei_vEXT");
            _F(target, index, data);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_memory_object</para>
        /// Supported: <para>gl, gles2</para>
        /// Original: <para>void glDeleteMemoryObjectsEXT(GLsizei n, const GLuint * memoryObjects);</para>
        /// </summary>
        public unsafe static void glDeleteMemoryObjectsEXT(int n, uint* memoryObjects) {
            var _F = _GetProc<GLNativeDelegate.FNglDeleteMemoryObjectsEXT>("glDeleteMemoryObjectsEXT");
            _F(n, memoryObjects);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_memory_object</para>
        /// Supported: <para>gl, gles2</para>
        /// Original: <para>GLboolean glIsMemoryObjectEXT(GLuint memoryObject);</para>
        /// </summary>
        public static bool glIsMemoryObjectEXT(uint memoryObject) {
            var _F = _GetProc<GLNativeDelegate.FNglIsMemoryObjectEXT>("glIsMemoryObjectEXT");
            return _F(memoryObject);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_memory_object</para>
        /// Supported: <para>gl, gles2</para>
        /// Original: <para>void glCreateMemoryObjectsEXT(GLsizei n, GLuint * memoryObjects);</para>
        /// </summary>
        public unsafe static void glCreateMemoryObjectsEXT(int n, uint* memoryObjects) {
            var _F = _GetProc<GLNativeDelegate.FNglCreateMemoryObjectsEXT>("glCreateMemoryObjectsEXT");
            _F(n, memoryObjects);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_memory_object</para>
        /// Supported: <para>gl, gles2</para>
        /// Original: <para>void glMemoryObjectParameterivEXT(GLuint memoryObject, GLenum pname, const GLint * params);</para>
        /// </summary>
        public unsafe static void glMemoryObjectParameterivEXT(uint memoryObject, uint pname, int* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglMemoryObjectParameterivEXT>("glMemoryObjectParameterivEXT");
            _F(memoryObject, pname, ps);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_memory_object</para>
        /// Supported: <para>gl, gles2</para>
        /// Original: <para>void glGetMemoryObjectParameterivEXT(GLuint memoryObject, GLenum pname, GLint * params);</para>
        /// </summary>
        public unsafe static void glGetMemoryObjectParameterivEXT(uint memoryObject, uint pname, int* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetMemoryObjectParameterivEXT>("glGetMemoryObjectParameterivEXT");
            _F(memoryObject, pname, ps);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_memory_object</para>
        /// Supported: <para>gl, gles2</para>
        /// Original: <para>void glTexStorageMem2DEXT(GLenum target, GLsizei levels, GLenum internalFormat, GLsizei width, GLsizei height, GLuint memory, GLuint64 offset);</para>
        /// </summary>
        public static void glTexStorageMem2DEXT(uint target, int levels, uint internalFormat, int width, int height, uint memory, UInt64 offset) {
            var _F = _GetProc<GLNativeDelegate.FNglTexStorageMem2DEXT>("glTexStorageMem2DEXT");
            _F(target, levels, internalFormat, width, height, memory, offset);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_memory_object</para>
        /// Supported: <para>gl, gles2</para>
        /// Original: <para>void glTexStorageMem2DMultisampleEXT(GLenum target, GLsizei samples, GLenum internalFormat, GLsizei width, GLsizei height, GLboolean fixedSampleLocations, GLuint memory, GLuint64 offset);</para>
        /// </summary>
        public static void glTexStorageMem2DMultisampleEXT(uint target, int samples, uint internalFormat, int width, int height, bool fixedSampleLocations, uint memory, UInt64 offset) {
            var _F = _GetProc<GLNativeDelegate.FNglTexStorageMem2DMultisampleEXT>("glTexStorageMem2DMultisampleEXT");
            _F(target, samples, internalFormat, width, height, fixedSampleLocations, memory, offset);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_memory_object</para>
        /// Supported: <para>gl, gles2</para>
        /// Original: <para>void glTexStorageMem3DEXT(GLenum target, GLsizei levels, GLenum internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLuint memory, GLuint64 offset);</para>
        /// </summary>
        public static void glTexStorageMem3DEXT(uint target, int levels, uint internalFormat, int width, int height, int depth, uint memory, UInt64 offset) {
            var _F = _GetProc<GLNativeDelegate.FNglTexStorageMem3DEXT>("glTexStorageMem3DEXT");
            _F(target, levels, internalFormat, width, height, depth, memory, offset);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_memory_object</para>
        /// Supported: <para>gl, gles2</para>
        /// Original: <para>void glTexStorageMem3DMultisampleEXT(GLenum target, GLsizei samples, GLenum internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedSampleLocations, GLuint memory, GLuint64 offset);</para>
        /// </summary>
        public static void glTexStorageMem3DMultisampleEXT(uint target, int samples, uint internalFormat, int width, int height, int depth, bool fixedSampleLocations, uint memory, UInt64 offset) {
            var _F = _GetProc<GLNativeDelegate.FNglTexStorageMem3DMultisampleEXT>("glTexStorageMem3DMultisampleEXT");
            _F(target, samples, internalFormat, width, height, depth, fixedSampleLocations, memory, offset);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_memory_object</para>
        /// Supported: <para>gl, gles2</para>
        /// Original: <para>void glBufferStorageMemEXT(GLenum target, GLsizeiptr size, GLuint memory, GLuint64 offset);</para>
        /// </summary>
        public static void glBufferStorageMemEXT(uint target, IntPtr size, uint memory, UInt64 offset) {
            var _F = _GetProc<GLNativeDelegate.FNglBufferStorageMemEXT>("glBufferStorageMemEXT");
            _F(target, size, memory, offset);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_memory_object</para>
        /// Supported: <para>gl, gles2</para>
        /// Original: <para>void glTextureStorageMem2DEXT(GLuint texture, GLsizei levels, GLenum internalFormat, GLsizei width, GLsizei height, GLuint memory, GLuint64 offset);</para>
        /// </summary>
        public static void glTextureStorageMem2DEXT(uint texture, int levels, uint internalFormat, int width, int height, uint memory, UInt64 offset) {
            var _F = _GetProc<GLNativeDelegate.FNglTextureStorageMem2DEXT>("glTextureStorageMem2DEXT");
            _F(texture, levels, internalFormat, width, height, memory, offset);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_memory_object</para>
        /// Supported: <para>gl, gles2</para>
        /// Original: <para>void glTextureStorageMem2DMultisampleEXT(GLuint texture, GLsizei samples, GLenum internalFormat, GLsizei width, GLsizei height, GLboolean fixedSampleLocations, GLuint memory, GLuint64 offset);</para>
        /// </summary>
        public static void glTextureStorageMem2DMultisampleEXT(uint texture, int samples, uint internalFormat, int width, int height, bool fixedSampleLocations, uint memory, UInt64 offset) {
            var _F = _GetProc<GLNativeDelegate.FNglTextureStorageMem2DMultisampleEXT>("glTextureStorageMem2DMultisampleEXT");
            _F(texture, samples, internalFormat, width, height, fixedSampleLocations, memory, offset);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_memory_object</para>
        /// Supported: <para>gl, gles2</para>
        /// Original: <para>void glTextureStorageMem3DEXT(GLuint texture, GLsizei levels, GLenum internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLuint memory, GLuint64 offset);</para>
        /// </summary>
        public static void glTextureStorageMem3DEXT(uint texture, int levels, uint internalFormat, int width, int height, int depth, uint memory, UInt64 offset) {
            var _F = _GetProc<GLNativeDelegate.FNglTextureStorageMem3DEXT>("glTextureStorageMem3DEXT");
            _F(texture, levels, internalFormat, width, height, depth, memory, offset);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_memory_object</para>
        /// Supported: <para>gl, gles2</para>
        /// Original: <para>void glTextureStorageMem3DMultisampleEXT(GLuint texture, GLsizei samples, GLenum internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedSampleLocations, GLuint memory, GLuint64 offset);</para>
        /// </summary>
        public static void glTextureStorageMem3DMultisampleEXT(uint texture, int samples, uint internalFormat, int width, int height, int depth, bool fixedSampleLocations, uint memory, UInt64 offset) {
            var _F = _GetProc<GLNativeDelegate.FNglTextureStorageMem3DMultisampleEXT>("glTextureStorageMem3DMultisampleEXT");
            _F(texture, samples, internalFormat, width, height, depth, fixedSampleLocations, memory, offset);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_memory_object</para>
        /// Supported: <para>gl, gles2</para>
        /// Original: <para>void glNamedBufferStorageMemEXT(GLuint buffer, GLsizeiptr size, GLuint memory, GLuint64 offset);</para>
        /// </summary>
        public static void glNamedBufferStorageMemEXT(uint buffer, IntPtr size, uint memory, UInt64 offset) {
            var _F = _GetProc<GLNativeDelegate.FNglNamedBufferStorageMemEXT>("glNamedBufferStorageMemEXT");
            _F(buffer, size, memory, offset);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_memory_object</para>
        /// Supported: <para>gl, gles2</para>
        /// Original: <para>void glTexStorageMem1DEXT(GLenum target, GLsizei levels, GLenum internalFormat, GLsizei width, GLuint memory, GLuint64 offset);</para>
        /// </summary>
        public static void glTexStorageMem1DEXT(uint target, int levels, uint internalFormat, int width, uint memory, UInt64 offset) {
            var _F = _GetProc<GLNativeDelegate.FNglTexStorageMem1DEXT>("glTexStorageMem1DEXT");
            _F(target, levels, internalFormat, width, memory, offset);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_memory_object</para>
        /// Supported: <para>gl, gles2</para>
        /// Original: <para>void glTextureStorageMem1DEXT(GLuint texture, GLsizei levels, GLenum internalFormat, GLsizei width, GLuint memory, GLuint64 offset);</para>
        /// </summary>
        public static void glTextureStorageMem1DEXT(uint texture, int levels, uint internalFormat, int width, uint memory, UInt64 offset) {
            var _F = _GetProc<GLNativeDelegate.FNglTextureStorageMem1DEXT>("glTextureStorageMem1DEXT");
            _F(texture, levels, internalFormat, width, memory, offset);
        }

        #endregion GL_EXT_memory_object

        #region GL_EXT_memory_object_fd

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_memory_object_fd</para>
        /// Supported: <para>gl, gles2</para>
        /// Original: <para>void glImportMemoryFdEXT(GLuint memory, GLuint64 size, GLenum handleType, GLint fd);</para>
        /// </summary>
        public static void glImportMemoryFdEXT(uint memory, UInt64 size, uint handleType, int fd) {
            var _F = _GetProc<GLNativeDelegate.FNglImportMemoryFdEXT>("glImportMemoryFdEXT");
            _F(memory, size, handleType, fd);
        }

        #endregion GL_EXT_memory_object_fd

        #region GL_EXT_memory_object_win32

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_memory_object_win32</para>
        /// Supported: <para>gl, gles2</para>
        /// Original: <para>void glImportMemoryWin32HandleEXT(GLuint memory, GLuint64 size, GLenum handleType, void * handle);</para>
        /// </summary>
        public unsafe static void glImportMemoryWin32HandleEXT(uint memory, UInt64 size, uint handleType, void* handle) {
            var _F = _GetProc<GLNativeDelegate.FNglImportMemoryWin32HandleEXT>("glImportMemoryWin32HandleEXT");
            _F(memory, size, handleType, handle);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_memory_object_win32</para>
        /// Supported: <para>gl, gles2</para>
        /// Original: <para>void glImportMemoryWin32NameEXT(GLuint memory, GLuint64 size, GLenum handleType, const void * name);</para>
        /// </summary>
        public unsafe static void glImportMemoryWin32NameEXT(uint memory, UInt64 size, uint handleType, void* name) {
            var _F = _GetProc<GLNativeDelegate.FNglImportMemoryWin32NameEXT>("glImportMemoryWin32NameEXT");
            _F(memory, size, handleType, name);
        }

        #endregion GL_EXT_memory_object_win32

        #region GL_EXT_multi_draw_arrays

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_multi_draw_arrays</para>
        /// Supported: <para>gl, gles1, gles2</para>
        /// Original: <para>void glMultiDrawArraysEXT(GLenum mode, const GLint * first, const GLsizei * count, GLsizei primcount);</para>
        /// </summary>
        public unsafe static void glMultiDrawArraysEXT(uint mode, int* first, int* count, int primcount) {
            var _F = _GetProc<GLNativeDelegate.FNglMultiDrawArraysEXT>("glMultiDrawArraysEXT");
            _F(mode, first, count, primcount);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_multi_draw_arrays</para>
        /// Supported: <para>gl, gles1, gles2</para>
        /// Original: <para>void glMultiDrawElementsEXT(GLenum mode, const GLsizei * count, GLenum type, const void *const* indices, GLsizei primcount);</para>
        /// </summary>
        public unsafe static void glMultiDrawElementsEXT(uint mode, int* count, uint type, IntPtr indices, int primcount) {
            var _F = _GetProc<GLNativeDelegate.FNglMultiDrawElementsEXT>("glMultiDrawElementsEXT");
            _F(mode, count, type, indices, primcount);
        }

        #endregion GL_EXT_multi_draw_arrays

        #region GL_EXT_multisample

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_multisample</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glSampleMaskEXT(GLclampf value, GLboolean invert);</para>
        /// </summary>
        public static void glSampleMaskEXT(float value, bool invert) {
            var _F = _GetProc<GLNativeDelegate.FNglSampleMaskEXT>("glSampleMaskEXT");
            _F(value, invert);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_multisample</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glSamplePatternEXT(GLenum pattern);</para>
        /// </summary>
        public static void glSamplePatternEXT(uint pattern) {
            var _F = _GetProc<GLNativeDelegate.FNglSamplePatternEXT>("glSamplePatternEXT");
            _F(pattern);
        }

        #endregion GL_EXT_multisample

        #region GL_EXT_paletted_texture

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_paletted_texture</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glColorTableEXT(GLenum target, GLenum internalFormat, GLsizei width, GLenum format, GLenum type, const void * table);</para>
        /// </summary>
        public unsafe static void glColorTableEXT(uint target, uint internalFormat, int width, uint format, uint type, void* table) {
            var _F = _GetProc<GLNativeDelegate.FNglColorTableEXT>("glColorTableEXT");
            _F(target, internalFormat, width, format, type, table);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_paletted_texture</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetColorTableEXT(GLenum target, GLenum format, GLenum type, void * data);</para>
        /// </summary>
        public unsafe static void glGetColorTableEXT(uint target, uint format, uint type, void* data) {
            var _F = _GetProc<GLNativeDelegate.FNglGetColorTableEXT>("glGetColorTableEXT");
            _F(target, format, type, data);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_paletted_texture</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetColorTableParameterivEXT(GLenum target, GLenum pname, GLint * params);</para>
        /// </summary>
        public unsafe static void glGetColorTableParameterivEXT(uint target, uint pname, int* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetColorTableParameterivEXT>("glGetColorTableParameterivEXT");
            _F(target, pname, ps);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_paletted_texture</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetColorTableParameterfvEXT(GLenum target, GLenum pname, GLfloat * params);</para>
        /// </summary>
        public unsafe static void glGetColorTableParameterfvEXT(uint target, uint pname, float* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetColorTableParameterfvEXT>("glGetColorTableParameterfvEXT");
            _F(target, pname, ps);
        }

        #endregion GL_EXT_paletted_texture

        #region GL_EXT_pixel_transform

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_pixel_transform</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glPixelTransformParameteriEXT(GLenum target, GLenum pname, GLint param);</para>
        /// </summary>
        public static void glPixelTransformParameteriEXT(uint target, uint pname, int param) {
            var _F = _GetProc<GLNativeDelegate.FNglPixelTransformParameteriEXT>("glPixelTransformParameteriEXT");
            _F(target, pname, param);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_pixel_transform</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glPixelTransformParameterfEXT(GLenum target, GLenum pname, GLfloat param);</para>
        /// </summary>
        public static void glPixelTransformParameterfEXT(uint target, uint pname, float param) {
            var _F = _GetProc<GLNativeDelegate.FNglPixelTransformParameterfEXT>("glPixelTransformParameterfEXT");
            _F(target, pname, param);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_pixel_transform</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glPixelTransformParameterivEXT(GLenum target, GLenum pname, const GLint * params);</para>
        /// </summary>
        public unsafe static void glPixelTransformParameterivEXT(uint target, uint pname, int* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglPixelTransformParameterivEXT>("glPixelTransformParameterivEXT");
            _F(target, pname, ps);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_pixel_transform</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glPixelTransformParameterfvEXT(GLenum target, GLenum pname, const GLfloat * params);</para>
        /// </summary>
        public unsafe static void glPixelTransformParameterfvEXT(uint target, uint pname, float* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglPixelTransformParameterfvEXT>("glPixelTransformParameterfvEXT");
            _F(target, pname, ps);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_pixel_transform</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetPixelTransformParameterivEXT(GLenum target, GLenum pname, GLint * params);</para>
        /// </summary>
        public unsafe static void glGetPixelTransformParameterivEXT(uint target, uint pname, int* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetPixelTransformParameterivEXT>("glGetPixelTransformParameterivEXT");
            _F(target, pname, ps);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_pixel_transform</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetPixelTransformParameterfvEXT(GLenum target, GLenum pname, GLfloat * params);</para>
        /// </summary>
        public unsafe static void glGetPixelTransformParameterfvEXT(uint target, uint pname, float* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetPixelTransformParameterfvEXT>("glGetPixelTransformParameterfvEXT");
            _F(target, pname, ps);
        }

        #endregion GL_EXT_pixel_transform

        #region GL_EXT_point_parameters

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_point_parameters</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glPointParameterfEXT(GLenum pname, GLfloat param);</para>
        /// </summary>
        public static void glPointParameterfEXT(uint pname, float param) {
            var _F = _GetProc<GLNativeDelegate.FNglPointParameterfEXT>("glPointParameterfEXT");
            _F(pname, param);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_point_parameters</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glPointParameterfvEXT(GLenum pname, const GLfloat * params);</para>
        /// </summary>
        public unsafe static void glPointParameterfvEXT(uint pname, float* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglPointParameterfvEXT>("glPointParameterfvEXT");
            _F(pname, ps);
        }

        #endregion GL_EXT_point_parameters

        #region GL_EXT_polygon_offset

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_polygon_offset</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glPolygonOffsetEXT(GLfloat factor, GLfloat bias);</para>
        /// </summary>
        public static void glPolygonOffsetEXT(float factor, float bias) {
            var _F = _GetProc<GLNativeDelegate.FNglPolygonOffsetEXT>("glPolygonOffsetEXT");
            _F(factor, bias);
        }

        #endregion GL_EXT_polygon_offset

        #region GL_EXT_polygon_offset_clamp

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_polygon_offset_clamp</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glPolygonOffsetClampEXT(GLfloat factor, GLfloat units, GLfloat clamp);</para>
        /// </summary>
        public static void glPolygonOffsetClampEXT(float factor, float units, float clamp) {
            var _F = _GetProc<GLNativeDelegate.FNglPolygonOffsetClampEXT>("glPolygonOffsetClampEXT");
            _F(factor, units, clamp);
        }

        #endregion GL_EXT_polygon_offset_clamp

        #region GL_EXT_provoking_vertex

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_provoking_vertex</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glProvokingVertexEXT(GLenum mode);</para>
        /// </summary>
        public static void glProvokingVertexEXT(uint mode) {
            var _F = _GetProc<GLNativeDelegate.FNglProvokingVertexEXT>("glProvokingVertexEXT");
            _F(mode);
        }

        #endregion GL_EXT_provoking_vertex

        #region GL_EXT_raster_multisample

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_raster_multisample, GL_NV_framebuffer_mixed_samples</para>
        /// Supported: <para>gl, glcore, gles2, gl, glcore, gles2</para>
        /// Original: <para>void glRasterSamplesEXT(GLuint samples, GLboolean fixedsamplelocations);</para>
        /// </summary>
        public static void glRasterSamplesEXT(uint samples, bool fixedsamplelocations) {
            var _F = _GetProc<GLNativeDelegate.FNglRasterSamplesEXT>("glRasterSamplesEXT");
            _F(samples, fixedsamplelocations);
        }

        #endregion GL_EXT_raster_multisample

        #region GL_EXT_semaphore

        // void glGetUnsignedBytevEXT(GLenum pname, GLubyte * data);
        // void glGetUnsignedBytei_vEXT(GLenum target, GLuint index, GLubyte * data);
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_semaphore</para>
        /// Supported: <para>gl, gles2</para>
        /// Original: <para>void glGenSemaphoresEXT(GLsizei n, GLuint * semaphores);</para>
        /// </summary>
        public unsafe static void glGenSemaphoresEXT(int n, uint* semaphores) {
            var _F = _GetProc<GLNativeDelegate.FNglGenSemaphoresEXT>("glGenSemaphoresEXT");
            _F(n, semaphores);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_semaphore</para>
        /// Supported: <para>gl, gles2</para>
        /// Original: <para>void glDeleteSemaphoresEXT(GLsizei n, const GLuint * semaphores);</para>
        /// </summary>
        public unsafe static void glDeleteSemaphoresEXT(int n, uint* semaphores) {
            var _F = _GetProc<GLNativeDelegate.FNglDeleteSemaphoresEXT>("glDeleteSemaphoresEXT");
            _F(n, semaphores);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_semaphore</para>
        /// Supported: <para>gl, gles2</para>
        /// Original: <para>GLboolean glIsSemaphoreEXT(GLuint semaphore);</para>
        /// </summary>
        public static bool glIsSemaphoreEXT(uint semaphore) {
            var _F = _GetProc<GLNativeDelegate.FNglIsSemaphoreEXT>("glIsSemaphoreEXT");
            return _F(semaphore);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_semaphore</para>
        /// Supported: <para>gl, gles2</para>
        /// Original: <para>void glSemaphoreParameterui64vEXT(GLuint semaphore, GLenum pname, const GLuint64 * params);</para>
        /// </summary>
        public unsafe static void glSemaphoreParameterui64vEXT(uint semaphore, uint pname, UInt64* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglSemaphoreParameterui64vEXT>("glSemaphoreParameterui64vEXT");
            _F(semaphore, pname, ps);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_semaphore</para>
        /// Supported: <para>gl, gles2</para>
        /// Original: <para>void glGetSemaphoreParameterui64vEXT(GLuint semaphore, GLenum pname, GLuint64 * params);</para>
        /// </summary>
        public unsafe static void glGetSemaphoreParameterui64vEXT(uint semaphore, uint pname, UInt64* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetSemaphoreParameterui64vEXT>("glGetSemaphoreParameterui64vEXT");
            _F(semaphore, pname, ps);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_semaphore</para>
        /// Supported: <para>gl, gles2</para>
        /// Original: <para>void glWaitSemaphoreEXT(GLuint semaphore, GLuint numBufferBarriers, const GLuint * buffers, GLuint numTextureBarriers, const GLuint * textures, const GLenum * srcLayouts);</para>
        /// </summary>
        public unsafe static void glWaitSemaphoreEXT(uint semaphore, uint numBufferBarriers, uint* buffers, uint numTextureBarriers, uint* textures, uint* srcLayouts) {
            var _F = _GetProc<GLNativeDelegate.FNglWaitSemaphoreEXT>("glWaitSemaphoreEXT");
            _F(semaphore, numBufferBarriers, buffers, numTextureBarriers, textures, srcLayouts);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_semaphore</para>
        /// Supported: <para>gl, gles2</para>
        /// Original: <para>void glSignalSemaphoreEXT(GLuint semaphore, GLuint numBufferBarriers, const GLuint * buffers, GLuint numTextureBarriers, const GLuint * textures, const GLenum * dstLayouts);</para>
        /// </summary>
        public unsafe static void glSignalSemaphoreEXT(uint semaphore, uint numBufferBarriers, uint* buffers, uint numTextureBarriers, uint* textures, uint* dstLayouts) {
            var _F = _GetProc<GLNativeDelegate.FNglSignalSemaphoreEXT>("glSignalSemaphoreEXT");
            _F(semaphore, numBufferBarriers, buffers, numTextureBarriers, textures, dstLayouts);
        }

        #endregion GL_EXT_semaphore

        #region GL_EXT_semaphore_fd

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_semaphore_fd</para>
        /// Supported: <para>gl, gles2</para>
        /// Original: <para>void glImportSemaphoreFdEXT(GLuint semaphore, GLenum handleType, GLint fd);</para>
        /// </summary>
        public static void glImportSemaphoreFdEXT(uint semaphore, uint handleType, int fd) {
            var _F = _GetProc<GLNativeDelegate.FNglImportSemaphoreFdEXT>("glImportSemaphoreFdEXT");
            _F(semaphore, handleType, fd);
        }

        #endregion GL_EXT_semaphore_fd

        #region GL_EXT_semaphore_win32

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_semaphore_win32</para>
        /// Supported: <para>gl, gles2</para>
        /// Original: <para>void glImportSemaphoreWin32HandleEXT(GLuint semaphore, GLenum handleType, void * handle);</para>
        /// </summary>
        public unsafe static void glImportSemaphoreWin32HandleEXT(uint semaphore, uint handleType, void* handle) {
            var _F = _GetProc<GLNativeDelegate.FNglImportSemaphoreWin32HandleEXT>("glImportSemaphoreWin32HandleEXT");
            _F(semaphore, handleType, handle);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_semaphore_win32</para>
        /// Supported: <para>gl, gles2</para>
        /// Original: <para>void glImportSemaphoreWin32NameEXT(GLuint semaphore, GLenum handleType, const void * name);</para>
        /// </summary>
        public unsafe static void glImportSemaphoreWin32NameEXT(uint semaphore, uint handleType, void* name) {
            var _F = _GetProc<GLNativeDelegate.FNglImportSemaphoreWin32NameEXT>("glImportSemaphoreWin32NameEXT");
            _F(semaphore, handleType, name);
        }

        #endregion GL_EXT_semaphore_win32

        #region GL_EXT_secondary_color

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_secondary_color</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glSecondaryColor3bEXT(GLbyte red, GLbyte green, GLbyte blue);</para>
        /// </summary>
        public static void glSecondaryColor3bEXT(byte red, byte green, byte blue) {
            var _F = _GetProc<GLNativeDelegate.FNglSecondaryColor3bEXT>("glSecondaryColor3bEXT");
            _F(red, green, blue);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_secondary_color</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glSecondaryColor3bvEXT(const GLbyte * v);</para>
        /// </summary>
        public unsafe static void glSecondaryColor3bvEXT(byte* v) {
            var _F = _GetProc<GLNativeDelegate.FNglSecondaryColor3bvEXT>("glSecondaryColor3bvEXT");
            _F(v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_secondary_color</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glSecondaryColor3dEXT(GLdouble red, GLdouble green, GLdouble blue);</para>
        /// </summary>
        public static void glSecondaryColor3dEXT(double red, double green, double blue) {
            var _F = _GetProc<GLNativeDelegate.FNglSecondaryColor3dEXT>("glSecondaryColor3dEXT");
            _F(red, green, blue);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_secondary_color</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glSecondaryColor3dvEXT(const GLdouble * v);</para>
        /// </summary>
        public unsafe static void glSecondaryColor3dvEXT(double* v) {
            var _F = _GetProc<GLNativeDelegate.FNglSecondaryColor3dvEXT>("glSecondaryColor3dvEXT");
            _F(v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_secondary_color</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glSecondaryColor3fEXT(GLfloat red, GLfloat green, GLfloat blue);</para>
        /// </summary>
        public static void glSecondaryColor3fEXT(float red, float green, float blue) {
            var _F = _GetProc<GLNativeDelegate.FNglSecondaryColor3fEXT>("glSecondaryColor3fEXT");
            _F(red, green, blue);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_secondary_color</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glSecondaryColor3fvEXT(const GLfloat * v);</para>
        /// </summary>
        public unsafe static void glSecondaryColor3fvEXT(float* v) {
            var _F = _GetProc<GLNativeDelegate.FNglSecondaryColor3fvEXT>("glSecondaryColor3fvEXT");
            _F(v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_secondary_color</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glSecondaryColor3iEXT(GLint red, GLint green, GLint blue);</para>
        /// </summary>
        public static void glSecondaryColor3iEXT(int red, int green, int blue) {
            var _F = _GetProc<GLNativeDelegate.FNglSecondaryColor3iEXT>("glSecondaryColor3iEXT");
            _F(red, green, blue);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_secondary_color</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glSecondaryColor3ivEXT(const GLint * v);</para>
        /// </summary>
        public unsafe static void glSecondaryColor3ivEXT(int* v) {
            var _F = _GetProc<GLNativeDelegate.FNglSecondaryColor3ivEXT>("glSecondaryColor3ivEXT");
            _F(v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_secondary_color</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glSecondaryColor3sEXT(GLshort red, GLshort green, GLshort blue);</para>
        /// </summary>
        public static void glSecondaryColor3sEXT(short red, short green, short blue) {
            var _F = _GetProc<GLNativeDelegate.FNglSecondaryColor3sEXT>("glSecondaryColor3sEXT");
            _F(red, green, blue);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_secondary_color</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glSecondaryColor3svEXT(const GLshort * v);</para>
        /// </summary>
        public unsafe static void glSecondaryColor3svEXT(short* v) {
            var _F = _GetProc<GLNativeDelegate.FNglSecondaryColor3svEXT>("glSecondaryColor3svEXT");
            _F(v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_secondary_color</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glSecondaryColor3ubEXT(GLubyte red, GLubyte green, GLubyte blue);</para>
        /// </summary>
        public static void glSecondaryColor3ubEXT(byte red, byte green, byte blue) {
            var _F = _GetProc<GLNativeDelegate.FNglSecondaryColor3ubEXT>("glSecondaryColor3ubEXT");
            _F(red, green, blue);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_secondary_color</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glSecondaryColor3ubvEXT(const GLubyte * v);</para>
        /// </summary>
        public unsafe static void glSecondaryColor3ubvEXT(byte* v) {
            var _F = _GetProc<GLNativeDelegate.FNglSecondaryColor3ubvEXT>("glSecondaryColor3ubvEXT");
            _F(v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_secondary_color</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glSecondaryColor3uiEXT(GLuint red, GLuint green, GLuint blue);</para>
        /// </summary>
        public static void glSecondaryColor3uiEXT(uint red, uint green, uint blue) {
            var _F = _GetProc<GLNativeDelegate.FNglSecondaryColor3uiEXT>("glSecondaryColor3uiEXT");
            _F(red, green, blue);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_secondary_color</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glSecondaryColor3uivEXT(const GLuint * v);</para>
        /// </summary>
        public unsafe static void glSecondaryColor3uivEXT(uint* v) {
            var _F = _GetProc<GLNativeDelegate.FNglSecondaryColor3uivEXT>("glSecondaryColor3uivEXT");
            _F(v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_secondary_color</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glSecondaryColor3usEXT(GLushort red, GLushort green, GLushort blue);</para>
        /// </summary>
        public static void glSecondaryColor3usEXT(ushort red, ushort green, ushort blue) {
            var _F = _GetProc<GLNativeDelegate.FNglSecondaryColor3usEXT>("glSecondaryColor3usEXT");
            _F(red, green, blue);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_secondary_color</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glSecondaryColor3usvEXT(const GLushort * v);</para>
        /// </summary>
        public unsafe static void glSecondaryColor3usvEXT(ushort* v) {
            var _F = _GetProc<GLNativeDelegate.FNglSecondaryColor3usvEXT>("glSecondaryColor3usvEXT");
            _F(v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_secondary_color</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glSecondaryColorPointerEXT(GLint size, GLenum type, GLsizei stride, const void * pointer);</para>
        /// </summary>
        public unsafe static void glSecondaryColorPointerEXT(int size, uint type, int stride, void* pointer) {
            var _F = _GetProc<GLNativeDelegate.FNglSecondaryColorPointerEXT>("glSecondaryColorPointerEXT");
            _F(size, type, stride, pointer);
        }

        #endregion GL_EXT_secondary_color

        #region GL_EXT_separate_shader_objects

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_separate_shader_objects</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glUseShaderProgramEXT(GLenum type, GLuint program);</para>
        /// </summary>
        public static void glUseShaderProgramEXT(uint type, uint program) {
            var _F = _GetProc<GLNativeDelegate.FNglUseShaderProgramEXT>("glUseShaderProgramEXT");
            _F(type, program);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_separate_shader_objects</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glActiveProgramEXT(GLuint program);</para>
        /// </summary>
        public static void glActiveProgramEXT(uint program) {
            var _F = _GetProc<GLNativeDelegate.FNglActiveProgramEXT>("glActiveProgramEXT");
            _F(program);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_separate_shader_objects</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>GLuint glCreateShaderProgramEXT(GLenum type, const GLchar * string);</para>
        /// </summary>
        public unsafe static uint glCreateShaderProgramEXT(uint type, byte* str) {
            var _F = _GetProc<GLNativeDelegate.FNglCreateShaderProgramEXT>("glCreateShaderProgramEXT");
            return _F(type, str);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_separate_shader_objects</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glActiveShaderProgramEXT(GLuint pipeline, GLuint program);</para>
        /// </summary>
        public static void glActiveShaderProgramEXT(uint pipeline, uint program) {
            var _F = _GetProc<GLNativeDelegate.FNglActiveShaderProgramEXT>("glActiveShaderProgramEXT");
            _F(pipeline, program);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_separate_shader_objects</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glBindProgramPipelineEXT(GLuint pipeline);</para>
        /// </summary>
        public static void glBindProgramPipelineEXT(uint pipeline) {
            var _F = _GetProc<GLNativeDelegate.FNglBindProgramPipelineEXT>("glBindProgramPipelineEXT");
            _F(pipeline);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_separate_shader_objects</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>GLuint glCreateShaderProgramvEXT(GLenum type, GLsizei count, const GLchar ** strings);</para>
        /// </summary>
        public unsafe static uint glCreateShaderProgramvEXT(uint type, int count, byte** strings) {
            var _F = _GetProc<GLNativeDelegate.FNglCreateShaderProgramvEXT>("glCreateShaderProgramvEXT");
            return _F(type, count, strings);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_separate_shader_objects</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glDeleteProgramPipelinesEXT(GLsizei n, const GLuint * pipelines);</para>
        /// </summary>
        public unsafe static void glDeleteProgramPipelinesEXT(int n, uint* pipelines) {
            var _F = _GetProc<GLNativeDelegate.FNglDeleteProgramPipelinesEXT>("glDeleteProgramPipelinesEXT");
            _F(n, pipelines);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_separate_shader_objects</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glGenProgramPipelinesEXT(GLsizei n, GLuint * pipelines);</para>
        /// </summary>
        public unsafe static void glGenProgramPipelinesEXT(int n, uint* pipelines) {
            var _F = _GetProc<GLNativeDelegate.FNglGenProgramPipelinesEXT>("glGenProgramPipelinesEXT");
            _F(n, pipelines);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_separate_shader_objects</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glGetProgramPipelineInfoLogEXT(GLuint pipeline, GLsizei bufSize, GLsizei * length, GLchar * infoLog);</para>
        /// </summary>
        public unsafe static void glGetProgramPipelineInfoLogEXT(uint pipeline, int bufSize, int* length, byte* infoLog) {
            var _F = _GetProc<GLNativeDelegate.FNglGetProgramPipelineInfoLogEXT>("glGetProgramPipelineInfoLogEXT");
            _F(pipeline, bufSize, length, infoLog);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_separate_shader_objects</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glGetProgramPipelineivEXT(GLuint pipeline, GLenum pname, GLint * params);</para>
        /// </summary>
        public unsafe static void glGetProgramPipelineivEXT(uint pipeline, uint pname, int* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetProgramPipelineivEXT>("glGetProgramPipelineivEXT");
            _F(pipeline, pname, ps);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_separate_shader_objects</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>GLboolean glIsProgramPipelineEXT(GLuint pipeline);</para>
        /// </summary>
        public static bool glIsProgramPipelineEXT(uint pipeline) {
            var _F = _GetProc<GLNativeDelegate.FNglIsProgramPipelineEXT>("glIsProgramPipelineEXT");
            return _F(pipeline);
        }
        // void glProgramParameteriEXT(GLuint program, GLenum pname, GLint value);
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_direct_state_access, GL_EXT_separate_shader_objects</para>
        /// Supported: <para>gl, glcore, gl, glcore, gles2</para>
        /// Original: <para>void glProgramUniform1fEXT(GLuint program, GLint location, GLfloat v0);</para>
        /// </summary>
        public static void glProgramUniform1fEXT(uint program, int location, float v0) {
            var _F = _GetProc<GLNativeDelegate.FNglProgramUniform1fEXT>("glProgramUniform1fEXT");
            _F(program, location, v0);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_direct_state_access, GL_EXT_separate_shader_objects</para>
        /// Supported: <para>gl, glcore, gl, glcore, gles2</para>
        /// Original: <para>void glProgramUniform1fvEXT(GLuint program, GLint location, GLsizei count, const GLfloat * value);</para>
        /// </summary>
        public unsafe static void glProgramUniform1fvEXT(uint program, int location, int count, float* value) {
            var _F = _GetProc<GLNativeDelegate.FNglProgramUniform1fvEXT>("glProgramUniform1fvEXT");
            _F(program, location, count, value);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_direct_state_access, GL_EXT_separate_shader_objects</para>
        /// Supported: <para>gl, glcore, gl, glcore, gles2</para>
        /// Original: <para>void glProgramUniform1iEXT(GLuint program, GLint location, GLint v0);</para>
        /// </summary>
        public static void glProgramUniform1iEXT(uint program, int location, int v0) {
            var _F = _GetProc<GLNativeDelegate.FNglProgramUniform1iEXT>("glProgramUniform1iEXT");
            _F(program, location, v0);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_direct_state_access, GL_EXT_separate_shader_objects</para>
        /// Supported: <para>gl, glcore, gl, glcore, gles2</para>
        /// Original: <para>void glProgramUniform1ivEXT(GLuint program, GLint location, GLsizei count, const GLint * value);</para>
        /// </summary>
        public unsafe static void glProgramUniform1ivEXT(uint program, int location, int count, int* value) {
            var _F = _GetProc<GLNativeDelegate.FNglProgramUniform1ivEXT>("glProgramUniform1ivEXT");
            _F(program, location, count, value);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_direct_state_access, GL_EXT_separate_shader_objects</para>
        /// Supported: <para>gl, glcore, gl, glcore, gles2</para>
        /// Original: <para>void glProgramUniform2fEXT(GLuint program, GLint location, GLfloat v0, GLfloat v1);</para>
        /// </summary>
        public static void glProgramUniform2fEXT(uint program, int location, float v0, float v1) {
            var _F = _GetProc<GLNativeDelegate.FNglProgramUniform2fEXT>("glProgramUniform2fEXT");
            _F(program, location, v0, v1);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_direct_state_access, GL_EXT_separate_shader_objects</para>
        /// Supported: <para>gl, glcore, gl, glcore, gles2</para>
        /// Original: <para>void glProgramUniform2fvEXT(GLuint program, GLint location, GLsizei count, const GLfloat * value);</para>
        /// </summary>
        public unsafe static void glProgramUniform2fvEXT(uint program, int location, int count, float* value) {
            var _F = _GetProc<GLNativeDelegate.FNglProgramUniform2fvEXT>("glProgramUniform2fvEXT");
            _F(program, location, count, value);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_direct_state_access, GL_EXT_separate_shader_objects</para>
        /// Supported: <para>gl, glcore, gl, glcore, gles2</para>
        /// Original: <para>void glProgramUniform2iEXT(GLuint program, GLint location, GLint v0, GLint v1);</para>
        /// </summary>
        public static void glProgramUniform2iEXT(uint program, int location, int v0, int v1) {
            var _F = _GetProc<GLNativeDelegate.FNglProgramUniform2iEXT>("glProgramUniform2iEXT");
            _F(program, location, v0, v1);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_direct_state_access, GL_EXT_separate_shader_objects</para>
        /// Supported: <para>gl, glcore, gl, glcore, gles2</para>
        /// Original: <para>void glProgramUniform2ivEXT(GLuint program, GLint location, GLsizei count, const GLint * value);</para>
        /// </summary>
        public unsafe static void glProgramUniform2ivEXT(uint program, int location, int count, int* value) {
            var _F = _GetProc<GLNativeDelegate.FNglProgramUniform2ivEXT>("glProgramUniform2ivEXT");
            _F(program, location, count, value);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_direct_state_access, GL_EXT_separate_shader_objects</para>
        /// Supported: <para>gl, glcore, gl, glcore, gles2</para>
        /// Original: <para>void glProgramUniform3fEXT(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2);</para>
        /// </summary>
        public static void glProgramUniform3fEXT(uint program, int location, float v0, float v1, float v2) {
            var _F = _GetProc<GLNativeDelegate.FNglProgramUniform3fEXT>("glProgramUniform3fEXT");
            _F(program, location, v0, v1, v2);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_direct_state_access, GL_EXT_separate_shader_objects</para>
        /// Supported: <para>gl, glcore, gl, glcore, gles2</para>
        /// Original: <para>void glProgramUniform3fvEXT(GLuint program, GLint location, GLsizei count, const GLfloat * value);</para>
        /// </summary>
        public unsafe static void glProgramUniform3fvEXT(uint program, int location, int count, float* value) {
            var _F = _GetProc<GLNativeDelegate.FNglProgramUniform3fvEXT>("glProgramUniform3fvEXT");
            _F(program, location, count, value);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_direct_state_access, GL_EXT_separate_shader_objects</para>
        /// Supported: <para>gl, glcore, gl, glcore, gles2</para>
        /// Original: <para>void glProgramUniform3iEXT(GLuint program, GLint location, GLint v0, GLint v1, GLint v2);</para>
        /// </summary>
        public static void glProgramUniform3iEXT(uint program, int location, int v0, int v1, int v2) {
            var _F = _GetProc<GLNativeDelegate.FNglProgramUniform3iEXT>("glProgramUniform3iEXT");
            _F(program, location, v0, v1, v2);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_direct_state_access, GL_EXT_separate_shader_objects</para>
        /// Supported: <para>gl, glcore, gl, glcore, gles2</para>
        /// Original: <para>void glProgramUniform3ivEXT(GLuint program, GLint location, GLsizei count, const GLint * value);</para>
        /// </summary>
        public unsafe static void glProgramUniform3ivEXT(uint program, int location, int count, int* value) {
            var _F = _GetProc<GLNativeDelegate.FNglProgramUniform3ivEXT>("glProgramUniform3ivEXT");
            _F(program, location, count, value);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_direct_state_access, GL_EXT_separate_shader_objects</para>
        /// Supported: <para>gl, glcore, gl, glcore, gles2</para>
        /// Original: <para>void glProgramUniform4fEXT(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3);</para>
        /// </summary>
        public static void glProgramUniform4fEXT(uint program, int location, float v0, float v1, float v2, float v3) {
            var _F = _GetProc<GLNativeDelegate.FNglProgramUniform4fEXT>("glProgramUniform4fEXT");
            _F(program, location, v0, v1, v2, v3);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_direct_state_access, GL_EXT_separate_shader_objects</para>
        /// Supported: <para>gl, glcore, gl, glcore, gles2</para>
        /// Original: <para>void glProgramUniform4fvEXT(GLuint program, GLint location, GLsizei count, const GLfloat * value);</para>
        /// </summary>
        public unsafe static void glProgramUniform4fvEXT(uint program, int location, int count, float* value) {
            var _F = _GetProc<GLNativeDelegate.FNglProgramUniform4fvEXT>("glProgramUniform4fvEXT");
            _F(program, location, count, value);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_direct_state_access, GL_EXT_separate_shader_objects</para>
        /// Supported: <para>gl, glcore, gl, glcore, gles2</para>
        /// Original: <para>void glProgramUniform4iEXT(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3);</para>
        /// </summary>
        public static void glProgramUniform4iEXT(uint program, int location, int v0, int v1, int v2, int v3) {
            var _F = _GetProc<GLNativeDelegate.FNglProgramUniform4iEXT>("glProgramUniform4iEXT");
            _F(program, location, v0, v1, v2, v3);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_direct_state_access, GL_EXT_separate_shader_objects</para>
        /// Supported: <para>gl, glcore, gl, glcore, gles2</para>
        /// Original: <para>void glProgramUniform4ivEXT(GLuint program, GLint location, GLsizei count, const GLint * value);</para>
        /// </summary>
        public unsafe static void glProgramUniform4ivEXT(uint program, int location, int count, int* value) {
            var _F = _GetProc<GLNativeDelegate.FNglProgramUniform4ivEXT>("glProgramUniform4ivEXT");
            _F(program, location, count, value);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_direct_state_access, GL_EXT_separate_shader_objects</para>
        /// Supported: <para>gl, glcore, gl, glcore, gles2</para>
        /// Original: <para>void glProgramUniformMatrix2fvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);</para>
        /// </summary>
        public unsafe static void glProgramUniformMatrix2fvEXT(uint program, int location, int count, bool transpose, float* value) {
            var _F = _GetProc<GLNativeDelegate.FNglProgramUniformMatrix2fvEXT>("glProgramUniformMatrix2fvEXT");
            _F(program, location, count, transpose, value);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_direct_state_access, GL_EXT_separate_shader_objects</para>
        /// Supported: <para>gl, glcore, gl, glcore, gles2</para>
        /// Original: <para>void glProgramUniformMatrix3fvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);</para>
        /// </summary>
        public unsafe static void glProgramUniformMatrix3fvEXT(uint program, int location, int count, bool transpose, float* value) {
            var _F = _GetProc<GLNativeDelegate.FNglProgramUniformMatrix3fvEXT>("glProgramUniformMatrix3fvEXT");
            _F(program, location, count, transpose, value);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_direct_state_access, GL_EXT_separate_shader_objects</para>
        /// Supported: <para>gl, glcore, gl, glcore, gles2</para>
        /// Original: <para>void glProgramUniformMatrix4fvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);</para>
        /// </summary>
        public unsafe static void glProgramUniformMatrix4fvEXT(uint program, int location, int count, bool transpose, float* value) {
            var _F = _GetProc<GLNativeDelegate.FNglProgramUniformMatrix4fvEXT>("glProgramUniformMatrix4fvEXT");
            _F(program, location, count, transpose, value);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_separate_shader_objects</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glUseProgramStagesEXT(GLuint pipeline, GLbitfield stages, GLuint program);</para>
        /// </summary>
        public static void glUseProgramStagesEXT(uint pipeline, uint stages, uint program) {
            var _F = _GetProc<GLNativeDelegate.FNglUseProgramStagesEXT>("glUseProgramStagesEXT");
            _F(pipeline, stages, program);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_separate_shader_objects</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glValidateProgramPipelineEXT(GLuint pipeline);</para>
        /// </summary>
        public static void glValidateProgramPipelineEXT(uint pipeline) {
            var _F = _GetProc<GLNativeDelegate.FNglValidateProgramPipelineEXT>("glValidateProgramPipelineEXT");
            _F(pipeline);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_direct_state_access, GL_EXT_separate_shader_objects</para>
        /// Supported: <para>gl, glcore, gl, glcore, gles2</para>
        /// Original: <para>void glProgramUniform1uiEXT(GLuint program, GLint location, GLuint v0);</para>
        /// </summary>
        public static void glProgramUniform1uiEXT(uint program, int location, uint v0) {
            var _F = _GetProc<GLNativeDelegate.FNglProgramUniform1uiEXT>("glProgramUniform1uiEXT");
            _F(program, location, v0);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_direct_state_access, GL_EXT_separate_shader_objects</para>
        /// Supported: <para>gl, glcore, gl, glcore, gles2</para>
        /// Original: <para>void glProgramUniform2uiEXT(GLuint program, GLint location, GLuint v0, GLuint v1);</para>
        /// </summary>
        public static void glProgramUniform2uiEXT(uint program, int location, uint v0, uint v1) {
            var _F = _GetProc<GLNativeDelegate.FNglProgramUniform2uiEXT>("glProgramUniform2uiEXT");
            _F(program, location, v0, v1);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_direct_state_access, GL_EXT_separate_shader_objects</para>
        /// Supported: <para>gl, glcore, gl, glcore, gles2</para>
        /// Original: <para>void glProgramUniform3uiEXT(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2);</para>
        /// </summary>
        public static void glProgramUniform3uiEXT(uint program, int location, uint v0, uint v1, uint v2) {
            var _F = _GetProc<GLNativeDelegate.FNglProgramUniform3uiEXT>("glProgramUniform3uiEXT");
            _F(program, location, v0, v1, v2);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_direct_state_access, GL_EXT_separate_shader_objects</para>
        /// Supported: <para>gl, glcore, gl, glcore, gles2</para>
        /// Original: <para>void glProgramUniform4uiEXT(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3);</para>
        /// </summary>
        public static void glProgramUniform4uiEXT(uint program, int location, uint v0, uint v1, uint v2, uint v3) {
            var _F = _GetProc<GLNativeDelegate.FNglProgramUniform4uiEXT>("glProgramUniform4uiEXT");
            _F(program, location, v0, v1, v2, v3);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_direct_state_access, GL_EXT_separate_shader_objects</para>
        /// Supported: <para>gl, glcore, gl, glcore, gles2</para>
        /// Original: <para>void glProgramUniform1uivEXT(GLuint program, GLint location, GLsizei count, const GLuint * value);</para>
        /// </summary>
        public unsafe static void glProgramUniform1uivEXT(uint program, int location, int count, uint* value) {
            var _F = _GetProc<GLNativeDelegate.FNglProgramUniform1uivEXT>("glProgramUniform1uivEXT");
            _F(program, location, count, value);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_direct_state_access, GL_EXT_separate_shader_objects</para>
        /// Supported: <para>gl, glcore, gl, glcore, gles2</para>
        /// Original: <para>void glProgramUniform2uivEXT(GLuint program, GLint location, GLsizei count, const GLuint * value);</para>
        /// </summary>
        public unsafe static void glProgramUniform2uivEXT(uint program, int location, int count, uint* value) {
            var _F = _GetProc<GLNativeDelegate.FNglProgramUniform2uivEXT>("glProgramUniform2uivEXT");
            _F(program, location, count, value);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_direct_state_access, GL_EXT_separate_shader_objects</para>
        /// Supported: <para>gl, glcore, gl, glcore, gles2</para>
        /// Original: <para>void glProgramUniform3uivEXT(GLuint program, GLint location, GLsizei count, const GLuint * value);</para>
        /// </summary>
        public unsafe static void glProgramUniform3uivEXT(uint program, int location, int count, uint* value) {
            var _F = _GetProc<GLNativeDelegate.FNglProgramUniform3uivEXT>("glProgramUniform3uivEXT");
            _F(program, location, count, value);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_direct_state_access, GL_EXT_separate_shader_objects</para>
        /// Supported: <para>gl, glcore, gl, glcore, gles2</para>
        /// Original: <para>void glProgramUniform4uivEXT(GLuint program, GLint location, GLsizei count, const GLuint * value);</para>
        /// </summary>
        public unsafe static void glProgramUniform4uivEXT(uint program, int location, int count, uint* value) {
            var _F = _GetProc<GLNativeDelegate.FNglProgramUniform4uivEXT>("glProgramUniform4uivEXT");
            _F(program, location, count, value);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_direct_state_access, GL_EXT_separate_shader_objects</para>
        /// Supported: <para>gl, glcore, gl, glcore, gles2</para>
        /// Original: <para>void glProgramUniformMatrix2x3fvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);</para>
        /// </summary>
        public unsafe static void glProgramUniformMatrix2x3fvEXT(uint program, int location, int count, bool transpose, float* value) {
            var _F = _GetProc<GLNativeDelegate.FNglProgramUniformMatrix2x3fvEXT>("glProgramUniformMatrix2x3fvEXT");
            _F(program, location, count, transpose, value);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_direct_state_access, GL_EXT_separate_shader_objects</para>
        /// Supported: <para>gl, glcore, gl, glcore, gles2</para>
        /// Original: <para>void glProgramUniformMatrix3x2fvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);</para>
        /// </summary>
        public unsafe static void glProgramUniformMatrix3x2fvEXT(uint program, int location, int count, bool transpose, float* value) {
            var _F = _GetProc<GLNativeDelegate.FNglProgramUniformMatrix3x2fvEXT>("glProgramUniformMatrix3x2fvEXT");
            _F(program, location, count, transpose, value);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_direct_state_access, GL_EXT_separate_shader_objects</para>
        /// Supported: <para>gl, glcore, gl, glcore, gles2</para>
        /// Original: <para>void glProgramUniformMatrix2x4fvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);</para>
        /// </summary>
        public unsafe static void glProgramUniformMatrix2x4fvEXT(uint program, int location, int count, bool transpose, float* value) {
            var _F = _GetProc<GLNativeDelegate.FNglProgramUniformMatrix2x4fvEXT>("glProgramUniformMatrix2x4fvEXT");
            _F(program, location, count, transpose, value);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_direct_state_access, GL_EXT_separate_shader_objects</para>
        /// Supported: <para>gl, glcore, gl, glcore, gles2</para>
        /// Original: <para>void glProgramUniformMatrix4x2fvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);</para>
        /// </summary>
        public unsafe static void glProgramUniformMatrix4x2fvEXT(uint program, int location, int count, bool transpose, float* value) {
            var _F = _GetProc<GLNativeDelegate.FNglProgramUniformMatrix4x2fvEXT>("glProgramUniformMatrix4x2fvEXT");
            _F(program, location, count, transpose, value);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_direct_state_access, GL_EXT_separate_shader_objects</para>
        /// Supported: <para>gl, glcore, gl, glcore, gles2</para>
        /// Original: <para>void glProgramUniformMatrix3x4fvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);</para>
        /// </summary>
        public unsafe static void glProgramUniformMatrix3x4fvEXT(uint program, int location, int count, bool transpose, float* value) {
            var _F = _GetProc<GLNativeDelegate.FNglProgramUniformMatrix3x4fvEXT>("glProgramUniformMatrix3x4fvEXT");
            _F(program, location, count, transpose, value);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_direct_state_access, GL_EXT_separate_shader_objects</para>
        /// Supported: <para>gl, glcore, gl, glcore, gles2</para>
        /// Original: <para>void glProgramUniformMatrix4x3fvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);</para>
        /// </summary>
        public unsafe static void glProgramUniformMatrix4x3fvEXT(uint program, int location, int count, bool transpose, float* value) {
            var _F = _GetProc<GLNativeDelegate.FNglProgramUniformMatrix4x3fvEXT>("glProgramUniformMatrix4x3fvEXT");
            _F(program, location, count, transpose, value);
        }

        #endregion GL_EXT_separate_shader_objects

        #region GL_EXT_shader_framebuffer_fetch_non_coherent

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_shader_framebuffer_fetch_non_coherent</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glFramebufferFetchBarrierEXT();</para>
        /// </summary>
        public static void glFramebufferFetchBarrierEXT() {
            var _F = _GetProc<GLNativeDelegate.FNglFramebufferFetchBarrierEXT>("glFramebufferFetchBarrierEXT");
            _F();
        }

        #endregion GL_EXT_shader_framebuffer_fetch_non_coherent

        #region GL_EXT_shader_image_load_store

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_shader_image_load_store</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glBindImageTextureEXT(GLuint index, GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum access, GLint format);</para>
        /// </summary>
        public static void glBindImageTextureEXT(uint index, uint texture, int level, bool layered, int layer, uint access, int format) {
            var _F = _GetProc<GLNativeDelegate.FNglBindImageTextureEXT>("glBindImageTextureEXT");
            _F(index, texture, level, layered, layer, access, format);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_shader_image_load_store</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glMemoryBarrierEXT(GLbitfield barriers);</para>
        /// </summary>
        public static void glMemoryBarrierEXT(uint barriers) {
            var _F = _GetProc<GLNativeDelegate.FNglMemoryBarrierEXT>("glMemoryBarrierEXT");
            _F(barriers);
        }

        #endregion GL_EXT_shader_image_load_store

        #region GL_EXT_stencil_clear_tag

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_stencil_clear_tag</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glStencilClearTagEXT(GLsizei stencilTagBits, GLuint stencilClearTag);</para>
        /// </summary>
        public static void glStencilClearTagEXT(int stencilTagBits, uint stencilClearTag) {
            var _F = _GetProc<GLNativeDelegate.FNglStencilClearTagEXT>("glStencilClearTagEXT");
            _F(stencilTagBits, stencilClearTag);
        }

        #endregion GL_EXT_stencil_clear_tag

        #region GL_EXT_stencil_two_side

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_stencil_two_side</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glActiveStencilFaceEXT(GLenum face);</para>
        /// </summary>
        public static void glActiveStencilFaceEXT(uint face) {
            var _F = _GetProc<GLNativeDelegate.FNglActiveStencilFaceEXT>("glActiveStencilFaceEXT");
            _F(face);
        }

        #endregion GL_EXT_stencil_two_side

        #region GL_EXT_subtexture

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_subtexture</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glTexSubImage1DEXT(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const void * pixels);</para>
        /// </summary>
        public unsafe static void glTexSubImage1DEXT(uint target, int level, int xoffset, int width, uint format, uint type, void* pixels) {
            var _F = _GetProc<GLNativeDelegate.FNglTexSubImage1DEXT>("glTexSubImage1DEXT");
            _F(target, level, xoffset, width, format, type, pixels);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_subtexture</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glTexSubImage2DEXT(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const void * pixels);</para>
        /// </summary>
        public unsafe static void glTexSubImage2DEXT(uint target, int level, int xoffset, int yoffset, int width, int height, uint format, uint type, void* pixels) {
            var _F = _GetProc<GLNativeDelegate.FNglTexSubImage2DEXT>("glTexSubImage2DEXT");
            _F(target, level, xoffset, yoffset, width, height, format, type, pixels);
        }

        #endregion GL_EXT_subtexture

        #region GL_EXT_texture3D

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_texture3D</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glTexImage3DEXT(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const void * pixels);</para>
        /// </summary>
        public unsafe static void glTexImage3DEXT(uint target, int level, uint internalformat, int width, int height, int depth, int border, uint format, uint type, void* pixels) {
            var _F = _GetProc<GLNativeDelegate.FNglTexImage3DEXT>("glTexImage3DEXT");
            _F(target, level, internalformat, width, height, depth, border, format, type, pixels);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_texture3D</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glTexSubImage3DEXT(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void * pixels);</para>
        /// </summary>
        public unsafe static void glTexSubImage3DEXT(uint target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, uint format, uint type, void* pixels) {
            var _F = _GetProc<GLNativeDelegate.FNglTexSubImage3DEXT>("glTexSubImage3DEXT");
            _F(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels);
        }

        #endregion GL_EXT_texture3D

        #region GL_EXT_texture_array

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_texture_array, GL_NV_geometry_program4</para>
        /// Supported: <para>gl, gl</para>
        /// Original: <para>void glFramebufferTextureLayerEXT(GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer);</para>
        /// </summary>
        public static void glFramebufferTextureLayerEXT(uint target, uint attachment, uint texture, int level, int layer) {
            var _F = _GetProc<GLNativeDelegate.FNglFramebufferTextureLayerEXT>("glFramebufferTextureLayerEXT");
            _F(target, attachment, texture, level, layer);
        }

        #endregion GL_EXT_texture_array

        #region GL_EXT_texture_buffer_object

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_texture_buffer, GL_EXT_texture_buffer_object</para>
        /// Supported: <para>gles2, gl</para>
        /// Original: <para>void glTexBufferEXT(GLenum target, GLenum internalformat, GLuint buffer);</para>
        /// </summary>
        public static void glTexBufferEXT(uint target, uint internalformat, uint buffer) {
            var _F = _GetProc<GLNativeDelegate.FNglTexBufferEXT>("glTexBufferEXT");
            _F(target, internalformat, buffer);
        }

        #endregion GL_EXT_texture_buffer_object

        #region GL_EXT_texture_integer

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_texture_border_clamp, GL_EXT_texture_integer</para>
        /// Supported: <para>gles2, gl</para>
        /// Original: <para>void glTexParameterIivEXT(GLenum target, GLenum pname, const GLint * params);</para>
        /// </summary>
        public unsafe static void glTexParameterIivEXT(uint target, uint pname, int* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglTexParameterIivEXT>("glTexParameterIivEXT");
            _F(target, pname, ps);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_texture_border_clamp, GL_EXT_texture_integer</para>
        /// Supported: <para>gles2, gl</para>
        /// Original: <para>void glTexParameterIuivEXT(GLenum target, GLenum pname, const GLuint * params);</para>
        /// </summary>
        public unsafe static void glTexParameterIuivEXT(uint target, uint pname, uint* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglTexParameterIuivEXT>("glTexParameterIuivEXT");
            _F(target, pname, ps);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_texture_border_clamp, GL_EXT_texture_integer</para>
        /// Supported: <para>gles2, gl</para>
        /// Original: <para>void glGetTexParameterIivEXT(GLenum target, GLenum pname, GLint * params);</para>
        /// </summary>
        public unsafe static void glGetTexParameterIivEXT(uint target, uint pname, int* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetTexParameterIivEXT>("glGetTexParameterIivEXT");
            _F(target, pname, ps);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_texture_border_clamp, GL_EXT_texture_integer</para>
        /// Supported: <para>gles2, gl</para>
        /// Original: <para>void glGetTexParameterIuivEXT(GLenum target, GLenum pname, GLuint * params);</para>
        /// </summary>
        public unsafe static void glGetTexParameterIuivEXT(uint target, uint pname, uint* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetTexParameterIuivEXT>("glGetTexParameterIuivEXT");
            _F(target, pname, ps);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_texture_integer</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glClearColorIiEXT(GLint red, GLint green, GLint blue, GLint alpha);</para>
        /// </summary>
        public static void glClearColorIiEXT(int red, int green, int blue, int alpha) {
            var _F = _GetProc<GLNativeDelegate.FNglClearColorIiEXT>("glClearColorIiEXT");
            _F(red, green, blue, alpha);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_texture_integer</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glClearColorIuiEXT(GLuint red, GLuint green, GLuint blue, GLuint alpha);</para>
        /// </summary>
        public static void glClearColorIuiEXT(uint red, uint green, uint blue, uint alpha) {
            var _F = _GetProc<GLNativeDelegate.FNglClearColorIuiEXT>("glClearColorIuiEXT");
            _F(red, green, blue, alpha);
        }

        #endregion GL_EXT_texture_integer

        #region GL_EXT_texture_object

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_texture_object</para>
        /// Supported: <para>gl</para>
        /// Original: <para>GLboolean glAreTexturesResidentEXT(GLsizei n, const GLuint * textures, GLboolean * residences);</para>
        /// </summary>
        public unsafe static bool glAreTexturesResidentEXT(int n, uint* textures, bool* residences) {
            var _F = _GetProc<GLNativeDelegate.FNglAreTexturesResidentEXT>("glAreTexturesResidentEXT");
            return _F(n, textures, residences);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_texture_object</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glBindTextureEXT(GLenum target, GLuint texture);</para>
        /// </summary>
        public static void glBindTextureEXT(uint target, uint texture) {
            var _F = _GetProc<GLNativeDelegate.FNglBindTextureEXT>("glBindTextureEXT");
            _F(target, texture);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_texture_object</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glDeleteTexturesEXT(GLsizei n, const GLuint * textures);</para>
        /// </summary>
        public unsafe static void glDeleteTexturesEXT(int n, uint* textures) {
            var _F = _GetProc<GLNativeDelegate.FNglDeleteTexturesEXT>("glDeleteTexturesEXT");
            _F(n, textures);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_texture_object</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGenTexturesEXT(GLsizei n, GLuint * textures);</para>
        /// </summary>
        public unsafe static void glGenTexturesEXT(int n, uint* textures) {
            var _F = _GetProc<GLNativeDelegate.FNglGenTexturesEXT>("glGenTexturesEXT");
            _F(n, textures);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_texture_object</para>
        /// Supported: <para>gl</para>
        /// Original: <para>GLboolean glIsTextureEXT(GLuint texture);</para>
        /// </summary>
        public static bool glIsTextureEXT(uint texture) {
            var _F = _GetProc<GLNativeDelegate.FNglIsTextureEXT>("glIsTextureEXT");
            return _F(texture);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_texture_object</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glPrioritizeTexturesEXT(GLsizei n, const GLuint * textures, const GLclampf * priorities);</para>
        /// </summary>
        public unsafe static void glPrioritizeTexturesEXT(int n, uint* textures, float* priorities) {
            var _F = _GetProc<GLNativeDelegate.FNglPrioritizeTexturesEXT>("glPrioritizeTexturesEXT");
            _F(n, textures, priorities);
        }

        #endregion GL_EXT_texture_object

        #region GL_EXT_texture_perturb_normal

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_texture_perturb_normal</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glTextureNormalEXT(GLenum mode);</para>
        /// </summary>
        public static void glTextureNormalEXT(uint mode) {
            var _F = _GetProc<GLNativeDelegate.FNglTextureNormalEXT>("glTextureNormalEXT");
            _F(mode);
        }

        #endregion GL_EXT_texture_perturb_normal

        #region GL_EXT_texture_storage

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_texture_storage</para>
        /// Supported: <para>gles1, gles2, gl, glcore</para>
        /// Original: <para>void glTexStorage1DEXT(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width);</para>
        /// </summary>
        public static void glTexStorage1DEXT(uint target, int levels, uint internalformat, int width) {
            var _F = _GetProc<GLNativeDelegate.FNglTexStorage1DEXT>("glTexStorage1DEXT");
            _F(target, levels, internalformat, width);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_texture_storage</para>
        /// Supported: <para>gles1, gles2, gl, glcore</para>
        /// Original: <para>void glTexStorage2DEXT(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height);</para>
        /// </summary>
        public static void glTexStorage2DEXT(uint target, int levels, uint internalformat, int width, int height) {
            var _F = _GetProc<GLNativeDelegate.FNglTexStorage2DEXT>("glTexStorage2DEXT");
            _F(target, levels, internalformat, width, height);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_texture_storage</para>
        /// Supported: <para>gles1, gles2, gl, glcore</para>
        /// Original: <para>void glTexStorage3DEXT(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth);</para>
        /// </summary>
        public static void glTexStorage3DEXT(uint target, int levels, uint internalformat, int width, int height, int depth) {
            var _F = _GetProc<GLNativeDelegate.FNglTexStorage3DEXT>("glTexStorage3DEXT");
            _F(target, levels, internalformat, width, height, depth);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_direct_state_access, GL_EXT_texture_storage</para>
        /// Supported: <para>gl, glcore, gles1, gles2, gl, glcore</para>
        /// Original: <para>void glTextureStorage1DEXT(GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width);</para>
        /// </summary>
        public static void glTextureStorage1DEXT(uint texture, uint target, int levels, uint internalformat, int width) {
            var _F = _GetProc<GLNativeDelegate.FNglTextureStorage1DEXT>("glTextureStorage1DEXT");
            _F(texture, target, levels, internalformat, width);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_direct_state_access, GL_EXT_texture_storage</para>
        /// Supported: <para>gl, glcore, gles1, gles2, gl, glcore</para>
        /// Original: <para>void glTextureStorage2DEXT(GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height);</para>
        /// </summary>
        public static void glTextureStorage2DEXT(uint texture, uint target, int levels, uint internalformat, int width, int height) {
            var _F = _GetProc<GLNativeDelegate.FNglTextureStorage2DEXT>("glTextureStorage2DEXT");
            _F(texture, target, levels, internalformat, width, height);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_direct_state_access, GL_EXT_texture_storage</para>
        /// Supported: <para>gl, glcore, gles1, gles2, gl, glcore</para>
        /// Original: <para>void glTextureStorage3DEXT(GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth);</para>
        /// </summary>
        public static void glTextureStorage3DEXT(uint texture, uint target, int levels, uint internalformat, int width, int height, int depth) {
            var _F = _GetProc<GLNativeDelegate.FNglTextureStorage3DEXT>("glTextureStorage3DEXT");
            _F(texture, target, levels, internalformat, width, height, depth);
        }

        #endregion GL_EXT_texture_storage

        #region GL_NV_timeline_semaphore

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_timeline_semaphore</para>
        /// Supported: <para>gl, gles2</para>
        /// Original: <para>void glCreateSemaphoresNV(GLsizei n, GLuint * semaphores);</para>
        /// </summary>
        public unsafe static void glCreateSemaphoresNV(int n, uint* semaphores) {
            var _F = _GetProc<GLNativeDelegate.FNglCreateSemaphoresNV>("glCreateSemaphoresNV");
            _F(n, semaphores);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_timeline_semaphore</para>
        /// Supported: <para>gl, gles2</para>
        /// Original: <para>void glSemaphoreParameterivNV(GLuint semaphore, GLenum pname, const GLint * params);</para>
        /// </summary>
        public unsafe static void glSemaphoreParameterivNV(uint semaphore, uint pname, int* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglSemaphoreParameterivNV>("glSemaphoreParameterivNV");
            _F(semaphore, pname, ps);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_timeline_semaphore</para>
        /// Supported: <para>gl, gles2</para>
        /// Original: <para>void glGetSemaphoreParameterivNV(GLuint semaphore, GLenum pname, GLint * params);</para>
        /// </summary>
        public unsafe static void glGetSemaphoreParameterivNV(uint semaphore, uint pname, int* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetSemaphoreParameterivNV>("glGetSemaphoreParameterivNV");
            _F(semaphore, pname, ps);
        }

        #endregion GL_NV_timeline_semaphore

        #region GL_EXT_timer_query

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_disjoint_timer_query, GL_EXT_timer_query</para>
        /// Supported: <para>gles2, gl</para>
        /// Original: <para>void glGetQueryObjecti64vEXT(GLuint id, GLenum pname, GLint64 * params);</para>
        /// </summary>
        public unsafe static void glGetQueryObjecti64vEXT(uint id, uint pname, UInt64* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetQueryObjecti64vEXT>("glGetQueryObjecti64vEXT");
            _F(id, pname, ps);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_disjoint_timer_query, GL_EXT_timer_query</para>
        /// Supported: <para>gles2, gl</para>
        /// Original: <para>void glGetQueryObjectui64vEXT(GLuint id, GLenum pname, GLuint64 * params);</para>
        /// </summary>
        public unsafe static void glGetQueryObjectui64vEXT(uint id, uint pname, UInt64* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetQueryObjectui64vEXT>("glGetQueryObjectui64vEXT");
            _F(id, pname, ps);
        }

        #endregion GL_EXT_timer_query

        #region GL_EXT_transform_feedback

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_transform_feedback</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glBeginTransformFeedbackEXT(GLenum primitiveMode);</para>
        /// </summary>
        public static void glBeginTransformFeedbackEXT(uint primitiveMode) {
            var _F = _GetProc<GLNativeDelegate.FNglBeginTransformFeedbackEXT>("glBeginTransformFeedbackEXT");
            _F(primitiveMode);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_transform_feedback</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glEndTransformFeedbackEXT();</para>
        /// </summary>
        public static void glEndTransformFeedbackEXT() {
            var _F = _GetProc<GLNativeDelegate.FNglEndTransformFeedbackEXT>("glEndTransformFeedbackEXT");
            _F();
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_transform_feedback</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glBindBufferRangeEXT(GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size);</para>
        /// </summary>
        public static void glBindBufferRangeEXT(uint target, uint index, uint buffer, IntPtr offset, IntPtr size) {
            var _F = _GetProc<GLNativeDelegate.FNglBindBufferRangeEXT>("glBindBufferRangeEXT");
            _F(target, index, buffer, offset, size);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_transform_feedback</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glBindBufferOffsetEXT(GLenum target, GLuint index, GLuint buffer, GLintptr offset);</para>
        /// </summary>
        public static void glBindBufferOffsetEXT(uint target, uint index, uint buffer, IntPtr offset) {
            var _F = _GetProc<GLNativeDelegate.FNglBindBufferOffsetEXT>("glBindBufferOffsetEXT");
            _F(target, index, buffer, offset);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_transform_feedback</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glBindBufferBaseEXT(GLenum target, GLuint index, GLuint buffer);</para>
        /// </summary>
        public static void glBindBufferBaseEXT(uint target, uint index, uint buffer) {
            var _F = _GetProc<GLNativeDelegate.FNglBindBufferBaseEXT>("glBindBufferBaseEXT");
            _F(target, index, buffer);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_transform_feedback</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glTransformFeedbackVaryingsEXT(GLuint program, GLsizei count, const GLchar *const* varyings, GLenum bufferMode);</para>
        /// </summary>
        public unsafe static void glTransformFeedbackVaryingsEXT(uint program, int count, byte** varyings, uint bufferMode) {
            var _F = _GetProc<GLNativeDelegate.FNglTransformFeedbackVaryingsEXT>("glTransformFeedbackVaryingsEXT");
            _F(program, count, varyings, bufferMode);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_transform_feedback</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetTransformFeedbackVaryingEXT(GLuint program, GLuint index, GLsizei bufSize, GLsizei * length, GLsizei * size, GLenum * type, GLchar * name);</para>
        /// </summary>
        public unsafe static void glGetTransformFeedbackVaryingEXT(uint program, uint index, int bufSize, int* length, int* size, uint* type, byte* name) {
            var _F = _GetProc<GLNativeDelegate.FNglGetTransformFeedbackVaryingEXT>("glGetTransformFeedbackVaryingEXT");
            _F(program, index, bufSize, length, size, type, name);
        }

        #endregion GL_EXT_transform_feedback

        #region GL_EXT_vertex_array

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_vertex_array</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glArrayElementEXT(GLint i);</para>
        /// </summary>
        public static void glArrayElementEXT(int i) {
            var _F = _GetProc<GLNativeDelegate.FNglArrayElementEXT>("glArrayElementEXT");
            _F(i);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_vertex_array</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glColorPointerEXT(GLint size, GLenum type, GLsizei stride, GLsizei count, const void * pointer);</para>
        /// </summary>
        public unsafe static void glColorPointerEXT(int size, uint type, int stride, int count, void* pointer) {
            var _F = _GetProc<GLNativeDelegate.FNglColorPointerEXT>("glColorPointerEXT");
            _F(size, type, stride, count, pointer);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_vertex_array</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glDrawArraysEXT(GLenum mode, GLint first, GLsizei count);</para>
        /// </summary>
        public static void glDrawArraysEXT(uint mode, int first, int count) {
            var _F = _GetProc<GLNativeDelegate.FNglDrawArraysEXT>("glDrawArraysEXT");
            _F(mode, first, count);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_vertex_array</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glEdgeFlagPointerEXT(GLsizei stride, GLsizei count, const GLboolean * pointer);</para>
        /// </summary>
        public unsafe static void glEdgeFlagPointerEXT(int stride, int count, bool* pointer) {
            var _F = _GetProc<GLNativeDelegate.FNglEdgeFlagPointerEXT>("glEdgeFlagPointerEXT");
            _F(stride, count, pointer);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_vertex_array</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetPointervEXT(GLenum pname, void ** params);</para>
        /// </summary>
        public unsafe static void glGetPointervEXT(uint pname, void** ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetPointervEXT>("glGetPointervEXT");
            _F(pname, ps);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_vertex_array</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glIndexPointerEXT(GLenum type, GLsizei stride, GLsizei count, const void * pointer);</para>
        /// </summary>
        public unsafe static void glIndexPointerEXT(uint type, int stride, int count, void* pointer) {
            var _F = _GetProc<GLNativeDelegate.FNglIndexPointerEXT>("glIndexPointerEXT");
            _F(type, stride, count, pointer);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_vertex_array</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glNormalPointerEXT(GLenum type, GLsizei stride, GLsizei count, const void * pointer);</para>
        /// </summary>
        public unsafe static void glNormalPointerEXT(uint type, int stride, int count, void* pointer) {
            var _F = _GetProc<GLNativeDelegate.FNglNormalPointerEXT>("glNormalPointerEXT");
            _F(type, stride, count, pointer);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_vertex_array</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glTexCoordPointerEXT(GLint size, GLenum type, GLsizei stride, GLsizei count, const void * pointer);</para>
        /// </summary>
        public unsafe static void glTexCoordPointerEXT(int size, uint type, int stride, int count, void* pointer) {
            var _F = _GetProc<GLNativeDelegate.FNglTexCoordPointerEXT>("glTexCoordPointerEXT");
            _F(size, type, stride, count, pointer);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_vertex_array</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexPointerEXT(GLint size, GLenum type, GLsizei stride, GLsizei count, const void * pointer);</para>
        /// </summary>
        public unsafe static void glVertexPointerEXT(int size, uint type, int stride, int count, void* pointer) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexPointerEXT>("glVertexPointerEXT");
            _F(size, type, stride, count, pointer);
        }

        #endregion GL_EXT_vertex_array

        #region GL_EXT_vertex_attrib_64bit

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_vertex_attrib_64bit</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexAttribL1dEXT(GLuint index, GLdouble x);</para>
        /// </summary>
        public static void glVertexAttribL1dEXT(uint index, double x) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttribL1dEXT>("glVertexAttribL1dEXT");
            _F(index, x);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_vertex_attrib_64bit</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexAttribL2dEXT(GLuint index, GLdouble x, GLdouble y);</para>
        /// </summary>
        public static void glVertexAttribL2dEXT(uint index, double x, double y) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttribL2dEXT>("glVertexAttribL2dEXT");
            _F(index, x, y);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_vertex_attrib_64bit</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexAttribL3dEXT(GLuint index, GLdouble x, GLdouble y, GLdouble z);</para>
        /// </summary>
        public static void glVertexAttribL3dEXT(uint index, double x, double y, double z) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttribL3dEXT>("glVertexAttribL3dEXT");
            _F(index, x, y, z);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_vertex_attrib_64bit</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexAttribL4dEXT(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);</para>
        /// </summary>
        public static void glVertexAttribL4dEXT(uint index, double x, double y, double z, double w) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttribL4dEXT>("glVertexAttribL4dEXT");
            _F(index, x, y, z, w);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_vertex_attrib_64bit</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexAttribL1dvEXT(GLuint index, const GLdouble * v);</para>
        /// </summary>
        public unsafe static void glVertexAttribL1dvEXT(uint index, double* v) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttribL1dvEXT>("glVertexAttribL1dvEXT");
            _F(index, v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_vertex_attrib_64bit</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexAttribL2dvEXT(GLuint index, const GLdouble * v);</para>
        /// </summary>
        public unsafe static void glVertexAttribL2dvEXT(uint index, double* v) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttribL2dvEXT>("glVertexAttribL2dvEXT");
            _F(index, v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_vertex_attrib_64bit</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexAttribL3dvEXT(GLuint index, const GLdouble * v);</para>
        /// </summary>
        public unsafe static void glVertexAttribL3dvEXT(uint index, double* v) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttribL3dvEXT>("glVertexAttribL3dvEXT");
            _F(index, v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_vertex_attrib_64bit</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexAttribL4dvEXT(GLuint index, const GLdouble * v);</para>
        /// </summary>
        public unsafe static void glVertexAttribL4dvEXT(uint index, double* v) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttribL4dvEXT>("glVertexAttribL4dvEXT");
            _F(index, v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_vertex_attrib_64bit</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexAttribLPointerEXT(GLuint index, GLint size, GLenum type, GLsizei stride, const void * pointer);</para>
        /// </summary>
        public unsafe static void glVertexAttribLPointerEXT(uint index, int size, uint type, int stride, void* pointer) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttribLPointerEXT>("glVertexAttribLPointerEXT");
            _F(index, size, type, stride, pointer);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_vertex_attrib_64bit</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetVertexAttribLdvEXT(GLuint index, GLenum pname, GLdouble * params);</para>
        /// </summary>
        public unsafe static void glGetVertexAttribLdvEXT(uint index, uint pname, double* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetVertexAttribLdvEXT>("glGetVertexAttribLdvEXT");
            _F(index, pname, ps);
        }

        #endregion GL_EXT_vertex_attrib_64bit

        #region GL_EXT_vertex_shader

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_vertex_shader</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glBeginVertexShaderEXT();</para>
        /// </summary>
        public static void glBeginVertexShaderEXT() {
            var _F = _GetProc<GLNativeDelegate.FNglBeginVertexShaderEXT>("glBeginVertexShaderEXT");
            _F();
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_vertex_shader</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glEndVertexShaderEXT();</para>
        /// </summary>
        public static void glEndVertexShaderEXT() {
            var _F = _GetProc<GLNativeDelegate.FNglEndVertexShaderEXT>("glEndVertexShaderEXT");
            _F();
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_vertex_shader</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glBindVertexShaderEXT(GLuint id);</para>
        /// </summary>
        public static void glBindVertexShaderEXT(uint id) {
            var _F = _GetProc<GLNativeDelegate.FNglBindVertexShaderEXT>("glBindVertexShaderEXT");
            _F(id);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_vertex_shader</para>
        /// Supported: <para>gl</para>
        /// Original: <para>GLuint glGenVertexShadersEXT(GLuint range);</para>
        /// </summary>
        public static uint glGenVertexShadersEXT(uint range) {
            var _F = _GetProc<GLNativeDelegate.FNglGenVertexShadersEXT>("glGenVertexShadersEXT");
            return _F(range);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_vertex_shader</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glDeleteVertexShaderEXT(GLuint id);</para>
        /// </summary>
        public static void glDeleteVertexShaderEXT(uint id) {
            var _F = _GetProc<GLNativeDelegate.FNglDeleteVertexShaderEXT>("glDeleteVertexShaderEXT");
            _F(id);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_vertex_shader</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glShaderOp1EXT(GLenum op, GLuint res, GLuint arg1);</para>
        /// </summary>
        public static void glShaderOp1EXT(uint op, uint res, uint arg1) {
            var _F = _GetProc<GLNativeDelegate.FNglShaderOp1EXT>("glShaderOp1EXT");
            _F(op, res, arg1);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_vertex_shader</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glShaderOp2EXT(GLenum op, GLuint res, GLuint arg1, GLuint arg2);</para>
        /// </summary>
        public static void glShaderOp2EXT(uint op, uint res, uint arg1, uint arg2) {
            var _F = _GetProc<GLNativeDelegate.FNglShaderOp2EXT>("glShaderOp2EXT");
            _F(op, res, arg1, arg2);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_vertex_shader</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glShaderOp3EXT(GLenum op, GLuint res, GLuint arg1, GLuint arg2, GLuint arg3);</para>
        /// </summary>
        public static void glShaderOp3EXT(uint op, uint res, uint arg1, uint arg2, uint arg3) {
            var _F = _GetProc<GLNativeDelegate.FNglShaderOp3EXT>("glShaderOp3EXT");
            _F(op, res, arg1, arg2, arg3);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_vertex_shader</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glSwizzleEXT(GLuint res, GLuint in, GLenum outX, GLenum outY, GLenum outZ, GLenum outW);</para>
        /// </summary>
        public static void glSwizzleEXT(uint res, uint i, uint outX, uint outY, uint outZ, uint outW) {
            var _F = _GetProc<GLNativeDelegate.FNglSwizzleEXT>("glSwizzleEXT");
            _F(res, i, outX, outY, outZ, outW);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_vertex_shader</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glWriteMaskEXT(GLuint res, GLuint in, GLenum outX, GLenum outY, GLenum outZ, GLenum outW);</para>
        /// </summary>
        public static void glWriteMaskEXT(uint res, uint i, uint outX, uint outY, uint outZ, uint outW) {
            var _F = _GetProc<GLNativeDelegate.FNglWriteMaskEXT>("glWriteMaskEXT");
            _F(res, i, outX, outY, outZ, outW);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_vertex_shader</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glInsertComponentEXT(GLuint res, GLuint src, GLuint num);</para>
        /// </summary>
        public static void glInsertComponentEXT(uint res, uint src, uint num) {
            var _F = _GetProc<GLNativeDelegate.FNglInsertComponentEXT>("glInsertComponentEXT");
            _F(res, src, num);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_vertex_shader</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glExtractComponentEXT(GLuint res, GLuint src, GLuint num);</para>
        /// </summary>
        public static void glExtractComponentEXT(uint res, uint src, uint num) {
            var _F = _GetProc<GLNativeDelegate.FNglExtractComponentEXT>("glExtractComponentEXT");
            _F(res, src, num);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_vertex_shader</para>
        /// Supported: <para>gl</para>
        /// Original: <para>GLuint glGenSymbolsEXT(GLenum datatype, GLenum storagetype, GLenum range, GLuint components);</para>
        /// </summary>
        public static uint glGenSymbolsEXT(uint datatype, uint storagetype, uint range, uint components) {
            var _F = _GetProc<GLNativeDelegate.FNglGenSymbolsEXT>("glGenSymbolsEXT");
            return _F(datatype, storagetype, range, components);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_vertex_shader</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glSetInvariantEXT(GLuint id, GLenum type, const void * addr);</para>
        /// </summary>
        public unsafe static void glSetInvariantEXT(uint id, uint type, void* addr) {
            var _F = _GetProc<GLNativeDelegate.FNglSetInvariantEXT>("glSetInvariantEXT");
            _F(id, type, addr);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_vertex_shader</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glSetLocalConstantEXT(GLuint id, GLenum type, const void * addr);</para>
        /// </summary>
        public unsafe static void glSetLocalConstantEXT(uint id, uint type, void* addr) {
            var _F = _GetProc<GLNativeDelegate.FNglSetLocalConstantEXT>("glSetLocalConstantEXT");
            _F(id, type, addr);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_vertex_shader</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVariantbvEXT(GLuint id, const GLbyte * addr);</para>
        /// </summary>
        public unsafe static void glVariantbvEXT(uint id, byte* addr) {
            var _F = _GetProc<GLNativeDelegate.FNglVariantbvEXT>("glVariantbvEXT");
            _F(id, addr);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_vertex_shader</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVariantsvEXT(GLuint id, const GLshort * addr);</para>
        /// </summary>
        public unsafe static void glVariantsvEXT(uint id, short* addr) {
            var _F = _GetProc<GLNativeDelegate.FNglVariantsvEXT>("glVariantsvEXT");
            _F(id, addr);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_vertex_shader</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVariantivEXT(GLuint id, const GLint * addr);</para>
        /// </summary>
        public unsafe static void glVariantivEXT(uint id, int* addr) {
            var _F = _GetProc<GLNativeDelegate.FNglVariantivEXT>("glVariantivEXT");
            _F(id, addr);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_vertex_shader</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVariantfvEXT(GLuint id, const GLfloat * addr);</para>
        /// </summary>
        public unsafe static void glVariantfvEXT(uint id, float* addr) {
            var _F = _GetProc<GLNativeDelegate.FNglVariantfvEXT>("glVariantfvEXT");
            _F(id, addr);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_vertex_shader</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVariantdvEXT(GLuint id, const GLdouble * addr);</para>
        /// </summary>
        public unsafe static void glVariantdvEXT(uint id, double* addr) {
            var _F = _GetProc<GLNativeDelegate.FNglVariantdvEXT>("glVariantdvEXT");
            _F(id, addr);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_vertex_shader</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVariantubvEXT(GLuint id, const GLubyte * addr);</para>
        /// </summary>
        public unsafe static void glVariantubvEXT(uint id, byte* addr) {
            var _F = _GetProc<GLNativeDelegate.FNglVariantubvEXT>("glVariantubvEXT");
            _F(id, addr);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_vertex_shader</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVariantusvEXT(GLuint id, const GLushort * addr);</para>
        /// </summary>
        public unsafe static void glVariantusvEXT(uint id, ushort* addr) {
            var _F = _GetProc<GLNativeDelegate.FNglVariantusvEXT>("glVariantusvEXT");
            _F(id, addr);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_vertex_shader</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVariantuivEXT(GLuint id, const GLuint * addr);</para>
        /// </summary>
        public unsafe static void glVariantuivEXT(uint id, uint* addr) {
            var _F = _GetProc<GLNativeDelegate.FNglVariantuivEXT>("glVariantuivEXT");
            _F(id, addr);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_vertex_shader</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVariantPointerEXT(GLuint id, GLenum type, GLuint stride, const void * addr);</para>
        /// </summary>
        public unsafe static void glVariantPointerEXT(uint id, uint type, uint stride, void* addr) {
            var _F = _GetProc<GLNativeDelegate.FNglVariantPointerEXT>("glVariantPointerEXT");
            _F(id, type, stride, addr);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_vertex_shader</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glEnableVariantClientStateEXT(GLuint id);</para>
        /// </summary>
        public static void glEnableVariantClientStateEXT(uint id) {
            var _F = _GetProc<GLNativeDelegate.FNglEnableVariantClientStateEXT>("glEnableVariantClientStateEXT");
            _F(id);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_vertex_shader</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glDisableVariantClientStateEXT(GLuint id);</para>
        /// </summary>
        public static void glDisableVariantClientStateEXT(uint id) {
            var _F = _GetProc<GLNativeDelegate.FNglDisableVariantClientStateEXT>("glDisableVariantClientStateEXT");
            _F(id);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_vertex_shader</para>
        /// Supported: <para>gl</para>
        /// Original: <para>GLuint glBindLightParameterEXT(GLenum light, GLenum value);</para>
        /// </summary>
        public static uint glBindLightParameterEXT(uint light, uint value) {
            var _F = _GetProc<GLNativeDelegate.FNglBindLightParameterEXT>("glBindLightParameterEXT");
            return _F(light, value);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_vertex_shader</para>
        /// Supported: <para>gl</para>
        /// Original: <para>GLuint glBindMaterialParameterEXT(GLenum face, GLenum value);</para>
        /// </summary>
        public static uint glBindMaterialParameterEXT(uint face, uint value) {
            var _F = _GetProc<GLNativeDelegate.FNglBindMaterialParameterEXT>("glBindMaterialParameterEXT");
            return _F(face, value);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_vertex_shader</para>
        /// Supported: <para>gl</para>
        /// Original: <para>GLuint glBindTexGenParameterEXT(GLenum unit, GLenum coord, GLenum value);</para>
        /// </summary>
        public static uint glBindTexGenParameterEXT(uint unit, uint coord, uint value) {
            var _F = _GetProc<GLNativeDelegate.FNglBindTexGenParameterEXT>("glBindTexGenParameterEXT");
            return _F(unit, coord, value);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_vertex_shader</para>
        /// Supported: <para>gl</para>
        /// Original: <para>GLuint glBindTextureUnitParameterEXT(GLenum unit, GLenum value);</para>
        /// </summary>
        public static uint glBindTextureUnitParameterEXT(uint unit, uint value) {
            var _F = _GetProc<GLNativeDelegate.FNglBindTextureUnitParameterEXT>("glBindTextureUnitParameterEXT");
            return _F(unit, value);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_vertex_shader</para>
        /// Supported: <para>gl</para>
        /// Original: <para>GLuint glBindParameterEXT(GLenum value);</para>
        /// </summary>
        public static uint glBindParameterEXT(uint value) {
            var _F = _GetProc<GLNativeDelegate.FNglBindParameterEXT>("glBindParameterEXT");
            return _F(value);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_vertex_shader</para>
        /// Supported: <para>gl</para>
        /// Original: <para>GLboolean glIsVariantEnabledEXT(GLuint id, GLenum cap);</para>
        /// </summary>
        public static bool glIsVariantEnabledEXT(uint id, uint cap) {
            var _F = _GetProc<GLNativeDelegate.FNglIsVariantEnabledEXT>("glIsVariantEnabledEXT");
            return _F(id, cap);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_vertex_shader</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetVariantBooleanvEXT(GLuint id, GLenum value, GLboolean * data);</para>
        /// </summary>
        public unsafe static void glGetVariantBooleanvEXT(uint id, uint value, bool* data) {
            var _F = _GetProc<GLNativeDelegate.FNglGetVariantBooleanvEXT>("glGetVariantBooleanvEXT");
            _F(id, value, data);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_vertex_shader</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetVariantIntegervEXT(GLuint id, GLenum value, GLint * data);</para>
        /// </summary>
        public unsafe static void glGetVariantIntegervEXT(uint id, uint value, int* data) {
            var _F = _GetProc<GLNativeDelegate.FNglGetVariantIntegervEXT>("glGetVariantIntegervEXT");
            _F(id, value, data);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_vertex_shader</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetVariantFloatvEXT(GLuint id, GLenum value, GLfloat * data);</para>
        /// </summary>
        public unsafe static void glGetVariantFloatvEXT(uint id, uint value, float* data) {
            var _F = _GetProc<GLNativeDelegate.FNglGetVariantFloatvEXT>("glGetVariantFloatvEXT");
            _F(id, value, data);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_vertex_shader</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetVariantPointervEXT(GLuint id, GLenum value, void ** data);</para>
        /// </summary>
        public unsafe static void glGetVariantPointervEXT(uint id, uint value, void** data) {
            var _F = _GetProc<GLNativeDelegate.FNglGetVariantPointervEXT>("glGetVariantPointervEXT");
            _F(id, value, data);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_vertex_shader</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetInvariantBooleanvEXT(GLuint id, GLenum value, GLboolean * data);</para>
        /// </summary>
        public unsafe static void glGetInvariantBooleanvEXT(uint id, uint value, bool* data) {
            var _F = _GetProc<GLNativeDelegate.FNglGetInvariantBooleanvEXT>("glGetInvariantBooleanvEXT");
            _F(id, value, data);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_vertex_shader</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetInvariantIntegervEXT(GLuint id, GLenum value, GLint * data);</para>
        /// </summary>
        public unsafe static void glGetInvariantIntegervEXT(uint id, uint value, int* data) {
            var _F = _GetProc<GLNativeDelegate.FNglGetInvariantIntegervEXT>("glGetInvariantIntegervEXT");
            _F(id, value, data);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_vertex_shader</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetInvariantFloatvEXT(GLuint id, GLenum value, GLfloat * data);</para>
        /// </summary>
        public unsafe static void glGetInvariantFloatvEXT(uint id, uint value, float* data) {
            var _F = _GetProc<GLNativeDelegate.FNglGetInvariantFloatvEXT>("glGetInvariantFloatvEXT");
            _F(id, value, data);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_vertex_shader</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetLocalConstantBooleanvEXT(GLuint id, GLenum value, GLboolean * data);</para>
        /// </summary>
        public unsafe static void glGetLocalConstantBooleanvEXT(uint id, uint value, bool* data) {
            var _F = _GetProc<GLNativeDelegate.FNglGetLocalConstantBooleanvEXT>("glGetLocalConstantBooleanvEXT");
            _F(id, value, data);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_vertex_shader</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetLocalConstantIntegervEXT(GLuint id, GLenum value, GLint * data);</para>
        /// </summary>
        public unsafe static void glGetLocalConstantIntegervEXT(uint id, uint value, int* data) {
            var _F = _GetProc<GLNativeDelegate.FNglGetLocalConstantIntegervEXT>("glGetLocalConstantIntegervEXT");
            _F(id, value, data);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_vertex_shader</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetLocalConstantFloatvEXT(GLuint id, GLenum value, GLfloat * data);</para>
        /// </summary>
        public unsafe static void glGetLocalConstantFloatvEXT(uint id, uint value, float* data) {
            var _F = _GetProc<GLNativeDelegate.FNglGetLocalConstantFloatvEXT>("glGetLocalConstantFloatvEXT");
            _F(id, value, data);
        }

        #endregion GL_EXT_vertex_shader

        #region GL_EXT_vertex_weighting

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_vertex_weighting</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexWeightfEXT(GLfloat weight);</para>
        /// </summary>
        public static void glVertexWeightfEXT(float weight) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexWeightfEXT>("glVertexWeightfEXT");
            _F(weight);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_vertex_weighting</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexWeightfvEXT(const GLfloat * weight);</para>
        /// </summary>
        public unsafe static void glVertexWeightfvEXT(float* weight) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexWeightfvEXT>("glVertexWeightfvEXT");
            _F(weight);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_vertex_weighting</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexWeightPointerEXT(GLint size, GLenum type, GLsizei stride, const void * pointer);</para>
        /// </summary>
        public unsafe static void glVertexWeightPointerEXT(int size, uint type, int stride, void* pointer) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexWeightPointerEXT>("glVertexWeightPointerEXT");
            _F(size, type, stride, pointer);
        }

        #endregion GL_EXT_vertex_weighting

        #region GL_EXT_win32_keyed_mutex

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_win32_keyed_mutex</para>
        /// Supported: <para>gl, gles2</para>
        /// Original: <para>GLboolean glAcquireKeyedMutexWin32EXT(GLuint memory, GLuint64 key, GLuint timeout);</para>
        /// </summary>
        public static bool glAcquireKeyedMutexWin32EXT(uint memory, UInt64 key, uint timeout) {
            var _F = _GetProc<GLNativeDelegate.FNglAcquireKeyedMutexWin32EXT>("glAcquireKeyedMutexWin32EXT");
            return _F(memory, key, timeout);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_win32_keyed_mutex</para>
        /// Supported: <para>gl, gles2</para>
        /// Original: <para>GLboolean glReleaseKeyedMutexWin32EXT(GLuint memory, GLuint64 key);</para>
        /// </summary>
        public static bool glReleaseKeyedMutexWin32EXT(uint memory, UInt64 key) {
            var _F = _GetProc<GLNativeDelegate.FNglReleaseKeyedMutexWin32EXT>("glReleaseKeyedMutexWin32EXT");
            return _F(memory, key);
        }

        #endregion GL_EXT_win32_keyed_mutex

        #region GL_EXT_window_rectangles

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_window_rectangles</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glWindowRectanglesEXT(GLenum mode, GLsizei count, const GLint * box);</para>
        /// </summary>
        public unsafe static void glWindowRectanglesEXT(uint mode, int count, int* box) {
            var _F = _GetProc<GLNativeDelegate.FNglWindowRectanglesEXT>("glWindowRectanglesEXT");
            _F(mode, count, box);
        }

        #endregion GL_EXT_window_rectangles

        #region GL_EXT_x11_sync_object

        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_x11_sync_object</para>
        /// Supported: <para>gl</para>
        /// Original: <para>GLsync glImportSyncEXT(GLenum external_sync_type, GLintptr external_sync, GLbitfield flags);</para>
        /// </summary>
        public static IntPtr glImportSyncEXT(uint external_sync_type, IntPtr external_sync, uint flags) {
            var _F = _GetProc<GLNativeDelegate.FNglImportSyncEXT>("glImportSyncEXT");
            return _F(external_sync_type, external_sync, flags);
        }

        #endregion GL_EXT_x11_sync_object

        #region GL_GREMEDY_frame_terminator

        /// <summary>
        /// <para>Require:</para> <para>GL_GREMEDY_frame_terminator</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glFrameTerminatorGREMEDY();</para>
        /// </summary>
        public static void glFrameTerminatorGREMEDY() {
            var _F = _GetProc<GLNativeDelegate.FNglFrameTerminatorGREMEDY>("glFrameTerminatorGREMEDY");
            _F();
        }

        #endregion GL_GREMEDY_frame_terminator

        #region GL_GREMEDY_string_marker

        /// <summary>
        /// <para>Require:</para> <para>GL_GREMEDY_string_marker</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glStringMarkerGREMEDY(GLsizei len, const void * string);</para>
        /// </summary>
        public unsafe static void glStringMarkerGREMEDY(int len, void* str) {
            var _F = _GetProc<GLNativeDelegate.FNglStringMarkerGREMEDY>("glStringMarkerGREMEDY");
            _F(len, str);
        }

        #endregion GL_GREMEDY_string_marker

        #region GL_HP_image_transform

        /// <summary>
        /// <para>Require:</para> <para>GL_HP_image_transform</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glImageTransformParameteriHP(GLenum target, GLenum pname, GLint param);</para>
        /// </summary>
        public static void glImageTransformParameteriHP(uint target, uint pname, int param) {
            var _F = _GetProc<GLNativeDelegate.FNglImageTransformParameteriHP>("glImageTransformParameteriHP");
            _F(target, pname, param);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_HP_image_transform</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glImageTransformParameterfHP(GLenum target, GLenum pname, GLfloat param);</para>
        /// </summary>
        public static void glImageTransformParameterfHP(uint target, uint pname, float param) {
            var _F = _GetProc<GLNativeDelegate.FNglImageTransformParameterfHP>("glImageTransformParameterfHP");
            _F(target, pname, param);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_HP_image_transform</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glImageTransformParameterivHP(GLenum target, GLenum pname, const GLint * params);</para>
        /// </summary>
        public unsafe static void glImageTransformParameterivHP(uint target, uint pname, int* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglImageTransformParameterivHP>("glImageTransformParameterivHP");
            _F(target, pname, ps);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_HP_image_transform</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glImageTransformParameterfvHP(GLenum target, GLenum pname, const GLfloat * params);</para>
        /// </summary>
        public unsafe static void glImageTransformParameterfvHP(uint target, uint pname, float* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglImageTransformParameterfvHP>("glImageTransformParameterfvHP");
            _F(target, pname, ps);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_HP_image_transform</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetImageTransformParameterivHP(GLenum target, GLenum pname, GLint * params);</para>
        /// </summary>
        public unsafe static void glGetImageTransformParameterivHP(uint target, uint pname, int* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetImageTransformParameterivHP>("glGetImageTransformParameterivHP");
            _F(target, pname, ps);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_HP_image_transform</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetImageTransformParameterfvHP(GLenum target, GLenum pname, GLfloat * params);</para>
        /// </summary>
        public unsafe static void glGetImageTransformParameterfvHP(uint target, uint pname, float* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetImageTransformParameterfvHP>("glGetImageTransformParameterfvHP");
            _F(target, pname, ps);
        }

        #endregion GL_HP_image_transform

        #region GL_IBM_multimode_draw_arrays

        /// <summary>
        /// <para>Require:</para> <para>GL_IBM_multimode_draw_arrays</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glMultiModeDrawArraysIBM(const GLenum * mode, const GLint * first, const GLsizei * count, GLsizei primcount, GLint modestride);</para>
        /// </summary>
        public unsafe static void glMultiModeDrawArraysIBM(uint* mode, int* first, int* count, int primcount, int modestride) {
            var _F = _GetProc<GLNativeDelegate.FNglMultiModeDrawArraysIBM>("glMultiModeDrawArraysIBM");
            _F(mode, first, count, primcount, modestride);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_IBM_multimode_draw_arrays</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glMultiModeDrawElementsIBM(const GLenum * mode, const GLsizei * count, GLenum type, const void *const* indices, GLsizei primcount, GLint modestride);</para>
        /// </summary>
        public unsafe static void glMultiModeDrawElementsIBM(uint* mode, int* count, uint type, IntPtr indices, int primcount, int modestride) {
            var _F = _GetProc<GLNativeDelegate.FNglMultiModeDrawElementsIBM>("glMultiModeDrawElementsIBM");
            _F(mode, count, type, indices, primcount, modestride);
        }

        #endregion GL_IBM_multimode_draw_arrays

        #region GL_IBM_static_data

        /// <summary>
        /// <para>Require:</para> <para>GL_IBM_static_data</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glFlushStaticDataIBM(GLenum target);</para>
        /// </summary>
        public static void glFlushStaticDataIBM(uint target) {
            var _F = _GetProc<GLNativeDelegate.FNglFlushStaticDataIBM>("glFlushStaticDataIBM");
            _F(target);
        }

        #endregion GL_IBM_static_data

        #region GL_IBM_vertex_array_lists

        /// <summary>
        /// <para>Require:</para> <para>GL_IBM_vertex_array_lists</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glColorPointerListIBM(GLint size, GLenum type, GLint stride, const void ** pointer, GLint ptrstride);</para>
        /// </summary>
        public unsafe static void glColorPointerListIBM(int size, uint type, int stride, void** pointer, int ptrstride) {
            var _F = _GetProc<GLNativeDelegate.FNglColorPointerListIBM>("glColorPointerListIBM");
            _F(size, type, stride, pointer, ptrstride);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_IBM_vertex_array_lists</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glSecondaryColorPointerListIBM(GLint size, GLenum type, GLint stride, const void ** pointer, GLint ptrstride);</para>
        /// </summary>
        public unsafe static void glSecondaryColorPointerListIBM(int size, uint type, int stride, void** pointer, int ptrstride) {
            var _F = _GetProc<GLNativeDelegate.FNglSecondaryColorPointerListIBM>("glSecondaryColorPointerListIBM");
            _F(size, type, stride, pointer, ptrstride);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_IBM_vertex_array_lists</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glEdgeFlagPointerListIBM(GLint stride, const GLboolean ** pointer, GLint ptrstride);</para>
        /// </summary>
        public unsafe static void glEdgeFlagPointerListIBM(int stride, bool** pointer, int ptrstride) {
            var _F = _GetProc<GLNativeDelegate.FNglEdgeFlagPointerListIBM>("glEdgeFlagPointerListIBM");
            _F(stride, pointer, ptrstride);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_IBM_vertex_array_lists</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glFogCoordPointerListIBM(GLenum type, GLint stride, const void ** pointer, GLint ptrstride);</para>
        /// </summary>
        public unsafe static void glFogCoordPointerListIBM(uint type, int stride, void** pointer, int ptrstride) {
            var _F = _GetProc<GLNativeDelegate.FNglFogCoordPointerListIBM>("glFogCoordPointerListIBM");
            _F(type, stride, pointer, ptrstride);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_IBM_vertex_array_lists</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glIndexPointerListIBM(GLenum type, GLint stride, const void ** pointer, GLint ptrstride);</para>
        /// </summary>
        public unsafe static void glIndexPointerListIBM(uint type, int stride, void** pointer, int ptrstride) {
            var _F = _GetProc<GLNativeDelegate.FNglIndexPointerListIBM>("glIndexPointerListIBM");
            _F(type, stride, pointer, ptrstride);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_IBM_vertex_array_lists</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glNormalPointerListIBM(GLenum type, GLint stride, const void ** pointer, GLint ptrstride);</para>
        /// </summary>
        public unsafe static void glNormalPointerListIBM(uint type, int stride, void** pointer, int ptrstride) {
            var _F = _GetProc<GLNativeDelegate.FNglNormalPointerListIBM>("glNormalPointerListIBM");
            _F(type, stride, pointer, ptrstride);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_IBM_vertex_array_lists</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glTexCoordPointerListIBM(GLint size, GLenum type, GLint stride, const void ** pointer, GLint ptrstride);</para>
        /// </summary>
        public unsafe static void glTexCoordPointerListIBM(int size, uint type, int stride, void** pointer, int ptrstride) {
            var _F = _GetProc<GLNativeDelegate.FNglTexCoordPointerListIBM>("glTexCoordPointerListIBM");
            _F(size, type, stride, pointer, ptrstride);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_IBM_vertex_array_lists</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexPointerListIBM(GLint size, GLenum type, GLint stride, const void ** pointer, GLint ptrstride);</para>
        /// </summary>
        public unsafe static void glVertexPointerListIBM(int size, uint type, int stride, void** pointer, int ptrstride) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexPointerListIBM>("glVertexPointerListIBM");
            _F(size, type, stride, pointer, ptrstride);
        }

        #endregion GL_IBM_vertex_array_lists

        #region GL_INGR_blend_func_separate

        /// <summary>
        /// <para>Require:</para> <para>GL_INGR_blend_func_separate</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glBlendFuncSeparateINGR(GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha);</para>
        /// </summary>
        public static void glBlendFuncSeparateINGR(uint sfactorRGB, uint dfactorRGB, uint sfactorAlpha, uint dfactorAlpha) {
            var _F = _GetProc<GLNativeDelegate.FNglBlendFuncSeparateINGR>("glBlendFuncSeparateINGR");
            _F(sfactorRGB, dfactorRGB, sfactorAlpha, dfactorAlpha);
        }

        #endregion GL_INGR_blend_func_separate

        #region GL_INTEL_framebuffer_CMAA

        /// <summary>
        /// <para>Require:</para> <para>GL_INTEL_framebuffer_CMAA</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glApplyFramebufferAttachmentCMAAINTEL();</para>
        /// </summary>
        public static void glApplyFramebufferAttachmentCMAAINTEL() {
            var _F = _GetProc<GLNativeDelegate.FNglApplyFramebufferAttachmentCMAAINTEL>("glApplyFramebufferAttachmentCMAAINTEL");
            _F();
        }

        #endregion GL_INTEL_framebuffer_CMAA

        #region GL_INTEL_map_texture

        /// <summary>
        /// <para>Require:</para> <para>GL_INTEL_map_texture</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glSyncTextureINTEL(GLuint texture);</para>
        /// </summary>
        public static void glSyncTextureINTEL(uint texture) {
            var _F = _GetProc<GLNativeDelegate.FNglSyncTextureINTEL>("glSyncTextureINTEL");
            _F(texture);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_INTEL_map_texture</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glUnmapTexture2DINTEL(GLuint texture, GLint level);</para>
        /// </summary>
        public static void glUnmapTexture2DINTEL(uint texture, int level) {
            var _F = _GetProc<GLNativeDelegate.FNglUnmapTexture2DINTEL>("glUnmapTexture2DINTEL");
            _F(texture, level);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_INTEL_map_texture</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void * glMapTexture2DINTEL(GLuint texture, GLint level, GLbitfield access, GLint * stride, GLenum * layout);</para>
        /// </summary>
        public unsafe static void* glMapTexture2DINTEL(uint texture, int level, uint access, int* stride, uint* layout) {
            var _F = _GetProc<GLNativeDelegate.FNglMapTexture2DINTEL>("glMapTexture2DINTEL");
            return _F(texture, level, access, stride, layout);
        }

        #endregion GL_INTEL_map_texture

        #region GL_INTEL_parallel_arrays

        /// <summary>
        /// <para>Require:</para> <para>GL_INTEL_parallel_arrays</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexPointervINTEL(GLint size, GLenum type, const void ** pointer);</para>
        /// </summary>
        public unsafe static void glVertexPointervINTEL(int size, uint type, void** pointer) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexPointervINTEL>("glVertexPointervINTEL");
            _F(size, type, pointer);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_INTEL_parallel_arrays</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glNormalPointervINTEL(GLenum type, const void ** pointer);</para>
        /// </summary>
        public unsafe static void glNormalPointervINTEL(uint type, void** pointer) {
            var _F = _GetProc<GLNativeDelegate.FNglNormalPointervINTEL>("glNormalPointervINTEL");
            _F(type, pointer);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_INTEL_parallel_arrays</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glColorPointervINTEL(GLint size, GLenum type, const void ** pointer);</para>
        /// </summary>
        public unsafe static void glColorPointervINTEL(int size, uint type, void** pointer) {
            var _F = _GetProc<GLNativeDelegate.FNglColorPointervINTEL>("glColorPointervINTEL");
            _F(size, type, pointer);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_INTEL_parallel_arrays</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glTexCoordPointervINTEL(GLint size, GLenum type, const void ** pointer);</para>
        /// </summary>
        public unsafe static void glTexCoordPointervINTEL(int size, uint type, void** pointer) {
            var _F = _GetProc<GLNativeDelegate.FNglTexCoordPointervINTEL>("glTexCoordPointervINTEL");
            _F(size, type, pointer);
        }

        #endregion GL_INTEL_parallel_arrays

        #region GL_INTEL_performance_query

        /// <summary>
        /// <para>Require:</para> <para>GL_INTEL_performance_query</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glBeginPerfQueryINTEL(GLuint queryHandle);</para>
        /// </summary>
        public static void glBeginPerfQueryINTEL(uint queryHandle) {
            var _F = _GetProc<GLNativeDelegate.FNglBeginPerfQueryINTEL>("glBeginPerfQueryINTEL");
            _F(queryHandle);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_INTEL_performance_query</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glCreatePerfQueryINTEL(GLuint queryId, GLuint * queryHandle);</para>
        /// </summary>
        public unsafe static void glCreatePerfQueryINTEL(uint queryId, uint* queryHandle) {
            var _F = _GetProc<GLNativeDelegate.FNglCreatePerfQueryINTEL>("glCreatePerfQueryINTEL");
            _F(queryId, queryHandle);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_INTEL_performance_query</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glDeletePerfQueryINTEL(GLuint queryHandle);</para>
        /// </summary>
        public static void glDeletePerfQueryINTEL(uint queryHandle) {
            var _F = _GetProc<GLNativeDelegate.FNglDeletePerfQueryINTEL>("glDeletePerfQueryINTEL");
            _F(queryHandle);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_INTEL_performance_query</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glEndPerfQueryINTEL(GLuint queryHandle);</para>
        /// </summary>
        public static void glEndPerfQueryINTEL(uint queryHandle) {
            var _F = _GetProc<GLNativeDelegate.FNglEndPerfQueryINTEL>("glEndPerfQueryINTEL");
            _F(queryHandle);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_INTEL_performance_query</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glGetFirstPerfQueryIdINTEL(GLuint * queryId);</para>
        /// </summary>
        public unsafe static void glGetFirstPerfQueryIdINTEL(uint* queryId) {
            var _F = _GetProc<GLNativeDelegate.FNglGetFirstPerfQueryIdINTEL>("glGetFirstPerfQueryIdINTEL");
            _F(queryId);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_INTEL_performance_query</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glGetNextPerfQueryIdINTEL(GLuint queryId, GLuint * nextQueryId);</para>
        /// </summary>
        public unsafe static void glGetNextPerfQueryIdINTEL(uint queryId, uint* nextQueryId) {
            var _F = _GetProc<GLNativeDelegate.FNglGetNextPerfQueryIdINTEL>("glGetNextPerfQueryIdINTEL");
            _F(queryId, nextQueryId);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_INTEL_performance_query</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glGetPerfCounterInfoINTEL(GLuint queryId, GLuint counterId, GLuint counterNameLength, GLchar * counterName, GLuint counterDescLength, GLchar * counterDesc, GLuint * counterOffset, GLuint * counterDataSize, GLuint * counterTypeEnum, GLuint * counterDataTypeEnum, GLuint64 * rawCounterMaxValue);</para>
        /// </summary>
        public unsafe static void glGetPerfCounterInfoINTEL(uint queryId, uint counterId, uint counterNameLength, byte* counterName, uint counterDescLength, byte* counterDesc, uint* counterOffset, uint* counterDataSize, uint* counterTypeEnum, uint* counterDataTypeEnum, UInt64* rawCounterMaxValue) {
            var _F = _GetProc<GLNativeDelegate.FNglGetPerfCounterInfoINTEL>("glGetPerfCounterInfoINTEL");
            _F(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset, counterDataSize, counterTypeEnum, counterDataTypeEnum, rawCounterMaxValue);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_INTEL_performance_query</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glGetPerfQueryDataINTEL(GLuint queryHandle, GLuint flags, GLsizei dataSize, void * data, GLuint * bytesWritten);</para>
        /// </summary>
        public unsafe static void glGetPerfQueryDataINTEL(uint queryHandle, uint flags, int dataSize, void* data, uint* bytesWritten) {
            var _F = _GetProc<GLNativeDelegate.FNglGetPerfQueryDataINTEL>("glGetPerfQueryDataINTEL");
            _F(queryHandle, flags, dataSize, data, bytesWritten);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_INTEL_performance_query</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glGetPerfQueryIdByNameINTEL(GLchar * queryName, GLuint * queryId);</para>
        /// </summary>
        public unsafe static void glGetPerfQueryIdByNameINTEL(byte* queryName, uint* queryId) {
            var _F = _GetProc<GLNativeDelegate.FNglGetPerfQueryIdByNameINTEL>("glGetPerfQueryIdByNameINTEL");
            _F(queryName, queryId);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_INTEL_performance_query</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glGetPerfQueryInfoINTEL(GLuint queryId, GLuint queryNameLength, GLchar * queryName, GLuint * dataSize, GLuint * noCounters, GLuint * noInstances, GLuint * capsMask);</para>
        /// </summary>
        public unsafe static void glGetPerfQueryInfoINTEL(uint queryId, uint queryNameLength, byte* queryName, uint* dataSize, uint* noCounters, uint* noInstances, uint* capsMask) {
            var _F = _GetProc<GLNativeDelegate.FNglGetPerfQueryInfoINTEL>("glGetPerfQueryInfoINTEL");
            _F(queryId, queryNameLength, queryName, dataSize, noCounters, noInstances, capsMask);
        }

        #endregion GL_INTEL_performance_query

        #region GL_KHR_blend_equation_advanced

        /// <summary>
        /// <para>Require:</para> <para>GL_KHR_blend_equation_advanced</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glBlendBarrierKHR();</para>
        /// </summary>
        public static void glBlendBarrierKHR() {
            var _F = _GetProc<GLNativeDelegate.FNglBlendBarrierKHR>("glBlendBarrierKHR");
            _F();
        }

        #endregion GL_KHR_blend_equation_advanced

        #region GL_KHR_debug

        // void glDebugMessageControl(GLenum source, GLenum type, GLenum severity, GLsizei count, const GLuint * ids, GLboolean enabled);
        // void glDebugMessageInsert(GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const char * message);
        // void glDebugMessageCallback(GLDEBUGPROC callback, const void * userParam);
        // GLuint glGetDebugMessageLog(GLuint count, GLsizei bufSize, GLenum * sources, GLenum * types, GLuint * ids, GLenum * severities, GLsizei * lengths, GLchar * messageLog);
        // void glPushDebugGroup(GLenum source, GLuint id, GLsizei length, const char * message);
        // void glPopDebugGroup();
        // void glObjectLabel(GLenum identifier, GLuint name, GLsizei length, const char * label);
        // void glGetObjectLabel(GLenum identifier, GLuint name, GLsizei bufSize, GLsizei * length, char * label);
        // void glObjectPtrLabel(void * ptr, GLsizei length, const char * label);
        // void glGetObjectPtrLabel(void * ptr, GLsizei bufSize, GLsizei * length, char * label);
        // void glGetPointerv(GLenum pname, void ** ps);
        /// <summary>
        /// <para>Require:</para> <para>GL_KHR_debug</para>
        /// Supported: <para>gl, glcore, gles1, gles2</para>
        /// Original: <para>void glDebugMessageControlKHR(GLenum source, GLenum type, GLenum severity, GLsizei count, const GLuint * ids, GLboolean enabled);</para>
        /// </summary>
        public unsafe static void glDebugMessageControlKHR(uint source, uint type, uint severity, int count, uint* ids, bool enabled) {
            var _F = _GetProc<GLNativeDelegate.FNglDebugMessageControlKHR>("glDebugMessageControlKHR");
            _F(source, type, severity, count, ids, enabled);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_KHR_debug</para>
        /// Supported: <para>gl, glcore, gles1, gles2</para>
        /// Original: <para>void glDebugMessageInsertKHR(GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const GLchar * buf);</para>
        /// </summary>
        public unsafe static void glDebugMessageInsertKHR(uint source, uint type, uint id, uint severity, int length, byte* buf) {
            var _F = _GetProc<GLNativeDelegate.FNglDebugMessageInsertKHR>("glDebugMessageInsertKHR");
            _F(source, type, id, severity, length, buf);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_KHR_debug</para>
        /// Supported: <para>gl, glcore, gles1, gles2</para>
        /// Original: <para>void glDebugMessageCallbackKHR(GLDEBUGPROCKHR callback, const void * userParam);</para>
        /// </summary>
        public unsafe static void glDebugMessageCallbackKHR(GLNativeDelegate.GLDEBUGPROCKHR callback, void* userParam) {
            var _F = _GetProc<GLNativeDelegate.FNglDebugMessageCallbackKHR>("glDebugMessageCallbackKHR");
            _F(callback, userParam);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_KHR_debug</para>
        /// Supported: <para>gl, glcore, gles1, gles2</para>
        /// Original: <para>GLuint glGetDebugMessageLogKHR(GLuint count, GLsizei bufSize, GLenum * sources, GLenum * types, GLuint * ids, GLenum * severities, GLsizei * lengths, GLchar * messageLog);</para>
        /// </summary>
        public unsafe static uint glGetDebugMessageLogKHR(uint count, int bufSize, uint* sources, uint* types, uint* ids, uint* severities, int* lengths, byte* messageLog) {
            var _F = _GetProc<GLNativeDelegate.FNglGetDebugMessageLogKHR>("glGetDebugMessageLogKHR");
            return _F(count, bufSize, sources, types, ids, severities, lengths, messageLog);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_KHR_debug</para>
        /// Supported: <para>gl, glcore, gles1, gles2</para>
        /// Original: <para>void glPushDebugGroupKHR(GLenum source, GLuint id, GLsizei length, const GLchar * message);</para>
        /// </summary>
        public unsafe static void glPushDebugGroupKHR(uint source, uint id, int length, byte* message) {
            var _F = _GetProc<GLNativeDelegate.FNglPushDebugGroupKHR>("glPushDebugGroupKHR");
            _F(source, id, length, message);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_KHR_debug</para>
        /// Supported: <para>gl, glcore, gles1, gles2</para>
        /// Original: <para>void glPopDebugGroupKHR();</para>
        /// </summary>
        public static void glPopDebugGroupKHR() {
            var _F = _GetProc<GLNativeDelegate.FNglPopDebugGroupKHR>("glPopDebugGroupKHR");
            _F();
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_KHR_debug</para>
        /// Supported: <para>gl, glcore, gles1, gles2</para>
        /// Original: <para>void glObjectLabelKHR(GLenum identifier, GLuint name, GLsizei length, const GLchar * label);</para>
        /// </summary>
        public unsafe static void glObjectLabelKHR(uint identifier, uint name, int length, byte* label) {
            var _F = _GetProc<GLNativeDelegate.FNglObjectLabelKHR>("glObjectLabelKHR");
            _F(identifier, name, length, label);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_KHR_debug</para>
        /// Supported: <para>gl, glcore, gles1, gles2</para>
        /// Original: <para>void glGetObjectLabelKHR(GLenum identifier, GLuint name, GLsizei bufSize, GLsizei * length, GLchar * label);</para>
        /// </summary>
        public unsafe static void glGetObjectLabelKHR(uint identifier, uint name, int bufSize, int* length, byte* label) {
            var _F = _GetProc<GLNativeDelegate.FNglGetObjectLabelKHR>("glGetObjectLabelKHR");
            _F(identifier, name, bufSize, length, label);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_KHR_debug</para>
        /// Supported: <para>gl, glcore, gles1, gles2</para>
        /// Original: <para>void glObjectPtrLabelKHR(const void * ptr, GLsizei length, const GLchar * label);</para>
        /// </summary>
        public unsafe static void glObjectPtrLabelKHR(void* ptr, int length, byte* label) {
            var _F = _GetProc<GLNativeDelegate.FNglObjectPtrLabelKHR>("glObjectPtrLabelKHR");
            _F(ptr, length, label);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_KHR_debug</para>
        /// Supported: <para>gl, glcore, gles1, gles2</para>
        /// Original: <para>void glGetObjectPtrLabelKHR(const void * ptr, GLsizei bufSize, GLsizei * length, GLchar * label);</para>
        /// </summary>
        public unsafe static void glGetObjectPtrLabelKHR(void* ptr, int bufSize, int* length, byte* label) {
            var _F = _GetProc<GLNativeDelegate.FNglGetObjectPtrLabelKHR>("glGetObjectPtrLabelKHR");
            _F(ptr, bufSize, length, label);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_KHR_debug</para>
        /// Supported: <para>gl, glcore, gles1, gles2</para>
        /// Original: <para>void glGetPointervKHR(GLenum pname, void ** params);</para>
        /// </summary>
        public unsafe static void glGetPointervKHR(uint pname, void** ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetPointervKHR>("glGetPointervKHR");
            _F(pname, ps);
        }

        #endregion GL_KHR_debug

        #region GL_KHR_robustness

        // GLenum glGetGraphicsResetStatus();
        // void glReadnPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLsizei bufSize, void * data);
        // void glGetnUniformfv(GLuint program, GLint location, GLsizei bufSize, GLfloat * ps);
        // void glGetnUniformiv(GLuint program, GLint location, GLsizei bufSize, GLint * ps);
        // void glGetnUniformuiv(GLuint program, GLint location, GLsizei bufSize, GLuint * ps);
        /// <summary>
        /// <para>Require:</para> <para>GL_KHR_robustness</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>GLenum glGetGraphicsResetStatusKHR();</para>
        /// </summary>
        public static uint glGetGraphicsResetStatusKHR() {
            var _F = _GetProc<GLNativeDelegate.FNglGetGraphicsResetStatusKHR>("glGetGraphicsResetStatusKHR");
            return _F();
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_KHR_robustness</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glReadnPixelsKHR(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLsizei bufSize, void * data);</para>
        /// </summary>
        public unsafe static void glReadnPixelsKHR(int x, int y, int width, int height, uint format, uint type, int bufSize, void* data) {
            var _F = _GetProc<GLNativeDelegate.FNglReadnPixelsKHR>("glReadnPixelsKHR");
            _F(x, y, width, height, format, type, bufSize, data);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_KHR_robustness</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glGetnUniformfvKHR(GLuint program, GLint location, GLsizei bufSize, GLfloat * params);</para>
        /// </summary>
        public unsafe static void glGetnUniformfvKHR(uint program, int location, int bufSize, float* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetnUniformfvKHR>("glGetnUniformfvKHR");
            _F(program, location, bufSize, ps);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_KHR_robustness</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glGetnUniformivKHR(GLuint program, GLint location, GLsizei bufSize, GLint * params);</para>
        /// </summary>
        public unsafe static void glGetnUniformivKHR(uint program, int location, int bufSize, int* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetnUniformivKHR>("glGetnUniformivKHR");
            _F(program, location, bufSize, ps);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_KHR_robustness</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glGetnUniformuivKHR(GLuint program, GLint location, GLsizei bufSize, GLuint * params);</para>
        /// </summary>
        public unsafe static void glGetnUniformuivKHR(uint program, int location, int bufSize, uint* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetnUniformuivKHR>("glGetnUniformuivKHR");
            _F(program, location, bufSize, ps);
        }

        #endregion GL_KHR_robustness

        #region GL_KHR_parallel_shader_compile

        /// <summary>
        /// <para>Require:</para> <para>GL_KHR_parallel_shader_compile</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glMaxShaderCompilerThreadsKHR(GLuint count);</para>
        /// </summary>
        public static void glMaxShaderCompilerThreadsKHR(uint count) {
            var _F = _GetProc<GLNativeDelegate.FNglMaxShaderCompilerThreadsKHR>("glMaxShaderCompilerThreadsKHR");
            _F(count);
        }

        #endregion GL_KHR_parallel_shader_compile

        #region GL_MESA_framebuffer_flip_y

        /// <summary>
        /// <para>Require:</para> <para>GL_MESA_framebuffer_flip_y</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glFramebufferParameteriMESA(GLenum target, GLenum pname, GLint param);</para>
        /// </summary>
        public static void glFramebufferParameteriMESA(uint target, uint pname, int param) {
            var _F = _GetProc<GLNativeDelegate.FNglFramebufferParameteriMESA>("glFramebufferParameteriMESA");
            _F(target, pname, param);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_MESA_framebuffer_flip_y</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glGetFramebufferParameterivMESA(GLenum target, GLenum pname, GLint * params);</para>
        /// </summary>
        public unsafe static void glGetFramebufferParameterivMESA(uint target, uint pname, int* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetFramebufferParameterivMESA>("glGetFramebufferParameterivMESA");
            _F(target, pname, ps);
        }

        #endregion GL_MESA_framebuffer_flip_y

        #region GL_MESA_resize_buffers

        /// <summary>
        /// <para>Require:</para> <para>GL_MESA_resize_buffers</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glResizeBuffersMESA();</para>
        /// </summary>
        public static void glResizeBuffersMESA() {
            var _F = _GetProc<GLNativeDelegate.FNglResizeBuffersMESA>("glResizeBuffersMESA");
            _F();
        }

        #endregion GL_MESA_resize_buffers

        #region GL_MESA_window_pos

        /// <summary>
        /// <para>Require:</para> <para>GL_MESA_window_pos</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glWindowPos2dMESA(GLdouble x, GLdouble y);</para>
        /// </summary>
        public static void glWindowPos2dMESA(double x, double y) {
            var _F = _GetProc<GLNativeDelegate.FNglWindowPos2dMESA>("glWindowPos2dMESA");
            _F(x, y);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_MESA_window_pos</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glWindowPos2dvMESA(const GLdouble * v);</para>
        /// </summary>
        public unsafe static void glWindowPos2dvMESA(double* v) {
            var _F = _GetProc<GLNativeDelegate.FNglWindowPos2dvMESA>("glWindowPos2dvMESA");
            _F(v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_MESA_window_pos</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glWindowPos2fMESA(GLfloat x, GLfloat y);</para>
        /// </summary>
        public static void glWindowPos2fMESA(float x, float y) {
            var _F = _GetProc<GLNativeDelegate.FNglWindowPos2fMESA>("glWindowPos2fMESA");
            _F(x, y);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_MESA_window_pos</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glWindowPos2fvMESA(const GLfloat * v);</para>
        /// </summary>
        public unsafe static void glWindowPos2fvMESA(float* v) {
            var _F = _GetProc<GLNativeDelegate.FNglWindowPos2fvMESA>("glWindowPos2fvMESA");
            _F(v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_MESA_window_pos</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glWindowPos2iMESA(GLint x, GLint y);</para>
        /// </summary>
        public static void glWindowPos2iMESA(int x, int y) {
            var _F = _GetProc<GLNativeDelegate.FNglWindowPos2iMESA>("glWindowPos2iMESA");
            _F(x, y);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_MESA_window_pos</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glWindowPos2ivMESA(const GLint * v);</para>
        /// </summary>
        public unsafe static void glWindowPos2ivMESA(int* v) {
            var _F = _GetProc<GLNativeDelegate.FNglWindowPos2ivMESA>("glWindowPos2ivMESA");
            _F(v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_MESA_window_pos</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glWindowPos2sMESA(GLshort x, GLshort y);</para>
        /// </summary>
        public static void glWindowPos2sMESA(short x, short y) {
            var _F = _GetProc<GLNativeDelegate.FNglWindowPos2sMESA>("glWindowPos2sMESA");
            _F(x, y);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_MESA_window_pos</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glWindowPos2svMESA(const GLshort * v);</para>
        /// </summary>
        public unsafe static void glWindowPos2svMESA(short* v) {
            var _F = _GetProc<GLNativeDelegate.FNglWindowPos2svMESA>("glWindowPos2svMESA");
            _F(v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_MESA_window_pos</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glWindowPos3dMESA(GLdouble x, GLdouble y, GLdouble z);</para>
        /// </summary>
        public static void glWindowPos3dMESA(double x, double y, double z) {
            var _F = _GetProc<GLNativeDelegate.FNglWindowPos3dMESA>("glWindowPos3dMESA");
            _F(x, y, z);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_MESA_window_pos</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glWindowPos3dvMESA(const GLdouble * v);</para>
        /// </summary>
        public unsafe static void glWindowPos3dvMESA(double* v) {
            var _F = _GetProc<GLNativeDelegate.FNglWindowPos3dvMESA>("glWindowPos3dvMESA");
            _F(v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_MESA_window_pos</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glWindowPos3fMESA(GLfloat x, GLfloat y, GLfloat z);</para>
        /// </summary>
        public static void glWindowPos3fMESA(float x, float y, float z) {
            var _F = _GetProc<GLNativeDelegate.FNglWindowPos3fMESA>("glWindowPos3fMESA");
            _F(x, y, z);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_MESA_window_pos</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glWindowPos3fvMESA(const GLfloat * v);</para>
        /// </summary>
        public unsafe static void glWindowPos3fvMESA(float* v) {
            var _F = _GetProc<GLNativeDelegate.FNglWindowPos3fvMESA>("glWindowPos3fvMESA");
            _F(v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_MESA_window_pos</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glWindowPos3iMESA(GLint x, GLint y, GLint z);</para>
        /// </summary>
        public static void glWindowPos3iMESA(int x, int y, int z) {
            var _F = _GetProc<GLNativeDelegate.FNglWindowPos3iMESA>("glWindowPos3iMESA");
            _F(x, y, z);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_MESA_window_pos</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glWindowPos3ivMESA(const GLint * v);</para>
        /// </summary>
        public unsafe static void glWindowPos3ivMESA(int* v) {
            var _F = _GetProc<GLNativeDelegate.FNglWindowPos3ivMESA>("glWindowPos3ivMESA");
            _F(v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_MESA_window_pos</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glWindowPos3sMESA(GLshort x, GLshort y, GLshort z);</para>
        /// </summary>
        public static void glWindowPos3sMESA(short x, short y, short z) {
            var _F = _GetProc<GLNativeDelegate.FNglWindowPos3sMESA>("glWindowPos3sMESA");
            _F(x, y, z);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_MESA_window_pos</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glWindowPos3svMESA(const GLshort * v);</para>
        /// </summary>
        public unsafe static void glWindowPos3svMESA(short* v) {
            var _F = _GetProc<GLNativeDelegate.FNglWindowPos3svMESA>("glWindowPos3svMESA");
            _F(v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_MESA_window_pos</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glWindowPos4dMESA(GLdouble x, GLdouble y, GLdouble z, GLdouble w);</para>
        /// </summary>
        public static void glWindowPos4dMESA(double x, double y, double z, double w) {
            var _F = _GetProc<GLNativeDelegate.FNglWindowPos4dMESA>("glWindowPos4dMESA");
            _F(x, y, z, w);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_MESA_window_pos</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glWindowPos4dvMESA(const GLdouble * v);</para>
        /// </summary>
        public unsafe static void glWindowPos4dvMESA(double* v) {
            var _F = _GetProc<GLNativeDelegate.FNglWindowPos4dvMESA>("glWindowPos4dvMESA");
            _F(v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_MESA_window_pos</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glWindowPos4fMESA(GLfloat x, GLfloat y, GLfloat z, GLfloat w);</para>
        /// </summary>
        public static void glWindowPos4fMESA(float x, float y, float z, float w) {
            var _F = _GetProc<GLNativeDelegate.FNglWindowPos4fMESA>("glWindowPos4fMESA");
            _F(x, y, z, w);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_MESA_window_pos</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glWindowPos4fvMESA(const GLfloat * v);</para>
        /// </summary>
        public unsafe static void glWindowPos4fvMESA(float* v) {
            var _F = _GetProc<GLNativeDelegate.FNglWindowPos4fvMESA>("glWindowPos4fvMESA");
            _F(v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_MESA_window_pos</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glWindowPos4iMESA(GLint x, GLint y, GLint z, GLint w);</para>
        /// </summary>
        public static void glWindowPos4iMESA(int x, int y, int z, int w) {
            var _F = _GetProc<GLNativeDelegate.FNglWindowPos4iMESA>("glWindowPos4iMESA");
            _F(x, y, z, w);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_MESA_window_pos</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glWindowPos4ivMESA(const GLint * v);</para>
        /// </summary>
        public unsafe static void glWindowPos4ivMESA(int* v) {
            var _F = _GetProc<GLNativeDelegate.FNglWindowPos4ivMESA>("glWindowPos4ivMESA");
            _F(v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_MESA_window_pos</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glWindowPos4sMESA(GLshort x, GLshort y, GLshort z, GLshort w);</para>
        /// </summary>
        public static void glWindowPos4sMESA(short x, short y, short z, short w) {
            var _F = _GetProc<GLNativeDelegate.FNglWindowPos4sMESA>("glWindowPos4sMESA");
            _F(x, y, z, w);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_MESA_window_pos</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glWindowPos4svMESA(const GLshort * v);</para>
        /// </summary>
        public unsafe static void glWindowPos4svMESA(short* v) {
            var _F = _GetProc<GLNativeDelegate.FNglWindowPos4svMESA>("glWindowPos4svMESA");
            _F(v);
        }

        #endregion GL_MESA_window_pos

        #region GL_NVX_conditional_render

        /// <summary>
        /// <para>Require:</para> <para>GL_NVX_conditional_render</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glBeginConditionalRenderNVX(GLuint id);</para>
        /// </summary>
        public static void glBeginConditionalRenderNVX(uint id) {
            var _F = _GetProc<GLNativeDelegate.FNglBeginConditionalRenderNVX>("glBeginConditionalRenderNVX");
            _F(id);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NVX_conditional_render</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glEndConditionalRenderNVX();</para>
        /// </summary>
        public static void glEndConditionalRenderNVX() {
            var _F = _GetProc<GLNativeDelegate.FNglEndConditionalRenderNVX>("glEndConditionalRenderNVX");
            _F();
        }

        #endregion GL_NVX_conditional_render

        #region GL_NVX_linked_gpu_multicast

        /// <summary>
        /// <para>Require:</para> <para>GL_NVX_linked_gpu_multicast</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glLGPUNamedBufferSubDataNVX(GLbitfield gpuMask, GLuint buffer, GLintptr offset, GLsizeiptr size, const void * data);</para>
        /// </summary>
        public unsafe static void glLGPUNamedBufferSubDataNVX(uint gpuMask, uint buffer, IntPtr offset, IntPtr size, void* data) {
            var _F = _GetProc<GLNativeDelegate.FNglLGPUNamedBufferSubDataNVX>("glLGPUNamedBufferSubDataNVX");
            _F(gpuMask, buffer, offset, size, data);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NVX_linked_gpu_multicast</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glLGPUCopyImageSubDataNVX(GLuint sourceGpu, GLbitfield destinationGpuMask, GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srxY, GLint srcZ, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei width, GLsizei height, GLsizei depth);</para>
        /// </summary>
        public static void glLGPUCopyImageSubDataNVX(uint sourceGpu, uint destinationGpuMask, uint srcName, uint srcTarget, int srcLevel, int srcX, int srxY, int srcZ, uint dstName, uint dstTarget, int dstLevel, int dstX, int dstY, int dstZ, int width, int height, int depth) {
            var _F = _GetProc<GLNativeDelegate.FNglLGPUCopyImageSubDataNVX>("glLGPUCopyImageSubDataNVX");
            _F(sourceGpu, destinationGpuMask, srcName, srcTarget, srcLevel, srcX, srxY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, width, height, depth);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NVX_linked_gpu_multicast</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glLGPUInterlockNVX();</para>
        /// </summary>
        public static void glLGPUInterlockNVX() {
            var _F = _GetProc<GLNativeDelegate.FNglLGPUInterlockNVX>("glLGPUInterlockNVX");
            _F();
        }

        #endregion GL_NVX_linked_gpu_multicast

        #region GL_NV_alpha_to_coverage_dither_control

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_alpha_to_coverage_dither_control</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glAlphaToCoverageDitherControlNV(GLenum mode);</para>
        /// </summary>
        public static void glAlphaToCoverageDitherControlNV(uint mode) {
            var _F = _GetProc<GLNativeDelegate.FNglAlphaToCoverageDitherControlNV>("glAlphaToCoverageDitherControlNV");
            _F(mode);
        }

        #endregion GL_NV_alpha_to_coverage_dither_control

        #region GL_NV_bindless_multi_draw_indirect

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_bindless_multi_draw_indirect</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glMultiDrawArraysIndirectBindlessNV(GLenum mode, const void * indirect, GLsizei drawCount, GLsizei stride, GLint vertexBufferCount);</para>
        /// </summary>
        public unsafe static void glMultiDrawArraysIndirectBindlessNV(uint mode, void* indirect, int drawCount, int stride, int vertexBufferCount) {
            var _F = _GetProc<GLNativeDelegate.FNglMultiDrawArraysIndirectBindlessNV>("glMultiDrawArraysIndirectBindlessNV");
            _F(mode, indirect, drawCount, stride, vertexBufferCount);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_bindless_multi_draw_indirect</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glMultiDrawElementsIndirectBindlessNV(GLenum mode, GLenum type, const void * indirect, GLsizei drawCount, GLsizei stride, GLint vertexBufferCount);</para>
        /// </summary>
        public unsafe static void glMultiDrawElementsIndirectBindlessNV(uint mode, uint type, void* indirect, int drawCount, int stride, int vertexBufferCount) {
            var _F = _GetProc<GLNativeDelegate.FNglMultiDrawElementsIndirectBindlessNV>("glMultiDrawElementsIndirectBindlessNV");
            _F(mode, type, indirect, drawCount, stride, vertexBufferCount);
        }

        #endregion GL_NV_bindless_multi_draw_indirect

        #region GL_NV_bindless_multi_draw_indirect_count

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_bindless_multi_draw_indirect_count</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glMultiDrawArraysIndirectBindlessCountNV(GLenum mode, const void * indirect, GLsizei drawCount, GLsizei maxDrawCount, GLsizei stride, GLint vertexBufferCount);</para>
        /// </summary>
        public unsafe static void glMultiDrawArraysIndirectBindlessCountNV(uint mode, void* indirect, int drawCount, int maxDrawCount, int stride, int vertexBufferCount) {
            var _F = _GetProc<GLNativeDelegate.FNglMultiDrawArraysIndirectBindlessCountNV>("glMultiDrawArraysIndirectBindlessCountNV");
            _F(mode, indirect, drawCount, maxDrawCount, stride, vertexBufferCount);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_bindless_multi_draw_indirect_count</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glMultiDrawElementsIndirectBindlessCountNV(GLenum mode, GLenum type, const void * indirect, GLsizei drawCount, GLsizei maxDrawCount, GLsizei stride, GLint vertexBufferCount);</para>
        /// </summary>
        public unsafe static void glMultiDrawElementsIndirectBindlessCountNV(uint mode, uint type, void* indirect, int drawCount, int maxDrawCount, int stride, int vertexBufferCount) {
            var _F = _GetProc<GLNativeDelegate.FNglMultiDrawElementsIndirectBindlessCountNV>("glMultiDrawElementsIndirectBindlessCountNV");
            _F(mode, type, indirect, drawCount, maxDrawCount, stride, vertexBufferCount);
        }

        #endregion GL_NV_bindless_multi_draw_indirect_count

        #region GL_NV_bindless_texture

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_bindless_texture</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>GLuint64 glGetTextureHandleNV(GLuint texture);</para>
        /// </summary>
        public static UInt64 glGetTextureHandleNV(uint texture) {
            var _F = _GetProc<GLNativeDelegate.FNglGetTextureHandleNV>("glGetTextureHandleNV");
            return _F(texture);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_bindless_texture</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>GLuint64 glGetTextureSamplerHandleNV(GLuint texture, GLuint sampler);</para>
        /// </summary>
        public static UInt64 glGetTextureSamplerHandleNV(uint texture, uint sampler) {
            var _F = _GetProc<GLNativeDelegate.FNglGetTextureSamplerHandleNV>("glGetTextureSamplerHandleNV");
            return _F(texture, sampler);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_bindless_texture</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glMakeTextureHandleResidentNV(GLuint64 handle);</para>
        /// </summary>
        public static void glMakeTextureHandleResidentNV(UInt64 handle) {
            var _F = _GetProc<GLNativeDelegate.FNglMakeTextureHandleResidentNV>("glMakeTextureHandleResidentNV");
            _F(handle);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_bindless_texture</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glMakeTextureHandleNonResidentNV(GLuint64 handle);</para>
        /// </summary>
        public static void glMakeTextureHandleNonResidentNV(UInt64 handle) {
            var _F = _GetProc<GLNativeDelegate.FNglMakeTextureHandleNonResidentNV>("glMakeTextureHandleNonResidentNV");
            _F(handle);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_bindless_texture</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>GLuint64 glGetImageHandleNV(GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum format);</para>
        /// </summary>
        public static UInt64 glGetImageHandleNV(uint texture, int level, bool layered, int layer, uint format) {
            var _F = _GetProc<GLNativeDelegate.FNglGetImageHandleNV>("glGetImageHandleNV");
            return _F(texture, level, layered, layer, format);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_bindless_texture</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glMakeImageHandleResidentNV(GLuint64 handle, GLenum access);</para>
        /// </summary>
        public static void glMakeImageHandleResidentNV(UInt64 handle, uint access) {
            var _F = _GetProc<GLNativeDelegate.FNglMakeImageHandleResidentNV>("glMakeImageHandleResidentNV");
            _F(handle, access);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_bindless_texture</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glMakeImageHandleNonResidentNV(GLuint64 handle);</para>
        /// </summary>
        public static void glMakeImageHandleNonResidentNV(UInt64 handle) {
            var _F = _GetProc<GLNativeDelegate.FNglMakeImageHandleNonResidentNV>("glMakeImageHandleNonResidentNV");
            _F(handle);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_bindless_texture</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glUniformHandleui64NV(GLint location, GLuint64 value);</para>
        /// </summary>
        public static void glUniformHandleui64NV(int location, UInt64 value) {
            var _F = _GetProc<GLNativeDelegate.FNglUniformHandleui64NV>("glUniformHandleui64NV");
            _F(location, value);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_bindless_texture</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glUniformHandleui64vNV(GLint location, GLsizei count, const GLuint64 * value);</para>
        /// </summary>
        public unsafe static void glUniformHandleui64vNV(int location, int count, UInt64* value) {
            var _F = _GetProc<GLNativeDelegate.FNglUniformHandleui64vNV>("glUniformHandleui64vNV");
            _F(location, count, value);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_bindless_texture</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glProgramUniformHandleui64NV(GLuint program, GLint location, GLuint64 value);</para>
        /// </summary>
        public static void glProgramUniformHandleui64NV(uint program, int location, UInt64 value) {
            var _F = _GetProc<GLNativeDelegate.FNglProgramUniformHandleui64NV>("glProgramUniformHandleui64NV");
            _F(program, location, value);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_bindless_texture</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glProgramUniformHandleui64vNV(GLuint program, GLint location, GLsizei count, const GLuint64 * values);</para>
        /// </summary>
        public unsafe static void glProgramUniformHandleui64vNV(uint program, int location, int count, UInt64* values) {
            var _F = _GetProc<GLNativeDelegate.FNglProgramUniformHandleui64vNV>("glProgramUniformHandleui64vNV");
            _F(program, location, count, values);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_bindless_texture</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>GLboolean glIsTextureHandleResidentNV(GLuint64 handle);</para>
        /// </summary>
        public static bool glIsTextureHandleResidentNV(UInt64 handle) {
            var _F = _GetProc<GLNativeDelegate.FNglIsTextureHandleResidentNV>("glIsTextureHandleResidentNV");
            return _F(handle);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_bindless_texture</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>GLboolean glIsImageHandleResidentNV(GLuint64 handle);</para>
        /// </summary>
        public static bool glIsImageHandleResidentNV(UInt64 handle) {
            var _F = _GetProc<GLNativeDelegate.FNglIsImageHandleResidentNV>("glIsImageHandleResidentNV");
            return _F(handle);
        }

        #endregion GL_NV_bindless_texture

        #region GL_NV_blend_equation_advanced

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_blend_equation_advanced</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glBlendParameteriNV(GLenum pname, GLint value);</para>
        /// </summary>
        public static void glBlendParameteriNV(uint pname, int value) {
            var _F = _GetProc<GLNativeDelegate.FNglBlendParameteriNV>("glBlendParameteriNV");
            _F(pname, value);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_blend_equation_advanced</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glBlendBarrierNV();</para>
        /// </summary>
        public static void glBlendBarrierNV() {
            var _F = _GetProc<GLNativeDelegate.FNglBlendBarrierNV>("glBlendBarrierNV");
            _F();
        }

        #endregion GL_NV_blend_equation_advanced

        #region GL_NV_clip_space_w_scaling

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_clip_space_w_scaling</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glViewportPositionWScaleNV(GLuint index, GLfloat xcoeff, GLfloat ycoeff);</para>
        /// </summary>
        public static void glViewportPositionWScaleNV(uint index, float xcoeff, float ycoeff) {
            var _F = _GetProc<GLNativeDelegate.FNglViewportPositionWScaleNV>("glViewportPositionWScaleNV");
            _F(index, xcoeff, ycoeff);
        }

        #endregion GL_NV_clip_space_w_scaling

        #region GL_NV_command_list

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_command_list</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glCreateStatesNV(GLsizei n, GLuint * states);</para>
        /// </summary>
        public unsafe static void glCreateStatesNV(int n, uint* states) {
            var _F = _GetProc<GLNativeDelegate.FNglCreateStatesNV>("glCreateStatesNV");
            _F(n, states);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_command_list</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glDeleteStatesNV(GLsizei n, const GLuint * states);</para>
        /// </summary>
        public unsafe static void glDeleteStatesNV(int n, uint* states) {
            var _F = _GetProc<GLNativeDelegate.FNglDeleteStatesNV>("glDeleteStatesNV");
            _F(n, states);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_command_list</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>GLboolean glIsStateNV(GLuint state);</para>
        /// </summary>
        public static bool glIsStateNV(uint state) {
            var _F = _GetProc<GLNativeDelegate.FNglIsStateNV>("glIsStateNV");
            return _F(state);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_command_list</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glStateCaptureNV(GLuint state, GLenum mode);</para>
        /// </summary>
        public static void glStateCaptureNV(uint state, uint mode) {
            var _F = _GetProc<GLNativeDelegate.FNglStateCaptureNV>("glStateCaptureNV");
            _F(state, mode);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_command_list</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>GLuint glGetCommandHeaderNV(GLenum tokenID, GLuint size);</para>
        /// </summary>
        public static uint glGetCommandHeaderNV(uint tokenID, uint size) {
            var _F = _GetProc<GLNativeDelegate.FNglGetCommandHeaderNV>("glGetCommandHeaderNV");
            return _F(tokenID, size);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_command_list</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>GLushort glGetStageIndexNV(GLenum shadertype);</para>
        /// </summary>
        public static ushort glGetStageIndexNV(uint shadertype) {
            var _F = _GetProc<GLNativeDelegate.FNglGetStageIndexNV>("glGetStageIndexNV");
            return _F(shadertype);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_command_list</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glDrawCommandsNV(GLenum primitiveMode, GLuint buffer, const GLintptr * indirects, const GLsizei * sizes, GLuint count);</para>
        /// </summary>
        public unsafe static void glDrawCommandsNV(uint primitiveMode, uint buffer, IntPtr indirects, int* sizes, uint count) {
            var _F = _GetProc<GLNativeDelegate.FNglDrawCommandsNV>("glDrawCommandsNV");
            _F(primitiveMode, buffer, indirects, sizes, count);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_command_list</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glDrawCommandsAddressNV(GLenum primitiveMode, const GLuint64 * indirects, const GLsizei * sizes, GLuint count);</para>
        /// </summary>
        public unsafe static void glDrawCommandsAddressNV(uint primitiveMode, UInt64* indirects, int* sizes, uint count) {
            var _F = _GetProc<GLNativeDelegate.FNglDrawCommandsAddressNV>("glDrawCommandsAddressNV");
            _F(primitiveMode, indirects, sizes, count);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_command_list</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glDrawCommandsStatesNV(GLuint buffer, const GLintptr * indirects, const GLsizei * sizes, const GLuint * states, const GLuint * fbos, GLuint count);</para>
        /// </summary>
        public unsafe static void glDrawCommandsStatesNV(uint buffer, IntPtr indirects, int* sizes, uint* states, uint* fbos, uint count) {
            var _F = _GetProc<GLNativeDelegate.FNglDrawCommandsStatesNV>("glDrawCommandsStatesNV");
            _F(buffer, indirects, sizes, states, fbos, count);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_command_list</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glDrawCommandsStatesAddressNV(const GLuint64 * indirects, const GLsizei * sizes, const GLuint * states, const GLuint * fbos, GLuint count);</para>
        /// </summary>
        public unsafe static void glDrawCommandsStatesAddressNV(UInt64* indirects, int* sizes, uint* states, uint* fbos, uint count) {
            var _F = _GetProc<GLNativeDelegate.FNglDrawCommandsStatesAddressNV>("glDrawCommandsStatesAddressNV");
            _F(indirects, sizes, states, fbos, count);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_command_list</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glCreateCommandListsNV(GLsizei n, GLuint * lists);</para>
        /// </summary>
        public unsafe static void glCreateCommandListsNV(int n, uint* lists) {
            var _F = _GetProc<GLNativeDelegate.FNglCreateCommandListsNV>("glCreateCommandListsNV");
            _F(n, lists);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_command_list</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glDeleteCommandListsNV(GLsizei n, const GLuint * lists);</para>
        /// </summary>
        public unsafe static void glDeleteCommandListsNV(int n, uint* lists) {
            var _F = _GetProc<GLNativeDelegate.FNglDeleteCommandListsNV>("glDeleteCommandListsNV");
            _F(n, lists);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_command_list</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>GLboolean glIsCommandListNV(GLuint list);</para>
        /// </summary>
        public static bool glIsCommandListNV(uint list) {
            var _F = _GetProc<GLNativeDelegate.FNglIsCommandListNV>("glIsCommandListNV");
            return _F(list);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_command_list</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glListDrawCommandsStatesClientNV(GLuint list, GLuint segment, const void ** indirects, const GLsizei * sizes, const GLuint * states, const GLuint * fbos, GLuint count);</para>
        /// </summary>
        public unsafe static void glListDrawCommandsStatesClientNV(uint list, uint segment, void** indirects, int* sizes, uint* states, uint* fbos, uint count) {
            var _F = _GetProc<GLNativeDelegate.FNglListDrawCommandsStatesClientNV>("glListDrawCommandsStatesClientNV");
            _F(list, segment, indirects, sizes, states, fbos, count);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_command_list</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glCommandListSegmentsNV(GLuint list, GLuint segments);</para>
        /// </summary>
        public static void glCommandListSegmentsNV(uint list, uint segments) {
            var _F = _GetProc<GLNativeDelegate.FNglCommandListSegmentsNV>("glCommandListSegmentsNV");
            _F(list, segments);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_command_list</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glCompileCommandListNV(GLuint list);</para>
        /// </summary>
        public static void glCompileCommandListNV(uint list) {
            var _F = _GetProc<GLNativeDelegate.FNglCompileCommandListNV>("glCompileCommandListNV");
            _F(list);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_command_list</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glCallCommandListNV(GLuint list);</para>
        /// </summary>
        public static void glCallCommandListNV(uint list) {
            var _F = _GetProc<GLNativeDelegate.FNglCallCommandListNV>("glCallCommandListNV");
            _F(list);
        }

        #endregion GL_NV_command_list

        #region GL_NV_conditional_render

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_conditional_render</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glBeginConditionalRenderNV(GLuint id, GLenum mode);</para>
        /// </summary>
        public static void glBeginConditionalRenderNV(uint id, uint mode) {
            var _F = _GetProc<GLNativeDelegate.FNglBeginConditionalRenderNV>("glBeginConditionalRenderNV");
            _F(id, mode);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_conditional_render</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glEndConditionalRenderNV();</para>
        /// </summary>
        public static void glEndConditionalRenderNV() {
            var _F = _GetProc<GLNativeDelegate.FNglEndConditionalRenderNV>("glEndConditionalRenderNV");
            _F();
        }

        #endregion GL_NV_conditional_render

        #region GL_NV_conservative_raster

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_conservative_raster</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glSubpixelPrecisionBiasNV(GLuint xbits, GLuint ybits);</para>
        /// </summary>
        public static void glSubpixelPrecisionBiasNV(uint xbits, uint ybits) {
            var _F = _GetProc<GLNativeDelegate.FNglSubpixelPrecisionBiasNV>("glSubpixelPrecisionBiasNV");
            _F(xbits, ybits);
        }

        #endregion GL_NV_conservative_raster

        #region GL_NV_conservative_raster_dilate

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_conservative_raster_dilate</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glConservativeRasterParameterfNV(GLenum pname, GLfloat value);</para>
        /// </summary>
        public static void glConservativeRasterParameterfNV(uint pname, float value) {
            var _F = _GetProc<GLNativeDelegate.FNglConservativeRasterParameterfNV>("glConservativeRasterParameterfNV");
            _F(pname, value);
        }

        #endregion GL_NV_conservative_raster_dilate

        #region GL_NV_conservative_raster_pre_snap_triangles

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_conservative_raster_pre_snap_triangles</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glConservativeRasterParameteriNV(GLenum pname, GLint param);</para>
        /// </summary>
        public static void glConservativeRasterParameteriNV(uint pname, int param) {
            var _F = _GetProc<GLNativeDelegate.FNglConservativeRasterParameteriNV>("glConservativeRasterParameteriNV");
            _F(pname, param);
        }

        #endregion GL_NV_conservative_raster_pre_snap_triangles

        #region GL_NV_copy_image

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_copy_image</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glCopyImageSubDataNV(GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei width, GLsizei height, GLsizei depth);</para>
        /// </summary>
        public static void glCopyImageSubDataNV(uint srcName, uint srcTarget, int srcLevel, int srcX, int srcY, int srcZ, uint dstName, uint dstTarget, int dstLevel, int dstX, int dstY, int dstZ, int width, int height, int depth) {
            var _F = _GetProc<GLNativeDelegate.FNglCopyImageSubDataNV>("glCopyImageSubDataNV");
            _F(srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, width, height, depth);
        }

        #endregion GL_NV_copy_image

        #region GL_NV_depth_buffer_float

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_depth_buffer_float</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glDepthRangedNV(GLdouble zNear, GLdouble zFar);</para>
        /// </summary>
        public static void glDepthRangedNV(double zNear, double zFar) {
            var _F = _GetProc<GLNativeDelegate.FNglDepthRangedNV>("glDepthRangedNV");
            _F(zNear, zFar);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_depth_buffer_float</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glClearDepthdNV(GLdouble depth);</para>
        /// </summary>
        public static void glClearDepthdNV(double depth) {
            var _F = _GetProc<GLNativeDelegate.FNglClearDepthdNV>("glClearDepthdNV");
            _F(depth);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_depth_buffer_float</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glDepthBoundsdNV(GLdouble zmin, GLdouble zmax);</para>
        /// </summary>
        public static void glDepthBoundsdNV(double zmin, double zmax) {
            var _F = _GetProc<GLNativeDelegate.FNglDepthBoundsdNV>("glDepthBoundsdNV");
            _F(zmin, zmax);
        }

        #endregion GL_NV_depth_buffer_float

        #region GL_NV_draw_texture

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_draw_texture</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glDrawTextureNV(GLuint texture, GLuint sampler, GLfloat x0, GLfloat y0, GLfloat x1, GLfloat y1, GLfloat z, GLfloat s0, GLfloat t0, GLfloat s1, GLfloat t1);</para>
        /// </summary>
        public static void glDrawTextureNV(uint texture, uint sampler, float x0, float y0, float x1, float y1, float z, float s0, float t0, float s1, float t1) {
            var _F = _GetProc<GLNativeDelegate.FNglDrawTextureNV>("glDrawTextureNV");
            _F(texture, sampler, x0, y0, x1, y1, z, s0, t0, s1, t1);
        }

        #endregion GL_NV_draw_texture

        #region GL_NV_draw_vulkan_image

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_draw_vulkan_image</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glDrawVkImageNV(GLuint64 vkImage, GLuint sampler, GLfloat x0, GLfloat y0, GLfloat x1, GLfloat y1, GLfloat z, GLfloat s0, GLfloat t0, GLfloat s1, GLfloat t1);</para>
        /// </summary>
        public static void glDrawVkImageNV(UInt64 vkImage, uint sampler, float x0, float y0, float x1, float y1, float z, float s0, float t0, float s1, float t1) {
            var _F = _GetProc<GLNativeDelegate.FNglDrawVkImageNV>("glDrawVkImageNV");
            _F(vkImage, sampler, x0, y0, x1, y1, z, s0, t0, s1, t1);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_draw_vulkan_image</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>GLVULKANPROCNV glGetVkProcAddrNV(const GLchar * name);</para>
        /// </summary>
        public unsafe static IntPtr glGetVkProcAddrNV(byte* name) {
            var _F = _GetProc<GLNativeDelegate.FNglGetVkProcAddrNV>("glGetVkProcAddrNV");
            return _F(name);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_draw_vulkan_image</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glWaitVkSemaphoreNV(GLuint64 vkSemaphore);</para>
        /// </summary>
        public static void glWaitVkSemaphoreNV(UInt64 vkSemaphore) {
            var _F = _GetProc<GLNativeDelegate.FNglWaitVkSemaphoreNV>("glWaitVkSemaphoreNV");
            _F(vkSemaphore);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_draw_vulkan_image</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glSignalVkSemaphoreNV(GLuint64 vkSemaphore);</para>
        /// </summary>
        public static void glSignalVkSemaphoreNV(UInt64 vkSemaphore) {
            var _F = _GetProc<GLNativeDelegate.FNglSignalVkSemaphoreNV>("glSignalVkSemaphoreNV");
            _F(vkSemaphore);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_draw_vulkan_image</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glSignalVkFenceNV(GLuint64 vkFence);</para>
        /// </summary>
        public static void glSignalVkFenceNV(UInt64 vkFence) {
            var _F = _GetProc<GLNativeDelegate.FNglSignalVkFenceNV>("glSignalVkFenceNV");
            _F(vkFence);
        }

        #endregion GL_NV_draw_vulkan_image

        #region GL_NV_evaluators

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_evaluators</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glMapControlPointsNV(GLenum target, GLuint index, GLenum type, GLsizei ustride, GLsizei vstride, GLint uorder, GLint vorder, GLboolean packed, const void * points);</para>
        /// </summary>
        public unsafe static void glMapControlPointsNV(uint target, uint index, uint type, int ustride, int vstride, int uorder, int vorder, bool packed, void* points) {
            var _F = _GetProc<GLNativeDelegate.FNglMapControlPointsNV>("glMapControlPointsNV");
            _F(target, index, type, ustride, vstride, uorder, vorder, packed, points);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_evaluators</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glMapParameterivNV(GLenum target, GLenum pname, const GLint * params);</para>
        /// </summary>
        public unsafe static void glMapParameterivNV(uint target, uint pname, int* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglMapParameterivNV>("glMapParameterivNV");
            _F(target, pname, ps);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_evaluators</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glMapParameterfvNV(GLenum target, GLenum pname, const GLfloat * params);</para>
        /// </summary>
        public unsafe static void glMapParameterfvNV(uint target, uint pname, float* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglMapParameterfvNV>("glMapParameterfvNV");
            _F(target, pname, ps);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_evaluators</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetMapControlPointsNV(GLenum target, GLuint index, GLenum type, GLsizei ustride, GLsizei vstride, GLboolean packed, void * points);</para>
        /// </summary>
        public unsafe static void glGetMapControlPointsNV(uint target, uint index, uint type, int ustride, int vstride, bool packed, void* points) {
            var _F = _GetProc<GLNativeDelegate.FNglGetMapControlPointsNV>("glGetMapControlPointsNV");
            _F(target, index, type, ustride, vstride, packed, points);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_evaluators</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetMapParameterivNV(GLenum target, GLenum pname, GLint * params);</para>
        /// </summary>
        public unsafe static void glGetMapParameterivNV(uint target, uint pname, int* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetMapParameterivNV>("glGetMapParameterivNV");
            _F(target, pname, ps);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_evaluators</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetMapParameterfvNV(GLenum target, GLenum pname, GLfloat * params);</para>
        /// </summary>
        public unsafe static void glGetMapParameterfvNV(uint target, uint pname, float* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetMapParameterfvNV>("glGetMapParameterfvNV");
            _F(target, pname, ps);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_evaluators</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetMapAttribParameterivNV(GLenum target, GLuint index, GLenum pname, GLint * params);</para>
        /// </summary>
        public unsafe static void glGetMapAttribParameterivNV(uint target, uint index, uint pname, int* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetMapAttribParameterivNV>("glGetMapAttribParameterivNV");
            _F(target, index, pname, ps);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_evaluators</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetMapAttribParameterfvNV(GLenum target, GLuint index, GLenum pname, GLfloat * params);</para>
        /// </summary>
        public unsafe static void glGetMapAttribParameterfvNV(uint target, uint index, uint pname, float* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetMapAttribParameterfvNV>("glGetMapAttribParameterfvNV");
            _F(target, index, pname, ps);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_evaluators</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glEvalMapsNV(GLenum target, GLenum mode);</para>
        /// </summary>
        public static void glEvalMapsNV(uint target, uint mode) {
            var _F = _GetProc<GLNativeDelegate.FNglEvalMapsNV>("glEvalMapsNV");
            _F(target, mode);
        }

        #endregion GL_NV_evaluators

        #region GL_NV_explicit_multisample

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_explicit_multisample</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetMultisamplefvNV(GLenum pname, GLuint index, GLfloat * val);</para>
        /// </summary>
        public unsafe static void glGetMultisamplefvNV(uint pname, uint index, float* val) {
            var _F = _GetProc<GLNativeDelegate.FNglGetMultisamplefvNV>("glGetMultisamplefvNV");
            _F(pname, index, val);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_explicit_multisample</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glSampleMaskIndexedNV(GLuint index, GLbitfield mask);</para>
        /// </summary>
        public static void glSampleMaskIndexedNV(uint index, uint mask) {
            var _F = _GetProc<GLNativeDelegate.FNglSampleMaskIndexedNV>("glSampleMaskIndexedNV");
            _F(index, mask);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_explicit_multisample</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glTexRenderbufferNV(GLenum target, GLuint renderbuffer);</para>
        /// </summary>
        public static void glTexRenderbufferNV(uint target, uint renderbuffer) {
            var _F = _GetProc<GLNativeDelegate.FNglTexRenderbufferNV>("glTexRenderbufferNV");
            _F(target, renderbuffer);
        }

        #endregion GL_NV_explicit_multisample

        #region GL_NV_fence

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_fence</para>
        /// Supported: <para>gl, gles1, gles2</para>
        /// Original: <para>void glDeleteFencesNV(GLsizei n, const GLuint * fences);</para>
        /// </summary>
        public unsafe static void glDeleteFencesNV(int n, uint* fences) {
            var _F = _GetProc<GLNativeDelegate.FNglDeleteFencesNV>("glDeleteFencesNV");
            _F(n, fences);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_fence</para>
        /// Supported: <para>gl, gles1, gles2</para>
        /// Original: <para>void glGenFencesNV(GLsizei n, GLuint * fences);</para>
        /// </summary>
        public unsafe static void glGenFencesNV(int n, uint* fences) {
            var _F = _GetProc<GLNativeDelegate.FNglGenFencesNV>("glGenFencesNV");
            _F(n, fences);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_fence</para>
        /// Supported: <para>gl, gles1, gles2</para>
        /// Original: <para>GLboolean glIsFenceNV(GLuint fence);</para>
        /// </summary>
        public static bool glIsFenceNV(uint fence) {
            var _F = _GetProc<GLNativeDelegate.FNglIsFenceNV>("glIsFenceNV");
            return _F(fence);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_fence</para>
        /// Supported: <para>gl, gles1, gles2</para>
        /// Original: <para>GLboolean glTestFenceNV(GLuint fence);</para>
        /// </summary>
        public static bool glTestFenceNV(uint fence) {
            var _F = _GetProc<GLNativeDelegate.FNglTestFenceNV>("glTestFenceNV");
            return _F(fence);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_fence</para>
        /// Supported: <para>gl, gles1, gles2</para>
        /// Original: <para>void glGetFenceivNV(GLuint fence, GLenum pname, GLint * params);</para>
        /// </summary>
        public unsafe static void glGetFenceivNV(uint fence, uint pname, int* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetFenceivNV>("glGetFenceivNV");
            _F(fence, pname, ps);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_fence</para>
        /// Supported: <para>gl, gles1, gles2</para>
        /// Original: <para>void glFinishFenceNV(GLuint fence);</para>
        /// </summary>
        public static void glFinishFenceNV(uint fence) {
            var _F = _GetProc<GLNativeDelegate.FNglFinishFenceNV>("glFinishFenceNV");
            _F(fence);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_fence</para>
        /// Supported: <para>gl, gles1, gles2</para>
        /// Original: <para>void glSetFenceNV(GLuint fence, GLenum condition);</para>
        /// </summary>
        public static void glSetFenceNV(uint fence, uint condition) {
            var _F = _GetProc<GLNativeDelegate.FNglSetFenceNV>("glSetFenceNV");
            _F(fence, condition);
        }

        #endregion GL_NV_fence

        #region GL_NV_fragment_coverage_to_color

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_fragment_coverage_to_color</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glFragmentCoverageColorNV(GLuint color);</para>
        /// </summary>
        public static void glFragmentCoverageColorNV(uint color) {
            var _F = _GetProc<GLNativeDelegate.FNglFragmentCoverageColorNV>("glFragmentCoverageColorNV");
            _F(color);
        }

        #endregion GL_NV_fragment_coverage_to_color

        #region GL_NV_framebuffer_mixed_samples

        // void glRasterSamplesEXT(GLuint samples, GLboolean fixedsamplelocations);
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_framebuffer_mixed_samples</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glCoverageModulationTableNV(GLsizei n, const GLfloat * v);</para>
        /// </summary>
        public unsafe static void glCoverageModulationTableNV(int n, float* v) {
            var _F = _GetProc<GLNativeDelegate.FNglCoverageModulationTableNV>("glCoverageModulationTableNV");
            _F(n, v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_framebuffer_mixed_samples</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glGetCoverageModulationTableNV(GLsizei bufSize, GLfloat * v);</para>
        /// </summary>
        public unsafe static void glGetCoverageModulationTableNV(int bufSize, float* v) {
            var _F = _GetProc<GLNativeDelegate.FNglGetCoverageModulationTableNV>("glGetCoverageModulationTableNV");
            _F(bufSize, v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_framebuffer_mixed_samples</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glCoverageModulationNV(GLenum components);</para>
        /// </summary>
        public static void glCoverageModulationNV(uint components) {
            var _F = _GetProc<GLNativeDelegate.FNglCoverageModulationNV>("glCoverageModulationNV");
            _F(components);
        }

        #endregion GL_NV_framebuffer_mixed_samples

        #region GL_NV_framebuffer_multisample_coverage

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_framebuffer_multisample_coverage</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glRenderbufferStorageMultisampleCoverageNV(GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLenum internalformat, GLsizei width, GLsizei height);</para>
        /// </summary>
        public static void glRenderbufferStorageMultisampleCoverageNV(uint target, int coverageSamples, int colorSamples, uint internalformat, int width, int height) {
            var _F = _GetProc<GLNativeDelegate.FNglRenderbufferStorageMultisampleCoverageNV>("glRenderbufferStorageMultisampleCoverageNV");
            _F(target, coverageSamples, colorSamples, internalformat, width, height);
        }

        #endregion GL_NV_framebuffer_multisample_coverage

        #region GL_NV_geometry_program4

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_geometry_program4</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glProgramVertexLimitNV(GLenum target, GLint limit);</para>
        /// </summary>
        public static void glProgramVertexLimitNV(uint target, int limit) {
            var _F = _GetProc<GLNativeDelegate.FNglProgramVertexLimitNV>("glProgramVertexLimitNV");
            _F(target, limit);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_geometry_shader, GL_NV_geometry_program4</para>
        /// Supported: <para>gles2, gl</para>
        /// Original: <para>void glFramebufferTextureEXT(GLenum target, GLenum attachment, GLuint texture, GLint level);</para>
        /// </summary>
        public static void glFramebufferTextureEXT(uint target, uint attachment, uint texture, int level) {
            var _F = _GetProc<GLNativeDelegate.FNglFramebufferTextureEXT>("glFramebufferTextureEXT");
            _F(target, attachment, texture, level);
        }
        // void glFramebufferTextureLayerEXT(GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer);
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_geometry_program4</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glFramebufferTextureFaceEXT(GLenum target, GLenum attachment, GLuint texture, GLint level, GLenum face);</para>
        /// </summary>
        public static void glFramebufferTextureFaceEXT(uint target, uint attachment, uint texture, int level, uint face) {
            var _F = _GetProc<GLNativeDelegate.FNglFramebufferTextureFaceEXT>("glFramebufferTextureFaceEXT");
            _F(target, attachment, texture, level, face);
        }

        #endregion GL_NV_geometry_program4

        #region GL_NV_gpu_program4

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_gpu_program4</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glProgramLocalParameterI4iNV(GLenum target, GLuint index, GLint x, GLint y, GLint z, GLint w);</para>
        /// </summary>
        public static void glProgramLocalParameterI4iNV(uint target, uint index, int x, int y, int z, int w) {
            var _F = _GetProc<GLNativeDelegate.FNglProgramLocalParameterI4iNV>("glProgramLocalParameterI4iNV");
            _F(target, index, x, y, z, w);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_gpu_program4</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glProgramLocalParameterI4ivNV(GLenum target, GLuint index, const GLint * params);</para>
        /// </summary>
        public unsafe static void glProgramLocalParameterI4ivNV(uint target, uint index, int* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglProgramLocalParameterI4ivNV>("glProgramLocalParameterI4ivNV");
            _F(target, index, ps);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_gpu_program4</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glProgramLocalParametersI4ivNV(GLenum target, GLuint index, GLsizei count, const GLint * params);</para>
        /// </summary>
        public unsafe static void glProgramLocalParametersI4ivNV(uint target, uint index, int count, int* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglProgramLocalParametersI4ivNV>("glProgramLocalParametersI4ivNV");
            _F(target, index, count, ps);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_gpu_program4</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glProgramLocalParameterI4uiNV(GLenum target, GLuint index, GLuint x, GLuint y, GLuint z, GLuint w);</para>
        /// </summary>
        public static void glProgramLocalParameterI4uiNV(uint target, uint index, uint x, uint y, uint z, uint w) {
            var _F = _GetProc<GLNativeDelegate.FNglProgramLocalParameterI4uiNV>("glProgramLocalParameterI4uiNV");
            _F(target, index, x, y, z, w);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_gpu_program4</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glProgramLocalParameterI4uivNV(GLenum target, GLuint index, const GLuint * params);</para>
        /// </summary>
        public unsafe static void glProgramLocalParameterI4uivNV(uint target, uint index, uint* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglProgramLocalParameterI4uivNV>("glProgramLocalParameterI4uivNV");
            _F(target, index, ps);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_gpu_program4</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glProgramLocalParametersI4uivNV(GLenum target, GLuint index, GLsizei count, const GLuint * params);</para>
        /// </summary>
        public unsafe static void glProgramLocalParametersI4uivNV(uint target, uint index, int count, uint* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglProgramLocalParametersI4uivNV>("glProgramLocalParametersI4uivNV");
            _F(target, index, count, ps);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_gpu_program4</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glProgramEnvParameterI4iNV(GLenum target, GLuint index, GLint x, GLint y, GLint z, GLint w);</para>
        /// </summary>
        public static void glProgramEnvParameterI4iNV(uint target, uint index, int x, int y, int z, int w) {
            var _F = _GetProc<GLNativeDelegate.FNglProgramEnvParameterI4iNV>("glProgramEnvParameterI4iNV");
            _F(target, index, x, y, z, w);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_gpu_program4</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glProgramEnvParameterI4ivNV(GLenum target, GLuint index, const GLint * params);</para>
        /// </summary>
        public unsafe static void glProgramEnvParameterI4ivNV(uint target, uint index, int* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglProgramEnvParameterI4ivNV>("glProgramEnvParameterI4ivNV");
            _F(target, index, ps);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_gpu_program4</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glProgramEnvParametersI4ivNV(GLenum target, GLuint index, GLsizei count, const GLint * params);</para>
        /// </summary>
        public unsafe static void glProgramEnvParametersI4ivNV(uint target, uint index, int count, int* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglProgramEnvParametersI4ivNV>("glProgramEnvParametersI4ivNV");
            _F(target, index, count, ps);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_gpu_program4</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glProgramEnvParameterI4uiNV(GLenum target, GLuint index, GLuint x, GLuint y, GLuint z, GLuint w);</para>
        /// </summary>
        public static void glProgramEnvParameterI4uiNV(uint target, uint index, uint x, uint y, uint z, uint w) {
            var _F = _GetProc<GLNativeDelegate.FNglProgramEnvParameterI4uiNV>("glProgramEnvParameterI4uiNV");
            _F(target, index, x, y, z, w);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_gpu_program4</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glProgramEnvParameterI4uivNV(GLenum target, GLuint index, const GLuint * params);</para>
        /// </summary>
        public unsafe static void glProgramEnvParameterI4uivNV(uint target, uint index, uint* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglProgramEnvParameterI4uivNV>("glProgramEnvParameterI4uivNV");
            _F(target, index, ps);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_gpu_program4</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glProgramEnvParametersI4uivNV(GLenum target, GLuint index, GLsizei count, const GLuint * params);</para>
        /// </summary>
        public unsafe static void glProgramEnvParametersI4uivNV(uint target, uint index, int count, uint* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglProgramEnvParametersI4uivNV>("glProgramEnvParametersI4uivNV");
            _F(target, index, count, ps);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_gpu_program4</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetProgramLocalParameterIivNV(GLenum target, GLuint index, GLint * params);</para>
        /// </summary>
        public unsafe static void glGetProgramLocalParameterIivNV(uint target, uint index, int* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetProgramLocalParameterIivNV>("glGetProgramLocalParameterIivNV");
            _F(target, index, ps);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_gpu_program4</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetProgramLocalParameterIuivNV(GLenum target, GLuint index, GLuint * params);</para>
        /// </summary>
        public unsafe static void glGetProgramLocalParameterIuivNV(uint target, uint index, uint* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetProgramLocalParameterIuivNV>("glGetProgramLocalParameterIuivNV");
            _F(target, index, ps);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_gpu_program4</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetProgramEnvParameterIivNV(GLenum target, GLuint index, GLint * params);</para>
        /// </summary>
        public unsafe static void glGetProgramEnvParameterIivNV(uint target, uint index, int* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetProgramEnvParameterIivNV>("glGetProgramEnvParameterIivNV");
            _F(target, index, ps);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_gpu_program4</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetProgramEnvParameterIuivNV(GLenum target, GLuint index, GLuint * params);</para>
        /// </summary>
        public unsafe static void glGetProgramEnvParameterIuivNV(uint target, uint index, uint* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetProgramEnvParameterIuivNV>("glGetProgramEnvParameterIuivNV");
            _F(target, index, ps);
        }

        #endregion GL_NV_gpu_program4

        #region GL_NV_gpu_program5

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_gpu_program5</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glProgramSubroutineParametersuivNV(GLenum target, GLsizei count, const GLuint * params);</para>
        /// </summary>
        public unsafe static void glProgramSubroutineParametersuivNV(uint target, int count, uint* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglProgramSubroutineParametersuivNV>("glProgramSubroutineParametersuivNV");
            _F(target, count, ps);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_gpu_program5</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetProgramSubroutineParameteruivNV(GLenum target, GLuint index, GLuint * param);</para>
        /// </summary>
        public unsafe static void glGetProgramSubroutineParameteruivNV(uint target, uint index, uint* param) {
            var _F = _GetProc<GLNativeDelegate.FNglGetProgramSubroutineParameteruivNV>("glGetProgramSubroutineParameteruivNV");
            _F(target, index, param);
        }

        #endregion GL_NV_gpu_program5

        #region GL_NV_gpu_shader5

        // void glUniform1i64NV(GLint location, GLint64EXT x);
        // void glUniform2i64NV(GLint location, GLint64EXT x, GLint64EXT y);
        // void glUniform3i64NV(GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z);
        // void glUniform4i64NV(GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z, GLint64EXT w);
        // void glUniform1i64vNV(GLint location, GLsizei count, const GLint64EXT * value);
        // void glUniform2i64vNV(GLint location, GLsizei count, const GLint64EXT * value);
        // void glUniform3i64vNV(GLint location, GLsizei count, const GLint64EXT * value);
        // void glUniform4i64vNV(GLint location, GLsizei count, const GLint64EXT * value);
        // void glUniform1ui64NV(GLint location, GLuint64EXT x);
        // void glUniform2ui64NV(GLint location, GLuint64EXT x, GLuint64EXT y);
        // void glUniform3ui64NV(GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z);
        // void glUniform4ui64NV(GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z, GLuint64EXT w);
        // void glUniform1ui64vNV(GLint location, GLsizei count, const GLuint64EXT * value);
        // void glUniform2ui64vNV(GLint location, GLsizei count, const GLuint64EXT * value);
        // void glUniform3ui64vNV(GLint location, GLsizei count, const GLuint64EXT * value);
        // void glUniform4ui64vNV(GLint location, GLsizei count, const GLuint64EXT * value);
        // void glGetUniformi64vNV(GLuint program, GLint location, GLint64EXT * ps);
        // void glProgramUniform1i64NV(GLuint program, GLint location, GLint64EXT x);
        // void glProgramUniform2i64NV(GLuint program, GLint location, GLint64EXT x, GLint64EXT y);
        // void glProgramUniform3i64NV(GLuint program, GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z);
        // void glProgramUniform4i64NV(GLuint program, GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z, GLint64EXT w);
        // void glProgramUniform1i64vNV(GLuint program, GLint location, GLsizei count, const GLint64EXT * value);
        // void glProgramUniform2i64vNV(GLuint program, GLint location, GLsizei count, const GLint64EXT * value);
        // void glProgramUniform3i64vNV(GLuint program, GLint location, GLsizei count, const GLint64EXT * value);
        // void glProgramUniform4i64vNV(GLuint program, GLint location, GLsizei count, const GLint64EXT * value);
        // void glProgramUniform1ui64NV(GLuint program, GLint location, GLuint64EXT x);
        // void glProgramUniform2ui64NV(GLuint program, GLint location, GLuint64EXT x, GLuint64EXT y);
        // void glProgramUniform3ui64NV(GLuint program, GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z);
        // void glProgramUniform4ui64NV(GLuint program, GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z, GLuint64EXT w);
        // void glProgramUniform1ui64vNV(GLuint program, GLint location, GLsizei count, const GLuint64EXT * value);
        // void glProgramUniform2ui64vNV(GLuint program, GLint location, GLsizei count, const GLuint64EXT * value);
        // void glProgramUniform3ui64vNV(GLuint program, GLint location, GLsizei count, const GLuint64EXT * value);
        // void glProgramUniform4ui64vNV(GLuint program, GLint location, GLsizei count, const GLuint64EXT * value);

        #endregion GL_NV_gpu_shader5

        #region GL_NV_half_float

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_half_float</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertex2hNV(GLhalfNV x, GLhalfNV y);</para>
        /// </summary>
        public static void glVertex2hNV(ushort x, ushort y) {
            var _F = _GetProc<GLNativeDelegate.FNglVertex2hNV>("glVertex2hNV");
            _F(x, y);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_half_float</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertex2hvNV(const GLhalfNV * v);</para>
        /// </summary>
        public unsafe static void glVertex2hvNV(ushort* v) {
            var _F = _GetProc<GLNativeDelegate.FNglVertex2hvNV>("glVertex2hvNV");
            _F(v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_half_float</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertex3hNV(GLhalfNV x, GLhalfNV y, GLhalfNV z);</para>
        /// </summary>
        public static void glVertex3hNV(ushort x, ushort y, ushort z) {
            var _F = _GetProc<GLNativeDelegate.FNglVertex3hNV>("glVertex3hNV");
            _F(x, y, z);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_half_float</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertex3hvNV(const GLhalfNV * v);</para>
        /// </summary>
        public unsafe static void glVertex3hvNV(ushort* v) {
            var _F = _GetProc<GLNativeDelegate.FNglVertex3hvNV>("glVertex3hvNV");
            _F(v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_half_float</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertex4hNV(GLhalfNV x, GLhalfNV y, GLhalfNV z, GLhalfNV w);</para>
        /// </summary>
        public static void glVertex4hNV(ushort x, ushort y, ushort z, ushort w) {
            var _F = _GetProc<GLNativeDelegate.FNglVertex4hNV>("glVertex4hNV");
            _F(x, y, z, w);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_half_float</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertex4hvNV(const GLhalfNV * v);</para>
        /// </summary>
        public unsafe static void glVertex4hvNV(ushort* v) {
            var _F = _GetProc<GLNativeDelegate.FNglVertex4hvNV>("glVertex4hvNV");
            _F(v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_half_float</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glNormal3hNV(GLhalfNV nx, GLhalfNV ny, GLhalfNV nz);</para>
        /// </summary>
        public static void glNormal3hNV(ushort nx, ushort ny, ushort nz) {
            var _F = _GetProc<GLNativeDelegate.FNglNormal3hNV>("glNormal3hNV");
            _F(nx, ny, nz);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_half_float</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glNormal3hvNV(const GLhalfNV * v);</para>
        /// </summary>
        public unsafe static void glNormal3hvNV(ushort* v) {
            var _F = _GetProc<GLNativeDelegate.FNglNormal3hvNV>("glNormal3hvNV");
            _F(v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_half_float</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glColor3hNV(GLhalfNV red, GLhalfNV green, GLhalfNV blue);</para>
        /// </summary>
        public static void glColor3hNV(ushort red, ushort green, ushort blue) {
            var _F = _GetProc<GLNativeDelegate.FNglColor3hNV>("glColor3hNV");
            _F(red, green, blue);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_half_float</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glColor3hvNV(const GLhalfNV * v);</para>
        /// </summary>
        public unsafe static void glColor3hvNV(ushort* v) {
            var _F = _GetProc<GLNativeDelegate.FNglColor3hvNV>("glColor3hvNV");
            _F(v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_half_float</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glColor4hNV(GLhalfNV red, GLhalfNV green, GLhalfNV blue, GLhalfNV alpha);</para>
        /// </summary>
        public static void glColor4hNV(ushort red, ushort green, ushort blue, ushort alpha) {
            var _F = _GetProc<GLNativeDelegate.FNglColor4hNV>("glColor4hNV");
            _F(red, green, blue, alpha);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_half_float</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glColor4hvNV(const GLhalfNV * v);</para>
        /// </summary>
        public unsafe static void glColor4hvNV(ushort* v) {
            var _F = _GetProc<GLNativeDelegate.FNglColor4hvNV>("glColor4hvNV");
            _F(v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_half_float</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glTexCoord1hNV(GLhalfNV s);</para>
        /// </summary>
        public static void glTexCoord1hNV(ushort s) {
            var _F = _GetProc<GLNativeDelegate.FNglTexCoord1hNV>("glTexCoord1hNV");
            _F(s);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_half_float</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glTexCoord1hvNV(const GLhalfNV * v);</para>
        /// </summary>
        public unsafe static void glTexCoord1hvNV(ushort* v) {
            var _F = _GetProc<GLNativeDelegate.FNglTexCoord1hvNV>("glTexCoord1hvNV");
            _F(v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_half_float</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glTexCoord2hNV(GLhalfNV s, GLhalfNV t);</para>
        /// </summary>
        public static void glTexCoord2hNV(ushort s, ushort t) {
            var _F = _GetProc<GLNativeDelegate.FNglTexCoord2hNV>("glTexCoord2hNV");
            _F(s, t);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_half_float</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glTexCoord2hvNV(const GLhalfNV * v);</para>
        /// </summary>
        public unsafe static void glTexCoord2hvNV(ushort* v) {
            var _F = _GetProc<GLNativeDelegate.FNglTexCoord2hvNV>("glTexCoord2hvNV");
            _F(v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_half_float</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glTexCoord3hNV(GLhalfNV s, GLhalfNV t, GLhalfNV r);</para>
        /// </summary>
        public static void glTexCoord3hNV(ushort s, ushort t, ushort r) {
            var _F = _GetProc<GLNativeDelegate.FNglTexCoord3hNV>("glTexCoord3hNV");
            _F(s, t, r);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_half_float</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glTexCoord3hvNV(const GLhalfNV * v);</para>
        /// </summary>
        public unsafe static void glTexCoord3hvNV(ushort* v) {
            var _F = _GetProc<GLNativeDelegate.FNglTexCoord3hvNV>("glTexCoord3hvNV");
            _F(v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_half_float</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glTexCoord4hNV(GLhalfNV s, GLhalfNV t, GLhalfNV r, GLhalfNV q);</para>
        /// </summary>
        public static void glTexCoord4hNV(ushort s, ushort t, ushort r, ushort q) {
            var _F = _GetProc<GLNativeDelegate.FNglTexCoord4hNV>("glTexCoord4hNV");
            _F(s, t, r, q);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_half_float</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glTexCoord4hvNV(const GLhalfNV * v);</para>
        /// </summary>
        public unsafe static void glTexCoord4hvNV(ushort* v) {
            var _F = _GetProc<GLNativeDelegate.FNglTexCoord4hvNV>("glTexCoord4hvNV");
            _F(v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_half_float</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glMultiTexCoord1hNV(GLenum target, GLhalfNV s);</para>
        /// </summary>
        public static void glMultiTexCoord1hNV(uint target, ushort s) {
            var _F = _GetProc<GLNativeDelegate.FNglMultiTexCoord1hNV>("glMultiTexCoord1hNV");
            _F(target, s);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_half_float</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glMultiTexCoord1hvNV(GLenum target, const GLhalfNV * v);</para>
        /// </summary>
        public unsafe static void glMultiTexCoord1hvNV(uint target, ushort* v) {
            var _F = _GetProc<GLNativeDelegate.FNglMultiTexCoord1hvNV>("glMultiTexCoord1hvNV");
            _F(target, v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_half_float</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glMultiTexCoord2hNV(GLenum target, GLhalfNV s, GLhalfNV t);</para>
        /// </summary>
        public static void glMultiTexCoord2hNV(uint target, ushort s, ushort t) {
            var _F = _GetProc<GLNativeDelegate.FNglMultiTexCoord2hNV>("glMultiTexCoord2hNV");
            _F(target, s, t);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_half_float</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glMultiTexCoord2hvNV(GLenum target, const GLhalfNV * v);</para>
        /// </summary>
        public unsafe static void glMultiTexCoord2hvNV(uint target, ushort* v) {
            var _F = _GetProc<GLNativeDelegate.FNglMultiTexCoord2hvNV>("glMultiTexCoord2hvNV");
            _F(target, v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_half_float</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glMultiTexCoord3hNV(GLenum target, GLhalfNV s, GLhalfNV t, GLhalfNV r);</para>
        /// </summary>
        public static void glMultiTexCoord3hNV(uint target, ushort s, ushort t, ushort r) {
            var _F = _GetProc<GLNativeDelegate.FNglMultiTexCoord3hNV>("glMultiTexCoord3hNV");
            _F(target, s, t, r);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_half_float</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glMultiTexCoord3hvNV(GLenum target, const GLhalfNV * v);</para>
        /// </summary>
        public unsafe static void glMultiTexCoord3hvNV(uint target, ushort* v) {
            var _F = _GetProc<GLNativeDelegate.FNglMultiTexCoord3hvNV>("glMultiTexCoord3hvNV");
            _F(target, v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_half_float</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glMultiTexCoord4hNV(GLenum target, GLhalfNV s, GLhalfNV t, GLhalfNV r, GLhalfNV q);</para>
        /// </summary>
        public static void glMultiTexCoord4hNV(uint target, ushort s, ushort t, ushort r, ushort q) {
            var _F = _GetProc<GLNativeDelegate.FNglMultiTexCoord4hNV>("glMultiTexCoord4hNV");
            _F(target, s, t, r, q);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_half_float</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glMultiTexCoord4hvNV(GLenum target, const GLhalfNV * v);</para>
        /// </summary>
        public unsafe static void glMultiTexCoord4hvNV(uint target, ushort* v) {
            var _F = _GetProc<GLNativeDelegate.FNglMultiTexCoord4hvNV>("glMultiTexCoord4hvNV");
            _F(target, v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_half_float</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glFogCoordhNV(GLhalfNV fog);</para>
        /// </summary>
        public static void glFogCoordhNV(ushort fog) {
            var _F = _GetProc<GLNativeDelegate.FNglFogCoordhNV>("glFogCoordhNV");
            _F(fog);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_half_float</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glFogCoordhvNV(const GLhalfNV * fog);</para>
        /// </summary>
        public unsafe static void glFogCoordhvNV(ushort* fog) {
            var _F = _GetProc<GLNativeDelegate.FNglFogCoordhvNV>("glFogCoordhvNV");
            _F(fog);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_half_float</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glSecondaryColor3hNV(GLhalfNV red, GLhalfNV green, GLhalfNV blue);</para>
        /// </summary>
        public static void glSecondaryColor3hNV(ushort red, ushort green, ushort blue) {
            var _F = _GetProc<GLNativeDelegate.FNglSecondaryColor3hNV>("glSecondaryColor3hNV");
            _F(red, green, blue);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_half_float</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glSecondaryColor3hvNV(const GLhalfNV * v);</para>
        /// </summary>
        public unsafe static void glSecondaryColor3hvNV(ushort* v) {
            var _F = _GetProc<GLNativeDelegate.FNglSecondaryColor3hvNV>("glSecondaryColor3hvNV");
            _F(v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_half_float</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexWeighthNV(GLhalfNV weight);</para>
        /// </summary>
        public static void glVertexWeighthNV(ushort weight) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexWeighthNV>("glVertexWeighthNV");
            _F(weight);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_half_float</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexWeighthvNV(const GLhalfNV * weight);</para>
        /// </summary>
        public unsafe static void glVertexWeighthvNV(ushort* weight) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexWeighthvNV>("glVertexWeighthvNV");
            _F(weight);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_half_float</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexAttrib1hNV(GLuint index, GLhalfNV x);</para>
        /// </summary>
        public static void glVertexAttrib1hNV(uint index, ushort x) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttrib1hNV>("glVertexAttrib1hNV");
            _F(index, x);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_half_float</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexAttrib1hvNV(GLuint index, const GLhalfNV * v);</para>
        /// </summary>
        public unsafe static void glVertexAttrib1hvNV(uint index, ushort* v) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttrib1hvNV>("glVertexAttrib1hvNV");
            _F(index, v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_half_float</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexAttrib2hNV(GLuint index, GLhalfNV x, GLhalfNV y);</para>
        /// </summary>
        public static void glVertexAttrib2hNV(uint index, ushort x, ushort y) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttrib2hNV>("glVertexAttrib2hNV");
            _F(index, x, y);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_half_float</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexAttrib2hvNV(GLuint index, const GLhalfNV * v);</para>
        /// </summary>
        public unsafe static void glVertexAttrib2hvNV(uint index, ushort* v) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttrib2hvNV>("glVertexAttrib2hvNV");
            _F(index, v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_half_float</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexAttrib3hNV(GLuint index, GLhalfNV x, GLhalfNV y, GLhalfNV z);</para>
        /// </summary>
        public static void glVertexAttrib3hNV(uint index, ushort x, ushort y, ushort z) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttrib3hNV>("glVertexAttrib3hNV");
            _F(index, x, y, z);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_half_float</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexAttrib3hvNV(GLuint index, const GLhalfNV * v);</para>
        /// </summary>
        public unsafe static void glVertexAttrib3hvNV(uint index, ushort* v) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttrib3hvNV>("glVertexAttrib3hvNV");
            _F(index, v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_half_float</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexAttrib4hNV(GLuint index, GLhalfNV x, GLhalfNV y, GLhalfNV z, GLhalfNV w);</para>
        /// </summary>
        public static void glVertexAttrib4hNV(uint index, ushort x, ushort y, ushort z, ushort w) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttrib4hNV>("glVertexAttrib4hNV");
            _F(index, x, y, z, w);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_half_float</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexAttrib4hvNV(GLuint index, const GLhalfNV * v);</para>
        /// </summary>
        public unsafe static void glVertexAttrib4hvNV(uint index, ushort* v) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttrib4hvNV>("glVertexAttrib4hvNV");
            _F(index, v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_half_float</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexAttribs1hvNV(GLuint index, GLsizei n, const GLhalfNV * v);</para>
        /// </summary>
        public unsafe static void glVertexAttribs1hvNV(uint index, int n, ushort* v) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttribs1hvNV>("glVertexAttribs1hvNV");
            _F(index, n, v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_half_float</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexAttribs2hvNV(GLuint index, GLsizei n, const GLhalfNV * v);</para>
        /// </summary>
        public unsafe static void glVertexAttribs2hvNV(uint index, int n, ushort* v) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttribs2hvNV>("glVertexAttribs2hvNV");
            _F(index, n, v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_half_float</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexAttribs3hvNV(GLuint index, GLsizei n, const GLhalfNV * v);</para>
        /// </summary>
        public unsafe static void glVertexAttribs3hvNV(uint index, int n, ushort* v) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttribs3hvNV>("glVertexAttribs3hvNV");
            _F(index, n, v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_half_float</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexAttribs4hvNV(GLuint index, GLsizei n, const GLhalfNV * v);</para>
        /// </summary>
        public unsafe static void glVertexAttribs4hvNV(uint index, int n, ushort* v) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttribs4hvNV>("glVertexAttribs4hvNV");
            _F(index, n, v);
        }

        #endregion GL_NV_half_float

        #region GL_NV_internalformat_sample_query

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_internalformat_sample_query</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glGetInternalformatSampleivNV(GLenum target, GLenum internalformat, GLsizei samples, GLenum pname, GLsizei count, GLint * params);</para>
        /// </summary>
        public unsafe static void glGetInternalformatSampleivNV(uint target, uint internalformat, int samples, uint pname, int count, int* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetInternalformatSampleivNV>("glGetInternalformatSampleivNV");
            _F(target, internalformat, samples, pname, count, ps);
        }

        #endregion GL_NV_internalformat_sample_query

        #region GL_NV_gpu_multicast

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_gpu_multicast</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glRenderGpuMaskNV(GLbitfield mask);</para>
        /// </summary>
        public static void glRenderGpuMaskNV(uint mask) {
            var _F = _GetProc<GLNativeDelegate.FNglRenderGpuMaskNV>("glRenderGpuMaskNV");
            _F(mask);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_gpu_multicast</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glMulticastBufferSubDataNV(GLbitfield gpuMask, GLuint buffer, GLintptr offset, GLsizeiptr size, const void * data);</para>
        /// </summary>
        public unsafe static void glMulticastBufferSubDataNV(uint gpuMask, uint buffer, IntPtr offset, IntPtr size, void* data) {
            var _F = _GetProc<GLNativeDelegate.FNglMulticastBufferSubDataNV>("glMulticastBufferSubDataNV");
            _F(gpuMask, buffer, offset, size, data);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_gpu_multicast</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glMulticastCopyBufferSubDataNV(GLuint readGpu, GLbitfield writeGpuMask, GLuint readBuffer, GLuint writeBuffer, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size);</para>
        /// </summary>
        public static void glMulticastCopyBufferSubDataNV(uint readGpu, uint writeGpuMask, uint readBuffer, uint writeBuffer, IntPtr readOffset, IntPtr writeOffset, IntPtr size) {
            var _F = _GetProc<GLNativeDelegate.FNglMulticastCopyBufferSubDataNV>("glMulticastCopyBufferSubDataNV");
            _F(readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_gpu_multicast</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glMulticastCopyImageSubDataNV(GLuint srcGpu, GLbitfield dstGpuMask, GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei srcWidth, GLsizei srcHeight, GLsizei srcDepth);</para>
        /// </summary>
        public static void glMulticastCopyImageSubDataNV(uint srcGpu, uint dstGpuMask, uint srcName, uint srcTarget, int srcLevel, int srcX, int srcY, int srcZ, uint dstName, uint dstTarget, int dstLevel, int dstX, int dstY, int dstZ, int srcWidth, int srcHeight, int srcDepth) {
            var _F = _GetProc<GLNativeDelegate.FNglMulticastCopyImageSubDataNV>("glMulticastCopyImageSubDataNV");
            _F(srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_gpu_multicast</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glMulticastBlitFramebufferNV(GLuint srcGpu, GLuint dstGpu, GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter);</para>
        /// </summary>
        public static void glMulticastBlitFramebufferNV(uint srcGpu, uint dstGpu, int srcX0, int srcY0, int srcX1, int srcY1, int dstX0, int dstY0, int dstX1, int dstY1, uint mask, uint filter) {
            var _F = _GetProc<GLNativeDelegate.FNglMulticastBlitFramebufferNV>("glMulticastBlitFramebufferNV");
            _F(srcGpu, dstGpu, srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_gpu_multicast</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glMulticastFramebufferSampleLocationsfvNV(GLuint gpu, GLuint framebuffer, GLuint start, GLsizei count, const GLfloat * v);</para>
        /// </summary>
        public unsafe static void glMulticastFramebufferSampleLocationsfvNV(uint gpu, uint framebuffer, uint start, int count, float* v) {
            var _F = _GetProc<GLNativeDelegate.FNglMulticastFramebufferSampleLocationsfvNV>("glMulticastFramebufferSampleLocationsfvNV");
            _F(gpu, framebuffer, start, count, v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_gpu_multicast</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glMulticastBarrierNV();</para>
        /// </summary>
        public static void glMulticastBarrierNV() {
            var _F = _GetProc<GLNativeDelegate.FNglMulticastBarrierNV>("glMulticastBarrierNV");
            _F();
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_gpu_multicast</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glMulticastWaitSyncNV(GLuint signalGpu, GLbitfield waitGpuMask);</para>
        /// </summary>
        public static void glMulticastWaitSyncNV(uint signalGpu, uint waitGpuMask) {
            var _F = _GetProc<GLNativeDelegate.FNglMulticastWaitSyncNV>("glMulticastWaitSyncNV");
            _F(signalGpu, waitGpuMask);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_gpu_multicast</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glMulticastGetQueryObjectivNV(GLuint gpu, GLuint id, GLenum pname, GLint * params);</para>
        /// </summary>
        public unsafe static void glMulticastGetQueryObjectivNV(uint gpu, uint id, uint pname, int* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglMulticastGetQueryObjectivNV>("glMulticastGetQueryObjectivNV");
            _F(gpu, id, pname, ps);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_gpu_multicast</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glMulticastGetQueryObjectuivNV(GLuint gpu, GLuint id, GLenum pname, GLuint * params);</para>
        /// </summary>
        public unsafe static void glMulticastGetQueryObjectuivNV(uint gpu, uint id, uint pname, uint* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglMulticastGetQueryObjectuivNV>("glMulticastGetQueryObjectuivNV");
            _F(gpu, id, pname, ps);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_gpu_multicast</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glMulticastGetQueryObjecti64vNV(GLuint gpu, GLuint id, GLenum pname, GLint64 * params);</para>
        /// </summary>
        public unsafe static void glMulticastGetQueryObjecti64vNV(uint gpu, uint id, uint pname, UInt64* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglMulticastGetQueryObjecti64vNV>("glMulticastGetQueryObjecti64vNV");
            _F(gpu, id, pname, ps);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_gpu_multicast</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glMulticastGetQueryObjectui64vNV(GLuint gpu, GLuint id, GLenum pname, GLuint64 * params);</para>
        /// </summary>
        public unsafe static void glMulticastGetQueryObjectui64vNV(uint gpu, uint id, uint pname, UInt64* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglMulticastGetQueryObjectui64vNV>("glMulticastGetQueryObjectui64vNV");
            _F(gpu, id, pname, ps);
        }

        #endregion GL_NV_gpu_multicast

        #region GL_NVX_gpu_multicast2

        /// <summary>
        /// <para>Require:</para> <para>GL_NVX_gpu_multicast2</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glUploadGpuMaskNVX(GLbitfield mask);</para>
        /// </summary>
        public static void glUploadGpuMaskNVX(uint mask) {
            var _F = _GetProc<GLNativeDelegate.FNglUploadGpuMaskNVX>("glUploadGpuMaskNVX");
            _F(mask);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NVX_gpu_multicast2</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glMulticastViewportArrayvNVX(GLuint gpu, GLuint first, GLsizei count, const GLfloat * v);</para>
        /// </summary>
        public unsafe static void glMulticastViewportArrayvNVX(uint gpu, uint first, int count, float* v) {
            var _F = _GetProc<GLNativeDelegate.FNglMulticastViewportArrayvNVX>("glMulticastViewportArrayvNVX");
            _F(gpu, first, count, v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NVX_gpu_multicast2</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glMulticastViewportPositionWScaleNVX(GLuint gpu, GLuint index, GLfloat xcoeff, GLfloat ycoeff);</para>
        /// </summary>
        public static void glMulticastViewportPositionWScaleNVX(uint gpu, uint index, float xcoeff, float ycoeff) {
            var _F = _GetProc<GLNativeDelegate.FNglMulticastViewportPositionWScaleNVX>("glMulticastViewportPositionWScaleNVX");
            _F(gpu, index, xcoeff, ycoeff);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NVX_gpu_multicast2</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glMulticastScissorArrayvNVX(GLuint gpu, GLuint first, GLsizei count, const GLint * v);</para>
        /// </summary>
        public unsafe static void glMulticastScissorArrayvNVX(uint gpu, uint first, int count, int* v) {
            var _F = _GetProc<GLNativeDelegate.FNglMulticastScissorArrayvNVX>("glMulticastScissorArrayvNVX");
            _F(gpu, first, count, v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NVX_gpu_multicast2</para>
        /// Supported: <para>gl</para>
        /// Original: <para>GLuint glAsyncCopyBufferSubDataNVX(GLsizei waitSemaphoreCount, const GLuint * waitSemaphoreArray, const GLuint64 * fenceValueArray, GLuint readGpu, GLbitfield writeGpuMask, GLuint readBuffer, GLuint writeBuffer, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size, GLsizei signalSemaphoreCount, const GLuint * signalSemaphoreArray, const GLuint64 * signalValueArray);</para>
        /// </summary>
        public unsafe static uint glAsyncCopyBufferSubDataNVX(int waitSemaphoreCount, uint* waitSemaphoreArray, UInt64* fenceValueArray, uint readGpu, uint writeGpuMask, uint readBuffer, uint writeBuffer, IntPtr readOffset, IntPtr writeOffset, IntPtr size, int signalSemaphoreCount, uint* signalSemaphoreArray, UInt64* signalValueArray) {
            var _F = _GetProc<GLNativeDelegate.FNglAsyncCopyBufferSubDataNVX>("glAsyncCopyBufferSubDataNVX");
            return _F(waitSemaphoreCount, waitSemaphoreArray, fenceValueArray, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, signalSemaphoreArray, signalValueArray);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NVX_gpu_multicast2</para>
        /// Supported: <para>gl</para>
        /// Original: <para>GLuint glAsyncCopyImageSubDataNVX(GLsizei waitSemaphoreCount, const GLuint * waitSemaphoreArray, const GLuint64 * waitValueArray, GLuint srcGpu, GLbitfield dstGpuMask, GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei srcWidth, GLsizei srcHeight, GLsizei srcDepth, GLsizei signalSemaphoreCount, const GLuint * signalSemaphoreArray, const GLuint64 * signalValueArray);</para>
        /// </summary>
        public unsafe static uint glAsyncCopyImageSubDataNVX(int waitSemaphoreCount, uint* waitSemaphoreArray, UInt64* waitValueArray, uint srcGpu, uint dstGpuMask, uint srcName, uint srcTarget, int srcLevel, int srcX, int srcY, int srcZ, uint dstName, uint dstTarget, int dstLevel, int dstX, int dstY, int dstZ, int srcWidth, int srcHeight, int srcDepth, int signalSemaphoreCount, uint* signalSemaphoreArray, UInt64* signalValueArray) {
            var _F = _GetProc<GLNativeDelegate.FNglAsyncCopyImageSubDataNVX>("glAsyncCopyImageSubDataNVX");
            return _F(waitSemaphoreCount, waitSemaphoreArray, waitValueArray, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, signalSemaphoreArray, signalValueArray);
        }

        #endregion GL_NVX_gpu_multicast2

        #region GL_NVX_progress_fence

        /// <summary>
        /// <para>Require:</para> <para>GL_NVX_progress_fence</para>
        /// Supported: <para>gl</para>
        /// Original: <para>GLuint glCreateProgressFenceNVX();</para>
        /// </summary>
        public static uint glCreateProgressFenceNVX() {
            var _F = _GetProc<GLNativeDelegate.FNglCreateProgressFenceNVX>("glCreateProgressFenceNVX");
            return _F();
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NVX_progress_fence</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glSignalSemaphoreui64NVX(GLuint signalGpu, GLsizei fenceObjectCount, const GLuint * semaphoreArray, const GLuint64 * fenceValueArray);</para>
        /// </summary>
        public unsafe static void glSignalSemaphoreui64NVX(uint signalGpu, int fenceObjectCount, uint* semaphoreArray, UInt64* fenceValueArray) {
            var _F = _GetProc<GLNativeDelegate.FNglSignalSemaphoreui64NVX>("glSignalSemaphoreui64NVX");
            _F(signalGpu, fenceObjectCount, semaphoreArray, fenceValueArray);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NVX_progress_fence</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glWaitSemaphoreui64NVX(GLuint waitGpu, GLsizei fenceObjectCount, const GLuint * semaphoreArray, const GLuint64 * fenceValueArray);</para>
        /// </summary>
        public unsafe static void glWaitSemaphoreui64NVX(uint waitGpu, int fenceObjectCount, uint* semaphoreArray, UInt64* fenceValueArray) {
            var _F = _GetProc<GLNativeDelegate.FNglWaitSemaphoreui64NVX>("glWaitSemaphoreui64NVX");
            _F(waitGpu, fenceObjectCount, semaphoreArray, fenceValueArray);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NVX_progress_fence</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glClientWaitSemaphoreui64NVX(GLsizei fenceObjectCount, const GLuint * semaphoreArray, const GLuint64 * fenceValueArray);</para>
        /// </summary>
        public unsafe static void glClientWaitSemaphoreui64NVX(int fenceObjectCount, uint* semaphoreArray, UInt64* fenceValueArray) {
            var _F = _GetProc<GLNativeDelegate.FNglClientWaitSemaphoreui64NVX>("glClientWaitSemaphoreui64NVX");
            _F(fenceObjectCount, semaphoreArray, fenceValueArray);
        }

        #endregion GL_NVX_progress_fence

        #region GL_NV_memory_attachment

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_memory_attachment</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glGetMemoryObjectDetachedResourcesuivNV(GLuint memory, GLenum pname, GLint first, GLsizei count, GLuint * params);</para>
        /// </summary>
        public unsafe static void glGetMemoryObjectDetachedResourcesuivNV(uint memory, uint pname, int first, int count, uint* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetMemoryObjectDetachedResourcesuivNV>("glGetMemoryObjectDetachedResourcesuivNV");
            _F(memory, pname, first, count, ps);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_memory_attachment</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glResetMemoryObjectParameterNV(GLuint memory, GLenum pname);</para>
        /// </summary>
        public static void glResetMemoryObjectParameterNV(uint memory, uint pname) {
            var _F = _GetProc<GLNativeDelegate.FNglResetMemoryObjectParameterNV>("glResetMemoryObjectParameterNV");
            _F(memory, pname);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_memory_attachment</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glTexAttachMemoryNV(GLenum target, GLuint memory, GLuint64 offset);</para>
        /// </summary>
        public static void glTexAttachMemoryNV(uint target, uint memory, UInt64 offset) {
            var _F = _GetProc<GLNativeDelegate.FNglTexAttachMemoryNV>("glTexAttachMemoryNV");
            _F(target, memory, offset);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_memory_attachment</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glBufferAttachMemoryNV(GLenum target, GLuint memory, GLuint64 offset);</para>
        /// </summary>
        public static void glBufferAttachMemoryNV(uint target, uint memory, UInt64 offset) {
            var _F = _GetProc<GLNativeDelegate.FNglBufferAttachMemoryNV>("glBufferAttachMemoryNV");
            _F(target, memory, offset);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_memory_attachment</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glTextureAttachMemoryNV(GLuint texture, GLuint memory, GLuint64 offset);</para>
        /// </summary>
        public static void glTextureAttachMemoryNV(uint texture, uint memory, UInt64 offset) {
            var _F = _GetProc<GLNativeDelegate.FNglTextureAttachMemoryNV>("glTextureAttachMemoryNV");
            _F(texture, memory, offset);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_memory_attachment</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glNamedBufferAttachMemoryNV(GLuint buffer, GLuint memory, GLuint64 offset);</para>
        /// </summary>
        public static void glNamedBufferAttachMemoryNV(uint buffer, uint memory, UInt64 offset) {
            var _F = _GetProc<GLNativeDelegate.FNglNamedBufferAttachMemoryNV>("glNamedBufferAttachMemoryNV");
            _F(buffer, memory, offset);
        }

        #endregion GL_NV_memory_attachment

        #region GL_NV_memory_object_sparse

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_memory_object_sparse</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glBufferPageCommitmentMemNV(GLenum target, GLintptr offset, GLsizeiptr size, GLuint memory, GLuint64 memOffset, GLboolean commit);</para>
        /// </summary>
        public static void glBufferPageCommitmentMemNV(uint target, IntPtr offset, IntPtr size, uint memory, UInt64 memOffset, bool commit) {
            var _F = _GetProc<GLNativeDelegate.FNglBufferPageCommitmentMemNV>("glBufferPageCommitmentMemNV");
            _F(target, offset, size, memory, memOffset, commit);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_memory_object_sparse</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glTexPageCommitmentMemNV(GLenum target, GLint layer, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLuint memory, GLuint64 offset, GLboolean commit);</para>
        /// </summary>
        public static void glTexPageCommitmentMemNV(uint target, int layer, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, uint memory, UInt64 offset, bool commit) {
            var _F = _GetProc<GLNativeDelegate.FNglTexPageCommitmentMemNV>("glTexPageCommitmentMemNV");
            _F(target, layer, level, xoffset, yoffset, zoffset, width, height, depth, memory, offset, commit);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_memory_object_sparse</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glNamedBufferPageCommitmentMemNV(GLuint buffer, GLintptr offset, GLsizeiptr size, GLuint memory, GLuint64 memOffset, GLboolean commit);</para>
        /// </summary>
        public static void glNamedBufferPageCommitmentMemNV(uint buffer, IntPtr offset, IntPtr size, uint memory, UInt64 memOffset, bool commit) {
            var _F = _GetProc<GLNativeDelegate.FNglNamedBufferPageCommitmentMemNV>("glNamedBufferPageCommitmentMemNV");
            _F(buffer, offset, size, memory, memOffset, commit);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_memory_object_sparse</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glTexturePageCommitmentMemNV(GLuint texture, GLint layer, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLuint memory, GLuint64 offset, GLboolean commit);</para>
        /// </summary>
        public static void glTexturePageCommitmentMemNV(uint texture, int layer, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, uint memory, UInt64 offset, bool commit) {
            var _F = _GetProc<GLNativeDelegate.FNglTexturePageCommitmentMemNV>("glTexturePageCommitmentMemNV");
            _F(texture, layer, level, xoffset, yoffset, zoffset, width, height, depth, memory, offset, commit);
        }

        #endregion GL_NV_memory_object_sparse

        #region GL_NV_mesh_shader

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_mesh_shader</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glDrawMeshTasksNV(GLuint first, GLuint count);</para>
        /// </summary>
        public static void glDrawMeshTasksNV(uint first, uint count) {
            var _F = _GetProc<GLNativeDelegate.FNglDrawMeshTasksNV>("glDrawMeshTasksNV");
            _F(first, count);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_mesh_shader</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glDrawMeshTasksIndirectNV(GLintptr indirect);</para>
        /// </summary>
        public static void glDrawMeshTasksIndirectNV(IntPtr indirect) {
            var _F = _GetProc<GLNativeDelegate.FNglDrawMeshTasksIndirectNV>("glDrawMeshTasksIndirectNV");
            _F(indirect);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_mesh_shader</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glMultiDrawMeshTasksIndirectNV(GLintptr indirect, GLsizei drawcount, GLsizei stride);</para>
        /// </summary>
        public static void glMultiDrawMeshTasksIndirectNV(IntPtr indirect, int drawcount, int stride) {
            var _F = _GetProc<GLNativeDelegate.FNglMultiDrawMeshTasksIndirectNV>("glMultiDrawMeshTasksIndirectNV");
            _F(indirect, drawcount, stride);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_mesh_shader</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glMultiDrawMeshTasksIndirectCountNV(GLintptr indirect, GLintptr drawcount, GLsizei maxdrawcount, GLsizei stride);</para>
        /// </summary>
        public static void glMultiDrawMeshTasksIndirectCountNV(IntPtr indirect, IntPtr drawcount, int maxdrawcount, int stride) {
            var _F = _GetProc<GLNativeDelegate.FNglMultiDrawMeshTasksIndirectCountNV>("glMultiDrawMeshTasksIndirectCountNV");
            _F(indirect, drawcount, maxdrawcount, stride);
        }

        #endregion GL_NV_mesh_shader

        #region GL_NV_occlusion_query

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_occlusion_query</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGenOcclusionQueriesNV(GLsizei n, GLuint * ids);</para>
        /// </summary>
        public unsafe static void glGenOcclusionQueriesNV(int n, uint* ids) {
            var _F = _GetProc<GLNativeDelegate.FNglGenOcclusionQueriesNV>("glGenOcclusionQueriesNV");
            _F(n, ids);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_occlusion_query</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glDeleteOcclusionQueriesNV(GLsizei n, const GLuint * ids);</para>
        /// </summary>
        public unsafe static void glDeleteOcclusionQueriesNV(int n, uint* ids) {
            var _F = _GetProc<GLNativeDelegate.FNglDeleteOcclusionQueriesNV>("glDeleteOcclusionQueriesNV");
            _F(n, ids);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_occlusion_query</para>
        /// Supported: <para>gl</para>
        /// Original: <para>GLboolean glIsOcclusionQueryNV(GLuint id);</para>
        /// </summary>
        public static bool glIsOcclusionQueryNV(uint id) {
            var _F = _GetProc<GLNativeDelegate.FNglIsOcclusionQueryNV>("glIsOcclusionQueryNV");
            return _F(id);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_occlusion_query</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glBeginOcclusionQueryNV(GLuint id);</para>
        /// </summary>
        public static void glBeginOcclusionQueryNV(uint id) {
            var _F = _GetProc<GLNativeDelegate.FNglBeginOcclusionQueryNV>("glBeginOcclusionQueryNV");
            _F(id);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_occlusion_query</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glEndOcclusionQueryNV();</para>
        /// </summary>
        public static void glEndOcclusionQueryNV() {
            var _F = _GetProc<GLNativeDelegate.FNglEndOcclusionQueryNV>("glEndOcclusionQueryNV");
            _F();
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_occlusion_query</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetOcclusionQueryivNV(GLuint id, GLenum pname, GLint * params);</para>
        /// </summary>
        public unsafe static void glGetOcclusionQueryivNV(uint id, uint pname, int* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetOcclusionQueryivNV>("glGetOcclusionQueryivNV");
            _F(id, pname, ps);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_occlusion_query</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetOcclusionQueryuivNV(GLuint id, GLenum pname, GLuint * params);</para>
        /// </summary>
        public unsafe static void glGetOcclusionQueryuivNV(uint id, uint pname, uint* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetOcclusionQueryuivNV>("glGetOcclusionQueryuivNV");
            _F(id, pname, ps);
        }

        #endregion GL_NV_occlusion_query

        #region GL_NV_parameter_buffer_object

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_parameter_buffer_object</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glProgramBufferParametersfvNV(GLenum target, GLuint bindingIndex, GLuint wordIndex, GLsizei count, const GLfloat * params);</para>
        /// </summary>
        public unsafe static void glProgramBufferParametersfvNV(uint target, uint bindingIndex, uint wordIndex, int count, float* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglProgramBufferParametersfvNV>("glProgramBufferParametersfvNV");
            _F(target, bindingIndex, wordIndex, count, ps);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_parameter_buffer_object</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glProgramBufferParametersIivNV(GLenum target, GLuint bindingIndex, GLuint wordIndex, GLsizei count, const GLint * params);</para>
        /// </summary>
        public unsafe static void glProgramBufferParametersIivNV(uint target, uint bindingIndex, uint wordIndex, int count, int* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglProgramBufferParametersIivNV>("glProgramBufferParametersIivNV");
            _F(target, bindingIndex, wordIndex, count, ps);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_parameter_buffer_object</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glProgramBufferParametersIuivNV(GLenum target, GLuint bindingIndex, GLuint wordIndex, GLsizei count, const GLuint * params);</para>
        /// </summary>
        public unsafe static void glProgramBufferParametersIuivNV(uint target, uint bindingIndex, uint wordIndex, int count, uint* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglProgramBufferParametersIuivNV>("glProgramBufferParametersIuivNV");
            _F(target, bindingIndex, wordIndex, count, ps);
        }

        #endregion GL_NV_parameter_buffer_object

        #region GL_NV_path_rendering

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_path_rendering</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>GLuint glGenPathsNV(GLsizei range);</para>
        /// </summary>
        public static uint glGenPathsNV(int range) {
            var _F = _GetProc<GLNativeDelegate.FNglGenPathsNV>("glGenPathsNV");
            return _F(range);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_path_rendering</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glDeletePathsNV(GLuint path, GLsizei range);</para>
        /// </summary>
        public static void glDeletePathsNV(uint path, int range) {
            var _F = _GetProc<GLNativeDelegate.FNglDeletePathsNV>("glDeletePathsNV");
            _F(path, range);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_path_rendering</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>GLboolean glIsPathNV(GLuint path);</para>
        /// </summary>
        public static bool glIsPathNV(uint path) {
            var _F = _GetProc<GLNativeDelegate.FNglIsPathNV>("glIsPathNV");
            return _F(path);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_path_rendering</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glPathCommandsNV(GLuint path, GLsizei numCommands, const GLubyte * commands, GLsizei numCoords, GLenum coordType, const void * coords);</para>
        /// </summary>
        public unsafe static void glPathCommandsNV(uint path, int numCommands, byte* commands, int numCoords, uint coordType, void* coords) {
            var _F = _GetProc<GLNativeDelegate.FNglPathCommandsNV>("glPathCommandsNV");
            _F(path, numCommands, commands, numCoords, coordType, coords);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_path_rendering</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glPathCoordsNV(GLuint path, GLsizei numCoords, GLenum coordType, const void * coords);</para>
        /// </summary>
        public unsafe static void glPathCoordsNV(uint path, int numCoords, uint coordType, void* coords) {
            var _F = _GetProc<GLNativeDelegate.FNglPathCoordsNV>("glPathCoordsNV");
            _F(path, numCoords, coordType, coords);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_path_rendering</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glPathSubCommandsNV(GLuint path, GLsizei commandStart, GLsizei commandsToDelete, GLsizei numCommands, const GLubyte * commands, GLsizei numCoords, GLenum coordType, const void * coords);</para>
        /// </summary>
        public unsafe static void glPathSubCommandsNV(uint path, int commandStart, int commandsToDelete, int numCommands, byte* commands, int numCoords, uint coordType, void* coords) {
            var _F = _GetProc<GLNativeDelegate.FNglPathSubCommandsNV>("glPathSubCommandsNV");
            _F(path, commandStart, commandsToDelete, numCommands, commands, numCoords, coordType, coords);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_path_rendering</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glPathSubCoordsNV(GLuint path, GLsizei coordStart, GLsizei numCoords, GLenum coordType, const void * coords);</para>
        /// </summary>
        public unsafe static void glPathSubCoordsNV(uint path, int coordStart, int numCoords, uint coordType, void* coords) {
            var _F = _GetProc<GLNativeDelegate.FNglPathSubCoordsNV>("glPathSubCoordsNV");
            _F(path, coordStart, numCoords, coordType, coords);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_path_rendering</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glPathStringNV(GLuint path, GLenum format, GLsizei length, const void * pathString);</para>
        /// </summary>
        public unsafe static void glPathStringNV(uint path, uint format, int length, void* pathString) {
            var _F = _GetProc<GLNativeDelegate.FNglPathStringNV>("glPathStringNV");
            _F(path, format, length, pathString);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_path_rendering</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glPathGlyphsNV(GLuint firstPathName, GLenum fontTarget, const void * fontName, GLbitfield fontStyle, GLsizei numGlyphs, GLenum type, const void * charcodes, GLenum handleMissingGlyphs, GLuint pathParameterTemplate, GLfloat emScale);</para>
        /// </summary>
        public unsafe static void glPathGlyphsNV(uint firstPathName, uint fontTarget, void* fontName, uint fontStyle, int numGlyphs, uint type, void* charcodes, uint handleMissingGlyphs, uint pathParameterTemplate, float emScale) {
            var _F = _GetProc<GLNativeDelegate.FNglPathGlyphsNV>("glPathGlyphsNV");
            _F(firstPathName, fontTarget, fontName, fontStyle, numGlyphs, type, charcodes, handleMissingGlyphs, pathParameterTemplate, emScale);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_path_rendering</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glPathGlyphRangeNV(GLuint firstPathName, GLenum fontTarget, const void * fontName, GLbitfield fontStyle, GLuint firstGlyph, GLsizei numGlyphs, GLenum handleMissingGlyphs, GLuint pathParameterTemplate, GLfloat emScale);</para>
        /// </summary>
        public unsafe static void glPathGlyphRangeNV(uint firstPathName, uint fontTarget, void* fontName, uint fontStyle, uint firstGlyph, int numGlyphs, uint handleMissingGlyphs, uint pathParameterTemplate, float emScale) {
            var _F = _GetProc<GLNativeDelegate.FNglPathGlyphRangeNV>("glPathGlyphRangeNV");
            _F(firstPathName, fontTarget, fontName, fontStyle, firstGlyph, numGlyphs, handleMissingGlyphs, pathParameterTemplate, emScale);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_path_rendering</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glWeightPathsNV(GLuint resultPath, GLsizei numPaths, const GLuint * paths, const GLfloat * weights);</para>
        /// </summary>
        public unsafe static void glWeightPathsNV(uint resultPath, int numPaths, uint* paths, float* weights) {
            var _F = _GetProc<GLNativeDelegate.FNglWeightPathsNV>("glWeightPathsNV");
            _F(resultPath, numPaths, paths, weights);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_path_rendering</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glCopyPathNV(GLuint resultPath, GLuint srcPath);</para>
        /// </summary>
        public static void glCopyPathNV(uint resultPath, uint srcPath) {
            var _F = _GetProc<GLNativeDelegate.FNglCopyPathNV>("glCopyPathNV");
            _F(resultPath, srcPath);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_path_rendering</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glInterpolatePathsNV(GLuint resultPath, GLuint pathA, GLuint pathB, GLfloat weight);</para>
        /// </summary>
        public static void glInterpolatePathsNV(uint resultPath, uint pathA, uint pathB, float weight) {
            var _F = _GetProc<GLNativeDelegate.FNglInterpolatePathsNV>("glInterpolatePathsNV");
            _F(resultPath, pathA, pathB, weight);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_path_rendering</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glTransformPathNV(GLuint resultPath, GLuint srcPath, GLenum transformType, const GLfloat * transformValues);</para>
        /// </summary>
        public unsafe static void glTransformPathNV(uint resultPath, uint srcPath, uint transformType, float* transformValues) {
            var _F = _GetProc<GLNativeDelegate.FNglTransformPathNV>("glTransformPathNV");
            _F(resultPath, srcPath, transformType, transformValues);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_path_rendering</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glPathParameterivNV(GLuint path, GLenum pname, const GLint * value);</para>
        /// </summary>
        public unsafe static void glPathParameterivNV(uint path, uint pname, int* value) {
            var _F = _GetProc<GLNativeDelegate.FNglPathParameterivNV>("glPathParameterivNV");
            _F(path, pname, value);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_path_rendering</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glPathParameteriNV(GLuint path, GLenum pname, GLint value);</para>
        /// </summary>
        public static void glPathParameteriNV(uint path, uint pname, int value) {
            var _F = _GetProc<GLNativeDelegate.FNglPathParameteriNV>("glPathParameteriNV");
            _F(path, pname, value);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_path_rendering</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glPathParameterfvNV(GLuint path, GLenum pname, const GLfloat * value);</para>
        /// </summary>
        public unsafe static void glPathParameterfvNV(uint path, uint pname, float* value) {
            var _F = _GetProc<GLNativeDelegate.FNglPathParameterfvNV>("glPathParameterfvNV");
            _F(path, pname, value);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_path_rendering</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glPathParameterfNV(GLuint path, GLenum pname, GLfloat value);</para>
        /// </summary>
        public static void glPathParameterfNV(uint path, uint pname, float value) {
            var _F = _GetProc<GLNativeDelegate.FNglPathParameterfNV>("glPathParameterfNV");
            _F(path, pname, value);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_path_rendering</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glPathDashArrayNV(GLuint path, GLsizei dashCount, const GLfloat * dashArray);</para>
        /// </summary>
        public unsafe static void glPathDashArrayNV(uint path, int dashCount, float* dashArray) {
            var _F = _GetProc<GLNativeDelegate.FNglPathDashArrayNV>("glPathDashArrayNV");
            _F(path, dashCount, dashArray);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_path_rendering</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glPathStencilFuncNV(GLenum func, GLint ref, GLuint mask);</para>
        /// </summary>
        public static void glPathStencilFuncNV(uint func, int r, uint mask) {
            var _F = _GetProc<GLNativeDelegate.FNglPathStencilFuncNV>("glPathStencilFuncNV");
            _F(func, r, mask);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_path_rendering</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glPathStencilDepthOffsetNV(GLfloat factor, GLfloat units);</para>
        /// </summary>
        public static void glPathStencilDepthOffsetNV(float factor, float units) {
            var _F = _GetProc<GLNativeDelegate.FNglPathStencilDepthOffsetNV>("glPathStencilDepthOffsetNV");
            _F(factor, units);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_path_rendering</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glStencilFillPathNV(GLuint path, GLenum fillMode, GLuint mask);</para>
        /// </summary>
        public static void glStencilFillPathNV(uint path, uint fillMode, uint mask) {
            var _F = _GetProc<GLNativeDelegate.FNglStencilFillPathNV>("glStencilFillPathNV");
            _F(path, fillMode, mask);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_path_rendering</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glStencilStrokePathNV(GLuint path, GLint reference, GLuint mask);</para>
        /// </summary>
        public static void glStencilStrokePathNV(uint path, int reference, uint mask) {
            var _F = _GetProc<GLNativeDelegate.FNglStencilStrokePathNV>("glStencilStrokePathNV");
            _F(path, reference, mask);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_path_rendering</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glStencilFillPathInstancedNV(GLsizei numPaths, GLenum pathNameType, const void * paths, GLuint pathBase, GLenum fillMode, GLuint mask, GLenum transformType, const GLfloat * transformValues);</para>
        /// </summary>
        public unsafe static void glStencilFillPathInstancedNV(int numPaths, uint pathNameType, void* paths, uint pathBase, uint fillMode, uint mask, uint transformType, float* transformValues) {
            var _F = _GetProc<GLNativeDelegate.FNglStencilFillPathInstancedNV>("glStencilFillPathInstancedNV");
            _F(numPaths, pathNameType, paths, pathBase, fillMode, mask, transformType, transformValues);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_path_rendering</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glStencilStrokePathInstancedNV(GLsizei numPaths, GLenum pathNameType, const void * paths, GLuint pathBase, GLint reference, GLuint mask, GLenum transformType, const GLfloat * transformValues);</para>
        /// </summary>
        public unsafe static void glStencilStrokePathInstancedNV(int numPaths, uint pathNameType, void* paths, uint pathBase, int reference, uint mask, uint transformType, float* transformValues) {
            var _F = _GetProc<GLNativeDelegate.FNglStencilStrokePathInstancedNV>("glStencilStrokePathInstancedNV");
            _F(numPaths, pathNameType, paths, pathBase, reference, mask, transformType, transformValues);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_path_rendering</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glPathCoverDepthFuncNV(GLenum func);</para>
        /// </summary>
        public static void glPathCoverDepthFuncNV(uint func) {
            var _F = _GetProc<GLNativeDelegate.FNglPathCoverDepthFuncNV>("glPathCoverDepthFuncNV");
            _F(func);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_path_rendering</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glCoverFillPathNV(GLuint path, GLenum coverMode);</para>
        /// </summary>
        public static void glCoverFillPathNV(uint path, uint coverMode) {
            var _F = _GetProc<GLNativeDelegate.FNglCoverFillPathNV>("glCoverFillPathNV");
            _F(path, coverMode);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_path_rendering</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glCoverStrokePathNV(GLuint path, GLenum coverMode);</para>
        /// </summary>
        public static void glCoverStrokePathNV(uint path, uint coverMode) {
            var _F = _GetProc<GLNativeDelegate.FNglCoverStrokePathNV>("glCoverStrokePathNV");
            _F(path, coverMode);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_path_rendering</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glCoverFillPathInstancedNV(GLsizei numPaths, GLenum pathNameType, const void * paths, GLuint pathBase, GLenum coverMode, GLenum transformType, const GLfloat * transformValues);</para>
        /// </summary>
        public unsafe static void glCoverFillPathInstancedNV(int numPaths, uint pathNameType, void* paths, uint pathBase, uint coverMode, uint transformType, float* transformValues) {
            var _F = _GetProc<GLNativeDelegate.FNglCoverFillPathInstancedNV>("glCoverFillPathInstancedNV");
            _F(numPaths, pathNameType, paths, pathBase, coverMode, transformType, transformValues);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_path_rendering</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glCoverStrokePathInstancedNV(GLsizei numPaths, GLenum pathNameType, const void * paths, GLuint pathBase, GLenum coverMode, GLenum transformType, const GLfloat * transformValues);</para>
        /// </summary>
        public unsafe static void glCoverStrokePathInstancedNV(int numPaths, uint pathNameType, void* paths, uint pathBase, uint coverMode, uint transformType, float* transformValues) {
            var _F = _GetProc<GLNativeDelegate.FNglCoverStrokePathInstancedNV>("glCoverStrokePathInstancedNV");
            _F(numPaths, pathNameType, paths, pathBase, coverMode, transformType, transformValues);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_path_rendering</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glGetPathParameterivNV(GLuint path, GLenum pname, GLint * value);</para>
        /// </summary>
        public unsafe static void glGetPathParameterivNV(uint path, uint pname, int* value) {
            var _F = _GetProc<GLNativeDelegate.FNglGetPathParameterivNV>("glGetPathParameterivNV");
            _F(path, pname, value);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_path_rendering</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glGetPathParameterfvNV(GLuint path, GLenum pname, GLfloat * value);</para>
        /// </summary>
        public unsafe static void glGetPathParameterfvNV(uint path, uint pname, float* value) {
            var _F = _GetProc<GLNativeDelegate.FNglGetPathParameterfvNV>("glGetPathParameterfvNV");
            _F(path, pname, value);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_path_rendering</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glGetPathCommandsNV(GLuint path, GLubyte * commands);</para>
        /// </summary>
        public unsafe static void glGetPathCommandsNV(uint path, byte* commands) {
            var _F = _GetProc<GLNativeDelegate.FNglGetPathCommandsNV>("glGetPathCommandsNV");
            _F(path, commands);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_path_rendering</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glGetPathCoordsNV(GLuint path, GLfloat * coords);</para>
        /// </summary>
        public unsafe static void glGetPathCoordsNV(uint path, float* coords) {
            var _F = _GetProc<GLNativeDelegate.FNglGetPathCoordsNV>("glGetPathCoordsNV");
            _F(path, coords);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_path_rendering</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glGetPathDashArrayNV(GLuint path, GLfloat * dashArray);</para>
        /// </summary>
        public unsafe static void glGetPathDashArrayNV(uint path, float* dashArray) {
            var _F = _GetProc<GLNativeDelegate.FNglGetPathDashArrayNV>("glGetPathDashArrayNV");
            _F(path, dashArray);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_path_rendering</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glGetPathMetricsNV(GLbitfield metricQueryMask, GLsizei numPaths, GLenum pathNameType, const void * paths, GLuint pathBase, GLsizei stride, GLfloat * metrics);</para>
        /// </summary>
        public unsafe static void glGetPathMetricsNV(uint metricQueryMask, int numPaths, uint pathNameType, void* paths, uint pathBase, int stride, float* metrics) {
            var _F = _GetProc<GLNativeDelegate.FNglGetPathMetricsNV>("glGetPathMetricsNV");
            _F(metricQueryMask, numPaths, pathNameType, paths, pathBase, stride, metrics);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_path_rendering</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glGetPathMetricRangeNV(GLbitfield metricQueryMask, GLuint firstPathName, GLsizei numPaths, GLsizei stride, GLfloat * metrics);</para>
        /// </summary>
        public unsafe static void glGetPathMetricRangeNV(uint metricQueryMask, uint firstPathName, int numPaths, int stride, float* metrics) {
            var _F = _GetProc<GLNativeDelegate.FNglGetPathMetricRangeNV>("glGetPathMetricRangeNV");
            _F(metricQueryMask, firstPathName, numPaths, stride, metrics);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_path_rendering</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glGetPathSpacingNV(GLenum pathListMode, GLsizei numPaths, GLenum pathNameType, const void * paths, GLuint pathBase, GLfloat advanceScale, GLfloat kerningScale, GLenum transformType, GLfloat * returnedSpacing);</para>
        /// </summary>
        public unsafe static void glGetPathSpacingNV(uint pathListMode, int numPaths, uint pathNameType, void* paths, uint pathBase, float advanceScale, float kerningScale, uint transformType, float* returnedSpacing) {
            var _F = _GetProc<GLNativeDelegate.FNglGetPathSpacingNV>("glGetPathSpacingNV");
            _F(pathListMode, numPaths, pathNameType, paths, pathBase, advanceScale, kerningScale, transformType, returnedSpacing);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_path_rendering</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>GLboolean glIsPointInFillPathNV(GLuint path, GLuint mask, GLfloat x, GLfloat y);</para>
        /// </summary>
        public static bool glIsPointInFillPathNV(uint path, uint mask, float x, float y) {
            var _F = _GetProc<GLNativeDelegate.FNglIsPointInFillPathNV>("glIsPointInFillPathNV");
            return _F(path, mask, x, y);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_path_rendering</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>GLboolean glIsPointInStrokePathNV(GLuint path, GLfloat x, GLfloat y);</para>
        /// </summary>
        public static bool glIsPointInStrokePathNV(uint path, float x, float y) {
            var _F = _GetProc<GLNativeDelegate.FNglIsPointInStrokePathNV>("glIsPointInStrokePathNV");
            return _F(path, x, y);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_path_rendering</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>GLfloat glGetPathLengthNV(GLuint path, GLsizei startSegment, GLsizei numSegments);</para>
        /// </summary>
        public static float glGetPathLengthNV(uint path, int startSegment, int numSegments) {
            var _F = _GetProc<GLNativeDelegate.FNglGetPathLengthNV>("glGetPathLengthNV");
            return _F(path, startSegment, numSegments);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_path_rendering</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>GLboolean glPointAlongPathNV(GLuint path, GLsizei startSegment, GLsizei numSegments, GLfloat distance, GLfloat * x, GLfloat * y, GLfloat * tangentX, GLfloat * tangentY);</para>
        /// </summary>
        public unsafe static bool glPointAlongPathNV(uint path, int startSegment, int numSegments, float distance, float* x, float* y, float* tangentX, float* tangentY) {
            var _F = _GetProc<GLNativeDelegate.FNglPointAlongPathNV>("glPointAlongPathNV");
            return _F(path, startSegment, numSegments, distance, x, y, tangentX, tangentY);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_path_rendering</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glMatrixLoad3x2fNV(GLenum matrixMode, const GLfloat * m);</para>
        /// </summary>
        public unsafe static void glMatrixLoad3x2fNV(uint matrixMode, float* m) {
            var _F = _GetProc<GLNativeDelegate.FNglMatrixLoad3x2fNV>("glMatrixLoad3x2fNV");
            _F(matrixMode, m);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_path_rendering</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glMatrixLoad3x3fNV(GLenum matrixMode, const GLfloat * m);</para>
        /// </summary>
        public unsafe static void glMatrixLoad3x3fNV(uint matrixMode, float* m) {
            var _F = _GetProc<GLNativeDelegate.FNglMatrixLoad3x3fNV>("glMatrixLoad3x3fNV");
            _F(matrixMode, m);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_path_rendering</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glMatrixLoadTranspose3x3fNV(GLenum matrixMode, const GLfloat * m);</para>
        /// </summary>
        public unsafe static void glMatrixLoadTranspose3x3fNV(uint matrixMode, float* m) {
            var _F = _GetProc<GLNativeDelegate.FNglMatrixLoadTranspose3x3fNV>("glMatrixLoadTranspose3x3fNV");
            _F(matrixMode, m);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_path_rendering</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glMatrixMult3x2fNV(GLenum matrixMode, const GLfloat * m);</para>
        /// </summary>
        public unsafe static void glMatrixMult3x2fNV(uint matrixMode, float* m) {
            var _F = _GetProc<GLNativeDelegate.FNglMatrixMult3x2fNV>("glMatrixMult3x2fNV");
            _F(matrixMode, m);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_path_rendering</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glMatrixMult3x3fNV(GLenum matrixMode, const GLfloat * m);</para>
        /// </summary>
        public unsafe static void glMatrixMult3x3fNV(uint matrixMode, float* m) {
            var _F = _GetProc<GLNativeDelegate.FNglMatrixMult3x3fNV>("glMatrixMult3x3fNV");
            _F(matrixMode, m);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_path_rendering</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glMatrixMultTranspose3x3fNV(GLenum matrixMode, const GLfloat * m);</para>
        /// </summary>
        public unsafe static void glMatrixMultTranspose3x3fNV(uint matrixMode, float* m) {
            var _F = _GetProc<GLNativeDelegate.FNglMatrixMultTranspose3x3fNV>("glMatrixMultTranspose3x3fNV");
            _F(matrixMode, m);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_path_rendering</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glStencilThenCoverFillPathNV(GLuint path, GLenum fillMode, GLuint mask, GLenum coverMode);</para>
        /// </summary>
        public static void glStencilThenCoverFillPathNV(uint path, uint fillMode, uint mask, uint coverMode) {
            var _F = _GetProc<GLNativeDelegate.FNglStencilThenCoverFillPathNV>("glStencilThenCoverFillPathNV");
            _F(path, fillMode, mask, coverMode);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_path_rendering</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glStencilThenCoverStrokePathNV(GLuint path, GLint reference, GLuint mask, GLenum coverMode);</para>
        /// </summary>
        public static void glStencilThenCoverStrokePathNV(uint path, int reference, uint mask, uint coverMode) {
            var _F = _GetProc<GLNativeDelegate.FNglStencilThenCoverStrokePathNV>("glStencilThenCoverStrokePathNV");
            _F(path, reference, mask, coverMode);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_path_rendering</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glStencilThenCoverFillPathInstancedNV(GLsizei numPaths, GLenum pathNameType, const void * paths, GLuint pathBase, GLenum fillMode, GLuint mask, GLenum coverMode, GLenum transformType, const GLfloat * transformValues);</para>
        /// </summary>
        public unsafe static void glStencilThenCoverFillPathInstancedNV(int numPaths, uint pathNameType, void* paths, uint pathBase, uint fillMode, uint mask, uint coverMode, uint transformType, float* transformValues) {
            var _F = _GetProc<GLNativeDelegate.FNglStencilThenCoverFillPathInstancedNV>("glStencilThenCoverFillPathInstancedNV");
            _F(numPaths, pathNameType, paths, pathBase, fillMode, mask, coverMode, transformType, transformValues);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_path_rendering</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glStencilThenCoverStrokePathInstancedNV(GLsizei numPaths, GLenum pathNameType, const void * paths, GLuint pathBase, GLint reference, GLuint mask, GLenum coverMode, GLenum transformType, const GLfloat * transformValues);</para>
        /// </summary>
        public unsafe static void glStencilThenCoverStrokePathInstancedNV(int numPaths, uint pathNameType, void* paths, uint pathBase, int reference, uint mask, uint coverMode, uint transformType, float* transformValues) {
            var _F = _GetProc<GLNativeDelegate.FNglStencilThenCoverStrokePathInstancedNV>("glStencilThenCoverStrokePathInstancedNV");
            _F(numPaths, pathNameType, paths, pathBase, reference, mask, coverMode, transformType, transformValues);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_path_rendering</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>GLenum glPathGlyphIndexRangeNV(GLenum fontTarget, const void * fontName, GLbitfield fontStyle, GLuint pathParameterTemplate, GLfloat emScale, GLuint * baseAndCount);</para>
        /// </summary>
        public unsafe static uint glPathGlyphIndexRangeNV(uint fontTarget, void* fontName, uint fontStyle, uint pathParameterTemplate, float emScale, uint* baseAndCount) {
            var _F = _GetProc<GLNativeDelegate.FNglPathGlyphIndexRangeNV>("glPathGlyphIndexRangeNV");
            return _F(fontTarget, fontName, fontStyle, pathParameterTemplate, emScale, baseAndCount);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_path_rendering</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>GLenum glPathGlyphIndexArrayNV(GLuint firstPathName, GLenum fontTarget, const void * fontName, GLbitfield fontStyle, GLuint firstGlyphIndex, GLsizei numGlyphs, GLuint pathParameterTemplate, GLfloat emScale);</para>
        /// </summary>
        public unsafe static uint glPathGlyphIndexArrayNV(uint firstPathName, uint fontTarget, void* fontName, uint fontStyle, uint firstGlyphIndex, int numGlyphs, uint pathParameterTemplate, float emScale) {
            var _F = _GetProc<GLNativeDelegate.FNglPathGlyphIndexArrayNV>("glPathGlyphIndexArrayNV");
            return _F(firstPathName, fontTarget, fontName, fontStyle, firstGlyphIndex, numGlyphs, pathParameterTemplate, emScale);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_path_rendering</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>GLenum glPathMemoryGlyphIndexArrayNV(GLuint firstPathName, GLenum fontTarget, GLsizeiptr fontSize, const void * fontData, GLsizei faceIndex, GLuint firstGlyphIndex, GLsizei numGlyphs, GLuint pathParameterTemplate, GLfloat emScale);</para>
        /// </summary>
        public unsafe static uint glPathMemoryGlyphIndexArrayNV(uint firstPathName, uint fontTarget, IntPtr fontSize, void* fontData, int faceIndex, uint firstGlyphIndex, int numGlyphs, uint pathParameterTemplate, float emScale) {
            var _F = _GetProc<GLNativeDelegate.FNglPathMemoryGlyphIndexArrayNV>("glPathMemoryGlyphIndexArrayNV");
            return _F(firstPathName, fontTarget, fontSize, fontData, faceIndex, firstGlyphIndex, numGlyphs, pathParameterTemplate, emScale);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_path_rendering</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glProgramPathFragmentInputGenNV(GLuint program, GLint location, GLenum genMode, GLint components, const GLfloat * coeffs);</para>
        /// </summary>
        public unsafe static void glProgramPathFragmentInputGenNV(uint program, int location, uint genMode, int components, float* coeffs) {
            var _F = _GetProc<GLNativeDelegate.FNglProgramPathFragmentInputGenNV>("glProgramPathFragmentInputGenNV");
            _F(program, location, genMode, components, coeffs);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_path_rendering</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glGetProgramResourcefvNV(GLuint program, GLenum programInterface, GLuint index, GLsizei propCount, const GLenum * props, GLsizei count, GLsizei * length, GLfloat * params);</para>
        /// </summary>
        public unsafe static void glGetProgramResourcefvNV(uint program, uint programInterface, uint index, int propCount, uint* props, int count, int* length, float* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetProgramResourcefvNV>("glGetProgramResourcefvNV");
            _F(program, programInterface, index, propCount, props, count, length, ps);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_path_rendering</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glPathColorGenNV(GLenum color, GLenum genMode, GLenum colorFormat, const GLfloat * coeffs);</para>
        /// </summary>
        public unsafe static void glPathColorGenNV(uint color, uint genMode, uint colorFormat, float* coeffs) {
            var _F = _GetProc<GLNativeDelegate.FNglPathColorGenNV>("glPathColorGenNV");
            _F(color, genMode, colorFormat, coeffs);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_path_rendering</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glPathTexGenNV(GLenum texCoordSet, GLenum genMode, GLint components, const GLfloat * coeffs);</para>
        /// </summary>
        public unsafe static void glPathTexGenNV(uint texCoordSet, uint genMode, int components, float* coeffs) {
            var _F = _GetProc<GLNativeDelegate.FNglPathTexGenNV>("glPathTexGenNV");
            _F(texCoordSet, genMode, components, coeffs);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_path_rendering</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glPathFogGenNV(GLenum genMode);</para>
        /// </summary>
        public static void glPathFogGenNV(uint genMode) {
            var _F = _GetProc<GLNativeDelegate.FNglPathFogGenNV>("glPathFogGenNV");
            _F(genMode);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_path_rendering</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glGetPathColorGenivNV(GLenum color, GLenum pname, GLint * value);</para>
        /// </summary>
        public unsafe static void glGetPathColorGenivNV(uint color, uint pname, int* value) {
            var _F = _GetProc<GLNativeDelegate.FNglGetPathColorGenivNV>("glGetPathColorGenivNV");
            _F(color, pname, value);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_path_rendering</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glGetPathColorGenfvNV(GLenum color, GLenum pname, GLfloat * value);</para>
        /// </summary>
        public unsafe static void glGetPathColorGenfvNV(uint color, uint pname, float* value) {
            var _F = _GetProc<GLNativeDelegate.FNglGetPathColorGenfvNV>("glGetPathColorGenfvNV");
            _F(color, pname, value);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_path_rendering</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glGetPathTexGenivNV(GLenum texCoordSet, GLenum pname, GLint * value);</para>
        /// </summary>
        public unsafe static void glGetPathTexGenivNV(uint texCoordSet, uint pname, int* value) {
            var _F = _GetProc<GLNativeDelegate.FNglGetPathTexGenivNV>("glGetPathTexGenivNV");
            _F(texCoordSet, pname, value);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_path_rendering</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glGetPathTexGenfvNV(GLenum texCoordSet, GLenum pname, GLfloat * value);</para>
        /// </summary>
        public unsafe static void glGetPathTexGenfvNV(uint texCoordSet, uint pname, float* value) {
            var _F = _GetProc<GLNativeDelegate.FNglGetPathTexGenfvNV>("glGetPathTexGenfvNV");
            _F(texCoordSet, pname, value);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_direct_state_access, GL_NV_path_rendering</para>
        /// Supported: <para>gl, glcore, gl, glcore, gles2</para>
        /// Original: <para>void glMatrixFrustumEXT(GLenum mode, GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar);</para>
        /// </summary>
        public static void glMatrixFrustumEXT(uint mode, double left, double right, double bottom, double top, double zNear, double zFar) {
            var _F = _GetProc<GLNativeDelegate.FNglMatrixFrustumEXT>("glMatrixFrustumEXT");
            _F(mode, left, right, bottom, top, zNear, zFar);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_direct_state_access, GL_NV_path_rendering</para>
        /// Supported: <para>gl, glcore, gl, glcore, gles2</para>
        /// Original: <para>void glMatrixLoadIdentityEXT(GLenum mode);</para>
        /// </summary>
        public static void glMatrixLoadIdentityEXT(uint mode) {
            var _F = _GetProc<GLNativeDelegate.FNglMatrixLoadIdentityEXT>("glMatrixLoadIdentityEXT");
            _F(mode);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_direct_state_access, GL_NV_path_rendering</para>
        /// Supported: <para>gl, glcore, gl, glcore, gles2</para>
        /// Original: <para>void glMatrixLoadTransposefEXT(GLenum mode, const GLfloat * m);</para>
        /// </summary>
        public unsafe static void glMatrixLoadTransposefEXT(uint mode, float* m) {
            var _F = _GetProc<GLNativeDelegate.FNglMatrixLoadTransposefEXT>("glMatrixLoadTransposefEXT");
            _F(mode, m);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_direct_state_access, GL_NV_path_rendering</para>
        /// Supported: <para>gl, glcore, gl, glcore, gles2</para>
        /// Original: <para>void glMatrixLoadTransposedEXT(GLenum mode, const GLdouble * m);</para>
        /// </summary>
        public unsafe static void glMatrixLoadTransposedEXT(uint mode, double* m) {
            var _F = _GetProc<GLNativeDelegate.FNglMatrixLoadTransposedEXT>("glMatrixLoadTransposedEXT");
            _F(mode, m);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_direct_state_access, GL_NV_path_rendering</para>
        /// Supported: <para>gl, glcore, gl, glcore, gles2</para>
        /// Original: <para>void glMatrixLoadfEXT(GLenum mode, const GLfloat * m);</para>
        /// </summary>
        public unsafe static void glMatrixLoadfEXT(uint mode, float* m) {
            var _F = _GetProc<GLNativeDelegate.FNglMatrixLoadfEXT>("glMatrixLoadfEXT");
            _F(mode, m);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_direct_state_access, GL_NV_path_rendering</para>
        /// Supported: <para>gl, glcore, gl, glcore, gles2</para>
        /// Original: <para>void glMatrixLoaddEXT(GLenum mode, const GLdouble * m);</para>
        /// </summary>
        public unsafe static void glMatrixLoaddEXT(uint mode, double* m) {
            var _F = _GetProc<GLNativeDelegate.FNglMatrixLoaddEXT>("glMatrixLoaddEXT");
            _F(mode, m);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_direct_state_access, GL_NV_path_rendering</para>
        /// Supported: <para>gl, glcore, gl, glcore, gles2</para>
        /// Original: <para>void glMatrixMultTransposefEXT(GLenum mode, const GLfloat * m);</para>
        /// </summary>
        public unsafe static void glMatrixMultTransposefEXT(uint mode, float* m) {
            var _F = _GetProc<GLNativeDelegate.FNglMatrixMultTransposefEXT>("glMatrixMultTransposefEXT");
            _F(mode, m);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_direct_state_access, GL_NV_path_rendering</para>
        /// Supported: <para>gl, glcore, gl, glcore, gles2</para>
        /// Original: <para>void glMatrixMultTransposedEXT(GLenum mode, const GLdouble * m);</para>
        /// </summary>
        public unsafe static void glMatrixMultTransposedEXT(uint mode, double* m) {
            var _F = _GetProc<GLNativeDelegate.FNglMatrixMultTransposedEXT>("glMatrixMultTransposedEXT");
            _F(mode, m);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_direct_state_access, GL_NV_path_rendering</para>
        /// Supported: <para>gl, glcore, gl, glcore, gles2</para>
        /// Original: <para>void glMatrixMultfEXT(GLenum mode, const GLfloat * m);</para>
        /// </summary>
        public unsafe static void glMatrixMultfEXT(uint mode, float* m) {
            var _F = _GetProc<GLNativeDelegate.FNglMatrixMultfEXT>("glMatrixMultfEXT");
            _F(mode, m);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_direct_state_access, GL_NV_path_rendering</para>
        /// Supported: <para>gl, glcore, gl, glcore, gles2</para>
        /// Original: <para>void glMatrixMultdEXT(GLenum mode, const GLdouble * m);</para>
        /// </summary>
        public unsafe static void glMatrixMultdEXT(uint mode, double* m) {
            var _F = _GetProc<GLNativeDelegate.FNglMatrixMultdEXT>("glMatrixMultdEXT");
            _F(mode, m);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_direct_state_access, GL_NV_path_rendering</para>
        /// Supported: <para>gl, glcore, gl, glcore, gles2</para>
        /// Original: <para>void glMatrixOrthoEXT(GLenum mode, GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar);</para>
        /// </summary>
        public static void glMatrixOrthoEXT(uint mode, double left, double right, double bottom, double top, double zNear, double zFar) {
            var _F = _GetProc<GLNativeDelegate.FNglMatrixOrthoEXT>("glMatrixOrthoEXT");
            _F(mode, left, right, bottom, top, zNear, zFar);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_direct_state_access, GL_NV_path_rendering</para>
        /// Supported: <para>gl, glcore, gl, glcore, gles2</para>
        /// Original: <para>void glMatrixPopEXT(GLenum mode);</para>
        /// </summary>
        public static void glMatrixPopEXT(uint mode) {
            var _F = _GetProc<GLNativeDelegate.FNglMatrixPopEXT>("glMatrixPopEXT");
            _F(mode);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_direct_state_access, GL_NV_path_rendering</para>
        /// Supported: <para>gl, glcore, gl, glcore, gles2</para>
        /// Original: <para>void glMatrixPushEXT(GLenum mode);</para>
        /// </summary>
        public static void glMatrixPushEXT(uint mode) {
            var _F = _GetProc<GLNativeDelegate.FNglMatrixPushEXT>("glMatrixPushEXT");
            _F(mode);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_direct_state_access, GL_NV_path_rendering</para>
        /// Supported: <para>gl, glcore, gl, glcore, gles2</para>
        /// Original: <para>void glMatrixRotatefEXT(GLenum mode, GLfloat angle, GLfloat x, GLfloat y, GLfloat z);</para>
        /// </summary>
        public static void glMatrixRotatefEXT(uint mode, float angle, float x, float y, float z) {
            var _F = _GetProc<GLNativeDelegate.FNglMatrixRotatefEXT>("glMatrixRotatefEXT");
            _F(mode, angle, x, y, z);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_direct_state_access, GL_NV_path_rendering</para>
        /// Supported: <para>gl, glcore, gl, glcore, gles2</para>
        /// Original: <para>void glMatrixRotatedEXT(GLenum mode, GLdouble angle, GLdouble x, GLdouble y, GLdouble z);</para>
        /// </summary>
        public static void glMatrixRotatedEXT(uint mode, double angle, double x, double y, double z) {
            var _F = _GetProc<GLNativeDelegate.FNglMatrixRotatedEXT>("glMatrixRotatedEXT");
            _F(mode, angle, x, y, z);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_direct_state_access, GL_NV_path_rendering</para>
        /// Supported: <para>gl, glcore, gl, glcore, gles2</para>
        /// Original: <para>void glMatrixScalefEXT(GLenum mode, GLfloat x, GLfloat y, GLfloat z);</para>
        /// </summary>
        public static void glMatrixScalefEXT(uint mode, float x, float y, float z) {
            var _F = _GetProc<GLNativeDelegate.FNglMatrixScalefEXT>("glMatrixScalefEXT");
            _F(mode, x, y, z);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_direct_state_access, GL_NV_path_rendering</para>
        /// Supported: <para>gl, glcore, gl, glcore, gles2</para>
        /// Original: <para>void glMatrixScaledEXT(GLenum mode, GLdouble x, GLdouble y, GLdouble z);</para>
        /// </summary>
        public static void glMatrixScaledEXT(uint mode, double x, double y, double z) {
            var _F = _GetProc<GLNativeDelegate.FNglMatrixScaledEXT>("glMatrixScaledEXT");
            _F(mode, x, y, z);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_direct_state_access, GL_NV_path_rendering</para>
        /// Supported: <para>gl, glcore, gl, glcore, gles2</para>
        /// Original: <para>void glMatrixTranslatefEXT(GLenum mode, GLfloat x, GLfloat y, GLfloat z);</para>
        /// </summary>
        public static void glMatrixTranslatefEXT(uint mode, float x, float y, float z) {
            var _F = _GetProc<GLNativeDelegate.FNglMatrixTranslatefEXT>("glMatrixTranslatefEXT");
            _F(mode, x, y, z);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_EXT_direct_state_access, GL_NV_path_rendering</para>
        /// Supported: <para>gl, glcore, gl, glcore, gles2</para>
        /// Original: <para>void glMatrixTranslatedEXT(GLenum mode, GLdouble x, GLdouble y, GLdouble z);</para>
        /// </summary>
        public static void glMatrixTranslatedEXT(uint mode, double x, double y, double z) {
            var _F = _GetProc<GLNativeDelegate.FNglMatrixTranslatedEXT>("glMatrixTranslatedEXT");
            _F(mode, x, y, z);
        }

        #endregion GL_NV_path_rendering

        #region GL_NV_pixel_data_range

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_pixel_data_range</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glPixelDataRangeNV(GLenum target, GLsizei length, const void * pointer);</para>
        /// </summary>
        public unsafe static void glPixelDataRangeNV(uint target, int length, void* pointer) {
            var _F = _GetProc<GLNativeDelegate.FNglPixelDataRangeNV>("glPixelDataRangeNV");
            _F(target, length, pointer);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_pixel_data_range</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glFlushPixelDataRangeNV(GLenum target);</para>
        /// </summary>
        public static void glFlushPixelDataRangeNV(uint target) {
            var _F = _GetProc<GLNativeDelegate.FNglFlushPixelDataRangeNV>("glFlushPixelDataRangeNV");
            _F(target);
        }

        #endregion GL_NV_pixel_data_range

        #region GL_NV_point_sprite

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_point_sprite</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glPointParameteriNV(GLenum pname, GLint param);</para>
        /// </summary>
        public static void glPointParameteriNV(uint pname, int param) {
            var _F = _GetProc<GLNativeDelegate.FNglPointParameteriNV>("glPointParameteriNV");
            _F(pname, param);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_point_sprite</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glPointParameterivNV(GLenum pname, const GLint * params);</para>
        /// </summary>
        public unsafe static void glPointParameterivNV(uint pname, int* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglPointParameterivNV>("glPointParameterivNV");
            _F(pname, ps);
        }

        #endregion GL_NV_point_sprite

        #region GL_NV_present_video

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_present_video</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glPresentFrameKeyedNV(GLuint video_slot, GLuint64EXT minPresentTime, GLuint beginPresentTimeId, GLuint presentDurationId, GLenum type, GLenum target0, GLuint fill0, GLuint key0, GLenum target1, GLuint fill1, GLuint key1);</para>
        /// </summary>
        public static void glPresentFrameKeyedNV(uint video_slot, UInt64 minPresentTime, uint beginPresentTimeId, uint presentDurationId, uint type, uint target0, uint fill0, uint key0, uint target1, uint fill1, uint key1) {
            var _F = _GetProc<GLNativeDelegate.FNglPresentFrameKeyedNV>("glPresentFrameKeyedNV");
            _F(video_slot, minPresentTime, beginPresentTimeId, presentDurationId, type, target0, fill0, key0, target1, fill1, key1);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_present_video</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glPresentFrameDualFillNV(GLuint video_slot, GLuint64EXT minPresentTime, GLuint beginPresentTimeId, GLuint presentDurationId, GLenum type, GLenum target0, GLuint fill0, GLenum target1, GLuint fill1, GLenum target2, GLuint fill2, GLenum target3, GLuint fill3);</para>
        /// </summary>
        public static void glPresentFrameDualFillNV(uint video_slot, UInt64 minPresentTime, uint beginPresentTimeId, uint presentDurationId, uint type, uint target0, uint fill0, uint target1, uint fill1, uint target2, uint fill2, uint target3, uint fill3) {
            var _F = _GetProc<GLNativeDelegate.FNglPresentFrameDualFillNV>("glPresentFrameDualFillNV");
            _F(video_slot, minPresentTime, beginPresentTimeId, presentDurationId, type, target0, fill0, target1, fill1, target2, fill2, target3, fill3);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_present_video</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetVideoivNV(GLuint video_slot, GLenum pname, GLint * params);</para>
        /// </summary>
        public unsafe static void glGetVideoivNV(uint video_slot, uint pname, int* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetVideoivNV>("glGetVideoivNV");
            _F(video_slot, pname, ps);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_present_video</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetVideouivNV(GLuint video_slot, GLenum pname, GLuint * params);</para>
        /// </summary>
        public unsafe static void glGetVideouivNV(uint video_slot, uint pname, uint* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetVideouivNV>("glGetVideouivNV");
            _F(video_slot, pname, ps);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_present_video</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetVideoi64vNV(GLuint video_slot, GLenum pname, GLint64EXT * params);</para>
        /// </summary>
        public unsafe static void glGetVideoi64vNV(uint video_slot, uint pname, Int64* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetVideoi64vNV>("glGetVideoi64vNV");
            _F(video_slot, pname, ps);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_present_video</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetVideoui64vNV(GLuint video_slot, GLenum pname, GLuint64EXT * params);</para>
        /// </summary>
        public unsafe static void glGetVideoui64vNV(uint video_slot, uint pname, UInt64* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetVideoui64vNV>("glGetVideoui64vNV");
            _F(video_slot, pname, ps);
        }

        #endregion GL_NV_present_video

        #region GL_NV_primitive_restart

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_primitive_restart</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glPrimitiveRestartNV();</para>
        /// </summary>
        public static void glPrimitiveRestartNV() {
            var _F = _GetProc<GLNativeDelegate.FNglPrimitiveRestartNV>("glPrimitiveRestartNV");
            _F();
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_primitive_restart</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glPrimitiveRestartIndexNV(GLuint index);</para>
        /// </summary>
        public static void glPrimitiveRestartIndexNV(uint index) {
            var _F = _GetProc<GLNativeDelegate.FNglPrimitiveRestartIndexNV>("glPrimitiveRestartIndexNV");
            _F(index);
        }

        #endregion GL_NV_primitive_restart

        #region GL_NV_query_resource

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_query_resource</para>
        /// Supported: <para>gl</para>
        /// Original: <para>GLint glQueryResourceNV(GLenum queryType, GLint tagId, GLuint count, GLint * buffer);</para>
        /// </summary>
        public unsafe static int glQueryResourceNV(uint queryType, int tagId, uint count, int* buffer) {
            var _F = _GetProc<GLNativeDelegate.FNglQueryResourceNV>("glQueryResourceNV");
            return _F(queryType, tagId, count, buffer);
        }

        #endregion GL_NV_query_resource

        #region GL_NV_query_resource_tag

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_query_resource_tag</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGenQueryResourceTagNV(GLsizei n, GLint * tagIds);</para>
        /// </summary>
        public unsafe static void glGenQueryResourceTagNV(int n, int* tagIds) {
            var _F = _GetProc<GLNativeDelegate.FNglGenQueryResourceTagNV>("glGenQueryResourceTagNV");
            _F(n, tagIds);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_query_resource_tag</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glDeleteQueryResourceTagNV(GLsizei n, const GLint * tagIds);</para>
        /// </summary>
        public unsafe static void glDeleteQueryResourceTagNV(int n, int* tagIds) {
            var _F = _GetProc<GLNativeDelegate.FNglDeleteQueryResourceTagNV>("glDeleteQueryResourceTagNV");
            _F(n, tagIds);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_query_resource_tag</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glQueryResourceTagNV(GLint tagId, const GLchar * tagString);</para>
        /// </summary>
        public unsafe static void glQueryResourceTagNV(int tagId, byte* tagString) {
            var _F = _GetProc<GLNativeDelegate.FNglQueryResourceTagNV>("glQueryResourceTagNV");
            _F(tagId, tagString);
        }

        #endregion GL_NV_query_resource_tag

        #region GL_NV_register_combiners

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_register_combiners</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glCombinerParameterfvNV(GLenum pname, const GLfloat * params);</para>
        /// </summary>
        public unsafe static void glCombinerParameterfvNV(uint pname, float* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglCombinerParameterfvNV>("glCombinerParameterfvNV");
            _F(pname, ps);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_register_combiners</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glCombinerParameterfNV(GLenum pname, GLfloat param);</para>
        /// </summary>
        public static void glCombinerParameterfNV(uint pname, float param) {
            var _F = _GetProc<GLNativeDelegate.FNglCombinerParameterfNV>("glCombinerParameterfNV");
            _F(pname, param);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_register_combiners</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glCombinerParameterivNV(GLenum pname, const GLint * params);</para>
        /// </summary>
        public unsafe static void glCombinerParameterivNV(uint pname, int* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglCombinerParameterivNV>("glCombinerParameterivNV");
            _F(pname, ps);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_register_combiners</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glCombinerParameteriNV(GLenum pname, GLint param);</para>
        /// </summary>
        public static void glCombinerParameteriNV(uint pname, int param) {
            var _F = _GetProc<GLNativeDelegate.FNglCombinerParameteriNV>("glCombinerParameteriNV");
            _F(pname, param);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_register_combiners</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glCombinerInputNV(GLenum stage, GLenum portion, GLenum variable, GLenum input, GLenum mapping, GLenum componentUsage);</para>
        /// </summary>
        public static void glCombinerInputNV(uint stage, uint portion, uint variable, uint input, uint mapping, uint componentUsage) {
            var _F = _GetProc<GLNativeDelegate.FNglCombinerInputNV>("glCombinerInputNV");
            _F(stage, portion, variable, input, mapping, componentUsage);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_register_combiners</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glCombinerOutputNV(GLenum stage, GLenum portion, GLenum abOutput, GLenum cdOutput, GLenum sumOutput, GLenum scale, GLenum bias, GLboolean abDotProduct, GLboolean cdDotProduct, GLboolean muxSum);</para>
        /// </summary>
        public static void glCombinerOutputNV(uint stage, uint portion, uint abOutput, uint cdOutput, uint sumOutput, uint scale, uint bias, bool abDotProduct, bool cdDotProduct, bool muxSum) {
            var _F = _GetProc<GLNativeDelegate.FNglCombinerOutputNV>("glCombinerOutputNV");
            _F(stage, portion, abOutput, cdOutput, sumOutput, scale, bias, abDotProduct, cdDotProduct, muxSum);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_register_combiners</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glFinalCombinerInputNV(GLenum variable, GLenum input, GLenum mapping, GLenum componentUsage);</para>
        /// </summary>
        public static void glFinalCombinerInputNV(uint variable, uint input, uint mapping, uint componentUsage) {
            var _F = _GetProc<GLNativeDelegate.FNglFinalCombinerInputNV>("glFinalCombinerInputNV");
            _F(variable, input, mapping, componentUsage);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_register_combiners</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetCombinerInputParameterfvNV(GLenum stage, GLenum portion, GLenum variable, GLenum pname, GLfloat * params);</para>
        /// </summary>
        public unsafe static void glGetCombinerInputParameterfvNV(uint stage, uint portion, uint variable, uint pname, float* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetCombinerInputParameterfvNV>("glGetCombinerInputParameterfvNV");
            _F(stage, portion, variable, pname, ps);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_register_combiners</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetCombinerInputParameterivNV(GLenum stage, GLenum portion, GLenum variable, GLenum pname, GLint * params);</para>
        /// </summary>
        public unsafe static void glGetCombinerInputParameterivNV(uint stage, uint portion, uint variable, uint pname, int* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetCombinerInputParameterivNV>("glGetCombinerInputParameterivNV");
            _F(stage, portion, variable, pname, ps);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_register_combiners</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetCombinerOutputParameterfvNV(GLenum stage, GLenum portion, GLenum pname, GLfloat * params);</para>
        /// </summary>
        public unsafe static void glGetCombinerOutputParameterfvNV(uint stage, uint portion, uint pname, float* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetCombinerOutputParameterfvNV>("glGetCombinerOutputParameterfvNV");
            _F(stage, portion, pname, ps);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_register_combiners</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetCombinerOutputParameterivNV(GLenum stage, GLenum portion, GLenum pname, GLint * params);</para>
        /// </summary>
        public unsafe static void glGetCombinerOutputParameterivNV(uint stage, uint portion, uint pname, int* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetCombinerOutputParameterivNV>("glGetCombinerOutputParameterivNV");
            _F(stage, portion, pname, ps);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_register_combiners</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetFinalCombinerInputParameterfvNV(GLenum variable, GLenum pname, GLfloat * params);</para>
        /// </summary>
        public unsafe static void glGetFinalCombinerInputParameterfvNV(uint variable, uint pname, float* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetFinalCombinerInputParameterfvNV>("glGetFinalCombinerInputParameterfvNV");
            _F(variable, pname, ps);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_register_combiners</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetFinalCombinerInputParameterivNV(GLenum variable, GLenum pname, GLint * params);</para>
        /// </summary>
        public unsafe static void glGetFinalCombinerInputParameterivNV(uint variable, uint pname, int* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetFinalCombinerInputParameterivNV>("glGetFinalCombinerInputParameterivNV");
            _F(variable, pname, ps);
        }

        #endregion GL_NV_register_combiners

        #region GL_NV_register_combiners2

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_register_combiners2</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glCombinerStageParameterfvNV(GLenum stage, GLenum pname, const GLfloat * params);</para>
        /// </summary>
        public unsafe static void glCombinerStageParameterfvNV(uint stage, uint pname, float* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglCombinerStageParameterfvNV>("glCombinerStageParameterfvNV");
            _F(stage, pname, ps);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_register_combiners2</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetCombinerStageParameterfvNV(GLenum stage, GLenum pname, GLfloat * params);</para>
        /// </summary>
        public unsafe static void glGetCombinerStageParameterfvNV(uint stage, uint pname, float* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetCombinerStageParameterfvNV>("glGetCombinerStageParameterfvNV");
            _F(stage, pname, ps);
        }

        #endregion GL_NV_register_combiners2

        #region GL_NV_sample_locations

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_sample_locations</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glFramebufferSampleLocationsfvNV(GLenum target, GLuint start, GLsizei count, const GLfloat * v);</para>
        /// </summary>
        public unsafe static void glFramebufferSampleLocationsfvNV(uint target, uint start, int count, float* v) {
            var _F = _GetProc<GLNativeDelegate.FNglFramebufferSampleLocationsfvNV>("glFramebufferSampleLocationsfvNV");
            _F(target, start, count, v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_sample_locations</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glNamedFramebufferSampleLocationsfvNV(GLuint framebuffer, GLuint start, GLsizei count, const GLfloat * v);</para>
        /// </summary>
        public unsafe static void glNamedFramebufferSampleLocationsfvNV(uint framebuffer, uint start, int count, float* v) {
            var _F = _GetProc<GLNativeDelegate.FNglNamedFramebufferSampleLocationsfvNV>("glNamedFramebufferSampleLocationsfvNV");
            _F(framebuffer, start, count, v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_sample_locations</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glResolveDepthValuesNV();</para>
        /// </summary>
        public static void glResolveDepthValuesNV() {
            var _F = _GetProc<GLNativeDelegate.FNglResolveDepthValuesNV>("glResolveDepthValuesNV");
            _F();
        }

        #endregion GL_NV_sample_locations

        #region GL_NV_scissor_exclusive

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_scissor_exclusive</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glScissorExclusiveNV(GLint x, GLint y, GLsizei width, GLsizei height);</para>
        /// </summary>
        public static void glScissorExclusiveNV(int x, int y, int width, int height) {
            var _F = _GetProc<GLNativeDelegate.FNglScissorExclusiveNV>("glScissorExclusiveNV");
            _F(x, y, width, height);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_scissor_exclusive</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glScissorExclusiveArrayvNV(GLuint first, GLsizei count, const GLint * v);</para>
        /// </summary>
        public unsafe static void glScissorExclusiveArrayvNV(uint first, int count, int* v) {
            var _F = _GetProc<GLNativeDelegate.FNglScissorExclusiveArrayvNV>("glScissorExclusiveArrayvNV");
            _F(first, count, v);
        }

        #endregion GL_NV_scissor_exclusive

        #region GL_NV_shader_buffer_load

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_shader_buffer_load</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glMakeBufferResidentNV(GLenum target, GLenum access);</para>
        /// </summary>
        public static void glMakeBufferResidentNV(uint target, uint access) {
            var _F = _GetProc<GLNativeDelegate.FNglMakeBufferResidentNV>("glMakeBufferResidentNV");
            _F(target, access);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_shader_buffer_load</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glMakeBufferNonResidentNV(GLenum target);</para>
        /// </summary>
        public static void glMakeBufferNonResidentNV(uint target) {
            var _F = _GetProc<GLNativeDelegate.FNglMakeBufferNonResidentNV>("glMakeBufferNonResidentNV");
            _F(target);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_shader_buffer_load</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>GLboolean glIsBufferResidentNV(GLenum target);</para>
        /// </summary>
        public static bool glIsBufferResidentNV(uint target) {
            var _F = _GetProc<GLNativeDelegate.FNglIsBufferResidentNV>("glIsBufferResidentNV");
            return _F(target);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_shader_buffer_load</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glMakeNamedBufferResidentNV(GLuint buffer, GLenum access);</para>
        /// </summary>
        public static void glMakeNamedBufferResidentNV(uint buffer, uint access) {
            var _F = _GetProc<GLNativeDelegate.FNglMakeNamedBufferResidentNV>("glMakeNamedBufferResidentNV");
            _F(buffer, access);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_shader_buffer_load</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glMakeNamedBufferNonResidentNV(GLuint buffer);</para>
        /// </summary>
        public static void glMakeNamedBufferNonResidentNV(uint buffer) {
            var _F = _GetProc<GLNativeDelegate.FNglMakeNamedBufferNonResidentNV>("glMakeNamedBufferNonResidentNV");
            _F(buffer);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_shader_buffer_load</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>GLboolean glIsNamedBufferResidentNV(GLuint buffer);</para>
        /// </summary>
        public static bool glIsNamedBufferResidentNV(uint buffer) {
            var _F = _GetProc<GLNativeDelegate.FNglIsNamedBufferResidentNV>("glIsNamedBufferResidentNV");
            return _F(buffer);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_shader_buffer_load</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetBufferParameterui64vNV(GLenum target, GLenum pname, GLuint64EXT * params);</para>
        /// </summary>
        public unsafe static void glGetBufferParameterui64vNV(uint target, uint pname, UInt64* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetBufferParameterui64vNV>("glGetBufferParameterui64vNV");
            _F(target, pname, ps);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_shader_buffer_load</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetNamedBufferParameterui64vNV(GLuint buffer, GLenum pname, GLuint64EXT * params);</para>
        /// </summary>
        public unsafe static void glGetNamedBufferParameterui64vNV(uint buffer, uint pname, UInt64* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetNamedBufferParameterui64vNV>("glGetNamedBufferParameterui64vNV");
            _F(buffer, pname, ps);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_shader_buffer_load</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetIntegerui64vNV(GLenum value, GLuint64EXT * result);</para>
        /// </summary>
        public unsafe static void glGetIntegerui64vNV(uint value, UInt64* result) {
            var _F = _GetProc<GLNativeDelegate.FNglGetIntegerui64vNV>("glGetIntegerui64vNV");
            _F(value, result);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_shader_buffer_load</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glUniformui64NV(GLint location, GLuint64EXT value);</para>
        /// </summary>
        public static void glUniformui64NV(int location, UInt64 value) {
            var _F = _GetProc<GLNativeDelegate.FNglUniformui64NV>("glUniformui64NV");
            _F(location, value);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_shader_buffer_load</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glUniformui64vNV(GLint location, GLsizei count, const GLuint64EXT * value);</para>
        /// </summary>
        public unsafe static void glUniformui64vNV(int location, int count, UInt64* value) {
            var _F = _GetProc<GLNativeDelegate.FNglUniformui64vNV>("glUniformui64vNV");
            _F(location, count, value);
        }
        // void glGetUniformui64vNV(GLuint program, GLint location, GLuint64EXT * ps);
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_shader_buffer_load</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glProgramUniformui64NV(GLuint program, GLint location, GLuint64EXT value);</para>
        /// </summary>
        public static void glProgramUniformui64NV(uint program, int location, UInt64 value) {
            var _F = _GetProc<GLNativeDelegate.FNglProgramUniformui64NV>("glProgramUniformui64NV");
            _F(program, location, value);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_shader_buffer_load</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glProgramUniformui64vNV(GLuint program, GLint location, GLsizei count, const GLuint64EXT * value);</para>
        /// </summary>
        public unsafe static void glProgramUniformui64vNV(uint program, int location, int count, UInt64* value) {
            var _F = _GetProc<GLNativeDelegate.FNglProgramUniformui64vNV>("glProgramUniformui64vNV");
            _F(program, location, count, value);
        }

        #endregion GL_NV_shader_buffer_load

        #region GL_NV_shading_rate_image

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_shading_rate_image</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glBindShadingRateImageNV(GLuint texture);</para>
        /// </summary>
        public static void glBindShadingRateImageNV(uint texture) {
            var _F = _GetProc<GLNativeDelegate.FNglBindShadingRateImageNV>("glBindShadingRateImageNV");
            _F(texture);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_shading_rate_image</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glGetShadingRateImagePaletteNV(GLuint viewport, GLuint entry, GLenum * rate);</para>
        /// </summary>
        public unsafe static void glGetShadingRateImagePaletteNV(uint viewport, uint entry, uint* rate) {
            var _F = _GetProc<GLNativeDelegate.FNglGetShadingRateImagePaletteNV>("glGetShadingRateImagePaletteNV");
            _F(viewport, entry, rate);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_shading_rate_image</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glGetShadingRateSampleLocationivNV(GLenum rate, GLuint samples, GLuint index, GLint * location);</para>
        /// </summary>
        public unsafe static void glGetShadingRateSampleLocationivNV(uint rate, uint samples, uint index, int* location) {
            var _F = _GetProc<GLNativeDelegate.FNglGetShadingRateSampleLocationivNV>("glGetShadingRateSampleLocationivNV");
            _F(rate, samples, index, location);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_shading_rate_image</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glShadingRateImageBarrierNV(GLboolean synchronize);</para>
        /// </summary>
        public static void glShadingRateImageBarrierNV(bool synchronize) {
            var _F = _GetProc<GLNativeDelegate.FNglShadingRateImageBarrierNV>("glShadingRateImageBarrierNV");
            _F(synchronize);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_shading_rate_image</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glShadingRateImagePaletteNV(GLuint viewport, GLuint first, GLsizei count, const GLenum * rates);</para>
        /// </summary>
        public unsafe static void glShadingRateImagePaletteNV(uint viewport, uint first, int count, uint* rates) {
            var _F = _GetProc<GLNativeDelegate.FNglShadingRateImagePaletteNV>("glShadingRateImagePaletteNV");
            _F(viewport, first, count, rates);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_shading_rate_image</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glShadingRateSampleOrderNV(GLenum order);</para>
        /// </summary>
        public static void glShadingRateSampleOrderNV(uint order) {
            var _F = _GetProc<GLNativeDelegate.FNglShadingRateSampleOrderNV>("glShadingRateSampleOrderNV");
            _F(order);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_shading_rate_image</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glShadingRateSampleOrderCustomNV(GLenum rate, GLuint samples, const GLint * locations);</para>
        /// </summary>
        public unsafe static void glShadingRateSampleOrderCustomNV(uint rate, uint samples, int* locations) {
            var _F = _GetProc<GLNativeDelegate.FNglShadingRateSampleOrderCustomNV>("glShadingRateSampleOrderCustomNV");
            _F(rate, samples, locations);
        }

        #endregion GL_NV_shading_rate_image

        #region GL_NV_texture_barrier

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_texture_barrier</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glTextureBarrierNV();</para>
        /// </summary>
        public static void glTextureBarrierNV() {
            var _F = _GetProc<GLNativeDelegate.FNglTextureBarrierNV>("glTextureBarrierNV");
            _F();
        }

        #endregion GL_NV_texture_barrier

        #region GL_NV_texture_multisample

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_texture_multisample</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glTexImage2DMultisampleCoverageNV(GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLboolean fixedSampleLocations);</para>
        /// </summary>
        public static void glTexImage2DMultisampleCoverageNV(uint target, int coverageSamples, int colorSamples, int internalFormat, int width, int height, bool fixedSampleLocations) {
            var _F = _GetProc<GLNativeDelegate.FNglTexImage2DMultisampleCoverageNV>("glTexImage2DMultisampleCoverageNV");
            _F(target, coverageSamples, colorSamples, internalFormat, width, height, fixedSampleLocations);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_texture_multisample</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glTexImage3DMultisampleCoverageNV(GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedSampleLocations);</para>
        /// </summary>
        public static void glTexImage3DMultisampleCoverageNV(uint target, int coverageSamples, int colorSamples, int internalFormat, int width, int height, int depth, bool fixedSampleLocations) {
            var _F = _GetProc<GLNativeDelegate.FNglTexImage3DMultisampleCoverageNV>("glTexImage3DMultisampleCoverageNV");
            _F(target, coverageSamples, colorSamples, internalFormat, width, height, depth, fixedSampleLocations);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_texture_multisample</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glTextureImage2DMultisampleNV(GLuint texture, GLenum target, GLsizei samples, GLint internalFormat, GLsizei width, GLsizei height, GLboolean fixedSampleLocations);</para>
        /// </summary>
        public static void glTextureImage2DMultisampleNV(uint texture, uint target, int samples, int internalFormat, int width, int height, bool fixedSampleLocations) {
            var _F = _GetProc<GLNativeDelegate.FNglTextureImage2DMultisampleNV>("glTextureImage2DMultisampleNV");
            _F(texture, target, samples, internalFormat, width, height, fixedSampleLocations);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_texture_multisample</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glTextureImage3DMultisampleNV(GLuint texture, GLenum target, GLsizei samples, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedSampleLocations);</para>
        /// </summary>
        public static void glTextureImage3DMultisampleNV(uint texture, uint target, int samples, int internalFormat, int width, int height, int depth, bool fixedSampleLocations) {
            var _F = _GetProc<GLNativeDelegate.FNglTextureImage3DMultisampleNV>("glTextureImage3DMultisampleNV");
            _F(texture, target, samples, internalFormat, width, height, depth, fixedSampleLocations);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_texture_multisample</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glTextureImage2DMultisampleCoverageNV(GLuint texture, GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLboolean fixedSampleLocations);</para>
        /// </summary>
        public static void glTextureImage2DMultisampleCoverageNV(uint texture, uint target, int coverageSamples, int colorSamples, int internalFormat, int width, int height, bool fixedSampleLocations) {
            var _F = _GetProc<GLNativeDelegate.FNglTextureImage2DMultisampleCoverageNV>("glTextureImage2DMultisampleCoverageNV");
            _F(texture, target, coverageSamples, colorSamples, internalFormat, width, height, fixedSampleLocations);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_texture_multisample</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glTextureImage3DMultisampleCoverageNV(GLuint texture, GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedSampleLocations);</para>
        /// </summary>
        public static void glTextureImage3DMultisampleCoverageNV(uint texture, uint target, int coverageSamples, int colorSamples, int internalFormat, int width, int height, int depth, bool fixedSampleLocations) {
            var _F = _GetProc<GLNativeDelegate.FNglTextureImage3DMultisampleCoverageNV>("glTextureImage3DMultisampleCoverageNV");
            _F(texture, target, coverageSamples, colorSamples, internalFormat, width, height, depth, fixedSampleLocations);
        }

        #endregion GL_NV_texture_multisample

        #region GL_NV_transform_feedback

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_transform_feedback</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glBeginTransformFeedbackNV(GLenum primitiveMode);</para>
        /// </summary>
        public static void glBeginTransformFeedbackNV(uint primitiveMode) {
            var _F = _GetProc<GLNativeDelegate.FNglBeginTransformFeedbackNV>("glBeginTransformFeedbackNV");
            _F(primitiveMode);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_transform_feedback</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glEndTransformFeedbackNV();</para>
        /// </summary>
        public static void glEndTransformFeedbackNV() {
            var _F = _GetProc<GLNativeDelegate.FNglEndTransformFeedbackNV>("glEndTransformFeedbackNV");
            _F();
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_transform_feedback</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glTransformFeedbackAttribsNV(GLsizei count, const GLint * attribs, GLenum bufferMode);</para>
        /// </summary>
        public unsafe static void glTransformFeedbackAttribsNV(int count, int* attribs, uint bufferMode) {
            var _F = _GetProc<GLNativeDelegate.FNglTransformFeedbackAttribsNV>("glTransformFeedbackAttribsNV");
            _F(count, attribs, bufferMode);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_transform_feedback</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glBindBufferRangeNV(GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size);</para>
        /// </summary>
        public static void glBindBufferRangeNV(uint target, uint index, uint buffer, IntPtr offset, IntPtr size) {
            var _F = _GetProc<GLNativeDelegate.FNglBindBufferRangeNV>("glBindBufferRangeNV");
            _F(target, index, buffer, offset, size);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_transform_feedback</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glBindBufferOffsetNV(GLenum target, GLuint index, GLuint buffer, GLintptr offset);</para>
        /// </summary>
        public static void glBindBufferOffsetNV(uint target, uint index, uint buffer, IntPtr offset) {
            var _F = _GetProc<GLNativeDelegate.FNglBindBufferOffsetNV>("glBindBufferOffsetNV");
            _F(target, index, buffer, offset);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_transform_feedback</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glBindBufferBaseNV(GLenum target, GLuint index, GLuint buffer);</para>
        /// </summary>
        public static void glBindBufferBaseNV(uint target, uint index, uint buffer) {
            var _F = _GetProc<GLNativeDelegate.FNglBindBufferBaseNV>("glBindBufferBaseNV");
            _F(target, index, buffer);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_transform_feedback</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glTransformFeedbackVaryingsNV(GLuint program, GLsizei count, const GLint * locations, GLenum bufferMode);</para>
        /// </summary>
        public unsafe static void glTransformFeedbackVaryingsNV(uint program, int count, int* locations, uint bufferMode) {
            var _F = _GetProc<GLNativeDelegate.FNglTransformFeedbackVaryingsNV>("glTransformFeedbackVaryingsNV");
            _F(program, count, locations, bufferMode);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_transform_feedback</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glActiveVaryingNV(GLuint program, const GLchar * name);</para>
        /// </summary>
        public unsafe static void glActiveVaryingNV(uint program, byte* name) {
            var _F = _GetProc<GLNativeDelegate.FNglActiveVaryingNV>("glActiveVaryingNV");
            _F(program, name);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_transform_feedback</para>
        /// Supported: <para>gl</para>
        /// Original: <para>GLint glGetVaryingLocationNV(GLuint program, const GLchar * name);</para>
        /// </summary>
        public unsafe static int glGetVaryingLocationNV(uint program, byte* name) {
            var _F = _GetProc<GLNativeDelegate.FNglGetVaryingLocationNV>("glGetVaryingLocationNV");
            return _F(program, name);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_transform_feedback</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetActiveVaryingNV(GLuint program, GLuint index, GLsizei bufSize, GLsizei * length, GLsizei * size, GLenum * type, GLchar * name);</para>
        /// </summary>
        public unsafe static void glGetActiveVaryingNV(uint program, uint index, int bufSize, int* length, int* size, uint* type, byte* name) {
            var _F = _GetProc<GLNativeDelegate.FNglGetActiveVaryingNV>("glGetActiveVaryingNV");
            _F(program, index, bufSize, length, size, type, name);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_transform_feedback</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetTransformFeedbackVaryingNV(GLuint program, GLuint index, GLint * location);</para>
        /// </summary>
        public unsafe static void glGetTransformFeedbackVaryingNV(uint program, uint index, int* location) {
            var _F = _GetProc<GLNativeDelegate.FNglGetTransformFeedbackVaryingNV>("glGetTransformFeedbackVaryingNV");
            _F(program, index, location);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_transform_feedback</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glTransformFeedbackStreamAttribsNV(GLsizei count, const GLint * attribs, GLsizei nbuffers, const GLint * bufstreams, GLenum bufferMode);</para>
        /// </summary>
        public unsafe static void glTransformFeedbackStreamAttribsNV(int count, int* attribs, int nbuffers, int* bufstreams, uint bufferMode) {
            var _F = _GetProc<GLNativeDelegate.FNglTransformFeedbackStreamAttribsNV>("glTransformFeedbackStreamAttribsNV");
            _F(count, attribs, nbuffers, bufstreams, bufferMode);
        }

        #endregion GL_NV_transform_feedback

        #region GL_NV_transform_feedback2

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_transform_feedback2</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glBindTransformFeedbackNV(GLenum target, GLuint id);</para>
        /// </summary>
        public static void glBindTransformFeedbackNV(uint target, uint id) {
            var _F = _GetProc<GLNativeDelegate.FNglBindTransformFeedbackNV>("glBindTransformFeedbackNV");
            _F(target, id);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_transform_feedback2</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glDeleteTransformFeedbacksNV(GLsizei n, const GLuint * ids);</para>
        /// </summary>
        public unsafe static void glDeleteTransformFeedbacksNV(int n, uint* ids) {
            var _F = _GetProc<GLNativeDelegate.FNglDeleteTransformFeedbacksNV>("glDeleteTransformFeedbacksNV");
            _F(n, ids);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_transform_feedback2</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGenTransformFeedbacksNV(GLsizei n, GLuint * ids);</para>
        /// </summary>
        public unsafe static void glGenTransformFeedbacksNV(int n, uint* ids) {
            var _F = _GetProc<GLNativeDelegate.FNglGenTransformFeedbacksNV>("glGenTransformFeedbacksNV");
            _F(n, ids);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_transform_feedback2</para>
        /// Supported: <para>gl</para>
        /// Original: <para>GLboolean glIsTransformFeedbackNV(GLuint id);</para>
        /// </summary>
        public static bool glIsTransformFeedbackNV(uint id) {
            var _F = _GetProc<GLNativeDelegate.FNglIsTransformFeedbackNV>("glIsTransformFeedbackNV");
            return _F(id);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_transform_feedback2</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glPauseTransformFeedbackNV();</para>
        /// </summary>
        public static void glPauseTransformFeedbackNV() {
            var _F = _GetProc<GLNativeDelegate.FNglPauseTransformFeedbackNV>("glPauseTransformFeedbackNV");
            _F();
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_transform_feedback2</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glResumeTransformFeedbackNV();</para>
        /// </summary>
        public static void glResumeTransformFeedbackNV() {
            var _F = _GetProc<GLNativeDelegate.FNglResumeTransformFeedbackNV>("glResumeTransformFeedbackNV");
            _F();
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_transform_feedback2</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glDrawTransformFeedbackNV(GLenum mode, GLuint id);</para>
        /// </summary>
        public static void glDrawTransformFeedbackNV(uint mode, uint id) {
            var _F = _GetProc<GLNativeDelegate.FNglDrawTransformFeedbackNV>("glDrawTransformFeedbackNV");
            _F(mode, id);
        }

        #endregion GL_NV_transform_feedback2

        #region GL_NV_vdpau_interop

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vdpau_interop</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVDPAUInitNV(const void * vdpDevice, const void * getProcAddress);</para>
        /// </summary>
        public unsafe static void glVDPAUInitNV(void* vdpDevice, void* getProcAddress) {
            var _F = _GetProc<GLNativeDelegate.FNglVDPAUInitNV>("glVDPAUInitNV");
            _F(vdpDevice, getProcAddress);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vdpau_interop</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVDPAUFiniNV();</para>
        /// </summary>
        public static void glVDPAUFiniNV() {
            var _F = _GetProc<GLNativeDelegate.FNglVDPAUFiniNV>("glVDPAUFiniNV");
            _F();
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vdpau_interop</para>
        /// Supported: <para>gl</para>
        /// Original: <para>GLvdpauSurfaceNV glVDPAURegisterVideoSurfaceNV(const void * vdpSurface, GLenum target, GLsizei numTextureNames, const GLuint * textureNames);</para>
        /// </summary>
        public unsafe static IntPtr glVDPAURegisterVideoSurfaceNV(void* vdpSurface, uint target, int numTextureNames, uint* textureNames) {
            var _F = _GetProc<GLNativeDelegate.FNglVDPAURegisterVideoSurfaceNV>("glVDPAURegisterVideoSurfaceNV");
            return _F(vdpSurface, target, numTextureNames, textureNames);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vdpau_interop</para>
        /// Supported: <para>gl</para>
        /// Original: <para>GLvdpauSurfaceNV glVDPAURegisterOutputSurfaceNV(const void * vdpSurface, GLenum target, GLsizei numTextureNames, const GLuint * textureNames);</para>
        /// </summary>
        public unsafe static IntPtr glVDPAURegisterOutputSurfaceNV(void* vdpSurface, uint target, int numTextureNames, uint* textureNames) {
            var _F = _GetProc<GLNativeDelegate.FNglVDPAURegisterOutputSurfaceNV>("glVDPAURegisterOutputSurfaceNV");
            return _F(vdpSurface, target, numTextureNames, textureNames);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vdpau_interop</para>
        /// Supported: <para>gl</para>
        /// Original: <para>GLboolean glVDPAUIsSurfaceNV(GLvdpauSurfaceNV surface);</para>
        /// </summary>
        public static bool glVDPAUIsSurfaceNV(IntPtr surface) {
            var _F = _GetProc<GLNativeDelegate.FNglVDPAUIsSurfaceNV>("glVDPAUIsSurfaceNV");
            return _F(surface);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vdpau_interop</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVDPAUUnregisterSurfaceNV(GLvdpauSurfaceNV surface);</para>
        /// </summary>
        public static void glVDPAUUnregisterSurfaceNV(IntPtr surface) {
            var _F = _GetProc<GLNativeDelegate.FNglVDPAUUnregisterSurfaceNV>("glVDPAUUnregisterSurfaceNV");
            _F(surface);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vdpau_interop</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVDPAUGetSurfaceivNV(GLvdpauSurfaceNV surface, GLenum pname, GLsizei count, GLsizei * length, GLint * values);</para>
        /// </summary>
        public unsafe static void glVDPAUGetSurfaceivNV(IntPtr surface, uint pname, int count, int* length, int* values) {
            var _F = _GetProc<GLNativeDelegate.FNglVDPAUGetSurfaceivNV>("glVDPAUGetSurfaceivNV");
            _F(surface, pname, count, length, values);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vdpau_interop</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVDPAUSurfaceAccessNV(GLvdpauSurfaceNV surface, GLenum access);</para>
        /// </summary>
        public static void glVDPAUSurfaceAccessNV(IntPtr surface, uint access) {
            var _F = _GetProc<GLNativeDelegate.FNglVDPAUSurfaceAccessNV>("glVDPAUSurfaceAccessNV");
            _F(surface, access);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vdpau_interop</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVDPAUMapSurfacesNV(GLsizei numSurfaces, const GLvdpauSurfaceNV * surfaces);</para>
        /// </summary>
        public static void glVDPAUMapSurfacesNV(int numSurfaces, IntPtr surfaces) {
            var _F = _GetProc<GLNativeDelegate.FNglVDPAUMapSurfacesNV>("glVDPAUMapSurfacesNV");
            _F(numSurfaces, surfaces);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vdpau_interop</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVDPAUUnmapSurfacesNV(GLsizei numSurface, const GLvdpauSurfaceNV * surfaces);</para>
        /// </summary>
        public static void glVDPAUUnmapSurfacesNV(int numSurface, IntPtr surfaces) {
            var _F = _GetProc<GLNativeDelegate.FNglVDPAUUnmapSurfacesNV>("glVDPAUUnmapSurfacesNV");
            _F(numSurface, surfaces);
        }

        #endregion GL_NV_vdpau_interop

        #region GL_NV_vdpau_interop2

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vdpau_interop2</para>
        /// Supported: <para>gl</para>
        /// Original: <para>GLvdpauSurfaceNV glVDPAURegisterVideoSurfaceWithPictureStructureNV(const void * vdpSurface, GLenum target, GLsizei numTextureNames, const GLuint * textureNames, GLboolean isFrameStructure);</para>
        /// </summary>
        public unsafe static IntPtr glVDPAURegisterVideoSurfaceWithPictureStructureNV(void* vdpSurface, uint target, int numTextureNames, uint* textureNames, bool isFrameStructure) {
            var _F = _GetProc<GLNativeDelegate.FNglVDPAURegisterVideoSurfaceWithPictureStructureNV>("glVDPAURegisterVideoSurfaceWithPictureStructureNV");
            return _F(vdpSurface, target, numTextureNames, textureNames, isFrameStructure);
        }

        #endregion GL_NV_vdpau_interop2

        #region GL_NV_vertex_array_range

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_array_range</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glFlushVertexArrayRangeNV();</para>
        /// </summary>
        public static void glFlushVertexArrayRangeNV() {
            var _F = _GetProc<GLNativeDelegate.FNglFlushVertexArrayRangeNV>("glFlushVertexArrayRangeNV");
            _F();
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_array_range</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexArrayRangeNV(GLsizei length, const void * pointer);</para>
        /// </summary>
        public unsafe static void glVertexArrayRangeNV(int length, void* pointer) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexArrayRangeNV>("glVertexArrayRangeNV");
            _F(length, pointer);
        }

        #endregion GL_NV_vertex_array_range

        #region GL_NV_vertex_attrib_integer_64bit

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_attrib_integer_64bit</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glVertexAttribL1i64NV(GLuint index, GLint64EXT x);</para>
        /// </summary>
        public static void glVertexAttribL1i64NV(uint index, Int64 x) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttribL1i64NV>("glVertexAttribL1i64NV");
            _F(index, x);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_attrib_integer_64bit</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glVertexAttribL2i64NV(GLuint index, GLint64EXT x, GLint64EXT y);</para>
        /// </summary>
        public static void glVertexAttribL2i64NV(uint index, Int64 x, Int64 y) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttribL2i64NV>("glVertexAttribL2i64NV");
            _F(index, x, y);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_attrib_integer_64bit</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glVertexAttribL3i64NV(GLuint index, GLint64EXT x, GLint64EXT y, GLint64EXT z);</para>
        /// </summary>
        public static void glVertexAttribL3i64NV(uint index, Int64 x, Int64 y, Int64 z) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttribL3i64NV>("glVertexAttribL3i64NV");
            _F(index, x, y, z);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_attrib_integer_64bit</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glVertexAttribL4i64NV(GLuint index, GLint64EXT x, GLint64EXT y, GLint64EXT z, GLint64EXT w);</para>
        /// </summary>
        public static void glVertexAttribL4i64NV(uint index, Int64 x, Int64 y, Int64 z, Int64 w) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttribL4i64NV>("glVertexAttribL4i64NV");
            _F(index, x, y, z, w);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_attrib_integer_64bit</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glVertexAttribL1i64vNV(GLuint index, const GLint64EXT * v);</para>
        /// </summary>
        public unsafe static void glVertexAttribL1i64vNV(uint index, Int64* v) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttribL1i64vNV>("glVertexAttribL1i64vNV");
            _F(index, v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_attrib_integer_64bit</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glVertexAttribL2i64vNV(GLuint index, const GLint64EXT * v);</para>
        /// </summary>
        public unsafe static void glVertexAttribL2i64vNV(uint index, Int64* v) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttribL2i64vNV>("glVertexAttribL2i64vNV");
            _F(index, v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_attrib_integer_64bit</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glVertexAttribL3i64vNV(GLuint index, const GLint64EXT * v);</para>
        /// </summary>
        public unsafe static void glVertexAttribL3i64vNV(uint index, Int64* v) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttribL3i64vNV>("glVertexAttribL3i64vNV");
            _F(index, v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_attrib_integer_64bit</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glVertexAttribL4i64vNV(GLuint index, const GLint64EXT * v);</para>
        /// </summary>
        public unsafe static void glVertexAttribL4i64vNV(uint index, Int64* v) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttribL4i64vNV>("glVertexAttribL4i64vNV");
            _F(index, v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_attrib_integer_64bit</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glVertexAttribL1ui64NV(GLuint index, GLuint64EXT x);</para>
        /// </summary>
        public static void glVertexAttribL1ui64NV(uint index, UInt64 x) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttribL1ui64NV>("glVertexAttribL1ui64NV");
            _F(index, x);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_attrib_integer_64bit</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glVertexAttribL2ui64NV(GLuint index, GLuint64EXT x, GLuint64EXT y);</para>
        /// </summary>
        public static void glVertexAttribL2ui64NV(uint index, UInt64 x, UInt64 y) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttribL2ui64NV>("glVertexAttribL2ui64NV");
            _F(index, x, y);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_attrib_integer_64bit</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glVertexAttribL3ui64NV(GLuint index, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z);</para>
        /// </summary>
        public static void glVertexAttribL3ui64NV(uint index, UInt64 x, UInt64 y, UInt64 z) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttribL3ui64NV>("glVertexAttribL3ui64NV");
            _F(index, x, y, z);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_attrib_integer_64bit</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glVertexAttribL4ui64NV(GLuint index, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z, GLuint64EXT w);</para>
        /// </summary>
        public static void glVertexAttribL4ui64NV(uint index, UInt64 x, UInt64 y, UInt64 z, UInt64 w) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttribL4ui64NV>("glVertexAttribL4ui64NV");
            _F(index, x, y, z, w);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_attrib_integer_64bit</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glVertexAttribL1ui64vNV(GLuint index, const GLuint64EXT * v);</para>
        /// </summary>
        public unsafe static void glVertexAttribL1ui64vNV(uint index, UInt64* v) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttribL1ui64vNV>("glVertexAttribL1ui64vNV");
            _F(index, v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_attrib_integer_64bit</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glVertexAttribL2ui64vNV(GLuint index, const GLuint64EXT * v);</para>
        /// </summary>
        public unsafe static void glVertexAttribL2ui64vNV(uint index, UInt64* v) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttribL2ui64vNV>("glVertexAttribL2ui64vNV");
            _F(index, v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_attrib_integer_64bit</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glVertexAttribL3ui64vNV(GLuint index, const GLuint64EXT * v);</para>
        /// </summary>
        public unsafe static void glVertexAttribL3ui64vNV(uint index, UInt64* v) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttribL3ui64vNV>("glVertexAttribL3ui64vNV");
            _F(index, v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_attrib_integer_64bit</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glVertexAttribL4ui64vNV(GLuint index, const GLuint64EXT * v);</para>
        /// </summary>
        public unsafe static void glVertexAttribL4ui64vNV(uint index, UInt64* v) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttribL4ui64vNV>("glVertexAttribL4ui64vNV");
            _F(index, v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_attrib_integer_64bit</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetVertexAttribLi64vNV(GLuint index, GLenum pname, GLint64EXT * params);</para>
        /// </summary>
        public unsafe static void glGetVertexAttribLi64vNV(uint index, uint pname, Int64* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetVertexAttribLi64vNV>("glGetVertexAttribLi64vNV");
            _F(index, pname, ps);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_attrib_integer_64bit</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetVertexAttribLui64vNV(GLuint index, GLenum pname, GLuint64EXT * params);</para>
        /// </summary>
        public unsafe static void glGetVertexAttribLui64vNV(uint index, uint pname, UInt64* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetVertexAttribLui64vNV>("glGetVertexAttribLui64vNV");
            _F(index, pname, ps);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_attrib_integer_64bit</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glVertexAttribLFormatNV(GLuint index, GLint size, GLenum type, GLsizei stride);</para>
        /// </summary>
        public static void glVertexAttribLFormatNV(uint index, int size, uint type, int stride) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttribLFormatNV>("glVertexAttribLFormatNV");
            _F(index, size, type, stride);
        }

        #endregion GL_NV_vertex_attrib_integer_64bit

        #region GL_NV_vertex_buffer_unified_memory

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_buffer_unified_memory</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glBufferAddressRangeNV(GLenum pname, GLuint index, GLuint64EXT address, GLsizeiptr length);</para>
        /// </summary>
        public static void glBufferAddressRangeNV(uint pname, uint index, UInt64 address, IntPtr length) {
            var _F = _GetProc<GLNativeDelegate.FNglBufferAddressRangeNV>("glBufferAddressRangeNV");
            _F(pname, index, address, length);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_buffer_unified_memory</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glVertexFormatNV(GLint size, GLenum type, GLsizei stride);</para>
        /// </summary>
        public static void glVertexFormatNV(int size, uint type, int stride) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexFormatNV>("glVertexFormatNV");
            _F(size, type, stride);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_buffer_unified_memory</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glNormalFormatNV(GLenum type, GLsizei stride);</para>
        /// </summary>
        public static void glNormalFormatNV(uint type, int stride) {
            var _F = _GetProc<GLNativeDelegate.FNglNormalFormatNV>("glNormalFormatNV");
            _F(type, stride);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_buffer_unified_memory</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glColorFormatNV(GLint size, GLenum type, GLsizei stride);</para>
        /// </summary>
        public static void glColorFormatNV(int size, uint type, int stride) {
            var _F = _GetProc<GLNativeDelegate.FNglColorFormatNV>("glColorFormatNV");
            _F(size, type, stride);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_buffer_unified_memory</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glIndexFormatNV(GLenum type, GLsizei stride);</para>
        /// </summary>
        public static void glIndexFormatNV(uint type, int stride) {
            var _F = _GetProc<GLNativeDelegate.FNglIndexFormatNV>("glIndexFormatNV");
            _F(type, stride);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_buffer_unified_memory</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glTexCoordFormatNV(GLint size, GLenum type, GLsizei stride);</para>
        /// </summary>
        public static void glTexCoordFormatNV(int size, uint type, int stride) {
            var _F = _GetProc<GLNativeDelegate.FNglTexCoordFormatNV>("glTexCoordFormatNV");
            _F(size, type, stride);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_buffer_unified_memory</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glEdgeFlagFormatNV(GLsizei stride);</para>
        /// </summary>
        public static void glEdgeFlagFormatNV(int stride) {
            var _F = _GetProc<GLNativeDelegate.FNglEdgeFlagFormatNV>("glEdgeFlagFormatNV");
            _F(stride);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_buffer_unified_memory</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glSecondaryColorFormatNV(GLint size, GLenum type, GLsizei stride);</para>
        /// </summary>
        public static void glSecondaryColorFormatNV(int size, uint type, int stride) {
            var _F = _GetProc<GLNativeDelegate.FNglSecondaryColorFormatNV>("glSecondaryColorFormatNV");
            _F(size, type, stride);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_buffer_unified_memory</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glFogCoordFormatNV(GLenum type, GLsizei stride);</para>
        /// </summary>
        public static void glFogCoordFormatNV(uint type, int stride) {
            var _F = _GetProc<GLNativeDelegate.FNglFogCoordFormatNV>("glFogCoordFormatNV");
            _F(type, stride);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_buffer_unified_memory</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glVertexAttribFormatNV(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride);</para>
        /// </summary>
        public static void glVertexAttribFormatNV(uint index, int size, uint type, bool normalized, int stride) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttribFormatNV>("glVertexAttribFormatNV");
            _F(index, size, type, normalized, stride);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_buffer_unified_memory</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glVertexAttribIFormatNV(GLuint index, GLint size, GLenum type, GLsizei stride);</para>
        /// </summary>
        public static void glVertexAttribIFormatNV(uint index, int size, uint type, int stride) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttribIFormatNV>("glVertexAttribIFormatNV");
            _F(index, size, type, stride);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_buffer_unified_memory</para>
        /// Supported: <para>gl, glcore</para>
        /// Original: <para>void glGetIntegerui64i_vNV(GLenum value, GLuint index, GLuint64EXT * result);</para>
        /// </summary>
        public unsafe static void glGetIntegerui64i_vNV(uint value, uint index, UInt64* result) {
            var _F = _GetProc<GLNativeDelegate.FNglGetIntegerui64i_vNV>("glGetIntegerui64i_vNV");
            _F(value, index, result);
        }

        #endregion GL_NV_vertex_buffer_unified_memory

        #region GL_NV_vertex_program

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_program</para>
        /// Supported: <para>gl</para>
        /// Original: <para>GLboolean glAreProgramsResidentNV(GLsizei n, const GLuint * programs, GLboolean * residences);</para>
        /// </summary>
        public unsafe static bool glAreProgramsResidentNV(int n, uint* programs, bool* residences) {
            var _F = _GetProc<GLNativeDelegate.FNglAreProgramsResidentNV>("glAreProgramsResidentNV");
            return _F(n, programs, residences);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_program</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glBindProgramNV(GLenum target, GLuint id);</para>
        /// </summary>
        public static void glBindProgramNV(uint target, uint id) {
            var _F = _GetProc<GLNativeDelegate.FNglBindProgramNV>("glBindProgramNV");
            _F(target, id);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_program</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glDeleteProgramsNV(GLsizei n, const GLuint * programs);</para>
        /// </summary>
        public unsafe static void glDeleteProgramsNV(int n, uint* programs) {
            var _F = _GetProc<GLNativeDelegate.FNglDeleteProgramsNV>("glDeleteProgramsNV");
            _F(n, programs);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_program</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glExecuteProgramNV(GLenum target, GLuint id, const GLfloat * params);</para>
        /// </summary>
        public unsafe static void glExecuteProgramNV(uint target, uint id, float* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglExecuteProgramNV>("glExecuteProgramNV");
            _F(target, id, ps);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_program</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGenProgramsNV(GLsizei n, GLuint * programs);</para>
        /// </summary>
        public unsafe static void glGenProgramsNV(int n, uint* programs) {
            var _F = _GetProc<GLNativeDelegate.FNglGenProgramsNV>("glGenProgramsNV");
            _F(n, programs);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_program</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetProgramParameterdvNV(GLenum target, GLuint index, GLenum pname, GLdouble * params);</para>
        /// </summary>
        public unsafe static void glGetProgramParameterdvNV(uint target, uint index, uint pname, double* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetProgramParameterdvNV>("glGetProgramParameterdvNV");
            _F(target, index, pname, ps);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_program</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetProgramParameterfvNV(GLenum target, GLuint index, GLenum pname, GLfloat * params);</para>
        /// </summary>
        public unsafe static void glGetProgramParameterfvNV(uint target, uint index, uint pname, float* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetProgramParameterfvNV>("glGetProgramParameterfvNV");
            _F(target, index, pname, ps);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_program</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetProgramivNV(GLuint id, GLenum pname, GLint * params);</para>
        /// </summary>
        public unsafe static void glGetProgramivNV(uint id, uint pname, int* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetProgramivNV>("glGetProgramivNV");
            _F(id, pname, ps);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_program</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetProgramStringNV(GLuint id, GLenum pname, GLubyte * program);</para>
        /// </summary>
        public unsafe static void glGetProgramStringNV(uint id, uint pname, byte* program) {
            var _F = _GetProc<GLNativeDelegate.FNglGetProgramStringNV>("glGetProgramStringNV");
            _F(id, pname, program);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_program</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetTrackMatrixivNV(GLenum target, GLuint address, GLenum pname, GLint * params);</para>
        /// </summary>
        public unsafe static void glGetTrackMatrixivNV(uint target, uint address, uint pname, int* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetTrackMatrixivNV>("glGetTrackMatrixivNV");
            _F(target, address, pname, ps);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_program</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetVertexAttribdvNV(GLuint index, GLenum pname, GLdouble * params);</para>
        /// </summary>
        public unsafe static void glGetVertexAttribdvNV(uint index, uint pname, double* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetVertexAttribdvNV>("glGetVertexAttribdvNV");
            _F(index, pname, ps);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_program</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetVertexAttribfvNV(GLuint index, GLenum pname, GLfloat * params);</para>
        /// </summary>
        public unsafe static void glGetVertexAttribfvNV(uint index, uint pname, float* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetVertexAttribfvNV>("glGetVertexAttribfvNV");
            _F(index, pname, ps);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_program</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetVertexAttribivNV(GLuint index, GLenum pname, GLint * params);</para>
        /// </summary>
        public unsafe static void glGetVertexAttribivNV(uint index, uint pname, int* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetVertexAttribivNV>("glGetVertexAttribivNV");
            _F(index, pname, ps);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_program</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetVertexAttribPointervNV(GLuint index, GLenum pname, void ** pointer);</para>
        /// </summary>
        public unsafe static void glGetVertexAttribPointervNV(uint index, uint pname, void** pointer) {
            var _F = _GetProc<GLNativeDelegate.FNglGetVertexAttribPointervNV>("glGetVertexAttribPointervNV");
            _F(index, pname, pointer);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_program</para>
        /// Supported: <para>gl</para>
        /// Original: <para>GLboolean glIsProgramNV(GLuint id);</para>
        /// </summary>
        public static bool glIsProgramNV(uint id) {
            var _F = _GetProc<GLNativeDelegate.FNglIsProgramNV>("glIsProgramNV");
            return _F(id);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_program</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glLoadProgramNV(GLenum target, GLuint id, GLsizei len, const GLubyte * program);</para>
        /// </summary>
        public unsafe static void glLoadProgramNV(uint target, uint id, int len, byte* program) {
            var _F = _GetProc<GLNativeDelegate.FNglLoadProgramNV>("glLoadProgramNV");
            _F(target, id, len, program);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_program</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glProgramParameter4dNV(GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);</para>
        /// </summary>
        public static void glProgramParameter4dNV(uint target, uint index, double x, double y, double z, double w) {
            var _F = _GetProc<GLNativeDelegate.FNglProgramParameter4dNV>("glProgramParameter4dNV");
            _F(target, index, x, y, z, w);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_program</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glProgramParameter4dvNV(GLenum target, GLuint index, const GLdouble * v);</para>
        /// </summary>
        public unsafe static void glProgramParameter4dvNV(uint target, uint index, double* v) {
            var _F = _GetProc<GLNativeDelegate.FNglProgramParameter4dvNV>("glProgramParameter4dvNV");
            _F(target, index, v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_program</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glProgramParameter4fNV(GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);</para>
        /// </summary>
        public static void glProgramParameter4fNV(uint target, uint index, float x, float y, float z, float w) {
            var _F = _GetProc<GLNativeDelegate.FNglProgramParameter4fNV>("glProgramParameter4fNV");
            _F(target, index, x, y, z, w);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_program</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glProgramParameter4fvNV(GLenum target, GLuint index, const GLfloat * v);</para>
        /// </summary>
        public unsafe static void glProgramParameter4fvNV(uint target, uint index, float* v) {
            var _F = _GetProc<GLNativeDelegate.FNglProgramParameter4fvNV>("glProgramParameter4fvNV");
            _F(target, index, v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_program</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glProgramParameters4dvNV(GLenum target, GLuint index, GLsizei count, const GLdouble * v);</para>
        /// </summary>
        public unsafe static void glProgramParameters4dvNV(uint target, uint index, int count, double* v) {
            var _F = _GetProc<GLNativeDelegate.FNglProgramParameters4dvNV>("glProgramParameters4dvNV");
            _F(target, index, count, v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_program</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glProgramParameters4fvNV(GLenum target, GLuint index, GLsizei count, const GLfloat * v);</para>
        /// </summary>
        public unsafe static void glProgramParameters4fvNV(uint target, uint index, int count, float* v) {
            var _F = _GetProc<GLNativeDelegate.FNglProgramParameters4fvNV>("glProgramParameters4fvNV");
            _F(target, index, count, v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_program</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glRequestResidentProgramsNV(GLsizei n, const GLuint * programs);</para>
        /// </summary>
        public unsafe static void glRequestResidentProgramsNV(int n, uint* programs) {
            var _F = _GetProc<GLNativeDelegate.FNglRequestResidentProgramsNV>("glRequestResidentProgramsNV");
            _F(n, programs);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_program</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glTrackMatrixNV(GLenum target, GLuint address, GLenum matrix, GLenum transform);</para>
        /// </summary>
        public static void glTrackMatrixNV(uint target, uint address, uint matrix, uint transform) {
            var _F = _GetProc<GLNativeDelegate.FNglTrackMatrixNV>("glTrackMatrixNV");
            _F(target, address, matrix, transform);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_program</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexAttribPointerNV(GLuint index, GLint fsize, GLenum type, GLsizei stride, const void * pointer);</para>
        /// </summary>
        public unsafe static void glVertexAttribPointerNV(uint index, int fsize, uint type, int stride, void* pointer) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttribPointerNV>("glVertexAttribPointerNV");
            _F(index, fsize, type, stride, pointer);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_program</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexAttrib1dNV(GLuint index, GLdouble x);</para>
        /// </summary>
        public static void glVertexAttrib1dNV(uint index, double x) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttrib1dNV>("glVertexAttrib1dNV");
            _F(index, x);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_program</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexAttrib1dvNV(GLuint index, const GLdouble * v);</para>
        /// </summary>
        public unsafe static void glVertexAttrib1dvNV(uint index, double* v) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttrib1dvNV>("glVertexAttrib1dvNV");
            _F(index, v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_program</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexAttrib1fNV(GLuint index, GLfloat x);</para>
        /// </summary>
        public static void glVertexAttrib1fNV(uint index, float x) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttrib1fNV>("glVertexAttrib1fNV");
            _F(index, x);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_program</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexAttrib1fvNV(GLuint index, const GLfloat * v);</para>
        /// </summary>
        public unsafe static void glVertexAttrib1fvNV(uint index, float* v) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttrib1fvNV>("glVertexAttrib1fvNV");
            _F(index, v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_program</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexAttrib1sNV(GLuint index, GLshort x);</para>
        /// </summary>
        public static void glVertexAttrib1sNV(uint index, short x) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttrib1sNV>("glVertexAttrib1sNV");
            _F(index, x);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_program</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexAttrib1svNV(GLuint index, const GLshort * v);</para>
        /// </summary>
        public unsafe static void glVertexAttrib1svNV(uint index, short* v) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttrib1svNV>("glVertexAttrib1svNV");
            _F(index, v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_program</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexAttrib2dNV(GLuint index, GLdouble x, GLdouble y);</para>
        /// </summary>
        public static void glVertexAttrib2dNV(uint index, double x, double y) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttrib2dNV>("glVertexAttrib2dNV");
            _F(index, x, y);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_program</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexAttrib2dvNV(GLuint index, const GLdouble * v);</para>
        /// </summary>
        public unsafe static void glVertexAttrib2dvNV(uint index, double* v) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttrib2dvNV>("glVertexAttrib2dvNV");
            _F(index, v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_program</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexAttrib2fNV(GLuint index, GLfloat x, GLfloat y);</para>
        /// </summary>
        public static void glVertexAttrib2fNV(uint index, float x, float y) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttrib2fNV>("glVertexAttrib2fNV");
            _F(index, x, y);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_program</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexAttrib2fvNV(GLuint index, const GLfloat * v);</para>
        /// </summary>
        public unsafe static void glVertexAttrib2fvNV(uint index, float* v) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttrib2fvNV>("glVertexAttrib2fvNV");
            _F(index, v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_program</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexAttrib2sNV(GLuint index, GLshort x, GLshort y);</para>
        /// </summary>
        public static void glVertexAttrib2sNV(uint index, short x, short y) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttrib2sNV>("glVertexAttrib2sNV");
            _F(index, x, y);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_program</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexAttrib2svNV(GLuint index, const GLshort * v);</para>
        /// </summary>
        public unsafe static void glVertexAttrib2svNV(uint index, short* v) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttrib2svNV>("glVertexAttrib2svNV");
            _F(index, v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_program</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexAttrib3dNV(GLuint index, GLdouble x, GLdouble y, GLdouble z);</para>
        /// </summary>
        public static void glVertexAttrib3dNV(uint index, double x, double y, double z) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttrib3dNV>("glVertexAttrib3dNV");
            _F(index, x, y, z);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_program</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexAttrib3dvNV(GLuint index, const GLdouble * v);</para>
        /// </summary>
        public unsafe static void glVertexAttrib3dvNV(uint index, double* v) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttrib3dvNV>("glVertexAttrib3dvNV");
            _F(index, v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_program</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexAttrib3fNV(GLuint index, GLfloat x, GLfloat y, GLfloat z);</para>
        /// </summary>
        public static void glVertexAttrib3fNV(uint index, float x, float y, float z) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttrib3fNV>("glVertexAttrib3fNV");
            _F(index, x, y, z);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_program</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexAttrib3fvNV(GLuint index, const GLfloat * v);</para>
        /// </summary>
        public unsafe static void glVertexAttrib3fvNV(uint index, float* v) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttrib3fvNV>("glVertexAttrib3fvNV");
            _F(index, v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_program</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexAttrib3sNV(GLuint index, GLshort x, GLshort y, GLshort z);</para>
        /// </summary>
        public static void glVertexAttrib3sNV(uint index, short x, short y, short z) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttrib3sNV>("glVertexAttrib3sNV");
            _F(index, x, y, z);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_program</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexAttrib3svNV(GLuint index, const GLshort * v);</para>
        /// </summary>
        public unsafe static void glVertexAttrib3svNV(uint index, short* v) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttrib3svNV>("glVertexAttrib3svNV");
            _F(index, v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_program</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexAttrib4dNV(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);</para>
        /// </summary>
        public static void glVertexAttrib4dNV(uint index, double x, double y, double z, double w) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttrib4dNV>("glVertexAttrib4dNV");
            _F(index, x, y, z, w);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_program</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexAttrib4dvNV(GLuint index, const GLdouble * v);</para>
        /// </summary>
        public unsafe static void glVertexAttrib4dvNV(uint index, double* v) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttrib4dvNV>("glVertexAttrib4dvNV");
            _F(index, v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_program</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexAttrib4fNV(GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);</para>
        /// </summary>
        public static void glVertexAttrib4fNV(uint index, float x, float y, float z, float w) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttrib4fNV>("glVertexAttrib4fNV");
            _F(index, x, y, z, w);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_program</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexAttrib4fvNV(GLuint index, const GLfloat * v);</para>
        /// </summary>
        public unsafe static void glVertexAttrib4fvNV(uint index, float* v) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttrib4fvNV>("glVertexAttrib4fvNV");
            _F(index, v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_program</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexAttrib4sNV(GLuint index, GLshort x, GLshort y, GLshort z, GLshort w);</para>
        /// </summary>
        public static void glVertexAttrib4sNV(uint index, short x, short y, short z, short w) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttrib4sNV>("glVertexAttrib4sNV");
            _F(index, x, y, z, w);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_program</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexAttrib4svNV(GLuint index, const GLshort * v);</para>
        /// </summary>
        public unsafe static void glVertexAttrib4svNV(uint index, short* v) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttrib4svNV>("glVertexAttrib4svNV");
            _F(index, v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_program</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexAttrib4ubNV(GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w);</para>
        /// </summary>
        public static void glVertexAttrib4ubNV(uint index, byte x, byte y, byte z, byte w) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttrib4ubNV>("glVertexAttrib4ubNV");
            _F(index, x, y, z, w);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_program</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexAttrib4ubvNV(GLuint index, const GLubyte * v);</para>
        /// </summary>
        public unsafe static void glVertexAttrib4ubvNV(uint index, byte* v) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttrib4ubvNV>("glVertexAttrib4ubvNV");
            _F(index, v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_program</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexAttribs1dvNV(GLuint index, GLsizei count, const GLdouble * v);</para>
        /// </summary>
        public unsafe static void glVertexAttribs1dvNV(uint index, int count, double* v) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttribs1dvNV>("glVertexAttribs1dvNV");
            _F(index, count, v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_program</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexAttribs1fvNV(GLuint index, GLsizei count, const GLfloat * v);</para>
        /// </summary>
        public unsafe static void glVertexAttribs1fvNV(uint index, int count, float* v) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttribs1fvNV>("glVertexAttribs1fvNV");
            _F(index, count, v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_program</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexAttribs1svNV(GLuint index, GLsizei count, const GLshort * v);</para>
        /// </summary>
        public unsafe static void glVertexAttribs1svNV(uint index, int count, short* v) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttribs1svNV>("glVertexAttribs1svNV");
            _F(index, count, v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_program</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexAttribs2dvNV(GLuint index, GLsizei count, const GLdouble * v);</para>
        /// </summary>
        public unsafe static void glVertexAttribs2dvNV(uint index, int count, double* v) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttribs2dvNV>("glVertexAttribs2dvNV");
            _F(index, count, v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_program</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexAttribs2fvNV(GLuint index, GLsizei count, const GLfloat * v);</para>
        /// </summary>
        public unsafe static void glVertexAttribs2fvNV(uint index, int count, float* v) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttribs2fvNV>("glVertexAttribs2fvNV");
            _F(index, count, v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_program</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexAttribs2svNV(GLuint index, GLsizei count, const GLshort * v);</para>
        /// </summary>
        public unsafe static void glVertexAttribs2svNV(uint index, int count, short* v) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttribs2svNV>("glVertexAttribs2svNV");
            _F(index, count, v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_program</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexAttribs3dvNV(GLuint index, GLsizei count, const GLdouble * v);</para>
        /// </summary>
        public unsafe static void glVertexAttribs3dvNV(uint index, int count, double* v) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttribs3dvNV>("glVertexAttribs3dvNV");
            _F(index, count, v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_program</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexAttribs3fvNV(GLuint index, GLsizei count, const GLfloat * v);</para>
        /// </summary>
        public unsafe static void glVertexAttribs3fvNV(uint index, int count, float* v) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttribs3fvNV>("glVertexAttribs3fvNV");
            _F(index, count, v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_program</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexAttribs3svNV(GLuint index, GLsizei count, const GLshort * v);</para>
        /// </summary>
        public unsafe static void glVertexAttribs3svNV(uint index, int count, short* v) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttribs3svNV>("glVertexAttribs3svNV");
            _F(index, count, v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_program</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexAttribs4dvNV(GLuint index, GLsizei count, const GLdouble * v);</para>
        /// </summary>
        public unsafe static void glVertexAttribs4dvNV(uint index, int count, double* v) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttribs4dvNV>("glVertexAttribs4dvNV");
            _F(index, count, v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_program</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexAttribs4fvNV(GLuint index, GLsizei count, const GLfloat * v);</para>
        /// </summary>
        public unsafe static void glVertexAttribs4fvNV(uint index, int count, float* v) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttribs4fvNV>("glVertexAttribs4fvNV");
            _F(index, count, v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_program</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexAttribs4svNV(GLuint index, GLsizei count, const GLshort * v);</para>
        /// </summary>
        public unsafe static void glVertexAttribs4svNV(uint index, int count, short* v) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttribs4svNV>("glVertexAttribs4svNV");
            _F(index, count, v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_vertex_program</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVertexAttribs4ubvNV(GLuint index, GLsizei count, const GLubyte * v);</para>
        /// </summary>
        public unsafe static void glVertexAttribs4ubvNV(uint index, int count, byte* v) {
            var _F = _GetProc<GLNativeDelegate.FNglVertexAttribs4ubvNV>("glVertexAttribs4ubvNV");
            _F(index, count, v);
        }

        #endregion GL_NV_vertex_program

        #region GL_NV_vertex_program4

        // void glVertexAttribI1iEXT(GLuint index, GLint x);
        // void glVertexAttribI2iEXT(GLuint index, GLint x, GLint y);
        // void glVertexAttribI3iEXT(GLuint index, GLint x, GLint y, GLint z);
        // void glVertexAttribI4iEXT(GLuint index, GLint x, GLint y, GLint z, GLint w);
        // void glVertexAttribI1uiEXT(GLuint index, GLuint x);
        // void glVertexAttribI2uiEXT(GLuint index, GLuint x, GLuint y);
        // void glVertexAttribI3uiEXT(GLuint index, GLuint x, GLuint y, GLuint z);
        // void glVertexAttribI4uiEXT(GLuint index, GLuint x, GLuint y, GLuint z, GLuint w);
        // void glVertexAttribI1ivEXT(GLuint index, const GLint * v);
        // void glVertexAttribI2ivEXT(GLuint index, const GLint * v);
        // void glVertexAttribI3ivEXT(GLuint index, const GLint * v);
        // void glVertexAttribI4ivEXT(GLuint index, const GLint * v);
        // void glVertexAttribI1uivEXT(GLuint index, const GLuint * v);
        // void glVertexAttribI2uivEXT(GLuint index, const GLuint * v);
        // void glVertexAttribI3uivEXT(GLuint index, const GLuint * v);
        // void glVertexAttribI4uivEXT(GLuint index, const GLuint * v);
        // void glVertexAttribI4bvEXT(GLuint index, const GLbyte * v);
        // void glVertexAttribI4svEXT(GLuint index, const GLshort * v);
        // void glVertexAttribI4ubvEXT(GLuint index, const GLubyte * v);
        // void glVertexAttribI4usvEXT(GLuint index, const GLushort * v);
        // void glVertexAttribIPointerEXT(GLuint index, GLint size, GLenum type, GLsizei stride, const void * pointer);
        // void glGetVertexAttribIivEXT(GLuint index, GLenum pname, GLint * ps);
        // void glGetVertexAttribIuivEXT(GLuint index, GLenum pname, GLuint * ps);

        #endregion GL_NV_vertex_program4

        #region GL_NV_video_capture

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_video_capture</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glBeginVideoCaptureNV(GLuint video_capture_slot);</para>
        /// </summary>
        public static void glBeginVideoCaptureNV(uint video_capture_slot) {
            var _F = _GetProc<GLNativeDelegate.FNglBeginVideoCaptureNV>("glBeginVideoCaptureNV");
            _F(video_capture_slot);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_video_capture</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glBindVideoCaptureStreamBufferNV(GLuint video_capture_slot, GLuint stream, GLenum frame_region, GLintptrARB offset);</para>
        /// </summary>
        public static void glBindVideoCaptureStreamBufferNV(uint video_capture_slot, uint stream, uint frame_region, IntPtr offset) {
            var _F = _GetProc<GLNativeDelegate.FNglBindVideoCaptureStreamBufferNV>("glBindVideoCaptureStreamBufferNV");
            _F(video_capture_slot, stream, frame_region, offset);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_video_capture</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glBindVideoCaptureStreamTextureNV(GLuint video_capture_slot, GLuint stream, GLenum frame_region, GLenum target, GLuint texture);</para>
        /// </summary>
        public static void glBindVideoCaptureStreamTextureNV(uint video_capture_slot, uint stream, uint frame_region, uint target, uint texture) {
            var _F = _GetProc<GLNativeDelegate.FNglBindVideoCaptureStreamTextureNV>("glBindVideoCaptureStreamTextureNV");
            _F(video_capture_slot, stream, frame_region, target, texture);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_video_capture</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glEndVideoCaptureNV(GLuint video_capture_slot);</para>
        /// </summary>
        public static void glEndVideoCaptureNV(uint video_capture_slot) {
            var _F = _GetProc<GLNativeDelegate.FNglEndVideoCaptureNV>("glEndVideoCaptureNV");
            _F(video_capture_slot);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_video_capture</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetVideoCaptureivNV(GLuint video_capture_slot, GLenum pname, GLint * params);</para>
        /// </summary>
        public unsafe static void glGetVideoCaptureivNV(uint video_capture_slot, uint pname, int* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetVideoCaptureivNV>("glGetVideoCaptureivNV");
            _F(video_capture_slot, pname, ps);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_video_capture</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetVideoCaptureStreamivNV(GLuint video_capture_slot, GLuint stream, GLenum pname, GLint * params);</para>
        /// </summary>
        public unsafe static void glGetVideoCaptureStreamivNV(uint video_capture_slot, uint stream, uint pname, int* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetVideoCaptureStreamivNV>("glGetVideoCaptureStreamivNV");
            _F(video_capture_slot, stream, pname, ps);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_video_capture</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetVideoCaptureStreamfvNV(GLuint video_capture_slot, GLuint stream, GLenum pname, GLfloat * params);</para>
        /// </summary>
        public unsafe static void glGetVideoCaptureStreamfvNV(uint video_capture_slot, uint stream, uint pname, float* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetVideoCaptureStreamfvNV>("glGetVideoCaptureStreamfvNV");
            _F(video_capture_slot, stream, pname, ps);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_video_capture</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetVideoCaptureStreamdvNV(GLuint video_capture_slot, GLuint stream, GLenum pname, GLdouble * params);</para>
        /// </summary>
        public unsafe static void glGetVideoCaptureStreamdvNV(uint video_capture_slot, uint stream, uint pname, double* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetVideoCaptureStreamdvNV>("glGetVideoCaptureStreamdvNV");
            _F(video_capture_slot, stream, pname, ps);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_video_capture</para>
        /// Supported: <para>gl</para>
        /// Original: <para>GLenum glVideoCaptureNV(GLuint video_capture_slot, GLuint * sequence_num, GLuint64EXT * capture_time);</para>
        /// </summary>
        public unsafe static uint glVideoCaptureNV(uint video_capture_slot, uint* sequence_num, UInt64* capture_time) {
            var _F = _GetProc<GLNativeDelegate.FNglVideoCaptureNV>("glVideoCaptureNV");
            return _F(video_capture_slot, sequence_num, capture_time);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_video_capture</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVideoCaptureStreamParameterivNV(GLuint video_capture_slot, GLuint stream, GLenum pname, const GLint * params);</para>
        /// </summary>
        public unsafe static void glVideoCaptureStreamParameterivNV(uint video_capture_slot, uint stream, uint pname, int* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglVideoCaptureStreamParameterivNV>("glVideoCaptureStreamParameterivNV");
            _F(video_capture_slot, stream, pname, ps);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_video_capture</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVideoCaptureStreamParameterfvNV(GLuint video_capture_slot, GLuint stream, GLenum pname, const GLfloat * params);</para>
        /// </summary>
        public unsafe static void glVideoCaptureStreamParameterfvNV(uint video_capture_slot, uint stream, uint pname, float* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglVideoCaptureStreamParameterfvNV>("glVideoCaptureStreamParameterfvNV");
            _F(video_capture_slot, stream, pname, ps);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_NV_video_capture</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glVideoCaptureStreamParameterdvNV(GLuint video_capture_slot, GLuint stream, GLenum pname, const GLdouble * params);</para>
        /// </summary>
        public unsafe static void glVideoCaptureStreamParameterdvNV(uint video_capture_slot, uint stream, uint pname, double* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglVideoCaptureStreamParameterdvNV>("glVideoCaptureStreamParameterdvNV");
            _F(video_capture_slot, stream, pname, ps);
        }

        #endregion GL_NV_video_capture

        #region GL_NV_viewport_swizzle

        /// <summary>
        /// <para>Require:</para> <para>GL_NV_viewport_swizzle</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glViewportSwizzleNV(GLuint index, GLenum swizzlex, GLenum swizzley, GLenum swizzlez, GLenum swizzlew);</para>
        /// </summary>
        public static void glViewportSwizzleNV(uint index, uint swizzlex, uint swizzley, uint swizzlez, uint swizzlew) {
            var _F = _GetProc<GLNativeDelegate.FNglViewportSwizzleNV>("glViewportSwizzleNV");
            _F(index, swizzlex, swizzley, swizzlez, swizzlew);
        }

        #endregion GL_NV_viewport_swizzle

        #region GL_OES_fixed_point

        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glAlphaFuncxOES(GLenum func, GLfixed ref);</para>
        /// </summary>
        public static void glAlphaFuncxOES(uint func, int r) {
            var _F = _GetProc<GLNativeDelegate.FNglAlphaFuncxOES>("glAlphaFuncxOES");
            _F(func, r);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glClearColorxOES(GLfixed red, GLfixed green, GLfixed blue, GLfixed alpha);</para>
        /// </summary>
        public static void glClearColorxOES(int red, int green, int blue, int alpha) {
            var _F = _GetProc<GLNativeDelegate.FNglClearColorxOES>("glClearColorxOES");
            _F(red, green, blue, alpha);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glClearDepthxOES(GLfixed depth);</para>
        /// </summary>
        public static void glClearDepthxOES(int depth) {
            var _F = _GetProc<GLNativeDelegate.FNglClearDepthxOES>("glClearDepthxOES");
            _F(depth);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glClipPlanexOES(GLenum plane, const GLfixed * equation);</para>
        /// </summary>
        public unsafe static void glClipPlanexOES(uint plane, int* equation) {
            var _F = _GetProc<GLNativeDelegate.FNglClipPlanexOES>("glClipPlanexOES");
            _F(plane, equation);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glColor4xOES(GLfixed red, GLfixed green, GLfixed blue, GLfixed alpha);</para>
        /// </summary>
        public static void glColor4xOES(int red, int green, int blue, int alpha) {
            var _F = _GetProc<GLNativeDelegate.FNglColor4xOES>("glColor4xOES");
            _F(red, green, blue, alpha);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glDepthRangexOES(GLfixed n, GLfixed f);</para>
        /// </summary>
        public static void glDepthRangexOES(int n, int f) {
            var _F = _GetProc<GLNativeDelegate.FNglDepthRangexOES>("glDepthRangexOES");
            _F(n, f);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glFogxOES(GLenum pname, GLfixed param);</para>
        /// </summary>
        public static void glFogxOES(uint pname, int param) {
            var _F = _GetProc<GLNativeDelegate.FNglFogxOES>("glFogxOES");
            _F(pname, param);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glFogxvOES(GLenum pname, const GLfixed * param);</para>
        /// </summary>
        public unsafe static void glFogxvOES(uint pname, int* param) {
            var _F = _GetProc<GLNativeDelegate.FNglFogxvOES>("glFogxvOES");
            _F(pname, param);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glFrustumxOES(GLfixed l, GLfixed r, GLfixed b, GLfixed t, GLfixed n, GLfixed f);</para>
        /// </summary>
        public static void glFrustumxOES(int l, int r, int b, int t, int n, int f) {
            var _F = _GetProc<GLNativeDelegate.FNglFrustumxOES>("glFrustumxOES");
            _F(l, r, b, t, n, f);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glGetClipPlanexOES(GLenum plane, GLfixed * equation);</para>
        /// </summary>
        public unsafe static void glGetClipPlanexOES(uint plane, int* equation) {
            var _F = _GetProc<GLNativeDelegate.FNglGetClipPlanexOES>("glGetClipPlanexOES");
            _F(plane, equation);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glGetFixedvOES(GLenum pname, GLfixed * params);</para>
        /// </summary>
        public unsafe static void glGetFixedvOES(uint pname, int* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetFixedvOES>("glGetFixedvOES");
            _F(pname, ps);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glGetTexEnvxvOES(GLenum target, GLenum pname, GLfixed * params);</para>
        /// </summary>
        public unsafe static void glGetTexEnvxvOES(uint target, uint pname, int* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetTexEnvxvOES>("glGetTexEnvxvOES");
            _F(target, pname, ps);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glGetTexParameterxvOES(GLenum target, GLenum pname, GLfixed * params);</para>
        /// </summary>
        public unsafe static void glGetTexParameterxvOES(uint target, uint pname, int* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetTexParameterxvOES>("glGetTexParameterxvOES");
            _F(target, pname, ps);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glLightModelxOES(GLenum pname, GLfixed param);</para>
        /// </summary>
        public static void glLightModelxOES(uint pname, int param) {
            var _F = _GetProc<GLNativeDelegate.FNglLightModelxOES>("glLightModelxOES");
            _F(pname, param);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glLightModelxvOES(GLenum pname, const GLfixed * param);</para>
        /// </summary>
        public unsafe static void glLightModelxvOES(uint pname, int* param) {
            var _F = _GetProc<GLNativeDelegate.FNglLightModelxvOES>("glLightModelxvOES");
            _F(pname, param);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glLightxOES(GLenum light, GLenum pname, GLfixed param);</para>
        /// </summary>
        public static void glLightxOES(uint light, uint pname, int param) {
            var _F = _GetProc<GLNativeDelegate.FNglLightxOES>("glLightxOES");
            _F(light, pname, param);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glLightxvOES(GLenum light, GLenum pname, const GLfixed * params);</para>
        /// </summary>
        public unsafe static void glLightxvOES(uint light, uint pname, int* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglLightxvOES>("glLightxvOES");
            _F(light, pname, ps);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glLineWidthxOES(GLfixed width);</para>
        /// </summary>
        public static void glLineWidthxOES(int width) {
            var _F = _GetProc<GLNativeDelegate.FNglLineWidthxOES>("glLineWidthxOES");
            _F(width);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glLoadMatrixxOES(const GLfixed * m);</para>
        /// </summary>
        public unsafe static void glLoadMatrixxOES(int* m) {
            var _F = _GetProc<GLNativeDelegate.FNglLoadMatrixxOES>("glLoadMatrixxOES");
            _F(m);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glMaterialxOES(GLenum face, GLenum pname, GLfixed param);</para>
        /// </summary>
        public static void glMaterialxOES(uint face, uint pname, int param) {
            var _F = _GetProc<GLNativeDelegate.FNglMaterialxOES>("glMaterialxOES");
            _F(face, pname, param);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glMaterialxvOES(GLenum face, GLenum pname, const GLfixed * param);</para>
        /// </summary>
        public unsafe static void glMaterialxvOES(uint face, uint pname, int* param) {
            var _F = _GetProc<GLNativeDelegate.FNglMaterialxvOES>("glMaterialxvOES");
            _F(face, pname, param);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glMultMatrixxOES(const GLfixed * m);</para>
        /// </summary>
        public unsafe static void glMultMatrixxOES(int* m) {
            var _F = _GetProc<GLNativeDelegate.FNglMultMatrixxOES>("glMultMatrixxOES");
            _F(m);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glMultiTexCoord4xOES(GLenum texture, GLfixed s, GLfixed t, GLfixed r, GLfixed q);</para>
        /// </summary>
        public static void glMultiTexCoord4xOES(uint texture, int s, int t, int r, int q) {
            var _F = _GetProc<GLNativeDelegate.FNglMultiTexCoord4xOES>("glMultiTexCoord4xOES");
            _F(texture, s, t, r, q);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glNormal3xOES(GLfixed nx, GLfixed ny, GLfixed nz);</para>
        /// </summary>
        public static void glNormal3xOES(int nx, int ny, int nz) {
            var _F = _GetProc<GLNativeDelegate.FNglNormal3xOES>("glNormal3xOES");
            _F(nx, ny, nz);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glOrthoxOES(GLfixed l, GLfixed r, GLfixed b, GLfixed t, GLfixed n, GLfixed f);</para>
        /// </summary>
        public static void glOrthoxOES(int l, int r, int b, int t, int n, int f) {
            var _F = _GetProc<GLNativeDelegate.FNglOrthoxOES>("glOrthoxOES");
            _F(l, r, b, t, n, f);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glPointParameterxvOES(GLenum pname, const GLfixed * params);</para>
        /// </summary>
        public unsafe static void glPointParameterxvOES(uint pname, int* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglPointParameterxvOES>("glPointParameterxvOES");
            _F(pname, ps);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glPointSizexOES(GLfixed size);</para>
        /// </summary>
        public static void glPointSizexOES(int size) {
            var _F = _GetProc<GLNativeDelegate.FNglPointSizexOES>("glPointSizexOES");
            _F(size);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glPolygonOffsetxOES(GLfixed factor, GLfixed units);</para>
        /// </summary>
        public static void glPolygonOffsetxOES(int factor, int units) {
            var _F = _GetProc<GLNativeDelegate.FNglPolygonOffsetxOES>("glPolygonOffsetxOES");
            _F(factor, units);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glRotatexOES(GLfixed angle, GLfixed x, GLfixed y, GLfixed z);</para>
        /// </summary>
        public static void glRotatexOES(int angle, int x, int y, int z) {
            var _F = _GetProc<GLNativeDelegate.FNglRotatexOES>("glRotatexOES");
            _F(angle, x, y, z);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glScalexOES(GLfixed x, GLfixed y, GLfixed z);</para>
        /// </summary>
        public static void glScalexOES(int x, int y, int z) {
            var _F = _GetProc<GLNativeDelegate.FNglScalexOES>("glScalexOES");
            _F(x, y, z);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glTexEnvxOES(GLenum target, GLenum pname, GLfixed param);</para>
        /// </summary>
        public static void glTexEnvxOES(uint target, uint pname, int param) {
            var _F = _GetProc<GLNativeDelegate.FNglTexEnvxOES>("glTexEnvxOES");
            _F(target, pname, param);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glTexEnvxvOES(GLenum target, GLenum pname, const GLfixed * params);</para>
        /// </summary>
        public unsafe static void glTexEnvxvOES(uint target, uint pname, int* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglTexEnvxvOES>("glTexEnvxvOES");
            _F(target, pname, ps);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glTexParameterxOES(GLenum target, GLenum pname, GLfixed param);</para>
        /// </summary>
        public static void glTexParameterxOES(uint target, uint pname, int param) {
            var _F = _GetProc<GLNativeDelegate.FNglTexParameterxOES>("glTexParameterxOES");
            _F(target, pname, param);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glTexParameterxvOES(GLenum target, GLenum pname, const GLfixed * params);</para>
        /// </summary>
        public unsafe static void glTexParameterxvOES(uint target, uint pname, int* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglTexParameterxvOES>("glTexParameterxvOES");
            _F(target, pname, ps);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glTranslatexOES(GLfixed x, GLfixed y, GLfixed z);</para>
        /// </summary>
        public static void glTranslatexOES(int x, int y, int z) {
            var _F = _GetProc<GLNativeDelegate.FNglTranslatexOES>("glTranslatexOES");
            _F(x, y, z);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glGetLightxvOES(GLenum light, GLenum pname, GLfixed * params);</para>
        /// </summary>
        public unsafe static void glGetLightxvOES(uint light, uint pname, int* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetLightxvOES>("glGetLightxvOES");
            _F(light, pname, ps);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glGetMaterialxvOES(GLenum face, GLenum pname, GLfixed * params);</para>
        /// </summary>
        public unsafe static void glGetMaterialxvOES(uint face, uint pname, int* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetMaterialxvOES>("glGetMaterialxvOES");
            _F(face, pname, ps);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glPointParameterxOES(GLenum pname, GLfixed param);</para>
        /// </summary>
        public static void glPointParameterxOES(uint pname, int param) {
            var _F = _GetProc<GLNativeDelegate.FNglPointParameterxOES>("glPointParameterxOES");
            _F(pname, param);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glSampleCoveragexOES(GLclampx value, GLboolean invert);</para>
        /// </summary>
        public static void glSampleCoveragexOES(Int32 value, bool invert) {
            var _F = _GetProc<GLNativeDelegate.FNglSampleCoveragexOES>("glSampleCoveragexOES");
            _F(value, invert);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glAccumxOES(GLenum op, GLfixed value);</para>
        /// </summary>
        public static void glAccumxOES(uint op, int value) {
            var _F = _GetProc<GLNativeDelegate.FNglAccumxOES>("glAccumxOES");
            _F(op, value);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glBitmapxOES(GLsizei width, GLsizei height, GLfixed xorig, GLfixed yorig, GLfixed xmove, GLfixed ymove, const GLubyte * bitmap);</para>
        /// </summary>
        public unsafe static void glBitmapxOES(int width, int height, int xorig, int yorig, int xmove, int ymove, byte* bitmap) {
            var _F = _GetProc<GLNativeDelegate.FNglBitmapxOES>("glBitmapxOES");
            _F(width, height, xorig, yorig, xmove, ymove, bitmap);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glBlendColorxOES(GLfixed red, GLfixed green, GLfixed blue, GLfixed alpha);</para>
        /// </summary>
        public static void glBlendColorxOES(int red, int green, int blue, int alpha) {
            var _F = _GetProc<GLNativeDelegate.FNglBlendColorxOES>("glBlendColorxOES");
            _F(red, green, blue, alpha);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glClearAccumxOES(GLfixed red, GLfixed green, GLfixed blue, GLfixed alpha);</para>
        /// </summary>
        public static void glClearAccumxOES(int red, int green, int blue, int alpha) {
            var _F = _GetProc<GLNativeDelegate.FNglClearAccumxOES>("glClearAccumxOES");
            _F(red, green, blue, alpha);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glColor3xOES(GLfixed red, GLfixed green, GLfixed blue);</para>
        /// </summary>
        public static void glColor3xOES(int red, int green, int blue) {
            var _F = _GetProc<GLNativeDelegate.FNglColor3xOES>("glColor3xOES");
            _F(red, green, blue);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glColor3xvOES(const GLfixed * components);</para>
        /// </summary>
        public unsafe static void glColor3xvOES(int* components) {
            var _F = _GetProc<GLNativeDelegate.FNglColor3xvOES>("glColor3xvOES");
            _F(components);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glColor4xvOES(const GLfixed * components);</para>
        /// </summary>
        public unsafe static void glColor4xvOES(int* components) {
            var _F = _GetProc<GLNativeDelegate.FNglColor4xvOES>("glColor4xvOES");
            _F(components);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glConvolutionParameterxOES(GLenum target, GLenum pname, GLfixed param);</para>
        /// </summary>
        public static void glConvolutionParameterxOES(uint target, uint pname, int param) {
            var _F = _GetProc<GLNativeDelegate.FNglConvolutionParameterxOES>("glConvolutionParameterxOES");
            _F(target, pname, param);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glConvolutionParameterxvOES(GLenum target, GLenum pname, const GLfixed * params);</para>
        /// </summary>
        public unsafe static void glConvolutionParameterxvOES(uint target, uint pname, int* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglConvolutionParameterxvOES>("glConvolutionParameterxvOES");
            _F(target, pname, ps);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glEvalCoord1xOES(GLfixed u);</para>
        /// </summary>
        public static void glEvalCoord1xOES(int u) {
            var _F = _GetProc<GLNativeDelegate.FNglEvalCoord1xOES>("glEvalCoord1xOES");
            _F(u);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glEvalCoord1xvOES(const GLfixed * coords);</para>
        /// </summary>
        public unsafe static void glEvalCoord1xvOES(int* coords) {
            var _F = _GetProc<GLNativeDelegate.FNglEvalCoord1xvOES>("glEvalCoord1xvOES");
            _F(coords);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glEvalCoord2xOES(GLfixed u, GLfixed v);</para>
        /// </summary>
        public static void glEvalCoord2xOES(int u, int v) {
            var _F = _GetProc<GLNativeDelegate.FNglEvalCoord2xOES>("glEvalCoord2xOES");
            _F(u, v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glEvalCoord2xvOES(const GLfixed * coords);</para>
        /// </summary>
        public unsafe static void glEvalCoord2xvOES(int* coords) {
            var _F = _GetProc<GLNativeDelegate.FNglEvalCoord2xvOES>("glEvalCoord2xvOES");
            _F(coords);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glFeedbackBufferxOES(GLsizei n, GLenum type, const GLfixed * buffer);</para>
        /// </summary>
        public unsafe static void glFeedbackBufferxOES(int n, uint type, int* buffer) {
            var _F = _GetProc<GLNativeDelegate.FNglFeedbackBufferxOES>("glFeedbackBufferxOES");
            _F(n, type, buffer);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glGetConvolutionParameterxvOES(GLenum target, GLenum pname, GLfixed * params);</para>
        /// </summary>
        public unsafe static void glGetConvolutionParameterxvOES(uint target, uint pname, int* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetConvolutionParameterxvOES>("glGetConvolutionParameterxvOES");
            _F(target, pname, ps);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glGetHistogramParameterxvOES(GLenum target, GLenum pname, GLfixed * params);</para>
        /// </summary>
        public unsafe static void glGetHistogramParameterxvOES(uint target, uint pname, int* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetHistogramParameterxvOES>("glGetHistogramParameterxvOES");
            _F(target, pname, ps);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glGetLightxOES(GLenum light, GLenum pname, GLfixed * params);</para>
        /// </summary>
        public unsafe static void glGetLightxOES(uint light, uint pname, int* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetLightxOES>("glGetLightxOES");
            _F(light, pname, ps);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glGetMapxvOES(GLenum target, GLenum query, GLfixed * v);</para>
        /// </summary>
        public unsafe static void glGetMapxvOES(uint target, uint query, int* v) {
            var _F = _GetProc<GLNativeDelegate.FNglGetMapxvOES>("glGetMapxvOES");
            _F(target, query, v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glGetMaterialxOES(GLenum face, GLenum pname, GLfixed param);</para>
        /// </summary>
        public static void glGetMaterialxOES(uint face, uint pname, int param) {
            var _F = _GetProc<GLNativeDelegate.FNglGetMaterialxOES>("glGetMaterialxOES");
            _F(face, pname, param);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glGetPixelMapxv(GLenum map, GLint size, GLfixed * values);</para>
        /// </summary>
        public unsafe static void glGetPixelMapxv(uint map, int size, int* values) {
            var _F = _GetProc<GLNativeDelegate.FNglGetPixelMapxv>("glGetPixelMapxv");
            _F(map, size, values);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point, GL_OES_texture_cube_map</para>
        /// Supported: <para>gl, gles1, gles1</para>
        /// Original: <para>void glGetTexGenxvOES(GLenum coord, GLenum pname, GLfixed * params);</para>
        /// </summary>
        public unsafe static void glGetTexGenxvOES(uint coord, uint pname, int* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetTexGenxvOES>("glGetTexGenxvOES");
            _F(coord, pname, ps);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glGetTexLevelParameterxvOES(GLenum target, GLint level, GLenum pname, GLfixed * params);</para>
        /// </summary>
        public unsafe static void glGetTexLevelParameterxvOES(uint target, int level, uint pname, int* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetTexLevelParameterxvOES>("glGetTexLevelParameterxvOES");
            _F(target, level, pname, ps);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glIndexxOES(GLfixed component);</para>
        /// </summary>
        public static void glIndexxOES(int component) {
            var _F = _GetProc<GLNativeDelegate.FNglIndexxOES>("glIndexxOES");
            _F(component);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glIndexxvOES(const GLfixed * component);</para>
        /// </summary>
        public unsafe static void glIndexxvOES(int* component) {
            var _F = _GetProc<GLNativeDelegate.FNglIndexxvOES>("glIndexxvOES");
            _F(component);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glLoadTransposeMatrixxOES(const GLfixed * m);</para>
        /// </summary>
        public unsafe static void glLoadTransposeMatrixxOES(int* m) {
            var _F = _GetProc<GLNativeDelegate.FNglLoadTransposeMatrixxOES>("glLoadTransposeMatrixxOES");
            _F(m);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glMap1xOES(GLenum target, GLfixed u1, GLfixed u2, GLint stride, GLint order, GLfixed points);</para>
        /// </summary>
        public static void glMap1xOES(uint target, int u1, int u2, int stride, int order, int points) {
            var _F = _GetProc<GLNativeDelegate.FNglMap1xOES>("glMap1xOES");
            _F(target, u1, u2, stride, order, points);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glMap2xOES(GLenum target, GLfixed u1, GLfixed u2, GLint ustride, GLint uorder, GLfixed v1, GLfixed v2, GLint vstride, GLint vorder, GLfixed points);</para>
        /// </summary>
        public static void glMap2xOES(uint target, int u1, int u2, int ustride, int uorder, int v1, int v2, int vstride, int vorder, int points) {
            var _F = _GetProc<GLNativeDelegate.FNglMap2xOES>("glMap2xOES");
            _F(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glMapGrid1xOES(GLint n, GLfixed u1, GLfixed u2);</para>
        /// </summary>
        public static void glMapGrid1xOES(int n, int u1, int u2) {
            var _F = _GetProc<GLNativeDelegate.FNglMapGrid1xOES>("glMapGrid1xOES");
            _F(n, u1, u2);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glMapGrid2xOES(GLint n, GLfixed u1, GLfixed u2, GLfixed v1, GLfixed v2);</para>
        /// </summary>
        public static void glMapGrid2xOES(int n, int u1, int u2, int v1, int v2) {
            var _F = _GetProc<GLNativeDelegate.FNglMapGrid2xOES>("glMapGrid2xOES");
            _F(n, u1, u2, v1, v2);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glMultTransposeMatrixxOES(const GLfixed * m);</para>
        /// </summary>
        public unsafe static void glMultTransposeMatrixxOES(int* m) {
            var _F = _GetProc<GLNativeDelegate.FNglMultTransposeMatrixxOES>("glMultTransposeMatrixxOES");
            _F(m);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glMultiTexCoord1xOES(GLenum texture, GLfixed s);</para>
        /// </summary>
        public static void glMultiTexCoord1xOES(uint texture, int s) {
            var _F = _GetProc<GLNativeDelegate.FNglMultiTexCoord1xOES>("glMultiTexCoord1xOES");
            _F(texture, s);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glMultiTexCoord1xvOES(GLenum texture, const GLfixed * coords);</para>
        /// </summary>
        public unsafe static void glMultiTexCoord1xvOES(uint texture, int* coords) {
            var _F = _GetProc<GLNativeDelegate.FNglMultiTexCoord1xvOES>("glMultiTexCoord1xvOES");
            _F(texture, coords);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glMultiTexCoord2xOES(GLenum texture, GLfixed s, GLfixed t);</para>
        /// </summary>
        public static void glMultiTexCoord2xOES(uint texture, int s, int t) {
            var _F = _GetProc<GLNativeDelegate.FNglMultiTexCoord2xOES>("glMultiTexCoord2xOES");
            _F(texture, s, t);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glMultiTexCoord2xvOES(GLenum texture, const GLfixed * coords);</para>
        /// </summary>
        public unsafe static void glMultiTexCoord2xvOES(uint texture, int* coords) {
            var _F = _GetProc<GLNativeDelegate.FNglMultiTexCoord2xvOES>("glMultiTexCoord2xvOES");
            _F(texture, coords);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glMultiTexCoord3xOES(GLenum texture, GLfixed s, GLfixed t, GLfixed r);</para>
        /// </summary>
        public static void glMultiTexCoord3xOES(uint texture, int s, int t, int r) {
            var _F = _GetProc<GLNativeDelegate.FNglMultiTexCoord3xOES>("glMultiTexCoord3xOES");
            _F(texture, s, t, r);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glMultiTexCoord3xvOES(GLenum texture, const GLfixed * coords);</para>
        /// </summary>
        public unsafe static void glMultiTexCoord3xvOES(uint texture, int* coords) {
            var _F = _GetProc<GLNativeDelegate.FNglMultiTexCoord3xvOES>("glMultiTexCoord3xvOES");
            _F(texture, coords);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glMultiTexCoord4xvOES(GLenum texture, const GLfixed * coords);</para>
        /// </summary>
        public unsafe static void glMultiTexCoord4xvOES(uint texture, int* coords) {
            var _F = _GetProc<GLNativeDelegate.FNglMultiTexCoord4xvOES>("glMultiTexCoord4xvOES");
            _F(texture, coords);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glNormal3xvOES(const GLfixed * coords);</para>
        /// </summary>
        public unsafe static void glNormal3xvOES(int* coords) {
            var _F = _GetProc<GLNativeDelegate.FNglNormal3xvOES>("glNormal3xvOES");
            _F(coords);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glPassThroughxOES(GLfixed token);</para>
        /// </summary>
        public static void glPassThroughxOES(int token) {
            var _F = _GetProc<GLNativeDelegate.FNglPassThroughxOES>("glPassThroughxOES");
            _F(token);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glPixelMapx(GLenum map, GLint size, const GLfixed * values);</para>
        /// </summary>
        public unsafe static void glPixelMapx(uint map, int size, int* values) {
            var _F = _GetProc<GLNativeDelegate.FNglPixelMapx>("glPixelMapx");
            _F(map, size, values);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glPixelStorex(GLenum pname, GLfixed param);</para>
        /// </summary>
        public static void glPixelStorex(uint pname, int param) {
            var _F = _GetProc<GLNativeDelegate.FNglPixelStorex>("glPixelStorex");
            _F(pname, param);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glPixelTransferxOES(GLenum pname, GLfixed param);</para>
        /// </summary>
        public static void glPixelTransferxOES(uint pname, int param) {
            var _F = _GetProc<GLNativeDelegate.FNglPixelTransferxOES>("glPixelTransferxOES");
            _F(pname, param);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glPixelZoomxOES(GLfixed xfactor, GLfixed yfactor);</para>
        /// </summary>
        public static void glPixelZoomxOES(int xfactor, int yfactor) {
            var _F = _GetProc<GLNativeDelegate.FNglPixelZoomxOES>("glPixelZoomxOES");
            _F(xfactor, yfactor);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glPrioritizeTexturesxOES(GLsizei n, const GLuint * textures, const GLfixed * priorities);</para>
        /// </summary>
        public unsafe static void glPrioritizeTexturesxOES(int n, uint* textures, int* priorities) {
            var _F = _GetProc<GLNativeDelegate.FNglPrioritizeTexturesxOES>("glPrioritizeTexturesxOES");
            _F(n, textures, priorities);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glRasterPos2xOES(GLfixed x, GLfixed y);</para>
        /// </summary>
        public static void glRasterPos2xOES(int x, int y) {
            var _F = _GetProc<GLNativeDelegate.FNglRasterPos2xOES>("glRasterPos2xOES");
            _F(x, y);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glRasterPos2xvOES(const GLfixed * coords);</para>
        /// </summary>
        public unsafe static void glRasterPos2xvOES(int* coords) {
            var _F = _GetProc<GLNativeDelegate.FNglRasterPos2xvOES>("glRasterPos2xvOES");
            _F(coords);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glRasterPos3xOES(GLfixed x, GLfixed y, GLfixed z);</para>
        /// </summary>
        public static void glRasterPos3xOES(int x, int y, int z) {
            var _F = _GetProc<GLNativeDelegate.FNglRasterPos3xOES>("glRasterPos3xOES");
            _F(x, y, z);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glRasterPos3xvOES(const GLfixed * coords);</para>
        /// </summary>
        public unsafe static void glRasterPos3xvOES(int* coords) {
            var _F = _GetProc<GLNativeDelegate.FNglRasterPos3xvOES>("glRasterPos3xvOES");
            _F(coords);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glRasterPos4xOES(GLfixed x, GLfixed y, GLfixed z, GLfixed w);</para>
        /// </summary>
        public static void glRasterPos4xOES(int x, int y, int z, int w) {
            var _F = _GetProc<GLNativeDelegate.FNglRasterPos4xOES>("glRasterPos4xOES");
            _F(x, y, z, w);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glRasterPos4xvOES(const GLfixed * coords);</para>
        /// </summary>
        public unsafe static void glRasterPos4xvOES(int* coords) {
            var _F = _GetProc<GLNativeDelegate.FNglRasterPos4xvOES>("glRasterPos4xvOES");
            _F(coords);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glRectxOES(GLfixed x1, GLfixed y1, GLfixed x2, GLfixed y2);</para>
        /// </summary>
        public static void glRectxOES(int x1, int y1, int x2, int y2) {
            var _F = _GetProc<GLNativeDelegate.FNglRectxOES>("glRectxOES");
            _F(x1, y1, x2, y2);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glRectxvOES(const GLfixed * v1, const GLfixed * v2);</para>
        /// </summary>
        public unsafe static void glRectxvOES(int* v1, int* v2) {
            var _F = _GetProc<GLNativeDelegate.FNglRectxvOES>("glRectxvOES");
            _F(v1, v2);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glTexCoord1xOES(GLfixed s);</para>
        /// </summary>
        public static void glTexCoord1xOES(int s) {
            var _F = _GetProc<GLNativeDelegate.FNglTexCoord1xOES>("glTexCoord1xOES");
            _F(s);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glTexCoord1xvOES(const GLfixed * coords);</para>
        /// </summary>
        public unsafe static void glTexCoord1xvOES(int* coords) {
            var _F = _GetProc<GLNativeDelegate.FNglTexCoord1xvOES>("glTexCoord1xvOES");
            _F(coords);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glTexCoord2xOES(GLfixed s, GLfixed t);</para>
        /// </summary>
        public static void glTexCoord2xOES(int s, int t) {
            var _F = _GetProc<GLNativeDelegate.FNglTexCoord2xOES>("glTexCoord2xOES");
            _F(s, t);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glTexCoord2xvOES(const GLfixed * coords);</para>
        /// </summary>
        public unsafe static void glTexCoord2xvOES(int* coords) {
            var _F = _GetProc<GLNativeDelegate.FNglTexCoord2xvOES>("glTexCoord2xvOES");
            _F(coords);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glTexCoord3xOES(GLfixed s, GLfixed t, GLfixed r);</para>
        /// </summary>
        public static void glTexCoord3xOES(int s, int t, int r) {
            var _F = _GetProc<GLNativeDelegate.FNglTexCoord3xOES>("glTexCoord3xOES");
            _F(s, t, r);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glTexCoord3xvOES(const GLfixed * coords);</para>
        /// </summary>
        public unsafe static void glTexCoord3xvOES(int* coords) {
            var _F = _GetProc<GLNativeDelegate.FNglTexCoord3xvOES>("glTexCoord3xvOES");
            _F(coords);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glTexCoord4xOES(GLfixed s, GLfixed t, GLfixed r, GLfixed q);</para>
        /// </summary>
        public static void glTexCoord4xOES(int s, int t, int r, int q) {
            var _F = _GetProc<GLNativeDelegate.FNglTexCoord4xOES>("glTexCoord4xOES");
            _F(s, t, r, q);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glTexCoord4xvOES(const GLfixed * coords);</para>
        /// </summary>
        public unsafe static void glTexCoord4xvOES(int* coords) {
            var _F = _GetProc<GLNativeDelegate.FNglTexCoord4xvOES>("glTexCoord4xvOES");
            _F(coords);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point, GL_OES_texture_cube_map</para>
        /// Supported: <para>gl, gles1, gles1</para>
        /// Original: <para>void glTexGenxOES(GLenum coord, GLenum pname, GLfixed param);</para>
        /// </summary>
        public static void glTexGenxOES(uint coord, uint pname, int param) {
            var _F = _GetProc<GLNativeDelegate.FNglTexGenxOES>("glTexGenxOES");
            _F(coord, pname, param);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point, GL_OES_texture_cube_map</para>
        /// Supported: <para>gl, gles1, gles1</para>
        /// Original: <para>void glTexGenxvOES(GLenum coord, GLenum pname, const GLfixed * params);</para>
        /// </summary>
        public unsafe static void glTexGenxvOES(uint coord, uint pname, int* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglTexGenxvOES>("glTexGenxvOES");
            _F(coord, pname, ps);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glVertex2xOES(GLfixed x);</para>
        /// </summary>
        public static void glVertex2xOES(int x) {
            var _F = _GetProc<GLNativeDelegate.FNglVertex2xOES>("glVertex2xOES");
            _F(x);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glVertex2xvOES(const GLfixed * coords);</para>
        /// </summary>
        public unsafe static void glVertex2xvOES(int* coords) {
            var _F = _GetProc<GLNativeDelegate.FNglVertex2xvOES>("glVertex2xvOES");
            _F(coords);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glVertex3xOES(GLfixed x, GLfixed y);</para>
        /// </summary>
        public static void glVertex3xOES(int x, int y) {
            var _F = _GetProc<GLNativeDelegate.FNglVertex3xOES>("glVertex3xOES");
            _F(x, y);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glVertex3xvOES(const GLfixed * coords);</para>
        /// </summary>
        public unsafe static void glVertex3xvOES(int* coords) {
            var _F = _GetProc<GLNativeDelegate.FNglVertex3xvOES>("glVertex3xvOES");
            _F(coords);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glVertex4xOES(GLfixed x, GLfixed y, GLfixed z);</para>
        /// </summary>
        public static void glVertex4xOES(int x, int y, int z) {
            var _F = _GetProc<GLNativeDelegate.FNglVertex4xOES>("glVertex4xOES");
            _F(x, y, z);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_OES_fixed_point</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glVertex4xvOES(const GLfixed * coords);</para>
        /// </summary>
        public unsafe static void glVertex4xvOES(int* coords) {
            var _F = _GetProc<GLNativeDelegate.FNglVertex4xvOES>("glVertex4xvOES");
            _F(coords);
        }

        #endregion GL_OES_fixed_point

        #region GL_OES_query_matrix

        /// <summary>
        /// <para>Require:</para> <para>GL_OES_query_matrix</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>GLbitfield glQueryMatrixxOES(GLfixed * mantissa, GLint * exponent);</para>
        /// </summary>
        public unsafe static uint glQueryMatrixxOES(int* mantissa, int* exponent) {
            var _F = _GetProc<GLNativeDelegate.FNglQueryMatrixxOES>("glQueryMatrixxOES");
            return _F(mantissa, exponent);
        }

        #endregion GL_OES_query_matrix

        #region GL_OES_single_precision

        /// <summary>
        /// <para>Require:</para> <para>GL_OES_single_precision</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glClearDepthfOES(GLclampf depth);</para>
        /// </summary>
        public static void glClearDepthfOES(float depth) {
            var _F = _GetProc<GLNativeDelegate.FNglClearDepthfOES>("glClearDepthfOES");
            _F(depth);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_OES_single_precision</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glClipPlanefOES(GLenum plane, const GLfloat * equation);</para>
        /// </summary>
        public unsafe static void glClipPlanefOES(uint plane, float* equation) {
            var _F = _GetProc<GLNativeDelegate.FNglClipPlanefOES>("glClipPlanefOES");
            _F(plane, equation);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_OES_single_precision</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glDepthRangefOES(GLclampf n, GLclampf f);</para>
        /// </summary>
        public static void glDepthRangefOES(float n, float f) {
            var _F = _GetProc<GLNativeDelegate.FNglDepthRangefOES>("glDepthRangefOES");
            _F(n, f);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_OES_single_precision</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glFrustumfOES(GLfloat l, GLfloat r, GLfloat b, GLfloat t, GLfloat n, GLfloat f);</para>
        /// </summary>
        public static void glFrustumfOES(float l, float r, float b, float t, float n, float f) {
            var _F = _GetProc<GLNativeDelegate.FNglFrustumfOES>("glFrustumfOES");
            _F(l, r, b, t, n, f);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_OES_single_precision</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glGetClipPlanefOES(GLenum plane, GLfloat * equation);</para>
        /// </summary>
        public unsafe static void glGetClipPlanefOES(uint plane, float* equation) {
            var _F = _GetProc<GLNativeDelegate.FNglGetClipPlanefOES>("glGetClipPlanefOES");
            _F(plane, equation);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_OES_single_precision</para>
        /// Supported: <para>gl, gles1</para>
        /// Original: <para>void glOrthofOES(GLfloat l, GLfloat r, GLfloat b, GLfloat t, GLfloat n, GLfloat f);</para>
        /// </summary>
        public static void glOrthofOES(float l, float r, float b, float t, float n, float f) {
            var _F = _GetProc<GLNativeDelegate.FNglOrthofOES>("glOrthofOES");
            _F(l, r, b, t, n, f);
        }

        #endregion GL_OES_single_precision

        #region GL_OVR_multiview

        /// <summary>
        /// <para>Require:</para> <para>GL_OVR_multiview</para>
        /// Supported: <para>gl, glcore, gles2</para>
        /// Original: <para>void glFramebufferTextureMultiviewOVR(GLenum target, GLenum attachment, GLuint texture, GLint level, GLint baseViewIndex, GLsizei numViews);</para>
        /// </summary>
        public static void glFramebufferTextureMultiviewOVR(uint target, uint attachment, uint texture, int level, int baseViewIndex, int numViews) {
            var _F = _GetProc<GLNativeDelegate.FNglFramebufferTextureMultiviewOVR>("glFramebufferTextureMultiviewOVR");
            _F(target, attachment, texture, level, baseViewIndex, numViews);
        }

        #endregion GL_OVR_multiview

        #region GL_PGI_misc_hints

        /// <summary>
        /// <para>Require:</para> <para>GL_PGI_misc_hints</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glHintPGI(GLenum target, GLint mode);</para>
        /// </summary>
        public static void glHintPGI(uint target, int mode) {
            var _F = _GetProc<GLNativeDelegate.FNglHintPGI>("glHintPGI");
            _F(target, mode);
        }

        #endregion GL_PGI_misc_hints

        #region GL_SGIS_detail_texture

        /// <summary>
        /// <para>Require:</para> <para>GL_SGIS_detail_texture</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glDetailTexFuncSGIS(GLenum target, GLsizei n, const GLfloat * points);</para>
        /// </summary>
        public unsafe static void glDetailTexFuncSGIS(uint target, int n, float* points) {
            var _F = _GetProc<GLNativeDelegate.FNglDetailTexFuncSGIS>("glDetailTexFuncSGIS");
            _F(target, n, points);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_SGIS_detail_texture</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetDetailTexFuncSGIS(GLenum target, GLfloat * points);</para>
        /// </summary>
        public unsafe static void glGetDetailTexFuncSGIS(uint target, float* points) {
            var _F = _GetProc<GLNativeDelegate.FNglGetDetailTexFuncSGIS>("glGetDetailTexFuncSGIS");
            _F(target, points);
        }

        #endregion GL_SGIS_detail_texture

        #region GL_SGIS_fog_function

        /// <summary>
        /// <para>Require:</para> <para>GL_SGIS_fog_function</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glFogFuncSGIS(GLsizei n, const GLfloat * points);</para>
        /// </summary>
        public unsafe static void glFogFuncSGIS(int n, float* points) {
            var _F = _GetProc<GLNativeDelegate.FNglFogFuncSGIS>("glFogFuncSGIS");
            _F(n, points);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_SGIS_fog_function</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetFogFuncSGIS(GLfloat * points);</para>
        /// </summary>
        public unsafe static void glGetFogFuncSGIS(float* points) {
            var _F = _GetProc<GLNativeDelegate.FNglGetFogFuncSGIS>("glGetFogFuncSGIS");
            _F(points);
        }

        #endregion GL_SGIS_fog_function

        #region GL_SGIS_multisample

        /// <summary>
        /// <para>Require:</para> <para>GL_SGIS_multisample</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glSampleMaskSGIS(GLclampf value, GLboolean invert);</para>
        /// </summary>
        public static void glSampleMaskSGIS(float value, bool invert) {
            var _F = _GetProc<GLNativeDelegate.FNglSampleMaskSGIS>("glSampleMaskSGIS");
            _F(value, invert);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_SGIS_multisample</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glSamplePatternSGIS(GLenum pattern);</para>
        /// </summary>
        public static void glSamplePatternSGIS(uint pattern) {
            var _F = _GetProc<GLNativeDelegate.FNglSamplePatternSGIS>("glSamplePatternSGIS");
            _F(pattern);
        }

        #endregion GL_SGIS_multisample

        #region GL_SGIS_pixel_texture

        /// <summary>
        /// <para>Require:</para> <para>GL_SGIS_pixel_texture</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glPixelTexGenParameteriSGIS(GLenum pname, GLint param);</para>
        /// </summary>
        public static void glPixelTexGenParameteriSGIS(uint pname, int param) {
            var _F = _GetProc<GLNativeDelegate.FNglPixelTexGenParameteriSGIS>("glPixelTexGenParameteriSGIS");
            _F(pname, param);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_SGIS_pixel_texture</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glPixelTexGenParameterivSGIS(GLenum pname, const GLint * params);</para>
        /// </summary>
        public unsafe static void glPixelTexGenParameterivSGIS(uint pname, int* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglPixelTexGenParameterivSGIS>("glPixelTexGenParameterivSGIS");
            _F(pname, ps);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_SGIS_pixel_texture</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glPixelTexGenParameterfSGIS(GLenum pname, GLfloat param);</para>
        /// </summary>
        public static void glPixelTexGenParameterfSGIS(uint pname, float param) {
            var _F = _GetProc<GLNativeDelegate.FNglPixelTexGenParameterfSGIS>("glPixelTexGenParameterfSGIS");
            _F(pname, param);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_SGIS_pixel_texture</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glPixelTexGenParameterfvSGIS(GLenum pname, const GLfloat * params);</para>
        /// </summary>
        public unsafe static void glPixelTexGenParameterfvSGIS(uint pname, float* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglPixelTexGenParameterfvSGIS>("glPixelTexGenParameterfvSGIS");
            _F(pname, ps);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_SGIS_pixel_texture</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetPixelTexGenParameterivSGIS(GLenum pname, GLint * params);</para>
        /// </summary>
        public unsafe static void glGetPixelTexGenParameterivSGIS(uint pname, int* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetPixelTexGenParameterivSGIS>("glGetPixelTexGenParameterivSGIS");
            _F(pname, ps);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_SGIS_pixel_texture</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetPixelTexGenParameterfvSGIS(GLenum pname, GLfloat * params);</para>
        /// </summary>
        public unsafe static void glGetPixelTexGenParameterfvSGIS(uint pname, float* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetPixelTexGenParameterfvSGIS>("glGetPixelTexGenParameterfvSGIS");
            _F(pname, ps);
        }

        #endregion GL_SGIS_pixel_texture

        #region GL_SGIS_point_parameters

        /// <summary>
        /// <para>Require:</para> <para>GL_SGIS_point_parameters</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glPointParameterfSGIS(GLenum pname, GLfloat param);</para>
        /// </summary>
        public static void glPointParameterfSGIS(uint pname, float param) {
            var _F = _GetProc<GLNativeDelegate.FNglPointParameterfSGIS>("glPointParameterfSGIS");
            _F(pname, param);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_SGIS_point_parameters</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glPointParameterfvSGIS(GLenum pname, const GLfloat * params);</para>
        /// </summary>
        public unsafe static void glPointParameterfvSGIS(uint pname, float* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglPointParameterfvSGIS>("glPointParameterfvSGIS");
            _F(pname, ps);
        }

        #endregion GL_SGIS_point_parameters

        #region GL_SGIS_sharpen_texture

        /// <summary>
        /// <para>Require:</para> <para>GL_SGIS_sharpen_texture</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glSharpenTexFuncSGIS(GLenum target, GLsizei n, const GLfloat * points);</para>
        /// </summary>
        public unsafe static void glSharpenTexFuncSGIS(uint target, int n, float* points) {
            var _F = _GetProc<GLNativeDelegate.FNglSharpenTexFuncSGIS>("glSharpenTexFuncSGIS");
            _F(target, n, points);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_SGIS_sharpen_texture</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetSharpenTexFuncSGIS(GLenum target, GLfloat * points);</para>
        /// </summary>
        public unsafe static void glGetSharpenTexFuncSGIS(uint target, float* points) {
            var _F = _GetProc<GLNativeDelegate.FNglGetSharpenTexFuncSGIS>("glGetSharpenTexFuncSGIS");
            _F(target, points);
        }

        #endregion GL_SGIS_sharpen_texture

        #region GL_SGIS_texture4D

        /// <summary>
        /// <para>Require:</para> <para>GL_SGIS_texture4D</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glTexImage4DSGIS(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLsizei size4d, GLint border, GLenum format, GLenum type, const void * pixels);</para>
        /// </summary>
        public unsafe static void glTexImage4DSGIS(uint target, int level, uint internalformat, int width, int height, int depth, int size4d, int border, uint format, uint type, void* pixels) {
            var _F = _GetProc<GLNativeDelegate.FNglTexImage4DSGIS>("glTexImage4DSGIS");
            _F(target, level, internalformat, width, height, depth, size4d, border, format, type, pixels);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_SGIS_texture4D</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glTexSubImage4DSGIS(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint woffset, GLsizei width, GLsizei height, GLsizei depth, GLsizei size4d, GLenum format, GLenum type, const void * pixels);</para>
        /// </summary>
        public unsafe static void glTexSubImage4DSGIS(uint target, int level, int xoffset, int yoffset, int zoffset, int woffset, int width, int height, int depth, int size4d, uint format, uint type, void* pixels) {
            var _F = _GetProc<GLNativeDelegate.FNglTexSubImage4DSGIS>("glTexSubImage4DSGIS");
            _F(target, level, xoffset, yoffset, zoffset, woffset, width, height, depth, size4d, format, type, pixels);
        }

        #endregion GL_SGIS_texture4D

        #region GL_SGIS_texture_color_mask

        /// <summary>
        /// <para>Require:</para> <para>GL_SGIS_texture_color_mask</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glTextureColorMaskSGIS(GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha);</para>
        /// </summary>
        public static void glTextureColorMaskSGIS(bool red, bool green, bool blue, bool alpha) {
            var _F = _GetProc<GLNativeDelegate.FNglTextureColorMaskSGIS>("glTextureColorMaskSGIS");
            _F(red, green, blue, alpha);
        }

        #endregion GL_SGIS_texture_color_mask

        #region GL_SGIS_texture_filter4

        /// <summary>
        /// <para>Require:</para> <para>GL_SGIS_texture_filter4</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetTexFilterFuncSGIS(GLenum target, GLenum filter, GLfloat * weights);</para>
        /// </summary>
        public unsafe static void glGetTexFilterFuncSGIS(uint target, uint filter, float* weights) {
            var _F = _GetProc<GLNativeDelegate.FNglGetTexFilterFuncSGIS>("glGetTexFilterFuncSGIS");
            _F(target, filter, weights);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_SGIS_texture_filter4</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glTexFilterFuncSGIS(GLenum target, GLenum filter, GLsizei n, const GLfloat * weights);</para>
        /// </summary>
        public unsafe static void glTexFilterFuncSGIS(uint target, uint filter, int n, float* weights) {
            var _F = _GetProc<GLNativeDelegate.FNglTexFilterFuncSGIS>("glTexFilterFuncSGIS");
            _F(target, filter, n, weights);
        }

        #endregion GL_SGIS_texture_filter4

        #region GL_SGIX_async

        /// <summary>
        /// <para>Require:</para> <para>GL_SGIX_async</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glAsyncMarkerSGIX(GLuint marker);</para>
        /// </summary>
        public static void glAsyncMarkerSGIX(uint marker) {
            var _F = _GetProc<GLNativeDelegate.FNglAsyncMarkerSGIX>("glAsyncMarkerSGIX");
            _F(marker);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_SGIX_async</para>
        /// Supported: <para>gl</para>
        /// Original: <para>GLint glFinishAsyncSGIX(GLuint * markerp);</para>
        /// </summary>
        public unsafe static int glFinishAsyncSGIX(uint* markerp) {
            var _F = _GetProc<GLNativeDelegate.FNglFinishAsyncSGIX>("glFinishAsyncSGIX");
            return _F(markerp);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_SGIX_async</para>
        /// Supported: <para>gl</para>
        /// Original: <para>GLint glPollAsyncSGIX(GLuint * markerp);</para>
        /// </summary>
        public unsafe static int glPollAsyncSGIX(uint* markerp) {
            var _F = _GetProc<GLNativeDelegate.FNglPollAsyncSGIX>("glPollAsyncSGIX");
            return _F(markerp);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_SGIX_async</para>
        /// Supported: <para>gl</para>
        /// Original: <para>GLuint glGenAsyncMarkersSGIX(GLsizei range);</para>
        /// </summary>
        public static uint glGenAsyncMarkersSGIX(int range) {
            var _F = _GetProc<GLNativeDelegate.FNglGenAsyncMarkersSGIX>("glGenAsyncMarkersSGIX");
            return _F(range);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_SGIX_async</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glDeleteAsyncMarkersSGIX(GLuint marker, GLsizei range);</para>
        /// </summary>
        public static void glDeleteAsyncMarkersSGIX(uint marker, int range) {
            var _F = _GetProc<GLNativeDelegate.FNglDeleteAsyncMarkersSGIX>("glDeleteAsyncMarkersSGIX");
            _F(marker, range);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_SGIX_async</para>
        /// Supported: <para>gl</para>
        /// Original: <para>GLboolean glIsAsyncMarkerSGIX(GLuint marker);</para>
        /// </summary>
        public static bool glIsAsyncMarkerSGIX(uint marker) {
            var _F = _GetProc<GLNativeDelegate.FNglIsAsyncMarkerSGIX>("glIsAsyncMarkerSGIX");
            return _F(marker);
        }

        #endregion GL_SGIX_async

        #region GL_SGIX_flush_raster

        /// <summary>
        /// <para>Require:</para> <para>GL_SGIX_flush_raster</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glFlushRasterSGIX();</para>
        /// </summary>
        public static void glFlushRasterSGIX() {
            var _F = _GetProc<GLNativeDelegate.FNglFlushRasterSGIX>("glFlushRasterSGIX");
            _F();
        }

        #endregion GL_SGIX_flush_raster

        #region GL_SGIX_fragment_lighting

        /// <summary>
        /// <para>Require:</para> <para>GL_SGIX_fragment_lighting</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glFragmentColorMaterialSGIX(GLenum face, GLenum mode);</para>
        /// </summary>
        public static void glFragmentColorMaterialSGIX(uint face, uint mode) {
            var _F = _GetProc<GLNativeDelegate.FNglFragmentColorMaterialSGIX>("glFragmentColorMaterialSGIX");
            _F(face, mode);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_SGIX_fragment_lighting</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glFragmentLightfSGIX(GLenum light, GLenum pname, GLfloat param);</para>
        /// </summary>
        public static void glFragmentLightfSGIX(uint light, uint pname, float param) {
            var _F = _GetProc<GLNativeDelegate.FNglFragmentLightfSGIX>("glFragmentLightfSGIX");
            _F(light, pname, param);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_SGIX_fragment_lighting</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glFragmentLightfvSGIX(GLenum light, GLenum pname, const GLfloat * params);</para>
        /// </summary>
        public unsafe static void glFragmentLightfvSGIX(uint light, uint pname, float* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglFragmentLightfvSGIX>("glFragmentLightfvSGIX");
            _F(light, pname, ps);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_SGIX_fragment_lighting</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glFragmentLightiSGIX(GLenum light, GLenum pname, GLint param);</para>
        /// </summary>
        public static void glFragmentLightiSGIX(uint light, uint pname, int param) {
            var _F = _GetProc<GLNativeDelegate.FNglFragmentLightiSGIX>("glFragmentLightiSGIX");
            _F(light, pname, param);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_SGIX_fragment_lighting</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glFragmentLightivSGIX(GLenum light, GLenum pname, const GLint * params);</para>
        /// </summary>
        public unsafe static void glFragmentLightivSGIX(uint light, uint pname, int* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglFragmentLightivSGIX>("glFragmentLightivSGIX");
            _F(light, pname, ps);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_SGIX_fragment_lighting</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glFragmentLightModelfSGIX(GLenum pname, GLfloat param);</para>
        /// </summary>
        public static void glFragmentLightModelfSGIX(uint pname, float param) {
            var _F = _GetProc<GLNativeDelegate.FNglFragmentLightModelfSGIX>("glFragmentLightModelfSGIX");
            _F(pname, param);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_SGIX_fragment_lighting</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glFragmentLightModelfvSGIX(GLenum pname, const GLfloat * params);</para>
        /// </summary>
        public unsafe static void glFragmentLightModelfvSGIX(uint pname, float* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglFragmentLightModelfvSGIX>("glFragmentLightModelfvSGIX");
            _F(pname, ps);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_SGIX_fragment_lighting</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glFragmentLightModeliSGIX(GLenum pname, GLint param);</para>
        /// </summary>
        public static void glFragmentLightModeliSGIX(uint pname, int param) {
            var _F = _GetProc<GLNativeDelegate.FNglFragmentLightModeliSGIX>("glFragmentLightModeliSGIX");
            _F(pname, param);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_SGIX_fragment_lighting</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glFragmentLightModelivSGIX(GLenum pname, const GLint * params);</para>
        /// </summary>
        public unsafe static void glFragmentLightModelivSGIX(uint pname, int* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglFragmentLightModelivSGIX>("glFragmentLightModelivSGIX");
            _F(pname, ps);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_SGIX_fragment_lighting</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glFragmentMaterialfSGIX(GLenum face, GLenum pname, GLfloat param);</para>
        /// </summary>
        public static void glFragmentMaterialfSGIX(uint face, uint pname, float param) {
            var _F = _GetProc<GLNativeDelegate.FNglFragmentMaterialfSGIX>("glFragmentMaterialfSGIX");
            _F(face, pname, param);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_SGIX_fragment_lighting</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glFragmentMaterialfvSGIX(GLenum face, GLenum pname, const GLfloat * params);</para>
        /// </summary>
        public unsafe static void glFragmentMaterialfvSGIX(uint face, uint pname, float* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglFragmentMaterialfvSGIX>("glFragmentMaterialfvSGIX");
            _F(face, pname, ps);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_SGIX_fragment_lighting</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glFragmentMaterialiSGIX(GLenum face, GLenum pname, GLint param);</para>
        /// </summary>
        public static void glFragmentMaterialiSGIX(uint face, uint pname, int param) {
            var _F = _GetProc<GLNativeDelegate.FNglFragmentMaterialiSGIX>("glFragmentMaterialiSGIX");
            _F(face, pname, param);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_SGIX_fragment_lighting</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glFragmentMaterialivSGIX(GLenum face, GLenum pname, const GLint * params);</para>
        /// </summary>
        public unsafe static void glFragmentMaterialivSGIX(uint face, uint pname, int* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglFragmentMaterialivSGIX>("glFragmentMaterialivSGIX");
            _F(face, pname, ps);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_SGIX_fragment_lighting</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetFragmentLightfvSGIX(GLenum light, GLenum pname, GLfloat * params);</para>
        /// </summary>
        public unsafe static void glGetFragmentLightfvSGIX(uint light, uint pname, float* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetFragmentLightfvSGIX>("glGetFragmentLightfvSGIX");
            _F(light, pname, ps);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_SGIX_fragment_lighting</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetFragmentLightivSGIX(GLenum light, GLenum pname, GLint * params);</para>
        /// </summary>
        public unsafe static void glGetFragmentLightivSGIX(uint light, uint pname, int* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetFragmentLightivSGIX>("glGetFragmentLightivSGIX");
            _F(light, pname, ps);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_SGIX_fragment_lighting</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetFragmentMaterialfvSGIX(GLenum face, GLenum pname, GLfloat * params);</para>
        /// </summary>
        public unsafe static void glGetFragmentMaterialfvSGIX(uint face, uint pname, float* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetFragmentMaterialfvSGIX>("glGetFragmentMaterialfvSGIX");
            _F(face, pname, ps);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_SGIX_fragment_lighting</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetFragmentMaterialivSGIX(GLenum face, GLenum pname, GLint * params);</para>
        /// </summary>
        public unsafe static void glGetFragmentMaterialivSGIX(uint face, uint pname, int* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetFragmentMaterialivSGIX>("glGetFragmentMaterialivSGIX");
            _F(face, pname, ps);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_SGIX_fragment_lighting</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glLightEnviSGIX(GLenum pname, GLint param);</para>
        /// </summary>
        public static void glLightEnviSGIX(uint pname, int param) {
            var _F = _GetProc<GLNativeDelegate.FNglLightEnviSGIX>("glLightEnviSGIX");
            _F(pname, param);
        }

        #endregion GL_SGIX_fragment_lighting

        #region GL_SGIX_framezoom

        /// <summary>
        /// <para>Require:</para> <para>GL_SGIX_framezoom</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glFrameZoomSGIX(GLint factor);</para>
        /// </summary>
        public static void glFrameZoomSGIX(int factor) {
            var _F = _GetProc<GLNativeDelegate.FNglFrameZoomSGIX>("glFrameZoomSGIX");
            _F(factor);
        }

        #endregion GL_SGIX_framezoom

        #region GL_SGIX_igloo_interface

        /// <summary>
        /// <para>Require:</para> <para>GL_SGIX_igloo_interface</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glIglooInterfaceSGIX(GLenum pname, const void * params);</para>
        /// </summary>
        public unsafe static void glIglooInterfaceSGIX(uint pname, void* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglIglooInterfaceSGIX>("glIglooInterfaceSGIX");
            _F(pname, ps);
        }

        #endregion GL_SGIX_igloo_interface

        #region GL_SGIX_instruments

        /// <summary>
        /// <para>Require:</para> <para>GL_SGIX_instruments</para>
        /// Supported: <para>gl</para>
        /// Original: <para>GLint glGetInstrumentsSGIX();</para>
        /// </summary>
        public static int glGetInstrumentsSGIX() {
            var _F = _GetProc<GLNativeDelegate.FNglGetInstrumentsSGIX>("glGetInstrumentsSGIX");
            return _F();
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_SGIX_instruments</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glInstrumentsBufferSGIX(GLsizei size, GLint * buffer);</para>
        /// </summary>
        public unsafe static void glInstrumentsBufferSGIX(int size, int* buffer) {
            var _F = _GetProc<GLNativeDelegate.FNglInstrumentsBufferSGIX>("glInstrumentsBufferSGIX");
            _F(size, buffer);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_SGIX_instruments</para>
        /// Supported: <para>gl</para>
        /// Original: <para>GLint glPollInstrumentsSGIX(GLint * marker_p);</para>
        /// </summary>
        public unsafe static int glPollInstrumentsSGIX(int* marker_p) {
            var _F = _GetProc<GLNativeDelegate.FNglPollInstrumentsSGIX>("glPollInstrumentsSGIX");
            return _F(marker_p);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_SGIX_instruments</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glReadInstrumentsSGIX(GLint marker);</para>
        /// </summary>
        public static void glReadInstrumentsSGIX(int marker) {
            var _F = _GetProc<GLNativeDelegate.FNglReadInstrumentsSGIX>("glReadInstrumentsSGIX");
            _F(marker);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_SGIX_instruments</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glStartInstrumentsSGIX();</para>
        /// </summary>
        public static void glStartInstrumentsSGIX() {
            var _F = _GetProc<GLNativeDelegate.FNglStartInstrumentsSGIX>("glStartInstrumentsSGIX");
            _F();
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_SGIX_instruments</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glStopInstrumentsSGIX(GLint marker);</para>
        /// </summary>
        public static void glStopInstrumentsSGIX(int marker) {
            var _F = _GetProc<GLNativeDelegate.FNglStopInstrumentsSGIX>("glStopInstrumentsSGIX");
            _F(marker);
        }

        #endregion GL_SGIX_instruments

        #region GL_SGIX_list_priority

        /// <summary>
        /// <para>Require:</para> <para>GL_SGIX_list_priority</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetListParameterfvSGIX(GLuint list, GLenum pname, GLfloat * params);</para>
        /// </summary>
        public unsafe static void glGetListParameterfvSGIX(uint list, uint pname, float* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetListParameterfvSGIX>("glGetListParameterfvSGIX");
            _F(list, pname, ps);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_SGIX_list_priority</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetListParameterivSGIX(GLuint list, GLenum pname, GLint * params);</para>
        /// </summary>
        public unsafe static void glGetListParameterivSGIX(uint list, uint pname, int* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetListParameterivSGIX>("glGetListParameterivSGIX");
            _F(list, pname, ps);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_SGIX_list_priority</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glListParameterfSGIX(GLuint list, GLenum pname, GLfloat param);</para>
        /// </summary>
        public static void glListParameterfSGIX(uint list, uint pname, float param) {
            var _F = _GetProc<GLNativeDelegate.FNglListParameterfSGIX>("glListParameterfSGIX");
            _F(list, pname, param);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_SGIX_list_priority</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glListParameterfvSGIX(GLuint list, GLenum pname, const GLfloat * params);</para>
        /// </summary>
        public unsafe static void glListParameterfvSGIX(uint list, uint pname, float* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglListParameterfvSGIX>("glListParameterfvSGIX");
            _F(list, pname, ps);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_SGIX_list_priority</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glListParameteriSGIX(GLuint list, GLenum pname, GLint param);</para>
        /// </summary>
        public static void glListParameteriSGIX(uint list, uint pname, int param) {
            var _F = _GetProc<GLNativeDelegate.FNglListParameteriSGIX>("glListParameteriSGIX");
            _F(list, pname, param);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_SGIX_list_priority</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glListParameterivSGIX(GLuint list, GLenum pname, const GLint * params);</para>
        /// </summary>
        public unsafe static void glListParameterivSGIX(uint list, uint pname, int* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglListParameterivSGIX>("glListParameterivSGIX");
            _F(list, pname, ps);
        }

        #endregion GL_SGIX_list_priority

        #region GL_SGIX_pixel_texture

        /// <summary>
        /// <para>Require:</para> <para>GL_SGIX_pixel_texture</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glPixelTexGenSGIX(GLenum mode);</para>
        /// </summary>
        public static void glPixelTexGenSGIX(uint mode) {
            var _F = _GetProc<GLNativeDelegate.FNglPixelTexGenSGIX>("glPixelTexGenSGIX");
            _F(mode);
        }

        #endregion GL_SGIX_pixel_texture

        #region GL_SGIX_polynomial_ffd

        /// <summary>
        /// <para>Require:</para> <para>GL_SGIX_polynomial_ffd</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glDeformationMap3dSGIX(GLenum target, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, GLdouble w1, GLdouble w2, GLint wstride, GLint worder, const GLdouble * points);</para>
        /// </summary>
        public unsafe static void glDeformationMap3dSGIX(uint target, double u1, double u2, int ustride, int uorder, double v1, double v2, int vstride, int vorder, double w1, double w2, int wstride, int worder, double* points) {
            var _F = _GetProc<GLNativeDelegate.FNglDeformationMap3dSGIX>("glDeformationMap3dSGIX");
            _F(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, w1, w2, wstride, worder, points);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_SGIX_polynomial_ffd</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glDeformationMap3fSGIX(GLenum target, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, GLfloat w1, GLfloat w2, GLint wstride, GLint worder, const GLfloat * points);</para>
        /// </summary>
        public unsafe static void glDeformationMap3fSGIX(uint target, float u1, float u2, int ustride, int uorder, float v1, float v2, int vstride, int vorder, float w1, float w2, int wstride, int worder, float* points) {
            var _F = _GetProc<GLNativeDelegate.FNglDeformationMap3fSGIX>("glDeformationMap3fSGIX");
            _F(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, w1, w2, wstride, worder, points);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_SGIX_polynomial_ffd</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glDeformSGIX(GLbitfield mask);</para>
        /// </summary>
        public static void glDeformSGIX(uint mask) {
            var _F = _GetProc<GLNativeDelegate.FNglDeformSGIX>("glDeformSGIX");
            _F(mask);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_SGIX_polynomial_ffd</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glLoadIdentityDeformationMapSGIX(GLbitfield mask);</para>
        /// </summary>
        public static void glLoadIdentityDeformationMapSGIX(uint mask) {
            var _F = _GetProc<GLNativeDelegate.FNglLoadIdentityDeformationMapSGIX>("glLoadIdentityDeformationMapSGIX");
            _F(mask);
        }

        #endregion GL_SGIX_polynomial_ffd

        #region GL_SGIX_reference_plane

        /// <summary>
        /// <para>Require:</para> <para>GL_SGIX_reference_plane</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glReferencePlaneSGIX(const GLdouble * equation);</para>
        /// </summary>
        public unsafe static void glReferencePlaneSGIX(double* equation) {
            var _F = _GetProc<GLNativeDelegate.FNglReferencePlaneSGIX>("glReferencePlaneSGIX");
            _F(equation);
        }

        #endregion GL_SGIX_reference_plane

        #region GL_SGIX_sprite

        /// <summary>
        /// <para>Require:</para> <para>GL_SGIX_sprite</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glSpriteParameterfSGIX(GLenum pname, GLfloat param);</para>
        /// </summary>
        public static void glSpriteParameterfSGIX(uint pname, float param) {
            var _F = _GetProc<GLNativeDelegate.FNglSpriteParameterfSGIX>("glSpriteParameterfSGIX");
            _F(pname, param);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_SGIX_sprite</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glSpriteParameterfvSGIX(GLenum pname, const GLfloat * params);</para>
        /// </summary>
        public unsafe static void glSpriteParameterfvSGIX(uint pname, float* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglSpriteParameterfvSGIX>("glSpriteParameterfvSGIX");
            _F(pname, ps);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_SGIX_sprite</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glSpriteParameteriSGIX(GLenum pname, GLint param);</para>
        /// </summary>
        public static void glSpriteParameteriSGIX(uint pname, int param) {
            var _F = _GetProc<GLNativeDelegate.FNglSpriteParameteriSGIX>("glSpriteParameteriSGIX");
            _F(pname, param);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_SGIX_sprite</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glSpriteParameterivSGIX(GLenum pname, const GLint * params);</para>
        /// </summary>
        public unsafe static void glSpriteParameterivSGIX(uint pname, int* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglSpriteParameterivSGIX>("glSpriteParameterivSGIX");
            _F(pname, ps);
        }

        #endregion GL_SGIX_sprite

        #region GL_SGIX_tag_sample_buffer

        /// <summary>
        /// <para>Require:</para> <para>GL_SGIX_tag_sample_buffer</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glTagSampleBufferSGIX();</para>
        /// </summary>
        public static void glTagSampleBufferSGIX() {
            var _F = _GetProc<GLNativeDelegate.FNglTagSampleBufferSGIX>("glTagSampleBufferSGIX");
            _F();
        }

        #endregion GL_SGIX_tag_sample_buffer

        #region GL_SGI_color_table

        /// <summary>
        /// <para>Require:</para> <para>GL_SGI_color_table</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glColorTableSGI(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const void * table);</para>
        /// </summary>
        public unsafe static void glColorTableSGI(uint target, uint internalformat, int width, uint format, uint type, void* table) {
            var _F = _GetProc<GLNativeDelegate.FNglColorTableSGI>("glColorTableSGI");
            _F(target, internalformat, width, format, type, table);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_SGI_color_table</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glColorTableParameterfvSGI(GLenum target, GLenum pname, const GLfloat * params);</para>
        /// </summary>
        public unsafe static void glColorTableParameterfvSGI(uint target, uint pname, float* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglColorTableParameterfvSGI>("glColorTableParameterfvSGI");
            _F(target, pname, ps);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_SGI_color_table</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glColorTableParameterivSGI(GLenum target, GLenum pname, const GLint * params);</para>
        /// </summary>
        public unsafe static void glColorTableParameterivSGI(uint target, uint pname, int* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglColorTableParameterivSGI>("glColorTableParameterivSGI");
            _F(target, pname, ps);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_SGI_color_table</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glCopyColorTableSGI(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width);</para>
        /// </summary>
        public static void glCopyColorTableSGI(uint target, uint internalformat, int x, int y, int width) {
            var _F = _GetProc<GLNativeDelegate.FNglCopyColorTableSGI>("glCopyColorTableSGI");
            _F(target, internalformat, x, y, width);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_SGI_color_table</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetColorTableSGI(GLenum target, GLenum format, GLenum type, void * table);</para>
        /// </summary>
        public unsafe static void glGetColorTableSGI(uint target, uint format, uint type, void* table) {
            var _F = _GetProc<GLNativeDelegate.FNglGetColorTableSGI>("glGetColorTableSGI");
            _F(target, format, type, table);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_SGI_color_table</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetColorTableParameterfvSGI(GLenum target, GLenum pname, GLfloat * params);</para>
        /// </summary>
        public unsafe static void glGetColorTableParameterfvSGI(uint target, uint pname, float* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetColorTableParameterfvSGI>("glGetColorTableParameterfvSGI");
            _F(target, pname, ps);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_SGI_color_table</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGetColorTableParameterivSGI(GLenum target, GLenum pname, GLint * params);</para>
        /// </summary>
        public unsafe static void glGetColorTableParameterivSGI(uint target, uint pname, int* ps) {
            var _F = _GetProc<GLNativeDelegate.FNglGetColorTableParameterivSGI>("glGetColorTableParameterivSGI");
            _F(target, pname, ps);
        }

        #endregion GL_SGI_color_table

        #region GL_SUNX_constant_data

        /// <summary>
        /// <para>Require:</para> <para>GL_SUNX_constant_data</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glFinishTextureSUNX();</para>
        /// </summary>
        public static void glFinishTextureSUNX() {
            var _F = _GetProc<GLNativeDelegate.FNglFinishTextureSUNX>("glFinishTextureSUNX");
            _F();
        }

        #endregion GL_SUNX_constant_data

        #region GL_SUN_global_alpha

        /// <summary>
        /// <para>Require:</para> <para>GL_SUN_global_alpha</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGlobalAlphaFactorbSUN(GLbyte factor);</para>
        /// </summary>
        public static void glGlobalAlphaFactorbSUN(byte factor) {
            var _F = _GetProc<GLNativeDelegate.FNglGlobalAlphaFactorbSUN>("glGlobalAlphaFactorbSUN");
            _F(factor);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_SUN_global_alpha</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGlobalAlphaFactorsSUN(GLshort factor);</para>
        /// </summary>
        public static void glGlobalAlphaFactorsSUN(short factor) {
            var _F = _GetProc<GLNativeDelegate.FNglGlobalAlphaFactorsSUN>("glGlobalAlphaFactorsSUN");
            _F(factor);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_SUN_global_alpha</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGlobalAlphaFactoriSUN(GLint factor);</para>
        /// </summary>
        public static void glGlobalAlphaFactoriSUN(int factor) {
            var _F = _GetProc<GLNativeDelegate.FNglGlobalAlphaFactoriSUN>("glGlobalAlphaFactoriSUN");
            _F(factor);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_SUN_global_alpha</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGlobalAlphaFactorfSUN(GLfloat factor);</para>
        /// </summary>
        public static void glGlobalAlphaFactorfSUN(float factor) {
            var _F = _GetProc<GLNativeDelegate.FNglGlobalAlphaFactorfSUN>("glGlobalAlphaFactorfSUN");
            _F(factor);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_SUN_global_alpha</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGlobalAlphaFactordSUN(GLdouble factor);</para>
        /// </summary>
        public static void glGlobalAlphaFactordSUN(double factor) {
            var _F = _GetProc<GLNativeDelegate.FNglGlobalAlphaFactordSUN>("glGlobalAlphaFactordSUN");
            _F(factor);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_SUN_global_alpha</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGlobalAlphaFactorubSUN(GLubyte factor);</para>
        /// </summary>
        public static void glGlobalAlphaFactorubSUN(byte factor) {
            var _F = _GetProc<GLNativeDelegate.FNglGlobalAlphaFactorubSUN>("glGlobalAlphaFactorubSUN");
            _F(factor);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_SUN_global_alpha</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGlobalAlphaFactorusSUN(GLushort factor);</para>
        /// </summary>
        public static void glGlobalAlphaFactorusSUN(ushort factor) {
            var _F = _GetProc<GLNativeDelegate.FNglGlobalAlphaFactorusSUN>("glGlobalAlphaFactorusSUN");
            _F(factor);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_SUN_global_alpha</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glGlobalAlphaFactoruiSUN(GLuint factor);</para>
        /// </summary>
        public static void glGlobalAlphaFactoruiSUN(uint factor) {
            var _F = _GetProc<GLNativeDelegate.FNglGlobalAlphaFactoruiSUN>("glGlobalAlphaFactoruiSUN");
            _F(factor);
        }

        #endregion GL_SUN_global_alpha

        #region GL_SUN_mesh_array

        /// <summary>
        /// <para>Require:</para> <para>GL_SUN_mesh_array</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glDrawMeshArraysSUN(GLenum mode, GLint first, GLsizei count, GLsizei width);</para>
        /// </summary>
        public static void glDrawMeshArraysSUN(uint mode, int first, int count, int width) {
            var _F = _GetProc<GLNativeDelegate.FNglDrawMeshArraysSUN>("glDrawMeshArraysSUN");
            _F(mode, first, count, width);
        }

        #endregion GL_SUN_mesh_array

        #region GL_SUN_triangle_list

        /// <summary>
        /// <para>Require:</para> <para>GL_SUN_triangle_list</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glReplacementCodeuiSUN(GLuint code);</para>
        /// </summary>
        public static void glReplacementCodeuiSUN(uint code) {
            var _F = _GetProc<GLNativeDelegate.FNglReplacementCodeuiSUN>("glReplacementCodeuiSUN");
            _F(code);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_SUN_triangle_list</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glReplacementCodeusSUN(GLushort code);</para>
        /// </summary>
        public static void glReplacementCodeusSUN(ushort code) {
            var _F = _GetProc<GLNativeDelegate.FNglReplacementCodeusSUN>("glReplacementCodeusSUN");
            _F(code);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_SUN_triangle_list</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glReplacementCodeubSUN(GLubyte code);</para>
        /// </summary>
        public static void glReplacementCodeubSUN(byte code) {
            var _F = _GetProc<GLNativeDelegate.FNglReplacementCodeubSUN>("glReplacementCodeubSUN");
            _F(code);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_SUN_triangle_list</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glReplacementCodeuivSUN(const GLuint * code);</para>
        /// </summary>
        public unsafe static void glReplacementCodeuivSUN(uint* code) {
            var _F = _GetProc<GLNativeDelegate.FNglReplacementCodeuivSUN>("glReplacementCodeuivSUN");
            _F(code);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_SUN_triangle_list</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glReplacementCodeusvSUN(const GLushort * code);</para>
        /// </summary>
        public unsafe static void glReplacementCodeusvSUN(ushort* code) {
            var _F = _GetProc<GLNativeDelegate.FNglReplacementCodeusvSUN>("glReplacementCodeusvSUN");
            _F(code);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_SUN_triangle_list</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glReplacementCodeubvSUN(const GLubyte * code);</para>
        /// </summary>
        public unsafe static void glReplacementCodeubvSUN(byte* code) {
            var _F = _GetProc<GLNativeDelegate.FNglReplacementCodeubvSUN>("glReplacementCodeubvSUN");
            _F(code);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_SUN_triangle_list</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glReplacementCodePointerSUN(GLenum type, GLsizei stride, const void ** pointer);</para>
        /// </summary>
        public unsafe static void glReplacementCodePointerSUN(uint type, int stride, void** pointer) {
            var _F = _GetProc<GLNativeDelegate.FNglReplacementCodePointerSUN>("glReplacementCodePointerSUN");
            _F(type, stride, pointer);
        }

        #endregion GL_SUN_triangle_list

        #region GL_SUN_vertex

        /// <summary>
        /// <para>Require:</para> <para>GL_SUN_vertex</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glColor4ubVertex2fSUN(GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y);</para>
        /// </summary>
        public static void glColor4ubVertex2fSUN(byte r, byte g, byte b, byte a, float x, float y) {
            var _F = _GetProc<GLNativeDelegate.FNglColor4ubVertex2fSUN>("glColor4ubVertex2fSUN");
            _F(r, g, b, a, x, y);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_SUN_vertex</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glColor4ubVertex2fvSUN(const GLubyte * c, const GLfloat * v);</para>
        /// </summary>
        public unsafe static void glColor4ubVertex2fvSUN(byte* c, float* v) {
            var _F = _GetProc<GLNativeDelegate.FNglColor4ubVertex2fvSUN>("glColor4ubVertex2fvSUN");
            _F(c, v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_SUN_vertex</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glColor4ubVertex3fSUN(GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y, GLfloat z);</para>
        /// </summary>
        public static void glColor4ubVertex3fSUN(byte r, byte g, byte b, byte a, float x, float y, float z) {
            var _F = _GetProc<GLNativeDelegate.FNglColor4ubVertex3fSUN>("glColor4ubVertex3fSUN");
            _F(r, g, b, a, x, y, z);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_SUN_vertex</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glColor4ubVertex3fvSUN(const GLubyte * c, const GLfloat * v);</para>
        /// </summary>
        public unsafe static void glColor4ubVertex3fvSUN(byte* c, float* v) {
            var _F = _GetProc<GLNativeDelegate.FNglColor4ubVertex3fvSUN>("glColor4ubVertex3fvSUN");
            _F(c, v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_SUN_vertex</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glColor3fVertex3fSUN(GLfloat r, GLfloat g, GLfloat b, GLfloat x, GLfloat y, GLfloat z);</para>
        /// </summary>
        public static void glColor3fVertex3fSUN(float r, float g, float b, float x, float y, float z) {
            var _F = _GetProc<GLNativeDelegate.FNglColor3fVertex3fSUN>("glColor3fVertex3fSUN");
            _F(r, g, b, x, y, z);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_SUN_vertex</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glColor3fVertex3fvSUN(const GLfloat * c, const GLfloat * v);</para>
        /// </summary>
        public unsafe static void glColor3fVertex3fvSUN(float* c, float* v) {
            var _F = _GetProc<GLNativeDelegate.FNglColor3fVertex3fvSUN>("glColor3fVertex3fvSUN");
            _F(c, v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_SUN_vertex</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glNormal3fVertex3fSUN(GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z);</para>
        /// </summary>
        public static void glNormal3fVertex3fSUN(float nx, float ny, float nz, float x, float y, float z) {
            var _F = _GetProc<GLNativeDelegate.FNglNormal3fVertex3fSUN>("glNormal3fVertex3fSUN");
            _F(nx, ny, nz, x, y, z);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_SUN_vertex</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glNormal3fVertex3fvSUN(const GLfloat * n, const GLfloat * v);</para>
        /// </summary>
        public unsafe static void glNormal3fVertex3fvSUN(float* n, float* v) {
            var _F = _GetProc<GLNativeDelegate.FNglNormal3fVertex3fvSUN>("glNormal3fVertex3fvSUN");
            _F(n, v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_SUN_vertex</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glColor4fNormal3fVertex3fSUN(GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z);</para>
        /// </summary>
        public static void glColor4fNormal3fVertex3fSUN(float r, float g, float b, float a, float nx, float ny, float nz, float x, float y, float z) {
            var _F = _GetProc<GLNativeDelegate.FNglColor4fNormal3fVertex3fSUN>("glColor4fNormal3fVertex3fSUN");
            _F(r, g, b, a, nx, ny, nz, x, y, z);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_SUN_vertex</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glColor4fNormal3fVertex3fvSUN(const GLfloat * c, const GLfloat * n, const GLfloat * v);</para>
        /// </summary>
        public unsafe static void glColor4fNormal3fVertex3fvSUN(float* c, float* n, float* v) {
            var _F = _GetProc<GLNativeDelegate.FNglColor4fNormal3fVertex3fvSUN>("glColor4fNormal3fVertex3fvSUN");
            _F(c, n, v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_SUN_vertex</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glTexCoord2fVertex3fSUN(GLfloat s, GLfloat t, GLfloat x, GLfloat y, GLfloat z);</para>
        /// </summary>
        public static void glTexCoord2fVertex3fSUN(float s, float t, float x, float y, float z) {
            var _F = _GetProc<GLNativeDelegate.FNglTexCoord2fVertex3fSUN>("glTexCoord2fVertex3fSUN");
            _F(s, t, x, y, z);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_SUN_vertex</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glTexCoord2fVertex3fvSUN(const GLfloat * tc, const GLfloat * v);</para>
        /// </summary>
        public unsafe static void glTexCoord2fVertex3fvSUN(float* tc, float* v) {
            var _F = _GetProc<GLNativeDelegate.FNglTexCoord2fVertex3fvSUN>("glTexCoord2fVertex3fvSUN");
            _F(tc, v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_SUN_vertex</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glTexCoord4fVertex4fSUN(GLfloat s, GLfloat t, GLfloat p, GLfloat q, GLfloat x, GLfloat y, GLfloat z, GLfloat w);</para>
        /// </summary>
        public static void glTexCoord4fVertex4fSUN(float s, float t, float p, float q, float x, float y, float z, float w) {
            var _F = _GetProc<GLNativeDelegate.FNglTexCoord4fVertex4fSUN>("glTexCoord4fVertex4fSUN");
            _F(s, t, p, q, x, y, z, w);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_SUN_vertex</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glTexCoord4fVertex4fvSUN(const GLfloat * tc, const GLfloat * v);</para>
        /// </summary>
        public unsafe static void glTexCoord4fVertex4fvSUN(float* tc, float* v) {
            var _F = _GetProc<GLNativeDelegate.FNglTexCoord4fVertex4fvSUN>("glTexCoord4fVertex4fvSUN");
            _F(tc, v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_SUN_vertex</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glTexCoord2fColor4ubVertex3fSUN(GLfloat s, GLfloat t, GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y, GLfloat z);</para>
        /// </summary>
        public static void glTexCoord2fColor4ubVertex3fSUN(float s, float t, byte r, byte g, byte b, byte a, float x, float y, float z) {
            var _F = _GetProc<GLNativeDelegate.FNglTexCoord2fColor4ubVertex3fSUN>("glTexCoord2fColor4ubVertex3fSUN");
            _F(s, t, r, g, b, a, x, y, z);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_SUN_vertex</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glTexCoord2fColor4ubVertex3fvSUN(const GLfloat * tc, const GLubyte * c, const GLfloat * v);</para>
        /// </summary>
        public unsafe static void glTexCoord2fColor4ubVertex3fvSUN(float* tc, byte* c, float* v) {
            var _F = _GetProc<GLNativeDelegate.FNglTexCoord2fColor4ubVertex3fvSUN>("glTexCoord2fColor4ubVertex3fvSUN");
            _F(tc, c, v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_SUN_vertex</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glTexCoord2fColor3fVertex3fSUN(GLfloat s, GLfloat t, GLfloat r, GLfloat g, GLfloat b, GLfloat x, GLfloat y, GLfloat z);</para>
        /// </summary>
        public static void glTexCoord2fColor3fVertex3fSUN(float s, float t, float r, float g, float b, float x, float y, float z) {
            var _F = _GetProc<GLNativeDelegate.FNglTexCoord2fColor3fVertex3fSUN>("glTexCoord2fColor3fVertex3fSUN");
            _F(s, t, r, g, b, x, y, z);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_SUN_vertex</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glTexCoord2fColor3fVertex3fvSUN(const GLfloat * tc, const GLfloat * c, const GLfloat * v);</para>
        /// </summary>
        public unsafe static void glTexCoord2fColor3fVertex3fvSUN(float* tc, float* c, float* v) {
            var _F = _GetProc<GLNativeDelegate.FNglTexCoord2fColor3fVertex3fvSUN>("glTexCoord2fColor3fVertex3fvSUN");
            _F(tc, c, v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_SUN_vertex</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glTexCoord2fNormal3fVertex3fSUN(GLfloat s, GLfloat t, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z);</para>
        /// </summary>
        public static void glTexCoord2fNormal3fVertex3fSUN(float s, float t, float nx, float ny, float nz, float x, float y, float z) {
            var _F = _GetProc<GLNativeDelegate.FNglTexCoord2fNormal3fVertex3fSUN>("glTexCoord2fNormal3fVertex3fSUN");
            _F(s, t, nx, ny, nz, x, y, z);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_SUN_vertex</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glTexCoord2fNormal3fVertex3fvSUN(const GLfloat * tc, const GLfloat * n, const GLfloat * v);</para>
        /// </summary>
        public unsafe static void glTexCoord2fNormal3fVertex3fvSUN(float* tc, float* n, float* v) {
            var _F = _GetProc<GLNativeDelegate.FNglTexCoord2fNormal3fVertex3fvSUN>("glTexCoord2fNormal3fVertex3fvSUN");
            _F(tc, n, v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_SUN_vertex</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glTexCoord2fColor4fNormal3fVertex3fSUN(GLfloat s, GLfloat t, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z);</para>
        /// </summary>
        public static void glTexCoord2fColor4fNormal3fVertex3fSUN(float s, float t, float r, float g, float b, float a, float nx, float ny, float nz, float x, float y, float z) {
            var _F = _GetProc<GLNativeDelegate.FNglTexCoord2fColor4fNormal3fVertex3fSUN>("glTexCoord2fColor4fNormal3fVertex3fSUN");
            _F(s, t, r, g, b, a, nx, ny, nz, x, y, z);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_SUN_vertex</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glTexCoord2fColor4fNormal3fVertex3fvSUN(const GLfloat * tc, const GLfloat * c, const GLfloat * n, const GLfloat * v);</para>
        /// </summary>
        public unsafe static void glTexCoord2fColor4fNormal3fVertex3fvSUN(float* tc, float* c, float* n, float* v) {
            var _F = _GetProc<GLNativeDelegate.FNglTexCoord2fColor4fNormal3fVertex3fvSUN>("glTexCoord2fColor4fNormal3fVertex3fvSUN");
            _F(tc, c, n, v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_SUN_vertex</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glTexCoord4fColor4fNormal3fVertex4fSUN(GLfloat s, GLfloat t, GLfloat p, GLfloat q, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z, GLfloat w);</para>
        /// </summary>
        public static void glTexCoord4fColor4fNormal3fVertex4fSUN(float s, float t, float p, float q, float r, float g, float b, float a, float nx, float ny, float nz, float x, float y, float z, float w) {
            var _F = _GetProc<GLNativeDelegate.FNglTexCoord4fColor4fNormal3fVertex4fSUN>("glTexCoord4fColor4fNormal3fVertex4fSUN");
            _F(s, t, p, q, r, g, b, a, nx, ny, nz, x, y, z, w);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_SUN_vertex</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glTexCoord4fColor4fNormal3fVertex4fvSUN(const GLfloat * tc, const GLfloat * c, const GLfloat * n, const GLfloat * v);</para>
        /// </summary>
        public unsafe static void glTexCoord4fColor4fNormal3fVertex4fvSUN(float* tc, float* c, float* n, float* v) {
            var _F = _GetProc<GLNativeDelegate.FNglTexCoord4fColor4fNormal3fVertex4fvSUN>("glTexCoord4fColor4fNormal3fVertex4fvSUN");
            _F(tc, c, n, v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_SUN_vertex</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glReplacementCodeuiVertex3fSUN(GLuint rc, GLfloat x, GLfloat y, GLfloat z);</para>
        /// </summary>
        public static void glReplacementCodeuiVertex3fSUN(uint rc, float x, float y, float z) {
            var _F = _GetProc<GLNativeDelegate.FNglReplacementCodeuiVertex3fSUN>("glReplacementCodeuiVertex3fSUN");
            _F(rc, x, y, z);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_SUN_vertex</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glReplacementCodeuiVertex3fvSUN(const GLuint * rc, const GLfloat * v);</para>
        /// </summary>
        public unsafe static void glReplacementCodeuiVertex3fvSUN(uint* rc, float* v) {
            var _F = _GetProc<GLNativeDelegate.FNglReplacementCodeuiVertex3fvSUN>("glReplacementCodeuiVertex3fvSUN");
            _F(rc, v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_SUN_vertex</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glReplacementCodeuiColor4ubVertex3fSUN(GLuint rc, GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y, GLfloat z);</para>
        /// </summary>
        public static void glReplacementCodeuiColor4ubVertex3fSUN(uint rc, byte r, byte g, byte b, byte a, float x, float y, float z) {
            var _F = _GetProc<GLNativeDelegate.FNglReplacementCodeuiColor4ubVertex3fSUN>("glReplacementCodeuiColor4ubVertex3fSUN");
            _F(rc, r, g, b, a, x, y, z);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_SUN_vertex</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glReplacementCodeuiColor4ubVertex3fvSUN(const GLuint * rc, const GLubyte * c, const GLfloat * v);</para>
        /// </summary>
        public unsafe static void glReplacementCodeuiColor4ubVertex3fvSUN(uint* rc, byte* c, float* v) {
            var _F = _GetProc<GLNativeDelegate.FNglReplacementCodeuiColor4ubVertex3fvSUN>("glReplacementCodeuiColor4ubVertex3fvSUN");
            _F(rc, c, v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_SUN_vertex</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glReplacementCodeuiColor3fVertex3fSUN(GLuint rc, GLfloat r, GLfloat g, GLfloat b, GLfloat x, GLfloat y, GLfloat z);</para>
        /// </summary>
        public static void glReplacementCodeuiColor3fVertex3fSUN(uint rc, float r, float g, float b, float x, float y, float z) {
            var _F = _GetProc<GLNativeDelegate.FNglReplacementCodeuiColor3fVertex3fSUN>("glReplacementCodeuiColor3fVertex3fSUN");
            _F(rc, r, g, b, x, y, z);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_SUN_vertex</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glReplacementCodeuiColor3fVertex3fvSUN(const GLuint * rc, const GLfloat * c, const GLfloat * v);</para>
        /// </summary>
        public unsafe static void glReplacementCodeuiColor3fVertex3fvSUN(uint* rc, float* c, float* v) {
            var _F = _GetProc<GLNativeDelegate.FNglReplacementCodeuiColor3fVertex3fvSUN>("glReplacementCodeuiColor3fVertex3fvSUN");
            _F(rc, c, v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_SUN_vertex</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glReplacementCodeuiNormal3fVertex3fSUN(GLuint rc, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z);</para>
        /// </summary>
        public static void glReplacementCodeuiNormal3fVertex3fSUN(uint rc, float nx, float ny, float nz, float x, float y, float z) {
            var _F = _GetProc<GLNativeDelegate.FNglReplacementCodeuiNormal3fVertex3fSUN>("glReplacementCodeuiNormal3fVertex3fSUN");
            _F(rc, nx, ny, nz, x, y, z);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_SUN_vertex</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glReplacementCodeuiNormal3fVertex3fvSUN(const GLuint * rc, const GLfloat * n, const GLfloat * v);</para>
        /// </summary>
        public unsafe static void glReplacementCodeuiNormal3fVertex3fvSUN(uint* rc, float* n, float* v) {
            var _F = _GetProc<GLNativeDelegate.FNglReplacementCodeuiNormal3fVertex3fvSUN>("glReplacementCodeuiNormal3fVertex3fvSUN");
            _F(rc, n, v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_SUN_vertex</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glReplacementCodeuiColor4fNormal3fVertex3fSUN(GLuint rc, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z);</para>
        /// </summary>
        public static void glReplacementCodeuiColor4fNormal3fVertex3fSUN(uint rc, float r, float g, float b, float a, float nx, float ny, float nz, float x, float y, float z) {
            var _F = _GetProc<GLNativeDelegate.FNglReplacementCodeuiColor4fNormal3fVertex3fSUN>("glReplacementCodeuiColor4fNormal3fVertex3fSUN");
            _F(rc, r, g, b, a, nx, ny, nz, x, y, z);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_SUN_vertex</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glReplacementCodeuiColor4fNormal3fVertex3fvSUN(const GLuint * rc, const GLfloat * c, const GLfloat * n, const GLfloat * v);</para>
        /// </summary>
        public unsafe static void glReplacementCodeuiColor4fNormal3fVertex3fvSUN(uint* rc, float* c, float* n, float* v) {
            var _F = _GetProc<GLNativeDelegate.FNglReplacementCodeuiColor4fNormal3fVertex3fvSUN>("glReplacementCodeuiColor4fNormal3fVertex3fvSUN");
            _F(rc, c, n, v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_SUN_vertex</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glReplacementCodeuiTexCoord2fVertex3fSUN(GLuint rc, GLfloat s, GLfloat t, GLfloat x, GLfloat y, GLfloat z);</para>
        /// </summary>
        public static void glReplacementCodeuiTexCoord2fVertex3fSUN(uint rc, float s, float t, float x, float y, float z) {
            var _F = _GetProc<GLNativeDelegate.FNglReplacementCodeuiTexCoord2fVertex3fSUN>("glReplacementCodeuiTexCoord2fVertex3fSUN");
            _F(rc, s, t, x, y, z);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_SUN_vertex</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glReplacementCodeuiTexCoord2fVertex3fvSUN(const GLuint * rc, const GLfloat * tc, const GLfloat * v);</para>
        /// </summary>
        public unsafe static void glReplacementCodeuiTexCoord2fVertex3fvSUN(uint* rc, float* tc, float* v) {
            var _F = _GetProc<GLNativeDelegate.FNglReplacementCodeuiTexCoord2fVertex3fvSUN>("glReplacementCodeuiTexCoord2fVertex3fvSUN");
            _F(rc, tc, v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_SUN_vertex</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN(GLuint rc, GLfloat s, GLfloat t, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z);</para>
        /// </summary>
        public static void glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN(uint rc, float s, float t, float nx, float ny, float nz, float x, float y, float z) {
            var _F = _GetProc<GLNativeDelegate.FNglReplacementCodeuiTexCoord2fNormal3fVertex3fSUN>("glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN");
            _F(rc, s, t, nx, ny, nz, x, y, z);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_SUN_vertex</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(const GLuint * rc, const GLfloat * tc, const GLfloat * n, const GLfloat * v);</para>
        /// </summary>
        public unsafe static void glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(uint* rc, float* tc, float* n, float* v) {
            var _F = _GetProc<GLNativeDelegate.FNglReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN>("glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN");
            _F(rc, tc, n, v);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_SUN_vertex</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN(GLuint rc, GLfloat s, GLfloat t, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z);</para>
        /// </summary>
        public static void glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN(uint rc, float s, float t, float r, float g, float b, float a, float nx, float ny, float nz, float x, float y, float z) {
            var _F = _GetProc<GLNativeDelegate.FNglReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN>("glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN");
            _F(rc, s, t, r, g, b, a, nx, ny, nz, x, y, z);
        }
        /// <summary>
        /// <para>Require:</para> <para>GL_SUN_vertex</para>
        /// Supported: <para>gl</para>
        /// Original: <para>void glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(const GLuint * rc, const GLfloat * tc, const GLfloat * c, const GLfloat * n, const GLfloat * v);</para>
        /// </summary>
        public unsafe static void glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(uint* rc, float* tc, float* c, float* n, float* v) {
            var _F = _GetProc<GLNativeDelegate.FNglReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN>("glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN");
            _F(rc, tc, c, n, v);
        }

        #endregion GL_SUN_vertex

    }
}
